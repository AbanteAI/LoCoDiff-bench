<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actual Output: packages/tldraw/src/lib/canvas/TldrawSelectionForeground.tsx - Claude Opus 4.1</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        .empty-content-notice {
            background-color: #f8f8f8;
            border: 1px dashed #ccc;
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            color: #666;
        }
        
        .empty-content-notice p:first-child {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .info-message {
            background-color: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            color: #0366d6;
        }
        
        .info-message p:first-child {
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Actual Output: packages/tldraw/src/lib/canvas/TldrawSelectionForeground.tsx</h1>
        <h2>Model: Claude Opus 4.1</h2>
        <p><a href="../../../cases/anthropic_claude-opus-4.1/tldraw_packages_tldraw_src_lib_canvas_TldrawSelectionForeground.tsx.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        
        <section>
            <h2>Raw Model Response</h2>
            
            <pre><code class="language-plaintext">Looking at this git history, I can trace through the changes to reconstruct the current state of the file `packages/tldraw/src/lib/canvas/TldrawSelectionForeground.tsx`.

The file was created in commit `b7d9c868` and has undergone numerous changes. The most recent changes include:

1. Adding `role="button"` attributes to various elements for accessibility (commit `a53f0a3d`)
2. Support for expandSelectionOutlinePx returning a Box (commit `48cd187b`)
3. Menu logic centralization (commit `9d6b5916`)
4. Various other improvements and fixes

Let me reconstruct the final state:

```tsx
import {
	Box,
	RotateCorner,
	TLEmbedShape,
	TLSelectionForegroundProps,
	TLTextShape,
	getCursor,
	tlenv,
	toDomPrecision,
	track,
	useEditor,
	useSelectionEvents,
	useTransform,
	useValue,
} from '@tldraw/editor'
import classNames from 'classnames'
import { useRef } from 'react'
import { useReadonly } from '../ui/hooks/useReadonly'
import { TldrawCropHandles } from './TldrawCropHandles'

/** @public */
export const TldrawSelectionForeground = track(function TldrawSelectionForeground({
	bounds,
	rotation,
}: TLSelectionForegroundProps) {
	const editor = useEditor()
	const rSvg = useRef<SVGSVGElement>(null)

	const isReadonlyMode = useReadonly()
	const topEvents = useSelectionEvents('top')
	const rightEvents = useSelectionEvents('right')
	const bottomEvents = useSelectionEvents('bottom')
	const leftEvents = useSelectionEvents('left')
	const topLeftEvents = useSelectionEvents('top_left')
	const topRightEvents = useSelectionEvents('top_right')
	const bottomRightEvents = useSelectionEvents('bottom_right')
	const bottomLeftEvents = useSelectionEvents('bottom_left')

	const isDefaultCursor = editor.getInstanceState().cursor.type === 'default'
	const isCoarsePointer = editor.getInstanceState().isCoarsePointer

	const onlyShape = editor.getOnlySelectedShape()
	const isLockedShape = onlyShape && editor.isShapeOrAncestorLocked(onlyShape)

	// if all shapes have an expandBy for the selection outline, we can expand by the l
	const expandOutlineBy = onlyShape
		? editor.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape)
		: 0

	const expandedBounds =
		expandOutlineBy instanceof Box
			? bounds.clone().expand(expandOutlineBy).zeroFix()
			: bounds.clone().expandBy(expandOutlineBy).zeroFix()

	useTransform(rSvg, bounds?.x, bounds?.y, 1, editor.getSelectionRotation(), {
		x: expandedBounds.x - bounds.x,
		y: expandedBounds.y - bounds.y,
	})

	if (onlyShape && editor.isShapeHidden(onlyShape)) return null

	const zoom = editor.getZoomLevel()
	const isChangingStyle = editor.getInstanceState().isChangingStyle

	const width = expandedBounds.width
	const height = expandedBounds.height

	const size = 8 / zoom
	const isTinyX = width < size * 2
	const isTinyY = height < size * 2

	const isSmallX = width < size * 4
	const isSmallY = height < size * 4
	const isSmallCropX = width < size * 5
	const isSmallCropY = height < size * 5

	const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1
	const targetSize = (6 / zoom) * mobileHandleMultiplier

	const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75)
	const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75)

	const showSelectionBounds =
		(onlyShape ? !editor.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) &&
		!isChangingStyle

	let shouldDisplayBox =
		(showSelectionBounds &&
			editor.isInAny(
				'select.idle',
				'select.brushing',
				'select.scribble_brushing',
				'select.pointing_canvas',
				'select.pointing_selection',
				'select.pointing_shape',
				'select.crop.idle',
				'select.crop.pointing_crop',
				'select.crop.pointing_crop_handle',
				'select.pointing_resize_handle'
			)) ||
		(showSelectionBounds &&
			editor.isIn('select.resizing') &&
			onlyShape &&
			editor.isShapeOfType<TLTextShape>(onlyShape, 'text'))

	if (onlyShape && shouldDisplayBox) {
		if (tlenv.isFirefox && editor.isShapeOfType<TLEmbedShape>(onlyShape, 'embed')) {
			shouldDisplayBox = false
		}
	}

	const showCropHandles =
		editor.isInAny(
			'select.crop.idle',
			'select.crop.pointing_crop',
			'select.crop.pointing_crop_handle'
		) &&
		!isChangingStyle &&
		!isReadonlyMode

	const shouldDisplayControls =
		editor.isInAny(
			'select.idle',
			'select.pointing_selection',
			'select.pointing_shape',
			'select.crop.idle'
		) &&
		!isChangingStyle &&
		!isReadonlyMode

	const showCornerRotateHandles =
		!isCoarsePointer &&
		!(isTinyX || isTinyY) &&
		(shouldDisplayControls || showCropHandles) &&
		(onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) &&
		!isLockedShape

	const showMobileRotateHandle =
		isCoarsePointer &&
		(!isSmallX || !isSmallY) &&
		(shouldDisplayControls || showCropHandles) &&
		(onlyShape ? !editor.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true) &&
		!isLockedShape

	const showResizeHandles =
		shouldDisplayControls &&
		(onlyShape
			? editor.getShapeUtil(onlyShape).canResize(onlyShape) &&
				!editor.getShapeUtil(onlyShape).hideResizeHandles(onlyShape)
			: true) &&
		!showCropHandles &&
		!isLockedShape

	const hideAlternateCornerHandles = isTinyX || isTinyY
	const showOnlyOneHandle = isTinyX && isTinyY
	const hideAlternateCropHandles = isSmallCropX || isSmallCropY

	const showHandles = showResizeHandles || showCropHandles
	const hideRotateCornerHandles = !showCornerRotateHandles
	const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle
	const hideTopLeftCorner = !shouldDisplayControls || !showHandles
	const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles
	const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles
	const hideBottomRightCorner =
		!shouldDisplayControls || !showHandles || (showOnlyOneHandle && !showCropHandles)

	// If we're showing crop handles, then show the edges too.
	// If we're showing resize handles, then show the edges only
	// if we're not hiding them for some other reason.
	let hideVerticalEdgeTargets = true
	// The same logic above applies here, except another nuance is that
	// we enable resizing for text on mobile (coarse).
	let hideHorizontalEdgeTargets = true

	if (showCropHandles) {
		hideVerticalEdgeTargets = hideAlternateCropHandles
		hideHorizontalEdgeTargets = hideAlternateCropHandles
	} else if (showResizeHandles) {
		hideVerticalEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || isCoarsePointer
		const isMobileAndTextShape = isCoarsePointer && onlyShape && onlyShape.type === 'text'
		hideHorizontalEdgeTargets = hideVerticalEdgeTargets && !isMobileAndTextShape
	}

	const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3)
	const showTextResizeHandles =
		shouldDisplayControls &&
		isCoarsePointer &&
		onlyShape &&
		editor.isShapeOfType<TLTextShape>(onlyShape, 'text') &&
		textHandleHeight * zoom >= 4

	return (
		<svg className="tl-overlays__item tl-selection__fg" data-testid="selection-foreground">
			<g ref={rSvg}>
				{shouldDisplayBox && (
					<rect
						className="tl-selection__fg__outline"
						width={toDomPrecision(width)}
						height={toDomPrecision(height)}
					/>
				)}
				<RotateCornerHandle
					data-testid="selection.rotate.top-left"
					cx={0}
					cy={0}
					targetSize={targetSize}
					corner="top_left_rotate"
					cursor={isDefaultCursor ? getCursor('nwse-rotate', rotation) : undefined}
					isHidden={hideRotateCornerHandles}
				/>
				<RotateCornerHandle
					data-testid="selection.rotate.top-right"
					cx={width + targetSize * 3}
					cy={0}
					targetSize={targetSize}
					corner="top_right_rotate"
					cursor={isDefaultCursor ? getCursor('nesw-rotate', rotation) : undefined}
					isHidden={hideRotateCornerHandles}
				/>
				<RotateCornerHandle
					data-testid="selection.rotate.bottom-left"
					cx={0}
					cy={height + targetSize * 3}
					targetSize={targetSize}
					corner="bottom_left_rotate"
					cursor={isDefaultCursor ? getCursor('swne-rotate', rotation) : undefined}
					isHidden={hideRotateCornerHandles}
				/>
				<RotateCornerHandle
					data-testid="selection.rotate.bottom-right"
					cx={width + targetSize * 3}
					cy={height + targetSize * 3}
					targetSize={targetSize}
					corner="bottom_right_rotate"
					cursor={isDefaultCursor ? getCursor('senw-rotate', rotation) : undefined}
					isHidden={hideRotateCornerHandles}
				/>
				<MobileRotateHandle
					data-testid="selection.rotate.mobile"
					cx={isSmallX ? -targetSize * 1.5 : width / 2}
					cy={isSmallX ? height / 2 : -targetSize * 1.5}
					size={size}
					isHidden={hideMobileRotateHandle}
				/>
				{/* Targets */}
				<rect
					className={classNames('tl-transparent', {
						'tl-hidden': hideVerticalEdgeTargets,
					})}
					data-testid="selection.resize.top"
					role="button"
					aria-label="top target"
					pointerEvents="all"
					x={0}
					y={toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY))}
					width={toDomPrecision(width)}
					height={toDomPrecision(Math.max(1, targetSizeY * 2))}
					style={isDefaultCursor ? { cursor: getCursor('ns-resize', rotation) } : undefined}
					{...topEvents}
				/>
				<rect
					className={classNames('tl-transparent', {
						'tl-hidden': hideHorizontalEdgeTargets,
					})}
					data-testid="selection.resize.right"
					role="button"
					aria-label="right target"
					pointerEvents="all"
					x={toDomPrecision(width - (isSmallX ? 0 : targetSizeX))}
					y={0}
					height={toDomPrecision(height)}
					width={toDomPrecision(Math.max(1, targetSizeX * 2))}
					style={isDefaultCursor ? { cursor: getCursor('ew-resize', rotation) } : undefined}
					{...rightEvents}
				/>
				<rect
					className={classNames('tl-transparent', {
						'tl-hidden': hideVerticalEdgeTargets,
					})}
					data-testid="selection.resize.bottom"
					role="button"
					aria-label="bottom target"
					pointerEvents="all"
					x={0}
					y={toDomPrecision(height - (isSmallY ? 0 : targetSizeY))}
					width={toDomPrecision(width)}
					height={toDomPrecision(Math.max(1, targetSizeY * 2))}
					style={isDefaultCursor ? { cursor: getCursor('ns-resize', rotation) } : undefined}
					{...bottomEvents}
				/>
				<rect
					className={classNames('tl-transparent', {
						'tl-hidden': hideHorizontalEdgeTargets,
					})}
					data-testid="selection.resize.left"
					role="button"
					aria-label="left target"
					pointerEvents="all"
					x={toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX))}
					y={0}
					height={toDomPrecision(height)}
					width={toDomPrecision(Math.max(1, targetSizeX * 2))}
					style={isDefaultCursor ? { cursor: getCursor('ew-resize', rotation) } : undefined}
					{...leftEvents}
				/>
				{/* Corner Targets */}
				<rect
					className={classNames('tl-transparent', {
						'tl-hidden':</code></pre>
        </section>
        
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    