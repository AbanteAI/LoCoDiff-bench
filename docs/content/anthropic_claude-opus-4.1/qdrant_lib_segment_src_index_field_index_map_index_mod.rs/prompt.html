<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/index/field_index/map_index/mod.rs - Claude Opus 4.1</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/index/field_index/map_index/mod.rs</h1>
        <h2>Model: Claude Opus 4.1</h2>
        <p><a href="../../../cases/anthropic_claude-opus-4.1/qdrant_lib_segment_src_index_field_index_map_index_mod.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/index/field_index/map_index/mod.rs

commit 9afca039556c1369faaf7b67133cea48015c7721
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Aug 16 15:27:46 2023 +0200

    Map index as a enum (#2446)
    
    * map index trait
    
    * remove trait and move into separate files

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
new file mode 100644
index 000000000..6b4fb3986
--- /dev/null
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -0,0 +1,610 @@
+pub mod mutable_map_index;
+
+use std::fmt::Display;
+use std::hash::Hash;
+use std::str::FromStr;
+use std::sync::Arc;
+
+use itertools::Itertools;
+use mutable_map_index::MutableMapIndex;
+use parking_lot::RwLock;
+use rocksdb::DB;
+use serde_json::Value;
+use smol_str::SmolStr;
+
+use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;
+use crate::common::Flusher;
+use crate::entry::entry_point::{OperationError, OperationResult};
+use crate::index::field_index::stat_tools::number_of_selected_points;
+use crate::index::field_index::{
+    CardinalityEstimation, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition, ValueIndexer,
+};
+use crate::index::query_estimator::combine_should_estimations;
+use crate::telemetry::PayloadIndexTelemetry;
+use crate::types::{
+    AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
+    PayloadKeyType, PointOffsetType, ValueVariants,
+};
+use crate::vector_storage::div_ceil;
+
+pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr> {
+    Mutable(MutableMapIndex<N>),
+}
+
+impl<N: Hash + Eq + Clone + Display + FromStr> MapIndex<N> {
+    pub fn new(db: Arc<RwLock<DB>>, field_name: &str) -> Self {
+        MapIndex::Mutable(MutableMapIndex::new(db, field_name))
+    }
+
+    fn get_db_wrapper(&self) -> &DatabaseColumnWrapper {
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper(),
+        }
+    }
+
+    fn load_from_db(&mut self) -> OperationResult<bool> {
+        match self {
+            MapIndex::Mutable(index) => index.load_from_db(),
+        }
+    }
+
+    pub fn get_values(&self, idx: PointOffsetType) -> Option<&[N]> {
+        match self {
+            MapIndex::Mutable(index) => index.get_values(idx),
+        }
+    }
+
+    fn get_indexed_points(&self) -> usize {
+        match self {
+            MapIndex::Mutable(index) => index.get_indexed_points(),
+        }
+    }
+
+    fn get_values_count(&self) -> usize {
+        match self {
+            MapIndex::Mutable(index) => index.get_values_count(),
+        }
+    }
+
+    fn get_unique_values_count(&self) -> usize {
+        match self {
+            MapIndex::Mutable(index) => index.get_unique_values_count(),
+        }
+    }
+
+    fn get_points_with_value_count<Q>(&self, value: &Q) -> Option<usize>
+    where
+        Q: ?Sized,
+        N: std::borrow::Borrow<Q>,
+        Q: Hash + Eq,
+    {
+        match self {
+            MapIndex::Mutable(index) => index.get_points_with_value_count(value),
+        }
+    }
+
+    fn get_iterator<Q>(&self, value: &Q) -> Box<dyn Iterator<Item = PointOffsetType> + '_>
+    where
+        Q: ?Sized,
+        N: std::borrow::Borrow<Q>,
+        Q: Hash + Eq,
+    {
+        match self {
+            MapIndex::Mutable(index) => index.get_iterator(value),
+        }
+    }
+
+    fn get_values_iterator(&self) -> Box<dyn Iterator<Item = &N> + '_> {
+        match self {
+            MapIndex::Mutable(index) => index.get_values_iterator(),
+        }
+    }
+
+    pub fn storage_cf_name(field: &str) -> String {
+        format!("{field}_map")
+    }
+
+    pub fn recreate(&self) -> OperationResult<()> {
+        self.get_db_wrapper().recreate_column_family()
+    }
+
+    fn flusher(&self) -> Flusher {
+        self.get_db_wrapper().flusher()
+    }
+
+    fn match_cardinality<Q>(&self, value: &Q) -> CardinalityEstimation
+    where
+        Q: ?Sized,
+        N: std::borrow::Borrow<Q>,
+        Q: Hash + Eq,
+    {
+        let values_count = self.get_points_with_value_count(value).unwrap_or(0);
+
+        CardinalityEstimation::exact(values_count)
+    }
+
+    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {
+        PayloadIndexTelemetry {
+            field_name: None,
+            points_count: self.get_indexed_points(),
+            points_values_count: self.get_values_count(),
+            histogram_bucket_size: None,
+        }
+    }
+
+    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {
+        format!("{value}/{idx}")
+    }
+
+    pub fn decode_db_record(s: &str) -> OperationResult<(N, PointOffsetType)> {
+        const DECODE_ERR: &str = "Index db parsing error: wrong data format";
+        let separator_pos = s
+            .rfind('/')
+            .ok_or_else(|| OperationError::service_error(DECODE_ERR))?;
+        if separator_pos == s.len() - 1 {
+            return Err(OperationError::service_error(DECODE_ERR));
+        }
+        let value_str = &s[..separator_pos];
+        let value =
+            N::from_str(value_str).map_err(|_| OperationError::service_error(DECODE_ERR))?;
+        let idx_str = &s[separator_pos + 1..];
+        let idx = PointOffsetType::from_str(idx_str)
+            .map_err(|_| OperationError::service_error(DECODE_ERR))?;
+        Ok((value, idx))
+    }
+
+    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
+        self.get_values(point_id).map(|x| x.len()).unwrap_or(0)
+    }
+
+    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
+        self.get_values(point_id)
+            .map(|x| x.is_empty())
+            .unwrap_or(true)
+    }
+
+    /// Estimates cardinality for `except` clause
+    ///
+    /// # Arguments
+    ///
+    /// * 'excluded' - values, which are not considered as matching
+    ///
+    /// # Returns
+    ///
+    /// * `CardinalityEstimation` - estimation of cardinality
+    fn except_cardinality<Q, I>(&self, excluded: impl Iterator<Item = I>) -> CardinalityEstimation
+    where
+        I: std::borrow::Borrow<Q>,
+        Q: ?Sized,
+        N: std::borrow::Borrow<Q>,
+        Q: Hash + Eq,
+    {
+        // Minimal case: we exclude as many points as possible.
+        // In this case, excluded points do not have any other values except excluded ones.
+        // So the first step - we estimate how many other points is needed to fit unused values.
+
+        // Example:
+        // Values: 20, 20
+        // Unique values: 5
+        // Total points: 100
+        // Total values: 110
+        // total_excluded_value_count = 40
+        // non_excluded_values_count = 110 - 40 = 70
+        // max_values_per_point = 5 - 2 = 3
+        // min_not_excluded_by_values = 70 / 3 = 24
+        // min = max(24, 100 - 40) = 60
+        // exp = ...
+        // max = min(20, 70) = 20
+
+        // Values: 60, 60
+        // Unique values: 5
+        // Total points: 100
+        // Total values: 200
+        // total_excluded_value_count = 120
+        // non_excluded_values_count = 200 - 120 = 80
+        // max_values_per_point = 5 - 2 = 3
+        // min_not_excluded_by_values = 80 / 3 = 27
+        // min = max(27, 100 - 120) = 27
+        // exp = ...
+        // max = min(60, 80) = 60
+
+        // Values: 60, 60, 60
+        // Unique values: 5
+        // Total points: 100
+        // Total values: 200
+        // total_excluded_value_count = 180
+        // non_excluded_values_count = 200 - 180 = 20
+        // max_values_per_point = 5 - 3 = 2
+        // min_not_excluded_by_values = 20 / 2 = 10
+        // min = max(10, 100 - 180) = 10
+        // exp = ...
+        // max = min(60, 20) = 20
+
+        let excluded_value_counts: Vec<_> = excluded
+            .map(|val| self.get_points_with_value_count(val.borrow()).unwrap_or(0))
+            .collect();
+        let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
+
+        debug_assert!(total_excluded_value_count <= self.get_values_count());
+
+        let non_excluded_values_count = self
+            .get_values_count()
+            .saturating_sub(total_excluded_value_count);
+        let max_values_per_point = self
+            .get_unique_values_count()
+            .saturating_sub(excluded_value_counts.len());
+
+        if max_values_per_point == 0 {
+            // All points are excluded, so we can't select any point
+            debug_assert_eq!(non_excluded_values_count, 0);
+            return CardinalityEstimation::exact(0);
+        }
+
+        // Minimal amount of points, required to fit all unused values.
+        // Cardinality can't be less than this value.
+        let min_not_excluded_by_values = div_ceil(non_excluded_values_count, max_values_per_point);
+
+        let min = min_not_excluded_by_values.max(
+            self.get_indexed_points()
+                .saturating_sub(total_excluded_value_count),
+        );
+
+        // Maximum scenario: selected points overlap as much as possible.
+        // From one side, all excluded values should be assigned to the same point
+        // => we can take the value with the maximum amount of points.
+        // From another side, all other values should be enough to fill all other points.
+
+        let max_excluded_value_count = excluded_value_counts.iter().max().copied().unwrap_or(0);
+
+        let max = self
+            .get_indexed_points()
+            .saturating_sub(max_excluded_value_count)
+            .min(non_excluded_values_count);
+
+        // Expected case: we assume that all points are filled equally.
+        // So we can estimate the probability of the point to have non-excluded value.
+        let exp = number_of_selected_points(self.get_indexed_points(), non_excluded_values_count)
+            .max(min)
+            .min(max);
+
+        CardinalityEstimation {
+            primary_clauses: vec![],
+            min,
+            exp,
+            max,
+        }
+    }
+
+    fn except_iterator<'a, Q>(
+        &'a self,
+        excluded: &'a [Q],
+    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
+    where
+        Q: PartialEq<N>,
+    {
+        Box::new(
+            self.get_values_iterator()
+                .filter(|key| !excluded.iter().any(|e| e.eq(*key)))
+                .flat_map(|key| self.get_iterator(key))
+                .unique(),
+        )
+    }
+}
+
+impl PayloadFieldIndex for MapIndex<SmolStr> {
+    fn count_indexed_points(&self) -> usize {
+        self.get_indexed_points()
+    }
+
+    fn load(&mut self) -> OperationResult<bool> {
+        self.load_from_db()
+    }
+
+    fn clear(self) -> OperationResult<()> {
+        self.get_db_wrapper().recreate_column_family()
+    }
+
+    fn flusher(&self) -> Flusher {
+        MapIndex::flusher(self)
+    }
+
+    fn filter<'a>(
+        &'a self,
+        condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        match &condition.r#match {
+            Some(Match::Value(MatchValue {
+                value: ValueVariants::Keyword(keyword),
+            })) => Some(self.get_iterator(keyword.as_str())),
+            Some(Match::Any(MatchAny {
+                any: AnyVariants::Keywords(keywords),
+            })) => Some(Box::new(
+                keywords
+                    .iter()
+                    .flat_map(|keyword| self.get_iterator(keyword.as_str()))
+                    .unique(),
+            )),
+            Some(Match::Except(MatchExcept {
+                except: AnyVariants::Keywords(keywords),
+            })) => Some(self.except_iterator(keywords)),
+            _ => None,
+        }
+    }
+
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+        match &condition.r#match {
+            Some(Match::Value(MatchValue {
+                value: ValueVariants::Keyword(keyword),
+            })) => {
+                let mut estimation = self.match_cardinality(keyword.as_str());
+                estimation
+                    .primary_clauses
+                    .push(PrimaryCondition::Condition(condition.clone()));
+                Some(estimation)
+            }
+            Some(Match::Any(MatchAny {
+                any: AnyVariants::Keywords(keywords),
+            })) => {
+                let estimations = keywords
+                    .iter()
+                    .map(|keyword| self.match_cardinality(keyword.as_str()))
+                    .collect::<Vec<_>>();
+                Some(combine_should_estimations(
+                    &estimations,
+                    self.get_indexed_points(),
+                ))
+            }
+            Some(Match::Except(MatchExcept {
+                except: AnyVariants::Keywords(keywords),
+            })) => Some(self.except_cardinality::<str, &str>(keywords.iter().map(|k| k.as_str()))),
+            _ => None,
+        }
+    }
+
+    fn payload_blocks(
+        &self,
+        threshold: usize,
+        key: PayloadKeyType,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+        Box::new(
+            self.get_values_iterator()
+                .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
+                .filter(move |(_value, count)| *count > threshold)
+                .map(move |(value, count)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(key.clone(), value.to_owned().into()),
+                    cardinality: count,
+                }),
+        )
+    }
+}
+
+impl PayloadFieldIndex for MapIndex<IntPayloadType> {
+    fn count_indexed_points(&self) -> usize {
+        self.get_indexed_points()
+    }
+
+    fn load(&mut self) -> OperationResult<bool> {
+        self.load_from_db()
+    }
+
+    fn clear(self) -> OperationResult<()> {
+        self.get_db_wrapper().recreate_column_family()
+    }
+
+    fn flusher(&self) -> Flusher {
+        MapIndex::flusher(self)
+    }
+
+    fn filter<'a>(
+        &'a self,
+        condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        match &condition.r#match {
+            Some(Match::Value(MatchValue {
+                value: ValueVariants::Integer(integer),
+            })) => Some(self.get_iterator(integer)),
+            Some(Match::Any(MatchAny {
+                any: AnyVariants::Integers(integers),
+            })) => Some(Box::new(
+                integers
+                    .iter()
+                    .flat_map(|integer| self.get_iterator(integer))
+                    .unique(),
+            )),
+            Some(Match::Except(MatchExcept {
+                except: AnyVariants::Integers(integers),
+            })) => Some(self.except_iterator(integers)),
+            _ => None,
+        }
+    }
+
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+        match &condition.r#match {
+            Some(Match::Value(MatchValue {
+                value: ValueVariants::Integer(integer),
+            })) => {
+                let mut estimation = self.match_cardinality(integer);
+                estimation
+                    .primary_clauses
+                    .push(PrimaryCondition::Condition(condition.clone()));
+                Some(estimation)
+            }
+            Some(Match::Any(MatchAny {
+                any: AnyVariants::Integers(integers),
+            })) => {
+                let estimations = integers
+                    .iter()
+                    .map(|integer| self.match_cardinality(integer))
+                    .collect::<Vec<_>>();
+                Some(combine_should_estimations(
+                    &estimations,
+                    self.get_indexed_points(),
+                ))
+            }
+            Some(Match::Except(MatchExcept {
+                except: AnyVariants::Integers(integers),
+            })) => Some(
+                self.except_cardinality::<IntPayloadType, IntPayloadType>(integers.iter().cloned()),
+            ),
+            _ => None,
+        }
+    }
+
+    fn payload_blocks(
+        &self,
+        threshold: usize,
+        key: PayloadKeyType,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+        Box::new(
+            self.get_values_iterator()
+                .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
+                .filter(move |(_value, count)| *count >= threshold)
+                .map(move |(value, count)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(key.clone(), value.to_owned().into()),
+                    cardinality: count,
+                }),
+        )
+    }
+}
+
+impl ValueIndexer<String> for MapIndex<SmolStr> {
+    fn add_many(&mut self, id: PointOffsetType, values: Vec<String>) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+        }
+    }
+
+    fn get_value(&self, value: &Value) -> Option<String> {
+        if let Value::String(keyword) = value {
+            return Some(keyword.to_owned());
+        }
+        None
+    }
+
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.remove_point(id),
+        }
+    }
+}
+
+impl ValueIndexer<IntPayloadType> for MapIndex<IntPayloadType> {
+    fn add_many(
+        &mut self,
+        id: PointOffsetType,
+        values: Vec<IntPayloadType>,
+    ) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+        }
+    }
+
+    fn get_value(&self, value: &Value) -> Option<IntPayloadType> {
+        if let Value::Number(num) = value {
+            return num.as_i64();
+        }
+        None
+    }
+
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.remove_point(id),
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use std::collections::HashSet;
+    use std::fmt::Debug;
+    use std::iter::FromIterator;
+    use std::path::Path;
+
+    use tempfile::Builder;
+
+    use super::*;
+    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;
+
+    const FIELD_NAME: &str = "test";
+
+    fn save_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug>(
+        data: &[Vec<N>],
+        path: &Path,
+    ) {
+        let mut index = MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+        index.recreate().unwrap();
+        for (idx, values) in data.iter().enumerate() {
+            match &mut index {
+                MapIndex::Mutable(index) => index
+                    .add_many_to_map(idx as PointOffsetType, values.clone())
+                    .unwrap(),
+            }
+        }
+        index.flusher()().unwrap();
+    }
+
+    fn load_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug>(
+        data: &[Vec<N>],
+        path: &Path,
+    ) {
+        let mut index = MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+        index.load_from_db().unwrap();
+        for (idx, values) in data.iter().enumerate() {
+            let index_values: HashSet<N> = HashSet::from_iter(
+                index
+                    .get_values(idx as PointOffsetType)
+                    .unwrap()
+                    .iter()
+                    .cloned(),
+            );
+            let check_values: HashSet<N> = HashSet::from_iter(values.iter().cloned());
+            assert_eq!(index_values, check_values);
+        }
+    }
+
+    #[test]
+    fn test_int_disk_map_index() {
+        let data = vec![
+            vec![1, 2, 3, 4, 5, 6],
+            vec![1, 2, 3, 4, 5, 6],
+            vec![13, 14, 15, 16, 17, 18],
+            vec![19, 20, 21, 22, 23, 24],
+            vec![25],
+        ];
+
+        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index(&data, temp_dir.path());
+        load_map_index(&data, temp_dir.path());
+    }
+
+    #[test]
+    fn test_string_disk_map_index() {
+        let data = vec![
+            vec![
+                String::from("AABB"),
+                String::from("UUFF"),
+                String::from("IIBB"),
+            ],
+            vec![
+                String::from("PPMM"),
+                String::from("QQXX"),
+                String::from("YYBB"),
+            ],
+            vec![
+                String::from("FFMM"),
+                String::from("IICC"),
+                String::from("IIBB"),
+            ],
+            vec![
+                String::from("AABB"),
+                String::from("UUFF"),
+                String::from("IIBB"),
+            ],
+            vec![String::from("PPGG")],
+        ];
+
+        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index(&data, temp_dir.path());
+        load_map_index(&data, temp_dir.path());
+    }
+}

commit d181ddab0e033c03393ab424e14f9472c77c5d75
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Aug 31 15:20:55 2023 +0200

    Immutable map index (#2453)
    
    * immutable map index
    
    * use (super) instead of (crate)
    
    * more comments
    
    * decompose remove_point
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 6b4fb3986..f72e78260 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -1,3 +1,4 @@
+pub mod immutable_map_index;
 pub mod mutable_map_index;
 
 use std::fmt::Display;
@@ -5,6 +6,7 @@ use std::hash::Hash;
 use std::str::FromStr;
 use std::sync::Arc;
 
+use immutable_map_index::ImmutableMapIndex;
 use itertools::Itertools;
 use mutable_map_index::MutableMapIndex;
 use parking_lot::RwLock;
@@ -29,9 +31,10 @@ use crate::vector_storage::div_ceil;
 
 pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr> {
     Mutable(MutableMapIndex<N>),
+    Immutable(ImmutableMapIndex<N>),
 }
 
-impl<N: Hash + Eq + Clone + Display + FromStr> MapIndex<N> {
+impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
     pub fn new(db: Arc<RwLock<DB>>, field_name: &str) -> Self {
         MapIndex::Mutable(MutableMapIndex::new(db, field_name))
     }
@@ -39,36 +42,42 @@ impl<N: Hash + Eq + Clone + Display + FromStr> MapIndex<N> {
     fn get_db_wrapper(&self) -> &DatabaseColumnWrapper {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper(),
+            MapIndex::Immutable(index) => index.get_db_wrapper(),
         }
     }
 
     fn load_from_db(&mut self) -> OperationResult<bool> {
         match self {
             MapIndex::Mutable(index) => index.load_from_db(),
+            MapIndex::Immutable(index) => index.load_from_db(),
         }
     }
 
     pub fn get_values(&self, idx: PointOffsetType) -> Option<&[N]> {
         match self {
             MapIndex::Mutable(index) => index.get_values(idx),
+            MapIndex::Immutable(index) => index.get_values(idx),
         }
     }
 
     fn get_indexed_points(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_indexed_points(),
+            MapIndex::Immutable(index) => index.get_indexed_points(),
         }
     }
 
     fn get_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_values_count(),
+            MapIndex::Immutable(index) => index.get_values_count(),
         }
     }
 
     fn get_unique_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_unique_values_count(),
+            MapIndex::Immutable(index) => index.get_unique_values_count(),
         }
     }
 
@@ -80,6 +89,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr> MapIndex<N> {
     {
         match self {
             MapIndex::Mutable(index) => index.get_points_with_value_count(value),
+            MapIndex::Immutable(index) => index.get_points_with_value_count(value),
         }
     }
 
@@ -91,12 +101,14 @@ impl<N: Hash + Eq + Clone + Display + FromStr> MapIndex<N> {
     {
         match self {
             MapIndex::Mutable(index) => index.get_iterator(value),
+            MapIndex::Immutable(index) => index.get_iterator(value),
         }
     }
 
     fn get_values_iterator(&self) -> Box<dyn Iterator<Item = &N> + '_> {
         match self {
             MapIndex::Mutable(index) => index.get_values_iterator(),
+            MapIndex::Immutable(index) => index.get_values_iterator(),
         }
     }
 
@@ -471,6 +483,9 @@ impl ValueIndexer<String> for MapIndex<SmolStr> {
     fn add_many(&mut self, id: PointOffsetType, values: Vec<String>) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Immutable(_) => Err(OperationError::service_error(
+                "Can't add values to immutable map index",
+            )),
         }
     }
 
@@ -484,6 +499,7 @@ impl ValueIndexer<String> for MapIndex<SmolStr> {
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.remove_point(id),
+            MapIndex::Immutable(index) => index.remove_point(id),
         }
     }
 }
@@ -496,6 +512,9 @@ impl ValueIndexer<IntPayloadType> for MapIndex<IntPayloadType> {
     ) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Immutable(_) => Err(OperationError::service_error(
+                "Can't add values to immutable map index",
+            )),
         }
     }
 
@@ -509,6 +528,7 @@ impl ValueIndexer<IntPayloadType> for MapIndex<IntPayloadType> {
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.remove_point(id),
+            MapIndex::Immutable(index) => index.remove_point(id),
         }
     }
 }
@@ -527,7 +547,7 @@ mod tests {
 
     const FIELD_NAME: &str = "test";
 
-    fn save_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug>(
+    fn save_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug + Default>(
         data: &[Vec<N>],
         path: &Path,
     ) {
@@ -538,12 +558,13 @@ mod tests {
                 MapIndex::Mutable(index) => index
                     .add_many_to_map(idx as PointOffsetType, values.clone())
                     .unwrap(),
+                _ => panic!("Wrong index type"),
             }
         }
         index.flusher()().unwrap();
     }
 
-    fn load_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug>(
+    fn load_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug + Default>(
         data: &[Vec<N>],
         path: &Path,
     ) {

commit 8ef51525235655112ab08adac644455d86a3d608
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Sep 4 15:24:52 2023 +0200

    immutable map index integration (#2524)
    
    * immutable map index integration
    
    * remove wipe
    
    * fix unit tests
    
    * get appendable flag from config
    
    * minor refactoring
    
    * fix chunked mmap appendable flag
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index f72e78260..b69095f08 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -35,8 +35,12 @@ pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr> {
 }
 
 impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
-    pub fn new(db: Arc<RwLock<DB>>, field_name: &str) -> Self {
-        MapIndex::Mutable(MutableMapIndex::new(db, field_name))
+    pub fn new(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
+        if is_appendable {
+            MapIndex::Mutable(MutableMapIndex::new(db, field_name))
+        } else {
+            MapIndex::Immutable(ImmutableMapIndex::new(db, field_name))
+        }
     }
 
     fn get_db_wrapper(&self) -> &DatabaseColumnWrapper {
@@ -551,7 +555,8 @@ mod tests {
         data: &[Vec<N>],
         path: &Path,
     ) {
-        let mut index = MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+        let mut index =
+            MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
         index.recreate().unwrap();
         for (idx, values) in data.iter().enumerate() {
             match &mut index {
@@ -568,7 +573,8 @@ mod tests {
         data: &[Vec<N>],
         path: &Path,
     ) {
-        let mut index = MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+        let mut index =
+            MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
             let index_values: HashSet<N> = HashSet::from_iter(

commit 1566d1cdc2eee6745d1f8944b46e9ddb8344807d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 21 19:42:03 2023 +0200

    Fix cardinality estimation for Any matcher (#2710)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index b69095f08..10bc6c97c 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -363,7 +363,14 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             })) => {
                 let estimations = keywords
                     .iter()
-                    .map(|keyword| self.match_cardinality(keyword.as_str()))
+                    .map(|keyword| {
+                        let keyword_condition = FieldCondition::new_match(
+                            condition.key.clone(),
+                            keyword.to_owned().into(),
+                        );
+                        self.match_cardinality(keyword.as_str())
+                            .with_primary_clause(PrimaryCondition::Condition(keyword_condition))
+                    })
                     .collect::<Vec<_>>();
                 Some(combine_should_estimations(
                     &estimations,
@@ -450,7 +457,14 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             })) => {
                 let estimations = integers
                     .iter()
-                    .map(|integer| self.match_cardinality(integer))
+                    .map(|integer| {
+                        let integer_condition = FieldCondition::new_match(
+                            condition.key.clone(),
+                            integer.to_owned().into(),
+                        );
+                        self.match_cardinality(integer)
+                            .with_primary_clause(PrimaryCondition::Condition(integer_condition))
+                    })
                     .collect::<Vec<_>>();
                 Some(combine_should_estimations(
                     &estimations,

commit 1611deaf034a8ec219b4aab80abe31200bb8fc15
Author: Eugene Tolbakov <ev.tolbakov@gmail.com>
Date:   Mon Sep 25 14:10:45 2023 +0100

    Refactor: replace expect with ServiceError, remove repetive code (#2701)
    
    * Refactor: replace expect with ServiceError, remove repetive code
    
    * chore: remove unnecessary code
    
    * chore: apply cr suggestions
    
    * chore: apply clippy recommendations
    
    * Improve constructing errors
    
    * Improve test assertions
    
    * fix: replace max_regions assertion with operation error
    
    * fix: adjust according to CR
    
    * chore: replace Option with OperationResult for estimate_cardinality
    
    * chore: replace Option with OperationResult for filter
    
    * Better handling of transforming none into an error
    
    * Replace for loop with simple iterator, simply other iterator
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 10bc6c97c..f1b8c5428 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -327,14 +327,14 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
-            })) => Some(self.get_iterator(keyword.as_str())),
+            })) => Ok(self.get_iterator(keyword.as_str())),
             Some(Match::Any(MatchAny {
                 any: AnyVariants::Keywords(keywords),
-            })) => Some(Box::new(
+            })) => Ok(Box::new(
                 keywords
                     .iter()
                     .flat_map(|keyword| self.get_iterator(keyword.as_str()))
@@ -342,12 +342,15 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             )),
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Some(self.except_iterator(keywords)),
-            _ => None,
+            })) => Ok(self.except_iterator(keywords)),
+            _ => Err(OperationError::service_error("failed to filter")),
         }
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+    ) -> OperationResult<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
@@ -356,7 +359,7 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
                 estimation
                     .primary_clauses
                     .push(PrimaryCondition::Condition(condition.clone()));
-                Some(estimation)
+                Ok(estimation)
             }
             Some(Match::Any(MatchAny {
                 any: AnyVariants::Keywords(keywords),
@@ -372,15 +375,17 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
                             .with_primary_clause(PrimaryCondition::Condition(keyword_condition))
                     })
                     .collect::<Vec<_>>();
-                Some(combine_should_estimations(
+                Ok(combine_should_estimations(
                     &estimations,
                     self.get_indexed_points(),
                 ))
             }
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Some(self.except_cardinality::<str, &str>(keywords.iter().map(|k| k.as_str()))),
-            _ => None,
+            })) => Ok(self.except_cardinality::<str, &str>(keywords.iter().map(|k| k.as_str()))),
+            _ => Err(OperationError::service_error(
+                "failed to estimate cardinality",
+            )),
         }
     }
 
@@ -421,14 +426,14 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
-            })) => Some(self.get_iterator(integer)),
+            })) => Ok(self.get_iterator(integer)),
             Some(Match::Any(MatchAny {
                 any: AnyVariants::Integers(integers),
-            })) => Some(Box::new(
+            })) => Ok(Box::new(
                 integers
                     .iter()
                     .flat_map(|integer| self.get_iterator(integer))
@@ -436,12 +441,15 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             )),
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => Some(self.except_iterator(integers)),
-            _ => None,
+            })) => Ok(self.except_iterator(integers)),
+            _ => Err(OperationError::service_error("failed to filter")),
         }
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+    ) -> OperationResult<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
@@ -450,7 +458,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 estimation
                     .primary_clauses
                     .push(PrimaryCondition::Condition(condition.clone()));
-                Some(estimation)
+                Ok(estimation)
             }
             Some(Match::Any(MatchAny {
                 any: AnyVariants::Integers(integers),
@@ -466,17 +474,20 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                             .with_primary_clause(PrimaryCondition::Condition(integer_condition))
                     })
                     .collect::<Vec<_>>();
-                Some(combine_should_estimations(
+                Ok(combine_should_estimations(
                     &estimations,
                     self.get_indexed_points(),
                 ))
             }
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => Some(
-                self.except_cardinality::<IntPayloadType, IntPayloadType>(integers.iter().cloned()),
-            ),
-            _ => None,
+            })) => {
+                Ok(self
+                    .except_cardinality::<IntPayloadType, IntPayloadType>(integers.iter().cloned()))
+            }
+            _ => Err(OperationError::service_error(
+                "failed to estimate cardinality",
+            )),
         }
     }
 

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index f1b8c5428..925b1dd3a 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -6,6 +6,7 @@ use std::hash::Hash;
 use std::str::FromStr;
 use std::sync::Arc;
 
+use common::types::PointOffsetType;
 use immutable_map_index::ImmutableMapIndex;
 use itertools::Itertools;
 use mutable_map_index::MutableMapIndex;
@@ -25,7 +26,7 @@ use crate::index::query_estimator::combine_should_estimations;
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
-    PayloadKeyType, PointOffsetType, ValueVariants,
+    PayloadKeyType, ValueVariants,
 };
 use crate::vector_storage::div_ceil;
 

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 925b1dd3a..df886c87d 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -15,9 +15,9 @@ use rocksdb::DB;
 use serde_json::Value;
 use smol_str::SmolStr;
 
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;
 use crate::common::Flusher;
-use crate::entry::entry_point::{OperationError, OperationResult};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
     CardinalityEstimation, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition, ValueIndexer,

commit 0b581a5429c3835b0af3cfde2a2eb6c864be6c0c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Oct 12 15:45:32 2023 +0200

    optimize usage of the match-any filter in case it is empty (#2803)
    
    * optimize usage of the match-any filter in case it is empty
    
    * fix outdated tests

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index df886c87d..f07e8484b 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -333,14 +333,23 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
             })) => Ok(self.get_iterator(keyword.as_str())),
-            Some(Match::Any(MatchAny {
-                any: AnyVariants::Keywords(keywords),
-            })) => Ok(Box::new(
-                keywords
-                    .iter()
-                    .flat_map(|keyword| self.get_iterator(keyword.as_str()))
-                    .unique(),
-            )),
+            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+                AnyVariants::Keywords(keywords) => Ok(Box::new(
+                    keywords
+                        .iter()
+                        .flat_map(|keyword| self.get_iterator(keyword.as_str()))
+                        .unique(),
+                )),
+                AnyVariants::Integers(integers) => {
+                    if integers.is_empty() {
+                        Ok(Box::new(vec![].into_iter()))
+                    } else {
+                        Err(OperationError::service_error(
+                            "failed to estimate cardinality",
+                        ))
+                    }
+                }
+            },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
             })) => Ok(self.except_iterator(keywords)),
@@ -362,25 +371,31 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
                     .push(PrimaryCondition::Condition(condition.clone()));
                 Ok(estimation)
             }
-            Some(Match::Any(MatchAny {
-                any: AnyVariants::Keywords(keywords),
-            })) => {
-                let estimations = keywords
-                    .iter()
-                    .map(|keyword| {
-                        let keyword_condition = FieldCondition::new_match(
-                            condition.key.clone(),
-                            keyword.to_owned().into(),
-                        );
-                        self.match_cardinality(keyword.as_str())
-                            .with_primary_clause(PrimaryCondition::Condition(keyword_condition))
-                    })
-                    .collect::<Vec<_>>();
-                Ok(combine_should_estimations(
-                    &estimations,
-                    self.get_indexed_points(),
-                ))
-            }
+            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+                AnyVariants::Keywords(keywords) => {
+                    let estimations = keywords
+                        .iter()
+                        .map(|keyword| self.match_cardinality(keyword.as_str()))
+                        .collect::<Vec<_>>();
+                    let estimation = if estimations.is_empty() {
+                        CardinalityEstimation::exact(0)
+                    } else {
+                        combine_should_estimations(&estimations, self.get_indexed_points())
+                    };
+                    Ok(estimation
+                        .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                }
+                AnyVariants::Integers(integers) => {
+                    if integers.is_empty() {
+                        Ok(CardinalityEstimation::exact(0)
+                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                    } else {
+                        Err(OperationError::service_error(
+                            "failed to estimate cardinality",
+                        ))
+                    }
+                }
+            },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
             })) => Ok(self.except_cardinality::<str, &str>(keywords.iter().map(|k| k.as_str()))),
@@ -432,14 +447,23 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
             })) => Ok(self.get_iterator(integer)),
-            Some(Match::Any(MatchAny {
-                any: AnyVariants::Integers(integers),
-            })) => Ok(Box::new(
-                integers
-                    .iter()
-                    .flat_map(|integer| self.get_iterator(integer))
-                    .unique(),
-            )),
+            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+                AnyVariants::Keywords(keywords) => {
+                    if keywords.is_empty() {
+                        Ok(Box::new(vec![].into_iter()))
+                    } else {
+                        Err(OperationError::service_error(
+                            "failed to estimate cardinality",
+                        ))
+                    }
+                }
+                AnyVariants::Integers(integers) => Ok(Box::new(
+                    integers
+                        .iter()
+                        .flat_map(|integer| self.get_iterator(integer))
+                        .unique(),
+                )),
+            },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
             })) => Ok(self.except_iterator(integers)),
@@ -461,25 +485,31 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                     .push(PrimaryCondition::Condition(condition.clone()));
                 Ok(estimation)
             }
-            Some(Match::Any(MatchAny {
-                any: AnyVariants::Integers(integers),
-            })) => {
-                let estimations = integers
-                    .iter()
-                    .map(|integer| {
-                        let integer_condition = FieldCondition::new_match(
-                            condition.key.clone(),
-                            integer.to_owned().into(),
-                        );
-                        self.match_cardinality(integer)
-                            .with_primary_clause(PrimaryCondition::Condition(integer_condition))
-                    })
-                    .collect::<Vec<_>>();
-                Ok(combine_should_estimations(
-                    &estimations,
-                    self.get_indexed_points(),
-                ))
-            }
+            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
+                AnyVariants::Keywords(keywords) => {
+                    if keywords.is_empty() {
+                        Ok(CardinalityEstimation::exact(0)
+                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                    } else {
+                        Err(OperationError::service_error(
+                            "failed to estimate cardinality",
+                        ))
+                    }
+                }
+                AnyVariants::Integers(integers) => {
+                    let estimations = integers
+                        .iter()
+                        .map(|integer| self.match_cardinality(integer))
+                        .collect::<Vec<_>>();
+                    let estimation = if estimations.is_empty() {
+                        CardinalityEstimation::exact(0)
+                    } else {
+                        combine_should_estimations(&estimations, self.get_indexed_points())
+                    };
+                    Ok(estimation
+                        .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                }
+            },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
             })) => {

commit 6534ea9af9fc51ab94c83af81c65dcb0b429827b
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Nov 17 12:55:25 2023 +0100

    Use stabilized `div_ceil` from from `std` (#2770)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index f07e8484b..8bd3b1a53 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -28,7 +28,6 @@ use crate::types::{
     AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
     PayloadKeyType, ValueVariants,
 };
-use crate::vector_storage::div_ceil;
 
 pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr> {
     Mutable(MutableMapIndex<N>),
@@ -259,7 +258,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
 
         // Minimal amount of points, required to fit all unused values.
         // Cardinality can't be less than this value.
-        let min_not_excluded_by_values = div_ceil(non_excluded_values_count, max_values_per_point);
+        let min_not_excluded_by_values = non_excluded_values_count.div_ceil(max_values_per_point);
 
         let min = min_not_excluded_by_values.max(
             self.get_indexed_points()

commit 5ebfdb05b35c1441e5f743b754f513daf7acda6b
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Nov 24 16:18:34 2023 +0100

    Default `max_values_per_point` to zero, add tests (#3039)
    
    * Prevent another division by zero in geo index
    
    * Set default `max_values_per_point` to zero
    
    * Extend empty cardinality test
    
    * Add unit tests for empty index types with cardinality
    
    * Shortcut cardinality estimation, zero if no values per point
    
    * Use const functions for cardinality type
    
    * Remove redundant checked division, we do a rhs zero check above

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 8bd3b1a53..9904b8c1c 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -627,7 +627,7 @@ mod tests {
     fn load_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug + Default>(
         data: &[Vec<N>],
         path: &Path,
-    ) {
+    ) -> MapIndex<N> {
         let mut index =
             MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
         index.load_from_db().unwrap();
@@ -642,6 +642,8 @@ mod tests {
             let check_values: HashSet<N> = HashSet::from_iter(values.iter().cloned());
             assert_eq!(index_values, check_values);
         }
+
+        index
     }
 
     #[test]
@@ -656,7 +658,12 @@ mod tests {
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
         save_map_index(&data, temp_dir.path());
-        load_map_index(&data, temp_dir.path());
+        let index = load_map_index(&data, temp_dir.path());
+
+        // Ensure cardinality is non zero
+        assert!(!index
+            .except_cardinality::<_, &_>(vec![].into_iter())
+            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
     #[test]
@@ -687,6 +694,25 @@ mod tests {
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
         save_map_index(&data, temp_dir.path());
-        load_map_index(&data, temp_dir.path());
+        let index = load_map_index(&data, temp_dir.path());
+
+        // Ensure cardinality is non zero
+        assert!(!index
+            .except_cardinality::<str, &str>(vec![].into_iter())
+            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
+    }
+
+    #[test]
+    fn test_empty_index() {
+        let data: Vec<Vec<String>> = vec![];
+
+        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+        save_map_index(&data, temp_dir.path());
+        let index = load_map_index(&data, temp_dir.path());
+
+        // Ensure cardinality is zero
+        assert!(index
+            .except_cardinality::<str, &str>(vec![].into_iter())
+            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 }

commit f6b081d96774f52bfa94788cf97dff6a297d1caf
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Jan 25 17:56:16 2024 +0100

    Filed index point-to-values as separate struct (#3296)
    
    * filed index point to values as separate struct
    
    * numeric index
    
    * return removed values
    
    * add comments
    
    * codespell
    
    * add unit test
    
    * fix counters
    
    * review remarks

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 9904b8c1c..48c69c8af 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -29,7 +29,7 @@ use crate::types::{
     PayloadKeyType, ValueVariants,
 };
 
-pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr> {
+pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr + Default> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
 }

commit 3ee5aac011321766efab793c6b1e6a66088b0d36
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:50:58 2024 +0100

    Optimize MatchAny (#3525)
    
    * add benches for large MatchAny
    
    * use HashSet for MatchAny
    
    * use fnv hash
    
    * make fnv workspace level dependency; apply clippy
    
    * remove SmolStr from Keyword; Improve performance
    
    * add bench for small number of keywords
    
    * fix openapi
    
    * fix performance issue
    
    * apply integer optimization; create magic number constant

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 48c69c8af..d35b8467d 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -2,12 +2,13 @@ pub mod immutable_map_index;
 pub mod mutable_map_index;
 
 use std::fmt::Display;
-use std::hash::Hash;
+use std::hash::{BuildHasher, Hash};
 use std::str::FromStr;
 use std::sync::Arc;
 
 use common::types::PointOffsetType;
 use immutable_map_index::ImmutableMapIndex;
+use indexmap::IndexSet;
 use itertools::Itertools;
 use mutable_map_index::MutableMapIndex;
 use parking_lot::RwLock;
@@ -291,17 +292,20 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    fn except_iterator<'a, Q>(
+    fn except_set<'a, A, K, S>(
         &'a self,
-        excluded: &'a [Q],
+        excluded: &'a IndexSet<K, A>,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
     where
-        Q: PartialEq<N>,
+        A: BuildHasher,
+        K: std::borrow::Borrow<S> + Hash + Eq,
+        N: std::borrow::Borrow<S>,
+        S: ?Sized + Hash + Eq,
     {
         Box::new(
             self.get_values_iterator()
-                .filter(|key| !excluded.iter().any(|e| e.eq(*key)))
-                .flat_map(|key| self.get_iterator(key))
+                .filter(|key| !excluded.contains((*key).borrow()))
+                .flat_map(|key| self.get_iterator(key.borrow()))
                 .unique(),
         )
     }
@@ -351,7 +355,7 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Ok(self.except_iterator(keywords)),
+            })) => Ok(self.except_set::<_, _, str>(keywords)),
             _ => Err(OperationError::service_error("failed to filter")),
         }
     }
@@ -465,7 +469,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => Ok(self.except_iterator(integers)),
+            })) => Ok(self.except_set(integers)),
             _ => Err(OperationError::service_error("failed to filter")),
         }
     }

commit d0a5349f788494d9c88e1f6b33cd740ef6103ec4
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Jul 11 14:48:11 2024 +0200

    Ensure payload is deleted on flush only (#4653)
    
    * Use DatabaseColumnScheduledDeleteWrapper to make sure we only delete payload and indexed payload when flushed at the right time
    
    * Remove double clone
    
    * In on disk payload storage, don't return payload if delete is pending
    
    * hide deleted_pending_persistence inside the abstraction
    
    * Add RocksDB column operator filtering pending deletes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index d35b8467d..1eee4bd6e 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -1,6 +1,3 @@
-pub mod immutable_map_index;
-pub mod mutable_map_index;
-
 use std::fmt::Display;
 use std::hash::{BuildHasher, Hash};
 use std::str::FromStr;
@@ -17,7 +14,7 @@ use serde_json::Value;
 use smol_str::SmolStr;
 
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;
+use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::Flusher;
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
@@ -30,6 +27,9 @@ use crate::types::{
     PayloadKeyType, ValueVariants,
 };
 
+pub mod immutable_map_index;
+pub mod mutable_map_index;
+
 pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr + Default> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
@@ -44,7 +44,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    fn get_db_wrapper(&self) -> &DatabaseColumnWrapper {
+    fn get_db_wrapper(&self) -> &DatabaseColumnScheduledDeleteWrapper {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper(),
             MapIndex::Immutable(index) => index.get_db_wrapper(),

commit c7d25b2096ae9c51d38ecd4476fe7581fbc1eb8d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Jul 12 11:37:20 2024 +0200

    Field index values as iterator instead of slice (#4644)
    
    * field index values as iterator instead of slice
    
    * Use consistent assertions
    
    * fix wrong values_count update
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 1eee4bd6e..cc995f68a 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -58,10 +58,28 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    pub fn get_values(&self, idx: PointOffsetType) -> Option<&[N]> {
+    pub fn get_values<NRef>(
+        &self,
+        idx: PointOffsetType,
+    ) -> Option<Box<dyn Iterator<Item = &NRef> + '_>>
+    where
+        N: std::borrow::Borrow<NRef>,
+        NRef: ?Sized,
+    {
         match self {
-            MapIndex::Mutable(index) => index.get_values(idx),
-            MapIndex::Immutable(index) => index.get_values(idx),
+            MapIndex::Mutable(index) => Some(Box::new(
+                index.get_values(idx)?.map(std::borrow::Borrow::borrow),
+            )),
+            MapIndex::Immutable(index) => Some(Box::new(
+                index.get_values(idx)?.map(std::borrow::Borrow::borrow),
+            )),
+        }
+    }
+
+    pub fn values_count(&self, idx: PointOffsetType) -> usize {
+        match self {
+            MapIndex::Mutable(index) => index.values_count(idx).unwrap_or_default(),
+            MapIndex::Immutable(index) => index.values_count(idx).unwrap_or_default(),
         }
     }
 
@@ -170,14 +188,8 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         Ok((value, idx))
     }
 
-    pub fn values_count(&self, point_id: PointOffsetType) -> usize {
-        self.get_values(point_id).map(|x| x.len()).unwrap_or(0)
-    }
-
-    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {
-        self.get_values(point_id)
-            .map(|x| x.is_empty())
-            .unwrap_or(true)
+    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {
+        self.values_count(idx) == 0
     }
 
     /// Estimates cardinality for `except` clause
@@ -638,9 +650,8 @@ mod tests {
         for (idx, values) in data.iter().enumerate() {
             let index_values: HashSet<N> = HashSet::from_iter(
                 index
-                    .get_values(idx as PointOffsetType)
+                    .get_values::<N>(idx as PointOffsetType)
                     .unwrap()
-                    .iter()
                     .cloned(),
             );
             let check_values: HashSet<N> = HashSet::from_iter(values.iter().cloned());

commit a0f9cafb56f778a9981474380f9c8a158ea183bd
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Jul 15 17:08:16 2024 +0200

    Remove dyn iterator from field condition checker (#4665)
    
    * remove dyn iterator from field condition checker
    
    * are you happy clippy
    
    * review remarks

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index cc995f68a..9662d1938 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -58,6 +58,26 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
+    pub fn check_values_any<NRef>(
+        &self,
+        idx: PointOffsetType,
+        check_fn: impl Fn(&NRef) -> bool,
+    ) -> bool
+    where
+        N: std::borrow::Borrow<NRef>,
+        NRef: ?Sized,
+    {
+        match self {
+            MapIndex::Mutable(index) => {
+                index.check_values_any(idx, |value| check_fn(value.borrow()))
+            }
+            MapIndex::Immutable(index) => {
+                index.check_values_any(idx, |value| check_fn(value.borrow()))
+            }
+        }
+    }
+
+    #[cfg(test)]
     pub fn get_values<NRef>(
         &self,
         idx: PointOffsetType,

commit 65964f86b07afd695243984f32f97c9604f50d00
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jul 16 13:36:50 2024 +0000

    Introduce MapIndexKey (#4676)
    
    * Introduce MapIndexKey
    
    * Review fixes
    
    * Remove unnecessary .borrow() call

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 9662d1938..7621a70f9 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -1,18 +1,20 @@
-use std::fmt::Display;
+use std::borrow::Borrow;
+use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::str::FromStr;
 use std::sync::Arc;
 
+use common::mmap_hashmap::Key;
 use common::types::PointOffsetType;
-use immutable_map_index::ImmutableMapIndex;
 use indexmap::IndexSet;
 use itertools::Itertools;
-use mutable_map_index::MutableMapIndex;
 use parking_lot::RwLock;
 use rocksdb::DB;
 use serde_json::Value;
 use smol_str::SmolStr;
 
+use self::immutable_map_index::ImmutableMapIndex;
+use self::mutable_map_index::MutableMapIndex;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::Flusher;
@@ -30,12 +32,34 @@ use crate::types::{
 pub mod immutable_map_index;
 pub mod mutable_map_index;
 
-pub enum MapIndex<N: Hash + Eq + Clone + Display + FromStr + Default> {
+pub trait MapIndexKey: Key + Eq + Display + Debug {
+    type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
+
+    fn to_owned(&self) -> Self::Owned;
+}
+
+impl MapIndexKey for str {
+    type Owned = SmolStr;
+
+    fn to_owned(&self) -> Self::Owned {
+        SmolStr::from(self)
+    }
+}
+
+impl MapIndexKey for IntPayloadType {
+    type Owned = IntPayloadType;
+
+    fn to_owned(&self) -> Self::Owned {
+        *self
+    }
+}
+
+pub enum MapIndex<N: MapIndexKey + ?Sized> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
 }
 
-impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
+impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     pub fn new(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
         if is_appendable {
             MapIndex::Mutable(MutableMapIndex::new(db, field_name))
@@ -58,41 +82,18 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    pub fn check_values_any<NRef>(
-        &self,
-        idx: PointOffsetType,
-        check_fn: impl Fn(&NRef) -> bool,
-    ) -> bool
-    where
-        N: std::borrow::Borrow<NRef>,
-        NRef: ?Sized,
-    {
+    pub fn check_values_any(&self, idx: PointOffsetType, check_fn: impl Fn(&N) -> bool) -> bool {
         match self {
-            MapIndex::Mutable(index) => {
-                index.check_values_any(idx, |value| check_fn(value.borrow()))
-            }
-            MapIndex::Immutable(index) => {
-                index.check_values_any(idx, |value| check_fn(value.borrow()))
-            }
+            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
         }
     }
 
     #[cfg(test)]
-    pub fn get_values<NRef>(
-        &self,
-        idx: PointOffsetType,
-    ) -> Option<Box<dyn Iterator<Item = &NRef> + '_>>
-    where
-        N: std::borrow::Borrow<NRef>,
-        NRef: ?Sized,
-    {
+    pub fn get_values(&self, idx: PointOffsetType) -> Option<Box<dyn Iterator<Item = &N> + '_>> {
         match self {
-            MapIndex::Mutable(index) => Some(Box::new(
-                index.get_values(idx)?.map(std::borrow::Borrow::borrow),
-            )),
-            MapIndex::Immutable(index) => Some(Box::new(
-                index.get_values(idx)?.map(std::borrow::Borrow::borrow),
-            )),
+            MapIndex::Mutable(index) => Some(Box::new(index.get_values(idx)?)),
+            MapIndex::Immutable(index) => Some(Box::new(index.get_values(idx)?)),
         }
     }
 
@@ -124,24 +125,14 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    fn get_points_with_value_count<Q>(&self, value: &Q) -> Option<usize>
-    where
-        Q: ?Sized,
-        N: std::borrow::Borrow<Q>,
-        Q: Hash + Eq,
-    {
+    fn get_points_with_value_count(&self, value: &N) -> Option<usize> {
         match self {
             MapIndex::Mutable(index) => index.get_points_with_value_count(value),
             MapIndex::Immutable(index) => index.get_points_with_value_count(value),
         }
     }
 
-    fn get_iterator<Q>(&self, value: &Q) -> Box<dyn Iterator<Item = PointOffsetType> + '_>
-    where
-        Q: ?Sized,
-        N: std::borrow::Borrow<Q>,
-        Q: Hash + Eq,
-    {
+    fn get_iterator(&self, value: &N) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
         match self {
             MapIndex::Mutable(index) => index.get_iterator(value),
             MapIndex::Immutable(index) => index.get_iterator(value),
@@ -167,12 +158,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         self.get_db_wrapper().flusher()
     }
 
-    fn match_cardinality<Q>(&self, value: &Q) -> CardinalityEstimation
-    where
-        Q: ?Sized,
-        N: std::borrow::Borrow<Q>,
-        Q: Hash + Eq,
-    {
+    fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
         let values_count = self.get_points_with_value_count(value).unwrap_or(0);
 
         CardinalityEstimation::exact(values_count)
@@ -191,7 +177,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         format!("{value}/{idx}")
     }
 
-    pub fn decode_db_record(s: &str) -> OperationResult<(N, PointOffsetType)> {
+    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {
         const DECODE_ERR: &str = "Index db parsing error: wrong data format";
         let separator_pos = s
             .rfind('/')
@@ -201,7 +187,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
         let value_str = &s[..separator_pos];
         let value =
-            N::from_str(value_str).map_err(|_| OperationError::service_error(DECODE_ERR))?;
+            N::Owned::from_str(value_str).map_err(|_| OperationError::service_error(DECODE_ERR))?;
         let idx_str = &s[separator_pos + 1..];
         let idx = PointOffsetType::from_str(idx_str)
             .map_err(|_| OperationError::service_error(DECODE_ERR))?;
@@ -221,13 +207,10 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
     /// # Returns
     ///
     /// * `CardinalityEstimation` - estimation of cardinality
-    fn except_cardinality<Q, I>(&self, excluded: impl Iterator<Item = I>) -> CardinalityEstimation
-    where
-        I: std::borrow::Borrow<Q>,
-        Q: ?Sized,
-        N: std::borrow::Borrow<Q>,
-        Q: Hash + Eq,
-    {
+    fn except_cardinality<'a>(
+        &'a self,
+        excluded: impl Iterator<Item = &'a N>,
+    ) -> CardinalityEstimation {
         // Minimal case: we exclude as many points as possible.
         // In this case, excluded points do not have any other values except excluded ones.
         // So the first step - we estimate how many other points is needed to fit unused values.
@@ -324,15 +307,13 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
         }
     }
 
-    fn except_set<'a, A, K, S>(
+    fn except_set<'a, K, A>(
         &'a self,
         excluded: &'a IndexSet<K, A>,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
     where
         A: BuildHasher,
-        K: std::borrow::Borrow<S> + Hash + Eq,
-        N: std::borrow::Borrow<S>,
-        S: ?Sized + Hash + Eq,
+        K: Borrow<N> + Hash + Eq,
     {
         Box::new(
             self.get_values_iterator()
@@ -343,7 +324,7 @@ impl<N: Hash + Eq + Clone + Display + FromStr + Default> MapIndex<N> {
     }
 }
 
-impl PayloadFieldIndex for MapIndex<SmolStr> {
+impl PayloadFieldIndex for MapIndex<str> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
     }
@@ -387,7 +368,7 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Ok(self.except_set::<_, _, str>(keywords)),
+            })) => Ok(self.except_set(keywords)),
             _ => Err(OperationError::service_error("failed to filter")),
         }
     }
@@ -433,7 +414,7 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Ok(self.except_cardinality::<str, &str>(keywords.iter().map(|k| k.as_str()))),
+            })) => Ok(self.except_cardinality(keywords.iter().map(|k| k.as_str()))),
             _ => Err(OperationError::service_error(
                 "failed to estimate cardinality",
             )),
@@ -450,7 +431,7 @@ impl PayloadFieldIndex for MapIndex<SmolStr> {
                 .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
                 .filter(move |(_value, count)| *count > threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
-                    condition: FieldCondition::new_match(key.clone(), value.to_owned().into()),
+                    condition: FieldCondition::new_match(key.clone(), value.to_string().into()),
                     cardinality: count,
                 }),
         )
@@ -547,10 +528,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => {
-                Ok(self
-                    .except_cardinality::<IntPayloadType, IntPayloadType>(integers.iter().cloned()))
-            }
+            })) => Ok(self.except_cardinality(integers.iter())),
             _ => Err(OperationError::service_error(
                 "failed to estimate cardinality",
             )),
@@ -567,14 +545,14 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
                 .filter(move |(_value, count)| *count >= threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
-                    condition: FieldCondition::new_match(key.clone(), value.to_owned().into()),
+                    condition: FieldCondition::new_match(key.clone(), (*value).into()),
                     cardinality: count,
                 }),
         )
     }
 }
 
-impl ValueIndexer<String> for MapIndex<SmolStr> {
+impl ValueIndexer<String> for MapIndex<str> {
     fn add_many(&mut self, id: PointOffsetType, values: Vec<String>) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values),
@@ -631,7 +609,6 @@ impl ValueIndexer<IntPayloadType> for MapIndex<IntPayloadType> {
 #[cfg(test)]
 mod tests {
     use std::collections::HashSet;
-    use std::fmt::Debug;
     use std::iter::FromIterator;
     use std::path::Path;
 
@@ -642,10 +619,7 @@ mod tests {
 
     const FIELD_NAME: &str = "test";
 
-    fn save_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug + Default>(
-        data: &[Vec<N>],
-        path: &Path,
-    ) {
+    fn save_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path) {
         let mut index =
             MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
         index.recreate().unwrap();
@@ -660,21 +634,14 @@ mod tests {
         index.flusher()().unwrap();
     }
 
-    fn load_map_index<N: Hash + Eq + Clone + Display + FromStr + Debug + Default>(
-        data: &[Vec<N>],
-        path: &Path,
-    ) -> MapIndex<N> {
+    fn load_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path) -> MapIndex<N> {
         let mut index =
             MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
-            let index_values: HashSet<N> = HashSet::from_iter(
-                index
-                    .get_values::<N>(idx as PointOffsetType)
-                    .unwrap()
-                    .cloned(),
-            );
-            let check_values: HashSet<N> = HashSet::from_iter(values.iter().cloned());
+            let index_values: HashSet<&N> =
+                HashSet::from_iter(index.get_values(idx as PointOffsetType).unwrap());
+            let check_values: HashSet<&N> = HashSet::from_iter(values.iter().map(|v| v.borrow()));
             assert_eq!(index_values, check_values);
         }
 
@@ -692,12 +659,12 @@ mod tests {
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index(&data, temp_dir.path());
-        let index = load_map_index(&data, temp_dir.path());
+        save_map_index::<IntPayloadType>(&data, temp_dir.path());
+        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path());
 
         // Ensure cardinality is non zero
         assert!(!index
-            .except_cardinality::<_, &_>(vec![].into_iter())
+            .except_cardinality(vec![].into_iter())
             .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
@@ -705,49 +672,49 @@ mod tests {
     fn test_string_disk_map_index() {
         let data = vec![
             vec![
-                String::from("AABB"),
-                String::from("UUFF"),
-                String::from("IIBB"),
+                SmolStr::from("AABB"),
+                SmolStr::from("UUFF"),
+                SmolStr::from("IIBB"),
             ],
             vec![
-                String::from("PPMM"),
-                String::from("QQXX"),
-                String::from("YYBB"),
+                SmolStr::from("PPMM"),
+                SmolStr::from("QQXX"),
+                SmolStr::from("YYBB"),
             ],
             vec![
-                String::from("FFMM"),
-                String::from("IICC"),
-                String::from("IIBB"),
+                SmolStr::from("FFMM"),
+                SmolStr::from("IICC"),
+                SmolStr::from("IIBB"),
             ],
             vec![
-                String::from("AABB"),
-                String::from("UUFF"),
-                String::from("IIBB"),
+                SmolStr::from("AABB"),
+                SmolStr::from("UUFF"),
+                SmolStr::from("IIBB"),
             ],
-            vec![String::from("PPGG")],
+            vec![SmolStr::from("PPGG")],
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index(&data, temp_dir.path());
-        let index = load_map_index(&data, temp_dir.path());
+        save_map_index::<str>(&data, temp_dir.path());
+        let index = load_map_index::<str>(&data, temp_dir.path());
 
         // Ensure cardinality is non zero
         assert!(!index
-            .except_cardinality::<str, &str>(vec![].into_iter())
+            .except_cardinality(vec![].into_iter())
             .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
     #[test]
     fn test_empty_index() {
-        let data: Vec<Vec<String>> = vec![];
+        let data: Vec<Vec<SmolStr>> = vec![];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index(&data, temp_dir.path());
-        let index = load_map_index(&data, temp_dir.path());
+        save_map_index::<str>(&data, temp_dir.path());
+        let index = load_map_index::<str>(&data, temp_dir.path());
 
         // Ensure cardinality is zero
         assert!(index
-            .except_cardinality::<str, &str>(vec![].into_iter())
+            .except_cardinality(vec![].into_iter())
             .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 }

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 7621a70f9..85c29a768 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -89,7 +89,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    #[cfg(test)]
     pub fn get_values(&self, idx: PointOffsetType) -> Option<Box<dyn Iterator<Item = &N> + '_>> {
         match self {
             MapIndex::Mutable(index) => Some(Box::new(index.get_values(idx)?)),

commit 38a8a01b244c26c18e3efe0eeb449f6e37566d83
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jul 19 12:57:25 2024 +0000

    Make ValueIndexer trait non-generic (#4690)
    
    * Introduce NumericIndexInner
    
    * Make ValueIndexer trait non-generic

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 85c29a768..2ac1782cb 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -551,7 +551,9 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     }
 }
 
-impl ValueIndexer<String> for MapIndex<str> {
+impl ValueIndexer for MapIndex<str> {
+    type ValueType = String;
+
     fn add_many(&mut self, id: PointOffsetType, values: Vec<String>) -> OperationResult<()> {
         match self {
             MapIndex::Mutable(index) => index.add_many_to_map(id, values),
@@ -576,7 +578,9 @@ impl ValueIndexer<String> for MapIndex<str> {
     }
 }
 
-impl ValueIndexer<IntPayloadType> for MapIndex<IntPayloadType> {
+impl ValueIndexer for MapIndex<IntPayloadType> {
+    type ValueType = IntPayloadType;
+
     fn add_many(
         &mut self,
         id: PointOffsetType,

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 2ac1782cb..cbae7e085 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -612,7 +612,6 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
 #[cfg(test)]
 mod tests {
     use std::collections::HashSet;
-    use std::iter::FromIterator;
     use std::path::Path;
 
     use tempfile::Builder;
@@ -643,8 +642,8 @@ mod tests {
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
             let index_values: HashSet<&N> =
-                HashSet::from_iter(index.get_values(idx as PointOffsetType).unwrap());
-            let check_values: HashSet<&N> = HashSet::from_iter(values.iter().map(|v| v.borrow()));
+                index.get_values(idx as PointOffsetType).unwrap().collect();
+            let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
             assert_eq!(index_values, check_values);
         }
 

commit f35f512605437d671bb81eec83a24a6d3509bc13
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 10:19:23 2024 +0000

    Introduce FieldIndexBuilder (#4717)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index cbae7e085..4d0da9148 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -15,6 +15,7 @@ use smol_str::SmolStr;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
+use super::FieldIndexBuilderTrait;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::Flusher;
@@ -68,6 +69,10 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
+        MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))
+    }
+
     fn get_db_wrapper(&self) -> &DatabaseColumnScheduledDeleteWrapper {
         match self {
             MapIndex::Mutable(index) => index.get_db_wrapper(),
@@ -323,6 +328,27 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     }
 }
 
+pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);
+
+impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexBuilder<N>
+where
+    MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+{
+    type FieldIndexType = MapIndex<N>;
+
+    fn init(&mut self) -> OperationResult<()> {
+        self.0.recreate()
+    }
+
+    fn add_point(&mut self, id: PointOffsetType, values: &[&Value]) -> OperationResult<()> {
+        self.0.add_point(id, values)
+    }
+
+    fn finalize(self) -> OperationResult<Self::FieldIndexType> {
+        Ok(self.0)
+    }
+}
+
 impl PayloadFieldIndex for MapIndex<str> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()

commit f77c98899a2771f4f6b178da46b2442f403dea61
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jul 23 13:53:08 2024 +0000

    Drop FieldIndex::recreate() method (#4735)
    
    * Drop FieldIndex::recreate() method
    
    * Make `make_empty()` return `Result`

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 4d0da9148..a6c140f50 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -154,10 +154,6 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         format!("{field}_map")
     }
 
-    pub fn recreate(&self) -> OperationResult<()> {
-        self.get_db_wrapper().recreate_column_family()
-    }
-
     fn flusher(&self) -> Flusher {
         self.get_db_wrapper().flusher()
     }
@@ -337,7 +333,7 @@ where
     type FieldIndexType = MapIndex<N>;
 
     fn init(&mut self) -> OperationResult<()> {
-        self.0.recreate()
+        self.0.get_db_wrapper().recreate_column_family()
     }
 
     fn add_point(&mut self, id: PointOffsetType, values: &[&Value]) -> OperationResult<()> {
@@ -647,10 +643,13 @@ mod tests {
 
     const FIELD_NAME: &str = "test";
 
-    fn save_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path) {
-        let mut index =
-            MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
-        index.recreate().unwrap();
+    fn save_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path)
+    where
+        MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+    {
+        let mut index = MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME)
+            .make_empty()
+            .unwrap();
         for (idx, values) in data.iter().enumerate() {
             match &mut index {
                 MapIndex::Mutable(index) => index

commit 5df4231e2d7ab63c2e3e1931624fb039c1087375
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Jul 24 08:43:00 2024 +0200

    ValueIndexer get_value without self (#4740)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index a6c140f50..14f48d6e3 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -585,7 +585,7 @@ impl ValueIndexer for MapIndex<str> {
         }
     }
 
-    fn get_value(&self, value: &Value) -> Option<String> {
+    fn get_value(value: &Value) -> Option<String> {
         if let Value::String(keyword) = value {
             return Some(keyword.to_owned());
         }
@@ -616,7 +616,7 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
         }
     }
 
-    fn get_value(&self, value: &Value) -> Option<IntPayloadType> {
+    fn get_value(value: &Value) -> Option<IntPayloadType> {
         if let Value::Number(num) = value {
             return num.as_i64();
         }

commit ab714cdfecc3f70f330ecdc0d262b39fe6440be7
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Jul 25 16:05:12 2024 -0400

    Use option in `filter` and `estimate_cardinality` (#4747)
    
    * chore: filter returns option
    
    * chore: make estimate_cardinality return Option
    
    * better comment

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 14f48d6e3..a109e8eba 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -1,6 +1,7 @@
 use std::borrow::Borrow;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
+use std::iter;
 use std::str::FromStr;
 use std::sync::Arc;
 
@@ -365,13 +366,13 @@ impl PayloadFieldIndex for MapIndex<str> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
-            })) => Ok(self.get_iterator(keyword.as_str())),
+            })) => Some(self.get_iterator(keyword.as_str())),
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Keywords(keywords) => Ok(Box::new(
+                AnyVariants::Keywords(keywords) => Some(Box::new(
                     keywords
                         .iter()
                         .flat_map(|keyword| self.get_iterator(keyword.as_str()))
@@ -379,25 +380,20 @@ impl PayloadFieldIndex for MapIndex<str> {
                 )),
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
-                        Ok(Box::new(vec![].into_iter()))
+                        Some(Box::new(iter::empty()))
                     } else {
-                        Err(OperationError::service_error(
-                            "failed to estimate cardinality",
-                        ))
+                        None
                     }
                 }
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Ok(self.except_set(keywords)),
-            _ => Err(OperationError::service_error("failed to filter")),
+            })) => Some(self.except_set(keywords)),
+            _ => None,
         }
     }
 
-    fn estimate_cardinality(
-        &self,
-        condition: &FieldCondition,
-    ) -> OperationResult<CardinalityEstimation> {
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
@@ -406,7 +402,7 @@ impl PayloadFieldIndex for MapIndex<str> {
                 estimation
                     .primary_clauses
                     .push(PrimaryCondition::Condition(condition.clone()));
-                Ok(estimation)
+                Some(estimation)
             }
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Keywords(keywords) => {
@@ -419,26 +415,27 @@ impl PayloadFieldIndex for MapIndex<str> {
                     } else {
                         combine_should_estimations(&estimations, self.get_indexed_points())
                     };
-                    Ok(estimation
-                        .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                    Some(
+                        estimation
+                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                    )
                 }
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
-                        Ok(CardinalityEstimation::exact(0)
-                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                        Some(
+                            CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ),
+                        )
                     } else {
-                        Err(OperationError::service_error(
-                            "failed to estimate cardinality",
-                        ))
+                        None
                     }
                 }
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Keywords(keywords),
-            })) => Ok(self.except_cardinality(keywords.iter().map(|k| k.as_str()))),
-            _ => Err(OperationError::service_error(
-                "failed to estimate cardinality",
-            )),
+            })) => Some(self.except_cardinality(keywords.iter().map(|k| k.as_str()))),
+            _ => None,
         }
     }
 
@@ -479,22 +476,20 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-    ) -> OperationResult<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
-            })) => Ok(self.get_iterator(integer)),
+            })) => Some(self.get_iterator(integer)),
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Keywords(keywords) => {
                     if keywords.is_empty() {
-                        Ok(Box::new(vec![].into_iter()))
+                        Some(Box::new(vec![].into_iter()))
                     } else {
-                        Err(OperationError::service_error(
-                            "failed to estimate cardinality",
-                        ))
+                        None
                     }
                 }
-                AnyVariants::Integers(integers) => Ok(Box::new(
+                AnyVariants::Integers(integers) => Some(Box::new(
                     integers
                         .iter()
                         .flat_map(|integer| self.get_iterator(integer))
@@ -503,15 +498,12 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => Ok(self.except_set(integers)),
-            _ => Err(OperationError::service_error("failed to filter")),
+            })) => Some(self.except_set(integers)),
+            _ => None,
         }
     }
 
-    fn estimate_cardinality(
-        &self,
-        condition: &FieldCondition,
-    ) -> OperationResult<CardinalityEstimation> {
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
@@ -520,17 +512,18 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 estimation
                     .primary_clauses
                     .push(PrimaryCondition::Condition(condition.clone()));
-                Ok(estimation)
+                Some(estimation)
             }
             Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
                 AnyVariants::Keywords(keywords) => {
                     if keywords.is_empty() {
-                        Ok(CardinalityEstimation::exact(0)
-                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                        Some(
+                            CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ),
+                        )
                     } else {
-                        Err(OperationError::service_error(
-                            "failed to estimate cardinality",
-                        ))
+                        None
                     }
                 }
                 AnyVariants::Integers(integers) => {
@@ -543,16 +536,16 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                     } else {
                         combine_should_estimations(&estimations, self.get_indexed_points())
                     };
-                    Ok(estimation
-                        .with_primary_clause(PrimaryCondition::Condition(condition.clone())))
+                    Some(
+                        estimation
+                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                    )
                 }
             },
             Some(Match::Except(MatchExcept {
                 except: AnyVariants::Integers(integers),
-            })) => Ok(self.except_cardinality(integers.iter())),
-            _ => Err(OperationError::service_error(
-                "failed to estimate cardinality",
-            )),
+            })) => Some(self.except_cardinality(integers.iter())),
+            _ => None,
         }
     }
 

commit eb679ff097c79aba3f11b0f0b01d307d2e163d0c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jul 30 13:18:19 2024 -0400

    Facets in segment (#4753)
    
    * faceting in segment
    
    * Add segment integration test
    
    * nits
    
    * count from filtered stream, not value->points map directly
    
    * drop AtomicRef from fn signature
    
    * count only unique values per point
    
    * use entry in hashmap
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index a109e8eba..c41490110 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -34,6 +34,8 @@ use crate::types::{
 pub mod immutable_map_index;
 pub mod mutable_map_index;
 
+pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;
+
 pub trait MapIndexKey: Key + Eq + Display + Debug {
     type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
 
@@ -130,24 +132,38 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_points_with_value_count(&self, value: &N) -> Option<usize> {
+    fn get_count_for_value(&self, value: &N) -> Option<usize> {
         match self {
-            MapIndex::Mutable(index) => index.get_points_with_value_count(value),
-            MapIndex::Immutable(index) => index.get_points_with_value_count(value),
+            MapIndex::Mutable(index) => index.get_count_for_value(value),
+            MapIndex::Immutable(index) => index.get_count_for_value(value),
         }
     }
 
-    fn get_iterator(&self, value: &N) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
+    fn get_iterator(&self, value: &N) -> IdRefIter<'_> {
         match self {
             MapIndex::Mutable(index) => index.get_iterator(value),
             MapIndex::Immutable(index) => index.get_iterator(value),
         }
     }
 
-    fn get_values_iterator(&self) -> Box<dyn Iterator<Item = &N> + '_> {
+    fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
+        match self {
+            MapIndex::Mutable(index) => index.iter_values(),
+            MapIndex::Immutable(index) => index.iter_values(),
+        }
+    }
+
+    pub fn iter_counts_per_value(&self) -> Box<dyn Iterator<Item = (&N, usize)> + '_> {
+        match self {
+            MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),
+            MapIndex::Immutable(index) => Box::new(index.iter_counts_per_value()),
+        }
+    }
+
+    pub fn iter_values_map(&self) -> Box<dyn Iterator<Item = (&N, IdRefIter<'_>)> + '_> {
         match self {
-            MapIndex::Mutable(index) => index.get_values_iterator(),
-            MapIndex::Immutable(index) => index.get_values_iterator(),
+            MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
+            MapIndex::Immutable(index) => Box::new(index.iter_values_map()),
         }
     }
 
@@ -160,7 +176,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     }
 
     fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
-        let values_count = self.get_points_with_value_count(value).unwrap_or(0);
+        let values_count = self.get_count_for_value(value).unwrap_or(0);
 
         CardinalityEstimation::exact(values_count)
     }
@@ -254,7 +270,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         // max = min(60, 20) = 20
 
         let excluded_value_counts: Vec<_> = excluded
-            .map(|val| self.get_points_with_value_count(val.borrow()).unwrap_or(0))
+            .map(|val| self.get_count_for_value(val.borrow()).unwrap_or(0))
             .collect();
         let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
 
@@ -317,9 +333,9 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         K: Borrow<N> + Hash + Eq,
     {
         Box::new(
-            self.get_values_iterator()
+            self.iter_values()
                 .filter(|key| !excluded.contains((*key).borrow()))
-                .flat_map(|key| self.get_iterator(key.borrow()))
+                .flat_map(|key| self.get_iterator(key.borrow()).copied())
                 .unique(),
         )
     }
@@ -370,12 +386,12 @@ impl PayloadFieldIndex for MapIndex<str> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Keyword(keyword),
-            })) => Some(self.get_iterator(keyword.as_str())),
+            })) => Some(Box::new(self.get_iterator(keyword.as_str()).copied())),
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Keywords(keywords) => Some(Box::new(
                     keywords
                         .iter()
-                        .flat_map(|keyword| self.get_iterator(keyword.as_str()))
+                        .flat_map(|keyword| self.get_iterator(keyword.as_str()).copied())
                         .unique(),
                 )),
                 AnyVariants::Integers(integers) => {
@@ -445,8 +461,8 @@ impl PayloadFieldIndex for MapIndex<str> {
         key: PayloadKeyType,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
-            self.get_values_iterator()
-                .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
+            self.iter_values()
+                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
                 .filter(move |(_value, count)| *count > threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
                     condition: FieldCondition::new_match(key.clone(), value.to_string().into()),
@@ -480,7 +496,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
         match &condition.r#match {
             Some(Match::Value(MatchValue {
                 value: ValueVariants::Integer(integer),
-            })) => Some(self.get_iterator(integer)),
+            })) => Some(Box::new(self.get_iterator(integer).copied())),
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Keywords(keywords) => {
                     if keywords.is_empty() {
@@ -492,7 +508,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 AnyVariants::Integers(integers) => Some(Box::new(
                     integers
                         .iter()
-                        .flat_map(|integer| self.get_iterator(integer))
+                        .flat_map(|integer| self.get_iterator(integer).copied())
                         .unique(),
                 )),
             },
@@ -555,8 +571,8 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
         key: PayloadKeyType,
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
-            self.get_values_iterator()
-                .map(|value| (value, self.get_points_with_value_count(value).unwrap_or(0)))
+            self.iter_values()
+                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
                 .filter(move |(_value, count)| *count >= threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
                     condition: FieldCondition::new_match(key.clone(), (*value).into()),

commit a9784f7f60822649d5251ccad533b50e5e29b028
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Aug 2 13:01:19 2024 +0200

    Mmap map index (#4779)
    
    * define mmap map index
    
    add point to values
    
    add mmap hash map
    
    are you happy fmt
    
    use new mmap hashmap methods
    
    build index
    
    saturating_sub
    
    are you happy clippy
    
    fix tests build
    
    * integrate facets for mmap index
    
    * mmap tests
    
    * fix ci
    
    * review remarks
    
    * review remarks

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index c41490110..51e1b4e17 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -2,13 +2,16 @@ use std::borrow::Borrow;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::iter;
+use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::sync::Arc;
 
+use ahash::HashMap;
 use common::mmap_hashmap::Key;
 use common::types::PointOffsetType;
 use indexmap::IndexSet;
 use itertools::Itertools;
+use mmap_map_index::MmapMapIndex;
 use parking_lot::RwLock;
 use rocksdb::DB;
 use serde_json::Value;
@@ -16,9 +19,9 @@ use smol_str::SmolStr;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
+use super::mmap_point_to_values::MmapValue;
 use super::FieldIndexBuilderTrait;
 use crate::common::operation_error::{OperationError, OperationResult};
-use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;
 use crate::common::Flusher;
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
@@ -32,11 +35,12 @@ use crate::types::{
 };
 
 pub mod immutable_map_index;
+pub mod mmap_map_index;
 pub mod mutable_map_index;
 
 pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;
 
-pub trait MapIndexKey: Key + Eq + Display + Debug {
+pub trait MapIndexKey: Key + MmapValue + Eq + Display + Debug {
     type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
 
     fn to_owned(&self) -> Self::Owned;
@@ -61,6 +65,7 @@ impl MapIndexKey for IntPayloadType {
 pub enum MapIndex<N: MapIndexKey + ?Sized> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
+    Mmap(Box<MmapMapIndex<N>>),
 }
 
 impl<N: MapIndexKey + ?Sized> MapIndex<N> {
@@ -72,14 +77,19 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    pub fn new_mmap(path: &Path) -> OperationResult<Self> {
+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path)?)))
+    }
+
     pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
         MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))
     }
 
-    fn get_db_wrapper(&self) -> &DatabaseColumnScheduledDeleteWrapper {
-        match self {
-            MapIndex::Mutable(index) => index.get_db_wrapper(),
-            MapIndex::Immutable(index) => index.get_db_wrapper(),
+    pub fn mmap_builder(path: &Path) -> MapIndexMmapBuilder<N> {
+        MapIndexMmapBuilder {
+            path: path.to_owned(),
+            point_to_values: Default::default(),
+            values_to_points: Default::default(),
         }
     }
 
@@ -87,6 +97,8 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.load_from_db(),
             MapIndex::Immutable(index) => index.load_from_db(),
+            // mmap index is always loaded
+            MapIndex::Mmap(_) => Ok(true),
         }
     }
 
@@ -94,13 +106,22 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
             MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),
         }
     }
 
-    pub fn get_values(&self, idx: PointOffsetType) -> Option<Box<dyn Iterator<Item = &N> + '_>> {
+    pub fn get_values(
+        &self,
+        idx: PointOffsetType,
+    ) -> Option<Box<dyn Iterator<Item = N::Referenced<'_>> + '_>> {
         match self {
-            MapIndex::Mutable(index) => Some(Box::new(index.get_values(idx)?)),
-            MapIndex::Immutable(index) => Some(Box::new(index.get_values(idx)?)),
+            MapIndex::Mutable(index) => Some(Box::new(
+                index.get_values(idx)?.map(|v| N::into_referenced(v)),
+            )),
+            MapIndex::Immutable(index) => Some(Box::new(
+                index.get_values(idx)?.map(|v| N::into_referenced(v)),
+            )),
+            MapIndex::Mmap(index) => Some(Box::new(index.get_values(idx)?)),
         }
     }
 
@@ -108,6 +129,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.values_count(idx).unwrap_or_default(),
             MapIndex::Immutable(index) => index.values_count(idx).unwrap_or_default(),
+            MapIndex::Mmap(index) => index.values_count(idx).unwrap_or_default(),
         }
     }
 
@@ -115,6 +137,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.get_indexed_points(),
             MapIndex::Immutable(index) => index.get_indexed_points(),
+            MapIndex::Mmap(index) => index.get_indexed_points(),
         }
     }
 
@@ -122,6 +145,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.get_values_count(),
             MapIndex::Immutable(index) => index.get_values_count(),
+            MapIndex::Mmap(index) => index.get_values_count(),
         }
     }
 
@@ -129,6 +153,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.get_unique_values_count(),
             MapIndex::Immutable(index) => index.get_unique_values_count(),
+            MapIndex::Mmap(index) => index.get_unique_values_count(),
         }
     }
 
@@ -136,6 +161,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.get_count_for_value(value),
             MapIndex::Immutable(index) => index.get_count_for_value(value),
+            MapIndex::Mmap(index) => index.get_count_for_value(value),
         }
     }
 
@@ -143,6 +169,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.get_iterator(value),
             MapIndex::Immutable(index) => index.get_iterator(value),
+            MapIndex::Mmap(index) => index.get_iterator(value),
         }
     }
 
@@ -150,6 +177,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => index.iter_values(),
             MapIndex::Immutable(index) => index.iter_values(),
+            MapIndex::Mmap(index) => index.iter_values(),
         }
     }
 
@@ -157,6 +185,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),
             MapIndex::Immutable(index) => Box::new(index.iter_counts_per_value()),
+            MapIndex::Mmap(index) => Box::new(index.iter_counts_per_value()),
         }
     }
 
@@ -164,6 +193,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         match self {
             MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
             MapIndex::Immutable(index) => Box::new(index.iter_values_map()),
+            MapIndex::Mmap(index) => Box::new(index.iter_values_map()),
         }
     }
 
@@ -172,7 +202,11 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     }
 
     fn flusher(&self) -> Flusher {
-        self.get_db_wrapper().flusher()
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper().flusher(),
+            MapIndex::Immutable(index) => index.get_db_wrapper().flusher(),
+            MapIndex::Mmap(index) => index.flusher(),
+        }
     }
 
     fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
@@ -215,6 +249,25 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         self.values_count(idx) == 0
     }
 
+    fn clear(self) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Mmap(index) => index.clear(),
+        }
+    }
+
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.remove_point(id),
+            MapIndex::Immutable(index) => index.remove_point(id),
+            MapIndex::Mmap(index) => {
+                index.remove_point(id);
+                Ok(())
+            }
+        }
+    }
+
     /// Estimates cardinality for `except` clause
     ///
     /// # Arguments
@@ -350,7 +403,11 @@ where
     type FieldIndexType = MapIndex<N>;
 
     fn init(&mut self) -> OperationResult<()> {
-        self.0.get_db_wrapper().recreate_column_family()
+        match &mut self.0 {
+            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
+            MapIndex::Immutable(_) => unreachable!(),
+            MapIndex::Mmap(_) => unreachable!(),
+        }
     }
 
     fn add_point(&mut self, id: PointOffsetType, values: &[&Value]) -> OperationResult<()> {
@@ -362,6 +419,47 @@ where
     }
 }
 
+pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {
+    path: PathBuf,
+    point_to_values: Vec<Vec<N::Owned>>,
+    values_to_points: HashMap<N::Owned, Vec<PointOffsetType>>,
+}
+
+impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexMmapBuilder<N>
+where
+    MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+    <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
+{
+    type FieldIndexType = MapIndex<N>;
+
+    fn init(&mut self) -> OperationResult<()> {
+        Ok(())
+    }
+
+    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+        let mut flatten_values: Vec<_> = vec![];
+        for value in payload.iter() {
+            let payload_values = <MapIndex<N> as ValueIndexer>::get_values(value);
+            flatten_values.extend(payload_values);
+        }
+        let flatten_values: Vec<N::Owned> = flatten_values.into_iter().map(Into::into).collect();
+        self.point_to_values.resize_with(id as usize + 1, Vec::new);
+        self.point_to_values[id as usize].extend(flatten_values.clone());
+        for value in flatten_values {
+            self.values_to_points.entry(value).or_default().push(id);
+        }
+        Ok(())
+    }
+
+    fn finalize(self) -> OperationResult<Self::FieldIndexType> {
+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::build(
+            &self.path,
+            self.point_to_values,
+            self.values_to_points,
+        )?)))
+    }
+}
+
 impl PayloadFieldIndex for MapIndex<str> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
@@ -372,7 +470,7 @@ impl PayloadFieldIndex for MapIndex<str> {
     }
 
     fn clear(self) -> OperationResult<()> {
-        self.get_db_wrapper().recreate_column_family()
+        self.clear()
     }
 
     fn flusher(&self) -> Flusher {
@@ -482,7 +580,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     }
 
     fn clear(self) -> OperationResult<()> {
-        self.get_db_wrapper().recreate_column_family()
+        self.clear()
     }
 
     fn flusher(&self) -> Flusher {
@@ -591,6 +689,9 @@ impl ValueIndexer for MapIndex<str> {
             MapIndex::Immutable(_) => Err(OperationError::service_error(
                 "Can't add values to immutable map index",
             )),
+            MapIndex::Mmap(_) => Err(OperationError::service_error(
+                "Can't add values to mmap map index",
+            )),
         }
     }
 
@@ -602,10 +703,7 @@ impl ValueIndexer for MapIndex<str> {
     }
 
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.remove_point(id),
-            MapIndex::Immutable(index) => index.remove_point(id),
-        }
+        self.remove_point(id)
     }
 }
 
@@ -622,6 +720,9 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
             MapIndex::Immutable(_) => Err(OperationError::service_error(
                 "Can't add values to immutable map index",
             )),
+            MapIndex::Mmap(_) => Err(OperationError::service_error(
+                "Can't add values to mmap map index",
+            )),
         }
     }
 
@@ -633,10 +734,7 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
     }
 
     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
-        match self {
-            MapIndex::Mutable(index) => index.remove_point(id),
-            MapIndex::Immutable(index) => index.remove_point(id),
-        }
+        self.remove_point(id)
     }
 }
 
@@ -645,6 +743,7 @@ mod tests {
     use std::collections::HashSet;
     use std::path::Path;
 
+    use rstest::rstest;
     use tempfile::Builder;
 
     use super::*;
@@ -652,31 +751,70 @@ mod tests {
 
     const FIELD_NAME: &str = "test";
 
-    fn save_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path)
-    where
+    #[derive(Clone, Copy)]
+    enum IndexType {
+        Mutable,
+        Immutable,
+        Mmap,
+    }
+
+    fn save_map_index<N>(
+        data: &[Vec<N::Owned>],
+        path: &Path,
+        index_type: IndexType,
+        into_value: impl Fn(&N::Owned) -> Value,
+    ) where
+        N: MapIndexKey + ?Sized,
         MapIndex<N>: PayloadFieldIndex + ValueIndexer,
+        <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
     {
-        let mut index = MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME)
-            .make_empty()
-            .unwrap();
-        for (idx, values) in data.iter().enumerate() {
-            match &mut index {
-                MapIndex::Mutable(index) => index
-                    .add_many_to_map(idx as PointOffsetType, values.clone())
-                    .unwrap(),
-                _ => panic!("Wrong index type"),
+        match index_type {
+            IndexType::Mutable | IndexType::Immutable => {
+                let mut builder =
+                    MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);
+                builder.init().unwrap();
+                for (idx, values) in data.iter().enumerate() {
+                    let values: Vec<Value> = values.iter().map(&into_value).collect();
+                    let values: Vec<_> = values.iter().collect();
+                    builder.add_point(idx as PointOffsetType, &values).unwrap();
+                }
+                builder.finalize().unwrap();
+            }
+            IndexType::Mmap => {
+                let mut builder = MapIndex::<N>::mmap_builder(path);
+                builder.init().unwrap();
+                for (idx, values) in data.iter().enumerate() {
+                    let values: Vec<Value> = values.iter().map(&into_value).collect();
+                    let values: Vec<_> = values.iter().collect();
+                    builder.add_point(idx as PointOffsetType, &values).unwrap();
+                }
+                builder.finalize().unwrap();
             }
         }
-        index.flusher()().unwrap();
     }
 
-    fn load_map_index<N: MapIndexKey + ?Sized>(data: &[Vec<N::Owned>], path: &Path) -> MapIndex<N> {
-        let mut index =
-            MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true);
+    fn load_map_index<N: MapIndexKey + ?Sized>(
+        data: &[Vec<N::Owned>],
+        path: &Path,
+        index_type: IndexType,
+    ) -> MapIndex<N> {
+        let mut index = match index_type {
+            IndexType::Mutable => {
+                MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
+            }
+            IndexType::Immutable => {
+                MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, false)
+            }
+            IndexType::Mmap => MapIndex::<N>::new_mmap(path).unwrap(),
+        };
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
-            let index_values: HashSet<&N> =
-                index.get_values(idx as PointOffsetType).unwrap().collect();
+            let index_values: HashSet<N::Owned> = index
+                .get_values(idx as PointOffsetType)
+                .unwrap()
+                .map(|v| N::to_owned(N::from_referenced(&v)))
+                .collect();
+            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();
             let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();
             assert_eq!(index_values, check_values);
         }
@@ -684,8 +822,11 @@ mod tests {
         index
     }
 
-    #[test]
-    fn test_int_disk_map_index() {
+    #[rstest]
+    #[case(IndexType::Mutable)]
+    #[case(IndexType::Immutable)]
+    #[case(IndexType::Mmap)]
+    fn test_int_disk_map_index(#[case] index_type: IndexType) {
         let data = vec![
             vec![1, 2, 3, 4, 5, 6],
             vec![1, 2, 3, 4, 5, 6],
@@ -695,8 +836,8 @@ mod tests {
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<IntPayloadType>(&data, temp_dir.path());
-        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path());
+        save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());
+        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is non zero
         assert!(!index
@@ -704,8 +845,11 @@ mod tests {
             .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
-    #[test]
-    fn test_string_disk_map_index() {
+    #[rstest]
+    #[case(IndexType::Mutable)]
+    #[case(IndexType::Immutable)]
+    #[case(IndexType::Mmap)]
+    fn test_string_disk_map_index(#[case] index_type: IndexType) {
         let data = vec![
             vec![
                 SmolStr::from("AABB"),
@@ -731,8 +875,8 @@ mod tests {
         ];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path());
-        let index = load_map_index::<str>(&data, temp_dir.path());
+        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
+        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is non zero
         assert!(!index
@@ -740,13 +884,16 @@ mod tests {
             .equals_min_exp_max(&CardinalityEstimation::exact(0)));
     }
 
-    #[test]
-    fn test_empty_index() {
+    #[rstest]
+    #[case(IndexType::Mutable)]
+    #[case(IndexType::Immutable)]
+    #[case(IndexType::Mmap)]
+    fn test_empty_index(#[case] index_type: IndexType) {
         let data: Vec<Vec<SmolStr>> = vec![];
 
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        save_map_index::<str>(&data, temp_dir.path());
-        let index = load_map_index::<str>(&data, temp_dir.path());
+        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
+        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is zero
         assert!(index

commit 64f0fdf29423eef31f4a030eb9d06c3fc2815965
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 09:35:21 2024 +0000

    Fix mmap payload index building (rebase) (#4818)
    
    * Fix mmap payload index building
    
    * clippy
    
    ---------
    
    Co-authored-by: jojii <jojii@gmx.net>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 51e1b4e17..d8d168460 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -443,7 +443,11 @@ where
             flatten_values.extend(payload_values);
         }
         let flatten_values: Vec<N::Owned> = flatten_values.into_iter().map(Into::into).collect();
-        self.point_to_values.resize_with(id as usize + 1, Vec::new);
+
+        if self.point_to_values.len() <= id as usize {
+            self.point_to_values.resize_with(id as usize + 1, Vec::new);
+        }
+
         self.point_to_values[id as usize].extend(flatten_values.clone());
         for value in flatten_values {
             self.values_to_points.entry(value).or_default().push(id);
@@ -822,6 +826,31 @@ mod tests {
         index
     }
 
+    #[test]
+    fn test_index_non_ascending_insertion() {
+        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
+        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path());
+        builder.init().unwrap();
+
+        let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];
+
+        for (idx, values) in data.iter().enumerate().rev() {
+            let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();
+            let values: Vec<_> = values.iter().collect();
+            builder.add_point(idx as PointOffsetType, &values).unwrap();
+        }
+
+        let index = builder.finalize().unwrap();
+        for (idx, values) in data.iter().enumerate().rev() {
+            let res: Vec<_> = index
+                .get_values(idx as u32)
+                .unwrap()
+                .map(|i| i as i32)
+                .collect();
+            assert_eq!(res, *values);
+        }
+    }
+
     #[rstest]
     #[case(IndexType::Mutable)]
     #[case(IndexType::Immutable)]

commit 7ea8e1ec7d378739ae8a6bf524daf31df2bb5b87
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Sat Aug 3 19:45:14 2024 +0000

    Integrate map/numeric mmap indices (#4809)
    
    * Extend FieldIndexBuilder with mmap indices
    
    * Introduce PayloadFieldIndex::files()
    
    * Create and delete index dirs
    
    * Update index_selector and index_builder_selector

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index d8d168460..c005a19b2 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -268,6 +268,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
+    fn files(&self) -> Vec<PathBuf> {
+        match self {
+            MapIndex::Mutable(_) => Vec::new(),
+            MapIndex::Immutable(_) => Vec::new(),
+            MapIndex::Mmap(index) => index.files(),
+        }
+    }
+
     /// Estimates cardinality for `except` clause
     ///
     /// # Arguments
@@ -481,6 +489,10 @@ impl PayloadFieldIndex for MapIndex<str> {
         MapIndex::flusher(self)
     }
 
+    fn files(&self) -> Vec<PathBuf> {
+        self.files()
+    }
+
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
@@ -591,6 +603,10 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
         MapIndex::flusher(self)
     }
 
+    fn files(&self) -> Vec<PathBuf> {
+        self.files()
+    }
+
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,

commit 564c085d4b0e20fbc3861dae0a8f25f07c9e1696
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Aug 7 19:45:42 2024 +0200

    On-disk Uuid hybrid-index (#4825)
    
    * Migrate uuid index to mmap
    
    * add uuid numeric index
    
    * select correct index + tenants
    
    * Only serialize if necessary
    
    * select correct index
    
    * reset Cargo.toml
    
    * review: use only map index for uuid for now
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index c005a19b2..492b24b8d 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -16,6 +16,7 @@ use parking_lot::RwLock;
 use rocksdb::DB;
 use serde_json::Value;
 use smol_str::SmolStr;
+use uuid::Uuid;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
@@ -31,7 +32,7 @@ use crate::index::query_estimator::combine_should_estimations;
 use crate::telemetry::PayloadIndexTelemetry;
 use crate::types::{
     AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,
-    PayloadKeyType, ValueVariants,
+    PayloadKeyType, UuidIntType, ValueVariants,
 };
 
 pub mod immutable_map_index;
@@ -62,6 +63,14 @@ impl MapIndexKey for IntPayloadType {
     }
 }
 
+impl MapIndexKey for UuidIntType {
+    type Owned = UuidIntType;
+
+    fn to_owned(&self) -> Self::Owned {
+        *self
+    }
+}
+
 pub enum MapIndex<N: MapIndexKey + ?Sized> {
     Mutable(MutableMapIndex<N>),
     Immutable(ImmutableMapIndex<N>),
@@ -586,6 +595,83 @@ impl PayloadFieldIndex for MapIndex<str> {
     }
 }
 
+impl PayloadFieldIndex for MapIndex<UuidIntType> {
+    fn count_indexed_points(&self) -> usize {
+        self.get_indexed_points()
+    }
+
+    fn load(&mut self) -> OperationResult<bool> {
+        self.load_from_db()
+    }
+
+    fn clear(self) -> OperationResult<()> {
+        self.clear()
+    }
+
+    fn flusher(&self) -> Flusher {
+        MapIndex::flusher(self)
+    }
+
+    fn files(&self) -> Vec<PathBuf> {
+        self.files()
+    }
+
+    fn filter<'a>(
+        &'a self,
+        condition: &'a FieldCondition,
+    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
+        if let Some(Match::Value(MatchValue {
+            value: ValueVariants::Keyword(keyword),
+        })) = &condition.r#match
+        {
+            let keyword = keyword.as_str();
+
+            if let Ok(uuid) = Uuid::from_str(keyword) {
+                return Some(Box::new(self.get_iterator(&uuid.as_u128()).copied()));
+            }
+        }
+
+        None
+    }
+
+    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+        if let Some(Match::Value(MatchValue {
+            value: ValueVariants::Keyword(keyword),
+        })) = &condition.r#match
+        {
+            let keyword = keyword.as_str();
+            if let Ok(uuid) = Uuid::from_str(keyword) {
+                let mut estimation = self.match_cardinality(&uuid.as_u128());
+                estimation
+                    .primary_clauses
+                    .push(PrimaryCondition::Condition(condition.clone()));
+                return Some(estimation);
+            }
+        }
+
+        None
+    }
+
+    fn payload_blocks(
+        &self,
+        threshold: usize,
+        key: PayloadKeyType,
+    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
+        Box::new(
+            self.iter_values()
+                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
+                .filter(move |(_value, count)| *count >= threshold)
+                .map(move |(value, count)| PayloadBlockCondition {
+                    condition: FieldCondition::new_match(
+                        key.clone(),
+                        Uuid::from_u128(*value).to_string().into(),
+                    ),
+                    cardinality: count,
+                }),
+        )
+    }
+}
+
 impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn count_indexed_points(&self) -> usize {
         self.get_indexed_points()
@@ -758,6 +844,34 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
     }
 }
 
+impl ValueIndexer for MapIndex<UuidIntType> {
+    type ValueType = UuidIntType;
+
+    fn add_many(
+        &mut self,
+        id: PointOffsetType,
+        values: Vec<Self::ValueType>,
+    ) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Immutable(_) => Err(OperationError::service_error(
+                "Can't add values to immutable map index",
+            )),
+            MapIndex::Mmap(_) => Err(OperationError::service_error(
+                "Can't add values to mmap map index",
+            )),
+        }
+    }
+
+    fn get_value(value: &Value) -> Option<Self::ValueType> {
+        Some(Uuid::parse_str(value.as_str()?).ok()?.as_u128())
+    }
+
+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {
+        self.remove_point(id)
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use std::collections::HashSet;

commit 3185dd23c50f02e8f38c10839ff622fc2bd3a072
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Aug 19 23:21:17 2024 -0400

    Exact facet mode (#4878)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 492b24b8d..d67de5039 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -182,7 +182,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
+    pub fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {
         match self {
             MapIndex::Mutable(index) => index.iter_values(),
             MapIndex::Immutable(index) => index.iter_values(),

commit 90449b30d672bce523b4b01cf9ff30eabbaa702f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 20 10:12:20 2024 -0400

    perf: Limit bad performance of filtered faceting (#4903)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index d67de5039..1fd4102e7 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -158,7 +158,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_unique_values_count(&self) -> usize {
+    pub fn get_unique_values_count(&self) -> usize {
         match self {
             MapIndex::Mutable(index) => index.get_unique_values_count(),
             MapIndex::Immutable(index) => index.get_unique_values_count(),

commit 287f287bbd98f53c1dd29583149dec7234f29c2c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 27 00:53:30 2024 +0200

    Implement better handling of UUID index (#4961)
    
    * rename keyword -> string for internal data structures
    
    * implement MatchAny and expect for filter on UUID mmap index
    
    * implement MatchAny and expect for cardinality estimation on UUID mmap index
    
    * refactor PayloadFieldIndex filter for handling incorrect empty query parsing case

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 1fd4102e7..018d19905 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -507,11 +507,15 @@ impl PayloadFieldIndex for MapIndex<str> {
         condition: &'a FieldCondition,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
-            Some(Match::Value(MatchValue {
-                value: ValueVariants::Keyword(keyword),
-            })) => Some(Box::new(self.get_iterator(keyword.as_str()).copied())),
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(keyword) => {
+                    Some(Box::new(self.get_iterator(keyword.as_str()).copied()))
+                }
+                ValueVariants::Integer(_) => None,
+                ValueVariants::Bool(_) => None,
+            },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Keywords(keywords) => Some(Box::new(
+                AnyVariants::Strings(keywords) => Some(Box::new(
                     keywords
                         .iter()
                         .flat_map(|keyword| self.get_iterator(keyword.as_str()).copied())
@@ -525,26 +529,35 @@ impl PayloadFieldIndex for MapIndex<str> {
                     }
                 }
             },
-            Some(Match::Except(MatchExcept {
-                except: AnyVariants::Keywords(keywords),
-            })) => Some(self.except_set(keywords)),
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(keywords) => Some(self.except_set(keywords)),
+                AnyVariants::Integers(other) => {
+                    if other.is_empty() {
+                        Some(Box::new(iter::empty()))
+                    } else {
+                        None
+                    }
+                }
+            },
             _ => None,
         }
     }
 
     fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
         match &condition.r#match {
-            Some(Match::Value(MatchValue {
-                value: ValueVariants::Keyword(keyword),
-            })) => {
-                let mut estimation = self.match_cardinality(keyword.as_str());
-                estimation
-                    .primary_clauses
-                    .push(PrimaryCondition::Condition(condition.clone()));
-                Some(estimation)
-            }
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(keyword) => {
+                    let mut estimation = self.match_cardinality(keyword.as_str());
+                    estimation
+                        .primary_clauses
+                        .push(PrimaryCondition::Condition(condition.clone()));
+                    Some(estimation)
+                }
+                ValueVariants::Integer(_) => None,
+                ValueVariants::Bool(_) => None,
+            },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Keywords(keywords) => {
+                AnyVariants::Strings(keywords) => {
                     let estimations = keywords
                         .iter()
                         .map(|keyword| self.match_cardinality(keyword.as_str()))
@@ -571,9 +584,22 @@ impl PayloadFieldIndex for MapIndex<str> {
                     }
                 }
             },
-            Some(Match::Except(MatchExcept {
-                except: AnyVariants::Keywords(keywords),
-            })) => Some(self.except_cardinality(keywords.iter().map(|k| k.as_str()))),
+            Some(Match::Except(MatchExcept { except })) => {
+                match except {
+                    AnyVariants::Strings(keywords) => {
+                        Some(self.except_cardinality(keywords.iter().map(|k| k.as_str())))
+                    }
+                    AnyVariants::Integers(others) => {
+                        if others.is_empty() {
+                            Some(CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ))
+                        } else {
+                            None
+                        }
+                    }
+                }
+            }
             _ => None,
         }
     }
@@ -620,36 +646,140 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
         &'a self,
         condition: &'a FieldCondition,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
-        if let Some(Match::Value(MatchValue {
-            value: ValueVariants::Keyword(keyword),
-        })) = &condition.r#match
-        {
-            let keyword = keyword.as_str();
-
-            if let Ok(uuid) = Uuid::from_str(keyword) {
-                return Some(Box::new(self.get_iterator(&uuid.as_u128()).copied()));
-            }
-        }
+        match &condition.r#match {
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(uuid_string) => {
+                    let uuid = Uuid::from_str(uuid_string).ok()?;
+                    Some(Box::new(self.get_iterator(&uuid.as_u128()).copied()))
+                }
+                ValueVariants::Integer(_) => None,
+                ValueVariants::Bool(_) => None,
+            },
+            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+                AnyVariants::Strings(uuids_string) => {
+                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+                        .iter()
+                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                        .collect();
 
-        None
+                    let uuids = uuids.ok()?;
+
+                    Some(Box::new(
+                        uuids
+                            .into_iter()
+                            .flat_map(|uuid| self.get_iterator(&uuid).copied())
+                            .unique(),
+                    ))
+                }
+                AnyVariants::Integers(integers) => {
+                    if integers.is_empty() {
+                        Some(Box::new(iter::empty()))
+                    } else {
+                        None
+                    }
+                }
+            },
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(uuids_string) => {
+                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+                        .iter()
+                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                        .collect();
+
+                    let excluded_uuids = uuids.ok()?;
+                    let exclude_iter = self
+                        .iter_values()
+                        .filter(move |key| !excluded_uuids.contains(*key))
+                        .flat_map(|key| self.get_iterator(key).copied())
+                        .unique();
+                    Some(Box::new(exclude_iter))
+                }
+                AnyVariants::Integers(other) => {
+                    if other.is_empty() {
+                        Some(Box::new(iter::empty()))
+                    } else {
+                        None
+                    }
+                }
+            },
+            _ => None,
+        }
     }
 
     fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
-        if let Some(Match::Value(MatchValue {
-            value: ValueVariants::Keyword(keyword),
-        })) = &condition.r#match
-        {
-            let keyword = keyword.as_str();
-            if let Ok(uuid) = Uuid::from_str(keyword) {
-                let mut estimation = self.match_cardinality(&uuid.as_u128());
-                estimation
-                    .primary_clauses
-                    .push(PrimaryCondition::Condition(condition.clone()));
-                return Some(estimation);
+        match &condition.r#match {
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(uuid_string) => {
+                    let uuid = Uuid::from_str(uuid_string).ok()?;
+                    let mut estimation = self.match_cardinality(&uuid.as_u128());
+                    estimation
+                        .primary_clauses
+                        .push(PrimaryCondition::Condition(condition.clone()));
+                    Some(estimation)
+                }
+                ValueVariants::Integer(_) => None,
+                ValueVariants::Bool(_) => None,
+            },
+            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
+                AnyVariants::Strings(uuids_string) => {
+                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+                        .iter()
+                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                        .collect();
+
+                    let uuids = uuids.ok()?;
+
+                    let estimations = uuids
+                        .into_iter()
+                        .map(|uuid| self.match_cardinality(&uuid))
+                        .collect::<Vec<_>>();
+                    let estimation = if estimations.is_empty() {
+                        CardinalityEstimation::exact(0)
+                    } else {
+                        combine_should_estimations(&estimations, self.get_indexed_points())
+                    };
+                    Some(
+                        estimation
+                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                    )
+                }
+                AnyVariants::Integers(integers) => {
+                    if integers.is_empty() {
+                        Some(
+                            CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ),
+                        )
+                    } else {
+                        None
+                    }
+                }
+            },
+            Some(Match::Except(MatchExcept { except })) => {
+                match except {
+                    AnyVariants::Strings(uuids_string) => {
+                        let uuids: Result<IndexSet<u128>, _> = uuids_string
+                            .iter()
+                            .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                            .collect();
+
+                        let excluded_uuids = uuids.ok()?;
+
+                        Some(self.except_cardinality(excluded_uuids.iter()))
+                    }
+                    AnyVariants::Integers(other) => {
+                        if other.is_empty() {
+                            Some(CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ))
+                        } else {
+                            None
+                        }
+                    }
+                }
             }
+            _ => None,
         }
-
-        None
     }
 
     fn payload_blocks(
@@ -698,11 +828,15 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
         condition: &'a FieldCondition,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
-            Some(Match::Value(MatchValue {
-                value: ValueVariants::Integer(integer),
-            })) => Some(Box::new(self.get_iterator(integer).copied())),
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(_) => None,
+                ValueVariants::Integer(integer) => {
+                    Some(Box::new(self.get_iterator(integer).copied()))
+                }
+                ValueVariants::Bool(_) => None,
+            },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Keywords(keywords) => {
+                AnyVariants::Strings(keywords) => {
                     if keywords.is_empty() {
                         Some(Box::new(vec![].into_iter()))
                     } else {
@@ -716,26 +850,35 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         .unique(),
                 )),
             },
-            Some(Match::Except(MatchExcept {
-                except: AnyVariants::Integers(integers),
-            })) => Some(self.except_set(integers)),
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(other) => {
+                    if other.is_empty() {
+                        Some(Box::new(iter::empty()))
+                    } else {
+                        None
+                    }
+                }
+                AnyVariants::Integers(integers) => Some(self.except_set(integers)),
+            },
             _ => None,
         }
     }
 
     fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
         match &condition.r#match {
-            Some(Match::Value(MatchValue {
-                value: ValueVariants::Integer(integer),
-            })) => {
-                let mut estimation = self.match_cardinality(integer);
-                estimation
-                    .primary_clauses
-                    .push(PrimaryCondition::Condition(condition.clone()));
-                Some(estimation)
-            }
+            Some(Match::Value(MatchValue { value })) => match value {
+                ValueVariants::String(_) => None,
+                ValueVariants::Integer(integer) => {
+                    let mut estimation = self.match_cardinality(integer);
+                    estimation
+                        .primary_clauses
+                        .push(PrimaryCondition::Condition(condition.clone()));
+                    Some(estimation)
+                }
+                ValueVariants::Bool(_) => None,
+            },
             Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
-                AnyVariants::Keywords(keywords) => {
+                AnyVariants::Strings(keywords) => {
                     if keywords.is_empty() {
                         Some(
                             CardinalityEstimation::exact(0).with_primary_clause(
@@ -762,9 +905,20 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                     )
                 }
             },
-            Some(Match::Except(MatchExcept {
-                except: AnyVariants::Integers(integers),
-            })) => Some(self.except_cardinality(integers.iter())),
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(others) => {
+                    if others.is_empty() {
+                        Some(
+                            CardinalityEstimation::exact(0).with_primary_clause(
+                                PrimaryCondition::Condition(condition.clone()),
+                            ),
+                        )
+                    } else {
+                        None
+                    }
+                }
+                AnyVariants::Integers(integers) => Some(self.except_cardinality(integers.iter())),
+            },
             _ => None,
         }
     }

commit 4b429214cc3feeede5d5ab2912fad76523219c4e
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Aug 27 11:30:57 2024 -0400

    Integer and UUID facets (#4946)
    
    * move FacetIndex into facet_index.rs
    
    * add support for integer facets
    
    * add support for uuid facets
    
    * use separate internal structure
    
    * rename FacetValue::Keyword into FacetValue::String in REST
    
    * fix after rebase

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 018d19905..0128b28f0 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -125,10 +125,10 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     ) -> Option<Box<dyn Iterator<Item = N::Referenced<'_>> + '_>> {
         match self {
             MapIndex::Mutable(index) => Some(Box::new(
-                index.get_values(idx)?.map(|v| N::into_referenced(v)),
+                index.get_values(idx)?.map(|v| N::as_referenced(v)),
             )),
             MapIndex::Immutable(index) => Some(Box::new(
-                index.get_values(idx)?.map(|v| N::into_referenced(v)),
+                index.get_values(idx)?.map(|v| N::as_referenced(v)),
             )),
             MapIndex::Mmap(index) => Some(Box::new(index.get_values(idx)?)),
         }
@@ -1129,7 +1129,7 @@ mod tests {
             let res: Vec<_> = index
                 .get_values(idx as u32)
                 .unwrap()
-                .map(|i| i as i32)
+                .map(|i| *i as i32)
                 .collect();
             assert_eq!(res, *values);
         }

commit cf8971503637f3d089670d74df81e31fb76f4fcf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Sep 16 16:27:30 2024 -0300

    Expose `on_disk` text index (#5074)
    
    * map index: fix reachable code marked as unreachable
    
    * plumber work to get mmap text index to interfaces
    
    * test: add fixture for mmap text index, always create mmap segment
    
    * various fixes
    
    - ensure dir is created for mmap
    - implement is_on_disk() for text index
    - invert deleted condition for filter in mmap inverted index
    
    * update grpc docs and openapi
    
    * implement return of files
    
    * review nit
    
    * fix after rebase
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 0128b28f0..b4496398b 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -422,7 +422,7 @@ where
     fn init(&mut self) -> OperationResult<()> {
         match &mut self.0 {
             MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),
-            MapIndex::Immutable(_) => unreachable!(),
+            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),
             MapIndex::Mmap(_) => unreachable!(),
         }
     }

commit ad6b9734f37b2d28700ed4a14fe3d913abf7531c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Oct 1 09:17:50 2024 -0300

    Facets: Support for `bool` payload  (#5100)
    
    * enable faceting with boolean index
    
    * test and fix
    
    * also test uuid

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index b4496398b..12f0c5f39 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -40,6 +40,7 @@ pub mod mmap_map_index;
 pub mod mutable_map_index;
 
 pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;
+pub type IdIter<'a> = Box<dyn Iterator<Item = PointOffsetType> + 'a>;
 
 pub trait MapIndexKey: Key + MmapValue + Eq + Display + Debug {
     type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;
@@ -198,7 +199,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn iter_values_map(&self) -> Box<dyn Iterator<Item = (&N, IdRefIter<'_>)> + '_> {
+    pub fn iter_values_map(&self) -> Box<dyn Iterator<Item = (&N, IdIter<'_>)> + '_> {
         match self {
             MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
             MapIndex::Immutable(index) => Box::new(index.iter_values_map()),

commit a73d0bfcc731785eecd2781e01d1841d0c42e626
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Oct 7 12:08:58 2024 +0200

    Mmap geo index (#4841)
    
    * define mmap geo index
    
    fix compilation
    
    deleted flags
    
    load new mmap
    
    geo index tests
    
    fix tests
    
    fix build after rebase
    
    add files list
    
    * are you happy fmt
    
    * refactor get_stored_sub_regions output type
    
    * repr(C) for geohash
    
    * Replace manual flattening with flat map iterator
    
    * review remanings
    
    * remove panics
    
    * add files for snapshot
    
    * rename Dynamic into InMemory
    
    * are you happy fmt
    
    * review renames
    
    * Use copied rather than cloned
    
    * minor review refactoring + comments
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 12f0c5f39..0c48c60ad 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -79,7 +79,7 @@ pub enum MapIndex<N: MapIndexKey + ?Sized> {
 }
 
 impl<N: MapIndexKey + ?Sized> MapIndex<N> {
-    pub fn new(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
+    pub fn new_memory(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {
         if is_appendable {
             MapIndex::Mutable(MutableMapIndex::new(db, field_name))
         } else {
@@ -1089,11 +1089,13 @@ mod tests {
     ) -> MapIndex<N> {
         let mut index = match index_type {
             IndexType::Mutable => {
-                MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
-            }
-            IndexType::Immutable => {
-                MapIndex::<N>::new(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, false)
+                MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)
             }
+            IndexType::Immutable => MapIndex::<N>::new_memory(
+                open_db_with_existing_cf(path).unwrap(),
+                FIELD_NAME,
+                false,
+            ),
             IndexType::Mmap => MapIndex::<N>::new_mmap(path).unwrap(),
         };
         index.load_from_db().unwrap();

commit c3068aaf272e63195c6bde395cf5d4021026d061
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 18 11:03:18 2024 +0100

    Fix clippy large variant for filter condition (#5455)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 0c48c60ad..c69daabc9 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -551,7 +551,7 @@ impl PayloadFieldIndex for MapIndex<str> {
                     let mut estimation = self.match_cardinality(keyword.as_str());
                     estimation
                         .primary_clauses
-                        .push(PrimaryCondition::Condition(condition.clone()));
+                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
                     Some(estimation)
                 }
                 ValueVariants::Integer(_) => None,
@@ -569,38 +569,35 @@ impl PayloadFieldIndex for MapIndex<str> {
                         combine_should_estimations(&estimations, self.get_indexed_points())
                     };
                     Some(
-                        estimation
-                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+                            condition.clone(),
+                        ))),
                     )
                 }
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
-                        Some(
-                            CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ),
-                        )
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
                     } else {
                         None
                     }
                 }
             },
-            Some(Match::Except(MatchExcept { except })) => {
-                match except {
-                    AnyVariants::Strings(keywords) => {
-                        Some(self.except_cardinality(keywords.iter().map(|k| k.as_str())))
-                    }
-                    AnyVariants::Integers(others) => {
-                        if others.is_empty() {
-                            Some(CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ))
-                        } else {
-                            None
-                        }
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(keywords) => {
+                    Some(self.except_cardinality(keywords.iter().map(|k| k.as_str())))
+                }
+                AnyVariants::Integers(others) => {
+                    if others.is_empty() {
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
+                    } else {
+                        None
                     }
                 }
-            }
+            },
             _ => None,
         }
     }
@@ -715,7 +712,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                     let mut estimation = self.match_cardinality(&uuid.as_u128());
                     estimation
                         .primary_clauses
-                        .push(PrimaryCondition::Condition(condition.clone()));
+                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
                     Some(estimation)
                 }
                 ValueVariants::Integer(_) => None,
@@ -740,45 +737,42 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                         combine_should_estimations(&estimations, self.get_indexed_points())
                     };
                     Some(
-                        estimation
-                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+                            condition.clone(),
+                        ))),
                     )
                 }
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
-                        Some(
-                            CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ),
-                        )
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
                     } else {
                         None
                     }
                 }
             },
-            Some(Match::Except(MatchExcept { except })) => {
-                match except {
-                    AnyVariants::Strings(uuids_string) => {
-                        let uuids: Result<IndexSet<u128>, _> = uuids_string
-                            .iter()
-                            .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
-                            .collect();
+            Some(Match::Except(MatchExcept { except })) => match except {
+                AnyVariants::Strings(uuids_string) => {
+                    let uuids: Result<IndexSet<u128>, _> = uuids_string
+                        .iter()
+                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
+                        .collect();
 
-                        let excluded_uuids = uuids.ok()?;
+                    let excluded_uuids = uuids.ok()?;
 
-                        Some(self.except_cardinality(excluded_uuids.iter()))
-                    }
-                    AnyVariants::Integers(other) => {
-                        if other.is_empty() {
-                            Some(CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ))
-                        } else {
-                            None
-                        }
+                    Some(self.except_cardinality(excluded_uuids.iter()))
+                }
+                AnyVariants::Integers(other) => {
+                    if other.is_empty() {
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
+                    } else {
+                        None
                     }
                 }
-            }
+            },
             _ => None,
         }
     }
@@ -873,7 +867,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                     let mut estimation = self.match_cardinality(integer);
                     estimation
                         .primary_clauses
-                        .push(PrimaryCondition::Condition(condition.clone()));
+                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));
                     Some(estimation)
                 }
                 ValueVariants::Bool(_) => None,
@@ -881,11 +875,9 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
             Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {
                 AnyVariants::Strings(keywords) => {
                     if keywords.is_empty() {
-                        Some(
-                            CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ),
-                        )
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
                     } else {
                         None
                     }
@@ -901,19 +893,18 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         combine_should_estimations(&estimations, self.get_indexed_points())
                     };
                     Some(
-                        estimation
-                            .with_primary_clause(PrimaryCondition::Condition(condition.clone())),
+                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(
+                            condition.clone(),
+                        ))),
                     )
                 }
             },
             Some(Match::Except(MatchExcept { except })) => match except {
                 AnyVariants::Strings(others) => {
                     if others.is_empty() {
-                        Some(
-                            CardinalityEstimation::exact(0).with_primary_clause(
-                                PrimaryCondition::Condition(condition.clone()),
-                            ),
-                        )
+                        Some(CardinalityEstimation::exact(0).with_primary_clause(
+                            PrimaryCondition::Condition(Box::new(condition.clone())),
+                        ))
                     } else {
                         None
                     }

commit c573f2f0a23e86cd1be27d67d17fa486a3ff9adf
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Dec 6 17:29:19 2024 -0600

    Mmap bool index (#5526)
    
    * add `MmapBitSlice::extend` helper
    
    * mmap bool index implementation
    
    * unit test both implementations
    
    * switch to `DynamicMmapFlags`
    
    * tidy up
    
    * recalculate `indexed_count` on load
    
    * grow bitslice aligned to the mmap page size
    
    * ergonomic get_slice_for
    
    * fix for growing mmap
    
    * use more `get_slice_for()`

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index c69daabc9..ce3d84883 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -491,7 +491,7 @@ impl PayloadFieldIndex for MapIndex<str> {
         self.load_from_db()
     }
 
-    fn clear(self) -> OperationResult<()> {
+    fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
 
@@ -628,7 +628,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
         self.load_from_db()
     }
 
-    fn clear(self) -> OperationResult<()> {
+    fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
 
@@ -806,7 +806,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
         self.load_from_db()
     }
 
-    fn clear(self) -> OperationResult<()> {
+    fn cleanup(self) -> OperationResult<()> {
         self.clear()
     }
 

commit 97e3f4c824a98a3621b7d48cf3e70a2f5dc7ad3c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Dec 18 05:53:01 2024 -0300

    Introduce facet index trait (#5673)
    
    * introduce facet index trait
    
    * clippy
    
    * fix simple bool index's `get_point_values`

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index ce3d84883..e64b3792d 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -20,10 +20,12 @@ use uuid::Uuid;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
+use super::facet_index::FacetIndex;
 use super::mmap_point_to_values::MmapValue;
 use super::FieldIndexBuilderTrait;
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
     CardinalityEstimation, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition, ValueIndexer,
@@ -932,6 +934,38 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     }
 }
 
+impl<N> FacetIndex for MapIndex<N>
+where
+    N: MapIndexKey + ?Sized,
+    for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,
+    for<'a> &'a N: Into<FacetValueRef<'a>>,
+{
+    fn get_point_values(
+        &self,
+        point_id: PointOffsetType,
+    ) -> impl Iterator<Item = FacetValueRef> + '_ {
+        MapIndex::get_values(self, point_id)
+            .into_iter()
+            .flatten()
+            .map(Into::into)
+    }
+
+    fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {
+        self.iter_values().map(Into::into)
+    }
+
+    fn iter_values_map(&self) -> impl Iterator<Item = (FacetValueRef, IdIter<'_>)> + '_ {
+        self.iter_values_map().map(|(k, iter)| (k.into(), iter))
+    }
+
+    fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
+        self.iter_counts_per_value().map(|(value, count)| FacetHit {
+            value: value.into(),
+            count,
+        })
+    }
+}
+
 impl ValueIndexer for MapIndex<str> {
     type ValueType = String;
 

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index e64b3792d..4ed953a4d 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -20,11 +20,11 @@ use uuid::Uuid;
 
 use self::immutable_map_index::ImmutableMapIndex;
 use self::mutable_map_index::MutableMapIndex;
+use super::FieldIndexBuilderTrait;
 use super::facet_index::FacetIndex;
 use super::mmap_point_to_values::MmapValue;
-use super::FieldIndexBuilderTrait;
-use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::data_types::facets::{FacetHit, FacetValueRef};
 use crate::index::field_index::stat_tools::number_of_selected_points;
 use crate::index::field_index::{
@@ -1181,9 +1181,11 @@ mod tests {
         let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is non zero
-        assert!(!index
-            .except_cardinality(vec![].into_iter())
-            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
+        assert!(
+            !index
+                .except_cardinality(vec![].into_iter())
+                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
+        );
     }
 
     #[rstest]
@@ -1220,9 +1222,11 @@ mod tests {
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is non zero
-        assert!(!index
-            .except_cardinality(vec![].into_iter())
-            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
+        assert!(
+            !index
+                .except_cardinality(vec![].into_iter())
+                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
+        );
     }
 
     #[rstest]
@@ -1237,8 +1241,10 @@ mod tests {
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
         // Ensure cardinality is zero
-        assert!(index
-            .except_cardinality(vec![].into_iter())
-            .equals_min_exp_max(&CardinalityEstimation::exact(0)));
+        assert!(
+            index
+                .except_cardinality(vec![].into_iter())
+                .equals_min_exp_max(&CardinalityEstimation::exact(0)),
+        );
     }
 }

commit 6d53bd91845ee56bb252c08716fdf46d883c48aa
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Mar 12 14:31:48 2025 +0100

    IO read measurements for most Payload indices (#5951)
    
    * Add payload index filtering IO measurements for some indices
    
    * Add payload index metric to api and telemetry
    
    * Also account for index access overhead
    
    * Review remarks
    
    * Anonymize new HardwareUsage field
    
    * Fix tests

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 4ed953a4d..cfacbf080 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -7,6 +7,8 @@ use std::str::FromStr;
 use std::sync::Arc;
 
 use ahash::HashMap;
+use common::counter::hardware_accumulator::HwMeasurementAcc;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::mmap_hashmap::Key;
 use common::types::PointOffsetType;
 use indexmap::IndexSet;
@@ -114,11 +116,16 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn check_values_any(&self, idx: PointOffsetType, check_fn: impl Fn(&N) -> bool) -> bool {
+    pub fn check_values_any(
+        &self,
+        idx: PointOffsetType,
+        hw_counter: &HardwareCounterCell,
+        check_fn: impl Fn(&N) -> bool,
+    ) -> bool {
         match self {
-            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
-            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Mutable(index) => index.check_values_any(idx, hw_counter, check_fn),
+            MapIndex::Immutable(index) => index.check_values_any(idx, hw_counter, check_fn),
+            MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),
         }
     }
 
@@ -177,11 +184,11 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_iterator(&self, value: &N) -> IdRefIter<'_> {
+    fn get_iterator(&self, value: &N, hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {
         match self {
-            MapIndex::Mutable(index) => index.get_iterator(value),
-            MapIndex::Immutable(index) => index.get_iterator(value),
-            MapIndex::Mmap(index) => index.get_iterator(value),
+            MapIndex::Mutable(index) => index.get_iterator(value, hw_counter),
+            MapIndex::Immutable(index) => index.get_iterator(value, hw_counter),
+            MapIndex::Mmap(index) => index.get_iterator(value, hw_counter),
         }
     }
 
@@ -405,10 +412,11 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         A: BuildHasher,
         K: Borrow<N> + Hash + Eq,
     {
+        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Maybe propagate?
         Box::new(
             self.iter_values()
                 .filter(|key| !excluded.contains((*key).borrow()))
-                .flat_map(|key| self.get_iterator(key.borrow()).copied())
+                .flat_map(move |key| self.get_iterator(key.borrow(), &hw_counter).copied())
                 .unique(),
         )
     }
@@ -508,22 +516,31 @@ impl PayloadFieldIndex for MapIndex<str> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
+        hw_acc: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(keyword) => {
-                    Some(Box::new(self.get_iterator(keyword.as_str()).copied()))
+                    let hw_counter = hw_acc.get_counter_cell();
+                    Some(Box::new(
+                        self.get_iterator(keyword.as_str(), &hw_counter).copied(),
+                    ))
                 }
                 ValueVariants::Integer(_) => None,
                 ValueVariants::Bool(_) => None,
             },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(keywords) => Some(Box::new(
-                    keywords
-                        .iter()
-                        .flat_map(|keyword| self.get_iterator(keyword.as_str()).copied())
-                        .unique(),
-                )),
+                AnyVariants::Strings(keywords) => {
+                    let hw_counter = hw_acc.get_counter_cell();
+                    Some(Box::new(
+                        keywords
+                            .iter()
+                            .flat_map(move |keyword| {
+                                self.get_iterator(keyword.as_str(), &hw_counter).copied()
+                            })
+                            .unique(),
+                    ))
+                }
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
                         Some(Box::new(iter::empty()))
@@ -645,18 +662,23 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
+        hw_acc: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(uuid_string) => {
                     let uuid = Uuid::from_str(uuid_string).ok()?;
-                    Some(Box::new(self.get_iterator(&uuid.as_u128()).copied()))
+                    let hw_counter = hw_acc.get_counter_cell();
+                    Some(Box::new(
+                        self.get_iterator(&uuid.as_u128(), &hw_counter).copied(),
+                    ))
                 }
                 ValueVariants::Integer(_) => None,
                 ValueVariants::Bool(_) => None,
             },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Strings(uuids_string) => {
+                    let hw_counter = hw_acc.get_counter_cell();
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
                         .iter()
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
@@ -667,7 +689,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                     Some(Box::new(
                         uuids
                             .into_iter()
-                            .flat_map(|uuid| self.get_iterator(&uuid).copied())
+                            .flat_map(move |uuid| self.get_iterator(&uuid, &hw_counter).copied())
                             .unique(),
                     ))
                 }
@@ -686,11 +708,13 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
                         .collect();
 
+                    let hw_counter = hw_acc.get_counter_cell();
+
                     let excluded_uuids = uuids.ok()?;
                     let exclude_iter = self
                         .iter_values()
                         .filter(move |key| !excluded_uuids.contains(*key))
-                        .flat_map(|key| self.get_iterator(key).copied())
+                        .flat_map(move |key| self.get_iterator(key, &hw_counter).copied())
                         .unique();
                     Some(Box::new(exclude_iter))
                 }
@@ -823,12 +847,14 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
+        hw_acc: HwMeasurementAcc,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(_) => None,
                 ValueVariants::Integer(integer) => {
-                    Some(Box::new(self.get_iterator(integer).copied()))
+                    let hw_counter = hw_acc.get_counter_cell();
+                    Some(Box::new(self.get_iterator(integer, &hw_counter).copied()))
                 }
                 ValueVariants::Bool(_) => None,
             },
@@ -840,12 +866,17 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         None
                     }
                 }
-                AnyVariants::Integers(integers) => Some(Box::new(
-                    integers
-                        .iter()
-                        .flat_map(|integer| self.get_iterator(integer).copied())
-                        .unique(),
-                )),
+                AnyVariants::Integers(integers) => {
+                    let hw_counter = hw_acc.get_counter_cell();
+                    Some(Box::new(
+                        integers
+                            .iter()
+                            .flat_map(move |integer| {
+                                self.get_iterator(integer, &hw_counter).copied()
+                            })
+                            .unique(),
+                    ))
+                }
             },
             Some(Match::Except(MatchExcept { except })) => match except {
                 AnyVariants::Strings(other) => {

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index cfacbf080..db67b96fe 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -176,11 +176,11 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn get_count_for_value(&self, value: &N) -> Option<usize> {
+    fn get_count_for_value(&self, value: &N, hw_counter: &HardwareCounterCell) -> Option<usize> {
         match self {
-            MapIndex::Mutable(index) => index.get_count_for_value(value),
-            MapIndex::Immutable(index) => index.get_count_for_value(value),
-            MapIndex::Mmap(index) => index.get_count_for_value(value),
+            MapIndex::Mutable(index) => index.get_count_for_value(value, hw_counter),
+            MapIndex::Immutable(index) => index.get_count_for_value(value, hw_counter),
+            MapIndex::Mmap(index) => index.get_count_for_value(value, hw_counter),
         }
     }
 
@@ -208,11 +208,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn iter_values_map(&self) -> Box<dyn Iterator<Item = (&N, IdIter<'_>)> + '_> {
+    pub fn iter_values_map(
+        &self,
+        hw_acc: HwMeasurementAcc,
+    ) -> Box<dyn Iterator<Item = (&N, IdIter<'_>)> + '_> {
         match self {
-            MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
-            MapIndex::Immutable(index) => Box::new(index.iter_values_map()),
-            MapIndex::Mmap(index) => Box::new(index.iter_values_map()),
+            MapIndex::Mutable(index) => Box::new(index.iter_values_map(hw_acc)),
+            MapIndex::Immutable(index) => Box::new(index.iter_values_map(hw_acc)),
+            MapIndex::Mmap(index) => Box::new(index.iter_values_map(hw_acc)),
         }
     }
 
@@ -228,8 +231,12 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    fn match_cardinality(&self, value: &N) -> CardinalityEstimation {
-        let values_count = self.get_count_for_value(value).unwrap_or(0);
+    fn match_cardinality(
+        &self,
+        value: &N,
+        hw_counter: &HardwareCounterCell,
+    ) -> CardinalityEstimation {
+        let values_count = self.get_count_for_value(value, hw_counter).unwrap_or(0);
 
         CardinalityEstimation::exact(values_count)
     }
@@ -307,6 +314,7 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     fn except_cardinality<'a>(
         &'a self,
         excluded: impl Iterator<Item = &'a N>,
+        hw_counter: &HardwareCounterCell,
     ) -> CardinalityEstimation {
         // Minimal case: we exclude as many points as possible.
         // In this case, excluded points do not have any other values except excluded ones.
@@ -350,7 +358,10 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         // max = min(60, 20) = 20
 
         let excluded_value_counts: Vec<_> = excluded
-            .map(|val| self.get_count_for_value(val.borrow()).unwrap_or(0))
+            .map(|val| {
+                self.get_count_for_value(val.borrow(), hw_counter)
+                    .unwrap_or(0)
+            })
             .collect();
         let total_excluded_value_count: usize = excluded_value_counts.iter().sum();
 
@@ -407,16 +418,16 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
     fn except_set<'a, K, A>(
         &'a self,
         excluded: &'a IndexSet<K, A>,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a>
     where
         A: BuildHasher,
         K: Borrow<N> + Hash + Eq,
     {
-        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Maybe propagate?
         Box::new(
             self.iter_values()
                 .filter(|key| !excluded.contains((*key).borrow()))
-                .flat_map(move |key| self.get_iterator(key.borrow(), &hw_counter).copied())
+                .flat_map(move |key| self.get_iterator(key.borrow(), hw_counter).copied())
                 .unique(),
         )
     }
@@ -516,31 +527,25 @@ impl PayloadFieldIndex for MapIndex<str> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_acc: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
-                ValueVariants::String(keyword) => {
-                    let hw_counter = hw_acc.get_counter_cell();
-                    Some(Box::new(
-                        self.get_iterator(keyword.as_str(), &hw_counter).copied(),
-                    ))
-                }
+                ValueVariants::String(keyword) => Some(Box::new(
+                    self.get_iterator(keyword.as_str(), hw_counter).copied(),
+                )),
                 ValueVariants::Integer(_) => None,
                 ValueVariants::Bool(_) => None,
             },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
-                AnyVariants::Strings(keywords) => {
-                    let hw_counter = hw_acc.get_counter_cell();
-                    Some(Box::new(
-                        keywords
-                            .iter()
-                            .flat_map(move |keyword| {
-                                self.get_iterator(keyword.as_str(), &hw_counter).copied()
-                            })
-                            .unique(),
-                    ))
-                }
+                AnyVariants::Strings(keywords) => Some(Box::new(
+                    keywords
+                        .iter()
+                        .flat_map(move |keyword| {
+                            self.get_iterator(keyword.as_str(), hw_counter).copied()
+                        })
+                        .unique(),
+                )),
                 AnyVariants::Integers(integers) => {
                     if integers.is_empty() {
                         Some(Box::new(iter::empty()))
@@ -550,7 +555,7 @@ impl PayloadFieldIndex for MapIndex<str> {
                 }
             },
             Some(Match::Except(MatchExcept { except })) => match except {
-                AnyVariants::Strings(keywords) => Some(self.except_set(keywords)),
+                AnyVariants::Strings(keywords) => Some(self.except_set(keywords, hw_counter)),
                 AnyVariants::Integers(other) => {
                     if other.is_empty() {
                         Some(Box::new(iter::empty()))
@@ -563,11 +568,15 @@ impl PayloadFieldIndex for MapIndex<str> {
         }
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(keyword) => {
-                    let mut estimation = self.match_cardinality(keyword.as_str());
+                    let mut estimation = self.match_cardinality(keyword.as_str(), hw_counter);
                     estimation
                         .primary_clauses
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
@@ -580,7 +589,7 @@ impl PayloadFieldIndex for MapIndex<str> {
                 AnyVariants::Strings(keywords) => {
                     let estimations = keywords
                         .iter()
-                        .map(|keyword| self.match_cardinality(keyword.as_str()))
+                        .map(|keyword| self.match_cardinality(keyword.as_str(), hw_counter))
                         .collect::<Vec<_>>();
                     let estimation = if estimations.is_empty() {
                         CardinalityEstimation::exact(0)
@@ -605,7 +614,7 @@ impl PayloadFieldIndex for MapIndex<str> {
             },
             Some(Match::Except(MatchExcept { except })) => match except {
                 AnyVariants::Strings(keywords) => {
-                    Some(self.except_cardinality(keywords.iter().map(|k| k.as_str())))
+                    Some(self.except_cardinality(keywords.iter().map(|k| k.as_str()), hw_counter))
                 }
                 AnyVariants::Integers(others) => {
                     if others.is_empty() {
@@ -628,7 +637,13 @@ impl PayloadFieldIndex for MapIndex<str> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
+                .map(|value| {
+                    (
+                        value,
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Payload_blocks only used in HNSW building, which is unmeasured.
+                            .unwrap_or(0),
+                    )
+                })
                 .filter(move |(_value, count)| *count > threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
                     condition: FieldCondition::new_match(key.clone(), value.to_string().into()),
@@ -662,15 +677,14 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_acc: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(uuid_string) => {
                     let uuid = Uuid::from_str(uuid_string).ok()?;
-                    let hw_counter = hw_acc.get_counter_cell();
                     Some(Box::new(
-                        self.get_iterator(&uuid.as_u128(), &hw_counter).copied(),
+                        self.get_iterator(&uuid.as_u128(), hw_counter).copied(),
                     ))
                 }
                 ValueVariants::Integer(_) => None,
@@ -678,7 +692,6 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
             },
             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {
                 AnyVariants::Strings(uuids_string) => {
-                    let hw_counter = hw_acc.get_counter_cell();
                     let uuids: Result<IndexSet<u128>, _> = uuids_string
                         .iter()
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
@@ -689,7 +702,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                     Some(Box::new(
                         uuids
                             .into_iter()
-                            .flat_map(move |uuid| self.get_iterator(&uuid, &hw_counter).copied())
+                            .flat_map(move |uuid| self.get_iterator(&uuid, hw_counter).copied())
                             .unique(),
                     ))
                 }
@@ -708,13 +721,11 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
                         .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))
                         .collect();
 
-                    let hw_counter = hw_acc.get_counter_cell();
-
                     let excluded_uuids = uuids.ok()?;
                     let exclude_iter = self
                         .iter_values()
                         .filter(move |key| !excluded_uuids.contains(*key))
-                        .flat_map(move |key| self.get_iterator(key, &hw_counter).copied())
+                        .flat_map(move |key| self.get_iterator(key, hw_counter).copied())
                         .unique();
                     Some(Box::new(exclude_iter))
                 }
@@ -730,12 +741,16 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
         }
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(uuid_string) => {
                     let uuid = Uuid::from_str(uuid_string).ok()?;
-                    let mut estimation = self.match_cardinality(&uuid.as_u128());
+                    let mut estimation = self.match_cardinality(&uuid.as_u128(), hw_counter);
                     estimation
                         .primary_clauses
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
@@ -755,7 +770,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
 
                     let estimations = uuids
                         .into_iter()
-                        .map(|uuid| self.match_cardinality(&uuid))
+                        .map(|uuid| self.match_cardinality(&uuid, hw_counter))
                         .collect::<Vec<_>>();
                     let estimation = if estimations.is_empty() {
                         CardinalityEstimation::exact(0)
@@ -787,7 +802,7 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
 
                     let excluded_uuids = uuids.ok()?;
 
-                    Some(self.except_cardinality(excluded_uuids.iter()))
+                    Some(self.except_cardinality(excluded_uuids.iter(), hw_counter))
                 }
                 AnyVariants::Integers(other) => {
                     if other.is_empty() {
@@ -810,7 +825,13 @@ impl PayloadFieldIndex for MapIndex<UuidIntType> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
+                .map(move |value| {
+                    (
+                        value,
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // payload_blocks only used in HNSW building, which is unmeasured.
+                            .unwrap_or(0),
+                    )
+                })
                 .filter(move |(_value, count)| *count >= threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
                     condition: FieldCondition::new_match(
@@ -847,14 +868,13 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     fn filter<'a>(
         &'a self,
         condition: &'a FieldCondition,
-        hw_acc: HwMeasurementAcc,
+        hw_counter: &'a HardwareCounterCell,
     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(_) => None,
                 ValueVariants::Integer(integer) => {
-                    let hw_counter = hw_acc.get_counter_cell();
-                    Some(Box::new(self.get_iterator(integer, &hw_counter).copied()))
+                    Some(Box::new(self.get_iterator(integer, hw_counter).copied()))
                 }
                 ValueVariants::Bool(_) => None,
             },
@@ -866,17 +886,12 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         None
                     }
                 }
-                AnyVariants::Integers(integers) => {
-                    let hw_counter = hw_acc.get_counter_cell();
-                    Some(Box::new(
-                        integers
-                            .iter()
-                            .flat_map(move |integer| {
-                                self.get_iterator(integer, &hw_counter).copied()
-                            })
-                            .unique(),
-                    ))
-                }
+                AnyVariants::Integers(integers) => Some(Box::new(
+                    integers
+                        .iter()
+                        .flat_map(move |integer| self.get_iterator(integer, hw_counter).copied())
+                        .unique(),
+                )),
             },
             Some(Match::Except(MatchExcept { except })) => match except {
                 AnyVariants::Strings(other) => {
@@ -886,18 +901,22 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         None
                     }
                 }
-                AnyVariants::Integers(integers) => Some(self.except_set(integers)),
+                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),
             },
             _ => None,
         }
     }
 
-    fn estimate_cardinality(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {
+    fn estimate_cardinality(
+        &self,
+        condition: &FieldCondition,
+        hw_counter: &HardwareCounterCell,
+    ) -> Option<CardinalityEstimation> {
         match &condition.r#match {
             Some(Match::Value(MatchValue { value })) => match value {
                 ValueVariants::String(_) => None,
                 ValueVariants::Integer(integer) => {
-                    let mut estimation = self.match_cardinality(integer);
+                    let mut estimation = self.match_cardinality(integer, hw_counter);
                     estimation
                         .primary_clauses
                         .push(PrimaryCondition::Condition(Box::new(condition.clone())));
@@ -918,7 +937,7 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                 AnyVariants::Integers(integers) => {
                     let estimations = integers
                         .iter()
-                        .map(|integer| self.match_cardinality(integer))
+                        .map(|integer| self.match_cardinality(integer, hw_counter))
                         .collect::<Vec<_>>();
                     let estimation = if estimations.is_empty() {
                         CardinalityEstimation::exact(0)
@@ -942,7 +961,9 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
                         None
                     }
                 }
-                AnyVariants::Integers(integers) => Some(self.except_cardinality(integers.iter())),
+                AnyVariants::Integers(integers) => {
+                    Some(self.except_cardinality(integers.iter(), hw_counter))
+                }
             },
             _ => None,
         }
@@ -955,7 +976,13 @@ impl PayloadFieldIndex for MapIndex<IntPayloadType> {
     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {
         Box::new(
             self.iter_values()
-                .map(|value| (value, self.get_count_for_value(value).unwrap_or(0)))
+                .map(move |value| {
+                    (
+                        value,
+                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Only used in HNSW building so no measurement needed here.
+                            .unwrap_or(0),
+                    )
+                })
                 .filter(move |(_value, count)| *count >= threshold)
                 .map(move |(value, count)| PayloadBlockCondition {
                     condition: FieldCondition::new_match(key.clone(), (*value).into()),
@@ -985,8 +1012,12 @@ where
         self.iter_values().map(Into::into)
     }
 
-    fn iter_values_map(&self) -> impl Iterator<Item = (FacetValueRef, IdIter<'_>)> + '_ {
-        self.iter_values_map().map(|(k, iter)| (k.into(), iter))
+    fn iter_values_map(
+        &self,
+        hw_acc: HwMeasurementAcc,
+    ) -> impl Iterator<Item = (FacetValueRef, IdIter<'_>)> + '_ {
+        self.iter_values_map(hw_acc)
+            .map(|(k, iter)| (k.into(), iter))
     }
 
     fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {
@@ -1211,10 +1242,12 @@ mod tests {
         save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());
         let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);
 
+        let hw_counter = HardwareCounterCell::new();
+
         // Ensure cardinality is non zero
         assert!(
             !index
-                .except_cardinality(vec![].into_iter())
+                .except_cardinality(vec![].into_iter(), &hw_counter)
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
         );
     }
@@ -1252,10 +1285,12 @@ mod tests {
         save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
+        let hw_counter = HardwareCounterCell::new();
+
         // Ensure cardinality is non zero
         assert!(
             !index
-                .except_cardinality(vec![].into_iter())
+                .except_cardinality(vec![].into_iter(), &hw_counter)
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
         );
     }
@@ -1271,10 +1306,12 @@ mod tests {
         save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());
         let index = load_map_index::<str>(&data, temp_dir.path(), index_type);
 
+        let hw_counter = HardwareCounterCell::new();
+
         // Ensure cardinality is zero
         assert!(
             index
-                .except_cardinality(vec![].into_iter())
+                .except_cardinality(vec![].into_iter(), &hw_counter)
                 .equals_min_exp_max(&CardinalityEstimation::exact(0)),
         );
     }

commit 13f0a87c80cd25a85bac907c7eee53f8c55f048e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 17 20:38:54 2025 +0100

    Mmap in-ram payload indexes without RocksDB (#6148)
    
    * refactor IndexSelector to support mmap with populate
    
    * specify populate flag DynamicMmapFlags
    
    * replace db+flag with enum StorageType
    
    * fix flag
    
    * disable by default
    
    * clippy
    
    * remove outdated comment
    
    * remove comment
    
    * Update lib/segment/src/index/field_index/bool_index/mmap_bool_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index db67b96fe..f3fb8b423 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -91,19 +91,22 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn new_mmap(path: &Path) -> OperationResult<Self> {
-        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path)?)))
+    pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {
+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(
+            path, is_on_disk,
+        )?)))
     }
 
     pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {
         MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))
     }
 
-    pub fn mmap_builder(path: &Path) -> MapIndexMmapBuilder<N> {
+    pub fn mmap_builder(path: &Path, is_on_disk: bool) -> MapIndexMmapBuilder<N> {
         MapIndexMmapBuilder {
             path: path.to_owned(),
             point_to_values: Default::default(),
             values_to_points: Default::default(),
+            is_on_disk,
         }
     }
 
@@ -462,6 +465,7 @@ pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {
     path: PathBuf,
     point_to_values: Vec<Vec<N::Owned>>,
     values_to_points: HashMap<N::Owned, Vec<PointOffsetType>>,
+    is_on_disk: bool,
 }
 
 impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexMmapBuilder<N>
@@ -499,6 +503,7 @@ where
             &self.path,
             self.point_to_values,
             self.values_to_points,
+            self.is_on_disk,
         )?)))
     }
 }
@@ -1157,7 +1162,7 @@ mod tests {
                 builder.finalize().unwrap();
             }
             IndexType::Mmap => {
-                let mut builder = MapIndex::<N>::mmap_builder(path);
+                let mut builder = MapIndex::<N>::mmap_builder(path, false);
                 builder.init().unwrap();
                 for (idx, values) in data.iter().enumerate() {
                     let values: Vec<Value> = values.iter().map(&into_value).collect();
@@ -1183,7 +1188,7 @@ mod tests {
                 FIELD_NAME,
                 false,
             ),
-            IndexType::Mmap => MapIndex::<N>::new_mmap(path).unwrap(),
+            IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),
         };
         index.load_from_db().unwrap();
         for (idx, values) in data.iter().enumerate() {
@@ -1203,7 +1208,7 @@ mod tests {
     #[test]
     fn test_index_non_ascending_insertion() {
         let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();
-        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path());
+        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path(), false);
         builder.init().unwrap();
 
         let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];

commit 5f49aa746f254d1f6afda7ed701a8c64585f75ec
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Mar 19 10:37:32 2025 +0100

    Payload Index Io measurements with Iterator (#6132)
    
    * IteratorExt helper functions for Hw Measurements + Some impls
    
    * More index impls; Performance improvements; Use new iterator
    
    * Add missing measurement in hnsw search. Use disposable flag in HwCounterCell too
    
    * use precomputed counts more
    
    * Review nits
    
    * Fix measurement of map_index iter_values_map
    
    * Review remarks
    
    * fix OnFinalCount
    
    * remove comment
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index f3fb8b423..94337711e 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -7,7 +7,6 @@ use std::str::FromStr;
 use std::sync::Arc;
 
 use ahash::HashMap;
-use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::mmap_hashmap::Key;
 use common::types::PointOffsetType;
@@ -211,14 +210,14 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         }
     }
 
-    pub fn iter_values_map(
-        &self,
-        hw_acc: HwMeasurementAcc,
-    ) -> Box<dyn Iterator<Item = (&N, IdIter<'_>)> + '_> {
+    pub fn iter_values_map<'a>(
+        &'a self,
+        hw_cell: &'a HardwareCounterCell,
+    ) -> Box<dyn Iterator<Item = (&'a N, IdIter<'a>)> + 'a> {
         match self {
-            MapIndex::Mutable(index) => Box::new(index.iter_values_map(hw_acc)),
-            MapIndex::Immutable(index) => Box::new(index.iter_values_map(hw_acc)),
-            MapIndex::Mmap(index) => Box::new(index.iter_values_map(hw_acc)),
+            MapIndex::Mutable(index) => Box::new(index.iter_values_map(hw_cell)),
+            MapIndex::Immutable(index) => Box::new(index.iter_values_map(hw_cell)),
+            MapIndex::Mmap(index) => Box::new(index.iter_values_map(hw_cell)),
         }
     }
 
@@ -1017,11 +1016,11 @@ where
         self.iter_values().map(Into::into)
     }
 
-    fn iter_values_map(
-        &self,
-        hw_acc: HwMeasurementAcc,
-    ) -> impl Iterator<Item = (FacetValueRef, IdIter<'_>)> + '_ {
-        self.iter_values_map(hw_acc)
+    fn iter_values_map<'a>(
+        &'a self,
+        hw_counter: &'a HardwareCounterCell,
+    ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {
+        self.iter_values_map(hw_counter)
             .map(|(k, iter)| (k.into(), iter))
     }
 

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 94337711e..39c29f5d2 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -1,4 +1,5 @@
 use std::borrow::Borrow;
+use std::collections::hash_map::Entry;
 use std::fmt::{Debug, Display};
 use std::hash::{BuildHasher, Hash};
 use std::iter;
@@ -451,8 +452,13 @@ where
         }
     }
 
-    fn add_point(&mut self, id: PointOffsetType, values: &[&Value]) -> OperationResult<()> {
-        self.0.add_point(id, values)
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        values: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
+        self.0.add_point(id, values, hw_counter)
     }
 
     fn finalize(self) -> OperationResult<Self::FieldIndexType> {
@@ -478,7 +484,12 @@ where
         Ok(())
     }
 
-    fn add_point(&mut self, id: PointOffsetType, payload: &[&Value]) -> OperationResult<()> {
+    fn add_point(
+        &mut self,
+        id: PointOffsetType,
+        payload: &[&Value],
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         let mut flatten_values: Vec<_> = vec![];
         for value in payload.iter() {
             let payload_values = <MapIndex<N> as ValueIndexer>::get_values(value);
@@ -491,9 +502,25 @@ where
         }
 
         self.point_to_values[id as usize].extend(flatten_values.clone());
+
+        let mut hw_counter_val = 0;
+
         for value in flatten_values {
-            self.values_to_points.entry(value).or_default().push(id);
+            let entry = self.values_to_points.entry(value);
+
+            if let Entry::Vacant(e) = &entry {
+                let size = N::mmapped_size(N::as_referenced(e.key().borrow()));
+                hw_counter_val += size;
+            }
+
+            hw_counter_val += size_of_val(&id);
+            entry.or_default().push(id);
         }
+
+        hw_counter
+            .payload_index_io_write_counter()
+            .incr_delta(hw_counter_val);
+
         Ok(())
     }
 
@@ -1035,9 +1062,14 @@ where
 impl ValueIndexer for MapIndex<str> {
     type ValueType = String;
 
-    fn add_many(&mut self, id: PointOffsetType, values: Vec<String>) -> OperationResult<()> {
+    fn add_many(
+        &mut self,
+        id: PointOffsetType,
+        values: Vec<String>,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         match self {
-            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
             MapIndex::Immutable(_) => Err(OperationError::service_error(
                 "Can't add values to immutable map index",
             )),
@@ -1066,9 +1098,10 @@ impl ValueIndexer for MapIndex<IntPayloadType> {
         &mut self,
         id: PointOffsetType,
         values: Vec<IntPayloadType>,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
         match self {
-            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
             MapIndex::Immutable(_) => Err(OperationError::service_error(
                 "Can't add values to immutable map index",
             )),
@@ -1097,9 +1130,10 @@ impl ValueIndexer for MapIndex<UuidIntType> {
         &mut self,
         id: PointOffsetType,
         values: Vec<Self::ValueType>,
+        hw_counter: &HardwareCounterCell,
     ) -> OperationResult<()> {
         match self {
-            MapIndex::Mutable(index) => index.add_many_to_map(id, values),
+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),
             MapIndex::Immutable(_) => Err(OperationError::service_error(
                 "Can't add values to immutable map index",
             )),
@@ -1148,6 +1182,8 @@ mod tests {
         MapIndex<N>: PayloadFieldIndex + ValueIndexer,
         <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,
     {
+        let hw_counter = HardwareCounterCell::new();
+
         match index_type {
             IndexType::Mutable | IndexType::Immutable => {
                 let mut builder =
@@ -1156,7 +1192,9 @@ mod tests {
                 for (idx, values) in data.iter().enumerate() {
                     let values: Vec<Value> = values.iter().map(&into_value).collect();
                     let values: Vec<_> = values.iter().collect();
-                    builder.add_point(idx as PointOffsetType, &values).unwrap();
+                    builder
+                        .add_point(idx as PointOffsetType, &values, &hw_counter)
+                        .unwrap();
                 }
                 builder.finalize().unwrap();
             }
@@ -1166,7 +1204,9 @@ mod tests {
                 for (idx, values) in data.iter().enumerate() {
                     let values: Vec<Value> = values.iter().map(&into_value).collect();
                     let values: Vec<_> = values.iter().collect();
-                    builder.add_point(idx as PointOffsetType, &values).unwrap();
+                    builder
+                        .add_point(idx as PointOffsetType, &values, &hw_counter)
+                        .unwrap();
                 }
                 builder.finalize().unwrap();
             }
@@ -1212,10 +1252,14 @@ mod tests {
 
         let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];
 
+        let hw_counter = HardwareCounterCell::new();
+
         for (idx, values) in data.iter().enumerate().rev() {
             let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();
             let values: Vec<_> = values.iter().collect();
-            builder.add_point(idx as PointOffsetType, &values).unwrap();
+            builder
+                .add_point(idx as PointOffsetType, &values, &hw_counter)
+                .unwrap();
         }
 
         let index = builder.finalize().unwrap();

commit dcd5674ebb5b096b882189599bfb5eea13d241dd
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Apr 3 20:09:29 2025 +0200

    Writeback counter cell (#6190)
    
    * Add WritebackCounterCell
    
    * Replace custom counting with WritebackCounterCell
    
    * Update lib/common/common/src/counter/counter_cell.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 39c29f5d2..4d46e5c20 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -503,24 +503,22 @@ where
 
         self.point_to_values[id as usize].extend(flatten_values.clone());
 
-        let mut hw_counter_val = 0;
+        let mut hw_cell_wb = hw_counter
+            .payload_index_io_write_counter()
+            .write_back_counter();
 
         for value in flatten_values {
             let entry = self.values_to_points.entry(value);
 
             if let Entry::Vacant(e) = &entry {
                 let size = N::mmapped_size(N::as_referenced(e.key().borrow()));
-                hw_counter_val += size;
+                hw_cell_wb.incr_delta(size);
             }
 
-            hw_counter_val += size_of_val(&id);
+            hw_cell_wb.incr_delta(size_of_val(&id));
             entry.or_default().push(id);
         }
 
-        hw_counter
-            .payload_index_io_write_counter()
-            .incr_delta(hw_counter_val);
-
         Ok(())
     }
 

commit 231d579f708c59a2ceeb5a75136ef2de10641b22
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Apr 3 20:57:03 2025 +0200

    Don't measure in memory geo, map and numeric indices (#6311)

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 4d46e5c20..0dbf24644 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -126,8 +126,8 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         check_fn: impl Fn(&N) -> bool,
     ) -> bool {
         match self {
-            MapIndex::Mutable(index) => index.check_values_any(idx, hw_counter, check_fn),
-            MapIndex::Immutable(index) => index.check_values_any(idx, hw_counter, check_fn),
+            MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),
+            MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),
             MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),
         }
     }
@@ -181,16 +181,16 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
 
     fn get_count_for_value(&self, value: &N, hw_counter: &HardwareCounterCell) -> Option<usize> {
         match self {
-            MapIndex::Mutable(index) => index.get_count_for_value(value, hw_counter),
-            MapIndex::Immutable(index) => index.get_count_for_value(value, hw_counter),
+            MapIndex::Mutable(index) => index.get_count_for_value(value),
+            MapIndex::Immutable(index) => index.get_count_for_value(value),
             MapIndex::Mmap(index) => index.get_count_for_value(value, hw_counter),
         }
     }
 
     fn get_iterator(&self, value: &N, hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {
         match self {
-            MapIndex::Mutable(index) => index.get_iterator(value, hw_counter),
-            MapIndex::Immutable(index) => index.get_iterator(value, hw_counter),
+            MapIndex::Mutable(index) => index.get_iterator(value),
+            MapIndex::Immutable(index) => index.get_iterator(value),
             MapIndex::Mmap(index) => index.get_iterator(value, hw_counter),
         }
     }
@@ -216,8 +216,8 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
         hw_cell: &'a HardwareCounterCell,
     ) -> Box<dyn Iterator<Item = (&'a N, IdIter<'a>)> + 'a> {
         match self {
-            MapIndex::Mutable(index) => Box::new(index.iter_values_map(hw_cell)),
-            MapIndex::Immutable(index) => Box::new(index.iter_values_map(hw_cell)),
+            MapIndex::Mutable(index) => Box::new(index.iter_values_map()),
+            MapIndex::Immutable(index) => Box::new(index.iter_values_map()),
             MapIndex::Mmap(index) => Box::new(index.iter_values_map(hw_cell)),
         }
     }

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index 0dbf24644..f702c55fc 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -434,6 +434,35 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
                 .unique(),
         )
     }
+
+    pub fn is_on_disk(&self) -> bool {
+        match self {
+            MapIndex::Mutable(_) => false,
+            MapIndex::Immutable(_) => false,
+            MapIndex::Mmap(index) => index.is_on_disk(),
+        }
+    }
+
+    /// Populate all pages in the mmap.
+    /// Block until all pages are populated.
+    pub fn populate(&self) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(_) => {}   // Not a mmap
+            MapIndex::Immutable(_) => {} // Not a mmap
+            MapIndex::Mmap(index) => index.populate()?,
+        }
+        Ok(())
+    }
+
+    /// Drop disk cache.
+    pub fn clear_cache(&self) -> OperationResult<()> {
+        match self {
+            MapIndex::Mutable(_) => {}   // Not a mmap
+            MapIndex::Immutable(_) => {} // Not a mmap
+            MapIndex::Mmap(index) => index.clear_cache()?,
+        }
+        Ok(())
+    }
 }
 
 pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);

commit a9795f7ce495c5d19aa2078dc957625f6c9b8d51
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 15 16:58:38 2025 +0200

    faster mmap numeric index (#6381)
    
    * wip: attempt to investigate slow mmap numeric index
    
    * fmt
    
    * Improve performance of ConditionedCounter (#6384)
    
    * Improve Performance of ConditionedCounter
    
    * Remove unneeded hw_counter from signatures
    
    * Clippy
    
    * Fix Clippy II
    
    * Fix Clippy III
    
    * Fix Clippy IV
    
    * Use static string, don't allocate string
    
    * Remove allow dead code attribute
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/index/field_index/map_index/mod.rs b/lib/segment/src/index/field_index/map_index/mod.rs
index f702c55fc..7de8b2e38 100644
--- a/lib/segment/src/index/field_index/map_index/mod.rs
+++ b/lib/segment/src/index/field_index/map_index/mod.rs
@@ -250,6 +250,11 @@ impl<N: MapIndexKey + ?Sized> MapIndex<N> {
             points_count: self.get_indexed_points(),
             points_values_count: self.get_values_count(),
             histogram_bucket_size: None,
+            index_type: match self {
+                MapIndex::Mutable(_) => "mutable_map",
+                MapIndex::Immutable(_) => "immutable_map",
+                MapIndex::Mmap(_) => "mmap_map",
+            },
         }
     }
 

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    