<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/spaces/simple.rs - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/spaces/simple.rs</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../../cases/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_spaces_simple.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/spaces/simple.rs

commit 73913ea61badae80937d44f65593830b79570955
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 23 17:26:20 2020 +0200

    move segment into separate crate

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
new file mode 100644
index 000000000..19680b4cf
--- /dev/null
+++ b/lib/segment/src/spaces/simple.rs
@@ -0,0 +1,40 @@
+use super::metric::Metric;
+use crate::types::ScoreType;
+
+pub struct DotProductMetric {}
+
+pub struct CosineMetric {}
+
+impl Metric<f32> for DotProductMetric {
+    fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
+        let ip: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+        return ip
+    }
+
+    fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
+        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    }
+
+    fn preprocess(&self, vector: Vec<f32>) -> Vec<f32> {
+        return vector;
+    }
+}
+
+
+impl Metric<f32> for CosineMetric {
+    fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
+        let cos: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+        return cos
+    }
+
+    fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
+        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    }
+
+    fn preprocess(&self, vector: Vec<f32>) -> Vec<f32> {
+        let length: f32 = vector.iter().map(|x| x * x).sum();
+        let norm_vector = vector.iter().map(|x| x / length).collect();
+        return norm_vector;
+    }
+}
+

commit 7cb939d6e04b3666aafca15e9432e282b7a7ef95
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 30 22:03:39 2020 +0200

    store multiple values of payload

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 19680b4cf..9400b0997 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -38,3 +38,37 @@ impl Metric<f32> for CosineMetric {
     }
 }
 
+
+impl Metric<f64> for DotProductMetric {
+    fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
+        let ip: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+        return ip as f32
+    }
+
+    fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {
+        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    }
+
+    fn preprocess(&self, vector: Vec<f64>) -> Vec<f64> {
+        return vector;
+    }
+}
+
+
+impl Metric<f64> for CosineMetric {
+    fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
+        let cos: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+        return cos as f32
+    }
+
+    fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {
+        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    }
+
+    fn preprocess(&self, vector: Vec<f64>) -> Vec<f64> {
+        let length: f64 = vector.iter().map(|x| x * x).sum();
+        let norm_vector = vector.iter().map(|x| x / length).collect();
+        return norm_vector;
+    }
+}
+

commit 03c86e7f655b5d8440628eb25885d654d43a6499
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jul 6 23:50:21 2020 +0200

    add simple segment builder

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 9400b0997..43a103e08 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,14 +1,18 @@
 use super::metric::Metric;
-use crate::types::ScoreType;
+use crate::types::{ScoreType, Distance};
 
 pub struct DotProductMetric {}
 
 pub struct CosineMetric {}
 
 impl Metric<f32> for DotProductMetric {
+    fn distance(&self) -> Distance {
+        Distance::Dot
+    }
+
     fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
         let ip: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return ip
+        return ip;
     }
 
     fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
@@ -20,11 +24,14 @@ impl Metric<f32> for DotProductMetric {
     }
 }
 
-
 impl Metric<f32> for CosineMetric {
+    fn distance(&self) -> Distance {
+        Distance::Cosine
+    }
+
     fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
         let cos: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return cos
+        return cos;
     }
 
     fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
@@ -40,9 +47,14 @@ impl Metric<f32> for CosineMetric {
 
 
 impl Metric<f64> for DotProductMetric {
+    fn distance(&self) -> Distance {
+        Distance::Dot
+    }
+
+
     fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
         let ip: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return ip as f32
+        return ip as f32;
     }
 
     fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {
@@ -56,9 +68,13 @@ impl Metric<f64> for DotProductMetric {
 
 
 impl Metric<f64> for CosineMetric {
+    fn distance(&self) -> Distance {
+        Distance::Cosine
+    }
+
     fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
         let cos: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return cos as f32
+        return cos as f32;
     }
 
     fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {

commit 8a85c109345708b6af14604fa212567aaea61c2a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 4 22:59:22 2021 +0100

    use BLAS for vector dot production

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 43a103e08..87757a722 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,90 +1,49 @@
+use ndarray::Array1;
+
+use crate::types::{Distance, ScoreType, VectorElementType};
+
 use super::metric::Metric;
-use crate::types::{ScoreType, Distance};
 
 pub struct DotProductMetric {}
 
 pub struct CosineMetric {}
 
-impl Metric<f32> for DotProductMetric {
+impl Metric for DotProductMetric {
     fn distance(&self) -> Distance {
         Distance::Dot
     }
 
-    fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
+    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         let ip: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
         return ip;
     }
 
-    fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
-        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
+        v1.dot(v2)
     }
 
-    fn preprocess(&self, vector: Vec<f32>) -> Vec<f32> {
+    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
         return vector;
     }
 }
 
-impl Metric<f32> for CosineMetric {
+impl Metric for CosineMetric {
     fn distance(&self) -> Distance {
         Distance::Cosine
     }
 
-    fn similarity(&self, v1: &[f32], v2: &[f32]) -> ScoreType {
-        let cos: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+        let cos: VectorElementType = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
         return cos;
     }
 
-    fn similarity_batch(&self, vector: &[f32], other_vectors: &[&[f32]]) -> Vec<ScoreType> {
-        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
+    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
+        v1.dot(v2)
     }
 
-    fn preprocess(&self, vector: Vec<f32>) -> Vec<f32> {
+    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
         let length: f32 = vector.iter().map(|x| x * x).sum();
         let norm_vector = vector.iter().map(|x| x / length).collect();
         return norm_vector;
     }
 }
-
-
-impl Metric<f64> for DotProductMetric {
-    fn distance(&self) -> Distance {
-        Distance::Dot
-    }
-
-
-    fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
-        let ip: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return ip as f32;
-    }
-
-    fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {
-        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
-    }
-
-    fn preprocess(&self, vector: Vec<f64>) -> Vec<f64> {
-        return vector;
-    }
-}
-
-
-impl Metric<f64> for CosineMetric {
-    fn distance(&self) -> Distance {
-        Distance::Cosine
-    }
-
-    fn similarity(&self, v1: &[f64], v2: &[f64]) -> ScoreType {
-        let cos: f64 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return cos as f32;
-    }
-
-    fn similarity_batch(&self, vector: &[f64], other_vectors: &[&[f64]]) -> Vec<ScoreType> {
-        other_vectors.iter().map(|v2| self.similarity(vector, *v2)).collect()
-    }
-
-    fn preprocess(&self, vector: Vec<f64>) -> Vec<f64> {
-        let length: f64 = vector.iter().map(|x| x * x).sum();
-        let norm_vector = vector.iter().map(|x| x / length).collect();
-        return norm_vector;
-    }
-}
-

commit 3616631300ab6d2b2a2cefb002ff567448710e06
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun May 30 17:14:42 2021 +0200

    Filtrable hnsw (#26)
    
    * raw points scorer
    
    * raw point scorer for memmap storage
    
    * search interface prepare
    
    * graph binary saving + store PointOffsetId as u32
    
    * WIP: entry points
    
    * connect new link method
    
    * update libs + search layer method + visited list + search context + update rust
    
    * implement Euclid metric + always use MinHeap for priority queue
    
    * small refactor
    
    * search for 0 level entry
    
    * update visited pool to be lock free and thread safe
    
    * use ef_construct from graph layer struct + limit visited links to M
    
    * add metric pre-processing before on vector upsert
    
    * old hnsw heuristic
    
    * save hnsw graph for export
    
    * search method + tests
    
    * small fixes
    
    * add benchmark and profiler
    
    * build time optimizations
    
    * use SeaHash
    
    * remove unsed benchmark
    
    * merge hnsw graph function
    
    * WIP:HNSW index build function
    
    * HNSW build_index with additional indexing
    
    * refactor fixtures
    
    * graph save and load test
    
    * test and fixes for filterable HNSW
    
    * enable hnsw index for query planning
    
    * fix cardinality estimation tests + remove query planner as class
    
    * small refactor
    
    * store full copy of collection settings with collection + allow partial override on creation #16
    
    * API for updating collection parameters #16
    
    * refactor: move collection error -> types
    
    * report collection status in info API #17
    
    * update OpenAPI Schema

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 87757a722..74ca0c52d 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,3 +1,5 @@
+extern crate blas_src;
+
 use ndarray::Array1;
 
 use crate::types::{Distance, ScoreType, VectorElementType};
@@ -8,13 +10,34 @@ pub struct DotProductMetric {}
 
 pub struct CosineMetric {}
 
+pub struct EuclidMetric {}
+
+
+impl Metric for EuclidMetric {
+    fn distance(&self) -> Distance { Distance::Euclid }
+
+    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+        let s: ScoreType = v1.iter().cloned().zip(v2.iter().cloned()).map(|(a, b)| (a - b).powi(2)).sum();
+        return -s.sqrt();
+    }
+
+    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
+        let s: ScoreType = v1.iter().cloned().zip(v2.iter().cloned()).map(|(a, b)| (a - b).powi(2)).sum();
+        return -s.sqrt();
+    }
+
+    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
+        return vector;
+    }
+}
+
 impl Metric for DotProductMetric {
     fn distance(&self) -> Distance {
         Distance::Dot
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        let ip: f32 = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
+        let ip: ScoreType = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
         return ip;
     }
 
@@ -42,7 +65,8 @@ impl Metric for CosineMetric {
     }
 
     fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
-        let length: f32 = vector.iter().map(|x| x * x).sum();
+        let mut length: f32 = vector.iter().map(|x| x * x).sum();
+        length = length.sqrt();
         let norm_vector = vector.iter().map(|x| x / length).collect();
         return norm_vector;
     }

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 74ca0c52d..62e6817f0 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -12,17 +12,32 @@ pub struct CosineMetric {}
 
 pub struct EuclidMetric {}
 
-
 impl Metric for EuclidMetric {
-    fn distance(&self) -> Distance { Distance::Euclid }
+    fn distance(&self) -> Distance {
+        Distance::Euclid
+    }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        let s: ScoreType = v1.iter().cloned().zip(v2.iter().cloned()).map(|(a, b)| (a - b).powi(2)).sum();
+        let s: ScoreType = v1
+            .iter()
+            .cloned()
+            .zip(v2.iter().cloned())
+            .map(|(a, b)| (a - b).powi(2))
+            .sum();
         return -s.sqrt();
     }
 
-    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
-        let s: ScoreType = v1.iter().cloned().zip(v2.iter().cloned()).map(|(a, b)| (a - b).powi(2)).sum();
+    fn blas_similarity(
+        &self,
+        v1: &Array1<VectorElementType>,
+        v2: &Array1<VectorElementType>,
+    ) -> ScoreType {
+        let s: ScoreType = v1
+            .iter()
+            .cloned()
+            .zip(v2.iter().cloned())
+            .map(|(a, b)| (a - b).powi(2))
+            .sum();
         return -s.sqrt();
     }
 
@@ -41,7 +56,11 @@ impl Metric for DotProductMetric {
         return ip;
     }
 
-    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
+    fn blas_similarity(
+        &self,
+        v1: &Array1<VectorElementType>,
+        v2: &Array1<VectorElementType>,
+    ) -> ScoreType {
         v1.dot(v2)
     }
 
@@ -60,7 +79,11 @@ impl Metric for CosineMetric {
         return cos;
     }
 
-    fn blas_similarity(&self, v1: &Array1<VectorElementType>, v2: &Array1<VectorElementType>) -> ScoreType {
+    fn blas_similarity(
+        &self,
+        v1: &Array1<VectorElementType>,
+        v2: &Array1<VectorElementType>,
+    ) -> ScoreType {
         v1.dot(v2)
     }
 

commit d796c9da42377f11ae15b6941baa53963bda27ab
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 14:17:04 2021 +0100

    Avoid useless vector copy during scoring (#51)
    
    * Avoid vector copy during scoring
    
    * Fixing ptr_arg clippy rules for &[VectorElementType]

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 62e6817f0..bfa012adb 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -24,7 +24,7 @@ impl Metric for EuclidMetric {
             .zip(v2.iter().cloned())
             .map(|(a, b)| (a - b).powi(2))
             .sum();
-        return -s.sqrt();
+        -s.sqrt()
     }
 
     fn blas_similarity(
@@ -38,11 +38,11 @@ impl Metric for EuclidMetric {
             .zip(v2.iter().cloned())
             .map(|(a, b)| (a - b).powi(2))
             .sum();
-        return -s.sqrt();
+        -s.sqrt()
     }
 
-    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
-        return vector;
+    fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+        None
     }
 }
 
@@ -52,8 +52,7 @@ impl Metric for DotProductMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        let ip: ScoreType = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return ip;
+        v1.iter().zip(v2).map(|(a, b)| a * b).sum()
     }
 
     fn blas_similarity(
@@ -64,8 +63,8 @@ impl Metric for DotProductMetric {
         v1.dot(v2)
     }
 
-    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
-        return vector;
+    fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+        None
     }
 }
 
@@ -75,8 +74,7 @@ impl Metric for CosineMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        let cos: VectorElementType = v1.iter().zip(v2).map(|(a, b)| a * b).sum();
-        return cos;
+        v1.iter().zip(v2).map(|(a, b)| a * b).sum()
     }
 
     fn blas_similarity(
@@ -87,10 +85,10 @@ impl Metric for CosineMetric {
         v1.dot(v2)
     }
 
-    fn preprocess(&self, vector: Vec<VectorElementType>) -> Vec<VectorElementType> {
+    fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         let mut length: f32 = vector.iter().map(|x| x * x).sum();
         length = length.sqrt();
         let norm_vector = vector.iter().map(|x| x / length).collect();
-        return norm_vector;
+        Some(norm_vector)
     }
 }

commit 6cab7f2a0b623d3eb69a1c224a3bba583d7e1a54
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Aug 29 23:31:55 2021 +0200

    dynamic arch (#79)
    
    * dynamic arch
    
    * fix fmt

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index bfa012adb..c51c4e9f2 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -92,3 +92,15 @@ impl Metric for CosineMetric {
         Some(norm_vector)
     }
 }
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_cosine_preprocessing() {
+        let metric = CosineMetric {};
+        let res = metric.preprocess(&vec![0.0, 0.0, 0.0, 0.0]);
+        eprintln!("res = {:#?}", res);
+    }
+}

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index c51c4e9f2..72940fb3a 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -100,7 +100,7 @@ mod tests {
     #[test]
     fn test_cosine_preprocessing() {
         let metric = CosineMetric {};
-        let res = metric.preprocess(&vec![0.0, 0.0, 0.0, 0.0]);
+        let res = metric.preprocess(&[0.0, 0.0, 0.0, 0.0]);
         eprintln!("res = {:#?}", res);
     }
 }

commit 297f54141d82fe4923847715a6253bb804f28022
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Jan 3 22:16:27 2022 +0300

    remove blas

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 72940fb3a..69b82081d 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,7 +1,3 @@
-extern crate blas_src;
-
-use ndarray::Array1;
-
 use crate::types::{Distance, ScoreType, VectorElementType};
 
 use super::metric::Metric;
@@ -27,20 +23,6 @@ impl Metric for EuclidMetric {
         -s.sqrt()
     }
 
-    fn blas_similarity(
-        &self,
-        v1: &Array1<VectorElementType>,
-        v2: &Array1<VectorElementType>,
-    ) -> ScoreType {
-        let s: ScoreType = v1
-            .iter()
-            .cloned()
-            .zip(v2.iter().cloned())
-            .map(|(a, b)| (a - b).powi(2))
-            .sum();
-        -s.sqrt()
-    }
-
     fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         None
     }
@@ -55,14 +37,6 @@ impl Metric for DotProductMetric {
         v1.iter().zip(v2).map(|(a, b)| a * b).sum()
     }
 
-    fn blas_similarity(
-        &self,
-        v1: &Array1<VectorElementType>,
-        v2: &Array1<VectorElementType>,
-    ) -> ScoreType {
-        v1.dot(v2)
-    }
-
     fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         None
     }
@@ -77,14 +51,6 @@ impl Metric for CosineMetric {
         v1.iter().zip(v2).map(|(a, b)| a * b).sum()
     }
 
-    fn blas_similarity(
-        &self,
-        v1: &Array1<VectorElementType>,
-        v2: &Array1<VectorElementType>,
-    ) -> ScoreType {
-        v1.dot(v2)
-    }
-
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         let mut length: f32 = vector.iter().map(|x| x * x).sum();
         length = length.sqrt();

commit 70e376bf5e1513cdca5f3e66a255d13925347427
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 00:32:13 2022 +0300

    add avx2 implementation

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 69b82081d..503bfdfa1 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,3 +1,9 @@
+#[cfg(target_arch = "x86")]
+use std::arch::x86::*;
+
+#[cfg(target_arch = "x86_64")]
+use std::arch::x86_64::*;
+
 use crate::types::{Distance, ScoreType, VectorElementType};
 
 use super::metric::Metric;
@@ -8,19 +14,88 @@ pub struct CosineMetric {}
 
 pub struct EuclidMetric {}
 
+fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let s: ScoreType = v1
+        .iter()
+        .cloned()
+        .zip(v2.iter().cloned())
+        .map(|(a, b)| (a - b).powi(2))
+        .sum();
+    -s.sqrt()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    unsafe {
+        let mut sum256: __m256 = _mm256_setzero_ps();
+        for i in (0..n).step_by(8) {
+            let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
+            sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
+        }
+        let res: f32 = hsum256_ps_avx(sum256);
+        for i in (n - (n % 8)..n) {
+            res += (v1[i] - v2[i]).powi(2);
+        }
+        -res.sqrt()
+    }
+}
+
+fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    v1.iter().zip(v2).map(|(a, b)| a * b).sum()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    unsafe {
+        let mut sum256: __m256 = _mm256_setzero_ps();
+        for i in (0..n).step_by(8) {
+            sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
+        }
+        let res: f32 = hsum256_ps_avx(sum256);
+        for i in (n - (n % 8)..n) {
+            res += v1[i] * v2[i];
+        }
+        res
+    }
+}
+
+fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let mut length: f32 = vector.iter().map(|x| x * x).sum();
+    length = length.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let length = unsafe {
+        let mut sum256: __m256 = _mm256_setzero_ps();
+        for i in (0..n).step_by(8) {
+            sum256 = _mm256_fmadd_ps(
+                _mm256_loadu_ps(&vector[i]),
+                _mm256_loadu_ps(&vector[i]), sum256);
+        }
+        let res: f32 = hsum256_ps_avx(sum256);
+        for i in (n - (n % 8)..n) {
+            res += vector[i].powi(2);
+        }
+        res
+    }.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
 impl Metric for EuclidMetric {
     fn distance(&self) -> Distance {
         Distance::Euclid
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        let s: ScoreType = v1
-            .iter()
-            .cloned()
-            .zip(v2.iter().cloned())
-            .map(|(a, b)| (a - b).powi(2))
-            .sum();
-        -s.sqrt()
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        {
+            if is_x86_feature_detected!("avx2") == 0 {
+                return euclid_similarity_avx2(v1, v2);
+            }
+        }
+        euclid_similarity(v1, v2)
     }
 
     fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
@@ -34,7 +109,13 @@ impl Metric for DotProductMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        v1.iter().zip(v2).map(|(a, b)| a * b).sum()
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        {
+            if is_x86_feature_detected!("avx2") == 0 {
+                return dot_similarity_avx2(v1, v2);
+            }
+        }
+        dot_similarity(v1, v2)
     }
 
     fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
@@ -48,14 +129,23 @@ impl Metric for CosineMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        v1.iter().zip(v2).map(|(a, b)| a * b).sum()
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        {
+            if is_x86_feature_detected!("avx2") == 0 {
+                return dot_similarity_avx2(v1, v2);
+            }
+        }
+        dot_similarity(v1, v2)
     }
 
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        let mut length: f32 = vector.iter().map(|x| x * x).sum();
-        length = length.sqrt();
-        let norm_vector = vector.iter().map(|x| x / length).collect();
-        Some(norm_vector)
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        {
+            if is_x86_feature_detected!("avx2") == 0 {
+                return Some(cosine_preprocess_avx2(vector));
+            }
+        }
+        Some(cosine_preprocess(vector))
     }
 }
 

commit cd2f33427121d7d3975d77046dbdd583b50e4e05
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 16:30:36 2022 +0300

    horizontal sum and test

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 503bfdfa1..7d87d8161 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -14,6 +14,19 @@ pub struct CosineMetric {}
 
 pub struct EuclidMetric {}
 
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "avx2")]
+unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
+    /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
+    let x128 : __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
+    /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
+    let x64 : __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
+    /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
+    let x32 : __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
+    /* Conversion to float is a no-op on x86-64 */
+    return _mm_cvtss_f32(x32);
+}
+
 fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
     let s: ScoreType = v1
         .iter()
@@ -25,19 +38,19 @@ fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> Scor
 }
 
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    unsafe {
-        let mut sum256: __m256 = _mm256_setzero_ps();
-        for i in (0..n).step_by(8) {
-            let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
-            sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
-        }
-        let res: f32 = hsum256_ps_avx(sum256);
-        for i in (n - (n % 8)..n) {
-            res += (v1[i] - v2[i]).powi(2);
-        }
-        -res.sqrt()
+#[target_feature(enable = "avx2")]
+unsafe fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..n).step_by(8) {
+        let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
+        sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
     }
+    let mut res = hsum256_ps_avx(sum256);
+    for i in n - (n % 8)..n {
+        res += (v1[i] - v2[i]).powi(2);
+    }
+    -res.sqrt()
 }
 
 fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
@@ -45,18 +58,18 @@ fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreTy
 }
 
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    unsafe {
-        let mut sum256: __m256 = _mm256_setzero_ps();
-        for i in (0..n).step_by(8) {
-            sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
-        }
-        let res: f32 = hsum256_ps_avx(sum256);
-        for i in (n - (n % 8)..n) {
-            res += v1[i] * v2[i];
-        }
-        res
+#[target_feature(enable = "avx2")]
+unsafe fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..n).step_by(8) {
+        sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
+    }
+    let mut res = hsum256_ps_avx(sum256);
+    for i in n - (n % 8)..n {
+        res += v1[i] * v2[i];
     }
+    res
 }
 
 fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
@@ -66,20 +79,20 @@ fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
 }
 
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let length = unsafe {
-        let mut sum256: __m256 = _mm256_setzero_ps();
-        for i in (0..n).step_by(8) {
-            sum256 = _mm256_fmadd_ps(
-                _mm256_loadu_ps(&vector[i]),
-                _mm256_loadu_ps(&vector[i]), sum256);
-        }
-        let res: f32 = hsum256_ps_avx(sum256);
-        for i in (n - (n % 8)..n) {
-            res += vector[i].powi(2);
-        }
-        res
-    }.sqrt();
+#[target_feature(enable = "avx2")]
+unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let n = vector.len();
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..n).step_by(8) {
+        sum256 = _mm256_fmadd_ps(
+            _mm256_loadu_ps(&vector[i]),
+            _mm256_loadu_ps(&vector[i]), sum256);
+    }
+    let mut length = hsum256_ps_avx(sum256);
+    for i in n - (n % 8)..n {
+        length += vector[i].powi(2);
+    }
+    length = length.sqrt();
     vector.iter().map(|x| x / length).collect()
 }
 
@@ -91,8 +104,8 @@ impl Metric for EuclidMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("avx2") == 0 {
-                return euclid_similarity_avx2(v1, v2);
+            if is_x86_feature_detected!("avx2") {
+                return unsafe { euclid_similarity_avx2(v1, v2) };
             }
         }
         euclid_similarity(v1, v2)
@@ -111,8 +124,8 @@ impl Metric for DotProductMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("avx2") == 0 {
-                return dot_similarity_avx2(v1, v2);
+            if is_x86_feature_detected!("avx2") {
+                return unsafe { dot_similarity_avx2(v1, v2) };
             }
         }
         dot_similarity(v1, v2)
@@ -131,8 +144,8 @@ impl Metric for CosineMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("avx2") == 0 {
-                return dot_similarity_avx2(v1, v2);
+            if is_x86_feature_detected!("avx2") {
+                return unsafe { dot_similarity_avx2(v1, v2) };
             }
         }
         dot_similarity(v1, v2)
@@ -141,8 +154,8 @@ impl Metric for CosineMetric {
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("avx2") == 0 {
-                return Some(cosine_preprocess_avx2(vector));
+            if is_x86_feature_detected!("avx2") {
+                return Some(unsafe { cosine_preprocess_avx2(vector) });
             }
         }
         Some(cosine_preprocess(vector))
@@ -159,4 +172,18 @@ mod tests {
         let res = metric.preprocess(&[0.0, 0.0, 0.0, 0.0]);
         eprintln!("res = {:#?}", res);
     }
+
+    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+    #[test]
+    fn test_avx2() {
+        if is_x86_feature_detected!("avx2") {
+            let v1 : Vec<f32> = vec![10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30.];
+            let v2 : Vec<f32> = vec![40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55., 56., 57., 58., 59., 60.];
+            let res1 = unsafe { euclid_similarity_avx2(&v1, &v2) };
+            let res2 = euclid_similarity(&v1, &v2);
+            println!("AVX2 = {}, orig = {}", res1, res2);
+        } else {
+            println!("AVX2 test skiped");
+        }
+    }
 }

commit 8a644a5ced0131efd891157dcb248445f280ecb6
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 17:48:33 2022 +0300

    bugfix

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 7d87d8161..00deb4226 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -14,88 +14,6 @@ pub struct CosineMetric {}
 
 pub struct EuclidMetric {}
 
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
-    /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
-    let x128 : __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
-    /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
-    let x64 : __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
-    /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
-    let x32 : __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
-    /* Conversion to float is a no-op on x86-64 */
-    return _mm_cvtss_f32(x32);
-}
-
-fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let s: ScoreType = v1
-        .iter()
-        .cloned()
-        .zip(v2.iter().cloned())
-        .map(|(a, b)| (a - b).powi(2))
-        .sum();
-    -s.sqrt()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..n).step_by(8) {
-        let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
-        sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
-    }
-    let mut res = hsum256_ps_avx(sum256);
-    for i in n - (n % 8)..n {
-        res += (v1[i] - v2[i]).powi(2);
-    }
-    -res.sqrt()
-}
-
-fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    v1.iter().zip(v2).map(|(a, b)| a * b).sum()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..n).step_by(8) {
-        sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
-    }
-    let mut res = hsum256_ps_avx(sum256);
-    for i in n - (n % 8)..n {
-        res += v1[i] * v2[i];
-    }
-    res
-}
-
-fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let mut length: f32 = vector.iter().map(|x| x * x).sum();
-    length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let n = vector.len();
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..n).step_by(8) {
-        sum256 = _mm256_fmadd_ps(
-            _mm256_loadu_ps(&vector[i]),
-            _mm256_loadu_ps(&vector[i]), sum256);
-    }
-    let mut length = hsum256_ps_avx(sum256);
-    for i in n - (n % 8)..n {
-        length += vector[i].powi(2);
-    }
-    length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
-}
-
 impl Metric for EuclidMetric {
     fn distance(&self) -> Distance {
         Distance::Euclid
@@ -162,6 +80,91 @@ impl Metric for CosineMetric {
     }
 }
 
+fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let s: ScoreType = v1
+        .iter()
+        .cloned()
+        .zip(v2.iter().cloned())
+        .map(|(a, b)| (a - b).powi(2))
+        .sum();
+    -s.sqrt()
+}
+
+fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let mut length: f32 = vector.iter().map(|x| x * x).sum();
+    length = length.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
+fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    v1.iter().zip(v2).map(|(a, b)| a * b).sum()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "avx2")]
+unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
+    /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
+    let x128 : __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
+    /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
+    let x64 : __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
+    /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
+    let x32 : __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
+    /* Conversion to float is a no-op on x86-64 */
+    return _mm_cvtss_f32(x32);
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "avx2")]
+unsafe fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 8);
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..m).step_by(8) {
+        let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
+        sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
+    }
+    let mut res = hsum256_ps_avx(sum256);
+    for i in m..n {
+        res += (v1[i] - v2[i]).powi(2);
+    }
+    -res.sqrt()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "avx2")]
+unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let n = vector.len();
+    let m = n - (n % 8);
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..m).step_by(8) {
+        sum256 = _mm256_fmadd_ps(
+            _mm256_loadu_ps(&vector[i]),
+            _mm256_loadu_ps(&vector[i]), sum256);
+    }
+    let mut length = hsum256_ps_avx(sum256);
+    for i in m..n {
+        length += vector[i].powi(2);
+    }
+    length = length.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "avx2")]
+unsafe fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 8);
+    let mut sum256: __m256 = _mm256_setzero_ps();
+    for i in (0..m).step_by(8) {
+        sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
+    }
+    let mut res = hsum256_ps_avx(sum256);
+    for i in m..n {
+        res += v1[i] * v2[i];
+    }
+    res
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -179,9 +182,18 @@ mod tests {
         if is_x86_feature_detected!("avx2") {
             let v1 : Vec<f32> = vec![10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30.];
             let v2 : Vec<f32> = vec![40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55., 56., 57., 58., 59., 60.];
-            let res1 = unsafe { euclid_similarity_avx2(&v1, &v2) };
-            let res2 = euclid_similarity(&v1, &v2);
-            println!("AVX2 = {}, orig = {}", res1, res2);
+
+            let euclid_avx2 = unsafe { euclid_similarity_avx2(&v1, &v2) };
+            let euclid = euclid_similarity(&v1, &v2);
+            assert_eq!(euclid_avx2, euclid);
+
+            let dot_avx2 = unsafe { dot_similarity_avx2(&v1, &v2) };
+            let dot = dot_similarity(&v1, &v2);
+            assert_eq!(dot_avx2, dot);
+
+            let cosine_avx2 = unsafe { cosine_preprocess_avx2(&v1) };
+            let cosine = cosine_preprocess(&v1);
+            assert_eq!(cosine_avx2, cosine);
         } else {
             println!("AVX2 test skiped");
         }

commit 55efa601adb99ac671194890fbc88178810bd094
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 18:09:49 2022 +0300

    restore copied call

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 00deb4226..a1de8bfa2 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -83,8 +83,8 @@ impl Metric for CosineMetric {
 fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
     let s: ScoreType = v1
         .iter()
-        .cloned()
-        .zip(v2.iter().cloned())
+        .copied()
+        .zip(v2.iter().copied())
         .map(|(a, b)| (a - b).powi(2))
         .sum();
     -s.sqrt()

commit 8daacbd160e7e5d1174bd9e2bb6b47afe4ce6c0a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 18:19:34 2022 +0300

    are you happy fmt?

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index a1de8bfa2..bdeeeb90d 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -104,11 +104,11 @@ fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreTy
 #[target_feature(enable = "avx2")]
 unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
     /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
-    let x128 : __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
+    let x128: __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
     /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
-    let x64 : __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
+    let x64: __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
     /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
-    let x32 : __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
+    let x32: __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
     /* Conversion to float is a no-op on x86-64 */
     return _mm_cvtss_f32(x32);
 }
@@ -139,7 +139,9 @@ unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElem
     for i in (0..m).step_by(8) {
         sum256 = _mm256_fmadd_ps(
             _mm256_loadu_ps(&vector[i]),
-            _mm256_loadu_ps(&vector[i]), sum256);
+            _mm256_loadu_ps(&vector[i]),
+            sum256,
+        );
     }
     let mut length = hsum256_ps_avx(sum256);
     for i in m..n {
@@ -180,8 +182,14 @@ mod tests {
     #[test]
     fn test_avx2() {
         if is_x86_feature_detected!("avx2") {
-            let v1 : Vec<f32> = vec![10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30.];
-            let v2 : Vec<f32> = vec![40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55., 56., 57., 58., 59., 60.];
+            let v1: Vec<f32> = vec![
+                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
+                26., 27., 28., 29., 30.,
+            ];
+            let v2: Vec<f32> = vec![
+                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
+                56., 57., 58., 59., 60.,
+            ];
 
             let euclid_avx2 = unsafe { euclid_similarity_avx2(&v1, &v2) };
             let euclid = euclid_similarity(&v1, &v2);

commit 883a46ac8e30c708a2c03c6c5f1f182286e29998
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 23:13:59 2022 +0300

    are you happy clippy?

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index bdeeeb90d..4661f0c47 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -110,7 +110,7 @@ unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
     /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
     let x32: __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
     /* Conversion to float is a no-op on x86-64 */
-    return _mm_cvtss_f32(x32);
+    _mm_cvtss_f32(x32)
 }
 
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
@@ -144,8 +144,8 @@ unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElem
         );
     }
     let mut length = hsum256_ps_avx(sum256);
-    for i in m..n {
-        length += vector[i].powi(2);
+    for v in vector.iter().take(n).skip(m) {
+        length += v.powi(2);
     }
     length = length.sqrt();
     vector.iter().map(|x| x / length).collect()

commit a0138600319f981f023a9067c8d321600be3fe28
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Jan 5 01:17:49 2022 +0300

    add sse support

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 4661f0c47..e59a41ad2 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -25,6 +25,9 @@ impl Metric for EuclidMetric {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { euclid_similarity_avx2(v1, v2) };
             }
+            if is_x86_feature_detected!("sse") {
+                return unsafe { euclid_similarity_sse(v1, v2) };
+            }
         }
         euclid_similarity(v1, v2)
     }
@@ -45,6 +48,9 @@ impl Metric for DotProductMetric {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { dot_similarity_avx2(v1, v2) };
             }
+            if is_x86_feature_detected!("sse") {
+                return unsafe { dot_similarity_sse(v1, v2) };
+            }
         }
         dot_similarity(v1, v2)
     }
@@ -65,6 +71,9 @@ impl Metric for CosineMetric {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { dot_similarity_avx2(v1, v2) };
             }
+            if is_x86_feature_detected!("sse") {
+                return unsafe { dot_similarity_sse(v1, v2) };
+            }
         }
         dot_similarity(v1, v2)
     }
@@ -75,6 +84,9 @@ impl Metric for CosineMetric {
             if is_x86_feature_detected!("avx2") {
                 return Some(unsafe { cosine_preprocess_avx2(vector) });
             }
+            if is_x86_feature_detected!("sse") {
+                return Some(unsafe { cosine_preprocess_sse(vector) });
+            }
         }
         Some(cosine_preprocess(vector))
     }
@@ -102,7 +114,7 @@ fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreTy
 
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 #[target_feature(enable = "avx2")]
-unsafe fn hsum256_ps_avx(x: __m256) -> f32 {
+unsafe fn hsum256_ps_avx2(x: __m256) -> f32 {
     /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
     let x128: __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
     /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
@@ -123,7 +135,7 @@ unsafe fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementTy
         let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
         sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
     }
-    let mut res = hsum256_ps_avx(sum256);
+    let mut res = hsum256_ps_avx2(sum256);
     for i in m..n {
         res += (v1[i] - v2[i]).powi(2);
     }
@@ -143,7 +155,7 @@ unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElem
             sum256,
         );
     }
-    let mut length = hsum256_ps_avx(sum256);
+    let mut length = hsum256_ps_avx2(sum256);
     for v in vector.iter().take(n).skip(m) {
         length += v.powi(2);
     }
@@ -160,7 +172,71 @@ unsafe fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]
     for i in (0..m).step_by(8) {
         sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
     }
-    let mut res = hsum256_ps_avx(sum256);
+    let mut res = hsum256_ps_avx2(sum256);
+    for i in m..n {
+        res += v1[i] * v2[i];
+    }
+    res
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "sse")]
+unsafe fn hsum128_ps_sse(x: __m128) -> f32 {
+    let x64: __m128 = _mm_add_ps(x, _mm_movehl_ps(x, x));
+    let x32: __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
+    _mm_cvtss_f32(x32)
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "sse")]
+unsafe fn euclid_similarity_sse(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 4);
+    let mut sum128: __m128 = _mm_setzero_ps();
+    for i in (0..m).step_by(4) {
+        let sub128: __m128 = _mm_sub_ps(_mm_loadu_ps(&v1[i]), _mm_loadu_ps(&v2[i]));
+        let a = _mm_mul_ps(sub128, sub128);
+        sum128 = _mm_add_ps(a, sum128);
+    }
+    let mut res = hsum128_ps_sse(sum128);
+    for i in m..n {
+        res += (v1[i] - v2[i]).powi(2);
+    }
+    -res.sqrt()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "sse")]
+unsafe fn cosine_preprocess_sse(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let n = vector.len();
+    let m = n - (n % 4);
+    let mut sum128: __m128 = _mm_setzero_ps();
+    for i in (0..m).step_by(4) {
+        let a = _mm_loadu_ps(&vector[i]);
+        let b = _mm_mul_ps(a, a);
+        sum128 = _mm_add_ps(b, sum128);
+    }
+    let mut length = hsum128_ps_sse(sum128);
+    for v in vector.iter().take(n).skip(m) {
+        length += v.powi(2);
+    }
+    length = length.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+#[target_feature(enable = "sse")]
+unsafe fn dot_similarity_sse(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 4);
+    let mut sum128: __m128 = _mm_setzero_ps();
+    for i in (0..m).step_by(4) {
+        let a = _mm_loadu_ps(&v1[i]);
+        let b = _mm_loadu_ps(&v2[i]);
+        let c = _mm_mul_ps(a, b);
+        sum128 = _mm_add_ps(c, sum128);
+    }
+    let mut res = hsum128_ps_sse(sum128);
     for i in m..n {
         res += v1[i] * v2[i];
     }
@@ -180,28 +256,53 @@ mod tests {
 
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
     #[test]
-    fn test_avx2() {
+    fn test_simd() {
+        if is_x86_feature_detected!("sse") {
+            let v1: Vec<f32> = vec![
+                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
+                26., 27., 28., 29., 30., 31.,
+            ];
+            let v2: Vec<f32> = vec![
+                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
+                56., 57., 58., 59., 60., 61.
+            ];
+
+            let euclid_simd = unsafe { euclid_similarity_sse(&v1, &v2) };
+            let euclid = euclid_similarity(&v1, &v2);
+            assert_eq!(euclid_simd, euclid);
+
+            let dot_simd = unsafe { dot_similarity_sse(&v1, &v2) };
+            let dot = dot_similarity(&v1, &v2);
+            assert_eq!(dot_simd, dot);
+
+            let cosine_simd = unsafe { cosine_preprocess_sse(&v1) };
+            let cosine = cosine_preprocess(&v1);
+            assert_eq!(cosine_simd, cosine);
+        } else {
+            println!("SSE test skiped");
+        }
+
         if is_x86_feature_detected!("avx2") {
             let v1: Vec<f32> = vec![
                 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
-                26., 27., 28., 29., 30.,
+                26., 27., 28., 29., 30., 31.,
             ];
             let v2: Vec<f32> = vec![
                 40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                56., 57., 58., 59., 60.,
+                56., 57., 58., 59., 60., 61.,
             ];
 
-            let euclid_avx2 = unsafe { euclid_similarity_avx2(&v1, &v2) };
+            let euclid_simd = unsafe { euclid_similarity_avx2(&v1, &v2) };
             let euclid = euclid_similarity(&v1, &v2);
-            assert_eq!(euclid_avx2, euclid);
+            assert_eq!(euclid_simd, euclid);
 
-            let dot_avx2 = unsafe { dot_similarity_avx2(&v1, &v2) };
+            let dot_simd = unsafe { dot_similarity_avx2(&v1, &v2) };
             let dot = dot_similarity(&v1, &v2);
-            assert_eq!(dot_avx2, dot);
+            assert_eq!(dot_simd, dot);
 
-            let cosine_avx2 = unsafe { cosine_preprocess_avx2(&v1) };
+            let cosine_simd = unsafe { cosine_preprocess_avx2(&v1) };
             let cosine = cosine_preprocess(&v1);
-            assert_eq!(cosine_avx2, cosine);
+            assert_eq!(cosine_simd, cosine);
         } else {
             println!("AVX2 test skiped");
         }

commit 1ee72b59bcf380264dd6abc6ced880418579ca22
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Jan 5 01:48:50 2022 +0300

    are you happy fmt?

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index e59a41ad2..829dc87f0 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -264,7 +264,7 @@ mod tests {
             ];
             let v2: Vec<f32> = vec![
                 40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                56., 57., 58., 59., 60., 61.
+                56., 57., 58., 59., 60., 61.,
             ];
 
             let euclid_simd = unsafe { euclid_similarity_sse(&v1, &v2) };

commit 7f00a1d7e0c4efffd5c129b867a5f2ee05c64a67
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 2 23:42:16 2022 +0400

    add neon aarch64 support

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 829dc87f0..009a8a291 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -4,6 +4,12 @@ use std::arch::x86::*;
 #[cfg(target_arch = "x86_64")]
 use std::arch::x86_64::*;
 
+#[cfg(target_arch = "aarch64")]
+use std::arch::aarch64::*;
+
+#[cfg(target_arch = "arm")]
+use std::arch::arm::*;
+
 use crate::types::{Distance, ScoreType, VectorElementType};
 
 use super::metric::Metric;
@@ -243,6 +249,64 @@ unsafe fn dot_similarity_sse(v1: &[VectorElementType], v2: &[VectorElementType])
     res
 }
 
+#[cfg(all(
+    target_arch = "aarch64",
+    target_feature = "neon"))]
+unsafe fn euclid_similarity_neon(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 4);
+    let mut res : f64 = 0.0;
+    for i in (0..m).step_by(4) {
+        let a = vld1q_f32(&v1[i]);
+        let b = vld1q_f32(&v2[i]);
+        let c = vsubq_f32(a, b);
+        let d = vmulq_f32(c, c);
+        res += vaddvq_f32(d) as f64;
+    }
+    for i in m..n {
+        res += (v1[i] - v2[i]).powi(2) as f64;
+    }
+    -res.sqrt() as ScoreType
+}
+
+#[cfg(all(
+    target_arch = "aarch64",
+    target_feature = "neon"))]
+unsafe fn cosine_preprocess_neon(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let n = vector.len();
+    let m = n - (n % 4);
+    let mut length : f64 = 0.0;
+    for i in (0..m).step_by(4) {
+        let a = vld1q_f32(&vector[i]);
+        let b = vmulq_f32(a, a);
+        length += vaddvq_f32(b) as f64;
+    }
+    for v in vector.iter().take(n).skip(m) {
+        length += v.powi(2) as f64;
+    }
+    let length = length.sqrt() as f32;
+    vector.iter().map(|x| x / length).collect()
+}
+
+#[cfg(all(
+    target_arch = "aarch64",
+    target_feature = "neon"))]
+unsafe fn dot_similarity_neon(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 4);
+    let mut res : f64 = 0.0;
+    for i in (0..m).step_by(4) {
+        let a = vld1q_f32(&v1[i]);
+        let b = vld1q_f32(&v2[i]);
+        let c = vmulq_f32(a, b);
+        res += vaddvq_f32(c) as f64;
+    }
+    for i in m..n {
+        res += (v1[i] * v2[i]) as f64;
+    }
+    res as ScoreType
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -307,4 +371,33 @@ mod tests {
             println!("AVX2 test skiped");
         }
     }
+
+    #[cfg(target_arch = "aarch64")]
+    #[test]
+    fn test_neon() {
+        if std::arch::is_aarch64_feature_detected!("neon") {
+            let v1: Vec<f32> = vec![
+                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
+                26., 27., 28., 29., 30., 31.,
+            ];
+            let v2: Vec<f32> = vec![
+                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
+                56., 57., 58., 59., 60., 61.,
+            ];
+
+            let euclid_simd = unsafe { euclid_similarity_neon(&v1, &v2) };
+            let euclid = euclid_similarity(&v1, &v2);
+            assert_eq!(euclid_simd, euclid);
+
+            let dot_simd = unsafe { dot_similarity_neon(&v1, &v2) };
+            let dot = dot_similarity(&v1, &v2);
+            assert_eq!(dot_simd, dot);
+
+            let cosine_simd = unsafe { cosine_preprocess_neon(&v1) };
+            let cosine = cosine_preprocess(&v1);
+            assert_eq!(cosine_simd, cosine);
+        } else {
+            println!("neon test skiped");
+        }
+    }
 }

commit 4e5b06833c441260b0b9ad453008188d34acbad5
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Mar 6 21:11:19 2022 +0400

    avx512f test

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 009a8a291..1449206d8 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -118,6 +118,63 @@ fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreTy
     v1.iter().zip(v2).map(|(a, b)| a * b).sum()
 }
 
+#[cfg(all(
+    target_arch = "x86_64",
+    target_feature = "avx512f"))]
+unsafe fn euclid_similarity_avx512f(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n2 = v1.len();
+    let m = n - (n % 16);
+    let mut sum512: __m512 = _mm512_setzero_ps();
+    for i in (0..m).step_by(16) {
+        let sub512: __m512 = _mm512_sub_ps(_mm512_loadu_ps(&v1[i]), _mm512_loadu_ps(&v2[i]));
+        sum512 = _mm512_fmadd_ps(sub512, sub512, sum512);
+    }
+    let mut res = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
+    for i in m..n {
+        res += (v1[i] - v2[i]).powi(2);
+    }
+    -res.sqrt()
+}
+
+#[cfg(all(
+    target_arch = "x86_64",
+    target_feature = "avx512f"))]
+unsafe fn cosine_preprocess_avx512f(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+    let n = vector.len();
+    let m = n - (n % 16);
+    let mut sum512: __m512 = _mm512_setzero_ps();
+    for i in (0..m).step_by(16) {
+        sum512 = _mm512_fmadd_ps(
+            _mm512_loadu_ps(&vector[i]),
+            _mm512_loadu_ps(&vector[i]),
+            sum512,
+        );
+    }
+    let mut length = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
+    for v in vector.iter().take(n).skip(m) {
+        length += v.powi(2);
+    }
+    length = length.sqrt();
+    vector.iter().map(|x| x / length).collect()
+}
+
+#[cfg(all(
+    target_arch = "x86_64",
+    target_feature = "avx512f"))]
+unsafe fn dot_similarity_avx512f(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    let n = v1.len();
+    let m = n - (n % 16);
+    let mut sum512: __m512 = _mm512_setzero_ps();
+    for i in (0..m).step_by(16) {
+        sum512 = _mm512_fmadd_ps(_mm512_loadu_ps(&v1[i]), _mm512_loadu_ps(&v2[i]), sum512);
+    }
+    let mut res = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
+    for i in m..n {
+        res += v1[i] * v2[i];
+    }
+    res
+}
+
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 #[target_feature(enable = "avx2")]
 unsafe fn hsum256_ps_avx2(x: __m256) -> f32 {
@@ -321,6 +378,38 @@ mod tests {
     #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
     #[test]
     fn test_simd() {
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx512f"))]
+        {
+            if is_x86_feature_detected!("avx512f") {
+                println!("avx512f test passed");
+
+                let v1: Vec<f32> = vec![
+                    10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
+                    26., 27., 28., 29., 30., 31.,
+                ];
+                let v2: Vec<f32> = vec![
+                    40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
+                    56., 57., 58., 59., 60., 61.,
+                ];
+    
+                let euclid_simd = unsafe { euclid_similarity_avx512f(&v1, &v2) };
+                let euclid = euclid_similarity(&v1, &v2);
+                assert_eq!(euclid_simd, euclid);
+    
+                let dot_simd = unsafe { dot_similarity_avx512f(&v1, &v2) };
+                let dot = dot_similarity(&v1, &v2);
+                assert_eq!(dot_simd, dot);
+    
+                let cosine_simd = unsafe { cosine_preprocess_avx512f(&v1) };
+                let cosine = cosine_preprocess(&v1);
+                assert_eq!(cosine_simd, cosine);
+            } else {
+                println!("avx512f test skiped");
+            }
+        }
+
         if is_x86_feature_detected!("sse") {
             let v1: Vec<f32> = vec![
                 10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,

commit 92bfa1e16223c5cc03ca569780dc60efe2aad4f9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Mar 8 07:57:52 2022 +0000

    simd refactor

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 1449206d8..32204dd7c 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,18 +1,18 @@
-#[cfg(target_arch = "x86")]
-use std::arch::x86::*;
+use crate::types::{Distance, ScoreType, VectorElementType};
 
-#[cfg(target_arch = "x86_64")]
-use std::arch::x86_64::*;
+use super::metric::Metric;
 
-#[cfg(target_arch = "aarch64")]
-use std::arch::aarch64::*;
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+use super::simple_sse::*;
 
-#[cfg(target_arch = "arm")]
-use std::arch::arm::*;
+#[cfg(target_arch = "x86_64")]
+use super::simple_avx2::*;
 
-use crate::types::{Distance, ScoreType, VectorElementType};
+#[cfg(target_arch = "x86_64")]
+use super::simple_avx512::*;
 
-use super::metric::Metric;
+#[cfg(target_arch = "aarch64")]
+use super::simple_neon::*;
 
 pub struct DotProductMetric {}
 
@@ -26,15 +26,40 @@ impl Metric for EuclidMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx512f"))]
+        {
+            if is_x86_feature_detected!("avx512f") {
+                return unsafe { euclid_similarity_avx512f(v1, v2) };
+            }
+        }
+
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx2"))]
         {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { euclid_similarity_avx2(v1, v2) };
             }
+        }
+
+        #[cfg(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            target_feature = "sse"))]
+        {
             if is_x86_feature_detected!("sse") {
                 return unsafe { euclid_similarity_sse(v1, v2) };
             }
         }
+
+        #[cfg(target_arch = "aarch64")]
+        {
+            if is_aarch64_feature_detected!("neon") {
+                return unsafe { euclid_similarity_neon(v1, v2) };
+            }
+        }
+
         euclid_similarity(v1, v2)
     }
 
@@ -49,15 +74,40 @@ impl Metric for DotProductMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx512f"))]
+        {
+            if is_x86_feature_detected!("avx512f") {
+                return unsafe { dot_similarity_avx512f(v1, v2) };
+            }
+        }
+
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx2"))]
         {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { dot_similarity_avx2(v1, v2) };
             }
+        }
+
+        #[cfg(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            target_feature = "sse"))]
+        {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
             }
         }
+
+        #[cfg(target_arch = "aarch64")]
+        {
+            if is_aarch64_feature_detected!("neon") {
+                return unsafe { dot_similarity_neon(v1, v2) };
+            }
+        }
+
         dot_similarity(v1, v2)
     }
 
@@ -72,33 +122,83 @@ impl Metric for CosineMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx512f"))]
+        {
+            if is_x86_feature_detected!("avx512f") {
+                return unsafe { dot_similarity_avx512f(v1, v2) };
+            }
+        }
+
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx2"))]
         {
             if is_x86_feature_detected!("avx2") {
                 return unsafe { dot_similarity_avx2(v1, v2) };
             }
+        }
+
+        #[cfg(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            target_feature = "sse"))]
+        {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
             }
         }
+
+        #[cfg(target_arch = "aarch64")]
+        {
+            if is_aarch64_feature_detected!("neon") {
+                return unsafe { dot_similarity_neon(v1, v2) };
+            }
+        }
+
         dot_similarity(v1, v2)
     }
 
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx512f"))]
+        {
+            if is_x86_feature_detected!("avx512f") {
+                return Some(unsafe { cosine_preprocess_avx512f(vector) });
+            }
+        }
+
+        #[cfg(all(
+            target_arch = "x86_64",
+            target_feature = "avx2"))]
         {
             if is_x86_feature_detected!("avx2") {
                 return Some(unsafe { cosine_preprocess_avx2(vector) });
             }
+        }
+
+        #[cfg(all(
+            any(target_arch = "x86", target_arch = "x86_64"),
+            target_feature = "sse"))]
+        {
             if is_x86_feature_detected!("sse") {
                 return Some(unsafe { cosine_preprocess_sse(vector) });
             }
         }
+
+        #[cfg(target_arch = "aarch64")]
+        {
+            if is_aarch64_feature_detected!("neon") {
+                return Some(unsafe { cosine_preprocess_neon(vector) });
+            }
+        }
+
         Some(cosine_preprocess(vector))
     }
 }
 
-fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
     let s: ScoreType = v1
         .iter()
         .copied()
@@ -108,262 +208,16 @@ fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> Scor
     -s.sqrt()
 }
 
-fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+pub fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
     length = length.sqrt();
     vector.iter().map(|x| x / length).collect()
 }
 
-fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+pub fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
     v1.iter().zip(v2).map(|(a, b)| a * b).sum()
 }
 
-#[cfg(all(
-    target_arch = "x86_64",
-    target_feature = "avx512f"))]
-unsafe fn euclid_similarity_avx512f(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n2 = v1.len();
-    let m = n - (n % 16);
-    let mut sum512: __m512 = _mm512_setzero_ps();
-    for i in (0..m).step_by(16) {
-        let sub512: __m512 = _mm512_sub_ps(_mm512_loadu_ps(&v1[i]), _mm512_loadu_ps(&v2[i]));
-        sum512 = _mm512_fmadd_ps(sub512, sub512, sum512);
-    }
-    let mut res = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
-    for i in m..n {
-        res += (v1[i] - v2[i]).powi(2);
-    }
-    -res.sqrt()
-}
-
-#[cfg(all(
-    target_arch = "x86_64",
-    target_feature = "avx512f"))]
-unsafe fn cosine_preprocess_avx512f(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let n = vector.len();
-    let m = n - (n % 16);
-    let mut sum512: __m512 = _mm512_setzero_ps();
-    for i in (0..m).step_by(16) {
-        sum512 = _mm512_fmadd_ps(
-            _mm512_loadu_ps(&vector[i]),
-            _mm512_loadu_ps(&vector[i]),
-            sum512,
-        );
-    }
-    let mut length = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
-    for v in vector.iter().take(n).skip(m) {
-        length += v.powi(2);
-    }
-    length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
-}
-
-#[cfg(all(
-    target_arch = "x86_64",
-    target_feature = "avx512f"))]
-unsafe fn dot_similarity_avx512f(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 16);
-    let mut sum512: __m512 = _mm512_setzero_ps();
-    for i in (0..m).step_by(16) {
-        sum512 = _mm512_fmadd_ps(_mm512_loadu_ps(&v1[i]), _mm512_loadu_ps(&v2[i]), sum512);
-    }
-    let mut res = _mm512_mask_reduce_add_ps(u16::MAX, sum512);
-    for i in m..n {
-        res += v1[i] * v2[i];
-    }
-    res
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn hsum256_ps_avx2(x: __m256) -> f32 {
-    /* ( x3+x7, x2+x6, x1+x5, x0+x4 ) */
-    let x128: __m128 = _mm_add_ps(_mm256_extractf128_ps(x, 1), _mm256_castps256_ps128(x));
-    /* ( -, -, x1+x3+x5+x7, x0+x2+x4+x6 ) */
-    let x64: __m128 = _mm_add_ps(x128, _mm_movehl_ps(x128, x128));
-    /* ( -, -, -, x0+x1+x2+x3+x4+x5+x6+x7 ) */
-    let x32: __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
-    /* Conversion to float is a no-op on x86-64 */
-    _mm_cvtss_f32(x32)
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn euclid_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 8);
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..m).step_by(8) {
-        let sub256: __m256 = _mm256_sub_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]));
-        sum256 = _mm256_fmadd_ps(sub256, sub256, sum256);
-    }
-    let mut res = hsum256_ps_avx2(sum256);
-    for i in m..n {
-        res += (v1[i] - v2[i]).powi(2);
-    }
-    -res.sqrt()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn cosine_preprocess_avx2(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let n = vector.len();
-    let m = n - (n % 8);
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..m).step_by(8) {
-        sum256 = _mm256_fmadd_ps(
-            _mm256_loadu_ps(&vector[i]),
-            _mm256_loadu_ps(&vector[i]),
-            sum256,
-        );
-    }
-    let mut length = hsum256_ps_avx2(sum256);
-    for v in vector.iter().take(n).skip(m) {
-        length += v.powi(2);
-    }
-    length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "avx2")]
-unsafe fn dot_similarity_avx2(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 8);
-    let mut sum256: __m256 = _mm256_setzero_ps();
-    for i in (0..m).step_by(8) {
-        sum256 = _mm256_fmadd_ps(_mm256_loadu_ps(&v1[i]), _mm256_loadu_ps(&v2[i]), sum256);
-    }
-    let mut res = hsum256_ps_avx2(sum256);
-    for i in m..n {
-        res += v1[i] * v2[i];
-    }
-    res
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "sse")]
-unsafe fn hsum128_ps_sse(x: __m128) -> f32 {
-    let x64: __m128 = _mm_add_ps(x, _mm_movehl_ps(x, x));
-    let x32: __m128 = _mm_add_ss(x64, _mm_shuffle_ps(x64, x64, 0x55));
-    _mm_cvtss_f32(x32)
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "sse")]
-unsafe fn euclid_similarity_sse(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 4);
-    let mut sum128: __m128 = _mm_setzero_ps();
-    for i in (0..m).step_by(4) {
-        let sub128: __m128 = _mm_sub_ps(_mm_loadu_ps(&v1[i]), _mm_loadu_ps(&v2[i]));
-        let a = _mm_mul_ps(sub128, sub128);
-        sum128 = _mm_add_ps(a, sum128);
-    }
-    let mut res = hsum128_ps_sse(sum128);
-    for i in m..n {
-        res += (v1[i] - v2[i]).powi(2);
-    }
-    -res.sqrt()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "sse")]
-unsafe fn cosine_preprocess_sse(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let n = vector.len();
-    let m = n - (n % 4);
-    let mut sum128: __m128 = _mm_setzero_ps();
-    for i in (0..m).step_by(4) {
-        let a = _mm_loadu_ps(&vector[i]);
-        let b = _mm_mul_ps(a, a);
-        sum128 = _mm_add_ps(b, sum128);
-    }
-    let mut length = hsum128_ps_sse(sum128);
-    for v in vector.iter().take(n).skip(m) {
-        length += v.powi(2);
-    }
-    length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
-}
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-#[target_feature(enable = "sse")]
-unsafe fn dot_similarity_sse(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 4);
-    let mut sum128: __m128 = _mm_setzero_ps();
-    for i in (0..m).step_by(4) {
-        let a = _mm_loadu_ps(&v1[i]);
-        let b = _mm_loadu_ps(&v2[i]);
-        let c = _mm_mul_ps(a, b);
-        sum128 = _mm_add_ps(c, sum128);
-    }
-    let mut res = hsum128_ps_sse(sum128);
-    for i in m..n {
-        res += v1[i] * v2[i];
-    }
-    res
-}
-
-#[cfg(all(
-    target_arch = "aarch64",
-    target_feature = "neon"))]
-unsafe fn euclid_similarity_neon(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 4);
-    let mut res : f64 = 0.0;
-    for i in (0..m).step_by(4) {
-        let a = vld1q_f32(&v1[i]);
-        let b = vld1q_f32(&v2[i]);
-        let c = vsubq_f32(a, b);
-        let d = vmulq_f32(c, c);
-        res += vaddvq_f32(d) as f64;
-    }
-    for i in m..n {
-        res += (v1[i] - v2[i]).powi(2) as f64;
-    }
-    -res.sqrt() as ScoreType
-}
-
-#[cfg(all(
-    target_arch = "aarch64",
-    target_feature = "neon"))]
-unsafe fn cosine_preprocess_neon(vector: &[VectorElementType]) -> Vec<VectorElementType> {
-    let n = vector.len();
-    let m = n - (n % 4);
-    let mut length : f64 = 0.0;
-    for i in (0..m).step_by(4) {
-        let a = vld1q_f32(&vector[i]);
-        let b = vmulq_f32(a, a);
-        length += vaddvq_f32(b) as f64;
-    }
-    for v in vector.iter().take(n).skip(m) {
-        length += v.powi(2) as f64;
-    }
-    let length = length.sqrt() as f32;
-    vector.iter().map(|x| x / length).collect()
-}
-
-#[cfg(all(
-    target_arch = "aarch64",
-    target_feature = "neon"))]
-unsafe fn dot_similarity_neon(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let n = v1.len();
-    let m = n - (n % 4);
-    let mut res : f64 = 0.0;
-    for i in (0..m).step_by(4) {
-        let a = vld1q_f32(&v1[i]);
-        let b = vld1q_f32(&v2[i]);
-        let c = vmulq_f32(a, b);
-        res += vaddvq_f32(c) as f64;
-    }
-    for i in m..n {
-        res += (v1[i] * v2[i]) as f64;
-    }
-    res as ScoreType
-}
-
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -374,119 +228,4 @@ mod tests {
         let res = metric.preprocess(&[0.0, 0.0, 0.0, 0.0]);
         eprintln!("res = {:#?}", res);
     }
-
-    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-    #[test]
-    fn test_simd() {
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "avx512f"))]
-        {
-            if is_x86_feature_detected!("avx512f") {
-                println!("avx512f test passed");
-
-                let v1: Vec<f32> = vec![
-                    10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
-                    26., 27., 28., 29., 30., 31.,
-                ];
-                let v2: Vec<f32> = vec![
-                    40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                    56., 57., 58., 59., 60., 61.,
-                ];
-    
-                let euclid_simd = unsafe { euclid_similarity_avx512f(&v1, &v2) };
-                let euclid = euclid_similarity(&v1, &v2);
-                assert_eq!(euclid_simd, euclid);
-    
-                let dot_simd = unsafe { dot_similarity_avx512f(&v1, &v2) };
-                let dot = dot_similarity(&v1, &v2);
-                assert_eq!(dot_simd, dot);
-    
-                let cosine_simd = unsafe { cosine_preprocess_avx512f(&v1) };
-                let cosine = cosine_preprocess(&v1);
-                assert_eq!(cosine_simd, cosine);
-            } else {
-                println!("avx512f test skiped");
-            }
-        }
-
-        if is_x86_feature_detected!("sse") {
-            let v1: Vec<f32> = vec![
-                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
-                26., 27., 28., 29., 30., 31.,
-            ];
-            let v2: Vec<f32> = vec![
-                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                56., 57., 58., 59., 60., 61.,
-            ];
-
-            let euclid_simd = unsafe { euclid_similarity_sse(&v1, &v2) };
-            let euclid = euclid_similarity(&v1, &v2);
-            assert_eq!(euclid_simd, euclid);
-
-            let dot_simd = unsafe { dot_similarity_sse(&v1, &v2) };
-            let dot = dot_similarity(&v1, &v2);
-            assert_eq!(dot_simd, dot);
-
-            let cosine_simd = unsafe { cosine_preprocess_sse(&v1) };
-            let cosine = cosine_preprocess(&v1);
-            assert_eq!(cosine_simd, cosine);
-        } else {
-            println!("SSE test skiped");
-        }
-
-        if is_x86_feature_detected!("avx2") {
-            let v1: Vec<f32> = vec![
-                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
-                26., 27., 28., 29., 30., 31.,
-            ];
-            let v2: Vec<f32> = vec![
-                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                56., 57., 58., 59., 60., 61.,
-            ];
-
-            let euclid_simd = unsafe { euclid_similarity_avx2(&v1, &v2) };
-            let euclid = euclid_similarity(&v1, &v2);
-            assert_eq!(euclid_simd, euclid);
-
-            let dot_simd = unsafe { dot_similarity_avx2(&v1, &v2) };
-            let dot = dot_similarity(&v1, &v2);
-            assert_eq!(dot_simd, dot);
-
-            let cosine_simd = unsafe { cosine_preprocess_avx2(&v1) };
-            let cosine = cosine_preprocess(&v1);
-            assert_eq!(cosine_simd, cosine);
-        } else {
-            println!("AVX2 test skiped");
-        }
-    }
-
-    #[cfg(target_arch = "aarch64")]
-    #[test]
-    fn test_neon() {
-        if std::arch::is_aarch64_feature_detected!("neon") {
-            let v1: Vec<f32> = vec![
-                10., 11., 12., 13., 14., 15., 16., 17., 18., 19., 20., 21., 22., 23., 24., 25.,
-                26., 27., 28., 29., 30., 31.,
-            ];
-            let v2: Vec<f32> = vec![
-                40., 41., 42., 43., 44., 45., 46., 47., 48., 49., 50., 51., 52., 53., 54., 55.,
-                56., 57., 58., 59., 60., 61.,
-            ];
-
-            let euclid_simd = unsafe { euclid_similarity_neon(&v1, &v2) };
-            let euclid = euclid_similarity(&v1, &v2);
-            assert_eq!(euclid_simd, euclid);
-
-            let dot_simd = unsafe { dot_similarity_neon(&v1, &v2) };
-            let dot = dot_similarity(&v1, &v2);
-            assert_eq!(dot_simd, dot);
-
-            let cosine_simd = unsafe { cosine_preprocess_neon(&v1) };
-            let cosine = cosine_preprocess(&v1);
-            assert_eq!(cosine_simd, cosine);
-        } else {
-            println!("neon test skiped");
-        }
-    }
 }

commit 4a24c275d91f2ad93636fc937644d104679c8436
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Mar 8 08:33:14 2022 +0000

    use avx+fma instead of avx2

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 32204dd7c..fc28bbf39 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -6,7 +6,7 @@ use super::metric::Metric;
 use super::simple_sse::*;
 
 #[cfg(target_arch = "x86_64")]
-use super::simple_avx2::*;
+use super::simple_avx::*;
 
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx512::*;
@@ -37,10 +37,11 @@ impl Metric for EuclidMetric {
 
         #[cfg(all(
             target_arch = "x86_64",
-            target_feature = "avx2"))]
+            target_feature = "fma",
+            target_feature = "avx"))]
         {
-            if is_x86_feature_detected!("avx2") {
-                return unsafe { euclid_similarity_avx2(v1, v2) };
+            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+                return unsafe { euclid_similarity_avx(v1, v2) };
             }
         }
 
@@ -85,10 +86,11 @@ impl Metric for DotProductMetric {
 
         #[cfg(all(
             target_arch = "x86_64",
-            target_feature = "avx2"))]
+            target_feature = "fma",
+            target_feature = "avx"))]
         {
-            if is_x86_feature_detected!("avx2") {
-                return unsafe { dot_similarity_avx2(v1, v2) };
+            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+                return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
@@ -133,10 +135,11 @@ impl Metric for CosineMetric {
 
         #[cfg(all(
             target_arch = "x86_64",
-            target_feature = "avx2"))]
+            target_feature = "fma",
+            target_feature = "avx"))]
         {
-            if is_x86_feature_detected!("avx2") {
-                return unsafe { dot_similarity_avx2(v1, v2) };
+            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+                return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
@@ -171,10 +174,11 @@ impl Metric for CosineMetric {
 
         #[cfg(all(
             target_arch = "x86_64",
-            target_feature = "avx2"))]
+            target_feature = "fma",
+            target_feature = "avx"))]
         {
-            if is_x86_feature_detected!("avx2") {
-                return Some(unsafe { cosine_preprocess_avx2(vector) });
+            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+                return Some(unsafe { cosine_preprocess_avx(vector) });
             }
         }
 

commit 063d0abe834080d6ea878f386297ca1e30eaee7c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 12:41:21 2022 +0400

    use fma instructions for arm

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index fc28bbf39..15de8265e 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -56,7 +56,7 @@ impl Metric for EuclidMetric {
 
         #[cfg(target_arch = "aarch64")]
         {
-            if is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { euclid_similarity_neon(v1, v2) };
             }
         }
@@ -105,7 +105,7 @@ impl Metric for DotProductMetric {
 
         #[cfg(target_arch = "aarch64")]
         {
-            if is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -154,7 +154,7 @@ impl Metric for CosineMetric {
 
         #[cfg(target_arch = "aarch64")]
         {
-            if is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -193,7 +193,7 @@ impl Metric for CosineMetric {
 
         #[cfg(target_arch = "aarch64")]
         {
-            if is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") {
                 return Some(unsafe { cosine_preprocess_neon(vector) });
             }
         }

commit 57fa65072f0b742662a9be5ef7f6840cddf5c6e1
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:36 2022 +0400

    use copied instead of cloned (#174)
    
    * use copied instead of cloned
    
    https://rust-lang.github.io/rust-clippy/master/index.html#cloned_instead_of_copied
    
    * use copied instead of cloned

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 72940fb3a..9e253dc71 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -20,8 +20,8 @@ impl Metric for EuclidMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         let s: ScoreType = v1
             .iter()
-            .cloned()
-            .zip(v2.iter().cloned())
+            .copied()
+            .zip(v2.iter().copied())
             .map(|(a, b)| (a - b).powi(2))
             .sum();
         -s.sqrt()
@@ -34,8 +34,8 @@ impl Metric for EuclidMetric {
     ) -> ScoreType {
         let s: ScoreType = v1
             .iter()
-            .cloned()
-            .zip(v2.iter().cloned())
+            .copied()
+            .zip(v2.iter().copied())
             .map(|(a, b)| (a - b).powi(2))
             .sum();
         -s.sqrt()

commit 898b692f39fe45f88623f01e2c57a4369030463b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jan 18 15:49:35 2022 +0100

    [WIP] Limit segment size #135 (#195)
    
    * add parameters to optimizer config
    
    * benchmark search speed in different segment sizes
    
    * use constructor for FilteredScorer
    
    * * Implement benchmarks for HNSW index search with different number of
      stored points
    * Fix minor issue in HNSW graph edge assignment
    * Update profiler with call-graph report generation
    * Add profiling guide
    * Add HNSW graph statistics test function (debug inly)
    
    * limit resulting segment size in merge optimizer
    
    * fix clippy
    
    * stop the music
    
    * fix clippy once again
    
    * fmt once again

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 9e253dc71..8fdf49727 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -6,10 +6,13 @@ use crate::types::{Distance, ScoreType, VectorElementType};
 
 use super::metric::Metric;
 
+#[derive(Clone)]
 pub struct DotProductMetric {}
 
+#[derive(Clone)]
 pub struct CosineMetric {}
 
+#[derive(Clone)]
 pub struct EuclidMetric {}
 
 impl Metric for EuclidMetric {

commit 2c4fd0a2059bc3d03e8cd0116bec23792c03ad87
Merge: 063d0abe8 bb8dba39b
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 15:48:25 2022 +0000

    Merge branch 'master' into remove-blas

diff --cc lib/segment/src/spaces/simple.rs
index 15de8265e,8fdf49727..f4966fa2d
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@@ -2,22 -6,13 +2,25 @@@ use crate::types::{Distance, ScoreType
  
  use super::metric::Metric;
  
 +#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 +use super::simple_sse::*;
 +
 +#[cfg(target_arch = "x86_64")]
 +use super::simple_avx::*;
 +
 +#[cfg(target_arch = "x86_64")]
 +use super::simple_avx512::*;
 +
 +#[cfg(target_arch = "aarch64")]
 +use super::simple_neon::*;
 +
+ #[derive(Clone)]
  pub struct DotProductMetric {}
  
+ #[derive(Clone)]
  pub struct CosineMetric {}
  
+ #[derive(Clone)]
  pub struct EuclidMetric {}
  
  impl Metric for EuclidMetric {

commit 241864255785e9da8a4ca8735ebbd74bcf38f383
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 15:50:21 2022 +0000

    are you happy fmt

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index f4966fa2d..9a8ba2c4b 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -29,19 +29,14 @@ impl Metric for EuclidMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "avx512f"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
         {
             if is_x86_feature_detected!("avx512f") {
                 return unsafe { euclid_similarity_avx512f(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "fma",
-            target_feature = "avx"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { euclid_similarity_avx(v1, v2) };
@@ -50,7 +45,8 @@ impl Metric for EuclidMetric {
 
         #[cfg(all(
             any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"))]
+            target_feature = "sse"
+        ))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { euclid_similarity_sse(v1, v2) };
@@ -78,19 +74,14 @@ impl Metric for DotProductMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "avx512f"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
         {
             if is_x86_feature_detected!("avx512f") {
                 return unsafe { dot_similarity_avx512f(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "fma",
-            target_feature = "avx"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { dot_similarity_avx(v1, v2) };
@@ -99,7 +90,8 @@ impl Metric for DotProductMetric {
 
         #[cfg(all(
             any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"))]
+            target_feature = "sse"
+        ))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
@@ -127,19 +119,14 @@ impl Metric for CosineMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "avx512f"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
         {
             if is_x86_feature_detected!("avx512f") {
                 return unsafe { dot_similarity_avx512f(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "fma",
-            target_feature = "avx"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { dot_similarity_avx(v1, v2) };
@@ -148,7 +135,8 @@ impl Metric for CosineMetric {
 
         #[cfg(all(
             any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"))]
+            target_feature = "sse"
+        ))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
@@ -166,19 +154,14 @@ impl Metric for CosineMetric {
     }
 
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "avx512f"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
         {
             if is_x86_feature_detected!("avx512f") {
                 return Some(unsafe { cosine_preprocess_avx512f(vector) });
             }
         }
 
-        #[cfg(all(
-            target_arch = "x86_64",
-            target_feature = "fma",
-            target_feature = "avx"))]
+        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return Some(unsafe { cosine_preprocess_avx(vector) });
@@ -187,7 +170,8 @@ impl Metric for CosineMetric {
 
         #[cfg(all(
             any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"))]
+            target_feature = "sse"
+        ))]
         {
             if is_x86_feature_detected!("sse") {
                 return Some(unsafe { cosine_preprocess_sse(vector) });

commit a91e77b824540f7394e0a65da465f223b817bbca
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 21:40:16 2022 +0000

    fix segment benches

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 9a8ba2c4b..a5dde7d84 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -8,7 +8,7 @@ use super::simple_sse::*;
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx::*;
 
-#[cfg(target_arch = "x86_64")]
+#[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
 use super::simple_avx512::*;
 
 #[cfg(target_arch = "aarch64")]
@@ -36,17 +36,14 @@ impl Metric for EuclidMetric {
             }
         }
 
-        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
+        #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { euclid_similarity_avx(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"
-        ))]
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { euclid_similarity_sse(v1, v2) };
@@ -81,17 +78,14 @@ impl Metric for DotProductMetric {
             }
         }
 
-        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
+        #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"
-        ))]
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
@@ -126,17 +120,14 @@ impl Metric for CosineMetric {
             }
         }
 
-        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
+        #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
-        #[cfg(all(
-            any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"
-        ))]
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
             if is_x86_feature_detected!("sse") {
                 return unsafe { dot_similarity_sse(v1, v2) };
@@ -161,17 +152,14 @@ impl Metric for CosineMetric {
             }
         }
 
-        #[cfg(all(target_arch = "x86_64", target_feature = "fma", target_feature = "avx"))]
+        #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
                 return Some(unsafe { cosine_preprocess_avx(vector) });
             }
         }
 
-        #[cfg(all(
-            any(target_arch = "x86", target_arch = "x86_64"),
-            target_feature = "sse"
-        ))]
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
             if is_x86_feature_detected!("sse") {
                 return Some(unsafe { cosine_preprocess_sse(vector) });

commit 4b930eda0a7edfc49fe8bf33b679041a59b4ab63
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Mar 11 13:39:48 2022 +0400

    fix warnings on arm

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index a5dde7d84..738f08871 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -11,7 +11,7 @@ use super::simple_avx::*;
 #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
 use super::simple_avx512::*;
 
-#[cfg(target_arch = "aarch64")]
+#[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
 use super::simple_neon::*;
 
 #[derive(Clone)]
@@ -50,7 +50,7 @@ impl Metric for EuclidMetric {
             }
         }
 
-        #[cfg(target_arch = "aarch64")]
+        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
             if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { euclid_similarity_neon(v1, v2) };
@@ -92,7 +92,7 @@ impl Metric for DotProductMetric {
             }
         }
 
-        #[cfg(target_arch = "aarch64")]
+        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
             if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { dot_similarity_neon(v1, v2) };
@@ -134,7 +134,7 @@ impl Metric for CosineMetric {
             }
         }
 
-        #[cfg(target_arch = "aarch64")]
+        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
             if std::arch::is_aarch64_feature_detected!("neon") {
                 return unsafe { dot_similarity_neon(v1, v2) };
@@ -166,7 +166,7 @@ impl Metric for CosineMetric {
             }
         }
 
-        #[cfg(target_arch = "aarch64")]
+        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
             if std::arch::is_aarch64_feature_detected!("neon") {
                 return Some(unsafe { cosine_preprocess_neon(vector) });

commit 3df7c36c883fcd503d52b0182fd8d03e5e707fbd
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 16 12:25:02 2022 +0400

    remove avx512

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 738f08871..7f90b0489 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -8,9 +8,6 @@ use super::simple_sse::*;
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx::*;
 
-#[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
-use super::simple_avx512::*;
-
 #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
 use super::simple_neon::*;
 
@@ -29,13 +26,6 @@ impl Metric for EuclidMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
-        {
-            if is_x86_feature_detected!("avx512f") {
-                return unsafe { euclid_similarity_avx512f(v1, v2) };
-            }
-        }
-
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
@@ -71,13 +61,6 @@ impl Metric for DotProductMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
-        {
-            if is_x86_feature_detected!("avx512f") {
-                return unsafe { dot_similarity_avx512f(v1, v2) };
-            }
-        }
-
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
@@ -113,13 +96,6 @@ impl Metric for CosineMetric {
     }
 
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
-        {
-            if is_x86_feature_detected!("avx512f") {
-                return unsafe { dot_similarity_avx512f(v1, v2) };
-            }
-        }
-
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
@@ -145,13 +121,6 @@ impl Metric for CosineMetric {
     }
 
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        #[cfg(all(target_arch = "x86_64", target_feature = "avx512f"))]
-        {
-            if is_x86_feature_detected!("avx512f") {
-                return Some(unsafe { cosine_preprocess_avx512f(vector) });
-            }
-        }
-
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {

commit 5a3408667bed08dd0e64485592245f44f50b9e87
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Apr 25 20:38:59 2022 +0400

    Disable simd on small dimensions (#508)
    
    Disable simd on small dimensions

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 7f90b0489..bc61163ab 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -11,6 +11,12 @@ use super::simple_avx::*;
 #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
 use super::simple_neon::*;
 
+#[cfg(target_arch = "x86_64")]
+const MIN_DIM_SIZE_AVX: usize = 32;
+
+#[cfg(any(target_arch = "x86", target_arch = "x86_64", target_arch = "aarch64"))]
+const MIN_DIM_SIZE_SIMD: usize = 16;
+
 #[derive(Clone)]
 pub struct DotProductMetric {}
 
@@ -28,21 +34,24 @@ impl Metric for EuclidMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
-            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+            if is_x86_feature_detected!("avx")
+                && is_x86_feature_detected!("fma")
+                && v1.len() >= MIN_DIM_SIZE_AVX
+            {
                 return unsafe { euclid_similarity_avx(v1, v2) };
             }
         }
 
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("sse") {
+            if is_x86_feature_detected!("sse") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { euclid_similarity_sse(v1, v2) };
             }
         }
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { euclid_similarity_neon(v1, v2) };
             }
         }
@@ -63,21 +72,24 @@ impl Metric for DotProductMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
-            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+            if is_x86_feature_detected!("avx")
+                && is_x86_feature_detected!("fma")
+                && v1.len() >= MIN_DIM_SIZE_AVX
+            {
                 return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("sse") {
+            if is_x86_feature_detected!("sse") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { dot_similarity_sse(v1, v2) };
             }
         }
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -98,21 +110,24 @@ impl Metric for CosineMetric {
     fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
-            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+            if is_x86_feature_detected!("avx")
+                && is_x86_feature_detected!("fma")
+                && v1.len() >= MIN_DIM_SIZE_AVX
+            {
                 return unsafe { dot_similarity_avx(v1, v2) };
             }
         }
 
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("sse") {
+            if is_x86_feature_detected!("sse") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { dot_similarity_sse(v1, v2) };
             }
         }
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
                 return unsafe { dot_similarity_neon(v1, v2) };
             }
         }
@@ -123,21 +138,25 @@ impl Metric for CosineMetric {
     fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         #[cfg(target_arch = "x86_64")]
         {
-            if is_x86_feature_detected!("avx") && is_x86_feature_detected!("fma") {
+            if is_x86_feature_detected!("avx")
+                && is_x86_feature_detected!("fma")
+                && vector.len() >= MIN_DIM_SIZE_AVX
+            {
                 return Some(unsafe { cosine_preprocess_avx(vector) });
             }
         }
 
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
-            if is_x86_feature_detected!("sse") {
+            if is_x86_feature_detected!("sse") && vector.len() >= MIN_DIM_SIZE_SIMD {
                 return Some(unsafe { cosine_preprocess_sse(vector) });
             }
         }
 
         #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
         {
-            if std::arch::is_aarch64_feature_detected!("neon") {
+            if std::arch::is_aarch64_feature_detected!("neon") && vector.len() >= MIN_DIM_SIZE_SIMD
+            {
                 return Some(unsafe { cosine_preprocess_neon(vector) });
             }
         }

commit 5800319edb20b56cd02add55b011e7ca7db2a0f3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 9 17:32:48 2022 +0200

    refactor distances + add score_threshold + fix negative euclid distance (#569)
    
    * refactor distances + add score_threshold + fix negative euclid distance
    
    * generate docs
    
    * fix clippy
    
    * Update lib/segment/src/spaces/tools.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index bc61163ab..80a8e2201 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -27,11 +27,11 @@ pub struct CosineMetric {}
 pub struct EuclidMetric {}
 
 impl Metric for EuclidMetric {
-    fn distance(&self) -> Distance {
+    fn distance() -> Distance {
         Distance::Euclid
     }
 
-    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    fn similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -59,17 +59,21 @@ impl Metric for EuclidMetric {
         euclid_similarity(v1, v2)
     }
 
-    fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+    fn preprocess(_vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         None
     }
+
+    fn postprocess(score: ScoreType) -> ScoreType {
+        score.abs().sqrt()
+    }
 }
 
 impl Metric for DotProductMetric {
-    fn distance(&self) -> Distance {
+    fn distance() -> Distance {
         Distance::Dot
     }
 
-    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    fn similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -97,17 +101,21 @@ impl Metric for DotProductMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(&self, _vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+    fn preprocess(_vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         None
     }
+
+    fn postprocess(score: ScoreType) -> ScoreType {
+        score
+    }
 }
 
 impl Metric for CosineMetric {
-    fn distance(&self) -> Distance {
+    fn distance() -> Distance {
         Distance::Cosine
     }
 
-    fn similarity(&self, v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    fn similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -135,7 +143,7 @@ impl Metric for CosineMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(&self, vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+    fn preprocess(vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -163,6 +171,10 @@ impl Metric for CosineMetric {
 
         Some(cosine_preprocess(vector))
     }
+
+    fn postprocess(score: ScoreType) -> ScoreType {
+        score
+    }
 }
 
 pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
@@ -172,7 +184,7 @@ pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) ->
         .zip(v2.iter().copied())
         .map(|(a, b)| (a - b).powi(2))
         .sum();
-    -s.sqrt()
+    -s
 }
 
 pub fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
@@ -191,8 +203,7 @@ mod tests {
 
     #[test]
     fn test_cosine_preprocessing() {
-        let metric = CosineMetric {};
-        let res = metric.preprocess(&[0.0, 0.0, 0.0, 0.0]);
+        let res = CosineMetric::preprocess(&[0.0, 0.0, 0.0, 0.0]);
         eprintln!("res = {:#?}", res);
     }
 }

commit 2581a2e3f22817c086be4bc4cb27a6ae00e97a8c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri May 27 16:34:00 2022 +0400

    arm unused const warning (#633)

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 80a8e2201..5502a892e 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -14,7 +14,11 @@ use super::simple_neon::*;
 #[cfg(target_arch = "x86_64")]
 const MIN_DIM_SIZE_AVX: usize = 32;
 
-#[cfg(any(target_arch = "x86", target_arch = "x86_64", target_arch = "aarch64"))]
+#[cfg(any(
+    target_arch = "x86",
+    target_arch = "x86_64",
+    all(target_arch = "aarch64", target_feature = "neon")
+))]
 const MIN_DIM_SIZE_SIMD: usize = 16;
 
 #[derive(Clone)]

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 5502a892e..0ba59e587 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,15 +1,11 @@
-use crate::types::{Distance, ScoreType, VectorElementType};
-
 use super::metric::Metric;
-
-#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-use super::simple_sse::*;
-
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx::*;
-
 #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
 use super::simple_neon::*;
+#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+use super::simple_sse::*;
+use crate::types::{Distance, ScoreType, VectorElementType};
 
 #[cfg(target_arch = "x86_64")]
 const MIN_DIM_SIZE_AVX: usize = 32;

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 0ba59e587..a9c32df11 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -5,7 +5,8 @@ use super::simple_avx::*;
 use super::simple_neon::*;
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 use super::simple_sse::*;
-use crate::types::{Distance, ScoreType, VectorElementType};
+use crate::data_types::vectors::VectorElementType;
+use crate::types::{Distance, ScoreType};
 
 #[cfg(target_arch = "x86_64")]
 const MIN_DIM_SIZE_AVX: usize = 32;

commit e027db4d27255784715b727bbf67abd44dd0d5c0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Nov 9 14:03:49 2022 +0100

    V0.11.2 (#1209)
    
    * Update: unmaintained crate memmap -> memmap2 (#559) (#1160)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * Consensus q n a (#1169)
    
    * Expand comments and minor refactoring for raft state
    
    * fmt
    
    * add comments to consensus.rs
    
    * fix "Consensus q n a" compatibility
    
    * Use less ram for id tracker (#1176)
    
    * use less ram for id tracker
    
    * are you happy clippy
    
    * use vec for internals
    
    * use versions for internal ids
    
    * keys test
    
    * Use less ram for id tracker fixes (#1182)
    
    * WIP: internal_to_version
    
    * fmt
    
    * fix unit tests
    
    * add comment
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * remove suggesting changes in replications on replication factor change (#1177)
    
    * Bump actix-cors from 0.6.3 to 0.6.4 (#1185)
    
    Bumps [actix-cors](https://github.com/actix/actix-extras) from 0.6.3 to 0.6.4.
    - [Release notes](https://github.com/actix/actix-extras/releases)
    - [Commits](https://github.com/actix/actix-extras/compare/cors-v0.6.3...cors-v0.6.4)
    
    ---
    updated-dependencies:
    - dependency-name: actix-cors
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * enable HTTP compression middleware (#1184)
    
    * Use systematically assert_http_ok for better error reporting (#1183)
    
    * Use systematically assert_http_ok for better error reporting
    
    * extraction assertion to use it outside of pytest
    
    * Bump pprof from 0.10.1 to 0.11.0 (#1188)
    
    Bumps [pprof](https://github.com/tikv/pprof-rs) from 0.10.1 to 0.11.0.
    - [Release notes](https://github.com/tikv/pprof-rs/releases)
    - [Changelog](https://github.com/tikv/pprof-rs/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/tikv/pprof-rs/commits)
    
    ---
    updated-dependencies:
    - dependency-name: pprof
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Cosine dist zero vectors (#1198)
    
    * skip pre-processing of zero-length vector for cosine distance
    
    * fmt
    
    * Bump env_logger from 0.9.1 to 0.9.3 (#1201)
    
    Bumps [env_logger](https://github.com/env-logger-rs/env_logger) from 0.9.1 to 0.9.3.
    - [Release notes](https://github.com/env-logger-rs/env_logger/releases)
    - [Changelog](https://github.com/env-logger-rs/env_logger/blob/main/CHANGELOG.md)
    - [Commits](https://github.com/env-logger-rs/env_logger/compare/v0.9.1...v0.9.3)
    
    ---
    updated-dependencies:
    - dependency-name: env_logger
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump indicatif from 0.17.1 to 0.17.2 (#1202)
    
    Bumps [indicatif](https://github.com/console-rs/indicatif) from 0.17.1 to 0.17.2.
    - [Release notes](https://github.com/console-rs/indicatif/releases)
    - [Commits](https://github.com/console-rs/indicatif/compare/0.17.1...0.17.2)
    
    ---
    updated-dependencies:
    - dependency-name: indicatif
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump ordered-float from 3.3.0 to 3.4.0 (#1204)
    
    Bumps [ordered-float](https://github.com/reem/rust-ordered-float) from 3.3.0 to 3.4.0.
    - [Release notes](https://github.com/reem/rust-ordered-float/releases)
    - [Commits](https://github.com/reem/rust-ordered-float/compare/v3.3.0...v3.4.0)
    
    ---
    updated-dependencies:
    - dependency-name: ordered-float
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump clap from 4.0.18 to 4.0.22 (#1205)
    
    Bumps [clap](https://github.com/clap-rs/clap) from 4.0.18 to 4.0.22.
    - [Release notes](https://github.com/clap-rs/clap/releases)
    - [Changelog](https://github.com/clap-rs/clap/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/clap-rs/clap/compare/v4.0.18...v4.0.22)
    
    ---
    updated-dependencies:
    - dependency-name: clap
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump num_cpus from 1.13.1 to 1.14.0 (#1203)
    
    * wait for state deactivation on replica update failure (#1200)
    
    * wait for state deactivation on replica update failure
    
    * review fixes
    
    * upd version to 0.11.2
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: erare-humanum <116254494+erare-humanum@users.noreply.github.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index a9c32df11..578bb1c22 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -151,14 +151,14 @@ impl Metric for CosineMetric {
                 && is_x86_feature_detected!("fma")
                 && vector.len() >= MIN_DIM_SIZE_AVX
             {
-                return Some(unsafe { cosine_preprocess_avx(vector) });
+                return unsafe { cosine_preprocess_avx(vector) };
             }
         }
 
         #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
         {
             if is_x86_feature_detected!("sse") && vector.len() >= MIN_DIM_SIZE_SIMD {
-                return Some(unsafe { cosine_preprocess_sse(vector) });
+                return unsafe { cosine_preprocess_sse(vector) };
             }
         }
 
@@ -166,11 +166,11 @@ impl Metric for CosineMetric {
         {
             if std::arch::is_aarch64_feature_detected!("neon") && vector.len() >= MIN_DIM_SIZE_SIMD
             {
-                return Some(unsafe { cosine_preprocess_neon(vector) });
+                return unsafe { cosine_preprocess_neon(vector) };
             }
         }
 
-        Some(cosine_preprocess(vector))
+        cosine_preprocess(vector)
     }
 
     fn postprocess(score: ScoreType) -> ScoreType {
@@ -188,10 +188,13 @@ pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) ->
     -s
 }
 
-pub fn cosine_preprocess(vector: &[VectorElementType]) -> Vec<VectorElementType> {
+pub fn cosine_preprocess(vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
+    if length < f32::EPSILON {
+        return None;
+    }
     length = length.sqrt();
-    vector.iter().map(|x| x / length).collect()
+    Some(vector.iter().map(|x| x / length).collect())
 }
 
 pub fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
@@ -205,6 +208,6 @@ mod tests {
     #[test]
     fn test_cosine_preprocessing() {
         let res = CosineMetric::preprocess(&[0.0, 0.0, 0.0, 0.0]);
-        eprintln!("res = {:#?}", res);
+        assert!(res.is_none());
     }
 }

commit b9ad046d51ffa7870d00a5707d68d9e8c32e346b
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Sep 1 02:55:22 2023 -0400

    refactor: Make `preprocess()` own its vector argument (#2553)
    
    * make preprocess own its vector argument
    
    * update doc comment

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 578bb1c22..6ba9f73fa 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -5,7 +5,7 @@ use super::simple_avx::*;
 use super::simple_neon::*;
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 use super::simple_sse::*;
-use crate::data_types::vectors::VectorElementType;
+use crate::data_types::vectors::{VectorElementType, VectorType};
 use crate::types::{Distance, ScoreType};
 
 #[cfg(target_arch = "x86_64")]
@@ -60,8 +60,8 @@ impl Metric for EuclidMetric {
         euclid_similarity(v1, v2)
     }
 
-    fn preprocess(_vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        None
+    fn preprocess(vector: VectorType) -> VectorType {
+        vector
     }
 
     fn postprocess(score: ScoreType) -> ScoreType {
@@ -102,8 +102,8 @@ impl Metric for DotProductMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(_vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
-        None
+    fn preprocess(vector: VectorType) -> VectorType {
+        vector
     }
 
     fn postprocess(score: ScoreType) -> ScoreType {
@@ -144,7 +144,7 @@ impl Metric for CosineMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+    fn preprocess(vector: VectorType) -> VectorType {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -188,13 +188,13 @@ pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) ->
     -s
 }
 
-pub fn cosine_preprocess(vector: &[VectorElementType]) -> Option<Vec<VectorElementType>> {
+pub fn cosine_preprocess(vector: VectorType) -> VectorType {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
     if length < f32::EPSILON {
-        return None;
+        return vector;
     }
     length = length.sqrt();
-    Some(vector.iter().map(|x| x / length).collect())
+    vector.iter().map(|x| x / length).collect()
 }
 
 pub fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
@@ -207,7 +207,7 @@ mod tests {
 
     #[test]
     fn test_cosine_preprocessing() {
-        let res = CosineMetric::preprocess(&[0.0, 0.0, 0.0, 0.0]);
-        assert!(res.is_none());
+        let res = CosineMetric::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
+        assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
 }

commit 67c2a414d67318ff0528e3374e41f96b7d6874fb
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Sep 14 12:37:14 2023 -0300

    Recommendation scorer internals (#2538)
    
    * use enum_dispatch on vector_index_base.rs
    
    * add reco_query_scorer.rs
    
    * smol refactor on reco_query_scorer
    
    * add PositiveNegative variant
    
    * recommend query scorer internals
    
    - missing tests
    
    * add test for RecoQuery
    
    * Revert "use enum_dispatch on vector_index_base.rs"
    
    This reverts commit 016e831d00d67ef01e64b4f7a76854e555cd9697.
    
    * remove enum_dispatch usage
    
    * disable score_internal implementation for QuantizedRecoQueryScorer
    
    * refactor test
    
    * refactor with latest preprocess changes
    
    * add reco scorer for async scorer
    
    * add iter_all() helper for RecoQuery
    
    * rename PositiveNegative -> Recommend,
    change variable names,
    refactor quantized query scorer
    
    * refactor new raw scorer
    
    * add tests for comparison raw against async and u8 quant
    
    * smol test improvements
    
    * fix error after rebase
    
    * fmt
    
    * finish score equivalency test, remove dbgs
    
    * make scorer builder for quantized storage
    
    * move query preprocessing to `new()` of quantized query scorers
    
    * self review
    
    * review suggestions
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 6ba9f73fa..f44fa0919 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -19,13 +19,13 @@ const MIN_DIM_SIZE_AVX: usize = 32;
 const MIN_DIM_SIZE_SIMD: usize = 16;
 
 #[derive(Clone)]
-pub struct DotProductMetric {}
+pub struct DotProductMetric;
 
 #[derive(Clone)]
-pub struct CosineMetric {}
+pub struct CosineMetric;
 
 #[derive(Clone)]
-pub struct EuclidMetric {}
+pub struct EuclidMetric;
 
 impl Metric for EuclidMetric {
     fn distance() -> Distance {

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index f44fa0919..b03e293b0 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,3 +1,5 @@
+use common::types::ScoreType;
+
 use super::metric::Metric;
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx::*;
@@ -6,7 +8,7 @@ use super::simple_neon::*;
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 use super::simple_sse::*;
 use crate::data_types::vectors::{VectorElementType, VectorType};
-use crate::types::{Distance, ScoreType};
+use crate::types::Distance;
 
 #[cfg(target_arch = "x86_64")]
 const MIN_DIM_SIZE_AVX: usize = 32;

commit 7ba801545540af06f2e0cee3b2c653b697082c57
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Nov 24 13:02:42 2023 +0100

    Remove redundant copy from sum iterator (#3085)
    
    * Remove redundant copy from sum iterator
    
    * Remove another redundant copied call

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index b03e293b0..23e3f2e65 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -181,13 +181,10 @@ impl Metric for CosineMetric {
 }
 
 pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-    let s: ScoreType = v1
-        .iter()
-        .copied()
-        .zip(v2.iter().copied())
+    -v1.iter()
+        .zip(v2)
         .map(|(a, b)| (a - b).powi(2))
-        .sum();
-    -s
+        .sum::<ScoreType>()
 }
 
 pub fn cosine_preprocess(vector: VectorType) -> VectorType {

commit 8f19257f70e639047cd7e90a6eb8e520ed505460
Author: Kaan C. Fidan <kaancfidan@gmail.com>
Date:   Sat Dec 2 23:28:38 2023 +0300

    Manhattan distance (#3079)
    
    * implemented Manhattan distance
    
    * updated quantization dependency
    
    * fixed negative distances and doc consistency
    
    * fixed neon implementation
    
    * updated quantization dependency
    
    * updated quantization dependency
    
    * removed redundant copy operation
    
    * updated quantization dependency
    
    * Change back to upstream quantization dependency
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 23e3f2e65..7de50f013 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -29,6 +29,9 @@ pub struct CosineMetric;
 #[derive(Clone)]
 pub struct EuclidMetric;
 
+#[derive(Clone)]
+pub struct ManhattanMetric;
+
 impl Metric for EuclidMetric {
     fn distance() -> Distance {
         Distance::Euclid
@@ -71,6 +74,48 @@ impl Metric for EuclidMetric {
     }
 }
 
+impl Metric for ManhattanMetric {
+    fn distance() -> Distance {
+        Distance::Manhattan
+    }
+
+    fn similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+        #[cfg(target_arch = "x86_64")]
+        {
+            if is_x86_feature_detected!("avx")
+                && is_x86_feature_detected!("fma")
+                && v1.len() >= MIN_DIM_SIZE_AVX
+            {
+                return unsafe { manhattan_similarity_avx(v1, v2) };
+            }
+        }
+
+        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
+        {
+            if is_x86_feature_detected!("sse") && v1.len() >= MIN_DIM_SIZE_SIMD {
+                return unsafe { manhattan_similarity_sse(v1, v2) };
+            }
+        }
+
+        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
+        {
+            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
+                return unsafe { manhattan_similarity_neon(v1, v2) };
+            }
+        }
+
+        manhattan_similarity(v1, v2)
+    }
+
+    fn preprocess(vector: VectorType) -> VectorType {
+        vector
+    }
+
+    fn postprocess(score: ScoreType) -> ScoreType {
+        score.abs()
+    }
+}
+
 impl Metric for DotProductMetric {
     fn distance() -> Distance {
         Distance::Dot
@@ -187,6 +232,13 @@ pub fn euclid_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) ->
         .sum::<ScoreType>()
 }
 
+pub fn manhattan_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
+    -v1.iter()
+        .zip(v2)
+        .map(|(a, b)| (a - b).abs())
+        .sum::<ScoreType>()
+}
+
 pub fn cosine_preprocess(vector: VectorType) -> VectorType {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
     if length < f32::EPSILON {

commit bd6bd55033c0bf42fc8f9430c45a7e183de1048e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 13 17:20:23 2023 +0100

    Rename `VectorType` to `DenseVector` (#3192)
    
    * rename vectortype to densevector
    
    * rename enums
    
    * are you happy fmt
    
    * openapi
    
    * revert type renamings

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 7de50f013..51f48034e 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -7,7 +7,7 @@ use super::simple_avx::*;
 use super::simple_neon::*;
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 use super::simple_sse::*;
-use crate::data_types::vectors::{VectorElementType, VectorType};
+use crate::data_types::vectors::{DenseVector, VectorElementType};
 use crate::types::Distance;
 
 #[cfg(target_arch = "x86_64")]
@@ -65,7 +65,7 @@ impl Metric for EuclidMetric {
         euclid_similarity(v1, v2)
     }
 
-    fn preprocess(vector: VectorType) -> VectorType {
+    fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
 
@@ -107,7 +107,7 @@ impl Metric for ManhattanMetric {
         manhattan_similarity(v1, v2)
     }
 
-    fn preprocess(vector: VectorType) -> VectorType {
+    fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
 
@@ -149,7 +149,7 @@ impl Metric for DotProductMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(vector: VectorType) -> VectorType {
+    fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
 
@@ -191,7 +191,7 @@ impl Metric for CosineMetric {
         dot_similarity(v1, v2)
     }
 
-    fn preprocess(vector: VectorType) -> VectorType {
+    fn preprocess(vector: DenseVector) -> DenseVector {
         #[cfg(target_arch = "x86_64")]
         {
             if is_x86_feature_detected!("avx")
@@ -239,7 +239,7 @@ pub fn manhattan_similarity(v1: &[VectorElementType], v2: &[VectorElementType])
         .sum::<ScoreType>()
 }
 
-pub fn cosine_preprocess(vector: VectorType) -> VectorType {
+pub fn cosine_preprocess(vector: DenseVector) -> DenseVector {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
     if length < f32::EPSILON {
         return vector;

commit caa608a1e61b133a1c07031f87885770f5153dd1
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Mar 18 13:44:36 2024 +0100

    Remove duplication in cosine similarity (#3843)

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 51f48034e..1894a4042 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -158,37 +158,14 @@ impl Metric for DotProductMetric {
     }
 }
 
+/// Equivalent to DotProductMetric with normalization of the vectors in preprocessing.
 impl Metric for CosineMetric {
     fn distance() -> Distance {
         Distance::Cosine
     }
 
     fn similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> ScoreType {
-        #[cfg(target_arch = "x86_64")]
-        {
-            if is_x86_feature_detected!("avx")
-                && is_x86_feature_detected!("fma")
-                && v1.len() >= MIN_DIM_SIZE_AVX
-            {
-                return unsafe { dot_similarity_avx(v1, v2) };
-            }
-        }
-
-        #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
-        {
-            if is_x86_feature_detected!("sse") && v1.len() >= MIN_DIM_SIZE_SIMD {
-                return unsafe { dot_similarity_sse(v1, v2) };
-            }
-        }
-
-        #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
-        {
-            if std::arch::is_aarch64_feature_detected!("neon") && v1.len() >= MIN_DIM_SIZE_SIMD {
-                return unsafe { dot_similarity_neon(v1, v2) };
-            }
-        }
-
-        dot_similarity(v1, v2)
+        DotProductMetric::similarity(v1, v2)
     }
 
     fn preprocess(vector: DenseVector) -> DenseVector {

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 1894a4042..b8a8e5002 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -1,6 +1,6 @@
 use common::types::ScoreType;
 
-use super::metric::Metric;
+use super::metric::{Metric, MetricPostProcessing};
 #[cfg(target_arch = "x86_64")]
 use super::simple_avx::*;
 #[cfg(all(target_arch = "aarch64", target_feature = "neon"))]
@@ -32,7 +32,7 @@ pub struct EuclidMetric;
 #[derive(Clone)]
 pub struct ManhattanMetric;
 
-impl Metric for EuclidMetric {
+impl Metric<VectorElementType> for EuclidMetric {
     fn distance() -> Distance {
         Distance::Euclid
     }
@@ -68,13 +68,15 @@ impl Metric for EuclidMetric {
     fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
+}
 
+impl MetricPostProcessing for EuclidMetric {
     fn postprocess(score: ScoreType) -> ScoreType {
         score.abs().sqrt()
     }
 }
 
-impl Metric for ManhattanMetric {
+impl Metric<VectorElementType> for ManhattanMetric {
     fn distance() -> Distance {
         Distance::Manhattan
     }
@@ -110,13 +112,15 @@ impl Metric for ManhattanMetric {
     fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
+}
 
+impl MetricPostProcessing for ManhattanMetric {
     fn postprocess(score: ScoreType) -> ScoreType {
         score.abs()
     }
 }
 
-impl Metric for DotProductMetric {
+impl Metric<VectorElementType> for DotProductMetric {
     fn distance() -> Distance {
         Distance::Dot
     }
@@ -152,14 +156,16 @@ impl Metric for DotProductMetric {
     fn preprocess(vector: DenseVector) -> DenseVector {
         vector
     }
+}
 
+impl MetricPostProcessing for DotProductMetric {
     fn postprocess(score: ScoreType) -> ScoreType {
         score
     }
 }
 
 /// Equivalent to DotProductMetric with normalization of the vectors in preprocessing.
-impl Metric for CosineMetric {
+impl Metric<VectorElementType> for CosineMetric {
     fn distance() -> Distance {
         Distance::Cosine
     }
@@ -196,7 +202,9 @@ impl Metric for CosineMetric {
 
         cosine_preprocess(vector)
     }
+}
 
+impl MetricPostProcessing for CosineMetric {
     fn postprocess(score: ScoreType) -> ScoreType {
         score
     }
@@ -235,7 +243,7 @@ mod tests {
 
     #[test]
     fn test_cosine_preprocessing() {
-        let res = CosineMetric::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
+        let res: DenseVector = CosineMetric::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
         assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
 }

commit fe702da2d884c09a1c1f8fd90a6a029c39b1b01b
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Mar 27 17:08:58 2024 +0100

    Stabilize vector renormalisation (#3928)
    
    * Add normalization stability test
    
    * Move stable preprocess test closer to implementation
    
    * Make renormalizing stable, keep old values if within certain threshold
    
    * Test with 1500 dimensions

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index b8a8e5002..cfa547448 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -7,6 +7,7 @@ use super::simple_avx::*;
 use super::simple_neon::*;
 #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
 use super::simple_sse::*;
+use super::tools::is_length_zero_or_normalized;
 use crate::data_types::vectors::{DenseVector, VectorElementType};
 use crate::types::Distance;
 
@@ -226,7 +227,7 @@ pub fn manhattan_similarity(v1: &[VectorElementType], v2: &[VectorElementType])
 
 pub fn cosine_preprocess(vector: DenseVector) -> DenseVector {
     let mut length: f32 = vector.iter().map(|x| x * x).sum();
-    if length < f32::EPSILON {
+    if is_length_zero_or_normalized(length) {
         return vector;
     }
     length = length.sqrt();
@@ -239,6 +240,8 @@ pub fn dot_similarity(v1: &[VectorElementType], v2: &[VectorElementType]) -> Sco
 
 #[cfg(test)]
 mod tests {
+    use rand::Rng;
+
     use super::*;
 
     #[test]
@@ -246,4 +249,29 @@ mod tests {
         let res: DenseVector = CosineMetric::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
         assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
+
+    /// If we preprocess a vector multiple times, we expect the same result.
+    /// Renormalization should not produce something different.
+    #[test]
+    fn test_cosine_stable_preprocessing() {
+        const DIM: usize = 1500;
+        const ATTEMPTS: usize = 100;
+
+        let mut rng = rand::thread_rng();
+
+        for attempt in 0..ATTEMPTS {
+            let range = rng.gen_range(-2.5..=0.0)..=rng.gen_range(0.0..2.5);
+            let vector: Vec<_> = (0..DIM).map(|_| rng.gen_range(range.clone())).collect();
+
+            // Preprocess and re-preprocess
+            let preprocess1 = CosineMetric::preprocess(vector);
+            let preprocess2: DenseVector = CosineMetric::preprocess(preprocess1.clone());
+
+            // All following preprocess attempts must be the same
+            assert_eq!(
+                preprocess1, preprocess2,
+                "renormalization is not stable (vector #{attempt})"
+            );
+        }
+    }
 }

commit 27595d40a72c25662c886a88e3ff660d2fc4cda3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Apr 17 20:15:50 2024 +0200

    byte metrics simd acceleration (#3976)
    
    * byte metrics simd acceleration
    
    * manhattan and benches
    
    * simd as separate crate
    
    * are you happy fmt
    
    * add compiler flags to cargo
    
    * speedup simd
    
    * neon simd
    
    * use avx2 feature
    
    * refactor
    
    * are you happy fmt
    
    * fix aarch64
    
    * apply simd
    
    * fix x64 build
    
    * apply simf to metrics
    
    * fix arm
    
    * fix cpu features
    
    * refactor
    
    * add basic omments
    
    * are you happy codespell
    
    * review remark
    
    * review remarks

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index cfa547448..befafd783 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -12,14 +12,14 @@ use crate::data_types::vectors::{DenseVector, VectorElementType};
 use crate::types::Distance;
 
 #[cfg(target_arch = "x86_64")]
-const MIN_DIM_SIZE_AVX: usize = 32;
+pub(crate) const MIN_DIM_SIZE_AVX: usize = 32;
 
 #[cfg(any(
     target_arch = "x86",
     target_arch = "x86_64",
     all(target_arch = "aarch64", target_feature = "neon")
 ))]
-const MIN_DIM_SIZE_SIMD: usize = 16;
+pub(crate) const MIN_DIM_SIZE_SIMD: usize = 16;
 
 #[derive(Clone)]
 pub struct DotProductMetric;

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index befafd783..8a5dd0378 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -246,7 +246,7 @@ mod tests {
 
     #[test]
     fn test_cosine_preprocessing() {
-        let res: DenseVector = CosineMetric::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
+        let res = <CosineMetric as Metric<VectorElementType>>::preprocess(vec![0.0, 0.0, 0.0, 0.0]);
         assert_eq!(res, vec![0.0, 0.0, 0.0, 0.0]);
     }
 
@@ -264,8 +264,9 @@ mod tests {
             let vector: Vec<_> = (0..DIM).map(|_| rng.gen_range(range.clone())).collect();
 
             // Preprocess and re-preprocess
-            let preprocess1 = CosineMetric::preprocess(vector);
-            let preprocess2: DenseVector = CosineMetric::preprocess(preprocess1.clone());
+            let preprocess1 = <CosineMetric as Metric<VectorElementType>>::preprocess(vector);
+            let preprocess2: DenseVector =
+                <CosineMetric as Metric<VectorElementType>>::preprocess(preprocess1.clone());
 
             // All following preprocess attempts must be the same
             assert_eq!(

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/spaces/simple.rs b/lib/segment/src/spaces/simple.rs
index 8a5dd0378..155ca5c35 100644
--- a/lib/segment/src/spaces/simple.rs
+++ b/lib/segment/src/spaces/simple.rs
@@ -257,11 +257,11 @@ mod tests {
         const DIM: usize = 1500;
         const ATTEMPTS: usize = 100;
 
-        let mut rng = rand::thread_rng();
+        let mut rng = rand::rng();
 
         for attempt in 0..ATTEMPTS {
-            let range = rng.gen_range(-2.5..=0.0)..=rng.gen_range(0.0..2.5);
-            let vector: Vec<_> = (0..DIM).map(|_| rng.gen_range(range.clone())).collect();
+            let range = rng.random_range(-2.5..=0.0)..=rng.random_range(0.0..2.5);
+            let vector: Vec<_> = (0..DIM).map(|_| rng.random_range(range.clone())).collect();
 
             // Preprocess and re-preprocess
             let preprocess1 = <CosineMetric as Metric<VectorElementType>>::preprocess(vector);

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    