<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actual Output: packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        .empty-content-notice {
            background-color: #f8f8f8;
            border: 1px dashed #ccc;
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            color: #666;
        }
        
        .empty-content-notice p:first-child {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .info-message {
            background-color: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            color: #0366d6;
        }
        
        .info-message p:first-child {
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Actual Output: packages/tldraw/src/lib/shapes/image/ImageShapeUtil.tsx</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../../cases/anthropic_claude-3.5-sonnet-20240620/tldraw_packages_tldraw_src_lib_shapes_image_ImageShapeUtil.tsx.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        
        <section>
            <h2>Raw Model Response</h2>
            
            <pre><code class="language-plaintext">```typescript
export class ImageShapeUtil extends BaseBoxShapeUtil<TLImageShape> {
  static override type = 'image' as const
  static override props = imageShapeProps
  static override migrations = imageShapeMigrations

  override isAspectRatioLocked() {
    return true
  }
  override canCrop() {
    return true
  }

  override getDefaultProps(): TLImageShape['props'] {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: true,
      url: '',
      crop: null,
      flipX: false, 
      flipY: false,
      altText: '',
    }
  }

  override getAriaDescriptor(shape: TLImageShape) {
    return shape.props.altText
  }

  override onResize(shape: TLImageShape, info: TLResizeInfo<TLImageShape>) {
    let resized: TLImageShape = resizeBox(shape, info)
    const { flipX, flipY } = info.initialShape.props
    const { scaleX, scaleY, mode } = info

    resized = {
      ...resized,
      props: {
        ...resized.props,
        flipX: scaleX < 0 !== flipX,
        flipY: scaleY < 0 !== flipY,
      },
    }
    if (!shape.props.crop) return resized

    const flipCropHorizontally =
      (mode === 'scale_shape' && scaleX === -1) ||
      (mode === 'resize_bounds' && flipX !== resized.props.flipX)
    const flipCropVertically =
      (mode === 'scale_shape' && scaleY === -1) ||
      (mode === 'resize_bounds' && flipY !== resized.props.flipY)

    const { topLeft, bottomRight } = shape.props.crop
    resized.props.crop = {
      topLeft: {
        x: flipCropHorizontally ? 1 - bottomRight.x : topLeft.x,
        y: flipCropVertically ? 1 - bottomRight.y : topLeft.y,
      },
      bottomRight: {
        x: flipCropHorizontally ? 1 - topLeft.x : bottomRight.x,
        y: flipCropVertically ? 1 - topLeft.y : bottomRight.y,
      },
    }
    return resized
  }

  component(shape: TLImageShape) {
    return <ImageShape shape={shape} />
  }

  indicator(shape: TLImageShape) {
    const isCropping = this.editor.getCroppingShapeId() === shape.id
    if (isCropping) return null
    return <rect width={toDomPrecision(shape.props.w)} height={toDomPrecision(shape.props.h)} />
  }

  override async toSvg(shape: TLImageShape, ctx: SvgExportContext) {
    if (!shape.props.assetId) return null

    const asset = this.editor.getAsset(shape.props.assetId)

    if (!asset) return null

    const { w } = getUncroppedSize(shape.props, shape.props.crop)

    const src = await imageSvgExportCache.get(asset, async () => {
      let src = await ctx.resolveAssetUrl(asset.id, w)
      if (!src) return null
      if (
        src.startsWith('blob:') ||
        src.startsWith('http') ||
        src.startsWith('/') ||
        src.startsWith('./')
      ) {
        src = (await getDataURIFromURL(src)) || ''
      }

      if (getIsAnimated(this.editor, asset.id)) {
        const { promise } = getFirstFrameOfAnimatedImage(src)
        src = await promise
      }
      return src
    })

    if (!src) return null

    return <SvgImage shape={shape} src={src} />
  }

  override onDoubleClickEdge(shape: TLImageShape) {
    const props = shape.props
    if (!props) return

    if (this.editor.getCroppingShapeId() !== shape.id) {
      return
    }

    const crop = structuredClone(props.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 },
    }

    const { w, h } = getUncroppedSize(shape.props, crop)

    const pointDelta = new Vec(crop.topLeft.x * w, crop.topLeft.y * h).rot(shape.rotation)

    const partial: TLShapePartial<TLImageShape> = {
      id: shape.id,
      type: shape.type,
      x: shape.x - pointDelta.x,
      y: shape.y - pointDelta.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 },
        },
        w,
        h,
      },
    }

    this.editor.updateShapes([partial])
  }

  override getInterpolatedProps(
    startShape: TLImageShape,
    endShape: TLImageShape,
    t: number
  ): TLImageShapeProps {
    function interpolateCrop(
      startShape: TLImageShape,
      endShape: TLImageShape
    ): TLImageShapeProps['crop'] {
      if (startShape.props.crop === null && endShape.props.crop === null) return null

      const startTL = startShape.props.crop?.topLeft || { x: 0, y: 0 }
      const startBR = startShape.props.crop?.bottomRight || { x: 1, y: 1 }
      const endTL = endShape.props.crop?.topLeft || { x: 0, y: 0 }
      const endBR = endShape.props.crop?.bottomRight || { x: 1, y: 1 }

      return {
        topLeft: { x: lerp(startTL.x, endTL.x, t), y: lerp(startTL.y, endTL.y, t) },
        bottomRight: { x: lerp(startBR.x, endBR.x, t), y: lerp(startBR.y, endBR.y, t) },
      }
    }

    return {
      ...(t > 0.5 ? endShape.props : startShape.props),
      w: lerp(startShape.props.w, endShape.props.w, t),
      h: lerp(startShape.props.h, endShape.props.h, t),
      crop: interpolateCrop(startShape, endShape),
    }
  }
}
```</code></pre>
        </section>
        
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    