<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../../cases/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src___tests___ReactIncrementalUpdates-test.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
new file mode 100644
index 0000000000..0d00233462
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -0,0 +1,346 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+'use strict';
+
+var React;
+var ReactNoop;
+
+describe('ReactIncrementalUpdates', () => {
+  beforeEach(() => {
+    jest.resetModuleRegistry();
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop};
+  }
+
+  it('applies updates in order of priority', () => {
+    let state;
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        ReactNoop.deferredUpdates(() => {
+          // Has low priority
+          this.setState({b: 'b'});
+          this.setState({c: 'c'});
+        });
+        // Has Task priority
+        this.setState({a: 'a'});
+      }
+      render() {
+        state = this.state;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flushDeferredPri(25);
+    expect(state).toEqual({a: 'a'});
+    ReactNoop.flush();
+    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+  });
+
+  it('applies updates with equal priority in insertion order', () => {
+    let state;
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        // All have Task priority
+        this.setState({a: 'a'});
+        this.setState({b: 'b'});
+        this.setState({c: 'c'});
+      }
+      render() {
+        state = this.state;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+  });
+
+  it('only drops updates with equal or lesser priority when replaceState is called', () => {
+    let instance;
+    let ops = [];
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        ops.push('componentDidMount');
+      }
+      componentDidUpdate() {
+        ops.push('componentDidUpdate');
+      }
+      render() {
+        ops.push('render');
+        instance = this;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    ReactNoop.flushSync(() => {
+      ReactNoop.deferredUpdates(() => {
+        instance.setState({x: 'x'});
+        instance.setState({y: 'y'});
+      });
+      instance.setState({a: 'a'});
+      instance.setState({b: 'b'});
+      ReactNoop.deferredUpdates(() => {
+        instance.updater.enqueueReplaceState(instance, {c: 'c'});
+        instance.setState({d: 'd'});
+      });
+    });
+
+    // Even though a replaceState has been already scheduled, it hasn't been
+    // flushed yet because it has async priority.
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+    expect(ops).toEqual([
+      'render',
+      'componentDidMount',
+      'render',
+      'componentDidUpdate',
+    ]);
+
+    ops = [];
+
+    ReactNoop.flush();
+    // Now the rest of the updates are flushed, including the replaceState.
+    expect(instance.state).toEqual({c: 'c', d: 'd'});
+    expect(ops).toEqual(['render', 'componentDidUpdate']);
+  });
+
+  it('can abort an update, schedule additional updates, and resume', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return <span prop={Object.keys(this.state).sort().join('')} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    function createUpdate(letter) {
+      return () => {
+        ReactNoop.yield(letter);
+        return {
+          [letter]: letter,
+        };
+      };
+    }
+
+    // Schedule some async updates
+    instance.setState(createUpdate('a'));
+    instance.setState(createUpdate('b'));
+    instance.setState(createUpdate('c'));
+
+    // Begin the updates but don't flush them yet
+    ReactNoop.flushThrough(['a', 'b', 'c']);
+    expect(ReactNoop.getChildren()).toEqual([span('')]);
+
+    // Schedule some more updates at different priorities{
+    instance.setState(createUpdate('d'));
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      instance.setState(createUpdate('f'));
+    });
+    instance.setState(createUpdate('g'));
+
+    // The sync updates should have flushed, but not the async ones
+    expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    expect(ReactNoop.flush()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
+    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+  });
+
+  it('can abort an update, schedule a replaceState, and resume', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return <span prop={Object.keys(this.state).sort().join('')} />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    function createUpdate(letter) {
+      return () => {
+        ReactNoop.yield(letter);
+        return {
+          [letter]: letter,
+        };
+      };
+    }
+
+    // Schedule some async updates
+    instance.setState(createUpdate('a'));
+    instance.setState(createUpdate('b'));
+    instance.setState(createUpdate('c'));
+
+    // Begin the updates but don't flush them yet
+    ReactNoop.flushThrough(['a', 'b', 'c']);
+    expect(ReactNoop.getChildren()).toEqual([span('')]);
+
+    // Schedule some more updates at different priorities{
+    instance.setState(createUpdate('d'));
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      // No longer a public API, but we can test that it works internally by
+      // reaching into the updater.
+      instance.updater.enqueueReplaceState(instance, createUpdate('f'));
+    });
+    instance.setState(createUpdate('g'));
+
+    // The sync updates should have flushed, but not the async ones. Update d
+    // was dropped and replaced by e.
+    expect(ReactNoop.getChildren()).toEqual([span('f')]);
+
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    expect(ReactNoop.flush()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
+    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+  });
+
+  it('passes accumulation of previous updates to replaceState updater function', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return <span />;
+      }
+    }
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    instance.setState({a: 'a'});
+    instance.setState({b: 'b'});
+    // No longer a public API, but we can test that it works internally by
+    // reaching into the updater.
+    instance.updater.enqueueReplaceState(instance, previousState => ({
+      previousState,
+    }));
+    ReactNoop.flush();
+    expect(instance.state).toEqual({previousState: {a: 'a', b: 'b'}});
+  });
+
+  it('does not call callbacks that are scheduled by another callback until a later commit', () => {
+    let ops = [];
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        ops.push('did mount');
+        this.setState({a: 'a'}, () => {
+          ops.push('callback a');
+          this.setState({b: 'b'}, () => {
+            ops.push('callback b');
+          });
+        });
+      }
+      render() {
+        ops.push('render');
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      'render',
+      'did mount',
+      'render',
+      'callback a',
+      'render',
+      'callback b',
+    ]);
+  });
+
+  it('gives setState during reconciliation the same priority as whatever level is currently reconciling', () => {
+    let instance;
+    let ops = [];
+
+    class Foo extends React.Component {
+      state = {};
+      componentWillReceiveProps() {
+        ops.push('componentWillReceiveProps');
+        this.setState({b: 'b'});
+      }
+      render() {
+        ops.push('render');
+        instance = this;
+        return <div />;
+      }
+    }
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    ops = [];
+
+    ReactNoop.flushSync(() => {
+      instance.setState({a: 'a'});
+      ReactNoop.render(<Foo />); // Trigger componentWillReceiveProps
+    });
+
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+    expect(ops).toEqual(['componentWillReceiveProps', 'render']);
+  });
+
+  it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
+    spyOn(console, 'error');
+    let instance;
+    let ops = [];
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        ops.push('render');
+        instance = this;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    ReactNoop.flush();
+
+    instance.setState(function a() {
+      ops.push('setState updater');
+      this.setState({b: 'b'});
+      return {a: 'a'};
+    });
+
+    ReactNoop.flush();
+    expect(ops).toEqual([
+      // Initial render
+      'render',
+      'setState updater',
+      // Update b is enqueued with the same priority as update a, so it should
+      // be flushed in the same commit.
+      'render',
+    ]);
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+
+    expectDev(console.error.calls.count()).toBe(1);
+    console.error.calls.reset();
+  });
+});

commit 3f1f3dc12e72809c997d8e1078edfadd7e31bc14
Author: Anushree Subramani <anushreesubramani@users.noreply.github.com>
Date:   Tue Oct 31 18:05:28 2017 +0530

     Deduplicated many warnings (#11140) (#11216)
    
    *  Deduplicated many warnings (#11140)
    
    *  Deduplicated the following warnings:
    
    1.  Can only update a mounted or mounting component.
        This usually means you called setState, replaceState,
        or forceUpdate on an unmounted component. This is a no-op
    
    2.  %s.componentWillReceiveProps(): Assigning directly to
        this.state is deprecated (except inside a component's
        constructor). Use setState instead.'
    
    3.  An update (setState, replaceState, or forceUpdate) was scheduled
        from inside an update function. Update functions should be pure,
        with zero side-effects. Consider using componentDidUpdate or a
        callback.
    
    4.  setState(...): Cannot call setState() inside getChildContext()
    
    * Code review changes made for #11140
    
    * Minor style fix
    
    * Test deduplication for noop updates in server renderer
    
    * Test deduplication for cWRP warning
    
    * Test deduplication for cWM setState warning
    
    * Test deduplication for unnmounted setState warning
    
    * Fix existing Flow typing
    
    * Test deduplication for invalid updates
    
    * Test deduplication of update-in-updater warning

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 0d00233462..b295897199 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -341,6 +341,19 @@ describe('ReactIncrementalUpdates', () => {
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
     expectDev(console.error.calls.count()).toBe(1);
-    console.error.calls.reset();
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'An update (setState, replaceState, or forceUpdate) was scheduled ' +
+        'from inside an update function. Update functions should be pure, ' +
+        'with zero side-effects. Consider using componentDidUpdate or a ' +
+        'callback.',
+    );
+
+    // Test deduplication
+    instance.setState(function a() {
+      this.setState({a: 'a'});
+      return {b: 'b'};
+    });
+    ReactNoop.flush();
+    expectDev(console.error.calls.count()).toBe(1);
   });
 });

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index b295897199..91b7b03171 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -128,7 +128,13 @@ describe('ReactIncrementalUpdates', () => {
       state = {};
       render() {
         instance = this;
-        return <span prop={Object.keys(this.state).sort().join('')} />;
+        return (
+          <span
+            prop={Object.keys(this.state)
+              .sort()
+              .join('')}
+          />
+        );
       }
     }
 
@@ -177,7 +183,13 @@ describe('ReactIncrementalUpdates', () => {
       state = {};
       render() {
         instance = this;
-        return <span prop={Object.keys(this.state).sort().join('')} />;
+        return (
+          <span
+            prop={Object.keys(this.state)
+              .sort()
+              .join('')}
+          />
+        );
       }
     }
 

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 91b7b03171..d817859798 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -320,7 +320,7 @@ describe('ReactIncrementalUpdates', () => {
   });
 
   it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     let instance;
     let ops = [];
     class Foo extends React.Component {
@@ -352,13 +352,15 @@ describe('ReactIncrementalUpdates', () => {
     ]);
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'An update (setState, replaceState, or forceUpdate) was scheduled ' +
-        'from inside an update function. Update functions should be pure, ' +
-        'with zero side-effects. Consider using componentDidUpdate or a ' +
-        'callback.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'An update (setState, replaceState, or forceUpdate) was scheduled ' +
+          'from inside an update function. Update functions should be pure, ' +
+          'with zero side-effects. Consider using componentDidUpdate or a ' +
+          'callback.',
+      );
+    }
 
     // Test deduplication
     instance.setState(function a() {
@@ -366,6 +368,8 @@ describe('ReactIncrementalUpdates', () => {
       return {b: 'b'};
     });
     ReactNoop.flush();
-    expectDev(console.error.calls.count()).toBe(1);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+    }
   });
 });

commit 6074664f73c6b1ea1f774f2bc698224e3677cef0
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Thu Nov 30 21:59:05 2017 -0200

    react-reconciler: convert vars into let/const (#11729)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index d817859798..b312040d78 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -9,8 +9,8 @@
 
 'use strict';
 
-var React;
-var ReactNoop;
+let React;
+let ReactNoop;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {

commit 0deea326674077598e351803d7a204a1c744a578
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jan 2 18:42:18 2018 +0000

    Run some tests in Node environment (#11948)
    
    * Run some tests in Node environment
    
    * Separate SSR tests that require DOM
    
    This allow us to run others with Node environment.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index b312040d78..6f43d97535 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -5,6 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @emails react-core
+ * @jest-environment node
  */
 
 'use strict';

commit 9f848f8ebec30b3aaa4844ecaef83b014359c5e3
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 13:55:37 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11957)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()
    
    * Updated several additional tests to use .toWarnDev() matcher
    
    * Updated ReactElementValidator to distinguish between Array and Object in its warning. Also updated its test to use .toWarnDev() matcher.
    
    * Updated a couple of additional tests
    
    * Removed unused normalizeCodeLocInfo() methods

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 6f43d97535..037e4c43e1 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -321,7 +321,6 @@ describe('ReactIncrementalUpdates', () => {
   });
 
   it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
-    spyOnDev(console, 'error');
     let instance;
     let ops = [];
     class Foo extends React.Component {
@@ -342,7 +341,12 @@ describe('ReactIncrementalUpdates', () => {
       return {a: 'a'};
     });
 
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'An update (setState, replaceState, or forceUpdate) was scheduled ' +
+        'from inside an update function. Update functions should be pure, ' +
+        'with zero side-effects. Consider using componentDidUpdate or a ' +
+        'callback.',
+    );
     expect(ops).toEqual([
       // Initial render
       'render',
@@ -353,24 +357,11 @@ describe('ReactIncrementalUpdates', () => {
     ]);
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'An update (setState, replaceState, or forceUpdate) was scheduled ' +
-          'from inside an update function. Update functions should be pure, ' +
-          'with zero side-effects. Consider using componentDidUpdate or a ' +
-          'callback.',
-      );
-    }
-
-    // Test deduplication
+    // Test deduplication (no additional warnings expected)
     instance.setState(function a() {
       this.setState({a: 'a'});
       return {b: 'b'};
     });
     ReactNoop.flush();
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-    }
   });
 });

commit 97e2911508a2a7af6f50cf87ae503abe39842bef
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri Jan 19 09:36:46 2018 -0800

    RFC 6: Deprecate unsafe lifecycles (#12028)
    
    * Added unsafe_* lifecycles and deprecation warnings
    If the old lifecycle hooks (componentWillMount, componentWillUpdate, componentWillReceiveProps) are detected, these methods will be called and a deprecation warning will be logged. (In other words, we do not check for both the presence of the old and new lifecycles.) This commit is expected to fail tests.
    
    * Ran lifecycle hook codemod over project
    This should handle the bulk of the updates. I will manually update TypeScript and CoffeeScript tests with another commit.
    The actual command run with this commit was: jscodeshift --parser=flow -t ../react-codemod/transforms/rename-unsafe-lifecycles.js ./packages/**/src/**/*.js
    
    * Manually migrated CoffeeScript and TypeScript tests
    
    * Added inline note to createReactClassIntegration-test
    Explaining why lifecycles hooks have not been renamed in this test.
    
    * Udated NativeMethodsMixin with new lifecycle hooks
    
    * Added static getDerivedStateFromProps to ReactPartialRenderer
    Also added a new set of tests focused on server side lifecycle hooks.
    
    * Added getDerivedStateFromProps to shallow renderer
    Also added warnings for several cases involving getDerivedStateFromProps() as well as the deprecated lifecycles.
    Also added tests for the above.
    
    * Dedupe and DEV-only deprecation warning in server renderer
    
    * Renamed unsafe_* prefix to UNSAFE_* to be more noticeable
    
    * Added getDerivedStateFromProps to ReactFiberClassComponent
    Also updated class component and lifecyle tests to cover the added functionality.
    
    * Warn about UNSAFE_componentWillRecieveProps misspelling
    
    * Added tests to createReactClassIntegration for new lifecycles
    
    * Added warning for stateless functional components with gDSFP
    
    * Added createReactClass test for static gDSFP
    
    * Moved lifecycle deprecation warnings behind (disabled) feature flag
    
    Updated tests accordingly, by temporarily splitting tests that were specific to this feature-flag into their own, internal tests. This was the only way I knew of to interact with the feature flag without breaking our build/dist tests.
    
    * Tidying up
    
    * Tweaked warning message wording slightly
    Replaced 'You may may have returned undefined.' with 'You may have returned undefined.'
    
    * Replaced truthy partialState checks with != null
    
    * Call getDerivedStateFromProps via .call(null) to prevent type access
    
    * Move shallow-renderer didWarn* maps off the instance
    
    * Only call getDerivedStateFromProps if props instance has changed
    
    * Avoid creating new state object if not necessary
    
    * Inject state as a param to callGetDerivedStateFromProps
    This value will be either workInProgress.memoizedState (for updates) or instance.state (for initialization).
    
    * Explicitly warn about uninitialized state before calling getDerivedStateFromProps.
    And added some new tests for this change.
    
    Also:
    * Improved a couple of falsy null/undefined checks to more explicitly check for null or undefined.
    * Made some small tweaks to ReactFiberClassComponent WRT when and how it reads instance.state and sets to null.
    
    * Improved wording for deprecation lifecycle warnings
    
    * Fix state-regression for module-pattern components
    Also add support for new static getDerivedStateFromProps method

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 037e4c43e1..c293a070bf 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -296,7 +296,7 @@ describe('ReactIncrementalUpdates', () => {
 
     class Foo extends React.Component {
       state = {};
-      componentWillReceiveProps() {
+      UNSAFE_componentWillReceiveProps() {
         ops.push('componentWillReceiveProps');
         this.setState({b: 'b'});
       }

commit cba51badce7923f76770149a3248a7baab87bc92
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Jan 23 14:01:55 2018 -0800

    Warn if unsafe lifecycle methods are found in an async subtree (#12060)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index c293a070bf..ff4a35611f 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -307,12 +307,16 @@ describe('ReactIncrementalUpdates', () => {
       }
     }
     ReactNoop.render(<Foo />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'componentWillReceiveProps: Please update the following components ' +
+        'to use static getDerivedStateFromProps instead: Foo',
+    );
 
     ops = [];
 
     ReactNoop.flushSync(() => {
       instance.setState({a: 'a'});
+
       ReactNoop.render(<Foo />); // Trigger componentWillReceiveProps
     });
 

commit d3b183c32326cacc29efea43ca9300a17ed4aca0
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Jan 25 14:30:53 2018 -0800

    Debug render-phase side effects in "strict" mode (#12094)
    
    A new feature flag has been added, debugRenderPhaseSideEffectsForStrictMode. When enabled, StrictMode subtrees will also double-invoke lifecycles in the same way as debugRenderPhaseSideEffects.
    
    By default, this flag is enabled for __DEV__ only. Internally we can toggle it with a GK.
    
    This breaks several of our incremental tests which make use of the noop-renderer. Updating the tests to account for the double-rendering in development mode makes them significantly more complicated. The most straight forward fix for this will be to convert them to be run as internal tests only. I believe this is reasonable since we are the only people making use of the noop renderer.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
deleted file mode 100644
index ff4a35611f..0000000000
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ /dev/null
@@ -1,371 +0,0 @@
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @emails react-core
- * @jest-environment node
- */
-
-'use strict';
-
-let React;
-let ReactNoop;
-
-describe('ReactIncrementalUpdates', () => {
-  beforeEach(() => {
-    jest.resetModuleRegistry();
-    React = require('react');
-    ReactNoop = require('react-noop-renderer');
-  });
-
-  function span(prop) {
-    return {type: 'span', children: [], prop};
-  }
-
-  it('applies updates in order of priority', () => {
-    let state;
-    class Foo extends React.Component {
-      state = {};
-      componentDidMount() {
-        ReactNoop.deferredUpdates(() => {
-          // Has low priority
-          this.setState({b: 'b'});
-          this.setState({c: 'c'});
-        });
-        // Has Task priority
-        this.setState({a: 'a'});
-      }
-      render() {
-        state = this.state;
-        return <div />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flushDeferredPri(25);
-    expect(state).toEqual({a: 'a'});
-    ReactNoop.flush();
-    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
-  });
-
-  it('applies updates with equal priority in insertion order', () => {
-    let state;
-    class Foo extends React.Component {
-      state = {};
-      componentDidMount() {
-        // All have Task priority
-        this.setState({a: 'a'});
-        this.setState({b: 'b'});
-        this.setState({c: 'c'});
-      }
-      render() {
-        state = this.state;
-        return <div />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
-  });
-
-  it('only drops updates with equal or lesser priority when replaceState is called', () => {
-    let instance;
-    let ops = [];
-    class Foo extends React.Component {
-      state = {};
-      componentDidMount() {
-        ops.push('componentDidMount');
-      }
-      componentDidUpdate() {
-        ops.push('componentDidUpdate');
-      }
-      render() {
-        ops.push('render');
-        instance = this;
-        return <div />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    ReactNoop.flushSync(() => {
-      ReactNoop.deferredUpdates(() => {
-        instance.setState({x: 'x'});
-        instance.setState({y: 'y'});
-      });
-      instance.setState({a: 'a'});
-      instance.setState({b: 'b'});
-      ReactNoop.deferredUpdates(() => {
-        instance.updater.enqueueReplaceState(instance, {c: 'c'});
-        instance.setState({d: 'd'});
-      });
-    });
-
-    // Even though a replaceState has been already scheduled, it hasn't been
-    // flushed yet because it has async priority.
-    expect(instance.state).toEqual({a: 'a', b: 'b'});
-    expect(ops).toEqual([
-      'render',
-      'componentDidMount',
-      'render',
-      'componentDidUpdate',
-    ]);
-
-    ops = [];
-
-    ReactNoop.flush();
-    // Now the rest of the updates are flushed, including the replaceState.
-    expect(instance.state).toEqual({c: 'c', d: 'd'});
-    expect(ops).toEqual(['render', 'componentDidUpdate']);
-  });
-
-  it('can abort an update, schedule additional updates, and resume', () => {
-    let instance;
-    class Foo extends React.Component {
-      state = {};
-      render() {
-        instance = this;
-        return (
-          <span
-            prop={Object.keys(this.state)
-              .sort()
-              .join('')}
-          />
-        );
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    function createUpdate(letter) {
-      return () => {
-        ReactNoop.yield(letter);
-        return {
-          [letter]: letter,
-        };
-      };
-    }
-
-    // Schedule some async updates
-    instance.setState(createUpdate('a'));
-    instance.setState(createUpdate('b'));
-    instance.setState(createUpdate('c'));
-
-    // Begin the updates but don't flush them yet
-    ReactNoop.flushThrough(['a', 'b', 'c']);
-    expect(ReactNoop.getChildren()).toEqual([span('')]);
-
-    // Schedule some more updates at different priorities{
-    instance.setState(createUpdate('d'));
-    ReactNoop.flushSync(() => {
-      instance.setState(createUpdate('e'));
-      instance.setState(createUpdate('f'));
-    });
-    instance.setState(createUpdate('g'));
-
-    // The sync updates should have flushed, but not the async ones
-    expect(ReactNoop.getChildren()).toEqual([span('ef')]);
-
-    // Now flush the remaining work. Even though e and f were already processed,
-    // they should be processed again, to ensure that the terminal state
-    // is deterministic.
-    expect(ReactNoop.flush()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
-  });
-
-  it('can abort an update, schedule a replaceState, and resume', () => {
-    let instance;
-    class Foo extends React.Component {
-      state = {};
-      render() {
-        instance = this;
-        return (
-          <span
-            prop={Object.keys(this.state)
-              .sort()
-              .join('')}
-          />
-        );
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    function createUpdate(letter) {
-      return () => {
-        ReactNoop.yield(letter);
-        return {
-          [letter]: letter,
-        };
-      };
-    }
-
-    // Schedule some async updates
-    instance.setState(createUpdate('a'));
-    instance.setState(createUpdate('b'));
-    instance.setState(createUpdate('c'));
-
-    // Begin the updates but don't flush them yet
-    ReactNoop.flushThrough(['a', 'b', 'c']);
-    expect(ReactNoop.getChildren()).toEqual([span('')]);
-
-    // Schedule some more updates at different priorities{
-    instance.setState(createUpdate('d'));
-    ReactNoop.flushSync(() => {
-      instance.setState(createUpdate('e'));
-      // No longer a public API, but we can test that it works internally by
-      // reaching into the updater.
-      instance.updater.enqueueReplaceState(instance, createUpdate('f'));
-    });
-    instance.setState(createUpdate('g'));
-
-    // The sync updates should have flushed, but not the async ones. Update d
-    // was dropped and replaced by e.
-    expect(ReactNoop.getChildren()).toEqual([span('f')]);
-
-    // Now flush the remaining work. Even though e and f were already processed,
-    // they should be processed again, to ensure that the terminal state
-    // is deterministic.
-    expect(ReactNoop.flush()).toEqual(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
-  });
-
-  it('passes accumulation of previous updates to replaceState updater function', () => {
-    let instance;
-    class Foo extends React.Component {
-      state = {};
-      render() {
-        instance = this;
-        return <span />;
-      }
-    }
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    instance.setState({a: 'a'});
-    instance.setState({b: 'b'});
-    // No longer a public API, but we can test that it works internally by
-    // reaching into the updater.
-    instance.updater.enqueueReplaceState(instance, previousState => ({
-      previousState,
-    }));
-    ReactNoop.flush();
-    expect(instance.state).toEqual({previousState: {a: 'a', b: 'b'}});
-  });
-
-  it('does not call callbacks that are scheduled by another callback until a later commit', () => {
-    let ops = [];
-    class Foo extends React.Component {
-      state = {};
-      componentDidMount() {
-        ops.push('did mount');
-        this.setState({a: 'a'}, () => {
-          ops.push('callback a');
-          this.setState({b: 'b'}, () => {
-            ops.push('callback b');
-          });
-        });
-      }
-      render() {
-        ops.push('render');
-        return <div />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-    expect(ops).toEqual([
-      'render',
-      'did mount',
-      'render',
-      'callback a',
-      'render',
-      'callback b',
-    ]);
-  });
-
-  it('gives setState during reconciliation the same priority as whatever level is currently reconciling', () => {
-    let instance;
-    let ops = [];
-
-    class Foo extends React.Component {
-      state = {};
-      UNSAFE_componentWillReceiveProps() {
-        ops.push('componentWillReceiveProps');
-        this.setState({b: 'b'});
-      }
-      render() {
-        ops.push('render');
-        instance = this;
-        return <div />;
-      }
-    }
-    ReactNoop.render(<Foo />);
-    expect(ReactNoop.flush).toWarnDev(
-      'componentWillReceiveProps: Please update the following components ' +
-        'to use static getDerivedStateFromProps instead: Foo',
-    );
-
-    ops = [];
-
-    ReactNoop.flushSync(() => {
-      instance.setState({a: 'a'});
-
-      ReactNoop.render(<Foo />); // Trigger componentWillReceiveProps
-    });
-
-    expect(instance.state).toEqual({a: 'a', b: 'b'});
-    expect(ops).toEqual(['componentWillReceiveProps', 'render']);
-  });
-
-  it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
-    let instance;
-    let ops = [];
-    class Foo extends React.Component {
-      state = {};
-      render() {
-        ops.push('render');
-        instance = this;
-        return <div />;
-      }
-    }
-
-    ReactNoop.render(<Foo />);
-    ReactNoop.flush();
-
-    instance.setState(function a() {
-      ops.push('setState updater');
-      this.setState({b: 'b'});
-      return {a: 'a'};
-    });
-
-    expect(ReactNoop.flush).toWarnDev(
-      'An update (setState, replaceState, or forceUpdate) was scheduled ' +
-        'from inside an update function. Update functions should be pure, ' +
-        'with zero side-effects. Consider using componentDidUpdate or a ' +
-        'callback.',
-    );
-    expect(ops).toEqual([
-      // Initial render
-      'render',
-      'setState updater',
-      // Update b is enqueued with the same priority as update a, so it should
-      // be flushed in the same commit.
-      'render',
-    ]);
-    expect(instance.state).toEqual({a: 'a', b: 'b'});
-
-    // Test deduplication (no additional warnings expected)
-    instance.setState(function a() {
-      this.setState({a: 'a'});
-      return {b: 'b'};
-    });
-    ReactNoop.flush();
-  });
-});

commit 147bdef11bbeb8f4aef18c56d53ec1591fce8653
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 8 20:54:54 2020 -0700

    Port more tests to the Scheduler.unstable_yieldValue pattern and drop internal.js (#18549)
    
    * Drop the .internal.js suffix on some files that don't need it anymore
    
    * Port some ops patterns to scheduler yield
    
    * Fix triangle test to avoid side-effects in constructor
    
    * Move replaying of setState updaters until after the effect
    
    Otherwise any warnings get silenced if they're deduped.
    
    * Drop .internal.js in more files
    
    * Don't check propTypes on a simple memo component unless it's lazy
    
    Comparing the elementType doesn't work for this because it will never be
    the same for a simple element.
    
    This caused us to double validate these. This was covered up because in
    internal tests this was deduped since they shared the prop types cache
    but since we now inline it, it doesn't get deduped.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
new file mode 100644
index 0000000000..51753f0e3f
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -0,0 +1,921 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ * @jest-environment node
+ */
+
+'use strict';
+
+let React;
+let ReactNoop;
+let Scheduler;
+
+describe('ReactIncrementalUpdates', () => {
+  beforeEach(() => {
+    jest.resetModuleRegistry();
+
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+    Scheduler = require('scheduler');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop, hidden: false};
+  }
+
+  it('applies updates in order of priority', () => {
+    let state;
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        Scheduler.unstable_yieldValue('commit');
+        ReactNoop.deferredUpdates(() => {
+          // Has low priority
+          this.setState({b: 'b'});
+          this.setState({c: 'c'});
+        });
+        // Has Task priority
+        this.setState({a: 'a'});
+      }
+      render() {
+        state = this.state;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushAndYieldThrough(['commit']);
+    expect(state).toEqual({a: 'a'});
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+  });
+
+  it('applies updates with equal priority in insertion order', () => {
+    let state;
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        // All have Task priority
+        this.setState({a: 'a'});
+        this.setState({b: 'b'});
+        this.setState({c: 'c'});
+      }
+      render() {
+        state = this.state;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+  });
+
+  it('only drops updates with equal or lesser priority when replaceState is called', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        Scheduler.unstable_yieldValue('componentDidMount');
+      }
+      componentDidUpdate() {
+        Scheduler.unstable_yieldValue('componentDidUpdate');
+      }
+      render() {
+        Scheduler.unstable_yieldValue('render');
+        instance = this;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushAndYield(['render', 'componentDidMount']);
+
+    ReactNoop.flushSync(() => {
+      ReactNoop.deferredUpdates(() => {
+        instance.setState({x: 'x'});
+        instance.setState({y: 'y'});
+      });
+      instance.setState({a: 'a'});
+      instance.setState({b: 'b'});
+      ReactNoop.deferredUpdates(() => {
+        instance.updater.enqueueReplaceState(instance, {c: 'c'});
+        instance.setState({d: 'd'});
+      });
+    });
+
+    // Even though a replaceState has been already scheduled, it hasn't been
+    // flushed yet because it has async priority.
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+    expect(Scheduler).toHaveYielded(['render', 'componentDidUpdate']);
+
+    expect(Scheduler).toFlushAndYield(['render', 'componentDidUpdate']);
+    // Now the rest of the updates are flushed, including the replaceState.
+    expect(instance.state).toEqual({c: 'c', d: 'd'});
+  });
+
+  it('can abort an update, schedule additional updates, and resume', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return (
+          <span
+            prop={Object.keys(this.state)
+              .sort()
+              .join('')}
+          />
+        );
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    function createUpdate(letter) {
+      return () => {
+        Scheduler.unstable_yieldValue(letter);
+        return {
+          [letter]: letter,
+        };
+      };
+    }
+
+    // Schedule some async updates
+    instance.setState(createUpdate('a'));
+    instance.setState(createUpdate('b'));
+    instance.setState(createUpdate('c'));
+
+    // Begin the updates but don't flush them yet
+    expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
+    expect(ReactNoop.getChildren()).toEqual([span('')]);
+
+    // Schedule some more updates at different priorities
+    instance.setState(createUpdate('d'));
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      instance.setState(createUpdate('f'));
+    });
+    instance.setState(createUpdate('g'));
+
+    // The sync updates should have flushed, but not the async ones
+    expect(Scheduler).toHaveYielded(['e', 'f']);
+    expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    expect(Scheduler).toFlushAndYield([
+      'a',
+      'b',
+      'c',
+
+      // e, f, and g are in a separate batch from a, b, and c because they
+      // were scheduled in the middle of a render
+      'e',
+      'f',
+      'g',
+
+      'd',
+      'e',
+      'f',
+      'g',
+    ]);
+    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+  });
+
+  it('can abort an update, schedule a replaceState, and resume', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return (
+          <span
+            prop={Object.keys(this.state)
+              .sort()
+              .join('')}
+          />
+        );
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    function createUpdate(letter) {
+      return () => {
+        Scheduler.unstable_yieldValue(letter);
+        return {
+          [letter]: letter,
+        };
+      };
+    }
+
+    // Schedule some async updates
+    instance.setState(createUpdate('a'));
+    instance.setState(createUpdate('b'));
+    instance.setState(createUpdate('c'));
+
+    // Begin the updates but don't flush them yet
+    expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
+    expect(ReactNoop.getChildren()).toEqual([span('')]);
+
+    // Schedule some more updates at different priorities{
+    instance.setState(createUpdate('d'));
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      // No longer a public API, but we can test that it works internally by
+      // reaching into the updater.
+      instance.updater.enqueueReplaceState(instance, createUpdate('f'));
+    });
+    instance.setState(createUpdate('g'));
+
+    // The sync updates should have flushed, but not the async ones. Update d
+    // was dropped and replaced by e.
+    expect(Scheduler).toHaveYielded(['e', 'f']);
+    expect(ReactNoop.getChildren()).toEqual([span('f')]);
+
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    expect(Scheduler).toFlushAndYield([
+      'a',
+      'b',
+      'c',
+
+      // e, f, and g are in a separate batch from a, b, and c because they
+      // were scheduled in the middle of a render
+      'e',
+      'f',
+      'g',
+
+      'd',
+      'e',
+      'f',
+      'g',
+    ]);
+    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+  });
+
+  it('passes accumulation of previous updates to replaceState updater function', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        instance = this;
+        return <span />;
+      }
+    }
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    instance.setState({a: 'a'});
+    instance.setState({b: 'b'});
+    // No longer a public API, but we can test that it works internally by
+    // reaching into the updater.
+    instance.updater.enqueueReplaceState(instance, previousState => ({
+      previousState,
+    }));
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(instance.state).toEqual({previousState: {a: 'a', b: 'b'}});
+  });
+
+  it('does not call callbacks that are scheduled by another callback until a later commit', () => {
+    class Foo extends React.Component {
+      state = {};
+      componentDidMount() {
+        Scheduler.unstable_yieldValue('did mount');
+        this.setState({a: 'a'}, () => {
+          Scheduler.unstable_yieldValue('callback a');
+          this.setState({b: 'b'}, () => {
+            Scheduler.unstable_yieldValue('callback b');
+          });
+        });
+      }
+      render() {
+        Scheduler.unstable_yieldValue('render');
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushAndYield([
+      'render',
+      'did mount',
+      'render',
+      'callback a',
+      'render',
+      'callback b',
+    ]);
+  });
+
+  it('gives setState during reconciliation the same priority as whatever level is currently reconciling', () => {
+    let instance;
+
+    class Foo extends React.Component {
+      state = {};
+      UNSAFE_componentWillReceiveProps() {
+        Scheduler.unstable_yieldValue('componentWillReceiveProps');
+        this.setState({b: 'b'});
+      }
+      render() {
+        Scheduler.unstable_yieldValue('render');
+        instance = this;
+        return <div />;
+      }
+    }
+    ReactNoop.render(<Foo />);
+    expect(() =>
+      expect(Scheduler).toFlushAndYield(['render']),
+    ).toErrorDev(
+      'Using UNSAFE_componentWillReceiveProps in strict mode is not recommended',
+      {withoutStack: true},
+    );
+
+    ReactNoop.flushSync(() => {
+      instance.setState({a: 'a'});
+
+      ReactNoop.render(<Foo />); // Trigger componentWillReceiveProps
+    });
+
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+    expect(Scheduler).toHaveYielded(['componentWillReceiveProps', 'render']);
+  });
+
+  it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
+    let instance;
+    class Foo extends React.Component {
+      state = {};
+      render() {
+        Scheduler.unstable_yieldValue('render');
+        instance = this;
+        return <div />;
+      }
+    }
+
+    ReactNoop.render(<Foo />);
+    expect(Scheduler).toFlushAndYield([
+      // Initial render
+      'render',
+    ]);
+
+    instance.setState(function a() {
+      Scheduler.unstable_yieldValue('setState updater');
+      this.setState({b: 'b'});
+      return {a: 'a'};
+    });
+
+    expect(() =>
+      expect(Scheduler).toFlushAndYield([
+        'setState updater',
+        // Update b is enqueued with the same priority as update a, so it should
+        // be flushed in the same commit.
+        'render',
+      ]),
+    ).toErrorDev(
+      'An update (setState, replaceState, or forceUpdate) was scheduled ' +
+        'from inside an update function. Update functions should be pure, ' +
+        'with zero side-effects. Consider using componentDidUpdate or a ' +
+        'callback.',
+    );
+    expect(instance.state).toEqual({a: 'a', b: 'b'});
+
+    // Test deduplication (no additional warnings expected)
+    instance.setState(function a() {
+      this.setState({a: 'a'});
+      return {b: 'b'};
+    });
+    expect(Scheduler).toFlushAndYield(['render']);
+  });
+
+  it('getDerivedStateFromProps should update base state of updateQueue (based on product bug)', () => {
+    // Based on real-world bug.
+
+    let foo;
+    class Foo extends React.Component {
+      state = {value: 'initial state'};
+      static getDerivedStateFromProps() {
+        return {value: 'derived state'};
+      }
+      render() {
+        foo = this;
+        return (
+          <>
+            <span prop={this.state.value} />
+            <Bar />
+          </>
+        );
+      }
+    }
+
+    let bar;
+    class Bar extends React.Component {
+      render() {
+        bar = this;
+        return null;
+      }
+    }
+
+    ReactNoop.flushSync(() => {
+      ReactNoop.render(<Foo />);
+    });
+    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+
+    ReactNoop.flushSync(() => {
+      // Triggers getDerivedStateFromProps again
+      ReactNoop.render(<Foo />);
+      // The noop callback is needed to trigger the specific internal path that
+      // led to this bug. Removing it causes it to "accidentally" work.
+      foo.setState({value: 'update state'}, function noop() {});
+    });
+    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+
+    ReactNoop.flushSync(() => {
+      bar.setState({});
+    });
+    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+  });
+
+  it('flushes all expired updates in a single batch', () => {
+    const {useEffect} = React;
+
+    function App({label}) {
+      Scheduler.unstable_yieldValue('Render: ' + label);
+      useEffect(() => {
+        Scheduler.unstable_yieldValue('Commit: ' + label);
+      });
+      return label;
+    }
+
+    function interrupt() {
+      ReactNoop.flushSync(() => {
+        ReactNoop.renderToRootWithID(null, 'other-root');
+      });
+    }
+
+    // First, as a sanity check, assert what happens when four low pri
+    // updates in separate batches are all flushed in the same callback
+    ReactNoop.act(() => {
+      ReactNoop.render(<App label="" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="he" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="hell" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="hello" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      // Each update flushes in a separate commit.
+      // Note: This isn't necessarily the ideal behavior. It might be better to
+      // batch all of these updates together. The fact that they don't is an
+      // implementation detail. The important part of this unit test is what
+      // happens when they expire, in which case they really should be batched to
+      // avoid blocking the main thread for a long time.
+      expect(Scheduler).toFlushAndYield([
+        'Render: ',
+        'Commit: ',
+        'Render: he',
+        'Commit: he',
+        'Render: hell',
+        'Commit: hell',
+        'Render: hello',
+        'Commit: hello',
+      ]);
+    });
+
+    ReactNoop.act(() => {
+      // Now do the same thing over again, but this time, expire all the updates
+      // instead of flushing them normally.
+      ReactNoop.render(<App label="" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="go" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="good" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.render(<App label="goodbye" />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      // All the updates should render and commit in a single batch.
+      Scheduler.unstable_advanceTime(10000);
+      expect(Scheduler).toFlushExpired(['Render: goodbye']);
+      // Passive effect
+      expect(Scheduler).toFlushAndYield(['Commit: goodbye']);
+    });
+  });
+
+  it('flushes all expired updates in a single batch across multiple roots', () => {
+    // Same as previous test, but with two roots.
+    const {useEffect} = React;
+
+    function App({label}) {
+      Scheduler.unstable_yieldValue('Render: ' + label);
+      useEffect(() => {
+        Scheduler.unstable_yieldValue('Commit: ' + label);
+      });
+      return label;
+    }
+
+    function interrupt() {
+      ReactNoop.flushSync(() => {
+        ReactNoop.renderToRootWithID(null, 'other-root');
+      });
+    }
+    ReactNoop.act(() => {
+      // First, as a sanity check, assert what happens when four low pri
+      // updates in separate batches are all flushed in the same callback
+      ReactNoop.renderToRootWithID(<App label="" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="he" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="he" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="hell" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="hell" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="hello" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="hello" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      // Each update flushes in a separate commit.
+      // Note: This isn't necessarily the ideal behavior. It might be better to
+      // batch all of these updates together. The fact that they don't is an
+      // implementation detail. The important part of this unit test is what
+      // happens when they expire, in which case they really should be batched to
+      // avoid blocking the main thread for a long time.
+      expect(Scheduler).toFlushAndYield([
+        'Render: ',
+        'Commit: ',
+        'Render: ',
+        'Commit: ',
+        'Render: he',
+        'Commit: he',
+        'Render: he',
+        'Commit: he',
+        'Render: hell',
+        'Commit: hell',
+        'Render: hell',
+        'Commit: hell',
+        'Render: hello',
+        'Commit: hello',
+        'Render: hello',
+        'Commit: hello',
+      ]);
+    });
+
+    ReactNoop.act(() => {
+      // Now do the same thing over again, but this time, expire all the updates
+      // instead of flushing them normally.
+      ReactNoop.renderToRootWithID(<App label="" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="go" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="go" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="good" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="good" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      ReactNoop.renderToRootWithID(<App label="goodbye" />, 'a');
+      ReactNoop.renderToRootWithID(<App label="goodbye" />, 'b');
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
+      interrupt();
+
+      // All the updates should render and commit in a single batch.
+      Scheduler.unstable_advanceTime(10000);
+      expect(Scheduler).toFlushExpired([
+        'Render: goodbye',
+        'Commit: goodbye',
+        'Render: goodbye',
+      ]);
+      // Passive effect
+      expect(Scheduler).toFlushAndYield(['Commit: goodbye']);
+    });
+  });
+
+  it('does not throw out partially completed tree if it expires midway through', () => {
+    function Text({text}) {
+      Scheduler.unstable_yieldValue(text);
+      return text;
+    }
+
+    function App({step}) {
+      return (
+        <>
+          <Text text={`A${step}`} />
+          <Text text={`B${step}`} />
+          <Text text={`C${step}`} />
+        </>
+      );
+    }
+
+    function interrupt() {
+      ReactNoop.flushSync(() => {
+        ReactNoop.renderToRootWithID(null, 'other-root');
+      });
+    }
+
+    // First, as a sanity check, assert what happens when four low pri
+    // updates in separate batches are all flushed in the same callback
+    ReactNoop.act(() => {
+      ReactNoop.render(<App step={1} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={2} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={3} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={4} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      // Each update flushes in a separate commit.
+      // Note: This isn't necessarily the ideal behavior. It might be better to
+      // batch all of these updates together. The fact that they don't is an
+      // implementation detail. The important part of this unit test is what
+      // happens when they expire, in which case they really should be batched to
+      // avoid blocking the main thread for a long time.
+      expect(Scheduler).toFlushAndYield([
+        // A1 already completed. Finish rendering the first level.
+        'B1',
+        'C1',
+        // The remaining two levels complete sequentially.
+        'A2',
+        'B2',
+        'C2',
+        'A3',
+        'B3',
+        'C3',
+        'A4',
+        'B4',
+        'C4',
+      ]);
+    });
+
+    ReactNoop.act(() => {
+      // Now do the same thing over again, but this time, expire all the updates
+      // instead of flushing them normally.
+      ReactNoop.render(<App step={1} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={2} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={3} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      interrupt();
+
+      ReactNoop.render(<App step={4} />);
+      Scheduler.unstable_advanceTime(1000);
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+
+      // Expire all the updates
+      ReactNoop.expire(10000);
+
+      expect(Scheduler).toFlushExpired([
+        // A1 already completed. Finish rendering the first level.
+        'B1',
+        'C1',
+        // Then render the remaining two levels in a single batch
+        'A4',
+        'B4',
+        'C4',
+      ]);
+    });
+  });
+
+  it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
+    const {useState, useLayoutEffect} = React;
+
+    let pushToLog;
+    function App() {
+      const [log, setLog] = useState('');
+      pushToLog = msg => {
+        setLog(prevLog => prevLog + msg);
+      };
+
+      useLayoutEffect(() => {
+        Scheduler.unstable_yieldValue('Committed: ' + log);
+        if (log === 'B') {
+          // Right after B commits, schedule additional updates.
+          Scheduler.unstable_runWithPriority(
+            Scheduler.unstable_UserBlockingPriority,
+            () => {
+              pushToLog('C');
+            },
+          );
+          setLog(prevLog => prevLog + 'D');
+        }
+      }, [log]);
+
+      return log;
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded(['Committed: ']);
+    expect(root).toMatchRenderedOutput('');
+
+    await ReactNoop.act(async () => {
+      pushToLog('A');
+      Scheduler.unstable_runWithPriority(
+        Scheduler.unstable_UserBlockingPriority,
+        () => {
+          pushToLog('B');
+        },
+      );
+    });
+    expect(Scheduler).toHaveYielded([
+      // A and B are pending. B is higher priority, so we'll render that first.
+      'Committed: B',
+      // Because A comes first in the queue, we're now in rebase mode. B must
+      // be rebased on top of A. Also, in a layout effect, we received two new
+      // updates: C and D. C is user-blocking and D is synchronous.
+      //
+      // First render the synchronous update. What we're testing here is that
+      // B *is not dropped* even though it has lower than sync priority. That's
+      // because we already committed it. However, this render should not
+      // include C, because that update wasn't already committed.
+      'Committed: BD',
+      'Committed: BCD',
+      'Committed: ABCD',
+    ]);
+    expect(root).toMatchRenderedOutput('ABCD');
+  });
+
+  it('when rebasing, does not exclude updates that were already committed, regardless of priority (classes)', async () => {
+    let pushToLog;
+    class App extends React.Component {
+      state = {log: ''};
+      pushToLog = msg => {
+        this.setState(prevState => ({log: prevState.log + msg}));
+      };
+      componentDidUpdate() {
+        Scheduler.unstable_yieldValue('Committed: ' + this.state.log);
+        if (this.state.log === 'B') {
+          // Right after B commits, schedule additional updates.
+          Scheduler.unstable_runWithPriority(
+            Scheduler.unstable_UserBlockingPriority,
+            () => {
+              this.pushToLog('C');
+            },
+          );
+          this.pushToLog('D');
+        }
+      }
+      render() {
+        pushToLog = this.pushToLog;
+        return this.state.log;
+      }
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded([]);
+    expect(root).toMatchRenderedOutput('');
+
+    await ReactNoop.act(async () => {
+      pushToLog('A');
+      Scheduler.unstable_runWithPriority(
+        Scheduler.unstable_UserBlockingPriority,
+        () => {
+          pushToLog('B');
+        },
+      );
+    });
+    expect(Scheduler).toHaveYielded([
+      // A and B are pending. B is higher priority, so we'll render that first.
+      'Committed: B',
+      // Because A comes first in the queue, we're now in rebase mode. B must
+      // be rebased on top of A. Also, in a layout effect, we received two new
+      // updates: C and D. C is user-blocking and D is synchronous.
+      //
+      // First render the synchronous update. What we're testing here is that
+      // B *is not dropped* even though it has lower than sync priority. That's
+      // because we already committed it. However, this render should not
+      // include C, because that update wasn't already committed.
+      'Committed: BD',
+      'Committed: BCD',
+      'Committed: ABCD',
+    ]);
+    expect(root).toMatchRenderedOutput('ABCD');
+  });
+
+  it("base state of update queue is initialized to its fiber's memoized state", async () => {
+    // This test is very weird because it tests an implementation detail but
+    // is tested in terms of public APIs. When it was originally written, the
+    // test failed because the update queue was initialized to the state of
+    // the alternate fiber.
+    let app;
+    class App extends React.Component {
+      state = {prevProp: 'A', count: 0};
+      static getDerivedStateFromProps(props, state) {
+        // Add 100 whenever the label prop changes. The prev label is stored
+        // in state. If the state is dropped incorrectly, we'll fail to detect
+        // prop changes.
+        if (props.prop !== state.prevProp) {
+          return {
+            prevProp: props.prop,
+            count: state.count + 100,
+          };
+        }
+        return null;
+      }
+      render() {
+        app = this;
+        return this.state.count;
+      }
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App prop="A" />);
+    });
+    expect(root).toMatchRenderedOutput('0');
+
+    // Changing the prop causes the count to increase by 100
+    await ReactNoop.act(async () => {
+      root.render(<App prop="B" />);
+    });
+    expect(root).toMatchRenderedOutput('100');
+
+    // Now increment the count by 1 with a state update. And, in the same
+    // batch, change the prop back to its original value.
+    await ReactNoop.act(async () => {
+      root.render(<App prop="A" />);
+      app.setState(state => ({count: state.count + 1}));
+    });
+    // There were two total prop changes, plus an increment.
+    expect(root).toMatchRenderedOutput('201');
+  });
+});

commit db6513914f99c260090f26f0a547ee1432c934e6
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 24 23:26:04 2020 -0700

    Make ExpirationTime an opaque type (#18732)
    
    * Add LanePriority type
    
    React's internal scheduler has more priority levels than the external
    Scheduler package. Let's use React as the source of truth for tracking
    the priority of updates so we have more control. We'll still fall back
    to Scheduler in the default case. In the future, we should consider
    removing `runWithPriority` from Scheduler and replacing the valid use
    cases with React-specific APIs.
    
    This commit adds a new type, called a LanePriority to disambiguate from
    the Scheduler one.
    
    ("Lane" refers to another type that I'm planning. It roughly translates
    to "thread." Each lane will have a priority associated with it.)
    
    I'm not actually using the lane anywhere, yet. Only setting stuff up.
    
    * Remove expiration times train model
    
    In the old reconciler, expiration times are computed by applying an
    offset to the current system time. This has the effect of increasing
    the priority of updates as time progresses. Because we also use
    expiration times as a kind of "thread" identifier, it turns out this
    is quite limiting because we can only flush work sequentially along
    the timeline.
    
    The new model will use a bitmask to represent parallel threads that
    can be worked on in any combination and in any order.
    
    In this commit, expiration times and the linear timeline are still in
    place, but they are no longer based on a timestamp. Effectively, they
    are constants based on their priority level.
    
    * Stop using ExpirationTime to represent timestamps
    
    Follow up to the previous commit. This converts the remaining places
    where we were using the ExpirationTime type to represent a timestamp,
    like Suspense timeouts.
    
    * Fork Dependencies and PendingInteractionMap types
    
    These contain expiration times
    
    * Make ExpirationTime an opaque type
    
    ExpirationTime is currently just an alias for the `number` type, for a
    few reasons. One is that it predates Flow's opaque type feature. Another
    is that making it opaque means we have to move all our comparisons and
    number math to the ExpirationTime module, and use utility functions
    everywhere else.
    
    However, this is actually what we want in the new system, because the
    Lanes type that will replace ExpirationTime is a bitmask with a
    particular layout, and performing operations on it will involve more
    than just number comparisions and artihmetic. I don't want this logic to
    spread ad hoc around the whole codebase.
    
    The utility functions get inlined by Closure so it doesn't matter
    performance-wise.
    
    I automated most of the changes with JSCodeshift, with only a few manual
    tweaks to stuff like imports. My goal was to port the logic exactly to
    prevent subtle mistakes, without trying to simplify anything in the
    process. I'll likely need to audit many of these sites again when I
    replace them with the new type, though, especially the ones
    in ReactFiberRoot.
    
    I added the codemods I used to the `scripts` directory. I won't merge
    these to master. I'll remove them in a subsequent commit. I'm only
    committing them here so they show up in the PR for future reference.
    
    I had a lot of trouble getting Flow to pass. Somehow it was not
    inferring the correct type of the constants exported from the
    ExpirationTime module, despite being annotated correctly.
    
    I tried converting them them to constructor functions — `NoWork`
    becomes `NoWork()` — and that made it work. I used that to unblock me,
    and fixed all the other type errors. Once there were no more type
    errors, I tried converting the constructors back to constants. Started
    getting errors again.
    
    Then I added a type constraint everywhere a constant was referenced.
    That fixed it. I also figured out that you only have to add a constraint
    when the constant is passed to another function, even if the function is
    annotated. So this indicates to me that it's probably a Flow bug. I'll
    file an issue with Flow.
    
    * Delete temporary codemods used in previous commit
    
    I only added these to the previous commit so that I can easily run it
    again when rebasing. When the stack is squashed, it will be as if they
    never existed.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 51753f0e3f..0e6c1d7aef 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -442,6 +442,9 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
+  // Note: This test doesn't really make sense in the new model, but we might
+  // want to port it once lanes are implemented.
+  // @gate old
   it('flushes all expired updates in a single batch', () => {
     const {useEffect} = React;
 
@@ -531,6 +534,9 @@ describe('ReactIncrementalUpdates', () => {
     });
   });
 
+  // Note: This test doesn't really make sense in the new model, but we might
+  // want to port it once lanes are implemented.
+  // @gate old
   it('flushes all expired updates in a single batch across multiple roots', () => {
     // Same as previous test, but with two roots.
     const {useEffect} = React;
@@ -640,6 +646,9 @@ describe('ReactIncrementalUpdates', () => {
     });
   });
 
+  // Note: This test doesn't really make sense in the new model, but we might
+  // want to port it once lanes are implemented.
+  // @gate old
   it('does not throw out partially completed tree if it expires midway through', () => {
     function Text({text}) {
       Scheduler.unstable_yieldValue(text);

commit 93e078ddf274636b0a40bd5501ce3549aec700fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat May 2 17:09:31 2020 -0700

    Initial Lanes implementation (#18796)
    
    See PR #18796 for more information.
    
    All of the changes I've made in this commit are behind the
    `enableNewReconciler` flag. Merging this to master will not affect the
    open source builds or the build that we ship to Facebook.
    
    The only build that is affected is the `ReactDOMForked` build, which is
    deployed to Facebook **behind an experimental flag (currently disabled
    for all users)**. We will use this flag to gradually roll out the new
    reconciler, and quickly roll it back if we find any problems.
    
    Because we have those protections in place, what I'm aiming for with
    this initial PR is the **smallest possible atomic change that lands
    cleanly and doesn't rely on too many hacks**. The goal has not been to
    get every single test or feature passing, and it definitely is not to
    implement all the features that we intend to build on top of the new
    model. When possible, I have chosen to preserve existing semantics and
    defer changes to follow-up steps. (Listed in the section below.)
    
    (I did not end up having to disable any tests, although if I had, that
    should not have necessarily been a merge blocker.)
    
    For example, even though one of the primary goals of this project is to
    improve our model for parallel Suspense transitions, in this initial
    implementation, I have chosen to keep the same core heuristics for
    sequencing and flushing that existed in the ExpirationTimes model: low
    priority updates cannot finish without also finishing high priority
    ones.
    
    Despite all these precautions, **because the scope of this refactor is
    inherently large, I do expect we will find regressions.** The flip side
    is that I also expect the new model to improve the stability of the
    codebase and make it easier to fix bugs when they arise.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 0e6c1d7aef..90a327d734 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -170,22 +170,32 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    expect(Scheduler).toFlushAndYield([
-      'a',
-      'b',
-      'c',
-
-      // e, f, and g are in a separate batch from a, b, and c because they
-      // were scheduled in the middle of a render
-      'e',
-      'f',
-      'g',
-
-      'd',
-      'e',
-      'f',
-      'g',
-    ]);
+    expect(Scheduler).toFlushAndYield(
+      gate(flags =>
+        flags.new
+          ? ['a', 'b', 'c', 'd', 'e', 'f', 'g']
+          : [
+              'a',
+              'b',
+              'c',
+
+              // The old reconciler has a quirk where `d` has slightly lower
+              // priority than `g`, because it was scheduled in the middle of a
+              // render. This is an implementation detail, but I've left the
+              // test in this branch as-is since this was written so long ago.
+              // This first render does not include d.
+              'e',
+              'f',
+              'g',
+
+              // This second render does.
+              'd',
+              'e',
+              'f',
+              'g',
+            ],
+      ),
+    );
     expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
   });
 
@@ -244,22 +254,32 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    expect(Scheduler).toFlushAndYield([
-      'a',
-      'b',
-      'c',
-
-      // e, f, and g are in a separate batch from a, b, and c because they
-      // were scheduled in the middle of a render
-      'e',
-      'f',
-      'g',
-
-      'd',
-      'e',
-      'f',
-      'g',
-    ]);
+    expect(Scheduler).toFlushAndYield(
+      gate(flags =>
+        flags.new
+          ? ['a', 'b', 'c', 'd', 'e', 'f', 'g']
+          : [
+              'a',
+              'b',
+              'c',
+
+              // The old reconciler has a quirk where `d` has slightly lower
+              // priority than `g`, because it was scheduled in the middle of a
+              // render. This is an implementation detail, but I've left the
+              // test in this branch as-is since this was written so long ago.
+              // This first render does not include d.
+              'e',
+              'f',
+              'g',
+
+              // This second render does.
+              'd',
+              'e',
+              'f',
+              'g',
+            ],
+      ),
+    );
     expect(ReactNoop.getChildren()).toEqual([span('fg')]);
   });
 
@@ -348,7 +368,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(Scheduler).toHaveYielded(['componentWillReceiveProps', 'render']);
   });
 
-  it('enqueues setState inside an updater function as if the in-progress update is progressed (and warns)', () => {
+  it('updates triggered from inside a class setState updater', () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -372,12 +392,26 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     expect(() =>
-      expect(Scheduler).toFlushAndYield([
-        'setState updater',
-        // Update b is enqueued with the same priority as update a, so it should
-        // be flushed in the same commit.
-        'render',
-      ]),
+      expect(Scheduler).toFlushAndYield(
+        gate(flags =>
+          flags.new
+            ? [
+                'setState updater',
+                // In the new reconciler, updates inside the render phase are
+                // treated as if they came from an event, so the update gets
+                // shifted to a subsequent render.
+                'render',
+                'render',
+              ]
+            : [
+                'setState updater',
+                // In the old reconciler, updates in the render phase receive
+                // the currently rendering expiration time, so the update
+                // flushes immediately in the same render.
+                'render',
+              ],
+        ),
+      ),
     ).toErrorDev(
       'An update (setState, replaceState, or forceUpdate) was scheduled ' +
         'from inside an update function. Update functions should be pure, ' +
@@ -391,7 +425,19 @@ describe('ReactIncrementalUpdates', () => {
       this.setState({a: 'a'});
       return {b: 'b'};
     });
-    expect(Scheduler).toFlushAndYield(['render']);
+    expect(Scheduler).toFlushAndYield(
+      gate(flags =>
+        flags.new
+          ? // In the new reconciler, updates inside the render phase are
+            // treated as if they came from an event, so the update gets shifted
+            // to a subsequent render.
+            ['render', 'render']
+          : // In the old reconciler, updates in the render phase receive
+            // the currently rendering expiration time, so the update flushes
+            // immediately in the same render.
+            ['render'],
+      ),
+    );
   });
 
   it('getDerivedStateFromProps should update base state of updateQueue (based on product bug)', () => {

commit 47ebc90b08be7a2e6955dd3cfd468318e0b8fdfd
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 6 19:19:14 2020 -0700

    Put render phase update change behind a flag (#18850)
    
    In the new reconciler, I made a change to how render phase updates
    work. (By render phase updates, I mean when a component updates
    another component during its render phase. Or when a class component
    updates itself during the render phase. It does not include when
    a hook updates its own component during the render phase. Those have
    their own semantics. So really I mean anything triggers the "`setState`
    in render" warning.)
    
    The old behavior is to give the update the same "thread" (expiration
    time) as whatever is currently rendering. So if you call `setState` on a
    component that happens later in the same render, it will flush during
    that render. Ideally, we want to remove the special case and treat them
    as if they came from an interleaved event.
    
    Regardless, this pattern is not officially supported. This behavior is
    only a fallback. The flag only exists until we can roll out the
    `setState` warnning, since existing code might accidentally rely on the
    current behavior.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 90a327d734..055a2ee5c6 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -394,7 +394,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(() =>
       expect(Scheduler).toFlushAndYield(
         gate(flags =>
-          flags.new
+          flags.new && flags.deferRenderPhaseUpdateToNextBatch
             ? [
                 'setState updater',
                 // In the new reconciler, updates inside the render phase are
@@ -427,7 +427,7 @@ describe('ReactIncrementalUpdates', () => {
     });
     expect(Scheduler).toFlushAndYield(
       gate(flags =>
-        flags.new
+        flags.new && flags.deferRenderPhaseUpdateToNextBatch
           ? // In the new reconciler, updates inside the render phase are
             // treated as if they came from an event, so the update gets shifted
             // to a subsequent render.

commit 6edaf6f764f23043f0cd1c2da355b42f641afd8b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri May 8 12:47:51 2020 -0700

    Detect and prevent render starvation, per lane (#18864)
    
    * Detect and prevent render starvation, per lane
    
    If an update is CPU-bound for longer than expected according to its
    priority, we assume it's being starved by other work on the main thread.
    
    To detect this, we keep track of the elapsed time using a fixed-size
    array where each slot corresponds to a lane. What we actually store is
    the event time when the lane first became CPU-bound.
    
    Then, when receiving a new update or yielding to the main thread, we
    check how long each lane has been pending. If the time exceeds a
    threshold constant corresponding to its priority, we mark it as expired
    to force it to synchronously finish.
    
    We don't want to mistake time elapsed while an update is IO-bound
    (waiting for data to resolve) for time when it is CPU-bound. So when a
    lane suspends, we clear its associated event time from the array. When
    it receives a signal to try again, either a ping or an update, we assign
    a new event time to restart the clock.
    
    * Store as expiration time, not start time
    
    I originally stored the start time because I thought I could use this
    in the future to also measure Suspense timeouts. (Event times are
    currently stored on each update object for this purpose.) But that
    won't work because in the case of expiration times, we reset the clock
    whenever the update becomes IO-bound. So to replace the per-update
    field, I'm going to have to track those on the room separately from
    expiration times.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 055a2ee5c6..d852480f27 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -488,8 +488,8 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
-  // Note: This test doesn't really make sense in the new model, but we might
-  // want to port it once lanes are implemented.
+  // Note: This test doesn't really make sense in the new model. The
+  // corresponding concept is tested in ReactExpiration-test.
   // @gate old
   it('flushes all expired updates in a single batch', () => {
     const {useEffect} = React;

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index d852480f27..63f06e2de2 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -170,32 +170,7 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    expect(Scheduler).toFlushAndYield(
-      gate(flags =>
-        flags.new
-          ? ['a', 'b', 'c', 'd', 'e', 'f', 'g']
-          : [
-              'a',
-              'b',
-              'c',
-
-              // The old reconciler has a quirk where `d` has slightly lower
-              // priority than `g`, because it was scheduled in the middle of a
-              // render. This is an implementation detail, but I've left the
-              // test in this branch as-is since this was written so long ago.
-              // This first render does not include d.
-              'e',
-              'f',
-              'g',
-
-              // This second render does.
-              'd',
-              'e',
-              'f',
-              'g',
-            ],
-      ),
-    );
+    expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
     expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
   });
 
@@ -254,32 +229,7 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    expect(Scheduler).toFlushAndYield(
-      gate(flags =>
-        flags.new
-          ? ['a', 'b', 'c', 'd', 'e', 'f', 'g']
-          : [
-              'a',
-              'b',
-              'c',
-
-              // The old reconciler has a quirk where `d` has slightly lower
-              // priority than `g`, because it was scheduled in the middle of a
-              // render. This is an implementation detail, but I've left the
-              // test in this branch as-is since this was written so long ago.
-              // This first render does not include d.
-              'e',
-              'f',
-              'g',
-
-              // This second render does.
-              'd',
-              'e',
-              'f',
-              'g',
-            ],
-      ),
-    );
+    expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
     expect(ReactNoop.getChildren()).toEqual([span('fg')]);
   });
 
@@ -394,7 +344,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(() =>
       expect(Scheduler).toFlushAndYield(
         gate(flags =>
-          flags.new && flags.deferRenderPhaseUpdateToNextBatch
+          flags.deferRenderPhaseUpdateToNextBatch
             ? [
                 'setState updater',
                 // In the new reconciler, updates inside the render phase are
@@ -427,7 +377,7 @@ describe('ReactIncrementalUpdates', () => {
     });
     expect(Scheduler).toFlushAndYield(
       gate(flags =>
-        flags.new && flags.deferRenderPhaseUpdateToNextBatch
+        flags.deferRenderPhaseUpdateToNextBatch
           ? // In the new reconciler, updates inside the render phase are
             // treated as if they came from an event, so the update gets shifted
             // to a subsequent render.
@@ -488,323 +438,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
-  // Note: This test doesn't really make sense in the new model. The
-  // corresponding concept is tested in ReactExpiration-test.
-  // @gate old
-  it('flushes all expired updates in a single batch', () => {
-    const {useEffect} = React;
-
-    function App({label}) {
-      Scheduler.unstable_yieldValue('Render: ' + label);
-      useEffect(() => {
-        Scheduler.unstable_yieldValue('Commit: ' + label);
-      });
-      return label;
-    }
-
-    function interrupt() {
-      ReactNoop.flushSync(() => {
-        ReactNoop.renderToRootWithID(null, 'other-root');
-      });
-    }
-
-    // First, as a sanity check, assert what happens when four low pri
-    // updates in separate batches are all flushed in the same callback
-    ReactNoop.act(() => {
-      ReactNoop.render(<App label="" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="he" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="hell" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="hello" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      // Each update flushes in a separate commit.
-      // Note: This isn't necessarily the ideal behavior. It might be better to
-      // batch all of these updates together. The fact that they don't is an
-      // implementation detail. The important part of this unit test is what
-      // happens when they expire, in which case they really should be batched to
-      // avoid blocking the main thread for a long time.
-      expect(Scheduler).toFlushAndYield([
-        'Render: ',
-        'Commit: ',
-        'Render: he',
-        'Commit: he',
-        'Render: hell',
-        'Commit: hell',
-        'Render: hello',
-        'Commit: hello',
-      ]);
-    });
-
-    ReactNoop.act(() => {
-      // Now do the same thing over again, but this time, expire all the updates
-      // instead of flushing them normally.
-      ReactNoop.render(<App label="" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="go" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="good" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.render(<App label="goodbye" />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      // All the updates should render and commit in a single batch.
-      Scheduler.unstable_advanceTime(10000);
-      expect(Scheduler).toFlushExpired(['Render: goodbye']);
-      // Passive effect
-      expect(Scheduler).toFlushAndYield(['Commit: goodbye']);
-    });
-  });
-
-  // Note: This test doesn't really make sense in the new model, but we might
-  // want to port it once lanes are implemented.
-  // @gate old
-  it('flushes all expired updates in a single batch across multiple roots', () => {
-    // Same as previous test, but with two roots.
-    const {useEffect} = React;
-
-    function App({label}) {
-      Scheduler.unstable_yieldValue('Render: ' + label);
-      useEffect(() => {
-        Scheduler.unstable_yieldValue('Commit: ' + label);
-      });
-      return label;
-    }
-
-    function interrupt() {
-      ReactNoop.flushSync(() => {
-        ReactNoop.renderToRootWithID(null, 'other-root');
-      });
-    }
-    ReactNoop.act(() => {
-      // First, as a sanity check, assert what happens when four low pri
-      // updates in separate batches are all flushed in the same callback
-      ReactNoop.renderToRootWithID(<App label="" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="he" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="he" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="hell" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="hell" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="hello" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="hello" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      // Each update flushes in a separate commit.
-      // Note: This isn't necessarily the ideal behavior. It might be better to
-      // batch all of these updates together. The fact that they don't is an
-      // implementation detail. The important part of this unit test is what
-      // happens when they expire, in which case they really should be batched to
-      // avoid blocking the main thread for a long time.
-      expect(Scheduler).toFlushAndYield([
-        'Render: ',
-        'Commit: ',
-        'Render: ',
-        'Commit: ',
-        'Render: he',
-        'Commit: he',
-        'Render: he',
-        'Commit: he',
-        'Render: hell',
-        'Commit: hell',
-        'Render: hell',
-        'Commit: hell',
-        'Render: hello',
-        'Commit: hello',
-        'Render: hello',
-        'Commit: hello',
-      ]);
-    });
-
-    ReactNoop.act(() => {
-      // Now do the same thing over again, but this time, expire all the updates
-      // instead of flushing them normally.
-      ReactNoop.renderToRootWithID(<App label="" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="go" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="go" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="good" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="good" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      ReactNoop.renderToRootWithID(<App label="goodbye" />, 'a');
-      ReactNoop.renderToRootWithID(<App label="goodbye" />, 'b');
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['Render: ']);
-      interrupt();
-
-      // All the updates should render and commit in a single batch.
-      Scheduler.unstable_advanceTime(10000);
-      expect(Scheduler).toFlushExpired([
-        'Render: goodbye',
-        'Commit: goodbye',
-        'Render: goodbye',
-      ]);
-      // Passive effect
-      expect(Scheduler).toFlushAndYield(['Commit: goodbye']);
-    });
-  });
-
-  // Note: This test doesn't really make sense in the new model, but we might
-  // want to port it once lanes are implemented.
-  // @gate old
-  it('does not throw out partially completed tree if it expires midway through', () => {
-    function Text({text}) {
-      Scheduler.unstable_yieldValue(text);
-      return text;
-    }
-
-    function App({step}) {
-      return (
-        <>
-          <Text text={`A${step}`} />
-          <Text text={`B${step}`} />
-          <Text text={`C${step}`} />
-        </>
-      );
-    }
-
-    function interrupt() {
-      ReactNoop.flushSync(() => {
-        ReactNoop.renderToRootWithID(null, 'other-root');
-      });
-    }
-
-    // First, as a sanity check, assert what happens when four low pri
-    // updates in separate batches are all flushed in the same callback
-    ReactNoop.act(() => {
-      ReactNoop.render(<App step={1} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={2} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={3} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={4} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      // Each update flushes in a separate commit.
-      // Note: This isn't necessarily the ideal behavior. It might be better to
-      // batch all of these updates together. The fact that they don't is an
-      // implementation detail. The important part of this unit test is what
-      // happens when they expire, in which case they really should be batched to
-      // avoid blocking the main thread for a long time.
-      expect(Scheduler).toFlushAndYield([
-        // A1 already completed. Finish rendering the first level.
-        'B1',
-        'C1',
-        // The remaining two levels complete sequentially.
-        'A2',
-        'B2',
-        'C2',
-        'A3',
-        'B3',
-        'C3',
-        'A4',
-        'B4',
-        'C4',
-      ]);
-    });
-
-    ReactNoop.act(() => {
-      // Now do the same thing over again, but this time, expire all the updates
-      // instead of flushing them normally.
-      ReactNoop.render(<App step={1} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={2} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={3} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      interrupt();
-
-      ReactNoop.render(<App step={4} />);
-      Scheduler.unstable_advanceTime(1000);
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
-
-      // Expire all the updates
-      ReactNoop.expire(10000);
-
-      expect(Scheduler).toFlushExpired([
-        // A1 already completed. Finish rendering the first level.
-        'B1',
-        'C1',
-        // Then render the remaining two levels in a single batch
-        'A4',
-        'B4',
-        'C4',
-      ]);
-    });
-  });
-
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
     const {useState, useLayoutEffect} = React;
 

commit fa32cf299f514a0daa5ccd16fd8595b5cc6bc18b
Author: jddxf <740531372@qq.com>
Date:   Tue Jun 30 19:42:59 2020 +0800

    Add regression tests where sync render causes later concurrent render to expire soon (#18608)
    
    * Add a failing test for #17911
    
    * Add more test cases where sync render causes later concurrent render to expire soon

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 63f06e2de2..d86c57a0c4 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -438,6 +438,70 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
+  it('regression: does not expire soon due to layout effects in the last batch', () => {
+    const {useState, useLayoutEffect} = React;
+
+    let setCount;
+    function App() {
+      const [count, _setCount] = useState(0);
+      setCount = _setCount;
+      Scheduler.unstable_yieldValue('Render: ' + count);
+      useLayoutEffect(() => {
+        setCount(prevCount => prevCount + 1);
+        Scheduler.unstable_yieldValue('Commit: ' + count);
+      }, []);
+      return null;
+    }
+
+    ReactNoop.act(() => {
+      ReactNoop.render(<App />);
+      expect(Scheduler).toFlushExpired([]);
+      expect(Scheduler).toFlushAndYield([
+        'Render: 0',
+        'Commit: 0',
+        'Render: 1',
+      ]);
+
+      Scheduler.unstable_advanceTime(10000);
+
+      setCount(2);
+      expect(Scheduler).toFlushExpired([]);
+    });
+  });
+
+  it('regression: does not expire soon due to previous flushSync', () => {
+    function Text({text}) {
+      Scheduler.unstable_yieldValue(text);
+      return text;
+    }
+
+    ReactNoop.flushSync(() => {
+      ReactNoop.render(<Text text="A" />);
+    });
+    expect(Scheduler).toHaveYielded(['A']);
+
+    Scheduler.unstable_advanceTime(10000);
+
+    ReactNoop.render(<Text text="B" />);
+    expect(Scheduler).toFlushExpired([]);
+  });
+
+  it('regression: does not expire soon due to previous expired work', () => {
+    function Text({text}) {
+      Scheduler.unstable_yieldValue(text);
+      return text;
+    }
+
+    ReactNoop.render(<Text text="A" />);
+    Scheduler.unstable_advanceTime(10000);
+    expect(Scheduler).toFlushExpired(['A']);
+
+    Scheduler.unstable_advanceTime(10000);
+
+    ReactNoop.render(<Text text="B" />);
+    expect(Scheduler).toFlushExpired([]);
+  });
+
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
     const {useState, useLayoutEffect} = React;
 

commit 91a2e8173f1fadd2dfd4b12753ebcdc60986d42d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jul 6 18:53:42 2020 -0400

    Decouple update priority tracking from Scheduler package (#19121)
    
    * Initial currentLanePriority implementation
    
    * Minor updates from review
    
    * Fix typos and enable flag
    
    * Fix feature flags and lint
    
    * Fix simple event tests by switching to withSuspenseConfig
    
    * Don't lower the priority of setPending in startTransition below InputContinuous
    
    * Move currentUpdateLanePriority in commit root into the first effect block
    
    * Refactor requestUpdateLane to log for priority mismatches
    
    Also verifies that the update lane priority matches the scheduler lane priority before using it
    
    * Fix four tests by adding ReactDOM.unstable_runWithPriority
    
    * Fix partial hydration when using update lane priority
    
    * Fix partial hydration when using update lane priority
    
    * Rename feature flag and only log for now
    
    * Move unstable_runWithPriority to ReactFiberReconciler
    
    * Add unstable_runWithPriority to ReactNoopPersistent too
    
    * Bug fixes and performance improvements
    
    * Initial currentLanePriority implementation
    
    * Minor updates from review
    
    * Fix typos and enable flag
    
    * Remove higherLanePriority from ReactDOMEventReplaying.js
    
    * Change warning implementation and startTransition update lane priority
    
    * Inject reconciler functions to avoid importing src/
    
    * Fix feature flags and lint
    
    * Fix simple event tests by switching to withSuspenseConfig
    
    * Don't lower the priority of setPending in startTransition below InputContinuous
    
    * Move currentUpdateLanePriority in commit root into the first effect block
    
    * Refactor requestUpdateLane to log for priority mismatches
    
    Also verifies that the update lane priority matches the scheduler lane priority before using it
    
    * Fix four tests by adding ReactDOM.unstable_runWithPriority
    
    * Fix partial hydration when using update lane priority
    
    * Fix partial hydration when using update lane priority
    
    * Rename feature flag and only log for now
    
    * Move unstable_runWithPriority to ReactFiberReconciler
    
    * Bug fixes and performance improvements
    
    * Remove higherLanePriority from ReactDOMEventReplaying.js
    
    * Change warning implementation and startTransition update lane priority
    
    * Inject reconciler functions to avoid importing src/
    
    * Fixes from bad rebase

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index d86c57a0c4..ba363fb28b 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -516,11 +516,16 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + log);
         if (log === 'B') {
           // Right after B commits, schedule additional updates.
-          Scheduler.unstable_runWithPriority(
+          // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
+          ReactNoop.unstable_runWithPriority(
             Scheduler.unstable_UserBlockingPriority,
-            () => {
-              pushToLog('C');
-            },
+            () =>
+              Scheduler.unstable_runWithPriority(
+                Scheduler.unstable_UserBlockingPriority,
+                () => {
+                  pushToLog('C');
+                },
+              ),
           );
           setLog(prevLog => prevLog + 'D');
         }
@@ -538,11 +543,17 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       pushToLog('A');
-      Scheduler.unstable_runWithPriority(
+
+      // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
+      ReactNoop.unstable_runWithPriority(
         Scheduler.unstable_UserBlockingPriority,
-        () => {
-          pushToLog('B');
-        },
+        () =>
+          Scheduler.unstable_runWithPriority(
+            Scheduler.unstable_UserBlockingPriority,
+            () => {
+              pushToLog('B');
+            },
+          ),
       );
     });
     expect(Scheduler).toHaveYielded([
@@ -574,11 +585,16 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + this.state.log);
         if (this.state.log === 'B') {
           // Right after B commits, schedule additional updates.
-          Scheduler.unstable_runWithPriority(
+          // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
+          ReactNoop.unstable_runWithPriority(
             Scheduler.unstable_UserBlockingPriority,
-            () => {
-              this.pushToLog('C');
-            },
+            () =>
+              Scheduler.unstable_runWithPriority(
+                Scheduler.unstable_UserBlockingPriority,
+                () => {
+                  this.pushToLog('C');
+                },
+              ),
           );
           this.pushToLog('D');
         }
@@ -598,11 +614,16 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       pushToLog('A');
-      Scheduler.unstable_runWithPriority(
+      // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
+      ReactNoop.unstable_runWithPriority(
         Scheduler.unstable_UserBlockingPriority,
-        () => {
-          pushToLog('B');
-        },
+        () =>
+          Scheduler.unstable_runWithPriority(
+            Scheduler.unstable_UserBlockingPriority,
+            () => {
+              pushToLog('B');
+            },
+          ),
       );
     });
     expect(Scheduler).toHaveYielded([

commit faa697f4f9afe9f1c98e315b2a9e70f5a74a7a74
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Jul 17 12:58:44 2020 -0400

    Set current update lane priority for user blocking events (#19342)
    
    * Set current update lane priority for user blocking events
    
    * Update to use LanePriority and not use runWithPriority
    
    * Remove unused imports
    
    * Fix tests, and I missed ReactDOMEventListener
    
    * Fix more tests
    
    * Add try/finally and hardcode lane priorities instead
    
    * Also hard code InputContinuousLanePriority in tests
    
    * Remove un-needed exports
    
    * Comment rollbacks

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index ba363fb28b..6d057d8973 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -14,6 +14,11 @@ let React;
 let ReactNoop;
 let Scheduler;
 
+// Copied from ReactFiberLanes. Don't do this!
+// This is hard coded directly to avoid needing to import, and
+// we'll remove this as we replace runWithPriority with React APIs.
+const InputContinuousLanePriority = 12;
+
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
     jest.resetModuleRegistry();
@@ -517,15 +522,13 @@ describe('ReactIncrementalUpdates', () => {
         if (log === 'B') {
           // Right after B commits, schedule additional updates.
           // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
-          ReactNoop.unstable_runWithPriority(
-            Scheduler.unstable_UserBlockingPriority,
-            () =>
-              Scheduler.unstable_runWithPriority(
-                Scheduler.unstable_UserBlockingPriority,
-                () => {
-                  pushToLog('C');
-                },
-              ),
+          ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+            Scheduler.unstable_runWithPriority(
+              Scheduler.unstable_UserBlockingPriority,
+              () => {
+                pushToLog('C');
+              },
+            ),
           );
           setLog(prevLog => prevLog + 'D');
         }
@@ -545,15 +548,13 @@ describe('ReactIncrementalUpdates', () => {
       pushToLog('A');
 
       // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
-      ReactNoop.unstable_runWithPriority(
-        Scheduler.unstable_UserBlockingPriority,
-        () =>
-          Scheduler.unstable_runWithPriority(
-            Scheduler.unstable_UserBlockingPriority,
-            () => {
-              pushToLog('B');
-            },
-          ),
+      ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => {
+            pushToLog('B');
+          },
+        ),
       );
     });
     expect(Scheduler).toHaveYielded([
@@ -586,15 +587,13 @@ describe('ReactIncrementalUpdates', () => {
         if (this.state.log === 'B') {
           // Right after B commits, schedule additional updates.
           // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
-          ReactNoop.unstable_runWithPriority(
-            Scheduler.unstable_UserBlockingPriority,
-            () =>
-              Scheduler.unstable_runWithPriority(
-                Scheduler.unstable_UserBlockingPriority,
-                () => {
-                  this.pushToLog('C');
-                },
-              ),
+          ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+            Scheduler.unstable_runWithPriority(
+              Scheduler.unstable_UserBlockingPriority,
+              () => {
+                this.pushToLog('C');
+              },
+            ),
           );
           this.pushToLog('D');
         }
@@ -615,15 +614,13 @@ describe('ReactIncrementalUpdates', () => {
     await ReactNoop.act(async () => {
       pushToLog('A');
       // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
-      ReactNoop.unstable_runWithPriority(
-        Scheduler.unstable_UserBlockingPriority,
-        () =>
-          Scheduler.unstable_runWithPriority(
-            Scheduler.unstable_UserBlockingPriority,
-            () => {
-              pushToLog('B');
-            },
-          ),
+      ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => {
+            pushToLog('B');
+          },
+        ),
       );
     });
     expect(Scheduler).toHaveYielded([

commit 8da0da0937af154b775b243c9d28b6aa50db696b
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Aug 26 16:35:13 2020 -0500

    Disable timeoutMs argument (#19703)
    
    * Remove distinction between long, short transitions
    
    We're removing the `timeoutMs` option, so there's no longer any
    distinction between "short" and "long" transitions. They're all treated
    the same.
    
    This commit doesn't remove `timeoutMs` yet, only combines the internal
    priority levels.
    
    * Disable `timeoutMs` argument
    
    tl;dr
    -----
    
    - We're removing the `timeoutMs` argument from `useTransition`.
    - Transitions will either immediately switch to a skeleton/placeholder
      view (when loading new content) or wait indefinitely until the data
      resolves (when refreshing stale content).
    - This commit disables the `timeoutMS` so that the API has the desired
      semantics. It doesn't yet update the types or migrate all the test
      callers. I'll do those steps in follow-up PRs.
    
    Motivation
    ----------
    
    Currently, transitions initiated by `startTransition` / `useTransition`
    accept a `timeoutMs` option. You can use this to control the maximum
    amount of time that a transition is allowed to delay before we give up
    and show a placeholder.
    
    What we've discovered is that, in practice, every transition falls into
    one of two categories: a **load** or a **refresh**:
    
    - **Loading a new screen**: show the next screen as soon as possible,
      even if the data hasn't finished loading. Use a skeleton/placeholder
      UI to show progress.
    - **Refreshing a screen that's already visible**: keep showing the
      current screen indefinitely, for as long as it takes to load the fresh
      data, even if the current data is stale. Use a pending state (and
      maybe a busy indicator) to show progress.
    
    In other words, transitions should either *delay indefinitely* (for a
    refresh) or they should show a placeholder *instantly* (for a load).
    There's not much use for transitions that are delayed for a
    small-but-noticeable amount of time.
    
    So, the plan is to remove the `timeoutMs` option. Instead, we'll assign
    an effective timeout of `0` for loads, and `Infinity` for refreshes.
    
    The mechanism for distinguishing a load from a refresh already exists in
    the current model. If a component suspends, and the nearest Suspense
    boundary hasn't already mounted, we treat that as a load, because
    there's nothing on the screen. However, if the nearest boundary is
    mounted, we treat that as a refresh, since it's already showing content.
    
    If you need to fix a transition to be treated as a load instead of a
    refresh, or vice versa, the solution will involve rearranging the
    location of your Suspense boundaries. It may also involve adding a key.
    
    We're still working on proper documentation for these patterns. In the
    meantime, please reach out to us if you run into problems that you're
    unsure how to fix.
    
    We will remove `timeoutMs` from `useDeferredValue`, too, and apply the
    same load versus refresh semantics to the update that spawns the
    deferred value.
    
    Note that there are other types of delays that are not related to
    transitions; for example, we will still throttle the appearance of
    nested placeholders (we refer to this as the placeholder "train model"),
    and we may still apply a Just Noticeable Difference heuristic (JND) in
    some cases. These aren't going anywhere. (Well, the JND heuristic might
    but for different reasons than those discussed above.)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 6d057d8973..2dd1cd18e7 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -17,7 +17,7 @@ let Scheduler;
 // Copied from ReactFiberLanes. Don't do this!
 // This is hard coded directly to avoid needing to import, and
 // we'll remove this as we replace runWithPriority with React APIs.
-const InputContinuousLanePriority = 12;
+const InputContinuousLanePriority = 10;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {

commit 7cb9fd7ef822436aef13c8cbf648af1e21a5309a
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 1 18:05:42 2021 -0600

    Land interleaved updates change in main fork (#20710)
    
    * Land #20615 in main fork
    
    Includes change to interleaved updates.
    
    ```
    yarn replace-fork
    ```
    
    * Check deferRenderPhaseUpdateToNextBatch in test

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 2dd1cd18e7..e24e2576dd 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -320,7 +320,16 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     expect(instance.state).toEqual({a: 'a', b: 'b'});
-    expect(Scheduler).toHaveYielded(['componentWillReceiveProps', 'render']);
+
+    if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
+      expect(Scheduler).toHaveYielded([
+        'componentWillReceiveProps',
+        'render',
+        'render',
+      ]);
+    } else {
+      expect(Scheduler).toHaveYielded(['componentWillReceiveProps', 'render']);
+    }
   });
 
   it('updates triggered from inside a class setState updater', () => {

commit 60182d64ca030ef28782c7e67be373eac81ae4c2
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Mar 10 12:44:25 2021 -0500

    Cleanup tests using runWithPriority. (#20958)
    
    * Remove Scheduler.runWithPriority from some tests
    
    * Mark experimental test experimental

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index e24e2576dd..95acb7d8fc 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -530,14 +530,8 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + log);
         if (log === 'B') {
           // Right after B commits, schedule additional updates.
-          // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
           ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
-            Scheduler.unstable_runWithPriority(
-              Scheduler.unstable_UserBlockingPriority,
-              () => {
-                pushToLog('C');
-              },
-            ),
+            pushToLog('C'),
           );
           setLog(prevLog => prevLog + 'D');
         }
@@ -556,14 +550,8 @@ describe('ReactIncrementalUpdates', () => {
     await ReactNoop.act(async () => {
       pushToLog('A');
 
-      // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
       ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => {
-            pushToLog('B');
-          },
-        ),
+        pushToLog('B'),
       );
     });
     expect(Scheduler).toHaveYielded([
@@ -595,14 +583,8 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + this.state.log);
         if (this.state.log === 'B') {
           // Right after B commits, schedule additional updates.
-          // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
           ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
-            Scheduler.unstable_runWithPriority(
-              Scheduler.unstable_UserBlockingPriority,
-              () => {
-                this.pushToLog('C');
-              },
-            ),
+            this.pushToLog('C'),
           );
           this.pushToLog('D');
         }
@@ -622,14 +604,8 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       pushToLog('A');
-      // TODO: Double wrapping is temporary while we remove Scheduler runWithPriority.
       ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => {
-            pushToLog('B');
-          },
-        ),
+        pushToLog('B'),
       );
     });
     expect(Scheduler).toHaveYielded([

commit be5a2e231ae27b2c64806c026a5b9921be5e7560
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 19 17:28:41 2021 -0500

    Land enableSyncMicrotasks (#20979)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 95acb7d8fc..ec587d7231 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -32,6 +32,15 @@ describe('ReactIncrementalUpdates', () => {
     return {type: 'span', children: [], prop, hidden: false};
   }
 
+  function flushNextRenderIfExpired() {
+    // This will start rendering the next level of work. If the work hasn't
+    // expired yet, React will exit without doing anything. If it has expired,
+    // it will schedule a sync task.
+    Scheduler.unstable_flushExpired();
+    // Flush the sync task.
+    ReactNoop.flushSync();
+  }
+
   it('applies updates in order of priority', () => {
     let state;
     class Foo extends React.Component {
@@ -469,7 +478,8 @@ describe('ReactIncrementalUpdates', () => {
 
     ReactNoop.act(() => {
       ReactNoop.render(<App />);
-      expect(Scheduler).toFlushExpired([]);
+      flushNextRenderIfExpired();
+      expect(Scheduler).toHaveYielded([]);
       expect(Scheduler).toFlushAndYield([
         'Render: 0',
         'Commit: 0',
@@ -479,7 +489,8 @@ describe('ReactIncrementalUpdates', () => {
       Scheduler.unstable_advanceTime(10000);
 
       setCount(2);
-      expect(Scheduler).toFlushExpired([]);
+      flushNextRenderIfExpired();
+      expect(Scheduler).toHaveYielded([]);
     });
   });
 
@@ -497,7 +508,8 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     ReactNoop.render(<Text text="B" />);
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
   });
 
   it('regression: does not expire soon due to previous expired work', () => {
@@ -508,12 +520,14 @@ describe('ReactIncrementalUpdates', () => {
 
     ReactNoop.render(<Text text="A" />);
     Scheduler.unstable_advanceTime(10000);
-    expect(Scheduler).toFlushExpired(['A']);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded(['A']);
 
     Scheduler.unstable_advanceTime(10000);
 
     ReactNoop.render(<Text text="B" />);
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
   });
 
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {

commit 03ede83d2ea1878e5cb82c3c17844621989caf66
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 25 11:21:41 2021 -0500

    Use EventPriority to track update priority (#21082)
    
    Instead of LanePriority. Internally, EventPriority is just a lane, so
    this skips an extra conversion. Since EventPriority is a "public" (to
    the host config) type, I was also able to remove some deep imports
    of the Lane module.
    
    This gets us most of the way to deleting the LanePriority entirely.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index ec587d7231..98092cf33f 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -13,11 +13,7 @@
 let React;
 let ReactNoop;
 let Scheduler;
-
-// Copied from ReactFiberLanes. Don't do this!
-// This is hard coded directly to avoid needing to import, and
-// we'll remove this as we replace runWithPriority with React APIs.
-const InputContinuousLanePriority = 10;
+let ContinuousEventPriority;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
@@ -26,6 +22,8 @@ describe('ReactIncrementalUpdates', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+    ContinuousEventPriority = require('react-reconciler/constants')
+      .ContinuousEventPriority;
   });
 
   function span(prop) {
@@ -544,7 +542,7 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + log);
         if (log === 'B') {
           // Right after B commits, schedule additional updates.
-          ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+          ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
             pushToLog('C'),
           );
           setLog(prevLog => prevLog + 'D');
@@ -564,7 +562,7 @@ describe('ReactIncrementalUpdates', () => {
     await ReactNoop.act(async () => {
       pushToLog('A');
 
-      ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+      ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );
     });
@@ -597,7 +595,7 @@ describe('ReactIncrementalUpdates', () => {
         Scheduler.unstable_yieldValue('Committed: ' + this.state.log);
         if (this.state.log === 'B') {
           // Right after B commits, schedule additional updates.
-          ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+          ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
             this.pushToLog('C'),
           );
           this.pushToLog('D');
@@ -618,7 +616,7 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       pushToLog('A');
-      ReactNoop.unstable_runWithPriority(InputContinuousLanePriority, () =>
+      ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );
     });

commit 933880b4544a83ce54c8a47f348effe725a58843
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Apr 9 19:50:09 2021 -0400

    Make time-slicing opt-in (#21072)
    
    * Add enableSyncDefaultUpdates feature flag
    
    * Add enableSyncDefaultUpdates implementation
    
    * Fix tests
    
    * Switch feature flag to true by default
    
    * Finish concurrent render whenever for non-sync lanes
    
    * Also return DefaultLane with eventLane
    
    * Gate interruption test
    
    * Add continuout native event test
    
    * Fix tests from rebasing main
    
    * Hardcode lanes, remove added export
    
    * Sync forks

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 98092cf33f..9eaa95f93e 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -61,9 +61,16 @@ describe('ReactIncrementalUpdates', () => {
 
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushAndYieldThrough(['commit']);
-    expect(state).toEqual({a: 'a'});
-    expect(Scheduler).toFlushWithoutYielding();
-    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      // TODO: should deferredUpdates flush sync with the default update?
+      expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+      expect(Scheduler).toFlushWithoutYielding();
+    } else {
+      expect(state).toEqual({a: 'a'});
+      expect(Scheduler).toFlushWithoutYielding();
+      expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
+    }
   });
 
   it('applies updates with equal priority in insertion order', () => {
@@ -130,6 +137,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(instance.state).toEqual({c: 'c', d: 'd'});
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('can abort an update, schedule additional updates, and resume', () => {
     let instance;
     class Foo extends React.Component {
@@ -159,33 +167,75 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    instance.setState(createUpdate('a'));
-    instance.setState(createUpdate('b'));
-    instance.setState(createUpdate('c'));
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        instance.setState(createUpdate('a'));
+        instance.setState(createUpdate('b'));
+        instance.setState(createUpdate('c'));
+      });
+    } else {
+      instance.setState(createUpdate('a'));
+      instance.setState(createUpdate('b'));
+      instance.setState(createUpdate('c'));
+    }
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
     expect(ReactNoop.getChildren()).toEqual([span('')]);
 
     // Schedule some more updates at different priorities
-    instance.setState(createUpdate('d'));
-    ReactNoop.flushSync(() => {
-      instance.setState(createUpdate('e'));
-      instance.setState(createUpdate('f'));
-    });
-    instance.setState(createUpdate('g'));
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      instance.setState(createUpdate('d'));
+      ReactNoop.flushSync(() => {
+        instance.setState(createUpdate('e'));
+        instance.setState(createUpdate('f'));
+      });
+      React.unstable_startTransition(() => {
+        instance.setState(createUpdate('g'));
+      });
 
-    // The sync updates should have flushed, but not the async ones
-    expect(Scheduler).toHaveYielded(['e', 'f']);
-    expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+      // The sync updates should have flushed, but not the async ones
+      expect(Scheduler).toHaveYielded(['e', 'f']);
+      expect(ReactNoop.getChildren()).toEqual([span('ef')]);
 
-    // Now flush the remaining work. Even though e and f were already processed,
-    // they should be processed again, to ensure that the terminal state
-    // is deterministic.
-    expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+      // Now flush the remaining work. Even though e and f were already processed,
+      // they should be processed again, to ensure that the terminal state
+      // is deterministic.
+      // TODO: should d, e, f be flushed again first?
+      expect(Scheduler).toFlushAndYield([
+        'd',
+        'e',
+        'f',
+        'a',
+        'b',
+        'c',
+        'd',
+        'e',
+        'f',
+        'g',
+      ]);
+      expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+    } else {
+      instance.setState(createUpdate('d'));
+      ReactNoop.flushSync(() => {
+        instance.setState(createUpdate('e'));
+        instance.setState(createUpdate('f'));
+      });
+      instance.setState(createUpdate('g'));
+
+      // The sync updates should have flushed, but not the async ones
+      expect(Scheduler).toHaveYielded(['e', 'f']);
+      expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+
+      // Now flush the remaining work. Even though e and f were already processed,
+      // they should be processed again, to ensure that the terminal state
+      // is deterministic.
+      expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
+      expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+    }
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('can abort an update, schedule a replaceState, and resume', () => {
     let instance;
     class Foo extends React.Component {
@@ -215,34 +265,79 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    instance.setState(createUpdate('a'));
-    instance.setState(createUpdate('b'));
-    instance.setState(createUpdate('c'));
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        instance.setState(createUpdate('a'));
+        instance.setState(createUpdate('b'));
+        instance.setState(createUpdate('c'));
+      });
+    } else {
+      instance.setState(createUpdate('a'));
+      instance.setState(createUpdate('b'));
+      instance.setState(createUpdate('c'));
+    }
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
     expect(ReactNoop.getChildren()).toEqual([span('')]);
 
-    // Schedule some more updates at different priorities{
-    instance.setState(createUpdate('d'));
-    ReactNoop.flushSync(() => {
-      instance.setState(createUpdate('e'));
-      // No longer a public API, but we can test that it works internally by
-      // reaching into the updater.
-      instance.updater.enqueueReplaceState(instance, createUpdate('f'));
-    });
-    instance.setState(createUpdate('g'));
-
-    // The sync updates should have flushed, but not the async ones. Update d
-    // was dropped and replaced by e.
-    expect(Scheduler).toHaveYielded(['e', 'f']);
-    expect(ReactNoop.getChildren()).toEqual([span('f')]);
-
-    // Now flush the remaining work. Even though e and f were already processed,
-    // they should be processed again, to ensure that the terminal state
-    // is deterministic.
-    expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+    // Schedule some more updates at different priorities
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      instance.setState(createUpdate('d'));
+
+      ReactNoop.flushSync(() => {
+        instance.setState(createUpdate('e'));
+        // No longer a public API, but we can test that it works internally by
+        // reaching into the updater.
+        instance.updater.enqueueReplaceState(instance, createUpdate('f'));
+      });
+      React.unstable_startTransition(() => {
+        instance.setState(createUpdate('g'));
+      });
+
+      // The sync updates should have flushed, but not the async ones.
+      // TODO: should 'd' have flushed?
+      // TODO: should 'f' have flushed? I don't know what enqueueReplaceState is.
+      expect(Scheduler).toHaveYielded(['e', 'f']);
+      expect(ReactNoop.getChildren()).toEqual([span('f')]);
+
+      // Now flush the remaining work. Even though e and f were already processed,
+      // they should be processed again, to ensure that the terminal state
+      // is deterministic.
+      expect(Scheduler).toFlushAndYield([
+        'd',
+        'e',
+        'f',
+        'a',
+        'b',
+        'c',
+        'd',
+        'e',
+        'f',
+        'g',
+      ]);
+      expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+    } else {
+      instance.setState(createUpdate('d'));
+      ReactNoop.flushSync(() => {
+        instance.setState(createUpdate('e'));
+        // No longer a public API, but we can test that it works internally by
+        // reaching into the updater.
+        instance.updater.enqueueReplaceState(instance, createUpdate('f'));
+      });
+      instance.setState(createUpdate('g'));
+
+      // The sync updates should have flushed, but not the async ones. Update d
+      // was dropped and replaced by e.
+      expect(Scheduler).toHaveYielded(['e', 'f']);
+      expect(ReactNoop.getChildren()).toEqual([span('f')]);
+
+      // Now flush the remaining work. Even though e and f were already processed,
+      // they should be processed again, to ensure that the terminal state
+      // is deterministic.
+      expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
+      expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+    }
   });
 
   it('passes accumulation of previous updates to replaceState updater function', () => {
@@ -459,6 +554,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to layout effects in the last batch', () => {
     const {useState, useLayoutEffect} = React;
 
@@ -475,7 +571,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.act(() => {
-      ReactNoop.render(<App />);
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          ReactNoop.render(<App />);
+        });
+      } else {
+        ReactNoop.render(<App />);
+      }
       flushNextRenderIfExpired();
       expect(Scheduler).toHaveYielded([]);
       expect(Scheduler).toFlushAndYield([
@@ -485,13 +587,19 @@ describe('ReactIncrementalUpdates', () => {
       ]);
 
       Scheduler.unstable_advanceTime(10000);
-
-      setCount(2);
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          setCount(2);
+        });
+      } else {
+        setCount(2);
+      }
       flushNextRenderIfExpired();
       expect(Scheduler).toHaveYielded([]);
     });
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to previous flushSync', () => {
     function Text({text}) {
       Scheduler.unstable_yieldValue(text);
@@ -505,29 +613,49 @@ describe('ReactIncrementalUpdates', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    ReactNoop.render(<Text text="B" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Text text="B" />);
+      });
+    } else {
+      ReactNoop.render(<Text text="B" />);
+    }
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to previous expired work', () => {
     function Text({text}) {
       Scheduler.unstable_yieldValue(text);
       return text;
     }
 
-    ReactNoop.render(<Text text="A" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Text text="A" />);
+      });
+    } else {
+      ReactNoop.render(<Text text="A" />);
+    }
     Scheduler.unstable_advanceTime(10000);
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded(['A']);
 
     Scheduler.unstable_advanceTime(10000);
 
-    ReactNoop.render(<Text text="B" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<Text text="B" />);
+      });
+    } else {
+      ReactNoop.render(<Text text="B" />);
+    }
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
     const {useState, useLayoutEffect} = React;
 
@@ -560,7 +688,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput('');
 
     await ReactNoop.act(async () => {
-      pushToLog('A');
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          pushToLog('A');
+        });
+      } else {
+        pushToLog('A');
+      }
 
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
@@ -584,6 +718,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput('ABCD');
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('when rebasing, does not exclude updates that were already committed, regardless of priority (classes)', async () => {
     let pushToLog;
     class App extends React.Component {
@@ -615,7 +750,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput('');
 
     await ReactNoop.act(async () => {
-      pushToLog('A');
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          pushToLog('A');
+        });
+      } else {
+        pushToLog('A');
+      }
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );

commit ef37d55b68ddc45d465b84ea2ce30e8328297b2d
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 21 10:29:31 2021 -0500

    Use performConcurrentWorkOnRoot for "sync default" (#21322)
    
    Instead of `performSyncWorkOnRoot`.
    
    The conceptual model is that the only difference between sync default
    updates (in React 18) and concurrent default updates (in a future major
    release) is time slicing. All other behavior should be the same
    (i.e. the stuff in `finishConcurrentRender`).
    
    Given this, I think it makes more sense to model the implementation this
    way, too. This exposed a quirk in the previous implementation where
    non-sync work was sometimes mistaken for sync work and flushed too
    early. In the new implementation, `performSyncWorkOnRoot` is only used
    for truly synchronous renders (i.e. `SyncLane`), which should make these
    mistakes less common.
    
    Fixes most of the tests marked with TODOs from #21072.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 9eaa95f93e..991937ee37 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -62,15 +62,9 @@ describe('ReactIncrementalUpdates', () => {
     ReactNoop.render(<Foo />);
     expect(Scheduler).toFlushAndYieldThrough(['commit']);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      // TODO: should deferredUpdates flush sync with the default update?
-      expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
-      expect(Scheduler).toFlushWithoutYielding();
-    } else {
-      expect(state).toEqual({a: 'a'});
-      expect(Scheduler).toFlushWithoutYielding();
-      expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
-    }
+    expect(state).toEqual({a: 'a'});
+    expect(Scheduler).toFlushWithoutYielding();
+    expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
   });
 
   it('applies updates with equal priority in insertion order', () => {

commit 15fb8c3045064e13e81706a36bf0e4e419803c97
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon May 3 16:57:03 2021 -0400

    createRoot API is no longer strict by default (#21417)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 991937ee37..a3fcf9dc70 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -402,12 +402,7 @@ describe('ReactIncrementalUpdates', () => {
       }
     }
     ReactNoop.render(<Foo />);
-    expect(() =>
-      expect(Scheduler).toFlushAndYield(['render']),
-    ).toErrorDev(
-      'Using UNSAFE_componentWillReceiveProps in strict mode is not recommended',
-      {withoutStack: true},
-    );
+    expect(Scheduler).toFlushAndYield(['render']);
 
     ReactNoop.flushSync(() => {
       instance.setState({a: 'a'});

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index a3fcf9dc70..cd560ae91c 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -131,7 +131,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(instance.state).toEqual({c: 'c', d: 'd'});
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('can abort an update, schedule additional updates, and resume', () => {
     let instance;
     class Foo extends React.Component {
@@ -162,7 +161,7 @@ describe('ReactIncrementalUpdates', () => {
 
     // Schedule some async updates
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         instance.setState(createUpdate('a'));
         instance.setState(createUpdate('b'));
         instance.setState(createUpdate('c'));
@@ -184,7 +183,7 @@ describe('ReactIncrementalUpdates', () => {
         instance.setState(createUpdate('e'));
         instance.setState(createUpdate('f'));
       });
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         instance.setState(createUpdate('g'));
       });
 
@@ -229,7 +228,6 @@ describe('ReactIncrementalUpdates', () => {
     }
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('can abort an update, schedule a replaceState, and resume', () => {
     let instance;
     class Foo extends React.Component {
@@ -260,7 +258,7 @@ describe('ReactIncrementalUpdates', () => {
 
     // Schedule some async updates
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         instance.setState(createUpdate('a'));
         instance.setState(createUpdate('b'));
         instance.setState(createUpdate('c'));
@@ -285,7 +283,7 @@ describe('ReactIncrementalUpdates', () => {
         // reaching into the updater.
         instance.updater.enqueueReplaceState(instance, createUpdate('f'));
       });
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         instance.setState(createUpdate('g'));
       });
 
@@ -543,7 +541,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to layout effects in the last batch', () => {
     const {useState, useLayoutEffect} = React;
 
@@ -561,7 +558,7 @@ describe('ReactIncrementalUpdates', () => {
 
     ReactNoop.act(() => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           ReactNoop.render(<App />);
         });
       } else {
@@ -577,7 +574,7 @@ describe('ReactIncrementalUpdates', () => {
 
       Scheduler.unstable_advanceTime(10000);
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           setCount(2);
         });
       } else {
@@ -588,7 +585,6 @@ describe('ReactIncrementalUpdates', () => {
     });
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to previous flushSync', () => {
     function Text({text}) {
       Scheduler.unstable_yieldValue(text);
@@ -603,7 +599,7 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Text text="B" />);
       });
     } else {
@@ -613,7 +609,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(Scheduler).toHaveYielded([]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('regression: does not expire soon due to previous expired work', () => {
     function Text({text}) {
       Scheduler.unstable_yieldValue(text);
@@ -621,7 +616,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Text text="A" />);
       });
     } else {
@@ -634,7 +629,7 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<Text text="B" />);
       });
     } else {
@@ -644,7 +639,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(Scheduler).toHaveYielded([]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
     const {useState, useLayoutEffect} = React;
 
@@ -678,7 +672,7 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           pushToLog('A');
         });
       } else {
@@ -707,7 +701,6 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput('ABCD');
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('when rebasing, does not exclude updates that were already committed, regardless of priority (classes)', async () => {
     let pushToLog;
     class App extends React.Component {
@@ -740,7 +733,7 @@ describe('ReactIncrementalUpdates', () => {
 
     await ReactNoop.act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           pushToLog('A');
         });
       } else {

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index cd560ae91c..200d645301 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -14,6 +14,7 @@ let React;
 let ReactNoop;
 let Scheduler;
 let ContinuousEventPriority;
+let act;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
@@ -22,6 +23,7 @@ describe('ReactIncrementalUpdates', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+    act = require('jest-react').act;
     ContinuousEventPriority = require('react-reconciler/constants')
       .ContinuousEventPriority;
   });
@@ -556,7 +558,7 @@ describe('ReactIncrementalUpdates', () => {
       return null;
     }
 
-    ReactNoop.act(() => {
+    act(() => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           ReactNoop.render(<App />);
@@ -664,13 +666,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['Committed: ']);
     expect(root).toMatchRenderedOutput('');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           pushToLog('A');
@@ -725,13 +727,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded([]);
     expect(root).toMatchRenderedOutput('');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           pushToLog('A');
@@ -788,20 +790,20 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App prop="A" />);
     });
     expect(root).toMatchRenderedOutput('0');
 
     // Changing the prop causes the count to increase by 100
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App prop="B" />);
     });
     expect(root).toMatchRenderedOutput('100');
 
     // Now increment the count by 1 with a state update. And, in the same
     // batch, change the prop back to its original value.
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App prop="A" />);
       app.setState(state => ({count: state.count + 1}));
     });

commit 5579f1dc875c328e8155906aabe20902fc14c04a
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jul 19 15:07:38 2021 -0400

    Update test comments with explanations (#21857)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 200d645301..b507076e9e 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -196,11 +196,13 @@ describe('ReactIncrementalUpdates', () => {
       // Now flush the remaining work. Even though e and f were already processed,
       // they should be processed again, to ensure that the terminal state
       // is deterministic.
-      // TODO: should d, e, f be flushed again first?
       expect(Scheduler).toFlushAndYield([
+        // Since 'g' is in a transition, we'll process 'd' separately first.
+        // That causes us to process 'd' with 'e' and 'f' rebased.
         'd',
         'e',
         'f',
+        // Then we'll re-process everything for 'g'.
         'a',
         'b',
         'c',
@@ -290,8 +292,6 @@ describe('ReactIncrementalUpdates', () => {
       });
 
       // The sync updates should have flushed, but not the async ones.
-      // TODO: should 'd' have flushed?
-      // TODO: should 'f' have flushed? I don't know what enqueueReplaceState is.
       expect(Scheduler).toHaveYielded(['e', 'f']);
       expect(ReactNoop.getChildren()).toEqual([span('f')]);
 
@@ -299,9 +299,12 @@ describe('ReactIncrementalUpdates', () => {
       // they should be processed again, to ensure that the terminal state
       // is deterministic.
       expect(Scheduler).toFlushAndYield([
+        // Since 'g' is in a transition, we'll process 'd' separately first.
+        // That causes us to process 'd' with 'e' and 'f' rebased.
         'd',
         'e',
         'f',
+        // Then we'll re-process everything for 'g'.
         'a',
         'b',
         'c',

commit c1220ebdde506de91c8b9693b5cb67ac710c8c89
Author: salazarm <salazarm@users.noreply.github.com>
Date:   Tue Nov 23 18:40:10 2021 -0500

    treat empty string as null (#22807)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index b507076e9e..ccbed48fae 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -673,7 +673,7 @@ describe('ReactIncrementalUpdates', () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['Committed: ']);
-    expect(root).toMatchRenderedOutput('');
+    expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
@@ -734,7 +734,7 @@ describe('ReactIncrementalUpdates', () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded([]);
-    expect(root).toMatchRenderedOutput('');
+    expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index ccbed48fae..454a0399b9 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 500c8aa0828b1c1f73e957b99bbe0e0f9b08aac5
Author: Samuel Susla <samuel.susla@gmail.com>
Date:   Fri Dec 2 17:14:12 2022 +0000

    Add component name to StrictMode error message (#25718)
    
    The error message to warn user about state update coming from inside an
    update function does not contain name of the offending component. Other
    warnings StrictMode has, always have offending component mentioned in
    top level error message.
    
    
    Previous error message:
    ```
    An update (setState, replaceState, or forceUpdate) was scheduled
    from inside an update function. Update functions should be pure
    with zero side-effects. Consider using componentDidUpdate or a
    callback.
    ```
    
    New error message:
    ```
    An update (setState, replaceState, or forceUpdate) was scheduled
    from inside an update function. Update functions should be pure
    with zero side-effects. Consider using componentDidUpdate or a
    callback.
    
    Please update the following component: Foo
    ```

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 454a0399b9..4d667b0ab6 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -474,7 +474,7 @@ describe('ReactIncrementalUpdates', () => {
       'An update (setState, replaceState, or forceUpdate) was scheduled ' +
         'from inside an update function. Update functions should be pure, ' +
         'with zero side-effects. Consider using componentDidUpdate or a ' +
-        'callback.',
+        'callback.\n\nPlease update the following component: Foo',
     );
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 

commit 5379b6123f171bb48cc8a9c435c11ccb9f8ff0e7
Author: Tianyu Yao <skyyao@fb.com>
Date:   Thu Jan 5 15:21:35 2023 -0800

    Batch sync, default and continuous lanes (#25700)
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn debug-test --watch TestName`, open
    `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    This is the other approach for unifying default and sync lane
    https://github.com/facebook/react/pull/25524.
    The approach in that PR is to merge default and continuous lane into the
    sync lane, and use a new field to track the priority. But there are a
    couple places that field will be needed, and it is difficult to
    correctly reset the field when there is no sync lane.
    
    In this PR we take the other approach that doesn't remove any lane, but
    batch them to get the behavior we want.
    
    
    ## How did you test this change?
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    yarn test
    
    Co-authored-by: Andrew Clark <hi@andrewclark.io>

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 4d667b0ab6..b56fdc8536 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -47,7 +47,7 @@ describe('ReactIncrementalUpdates', () => {
       state = {};
       componentDidMount() {
         Scheduler.unstable_yieldValue('commit');
-        ReactNoop.deferredUpdates(() => {
+        React.startTransition(() => {
           // Has low priority
           this.setState({b: 'b'});
           this.setState({c: 'c'});
@@ -111,13 +111,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(Scheduler).toFlushAndYield(['render', 'componentDidMount']);
 
     ReactNoop.flushSync(() => {
-      ReactNoop.deferredUpdates(() => {
+      React.startTransition(() => {
         instance.setState({x: 'x'});
         instance.setState({y: 'y'});
       });
       instance.setState({a: 'a'});
       instance.setState({b: 'b'});
-      ReactNoop.deferredUpdates(() => {
+      React.startTransition(() => {
         instance.updater.enqueueReplaceState(instance, {c: 'c'});
         instance.setState({d: 'd'});
       });
@@ -162,7 +162,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+      )
+    ) {
       React.startTransition(() => {
         instance.setState(createUpdate('a'));
         instance.setState(createUpdate('b'));
@@ -179,23 +183,37 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('')]);
 
     // Schedule some more updates at different priorities
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      instance.setState(createUpdate('d'));
-      ReactNoop.flushSync(() => {
-        instance.setState(createUpdate('e'));
-        instance.setState(createUpdate('f'));
-      });
-      React.startTransition(() => {
-        instance.setState(createUpdate('g'));
-      });
+    instance.setState(createUpdate('d'));
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      instance.setState(createUpdate('f'));
+    });
+    React.startTransition(() => {
+      instance.setState(createUpdate('g'));
+    });
 
-      // The sync updates should have flushed, but not the async ones
+    // The sync updates should have flushed, but not the async ones.
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+      )
+    ) {
+      expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
+      expect(ReactNoop.getChildren()).toEqual([span('def')]);
+    } else {
+      // Update d was dropped and replaced by e.
       expect(Scheduler).toHaveYielded(['e', 'f']);
       expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+    }
 
-      // Now flush the remaining work. Even though e and f were already processed,
-      // they should be processed again, to ensure that the terminal state
-      // is deterministic.
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+      )
+    ) {
       expect(Scheduler).toFlushAndYield([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -211,25 +229,19 @@ describe('ReactIncrementalUpdates', () => {
         'f',
         'g',
       ]);
-      expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
     } else {
-      instance.setState(createUpdate('d'));
-      ReactNoop.flushSync(() => {
-        instance.setState(createUpdate('e'));
-        instance.setState(createUpdate('f'));
-      });
-      instance.setState(createUpdate('g'));
-
-      // The sync updates should have flushed, but not the async ones
-      expect(Scheduler).toHaveYielded(['e', 'f']);
-      expect(ReactNoop.getChildren()).toEqual([span('ef')]);
-
-      // Now flush the remaining work. Even though e and f were already processed,
-      // they should be processed again, to ensure that the terminal state
-      // is deterministic.
-      expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-      expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+      expect(Scheduler).toFlushAndYield([
+        // Then we'll re-process everything for 'g'.
+        'a',
+        'b',
+        'c',
+        'd',
+        'e',
+        'f',
+        'g',
+      ]);
     }
+    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
   });
 
   it('can abort an update, schedule a replaceState, and resume', () => {
@@ -261,7 +273,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+      )
+    ) {
       React.startTransition(() => {
         instance.setState(createUpdate('a'));
         instance.setState(createUpdate('b'));
@@ -278,26 +294,39 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop.getChildren()).toEqual([span('')]);
 
     // Schedule some more updates at different priorities
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      instance.setState(createUpdate('d'));
+    instance.setState(createUpdate('d'));
 
-      ReactNoop.flushSync(() => {
-        instance.setState(createUpdate('e'));
-        // No longer a public API, but we can test that it works internally by
-        // reaching into the updater.
-        instance.updater.enqueueReplaceState(instance, createUpdate('f'));
-      });
-      React.startTransition(() => {
-        instance.setState(createUpdate('g'));
-      });
+    ReactNoop.flushSync(() => {
+      instance.setState(createUpdate('e'));
+      // No longer a public API, but we can test that it works internally by
+      // reaching into the updater.
+      instance.updater.enqueueReplaceState(instance, createUpdate('f'));
+    });
+    React.startTransition(() => {
+      instance.setState(createUpdate('g'));
+    });
 
-      // The sync updates should have flushed, but not the async ones.
+    // The sync updates should have flushed, but not the async ones.
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+      )
+    ) {
+      expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
+    } else {
+      // Update d was dropped and replaced by e.
       expect(Scheduler).toHaveYielded(['e', 'f']);
-      expect(ReactNoop.getChildren()).toEqual([span('f')]);
-
-      // Now flush the remaining work. Even though e and f were already processed,
-      // they should be processed again, to ensure that the terminal state
-      // is deterministic.
+    }
+    expect(ReactNoop.getChildren()).toEqual([span('f')]);
+
+    // Now flush the remaining work. Even though e and f were already processed,
+    // they should be processed again, to ensure that the terminal state
+    // is deterministic.
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+      )
+    ) {
       expect(Scheduler).toFlushAndYield([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -313,28 +342,19 @@ describe('ReactIncrementalUpdates', () => {
         'f',
         'g',
       ]);
-      expect(ReactNoop.getChildren()).toEqual([span('fg')]);
     } else {
-      instance.setState(createUpdate('d'));
-      ReactNoop.flushSync(() => {
-        instance.setState(createUpdate('e'));
-        // No longer a public API, but we can test that it works internally by
-        // reaching into the updater.
-        instance.updater.enqueueReplaceState(instance, createUpdate('f'));
-      });
-      instance.setState(createUpdate('g'));
-
-      // The sync updates should have flushed, but not the async ones. Update d
-      // was dropped and replaced by e.
-      expect(Scheduler).toHaveYielded(['e', 'f']);
-      expect(ReactNoop.getChildren()).toEqual([span('f')]);
-
-      // Now flush the remaining work. Even though e and f were already processed,
-      // they should be processed again, to ensure that the terminal state
-      // is deterministic.
-      expect(Scheduler).toFlushAndYield(['a', 'b', 'c', 'd', 'e', 'f', 'g']);
-      expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+      expect(Scheduler).toFlushAndYield([
+        // Then we'll re-process everything for 'g'.
+        'a',
+        'b',
+        'c',
+        'd',
+        'e',
+        'f',
+        'g',
+      ]);
     }
+    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
   });
 
   it('passes accumulation of previous updates to replaceState updater function', () => {
@@ -688,21 +708,29 @@ describe('ReactIncrementalUpdates', () => {
         pushToLog('B'),
       );
     });
-    expect(Scheduler).toHaveYielded([
-      // A and B are pending. B is higher priority, so we'll render that first.
-      'Committed: B',
-      // Because A comes first in the queue, we're now in rebase mode. B must
-      // be rebased on top of A. Also, in a layout effect, we received two new
-      // updates: C and D. C is user-blocking and D is synchronous.
-      //
-      // First render the synchronous update. What we're testing here is that
-      // B *is not dropped* even though it has lower than sync priority. That's
-      // because we already committed it. However, this render should not
-      // include C, because that update wasn't already committed.
-      'Committed: BD',
-      'Committed: BCD',
-      'Committed: ABCD',
-    ]);
+    if (gate(flags => flags.enableUnifiedSyncLane)) {
+      expect(Scheduler).toHaveYielded([
+        'Committed: B',
+        'Committed: BCD',
+        'Committed: ABCD',
+      ]);
+    } else {
+      expect(Scheduler).toHaveYielded([
+        // A and B are pending. B is higher priority, so we'll render that first.
+        'Committed: B',
+        // Because A comes first in the queue, we're now in rebase mode. B must
+        // be rebased on top of A. Also, in a layout effect, we received two new
+        // updates: C and D. C is user-blocking and D is synchronous.
+        //
+        // First render the synchronous update. What we're testing here is that
+        // B *is not dropped* even though it has lower than sync priority. That's
+        // because we already committed it. However, this render should not
+        // include C, because that update wasn't already committed.
+        'Committed: BD',
+        'Committed: BCD',
+        'Committed: ABCD',
+      ]);
+    }
     expect(root).toMatchRenderedOutput('ABCD');
   });
 
@@ -748,21 +776,29 @@ describe('ReactIncrementalUpdates', () => {
         pushToLog('B'),
       );
     });
-    expect(Scheduler).toHaveYielded([
-      // A and B are pending. B is higher priority, so we'll render that first.
-      'Committed: B',
-      // Because A comes first in the queue, we're now in rebase mode. B must
-      // be rebased on top of A. Also, in a layout effect, we received two new
-      // updates: C and D. C is user-blocking and D is synchronous.
-      //
-      // First render the synchronous update. What we're testing here is that
-      // B *is not dropped* even though it has lower than sync priority. That's
-      // because we already committed it. However, this render should not
-      // include C, because that update wasn't already committed.
-      'Committed: BD',
-      'Committed: BCD',
-      'Committed: ABCD',
-    ]);
+    if (gate(flags => flags.enableUnifiedSyncLane)) {
+      expect(Scheduler).toHaveYielded([
+        'Committed: B',
+        'Committed: BCD',
+        'Committed: ABCD',
+      ]);
+    } else {
+      expect(Scheduler).toHaveYielded([
+        // A and B are pending. B is higher priority, so we'll render that first.
+        'Committed: B',
+        // Because A comes first in the queue, we're now in rebase mode. B must
+        // be rebased on top of A. Also, in a layout effect, we received two new
+        // updates: C and D. C is user-blocking and D is synchronous.
+        //
+        // First render the synchronous update. What we're testing here is that
+        // B *is not dropped* even though it has lower than sync priority. That's
+        // because we already committed it. However, this render should not
+        // include C, because that update wasn't already committed.
+        'Committed: BD',
+        'Committed: BCD',
+        'Committed: ABCD',
+      ]);
+    }
     expect(root).toMatchRenderedOutput('ABCD');
   });
 

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index b56fdc8536..f5f480ecca 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -24,8 +24,8 @@ describe('ReactIncrementalUpdates', () => {
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
     act = require('jest-react').act;
-    ContinuousEventPriority = require('react-reconciler/constants')
-      .ContinuousEventPriority;
+    ContinuousEventPriority =
+      require('react-reconciler/constants').ContinuousEventPriority;
   });
 
   function span(prop) {
@@ -139,13 +139,7 @@ describe('ReactIncrementalUpdates', () => {
       state = {};
       render() {
         instance = this;
-        return (
-          <span
-            prop={Object.keys(this.state)
-              .sort()
-              .join('')}
-          />
-        );
+        return <span prop={Object.keys(this.state).sort().join('')} />;
       }
     }
 
@@ -250,13 +244,7 @@ describe('ReactIncrementalUpdates', () => {
       state = {};
       render() {
         instance = this;
-        return (
-          <span
-            prop={Object.keys(this.state)
-              .sort()
-              .join('')}
-          />
-        );
+        return <span prop={Object.keys(this.state).sort().join('')} />;
       }
     }
 

commit 3ff1540e9bbe30aae52e2c9ab61c843bd0c94237
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Feb 9 11:54:35 2023 +0100

    Prefer JSX in ReactNoop assertions (to combat out-of-memory test runs) (#26127)
    
    ## Summary
    
    Prefer `getChildrenAsJSX` or `toMatchRenderedOutput` over `getChildren`.
    Use `dangerouslyGetChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    Prefer `getPendingChildrenAsJSX` over `getPendingChildren`. Use
    `dangerouslyGetPendingChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    `ReactNoop.getChildren` contains the fibers as non-enumerable
    properties. If you pass the children to `toEqual` and have a mismatch,
    Jest performance is very poor (to the point of causing out-of-memory
    crashes e.g.
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624297/parallel-runs/5?filterBy=ALL&invite=true#step-106-27).
    Mismatches can sometimes be intended e.g. on gated tests.
    
    Instead, I converted almost all of the `toEqual` assertions to
    `toMatchRenderedOutput` assertions or compare the JSX instead. For
    ReactNoopPersistent we still use `getChildren` since we have assertions
    on referential equality. `toMatchRenderedOutput` is more accurate in
    some instances anyway. I highlighted some of those more accurate
    assertions in review-comments.
    
    ## How did you test this change?
    
    - [x] `CIRCLE_NODE_TOTAL=20 CIRCLE_NODE_INDEX=5 yarn test
    -r=experimental --env=development --ci`: Can take up to 350s (and use up
    to 7GB of memory) on `main` but 11s on this branch
    - [x] No more slow `yarn test` parallel runs of `yarn_test` jobs (the
    steps in these runs should take <1min but sometimes they take 3min and
    end with OOM like
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624258/parallel-runs/5?filterBy=ALL:
    Looks good with a sample size of 1
    https://app.circleci.com/pipelines/github/facebook/react/38110/workflows/745109a2-b86b-429f-8c01-9b23a245417a/jobs/624651

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index f5f480ecca..02c849f6ed 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -28,10 +28,6 @@ describe('ReactIncrementalUpdates', () => {
       require('react-reconciler/constants').ContinuousEventPriority;
   });
 
-  function span(prop) {
-    return {type: 'span', children: [], prop, hidden: false};
-  }
-
   function flushNextRenderIfExpired() {
     // This will start rendering the next level of work. If the work hasn't
     // expired yet, React will exit without doing anything. If it has expired,
@@ -174,7 +170,7 @@ describe('ReactIncrementalUpdates', () => {
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
-    expect(ReactNoop.getChildren()).toEqual([span('')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="" />);
 
     // Schedule some more updates at different priorities
     instance.setState(createUpdate('d'));
@@ -193,11 +189,11 @@ describe('ReactIncrementalUpdates', () => {
       )
     ) {
       expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
-      expect(ReactNoop.getChildren()).toEqual([span('def')]);
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
     } else {
       // Update d was dropped and replaced by e.
       expect(Scheduler).toHaveYielded(['e', 'f']);
-      expect(ReactNoop.getChildren()).toEqual([span('ef')]);
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="ef" />);
     }
 
     // Now flush the remaining work. Even though e and f were already processed,
@@ -235,7 +231,7 @@ describe('ReactIncrementalUpdates', () => {
         'g',
       ]);
     }
-    expect(ReactNoop.getChildren()).toEqual([span('abcdefg')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="abcdefg" />);
   });
 
   it('can abort an update, schedule a replaceState, and resume', () => {
@@ -279,7 +275,7 @@ describe('ReactIncrementalUpdates', () => {
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
-    expect(ReactNoop.getChildren()).toEqual([span('')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="" />);
 
     // Schedule some more updates at different priorities
     instance.setState(createUpdate('d'));
@@ -305,7 +301,7 @@ describe('ReactIncrementalUpdates', () => {
       // Update d was dropped and replaced by e.
       expect(Scheduler).toHaveYielded(['e', 'f']);
     }
-    expect(ReactNoop.getChildren()).toEqual([span('f')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="f" />);
 
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
@@ -342,7 +338,7 @@ describe('ReactIncrementalUpdates', () => {
         'g',
       ]);
     }
-    expect(ReactNoop.getChildren()).toEqual([span('fg')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="fg" />);
   });
 
   it('passes accumulation of previous updates to replaceState updater function', () => {
@@ -537,7 +533,7 @@ describe('ReactIncrementalUpdates', () => {
     ReactNoop.flushSync(() => {
       ReactNoop.render(<Foo />);
     });
-    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="derived state" />);
 
     ReactNoop.flushSync(() => {
       // Triggers getDerivedStateFromProps again
@@ -546,12 +542,12 @@ describe('ReactIncrementalUpdates', () => {
       // led to this bug. Removing it causes it to "accidentally" work.
       foo.setState({value: 'update state'}, function noop() {});
     });
-    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="derived state" />);
 
     ReactNoop.flushSync(() => {
       bar.setState({});
     });
-    expect(ReactNoop.getChildren()).toEqual([span('derived state')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="derived state" />);
   });
 
   it('regression: does not expire soon due to layout effects in the last batch', () => {

commit 59409349671d7c096975025ff21996c525e4ae2b
Author: Ming Ye <ymqyit@gmail.com>
Date:   Fri Feb 10 00:07:49 2023 +0800

    Update to Jest 29 (#26088)
    
    ## Summary
    
    - yarn.lock diff +-6249, **small pr**
    - use jest-environment-jsdom by default
    - uncaught error from jsdom is an error object instead of strings
    - abortSignal.reason is read-only in jsdom and node,
    https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason
    
    ## How did you test this change?
    
    ci green
    
    ---------
    
    Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 02c849f6ed..1d6ab92a49 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -18,7 +18,7 @@ let act;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
-    jest.resetModuleRegistry();
+    jest.resetModules();
 
     React = require('react');
     ReactNoop = require('react-noop-renderer');

commit b2ae9ddb3b497d16a7c27c051da1827d08871138
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Feb 27 14:04:02 2023 -0500

    Cleanup enableSyncDefaultUpdate flag (#26236)
    
    This feature flag is enabled everywhere.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 1d6ab92a49..de60712c11 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -152,21 +152,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
-      )
-    ) {
-      React.startTransition(() => {
-        instance.setState(createUpdate('a'));
-        instance.setState(createUpdate('b'));
-        instance.setState(createUpdate('c'));
-      });
-    } else {
+    React.startTransition(() => {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    }
+    });
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
@@ -183,11 +173,7 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
-      )
-    ) {
+    if (gate(flags => flags.enableUnifiedSyncLane)) {
       expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
     } else {
@@ -199,11 +185,7 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
-      )
-    ) {
+    if (gate(flags => !flags.enableUnifiedSyncLane)) {
       expect(Scheduler).toFlushAndYield([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -257,21 +239,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
-      )
-    ) {
-      React.startTransition(() => {
-        instance.setState(createUpdate('a'));
-        instance.setState(createUpdate('b'));
-        instance.setState(createUpdate('c'));
-      });
-    } else {
+    React.startTransition(() => {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    }
+    });
 
     // Begin the updates but don't flush them yet
     expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
@@ -291,11 +263,7 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
-      )
-    ) {
+    if (gate(flags => flags.enableUnifiedSyncLane)) {
       expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
     } else {
       // Update d was dropped and replaced by e.
@@ -306,11 +274,7 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (
-      gate(
-        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
-      )
-    ) {
+    if (gate(flags => !flags.enableUnifiedSyncLane)) {
       expect(Scheduler).toFlushAndYield([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -566,13 +530,9 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     act(() => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          ReactNoop.render(<App />);
-        });
-      } else {
+      React.startTransition(() => {
         ReactNoop.render(<App />);
-      }
+      });
       flushNextRenderIfExpired();
       expect(Scheduler).toHaveYielded([]);
       expect(Scheduler).toFlushAndYield([
@@ -582,13 +542,9 @@ describe('ReactIncrementalUpdates', () => {
       ]);
 
       Scheduler.unstable_advanceTime(10000);
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          setCount(2);
-        });
-      } else {
+      React.startTransition(() => {
         setCount(2);
-      }
+      });
       flushNextRenderIfExpired();
       expect(Scheduler).toHaveYielded([]);
     });
@@ -607,13 +563,9 @@ describe('ReactIncrementalUpdates', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Text text="B" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Text text="B" />);
-    }
+    });
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
   });
@@ -624,26 +576,18 @@ describe('ReactIncrementalUpdates', () => {
       return text;
     }
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Text text="A" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Text text="A" />);
-    }
+    });
     Scheduler.unstable_advanceTime(10000);
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded(['A']);
 
     Scheduler.unstable_advanceTime(10000);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<Text text="B" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<Text text="B" />);
-    }
+    });
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
   });
@@ -680,13 +624,9 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          pushToLog('A');
-        });
-      } else {
+      React.startTransition(() => {
         pushToLog('A');
-      }
+      });
 
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
@@ -749,13 +689,9 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          pushToLog('A');
-        });
-      } else {
+      React.startTransition(() => {
         pushToLog('A');
-      }
+      });
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );

commit faacefb4d0167f8d5973672754fe87afc607397b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 21:24:22 2023 -0500

    Codemod tests to waitFor pattern (4/?) (#26302)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index de60712c11..3c548469fb 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -15,6 +15,9 @@ let ReactNoop;
 let Scheduler;
 let ContinuousEventPriority;
 let act;
+let waitForAll;
+let waitFor;
+let assertLog;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
@@ -26,6 +29,11 @@ describe('ReactIncrementalUpdates', () => {
     act = require('jest-react').act;
     ContinuousEventPriority =
       require('react-reconciler/constants').ContinuousEventPriority;
+
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
   });
 
   function flushNextRenderIfExpired() {
@@ -37,7 +45,7 @@ describe('ReactIncrementalUpdates', () => {
     ReactNoop.flushSync();
   }
 
-  it('applies updates in order of priority', () => {
+  it('applies updates in order of priority', async () => {
     let state;
     class Foo extends React.Component {
       state = {};
@@ -58,14 +66,14 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushAndYieldThrough(['commit']);
+    await waitFor(['commit']);
 
     expect(state).toEqual({a: 'a'});
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
   });
 
-  it('applies updates with equal priority in insertion order', () => {
+  it('applies updates with equal priority in insertion order', async () => {
     let state;
     class Foo extends React.Component {
       state = {};
@@ -82,11 +90,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(state).toEqual({a: 'a', b: 'b', c: 'c'});
   });
 
-  it('only drops updates with equal or lesser priority when replaceState is called', () => {
+  it('only drops updates with equal or lesser priority when replaceState is called', async () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -104,7 +112,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushAndYield(['render', 'componentDidMount']);
+    await waitForAll(['render', 'componentDidMount']);
 
     ReactNoop.flushSync(() => {
       React.startTransition(() => {
@@ -122,14 +130,14 @@ describe('ReactIncrementalUpdates', () => {
     // Even though a replaceState has been already scheduled, it hasn't been
     // flushed yet because it has async priority.
     expect(instance.state).toEqual({a: 'a', b: 'b'});
-    expect(Scheduler).toHaveYielded(['render', 'componentDidUpdate']);
+    assertLog(['render', 'componentDidUpdate']);
 
-    expect(Scheduler).toFlushAndYield(['render', 'componentDidUpdate']);
+    await waitForAll(['render', 'componentDidUpdate']);
     // Now the rest of the updates are flushed, including the replaceState.
     expect(instance.state).toEqual({c: 'c', d: 'd'});
   });
 
-  it('can abort an update, schedule additional updates, and resume', () => {
+  it('can abort an update, schedule additional updates, and resume', async () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -140,7 +148,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     function createUpdate(letter) {
       return () => {
@@ -159,7 +167,7 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // Begin the updates but don't flush them yet
-    expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
+    await waitFor(['a', 'b', 'c']);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="" />);
 
     // Schedule some more updates at different priorities
@@ -174,11 +182,11 @@ describe('ReactIncrementalUpdates', () => {
 
     // The sync updates should have flushed, but not the async ones.
     if (gate(flags => flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
+      assertLog(['d', 'e', 'f']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
     } else {
       // Update d was dropped and replaced by e.
-      expect(Scheduler).toHaveYielded(['e', 'f']);
+      assertLog(['e', 'f']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="ef" />);
     }
 
@@ -186,7 +194,7 @@ describe('ReactIncrementalUpdates', () => {
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
     if (gate(flags => !flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toFlushAndYield([
+      await waitForAll([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
         'd',
@@ -202,7 +210,7 @@ describe('ReactIncrementalUpdates', () => {
         'g',
       ]);
     } else {
-      expect(Scheduler).toFlushAndYield([
+      await waitForAll([
         // Then we'll re-process everything for 'g'.
         'a',
         'b',
@@ -216,7 +224,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop).toMatchRenderedOutput(<span prop="abcdefg" />);
   });
 
-  it('can abort an update, schedule a replaceState, and resume', () => {
+  it('can abort an update, schedule a replaceState, and resume', async () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -227,7 +235,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     function createUpdate(letter) {
       return () => {
@@ -246,7 +254,7 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // Begin the updates but don't flush them yet
-    expect(Scheduler).toFlushAndYieldThrough(['a', 'b', 'c']);
+    await waitFor(['a', 'b', 'c']);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="" />);
 
     // Schedule some more updates at different priorities
@@ -264,10 +272,10 @@ describe('ReactIncrementalUpdates', () => {
 
     // The sync updates should have flushed, but not the async ones.
     if (gate(flags => flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toHaveYielded(['d', 'e', 'f']);
+      assertLog(['d', 'e', 'f']);
     } else {
       // Update d was dropped and replaced by e.
-      expect(Scheduler).toHaveYielded(['e', 'f']);
+      assertLog(['e', 'f']);
     }
     expect(ReactNoop).toMatchRenderedOutput(<span prop="f" />);
 
@@ -275,7 +283,7 @@ describe('ReactIncrementalUpdates', () => {
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
     if (gate(flags => !flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toFlushAndYield([
+      await waitForAll([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
         'd',
@@ -291,7 +299,7 @@ describe('ReactIncrementalUpdates', () => {
         'g',
       ]);
     } else {
-      expect(Scheduler).toFlushAndYield([
+      await waitForAll([
         // Then we'll re-process everything for 'g'.
         'a',
         'b',
@@ -305,7 +313,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop).toMatchRenderedOutput(<span prop="fg" />);
   });
 
-  it('passes accumulation of previous updates to replaceState updater function', () => {
+  it('passes accumulation of previous updates to replaceState updater function', async () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -315,7 +323,7 @@ describe('ReactIncrementalUpdates', () => {
       }
     }
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     instance.setState({a: 'a'});
     instance.setState({b: 'b'});
@@ -324,11 +332,11 @@ describe('ReactIncrementalUpdates', () => {
     instance.updater.enqueueReplaceState(instance, previousState => ({
       previousState,
     }));
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
     expect(instance.state).toEqual({previousState: {a: 'a', b: 'b'}});
   });
 
-  it('does not call callbacks that are scheduled by another callback until a later commit', () => {
+  it('does not call callbacks that are scheduled by another callback until a later commit', async () => {
     class Foo extends React.Component {
       state = {};
       componentDidMount() {
@@ -347,7 +355,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushAndYield([
+    await waitForAll([
       'render',
       'did mount',
       'render',
@@ -357,7 +365,7 @@ describe('ReactIncrementalUpdates', () => {
     ]);
   });
 
-  it('gives setState during reconciliation the same priority as whatever level is currently reconciling', () => {
+  it('gives setState during reconciliation the same priority as whatever level is currently reconciling', async () => {
     let instance;
 
     class Foo extends React.Component {
@@ -373,7 +381,7 @@ describe('ReactIncrementalUpdates', () => {
       }
     }
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushAndYield(['render']);
+    await waitForAll(['render']);
 
     ReactNoop.flushSync(() => {
       instance.setState({a: 'a'});
@@ -384,17 +392,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
     if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-      expect(Scheduler).toHaveYielded([
-        'componentWillReceiveProps',
-        'render',
-        'render',
-      ]);
+      assertLog(['componentWillReceiveProps', 'render', 'render']);
     } else {
-      expect(Scheduler).toHaveYielded(['componentWillReceiveProps', 'render']);
+      assertLog(['componentWillReceiveProps', 'render']);
     }
   });
 
-  it('updates triggered from inside a class setState updater', () => {
+  it('updates triggered from inside a class setState updater', async () => {
     let instance;
     class Foo extends React.Component {
       state = {};
@@ -406,7 +410,7 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     ReactNoop.render(<Foo />);
-    expect(Scheduler).toFlushAndYield([
+    await waitForAll([
       // Initial render
       'render',
     ]);
@@ -451,7 +455,7 @@ describe('ReactIncrementalUpdates', () => {
       this.setState({a: 'a'});
       return {b: 'b'};
     });
-    expect(Scheduler).toFlushAndYield(
+    await waitForAll(
       gate(flags =>
         flags.deferRenderPhaseUpdateToNextBatch
           ? // In the new reconciler, updates inside the render phase are
@@ -529,24 +533,20 @@ describe('ReactIncrementalUpdates', () => {
       return null;
     }
 
-    act(() => {
+    act(async () => {
       React.startTransition(() => {
         ReactNoop.render(<App />);
       });
       flushNextRenderIfExpired();
-      expect(Scheduler).toHaveYielded([]);
-      expect(Scheduler).toFlushAndYield([
-        'Render: 0',
-        'Commit: 0',
-        'Render: 1',
-      ]);
+      assertLog([]);
+      await waitForAll(['Render: 0', 'Commit: 0', 'Render: 1']);
 
       Scheduler.unstable_advanceTime(10000);
       React.startTransition(() => {
         setCount(2);
       });
       flushNextRenderIfExpired();
-      expect(Scheduler).toHaveYielded([]);
+      assertLog([]);
     });
   });
 
@@ -559,7 +559,7 @@ describe('ReactIncrementalUpdates', () => {
     ReactNoop.flushSync(() => {
       ReactNoop.render(<Text text="A" />);
     });
-    expect(Scheduler).toHaveYielded(['A']);
+    assertLog(['A']);
 
     Scheduler.unstable_advanceTime(10000);
 
@@ -567,7 +567,7 @@ describe('ReactIncrementalUpdates', () => {
       ReactNoop.render(<Text text="B" />);
     });
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
   });
 
   it('regression: does not expire soon due to previous expired work', () => {
@@ -581,7 +581,7 @@ describe('ReactIncrementalUpdates', () => {
     });
     Scheduler.unstable_advanceTime(10000);
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded(['A']);
+    assertLog(['A']);
 
     Scheduler.unstable_advanceTime(10000);
 
@@ -589,7 +589,7 @@ describe('ReactIncrementalUpdates', () => {
       ReactNoop.render(<Text text="B" />);
     });
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
   });
 
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {
@@ -620,7 +620,7 @@ describe('ReactIncrementalUpdates', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['Committed: ']);
+    assertLog(['Committed: ']);
     expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
@@ -633,13 +633,9 @@ describe('ReactIncrementalUpdates', () => {
       );
     });
     if (gate(flags => flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toHaveYielded([
-        'Committed: B',
-        'Committed: BCD',
-        'Committed: ABCD',
-      ]);
+      assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
     } else {
-      expect(Scheduler).toHaveYielded([
+      assertLog([
         // A and B are pending. B is higher priority, so we'll render that first.
         'Committed: B',
         // Because A comes first in the queue, we're now in rebase mode. B must
@@ -685,7 +681,7 @@ describe('ReactIncrementalUpdates', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(root).toMatchRenderedOutput(null);
 
     await act(async () => {
@@ -697,13 +693,9 @@ describe('ReactIncrementalUpdates', () => {
       );
     });
     if (gate(flags => flags.enableUnifiedSyncLane)) {
-      expect(Scheduler).toHaveYielded([
-        'Committed: B',
-        'Committed: BCD',
-        'Committed: ABCD',
-      ]);
+      assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
     } else {
-      expect(Scheduler).toHaveYielded([
+      assertLog([
         // A and B are pending. B is higher priority, so we'll render that first.
         'Committed: B',
         // Because A comes first in the queue, we're now in rebase mode. B must

commit 9a52cc8bcd580238f4a8b12036e698823847fd65
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 4 11:44:41 2023 -0500

    Convert ReactLazy-test to waitFor pattern (#26304)
    
    I'm in the process of codemodding our test suite to the waitFor pattern.
    See #26285 for full context.
    
    This module required a lot of manual changes so I'm doing it as its own
    PR. The reason is that most of the tests involved simulating an async
    import by wrapping them in `Promise.resolve()`, which means they would
    immediately resolve the next time the microtask queue was flushed. I
    rewrote the tests to resolve the simulated import explicitly.
    
    While converting these tests, I also realized that the `waitFor` helpers
    weren't properly waiting for the entire microtask queue to recursively
    finish — if a microtask schedules another microtask, the subsequent one
    wouldn't fire until after `waitFor` had resolved. To fix this, I used
    the same strategy as `act` — wait for a real task to finish before
    proceeding, such as a message event.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 3c548469fb..6f81c28ea9 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -518,7 +518,7 @@ describe('ReactIncrementalUpdates', () => {
     expect(ReactNoop).toMatchRenderedOutput(<span prop="derived state" />);
   });
 
-  it('regression: does not expire soon due to layout effects in the last batch', () => {
+  it('regression: does not expire soon due to layout effects in the last batch', async () => {
     const {useState, useLayoutEffect} = React;
 
     let setCount;
@@ -533,7 +533,7 @@ describe('ReactIncrementalUpdates', () => {
       return null;
     }
 
-    act(async () => {
+    await act(async () => {
       React.startTransition(() => {
         ReactNoop.render(<App />);
       });

commit 25685d8a90dd83d30cee6bd365bcb0115f1a2ff1
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 4 18:06:20 2023 -0500

    Codemod tests to waitFor pattern (9/?) (#26309)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 6f81c28ea9..4fd471d752 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -421,27 +421,28 @@ describe('ReactIncrementalUpdates', () => {
       return {a: 'a'};
     });
 
-    expect(() =>
-      expect(Scheduler).toFlushAndYield(
-        gate(flags =>
-          flags.deferRenderPhaseUpdateToNextBatch
-            ? [
-                'setState updater',
-                // In the new reconciler, updates inside the render phase are
-                // treated as if they came from an event, so the update gets
-                // shifted to a subsequent render.
-                'render',
-                'render',
-              ]
-            : [
-                'setState updater',
-                // In the old reconciler, updates in the render phase receive
-                // the currently rendering expiration time, so the update
-                // flushes immediately in the same render.
-                'render',
-              ],
+    await expect(
+      async () =>
+        await waitForAll(
+          gate(flags =>
+            flags.deferRenderPhaseUpdateToNextBatch
+              ? [
+                  'setState updater',
+                  // In the new reconciler, updates inside the render phase are
+                  // treated as if they came from an event, so the update gets
+                  // shifted to a subsequent render.
+                  'render',
+                  'render',
+                ]
+              : [
+                  'setState updater',
+                  // In the old reconciler, updates in the render phase receive
+                  // the currently rendering expiration time, so the update
+                  // flushes immediately in the same render.
+                  'render',
+                ],
+          ),
         ),
-      ),
     ).toErrorDev(
       'An update (setState, replaceState, or forceUpdate) was scheduled ' +
         'from inside an update function. Update functions should be pure, ' +

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 4fd471d752..f9dcf753ba 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -50,7 +50,7 @@ describe('ReactIncrementalUpdates', () => {
     class Foo extends React.Component {
       state = {};
       componentDidMount() {
-        Scheduler.unstable_yieldValue('commit');
+        Scheduler.log('commit');
         React.startTransition(() => {
           // Has low priority
           this.setState({b: 'b'});
@@ -99,13 +99,13 @@ describe('ReactIncrementalUpdates', () => {
     class Foo extends React.Component {
       state = {};
       componentDidMount() {
-        Scheduler.unstable_yieldValue('componentDidMount');
+        Scheduler.log('componentDidMount');
       }
       componentDidUpdate() {
-        Scheduler.unstable_yieldValue('componentDidUpdate');
+        Scheduler.log('componentDidUpdate');
       }
       render() {
-        Scheduler.unstable_yieldValue('render');
+        Scheduler.log('render');
         instance = this;
         return <div />;
       }
@@ -152,7 +152,7 @@ describe('ReactIncrementalUpdates', () => {
 
     function createUpdate(letter) {
       return () => {
-        Scheduler.unstable_yieldValue(letter);
+        Scheduler.log(letter);
         return {
           [letter]: letter,
         };
@@ -239,7 +239,7 @@ describe('ReactIncrementalUpdates', () => {
 
     function createUpdate(letter) {
       return () => {
-        Scheduler.unstable_yieldValue(letter);
+        Scheduler.log(letter);
         return {
           [letter]: letter,
         };
@@ -340,16 +340,16 @@ describe('ReactIncrementalUpdates', () => {
     class Foo extends React.Component {
       state = {};
       componentDidMount() {
-        Scheduler.unstable_yieldValue('did mount');
+        Scheduler.log('did mount');
         this.setState({a: 'a'}, () => {
-          Scheduler.unstable_yieldValue('callback a');
+          Scheduler.log('callback a');
           this.setState({b: 'b'}, () => {
-            Scheduler.unstable_yieldValue('callback b');
+            Scheduler.log('callback b');
           });
         });
       }
       render() {
-        Scheduler.unstable_yieldValue('render');
+        Scheduler.log('render');
         return <div />;
       }
     }
@@ -371,11 +371,11 @@ describe('ReactIncrementalUpdates', () => {
     class Foo extends React.Component {
       state = {};
       UNSAFE_componentWillReceiveProps() {
-        Scheduler.unstable_yieldValue('componentWillReceiveProps');
+        Scheduler.log('componentWillReceiveProps');
         this.setState({b: 'b'});
       }
       render() {
-        Scheduler.unstable_yieldValue('render');
+        Scheduler.log('render');
         instance = this;
         return <div />;
       }
@@ -403,7 +403,7 @@ describe('ReactIncrementalUpdates', () => {
     class Foo extends React.Component {
       state = {};
       render() {
-        Scheduler.unstable_yieldValue('render');
+        Scheduler.log('render');
         instance = this;
         return <div />;
       }
@@ -416,7 +416,7 @@ describe('ReactIncrementalUpdates', () => {
     ]);
 
     instance.setState(function a() {
-      Scheduler.unstable_yieldValue('setState updater');
+      Scheduler.log('setState updater');
       this.setState({b: 'b'});
       return {a: 'a'};
     });
@@ -526,10 +526,10 @@ describe('ReactIncrementalUpdates', () => {
     function App() {
       const [count, _setCount] = useState(0);
       setCount = _setCount;
-      Scheduler.unstable_yieldValue('Render: ' + count);
+      Scheduler.log('Render: ' + count);
       useLayoutEffect(() => {
         setCount(prevCount => prevCount + 1);
-        Scheduler.unstable_yieldValue('Commit: ' + count);
+        Scheduler.log('Commit: ' + count);
       }, []);
       return null;
     }
@@ -553,7 +553,7 @@ describe('ReactIncrementalUpdates', () => {
 
   it('regression: does not expire soon due to previous flushSync', () => {
     function Text({text}) {
-      Scheduler.unstable_yieldValue(text);
+      Scheduler.log(text);
       return text;
     }
 
@@ -573,7 +573,7 @@ describe('ReactIncrementalUpdates', () => {
 
   it('regression: does not expire soon due to previous expired work', () => {
     function Text({text}) {
-      Scheduler.unstable_yieldValue(text);
+      Scheduler.log(text);
       return text;
     }
 
@@ -604,7 +604,7 @@ describe('ReactIncrementalUpdates', () => {
       };
 
       useLayoutEffect(() => {
-        Scheduler.unstable_yieldValue('Committed: ' + log);
+        Scheduler.log('Committed: ' + log);
         if (log === 'B') {
           // Right after B commits, schedule additional updates.
           ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
@@ -663,7 +663,7 @@ describe('ReactIncrementalUpdates', () => {
         this.setState(prevState => ({log: prevState.log + msg}));
       };
       componentDidUpdate() {
-        Scheduler.unstable_yieldValue('Committed: ' + this.state.log);
+        Scheduler.log('Committed: ' + this.state.log);
         if (this.state.log === 'B') {
           // Right after B commits, schedule additional updates.
           ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>

commit 44d3807945700de8bb6bdbbf5c4d1ba513303747
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 12:58:31 2023 -0500

    Move internalAct to internal-test-utils package (#26344)
    
    This is not a public API. We only use it for our internal tests, the
    ones in this repo. Let's move it to this private package. Practically
    speaking this will also let us use async/await in the implementation.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index f9dcf753ba..dd88d959aa 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -26,7 +26,7 @@ describe('ReactIncrementalUpdates', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
-    act = require('jest-react').act;
+    act = require('internal-test-utils').act;
     ContinuousEventPriority =
       require('react-reconciler/constants').ContinuousEventPriority;
 

commit 62cd5af08e2ac8b1d4691e75252487083cf7a4aa
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 16:40:23 2023 -0500

    Codemod redundant async act scopes (#26350)
    
    Prior to #26347, our internal `act` API (not the public API) behaved
    differently depending on whether the scope function returned a promise
    (i.e. was an async function), for historical reasons that no longer
    apply. Now that this is fixed, I've codemodded all async act scopes that
    don't contain an await to be sync.
    
    No pressing motivation other than it looks nicer and the codemod was
    easy. Might help avoid confusion for new contributors who see async act
    scopes with nothing async inside and infer it must be like that for a
    reason.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index dd88d959aa..5fd12fee1f 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -618,13 +618,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['Committed: ']);
     expect(root).toMatchRenderedOutput(null);
 
-    await act(async () => {
+    await act(() => {
       React.startTransition(() => {
         pushToLog('A');
       });
@@ -679,13 +679,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog([]);
     expect(root).toMatchRenderedOutput(null);
 
-    await act(async () => {
+    await act(() => {
       React.startTransition(() => {
         pushToLog('A');
       });
@@ -742,20 +742,20 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App prop="A" />);
     });
     expect(root).toMatchRenderedOutput('0');
 
     // Changing the prop causes the count to increase by 100
-    await act(async () => {
+    await act(() => {
       root.render(<App prop="B" />);
     });
     expect(root).toMatchRenderedOutput('100');
 
     // Now increment the count by 1 with a state update. And, in the same
     // batch, change the prop back to its original value.
-    await act(async () => {
+    await act(() => {
       root.render(<App prop="A" />);
       app.setState(state => ({count: state.count + 1}));
     });

commit fc90eb636876d54d99ace2773dd4923f3e848106
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 28 00:03:57 2023 -0400

    Codemod more tests to waitFor pattern (#26494)

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 5fd12fee1f..a85cf89c68 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -36,13 +36,9 @@ describe('ReactIncrementalUpdates', () => {
     assertLog = InternalTestUtils.assertLog;
   });
 
-  function flushNextRenderIfExpired() {
-    // This will start rendering the next level of work. If the work hasn't
-    // expired yet, React will exit without doing anything. If it has expired,
-    // it will schedule a sync task.
-    Scheduler.unstable_flushExpired();
-    // Flush the sync task.
-    ReactNoop.flushSync();
+  function Text({text}) {
+    Scheduler.log(text);
+    return text;
   }
 
   it('applies updates in order of priority', async () => {
@@ -528,35 +524,38 @@ describe('ReactIncrementalUpdates', () => {
       setCount = _setCount;
       Scheduler.log('Render: ' + count);
       useLayoutEffect(() => {
-        setCount(prevCount => prevCount + 1);
+        setCount(1);
         Scheduler.log('Commit: ' + count);
       }, []);
-      return null;
+      return <Text text="Child" />;
     }
 
     await act(async () => {
       React.startTransition(() => {
         ReactNoop.render(<App />);
       });
-      flushNextRenderIfExpired();
       assertLog([]);
-      await waitForAll(['Render: 0', 'Commit: 0', 'Render: 1']);
+      await waitForAll([
+        'Render: 0',
+        'Child',
+        'Commit: 0',
+        'Render: 1',
+        'Child',
+      ]);
 
       Scheduler.unstable_advanceTime(10000);
       React.startTransition(() => {
         setCount(2);
       });
-      flushNextRenderIfExpired();
-      assertLog([]);
+      // The transition should not have expired, so we should be able to
+      // partially render it.
+      await waitFor(['Render: 2']);
+      // Now do the rest
+      await waitForAll(['Child']);
     });
   });
 
-  it('regression: does not expire soon due to previous flushSync', () => {
-    function Text({text}) {
-      Scheduler.log(text);
-      return text;
-    }
-
+  it('regression: does not expire soon due to previous flushSync', async () => {
     ReactNoop.flushSync(() => {
       ReactNoop.render(<Text text="A" />);
     });
@@ -565,32 +564,70 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     React.startTransition(() => {
-      ReactNoop.render(<Text text="B" />);
+      ReactNoop.render(
+        <>
+          <Text text="A" />
+          <Text text="B" />
+          <Text text="C" />
+          <Text text="D" />
+        </>,
+      );
+    });
+    // The transition should not have expired, so we should be able to
+    // partially render it.
+    await waitFor(['A']);
+
+    // FIXME:  We should be able to partially render B, too, but currently it
+    // expires. This is an existing bug that I discovered, which will be fixed
+    // in a PR that I'm currently working on.
+    //
+    // Correct behavior:
+    //   await waitFor(['B']);
+    //   await waitForAll(['C', 'D']);
+    //
+    // Current behavior:
+    await waitFor(['B'], {
+      additionalLogsAfterAttemptingToYield: ['C', 'D'],
     });
-    flushNextRenderIfExpired();
-    assertLog([]);
   });
 
-  it('regression: does not expire soon due to previous expired work', () => {
-    function Text({text}) {
-      Scheduler.log(text);
-      return text;
-    }
-
+  it('regression: does not expire soon due to previous expired work', async () => {
     React.startTransition(() => {
-      ReactNoop.render(<Text text="A" />);
+      ReactNoop.render(
+        <>
+          <Text text="A" />
+          <Text text="B" />
+          <Text text="C" />
+          <Text text="D" />
+        </>,
+      );
     });
+    await waitFor(['A']);
+
+    // This will expire the rest of the update
     Scheduler.unstable_advanceTime(10000);
-    flushNextRenderIfExpired();
-    assertLog(['A']);
+    await waitFor(['B'], {
+      additionalLogsAfterAttemptingToYield: ['C', 'D'],
+    });
 
     Scheduler.unstable_advanceTime(10000);
 
+    // Now do another transition. This one should not expire.
     React.startTransition(() => {
-      ReactNoop.render(<Text text="B" />);
+      ReactNoop.render(
+        <>
+          <Text text="A" />
+          <Text text="B" />
+          <Text text="C" />
+          <Text text="D" />
+        </>,
+      );
     });
-    flushNextRenderIfExpired();
-    assertLog([]);
+    // The transition should not have expired, so we should be able to
+    // partially render it.
+    await waitFor(['A']);
+    await waitFor(['B']);
+    await waitForAll(['C', 'D']);
   });
 
   it('when rebasing, does not exclude updates that were already committed, regardless of priority', async () => {

commit 2d51251e608b7b1a8baf79ae6bdba81ed8e1939a
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 30 14:10:19 2023 -0400

    Clean up deferRenderPhaseUpdateToNextBatch (#26511)
    
    This is a change to some undefined behavior that we though we would do
    at one point but decided not to roll out. It's already disabled
    everywhere, so this just deletes the branch from the implementation and
    the tests.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index a85cf89c68..7413e51a3a 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -387,11 +387,7 @@ describe('ReactIncrementalUpdates', () => {
 
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
-    if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-      assertLog(['componentWillReceiveProps', 'render', 'render']);
-    } else {
-      assertLog(['componentWillReceiveProps', 'render']);
-    }
+    assertLog(['componentWillReceiveProps', 'render']);
   });
 
   it('updates triggered from inside a class setState updater', async () => {
@@ -419,26 +415,12 @@ describe('ReactIncrementalUpdates', () => {
 
     await expect(
       async () =>
-        await waitForAll(
-          gate(flags =>
-            flags.deferRenderPhaseUpdateToNextBatch
-              ? [
-                  'setState updater',
-                  // In the new reconciler, updates inside the render phase are
-                  // treated as if they came from an event, so the update gets
-                  // shifted to a subsequent render.
-                  'render',
-                  'render',
-                ]
-              : [
-                  'setState updater',
-                  // In the old reconciler, updates in the render phase receive
-                  // the currently rendering expiration time, so the update
-                  // flushes immediately in the same render.
-                  'render',
-                ],
-          ),
-        ),
+        await waitForAll([
+          'setState updater',
+          // Updates in the render phase receive the currently rendering
+          // lane, so the update flushes immediately in the same render.
+          'render',
+        ]),
     ).toErrorDev(
       'An update (setState, replaceState, or forceUpdate) was scheduled ' +
         'from inside an update function. Update functions should be pure, ' +
@@ -454,15 +436,9 @@ describe('ReactIncrementalUpdates', () => {
     });
     await waitForAll(
       gate(flags =>
-        flags.deferRenderPhaseUpdateToNextBatch
-          ? // In the new reconciler, updates inside the render phase are
-            // treated as if they came from an event, so the update gets shifted
-            // to a subsequent render.
-            ['render', 'render']
-          : // In the old reconciler, updates in the render phase receive
-            // the currently rendering expiration time, so the update flushes
-            // immediately in the same render.
-            ['render'],
+        // Updates in the render phase receive the currently rendering
+        // lane, so the update flushes immediately in the same render.
+        ['render'],
       ),
     );
   });

commit 09c8d2563300621dc91258a4c2839210e2fbdf0e
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 31 13:04:08 2023 -0400

    Move update scheduling to microtask (#26512)
    
    When React receives new input (via `setState`, a Suspense promise
    resolution, and so on), it needs to ensure there's a rendering task
    associated with the update. Most of this happens
    `ensureRootIsScheduled`.
    
    If a single event contains multiple updates, we end up running the
    scheduling code once per update. But this is wasteful because we really
    only need to run it once, at the end of the event (or in the case of
    flushSync, at the end of the scope function's execution).
    
    So this PR moves the scheduling logic to happen in a microtask instead.
    In some cases, we will force it run earlier than that, like for
    `flushSync`, but since updates are batched by default, it will almost
    always happen in the microtask. Even for discrete updates.
    
    In production, this should have no observable behavior difference. In a
    testing environment that uses `act`, this should also not have a
    behavior difference because React will push these tasks to an internal
    `act` queue.
    
    However, tests that do not use `act` and do not simulate an actual
    production environment (like an e2e test) may be affected. For example,
    before this change, if a test were to call `setState` outside of `act`
    and then immediately call `jest.runAllTimers()`, the update would be
    synchronously applied. After this change, that will no longer work
    because the rendering task (a timer, in this case) isn't scheduled until
    after the microtask queue has run.
    
    I don't expect this to be an issue in practice because most people do
    not write their tests this way. They either use `act`, or they write
    e2e-style tests.
    
    The biggest exception has been... our own internal test suite. Until
    recently, many of our tests were written in a way that accidentally
    relied on the updates being scheduled synchronously. Over the past few
    weeks, @tyao1 and I have gradually converted the test suite to use a new
    set of testing helpers that are resilient to this implementation detail.
    
    (There are also some old Relay tests that were written in the style of
    React's internal test suite. Those will need to be fixed, too.)
    
    The larger motivation behind this change, aside from a minor performance
    improvement, is we intend to use this new microtask to perform
    additional logic that doesn't yet exist. Like inferring the priority of
    a custom event.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 7413e51a3a..b224e4d776 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -552,19 +552,8 @@ describe('ReactIncrementalUpdates', () => {
     // The transition should not have expired, so we should be able to
     // partially render it.
     await waitFor(['A']);
-
-    // FIXME:  We should be able to partially render B, too, but currently it
-    // expires. This is an existing bug that I discovered, which will be fixed
-    // in a PR that I'm currently working on.
-    //
-    // Correct behavior:
-    //   await waitFor(['B']);
-    //   await waitForAll(['C', 'D']);
-    //
-    // Current behavior:
-    await waitFor(['B'], {
-      additionalLogsAfterAttemptingToYield: ['C', 'D'],
-    });
+    await waitFor(['B']);
+    await waitForAll(['C', 'D']);
   });
 
   it('regression: does not expire soon due to previous expired work', async () => {

commit da94e8b24a3f31a3e805f9bf6bba73055aad9d41
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Apr 4 10:08:14 2023 -0400

    Revert "Cleanup enableSyncDefaultUpdate flag (#26236)" (#26528)
    
    This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.
    
    While the feature flag is fully rolled out, these tests are also testing
    behavior set with an unstable flag on root, which for now we want to
    preserve.
    
    Not sure if there's a better way then adding a dynamic feature flag to
    the www build?

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index b224e4d776..13488a7c89 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -156,11 +156,21 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    React.startTransition(() => {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+      )
+    ) {
+      React.startTransition(() => {
+        instance.setState(createUpdate('a'));
+        instance.setState(createUpdate('b'));
+        instance.setState(createUpdate('c'));
+      });
+    } else {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    });
+    }
 
     // Begin the updates but don't flush them yet
     await waitFor(['a', 'b', 'c']);
@@ -177,7 +187,11 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (gate(flags => flags.enableUnifiedSyncLane)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+      )
+    ) {
       assertLog(['d', 'e', 'f']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
     } else {
@@ -189,7 +203,11 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (gate(flags => !flags.enableUnifiedSyncLane)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+      )
+    ) {
       await waitForAll([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -243,11 +261,21 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    React.startTransition(() => {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+      )
+    ) {
+      React.startTransition(() => {
+        instance.setState(createUpdate('a'));
+        instance.setState(createUpdate('b'));
+        instance.setState(createUpdate('c'));
+      });
+    } else {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    });
+    }
 
     // Begin the updates but don't flush them yet
     await waitFor(['a', 'b', 'c']);
@@ -267,7 +295,11 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (gate(flags => flags.enableUnifiedSyncLane)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+      )
+    ) {
       assertLog(['d', 'e', 'f']);
     } else {
       // Update d was dropped and replaced by e.
@@ -278,7 +310,11 @@ describe('ReactIncrementalUpdates', () => {
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (gate(flags => !flags.enableUnifiedSyncLane)) {
+    if (
+      gate(
+        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+      )
+    ) {
       await waitForAll([
         // Since 'g' is in a transition, we'll process 'd' separately first.
         // That causes us to process 'd' with 'e' and 'f' rebased.
@@ -507,9 +543,13 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     await act(async () => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          ReactNoop.render(<App />);
+        });
+      } else {
         ReactNoop.render(<App />);
-      });
+      }
       assertLog([]);
       await waitForAll([
         'Render: 0',
@@ -520,9 +560,13 @@ describe('ReactIncrementalUpdates', () => {
       ]);
 
       Scheduler.unstable_advanceTime(10000);
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          setCount(2);
+        });
+      } else {
         setCount(2);
-      });
+      }
       // The transition should not have expired, so we should be able to
       // partially render it.
       await waitFor(['Render: 2']);
@@ -539,7 +583,18 @@ describe('ReactIncrementalUpdates', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(
+          <>
+            <Text text="A" />
+            <Text text="B" />
+            <Text text="C" />
+            <Text text="D" />
+          </>,
+        );
+      });
+    } else {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -548,7 +603,7 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    });
+    }
     // The transition should not have expired, so we should be able to
     // partially render it.
     await waitFor(['A']);
@@ -557,7 +612,18 @@ describe('ReactIncrementalUpdates', () => {
   });
 
   it('regression: does not expire soon due to previous expired work', async () => {
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(
+          <>
+            <Text text="A" />
+            <Text text="B" />
+            <Text text="C" />
+            <Text text="D" />
+          </>,
+        );
+      });
+    } else {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -566,9 +632,8 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    });
+    }
     await waitFor(['A']);
-
     // This will expire the rest of the update
     Scheduler.unstable_advanceTime(10000);
     await waitFor(['B'], {
@@ -578,7 +643,18 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     // Now do another transition. This one should not expire.
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(
+          <>
+            <Text text="A" />
+            <Text text="B" />
+            <Text text="C" />
+            <Text text="D" />
+          </>,
+        );
+      });
+    } else {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -587,7 +663,7 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    });
+    }
     // The transition should not have expired, so we should be able to
     // partially render it.
     await waitFor(['A']);
@@ -627,9 +703,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(() => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          pushToLog('A');
+        });
+      } else {
         pushToLog('A');
-      });
+      }
 
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
@@ -688,9 +768,13 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(() => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          pushToLog('A');
+        });
+      } else {
         pushToLog('A');
-      });
+      }
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );

commit 018c58c9c65452cff25aaf1f38f78a9b90d8e5c1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jun 1 09:24:56 2023 -0400

    Clean up enableSyncDefaultUpdates flag a bit (#26858)
    
    ## Overview
    
    Does a few things:
    - Renames `enableSyncDefaultUpdates` to
    `forceConcurrentByDefaultForTesting`
    - Changes the way it's used so it's dead-code eliminated separate from
    `allowConcurrentByDefault`
    - Deletes a bunch of the gated code
    
    The gates that are deleted are unnecessary now. We were keeping them
    when we originally thought we would come back to being concurrent by
    default. But we've shifted and now sync-by default is the desired
    behavior long term, so there's no need to keep all these forked tests
    around.
    
    I'll follow up to delete more of the forked behavior if possible.
    Ideally we wouldn't need this flag even if we're still using
    `allowConcurrentByDefault`.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 13488a7c89..f3d5cbc675 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -158,7 +158,9 @@ describe('ReactIncrementalUpdates', () => {
     // Schedule some async updates
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting ||
+          flags.enableUnifiedSyncLane,
       )
     ) {
       React.startTransition(() => {
@@ -189,7 +191,9 @@ describe('ReactIncrementalUpdates', () => {
     // The sync updates should have flushed, but not the async ones.
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting &&
+          flags.enableUnifiedSyncLane,
       )
     ) {
       assertLog(['d', 'e', 'f']);
@@ -205,7 +209,9 @@ describe('ReactIncrementalUpdates', () => {
     // is deterministic.
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting &&
+          !flags.enableUnifiedSyncLane,
       )
     ) {
       await waitForAll([
@@ -263,7 +269,9 @@ describe('ReactIncrementalUpdates', () => {
     // Schedule some async updates
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates || flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting ||
+          flags.enableUnifiedSyncLane,
       )
     ) {
       React.startTransition(() => {
@@ -297,7 +305,9 @@ describe('ReactIncrementalUpdates', () => {
     // The sync updates should have flushed, but not the async ones.
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates && flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting &&
+          flags.enableUnifiedSyncLane,
       )
     ) {
       assertLog(['d', 'e', 'f']);
@@ -312,7 +322,9 @@ describe('ReactIncrementalUpdates', () => {
     // is deterministic.
     if (
       gate(
-        flags => flags.enableSyncDefaultUpdates && !flags.enableUnifiedSyncLane,
+        flags =>
+          !flags.forceConcurrentByDefaultForTesting &&
+          !flags.enableUnifiedSyncLane,
       )
     ) {
       await waitForAll([
@@ -543,13 +555,9 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          ReactNoop.render(<App />);
-        });
-      } else {
+      React.startTransition(() => {
         ReactNoop.render(<App />);
-      }
+      });
       assertLog([]);
       await waitForAll([
         'Render: 0',
@@ -560,13 +568,9 @@ describe('ReactIncrementalUpdates', () => {
       ]);
 
       Scheduler.unstable_advanceTime(10000);
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          setCount(2);
-        });
-      } else {
+      React.startTransition(() => {
         setCount(2);
-      }
+      });
       // The transition should not have expired, so we should be able to
       // partially render it.
       await waitFor(['Render: 2']);
@@ -583,18 +587,7 @@ describe('ReactIncrementalUpdates', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(
-          <>
-            <Text text="A" />
-            <Text text="B" />
-            <Text text="C" />
-            <Text text="D" />
-          </>,
-        );
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -603,7 +596,7 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    }
+    });
     // The transition should not have expired, so we should be able to
     // partially render it.
     await waitFor(['A']);
@@ -612,18 +605,7 @@ describe('ReactIncrementalUpdates', () => {
   });
 
   it('regression: does not expire soon due to previous expired work', async () => {
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(
-          <>
-            <Text text="A" />
-            <Text text="B" />
-            <Text text="C" />
-            <Text text="D" />
-          </>,
-        );
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -632,7 +614,8 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    }
+    });
+
     await waitFor(['A']);
     // This will expire the rest of the update
     Scheduler.unstable_advanceTime(10000);
@@ -643,18 +626,7 @@ describe('ReactIncrementalUpdates', () => {
     Scheduler.unstable_advanceTime(10000);
 
     // Now do another transition. This one should not expire.
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(
-          <>
-            <Text text="A" />
-            <Text text="B" />
-            <Text text="C" />
-            <Text text="D" />
-          </>,
-        );
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(
         <>
           <Text text="A" />
@@ -663,7 +635,8 @@ describe('ReactIncrementalUpdates', () => {
           <Text text="D" />
         </>,
       );
-    }
+    });
+
     // The transition should not have expired, so we should be able to
     // partially render it.
     await waitFor(['A']);
@@ -703,13 +676,9 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(() => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          pushToLog('A');
-        });
-      } else {
+      React.startTransition(() => {
         pushToLog('A');
-      }
+      });
 
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
@@ -768,13 +737,9 @@ describe('ReactIncrementalUpdates', () => {
     expect(root).toMatchRenderedOutput(null);
 
     await act(() => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          pushToLog('A');
-        });
-      } else {
+      React.startTransition(() => {
         pushToLog('A');
-      }
+      });
       ReactNoop.unstable_runWithPriority(ContinuousEventPriority, () =>
         pushToLog('B'),
       );

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index f3d5cbc675..d75193883e 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -21,8 +21,6 @@ let assertLog;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
-    jest.resetModules();
-
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index d75193883e..f3d5cbc675 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -21,6 +21,8 @@ let assertLog;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
+    jest.resetModules();
+
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');

commit c21bcd627b6a8f31548edfc149dd3b879fea6558
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Jun 24 11:18:22 2024 -0400

    Clean up enableUnifiedSyncLane flag (#30062)
    
    `enableUnifiedSyncLane` now passes everywhere. Let's clean it up
    
    Implemented with https://github.com/facebook/react/pull/27646
    
    Flag enabled with https://github.com/facebook/react/pull/27646,
    https://github.com/facebook/react/pull/28269,
    https://github.com/facebook/react/pull/29052

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index f3d5cbc675..4d4ab4f7c9 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -156,23 +156,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting ||
-          flags.enableUnifiedSyncLane,
-      )
-    ) {
-      React.startTransition(() => {
-        instance.setState(createUpdate('a'));
-        instance.setState(createUpdate('b'));
-        instance.setState(createUpdate('c'));
-      });
-    } else {
+    React.startTransition(() => {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    }
+    });
 
     // Begin the updates but don't flush them yet
     await waitFor(['a', 'b', 'c']);
@@ -189,58 +177,22 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting &&
-          flags.enableUnifiedSyncLane,
-      )
-    ) {
-      assertLog(['d', 'e', 'f']);
-      expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
-    } else {
-      // Update d was dropped and replaced by e.
-      assertLog(['e', 'f']);
-      expect(ReactNoop).toMatchRenderedOutput(<span prop="ef" />);
-    }
+    assertLog(['d', 'e', 'f']);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="def" />);
 
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting &&
-          !flags.enableUnifiedSyncLane,
-      )
-    ) {
-      await waitForAll([
-        // Since 'g' is in a transition, we'll process 'd' separately first.
-        // That causes us to process 'd' with 'e' and 'f' rebased.
-        'd',
-        'e',
-        'f',
-        // Then we'll re-process everything for 'g'.
-        'a',
-        'b',
-        'c',
-        'd',
-        'e',
-        'f',
-        'g',
-      ]);
-    } else {
-      await waitForAll([
-        // Then we'll re-process everything for 'g'.
-        'a',
-        'b',
-        'c',
-        'd',
-        'e',
-        'f',
-        'g',
-      ]);
-    }
+    await waitForAll([
+      // Then we'll re-process everything for 'g'.
+      'a',
+      'b',
+      'c',
+      'd',
+      'e',
+      'f',
+      'g',
+    ]);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="abcdefg" />);
   });
 
@@ -267,23 +219,11 @@ describe('ReactIncrementalUpdates', () => {
     }
 
     // Schedule some async updates
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting ||
-          flags.enableUnifiedSyncLane,
-      )
-    ) {
-      React.startTransition(() => {
-        instance.setState(createUpdate('a'));
-        instance.setState(createUpdate('b'));
-        instance.setState(createUpdate('c'));
-      });
-    } else {
+    React.startTransition(() => {
       instance.setState(createUpdate('a'));
       instance.setState(createUpdate('b'));
       instance.setState(createUpdate('c'));
-    }
+    });
 
     // Begin the updates but don't flush them yet
     await waitFor(['a', 'b', 'c']);
@@ -303,57 +243,22 @@ describe('ReactIncrementalUpdates', () => {
     });
 
     // The sync updates should have flushed, but not the async ones.
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting &&
-          flags.enableUnifiedSyncLane,
-      )
-    ) {
-      assertLog(['d', 'e', 'f']);
-    } else {
-      // Update d was dropped and replaced by e.
-      assertLog(['e', 'f']);
-    }
+    assertLog(['d', 'e', 'f']);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="f" />);
 
     // Now flush the remaining work. Even though e and f were already processed,
     // they should be processed again, to ensure that the terminal state
     // is deterministic.
-    if (
-      gate(
-        flags =>
-          !flags.forceConcurrentByDefaultForTesting &&
-          !flags.enableUnifiedSyncLane,
-      )
-    ) {
-      await waitForAll([
-        // Since 'g' is in a transition, we'll process 'd' separately first.
-        // That causes us to process 'd' with 'e' and 'f' rebased.
-        'd',
-        'e',
-        'f',
-        // Then we'll re-process everything for 'g'.
-        'a',
-        'b',
-        'c',
-        'd',
-        'e',
-        'f',
-        'g',
-      ]);
-    } else {
-      await waitForAll([
-        // Then we'll re-process everything for 'g'.
-        'a',
-        'b',
-        'c',
-        'd',
-        'e',
-        'f',
-        'g',
-      ]);
-    }
+    await waitForAll([
+      // Then we'll re-process everything for 'g'.
+      'a',
+      'b',
+      'c',
+      'd',
+      'e',
+      'f',
+      'g',
+    ]);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="fg" />);
   });
 
@@ -684,25 +589,7 @@ describe('ReactIncrementalUpdates', () => {
         pushToLog('B'),
       );
     });
-    if (gate(flags => flags.enableUnifiedSyncLane)) {
-      assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
-    } else {
-      assertLog([
-        // A and B are pending. B is higher priority, so we'll render that first.
-        'Committed: B',
-        // Because A comes first in the queue, we're now in rebase mode. B must
-        // be rebased on top of A. Also, in a layout effect, we received two new
-        // updates: C and D. C is user-blocking and D is synchronous.
-        //
-        // First render the synchronous update. What we're testing here is that
-        // B *is not dropped* even though it has lower than sync priority. That's
-        // because we already committed it. However, this render should not
-        // include C, because that update wasn't already committed.
-        'Committed: BD',
-        'Committed: BCD',
-        'Committed: ABCD',
-      ]);
-    }
+    assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
     expect(root).toMatchRenderedOutput('ABCD');
   });
 
@@ -744,25 +631,7 @@ describe('ReactIncrementalUpdates', () => {
         pushToLog('B'),
       );
     });
-    if (gate(flags => flags.enableUnifiedSyncLane)) {
-      assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
-    } else {
-      assertLog([
-        // A and B are pending. B is higher priority, so we'll render that first.
-        'Committed: B',
-        // Because A comes first in the queue, we're now in rebase mode. B must
-        // be rebased on top of A. Also, in a layout effect, we received two new
-        // updates: C and D. C is user-blocking and D is synchronous.
-        //
-        // First render the synchronous update. What we're testing here is that
-        // B *is not dropped* even though it has lower than sync priority. That's
-        // because we already committed it. However, this render should not
-        // include C, because that update wasn't already committed.
-        'Committed: BD',
-        'Committed: BCD',
-        'Committed: ABCD',
-      ]);
-    }
+    assertLog(['Committed: B', 'Committed: BCD', 'Committed: ABCD']);
     expect(root).toMatchRenderedOutput('ABCD');
   });
 

commit 6b865330f4bc6c87dcd2c8cdf665895c8a190fc1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jan 6 14:12:53 2025 -0500

    [assert helpers] react-reconciler (#31986)
    
    Based off: https://github.com/facebook/react/pull/31984

diff --git a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
index 4d4ab4f7c9..b7a2d6b661 100644
--- a/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactIncrementalUpdates-test.js
@@ -18,6 +18,7 @@ let act;
 let waitForAll;
 let waitFor;
 let assertLog;
+let assertConsoleErrorDev;
 
 describe('ReactIncrementalUpdates', () => {
   beforeEach(() => {
@@ -34,6 +35,7 @@ describe('ReactIncrementalUpdates', () => {
     waitForAll = InternalTestUtils.waitForAll;
     waitFor = InternalTestUtils.waitFor;
     assertLog = InternalTestUtils.assertLog;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
   });
 
   function Text({text}) {
@@ -366,20 +368,21 @@ describe('ReactIncrementalUpdates', () => {
       return {a: 'a'};
     });
 
-    await expect(
-      async () =>
-        await waitForAll([
-          'setState updater',
-          // Updates in the render phase receive the currently rendering
-          // lane, so the update flushes immediately in the same render.
-          'render',
-        ]),
-    ).toErrorDev(
+    await waitForAll([
+      'setState updater',
+      // Updates in the render phase receive the currently rendering
+      // lane, so the update flushes immediately in the same render.
+      'render',
+    ]);
+    assertConsoleErrorDev([
       'An update (setState, replaceState, or forceUpdate) was scheduled ' +
         'from inside an update function. Update functions should be pure, ' +
         'with zero side-effects. Consider using componentDidUpdate or a ' +
-        'callback.\n\nPlease update the following component: Foo',
-    );
+        'callback.\n' +
+        '\n' +
+        'Please update the following component: Foo\n' +
+        '    in Foo (at **)',
+    ]);
     expect(instance.state).toEqual({a: 'a', b: 'b'});
 
     // Test deduplication (no additional warnings expected)

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    