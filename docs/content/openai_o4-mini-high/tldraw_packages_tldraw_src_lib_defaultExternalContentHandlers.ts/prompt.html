<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/tldraw/src/lib/defaultExternalContentHandlers.ts - o4-mini-high</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/tldraw/src/lib/defaultExternalContentHandlers.ts</h1>
        <p><a href="../../../cases/openai_o4-mini-high/tldraw_packages_tldraw_src_lib_defaultExternalContentHandlers.ts.html">← Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/defaultExternalContentHandlers.ts

commit 3bc79260d8756af71d2877cb408b848bbf112108
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Sep 6 11:07:18 2023 +0100

    [fix] assets and content handlers (#1846)
    
    This PR fixes a bug where external content handlers etc defined in an
    `onMount` were being overwritten by the default external content
    handlers.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Try adding images to rooms in our dot com staging environement
    (sorry).

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
new file mode 100644
index 000000000..2f5ddf3c6
--- /dev/null
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -0,0 +1,473 @@
+import {
+	AssetRecordType,
+	Editor,
+	MediaHelpers,
+	TLAsset,
+	TLAssetId,
+	TLEmbedShape,
+	TLShapePartial,
+	TLTextShape,
+	TLTextShapeProps,
+	Vec2d,
+	VecLike,
+	compact,
+	createShapeId,
+	getHashForString,
+} from '@tldraw/editor'
+import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
+import { containBoxSize, getResizedImageDataUrl, isGifAnimated } from './utils/assets'
+import { getEmbedInfo } from './utils/embeds'
+import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text'
+
+/** @public */
+export type TLExternalContentProps = {
+	// The maximum dimension (width or height) of an image. Images larger than this will be rescaled to fit. Defaults to infinity.
+	maxImageDimension: number
+	// The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).
+	maxAssetSize: number
+	// The mime types of images that are allowed to be handled. Defaults to ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'].
+	acceptedImageMimeTypes: string[]
+	// The mime types of videos that are allowed to be handled. Defaults to ['video/mp4', 'video/webm', 'video/quicktime'].
+	acceptedVideoMimeTypes: string[]
+}
+
+export function registerDefaultExternalContentHandlers(
+	editor: Editor,
+	{
+		maxImageDimension,
+		maxAssetSize,
+		acceptedImageMimeTypes,
+		acceptedVideoMimeTypes,
+	}: TLExternalContentProps
+) {
+	// files -> asset
+	editor.registerExternalAssetHandler('file', async ({ file }) => {
+		return await new Promise((resolve, reject) => {
+			if (
+				!acceptedImageMimeTypes.includes(file.type) &&
+				!acceptedVideoMimeTypes.includes(file.type)
+			) {
+				console.warn(`File type not allowed: ${file.type}`)
+				reject()
+			}
+
+			if (file.size > maxAssetSize) {
+				console.warn(
+					`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
+						maxAssetSize / 1024
+					).toFixed()}kb`
+				)
+				reject()
+			}
+
+			const reader = new FileReader()
+			reader.onerror = () => reject(reader.error)
+			reader.onload = async () => {
+				let dataUrl = reader.result as string
+
+				// Hack to make .mov videos work via dataURL.
+				if (file.type === 'video/quicktime' && dataUrl.includes('video/quicktime')) {
+					dataUrl = dataUrl.replace('video/quicktime', 'video/mp4')
+				}
+
+				const isImageType = acceptedImageMimeTypes.includes(file.type)
+
+				let size: {
+					w: number
+					h: number
+				}
+				let isAnimated: boolean
+
+				if (isImageType) {
+					size = await MediaHelpers.getImageSizeFromSrc(dataUrl)
+					isAnimated = file.type === 'image/gif' && (await isGifAnimated(file))
+				} else {
+					isAnimated = true
+					size = await MediaHelpers.getVideoSizeFromSrc(dataUrl)
+				}
+
+				if (isFinite(maxImageDimension)) {
+					const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
+					if (size !== resizedSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
+						// If we created a new size and the type is an image, rescale the image
+						dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h)
+					}
+					size = resizedSize
+				}
+
+				const assetId: TLAssetId = AssetRecordType.createId(getHashForString(dataUrl))
+
+				const asset = AssetRecordType.create({
+					id: assetId,
+					type: isImageType ? 'image' : 'video',
+					typeName: 'asset',
+					props: {
+						name: file.name,
+						src: dataUrl,
+						w: size.w,
+						h: size.h,
+						mimeType: file.type,
+						isAnimated,
+					},
+				})
+
+				resolve(asset)
+			}
+
+			reader.readAsDataURL(file)
+		})
+	})
+
+	// urls -> bookmark asset
+	editor.registerExternalAssetHandler('url', async ({ url }) => {
+		let meta: { image: string; title: string; description: string }
+
+		try {
+			const resp = await fetch(url, { method: 'GET', mode: 'no-cors' })
+			const html = await resp.text()
+			const doc = new DOMParser().parseFromString(html, 'text/html')
+			meta = {
+				image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute('content') ?? '',
+				title:
+					doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ??
+					truncateStringWithEllipsis(url, 32),
+				description:
+					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
+			}
+		} catch (error) {
+			console.error(error)
+			meta = { image: '', title: truncateStringWithEllipsis(url, 32), description: '' }
+		}
+
+		// Create the bookmark asset from the meta
+		return {
+			id: AssetRecordType.createId(getHashForString(url)),
+			typeName: 'asset',
+			type: 'bookmark',
+			props: {
+				src: url,
+				description: meta.description,
+				image: meta.image,
+				title: meta.title,
+			},
+			meta: {},
+		}
+	})
+
+	// svg text
+	editor.registerExternalContentHandler('svg-text', async ({ point, text }) => {
+		const position =
+			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+
+		const svg = new DOMParser().parseFromString(text, 'image/svg+xml').querySelector('svg')
+		if (!svg) {
+			throw new Error('No <svg/> element present')
+		}
+
+		let width = parseFloat(svg.getAttribute('width') || '0')
+		let height = parseFloat(svg.getAttribute('height') || '0')
+
+		if (!(width && height)) {
+			document.body.appendChild(svg)
+			const box = svg.getBoundingClientRect()
+			document.body.removeChild(svg)
+
+			width = box.width
+			height = box.height
+		}
+
+		const asset = await editor.getAssetForExternalContent({
+			type: 'file',
+			file: new File([text], 'asset.svg', { type: 'image/svg+xml' }),
+		})
+
+		if (!asset) throw Error('Could not create an asset')
+
+		createShapesForAssets(editor, [asset], position)
+	})
+
+	// embeds
+	editor.registerExternalContentHandler('embed', ({ point, url, embed }) => {
+		const position =
+			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+
+		const { width, height } = embed
+
+		const id = createShapeId()
+
+		const shapePartial: TLShapePartial<TLEmbedShape> = {
+			id,
+			type: 'embed',
+			x: position.x - (width || 450) / 2,
+			y: position.y - (height || 450) / 2,
+			props: {
+				w: width,
+				h: height,
+				url,
+			},
+		}
+
+		editor.createShapes([shapePartial]).select(id)
+	})
+
+	// files
+	editor.registerExternalContentHandler('files', async ({ point, files }) => {
+		const position =
+			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+
+		const pagePoint = new Vec2d(position.x, position.y)
+
+		const assets: TLAsset[] = []
+
+		await Promise.all(
+			files.map(async (file, i) => {
+				if (file.size > maxAssetSize) {
+					console.warn(
+						`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
+							maxAssetSize / 1024
+						).toFixed()}kb`
+					)
+					return null
+				}
+
+				// Use mime type instead of file ext, this is because
+				// window.navigator.clipboard does not preserve file names
+				// of copied files.
+				if (!file.type) {
+					throw new Error('No mime type')
+				}
+
+				// We can only accept certain extensions (either images or a videos)
+				if (!acceptedImageMimeTypes.concat(acceptedVideoMimeTypes).includes(file.type)) {
+					console.warn(`${file.name} not loaded - Extension not allowed.`)
+					return null
+				}
+
+				try {
+					const asset = await editor.getAssetForExternalContent({ type: 'file', file })
+
+					if (!asset) {
+						throw Error('Could not create an asset')
+					}
+
+					assets[i] = asset
+				} catch (error) {
+					console.error(error)
+					return null
+				}
+			})
+		)
+
+		createShapesForAssets(editor, compact(assets), pagePoint)
+	})
+
+	// text
+	editor.registerExternalContentHandler('text', async ({ point, text }) => {
+		const p =
+			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+
+		const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
+
+		const textToPaste = cleanupText(text)
+
+		// Measure the text with default values
+		let w: number
+		let h: number
+		let autoSize: boolean
+		let align = 'middle' as TLTextShapeProps['align']
+
+		const isMultiLine = textToPaste.split('\n').length > 1
+
+		// check whether the text contains the most common characters in RTL languages
+		const isRtl = isRightToLeftLanguage(textToPaste)
+
+		if (isMultiLine) {
+			align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
+		}
+
+		const rawSize = editor.textMeasure.measureText(textToPaste, {
+			...TEXT_PROPS,
+			fontFamily: FONT_FAMILIES[defaultProps.font],
+			fontSize: FONT_SIZES[defaultProps.size],
+			width: 'fit-content',
+		})
+
+		const minWidth = Math.min(
+			isMultiLine ? editor.viewportPageBounds.width * 0.9 : 920,
+			Math.max(200, editor.viewportPageBounds.width * 0.9)
+		)
+
+		if (rawSize.w > minWidth) {
+			const shrunkSize = editor.textMeasure.measureText(textToPaste, {
+				...TEXT_PROPS,
+				fontFamily: FONT_FAMILIES[defaultProps.font],
+				fontSize: FONT_SIZES[defaultProps.size],
+				width: minWidth + 'px',
+			})
+			w = shrunkSize.w
+			h = shrunkSize.h
+			autoSize = false
+			align = isRtl ? 'end' : 'start'
+		} else {
+			// autosize is fine
+			w = rawSize.w
+			h = rawSize.h
+			autoSize = true
+		}
+
+		if (p.y - h / 2 < editor.viewportPageBounds.minY + 40) {
+			p.y = editor.viewportPageBounds.minY + 40 + h / 2
+		}
+
+		editor.createShapes<TLTextShape>([
+			{
+				id: createShapeId(),
+				type: 'text',
+				x: p.x - w / 2,
+				y: p.y - h / 2,
+				props: {
+					text: textToPaste,
+					// if the text has more than one line, align it to the left
+					align,
+					autoSize,
+					w,
+				},
+			},
+		])
+	})
+
+	// url
+	editor.registerExternalContentHandler('url', async ({ point, url }) => {
+		// try to paste as an embed first
+		const embedInfo = getEmbedInfo(url)
+
+		if (embedInfo) {
+			return editor.putExternalContent({
+				type: 'embed',
+				url: embedInfo.url,
+				point,
+				embed: embedInfo.definition,
+			})
+		}
+
+		const position =
+			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+
+		const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
+
+		// Use an existing asset if we have one, or else else create a new one
+		let asset = editor.getAsset(assetId) as TLAsset
+		let shouldAlsoCreateAsset = false
+		if (!asset) {
+			shouldAlsoCreateAsset = true
+			const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
+			if (!bookmarkAsset) throw Error('Could not create an asset')
+			asset = bookmarkAsset
+		}
+
+		editor.batch(() => {
+			if (shouldAlsoCreateAsset) {
+				editor.createAssets([asset])
+			}
+
+			createShapesForAssets(editor, [asset], position)
+		})
+	})
+}
+
+export async function createShapesForAssets(editor: Editor, assets: TLAsset[], position: VecLike) {
+	if (!assets.length) return
+
+	const currentPoint = Vec2d.From(position)
+	const paritals: TLShapePartial[] = []
+
+	for (const asset of assets) {
+		switch (asset.type) {
+			case 'bookmark': {
+				paritals.push({
+					id: createShapeId(),
+					type: 'bookmark',
+					x: currentPoint.x - 150,
+					y: currentPoint.y - 160,
+					opacity: 1,
+					props: {
+						assetId: asset.id,
+						url: asset.props.src,
+					},
+				})
+
+				currentPoint.x += 300
+				break
+			}
+			case 'image': {
+				paritals.push({
+					id: createShapeId(),
+					type: 'image',
+					x: currentPoint.x - asset.props.w / 2,
+					y: currentPoint.y - asset.props.h / 2,
+					opacity: 1,
+					props: {
+						assetId: asset.id,
+						w: asset.props.w,
+						h: asset.props.h,
+					},
+				})
+
+				currentPoint.x += asset.props.w
+				break
+			}
+			case 'video': {
+				paritals.push({
+					id: createShapeId(),
+					type: 'video',
+					x: currentPoint.x - asset.props.w / 2,
+					y: currentPoint.y - asset.props.h / 2,
+					opacity: 1,
+					props: {
+						assetId: asset.id,
+						w: asset.props.w,
+						h: asset.props.h,
+					},
+				})
+
+				currentPoint.x += asset.props.w
+			}
+		}
+	}
+
+	editor.batch(() => {
+		// Create any assets
+		const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id))
+		if (assetsToCreate.length) {
+			editor.createAssets(assetsToCreate)
+		}
+
+		// Create the shapes
+		editor.createShapes(paritals).select(...paritals.map((p) => p.id))
+
+		// Re-position shapes so that the center of the group is at the provided point
+		const { viewportPageBounds } = editor
+		let { selectionPageBounds } = editor
+
+		if (selectionPageBounds) {
+			const offset = selectionPageBounds!.center.sub(position)
+
+			editor.updateShapes(
+				paritals.map((partial) => {
+					return {
+						id: partial.id,
+						type: partial.type,
+						x: partial.x! - offset.x,
+						y: partial.y! - offset.y,
+					}
+				})
+			)
+		}
+
+		// Zoom out to fit the shapes, if necessary
+		selectionPageBounds = editor.selectionPageBounds
+		if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
+			editor.zoomToSelection()
+		}
+	})
+}

commit ac593b2ac2a3e78aeecb8419da3a687cfa59de48
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Sep 8 09:26:55 2023 +0100

    Fix paste transform (#1859)
    
    This PR fixes a bug where pasted content would be placed incorrectly if
    pasted into a parent frame.
    
    Closes #1857
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Fixes a bug affecting the position of pasted content inside frames.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 2f5ddf3c6..d10c51afd 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -379,12 +379,12 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 	if (!assets.length) return
 
 	const currentPoint = Vec2d.From(position)
-	const paritals: TLShapePartial[] = []
+	const partials: TLShapePartial[] = []
 
 	for (const asset of assets) {
 		switch (asset.type) {
 			case 'bookmark': {
-				paritals.push({
+				partials.push({
 					id: createShapeId(),
 					type: 'bookmark',
 					x: currentPoint.x - 150,
@@ -400,7 +400,7 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 				break
 			}
 			case 'image': {
-				paritals.push({
+				partials.push({
 					id: createShapeId(),
 					type: 'image',
 					x: currentPoint.x - asset.props.w / 2,
@@ -417,7 +417,7 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 				break
 			}
 			case 'video': {
-				paritals.push({
+				partials.push({
 					id: createShapeId(),
 					type: 'video',
 					x: currentPoint.x - asset.props.w / 2,
@@ -443,7 +443,7 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 		}
 
 		// Create the shapes
-		editor.createShapes(paritals).select(...paritals.map((p) => p.id))
+		editor.createShapes(partials).select(...partials.map((p) => p.id))
 
 		// Re-position shapes so that the center of the group is at the provided point
 		const { viewportPageBounds } = editor
@@ -453,12 +453,14 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 			const offset = selectionPageBounds!.center.sub(position)
 
 			editor.updateShapes(
-				paritals.map((partial) => {
+				editor.selectedShapes.map((shape) => {
+					const localRotation = editor.getShapeParentTransform(shape).decompose().rotation
+					const localDelta = Vec2d.Rot(offset, -localRotation)
 					return {
-						id: partial.id,
-						type: partial.type,
-						x: partial.x! - offset.x,
-						y: partial.y! - offset.y,
+						id: shape.id,
+						type: shape.type,
+						x: shape.x! - localDelta.x,
+						y: shape.y! - localDelta.y,
 					}
 				})
 			)

commit f73bf9a7fea4ca6922b8effa10412fbb9f77c288
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Oct 2 12:30:53 2023 +0100

    Fix text-wrapping on Safari (#1980)
    
    Co-authored-by: Alex Alex@dytry.ch
    
    closes [#1978](https://github.com/tldraw/tldraw/issues/1978)
    
    Text was wrapping on Safari because the measure text div was rendered
    differently on different browsers. Interestingly, when forcing the
    text-measure div to be visible and on-screen in Chrome, the same
    text-wrapping behaviour was apparent. By setting white-space to 'pre'
    when width hasn't been set by the user, we can ensure that only line
    breaks the user has inputted are rendered by default on all browsers.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. On Safari
    2. Make a new text shape and start typing
    3. At a certain point the text starts to wrap without the width having
    been set
    
    
    ### Release Notes
    
    - Fix text wrapping differently on Safari and Chrome/Firefox
    
    Before/After
    
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/320171b4-61e0-4a41-b8d3-830bd90bea65">
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/b42d7156-0ce9-4894-9692-9338dc931b79">

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index d10c51afd..b47e86263 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -289,7 +289,7 @@ export function registerDefaultExternalContentHandlers(
 			...TEXT_PROPS,
 			fontFamily: FONT_FAMILIES[defaultProps.font],
 			fontSize: FONT_SIZES[defaultProps.size],
-			width: 'fit-content',
+			width: null,
 		})
 
 		const minWidth = Math.min(
@@ -302,7 +302,7 @@ export function registerDefaultExternalContentHandlers(
 				...TEXT_PROPS,
 				fontFamily: FONT_FAMILIES[defaultProps.font],
 				fontSize: FONT_SIZES[defaultProps.size],
-				width: minWidth + 'px',
+				width: minWidth,
 			})
 			w = shrunkSize.w
 			h = shrunkSize.h

commit 92886e1f40670018589d2c14dced119e47f8e6d1
Author: alex <alex@dytry.ch>
Date:   Tue Oct 3 15:26:13 2023 +0100

    fix text in geo shapes not causing its container to grow (#2003)
    
    We got things sliggghhhtly wrong in #1980. That diff was attempting to
    fix a bug where the text measurement element would refuse to go above
    the viewport size in safari. This was most obvious in the case where
    there was no fixed width on a text shape, and that diff fixed that case,
    but it was also happening when a fixed width text shape was wider than
    viewport - which wasn't covered by that fix. It turned out that that fix
    also introduced a bug where shapes would no longer grow along the y-axis
    - in part because the relationship between `width`, `maxWidth`, and
    `minWidth` is very confusing.
    
    The one-liner fix is to just use `max-content` instead of `fit-content`
    - that way, the div ignores the size of its container. But I also
    cleared up the API for text measurement to remove the `width` property
    entirely in favour of `maxWidth`. I think this makes things much clearer
    and as far as I can tell doesn't affect anything.
    
    Closes #1998
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create an arrow & geo shape with labels, plus a note and text shape
    2. Try to break text measurement - overflow the bounds, make very wide
    text, experiment with fixed/auto-size text, etc.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index b47e86263..c267379da 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -289,7 +289,7 @@ export function registerDefaultExternalContentHandlers(
 			...TEXT_PROPS,
 			fontFamily: FONT_FAMILIES[defaultProps.font],
 			fontSize: FONT_SIZES[defaultProps.size],
-			width: null,
+			maxWidth: null,
 		})
 
 		const minWidth = Math.min(
@@ -302,7 +302,7 @@ export function registerDefaultExternalContentHandlers(
 				...TEXT_PROPS,
 				fontFamily: FONT_FAMILIES[defaultProps.font],
 				fontSize: FONT_SIZES[defaultProps.size],
-				width: minWidth,
+				maxWidth: minWidth,
 			})
 			w = shrunkSize.w
 			h = shrunkSize.h

commit 133b8fbdc033b965b3ce9e6102c05b7d96f533d6
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Nov 8 11:08:03 2023 +0000

    instant bookmarks (#2176)
    
    this PR does a couple of things when creating bookmarks
    
    - any time a url was pasted it was previously calling `fetch` on the url
    to check whether the url is an image that we have cors access to. In
    that case we can paste the image itself rather than a bookmark. But
    that's gonna be a relatively rare use case, and the check itself seemed
    to cost anywhere from 200ms to +1s which is certainly not worth it when
    the fallback behaviour (create a regular bookmark) is fine. So i moved
    that check behind a url pathname extension check. i.e. if the url
    pathname ends with .gif, .jpg, .jpeg, .svg, or .png, then it will check
    whether we can paste the image directly, otherwise it will always do a
    regular bookmark.
    - we create an asset-less bookmark shape on the canvas while we wait for
    the asset to load if it is not already available. This means the user
    gets immediate feedback that their paste succeeded, but they won't see
    the actual bookmark details for a little bit.
    
    It looks like this
    
    ![Kapture 2023-11-08 at 10 34
    35](https://github.com/tldraw/tldraw/assets/1242537/89c93612-a794-419f-aa68-1efdb82bfbf2)
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    
    ### Release Notes
    
    - Improves ux around pasting bookmarks

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index c267379da..214809ded 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -4,7 +4,9 @@ import {
 	MediaHelpers,
 	TLAsset,
 	TLAssetId,
+	TLBookmarkShape,
 	TLEmbedShape,
+	TLShapeId,
 	TLShapePartial,
 	TLTextShape,
 	TLTextShapeProps,
@@ -354,6 +356,7 @@ export function registerDefaultExternalContentHandlers(
 			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
 
 		const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
+		const shape = createEmptyBookmarkShape(editor, url, position)
 
 		// Use an existing asset if we have one, or else else create a new one
 		let asset = editor.getAsset(assetId) as TLAsset
@@ -370,13 +373,25 @@ export function registerDefaultExternalContentHandlers(
 				editor.createAssets([asset])
 			}
 
-			createShapesForAssets(editor, [asset], position)
+			editor.updateShapes([
+				{
+					...shape,
+					props: {
+						...shape.props,
+						assetId: asset.id,
+					},
+				},
+			])
 		})
 	})
 }
 
-export async function createShapesForAssets(editor: Editor, assets: TLAsset[], position: VecLike) {
-	if (!assets.length) return
+export async function createShapesForAssets(
+	editor: Editor,
+	assets: TLAsset[],
+	position: VecLike
+): Promise<TLShapeId[]> {
+	if (!assets.length) return []
 
 	const currentPoint = Vec2d.From(position)
 	const partials: TLShapePartial[] = []
@@ -446,30 +461,62 @@ export async function createShapesForAssets(editor: Editor, assets: TLAsset[], p
 		editor.createShapes(partials).select(...partials.map((p) => p.id))
 
 		// Re-position shapes so that the center of the group is at the provided point
-		const { viewportPageBounds } = editor
-		let { selectionPageBounds } = editor
-
-		if (selectionPageBounds) {
-			const offset = selectionPageBounds!.center.sub(position)
-
-			editor.updateShapes(
-				editor.selectedShapes.map((shape) => {
-					const localRotation = editor.getShapeParentTransform(shape).decompose().rotation
-					const localDelta = Vec2d.Rot(offset, -localRotation)
-					return {
-						id: shape.id,
-						type: shape.type,
-						x: shape.x! - localDelta.x,
-						y: shape.y! - localDelta.y,
-					}
-				})
-			)
-		}
+		centerSelecitonAroundPoint(editor, position)
+	})
 
-		// Zoom out to fit the shapes, if necessary
-		selectionPageBounds = editor.selectionPageBounds
-		if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
-			editor.zoomToSelection()
-		}
+	return partials.map((p) => p.id)
+}
+
+function centerSelecitonAroundPoint(editor: Editor, position: VecLike) {
+	// Re-position shapes so that the center of the group is at the provided point
+	const { viewportPageBounds } = editor
+	let { selectionPageBounds } = editor
+
+	if (selectionPageBounds) {
+		const offset = selectionPageBounds!.center.sub(position)
+
+		editor.updateShapes(
+			editor.selectedShapes.map((shape) => {
+				const localRotation = editor.getShapeParentTransform(shape).decompose().rotation
+				const localDelta = Vec2d.Rot(offset, -localRotation)
+				return {
+					id: shape.id,
+					type: shape.type,
+					x: shape.x! - localDelta.x,
+					y: shape.y! - localDelta.y,
+				}
+			})
+		)
+	}
+
+	// Zoom out to fit the shapes, if necessary
+	selectionPageBounds = editor.selectionPageBounds
+	if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
+		editor.zoomToSelection()
+	}
+}
+
+export function createEmptyBookmarkShape(
+	editor: Editor,
+	url: string,
+	position: VecLike
+): TLBookmarkShape {
+	const partial: TLShapePartial = {
+		id: createShapeId(),
+		type: 'bookmark',
+		x: position.x - 150,
+		y: position.y - 160,
+		opacity: 1,
+		props: {
+			assetId: null,
+			url,
+		},
+	}
+
+	editor.batch(() => {
+		editor.createShapes([partial]).select(partial.id)
+		centerSelecitonAroundPoint(editor, position)
 	})
+
+	return editor.getShape(partial.id) as TLBookmarkShape
 }

commit 7ffda2335ce1c9b20e453436db438b08d03e9a87
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 14:31:27 2023 +0000

    No impure getters pt3 (#2203)
    
    Follow up to #2189 and #2202
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 214809ded..b3f900b8b 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -476,7 +476,7 @@ function centerSelecitonAroundPoint(editor: Editor, position: VecLike) {
 		const offset = selectionPageBounds!.center.sub(position)
 
 		editor.updateShapes(
-			editor.selectedShapes.map((shape) => {
+			editor.getSelectedShapes().map((shape) => {
 				const localRotation = editor.getShapeParentTransform(shape).decompose().rotation
 				const localDelta = Vec2d.Rot(offset, -localRotation)
 				return {

commit daf729d45c879d4e234d9417570149ad854f635b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 16:02:50 2023 +0000

    No impure getters pt4 (#2206)
    
    follow up to #2189 and #2203
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index b3f900b8b..285e9a9c1 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -461,16 +461,16 @@ export async function createShapesForAssets(
 		editor.createShapes(partials).select(...partials.map((p) => p.id))
 
 		// Re-position shapes so that the center of the group is at the provided point
-		centerSelecitonAroundPoint(editor, position)
+		centerSelectionAroundPoint(editor, position)
 	})
 
 	return partials.map((p) => p.id)
 }
 
-function centerSelecitonAroundPoint(editor: Editor, position: VecLike) {
+function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	// Re-position shapes so that the center of the group is at the provided point
 	const { viewportPageBounds } = editor
-	let { selectionPageBounds } = editor
+	let selectionPageBounds = editor.getSelectionPageBounds()
 
 	if (selectionPageBounds) {
 		const offset = selectionPageBounds!.center.sub(position)
@@ -490,7 +490,7 @@ function centerSelecitonAroundPoint(editor: Editor, position: VecLike) {
 	}
 
 	// Zoom out to fit the shapes, if necessary
-	selectionPageBounds = editor.selectionPageBounds
+	selectionPageBounds = editor.getSelectionPageBounds()
 	if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
 		editor.zoomToSelection()
 	}
@@ -515,7 +515,7 @@ export function createEmptyBookmarkShape(
 
 	editor.batch(() => {
 		editor.createShapes([partial]).select(partial.id)
-		centerSelecitonAroundPoint(editor, position)
+		centerSelectionAroundPoint(editor, position)
 	})
 
 	return editor.getShape(partial.id) as TLBookmarkShape

commit 65bdafa0babb113722ac629f6289270b17b9a07c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Nov 14 08:21:32 2023 +0000

    [fix] huge images, use downscale for image scaling (#2207)
    
    This PR improves our method for handling images, which is especially
    useful when using a local tldraw editor. Previously, we were only
    downsample images that were above the browser's maximum size. We now
    downsample all images. This will result in smaller images in almost all
    cases. It will also prevent very large jpeg images from being converted
    to png images, which could often lead to an increase in file size!
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Add some images (jpegs or pngs) to the canvas.
    
    ### Release Notes
    
    - Improved image rescaling.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 285e9a9c1..825d3cda4 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -91,10 +91,16 @@ export function registerDefaultExternalContentHandlers(
 				if (isFinite(maxImageDimension)) {
 					const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
 					if (size !== resizedSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
-						// If we created a new size and the type is an image, rescale the image
-						dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h)
+						size = resizedSize
 					}
-					size = resizedSize
+				}
+
+				// Always rescale the image
+				if (file.type === 'image/jpeg' || file.type === 'image/png') {
+					dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h, {
+						type: file.type,
+						quality: 0.92,
+					})
 				}
 
 				const assetId: TLAssetId = AssetRecordType.createId(getHashForString(dataUrl))

commit 898feb66506a107eec833ffd2e299777cde4c78d
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 10:33:43 2023 +0000

    don't overwrite bookmark position if it changed before metadata arrives (#2215)
    
    Fixes issue when creating new bookmark shape where the position would be
    reset if you moved it before the bookmark metadata was fetched
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Release Notes
    
    - Fixes issue when creating new bookmark shape where the position would
    be reset if you moved it before the bookmark metadata was fetched.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 825d3cda4..95313e39e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -381,9 +381,9 @@ export function registerDefaultExternalContentHandlers(
 
 			editor.updateShapes([
 				{
-					...shape,
+					id: shape.id,
+					type: shape.type,
 					props: {
-						...shape.props,
 						assetId: asset.id,
 					},
 				},

commit 6f872c796afd6cf538ce81d35c5a40dcccbe7013
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 11:57:43 2023 +0000

    No impure getters pt6 (#2218)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 95313e39e..1e55afe42 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -165,7 +165,8 @@ export function registerDefaultExternalContentHandlers(
 	// svg text
 	editor.registerExternalContentHandler('svg-text', async ({ point, text }) => {
 		const position =
-			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+			point ??
+			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
 		const svg = new DOMParser().parseFromString(text, 'image/svg+xml').querySelector('svg')
 		if (!svg) {
@@ -197,7 +198,8 @@ export function registerDefaultExternalContentHandlers(
 	// embeds
 	editor.registerExternalContentHandler('embed', ({ point, url, embed }) => {
 		const position =
-			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+			point ??
+			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
 		const { width, height } = embed
 
@@ -221,7 +223,8 @@ export function registerDefaultExternalContentHandlers(
 	// files
 	editor.registerExternalContentHandler('files', async ({ point, files }) => {
 		const position =
-			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+			point ??
+			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
 		const pagePoint = new Vec2d(position.x, position.y)
 
@@ -272,7 +275,8 @@ export function registerDefaultExternalContentHandlers(
 	// text
 	editor.registerExternalContentHandler('text', async ({ point, text }) => {
 		const p =
-			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+			point ??
+			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
 		const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
 
@@ -301,8 +305,8 @@ export function registerDefaultExternalContentHandlers(
 		})
 
 		const minWidth = Math.min(
-			isMultiLine ? editor.viewportPageBounds.width * 0.9 : 920,
-			Math.max(200, editor.viewportPageBounds.width * 0.9)
+			isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
+			Math.max(200, editor.getViewportPageBounds().width * 0.9)
 		)
 
 		if (rawSize.w > minWidth) {
@@ -323,8 +327,8 @@ export function registerDefaultExternalContentHandlers(
 			autoSize = true
 		}
 
-		if (p.y - h / 2 < editor.viewportPageBounds.minY + 40) {
-			p.y = editor.viewportPageBounds.minY + 40 + h / 2
+		if (p.y - h / 2 < editor.getViewportPageBounds().minY + 40) {
+			p.y = editor.getViewportPageBounds().minY + 40 + h / 2
 		}
 
 		editor.createShapes<TLTextShape>([
@@ -359,7 +363,8 @@ export function registerDefaultExternalContentHandlers(
 		}
 
 		const position =
-			point ?? (editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.viewportPageCenter)
+			point ??
+			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
 		const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
 		const shape = createEmptyBookmarkShape(editor, url, position)
@@ -475,7 +480,7 @@ export async function createShapesForAssets(
 
 function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	// Re-position shapes so that the center of the group is at the provided point
-	const { viewportPageBounds } = editor
+	const viewportPageBounds = editor.getViewportPageBounds()
 	let selectionPageBounds = editor.getSelectionPageBounds()
 
 	if (selectionPageBounds) {

commit 14e8d19a713fb21c3f976a15cdbdf0dd05167366
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Nov 15 18:06:02 2023 +0000

    Custom Tools DX + screenshot example (#2198)
    
    This PR adds a custom tool example, the `Screenshot Tool`.
    
    It demonstrates how a user can create a custom tool together with custom
    tool UI.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Use the screenshot example
    
    ### Release Notes
    
    - adds ScreenshotTool custom tool example
    - improvements and new exports related to copying and exporting images /
    files
    - loosens up types around icons and translations
    - moving `StateNode.isActive` into an atom
    - adding `Editor.path`

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 1e55afe42..c5b519f99 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -17,9 +17,9 @@ import {
 	getHashForString,
 } from '@tldraw/editor'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
-import { containBoxSize, getResizedImageDataUrl, isGifAnimated } from './utils/assets'
-import { getEmbedInfo } from './utils/embeds'
-import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text'
+import { containBoxSize, getResizedImageDataUrl, isGifAnimated } from './utils/assets/assets'
+import { getEmbedInfo } from './utils/embeds/embeds'
+import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
 
 /** @public */
 export type TLExternalContentProps = {

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index c5b519f99..6947aba2f 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -10,7 +10,7 @@ import {
 	TLShapePartial,
 	TLTextShape,
 	TLTextShapeProps,
-	Vec2d,
+	Vec,
 	VecLike,
 	compact,
 	createShapeId,
@@ -226,7 +226,7 @@ export function registerDefaultExternalContentHandlers(
 			point ??
 			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
 
-		const pagePoint = new Vec2d(position.x, position.y)
+		const pagePoint = new Vec(position.x, position.y)
 
 		const assets: TLAsset[] = []
 
@@ -404,7 +404,7 @@ export async function createShapesForAssets(
 ): Promise<TLShapeId[]> {
 	if (!assets.length) return []
 
-	const currentPoint = Vec2d.From(position)
+	const currentPoint = Vec.From(position)
 	const partials: TLShapePartial[] = []
 
 	for (const asset of assets) {
@@ -489,7 +489,7 @@ function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 		editor.updateShapes(
 			editor.getSelectedShapes().map((shape) => {
 				const localRotation = editor.getShapeParentTransform(shape).decompose().rotation
-				const localDelta = Vec2d.Rot(offset, -localRotation)
+				const localDelta = Vec.Rot(offset, -localRotation)
 				return {
 					id: shape.id,
 					type: shape.type,

commit 3c1aee492a4ba6acf10620b70445af291f7dc6b6
Author: alex <alex@dytry.ch>
Date:   Wed Jan 10 14:41:18 2024 +0000

    faster image processing in default asset handler (#2441)
    
    ![Kapture 2024-01-10 at 13 42
    06](https://github.com/tldraw/tldraw/assets/1489520/616bcda7-c05b-46f1-b985-3a36bb5c9476)
    (gif is with 6x CPU throttling to make the effect more visible)
    
    This is the first of a few diffs I'm working on to make dropping images
    onto the canvas feel a lot faster.
    
    There are three main changes here:
    1. We operate on `Blob`s and `File`s rather than data urls. This saves a
    fair bit on converting to/from base64 all the time. I've updated our
    `MediaHelper` APIs to encourage the same in consumers.
    2. We only check the max canvas size (slow) if images are above a
    certain dimension that we consider "safe" (8k x 8k)
    3. Switching from the `downscale` npm library to canvas native
    downscaling. that library claims to give better results than the
    browser, but hasn't been updated in ~7 years. in modern browsers, we can
    opt-in to native high-quality image smoothing to achieve similar results
    much faster than with an algorithm implemented in pure JS.
    
    I want to follow this up with a system to show image placeholders whilst
    we're waiting for long-running operations like resizing etc but i'm
    going to split that out into its own diff as it'll involve some fairly
    complex changes to the history management API.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Tested manually, unit tests & end-to-end tests pass

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 6947aba2f..ba6b4f427 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -12,12 +12,14 @@ import {
 	TLTextShapeProps,
 	Vec,
 	VecLike,
+	assert,
 	compact,
 	createShapeId,
+	getHashForBuffer,
 	getHashForString,
 } from '@tldraw/editor'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
-import { containBoxSize, getResizedImageDataUrl, isGifAnimated } from './utils/assets/assets'
+import { containBoxSize, downsizeImage, isGifAnimated } from './utils/assets/assets'
 import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
 
@@ -43,87 +45,63 @@ export function registerDefaultExternalContentHandlers(
 	}: TLExternalContentProps
 ) {
 	// files -> asset
-	editor.registerExternalAssetHandler('file', async ({ file }) => {
-		return await new Promise((resolve, reject) => {
-			if (
-				!acceptedImageMimeTypes.includes(file.type) &&
-				!acceptedVideoMimeTypes.includes(file.type)
-			) {
-				console.warn(`File type not allowed: ${file.type}`)
-				reject()
-			}
-
-			if (file.size > maxAssetSize) {
-				console.warn(
-					`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
-						maxAssetSize / 1024
-					).toFixed()}kb`
-				)
-				reject()
-			}
-
-			const reader = new FileReader()
-			reader.onerror = () => reject(reader.error)
-			reader.onload = async () => {
-				let dataUrl = reader.result as string
-
-				// Hack to make .mov videos work via dataURL.
-				if (file.type === 'video/quicktime' && dataUrl.includes('video/quicktime')) {
-					dataUrl = dataUrl.replace('video/quicktime', 'video/mp4')
-				}
+	editor.registerExternalAssetHandler('file', async ({ file: _file }) => {
+		const name = _file.name
+		let file: Blob = _file
+		const isImageType = acceptedImageMimeTypes.includes(file.type)
+		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
+
+		assert(isImageType || isVideoType, `File type not allowed: ${file.type}`)
+		assert(
+			file.size <= maxAssetSize,
+			`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
+		)
 
-				const isImageType = acceptedImageMimeTypes.includes(file.type)
+		if (file.type === 'video/quicktime') {
+			// hack to make .mov videos work
+			file = new Blob([file], { type: 'video/mp4' })
+		}
 
-				let size: {
-					w: number
-					h: number
-				}
-				let isAnimated: boolean
-
-				if (isImageType) {
-					size = await MediaHelpers.getImageSizeFromSrc(dataUrl)
-					isAnimated = file.type === 'image/gif' && (await isGifAnimated(file))
-				} else {
-					isAnimated = true
-					size = await MediaHelpers.getVideoSizeFromSrc(dataUrl)
-				}
+		let size = isImageType
+			? await MediaHelpers.getImageSize(file)
+			: await MediaHelpers.getVideoSize(file)
 
-				if (isFinite(maxImageDimension)) {
-					const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
-					if (size !== resizedSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
-						size = resizedSize
-					}
-				}
+		const isAnimated = file.type === 'image/gif' ? await isGifAnimated(file) : isVideoType
 
-				// Always rescale the image
-				if (file.type === 'image/jpeg' || file.type === 'image/png') {
-					dataUrl = await getResizedImageDataUrl(dataUrl, size.w, size.h, {
-						type: file.type,
-						quality: 0.92,
-					})
-				}
+		const hash = await getHashForBuffer(await file.arrayBuffer())
 
-				const assetId: TLAssetId = AssetRecordType.createId(getHashForString(dataUrl))
+		if (isFinite(maxImageDimension)) {
+			const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
+			if (size !== resizedSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
+				size = resizedSize
+			}
+		}
 
-				const asset = AssetRecordType.create({
-					id: assetId,
-					type: isImageType ? 'image' : 'video',
-					typeName: 'asset',
-					props: {
-						name: file.name,
-						src: dataUrl,
-						w: size.w,
-						h: size.h,
-						mimeType: file.type,
-						isAnimated,
-					},
-				})
+		// Always rescale the image
+		if (file.type === 'image/jpeg' || file.type === 'image/png') {
+			file = await downsizeImage(file, size.w, size.h, {
+				type: file.type,
+				quality: 0.92,
+			})
+		}
 
-				resolve(asset)
-			}
+		const assetId: TLAssetId = AssetRecordType.createId(hash)
 
-			reader.readAsDataURL(file)
+		const asset = AssetRecordType.create({
+			id: assetId,
+			type: isImageType ? 'image' : 'video',
+			typeName: 'asset',
+			props: {
+				name,
+				src: await MediaHelpers.blobToDataUrl(file),
+				w: size.w,
+				h: size.h,
+				mimeType: file.type,
+				isAnimated,
+			},
 		})
+
+		return asset
 	})
 
 	// urls -> bookmark asset

commit ac0259a6af0ede496f26041d552119a6e7dce41c
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Feb 15 12:10:09 2024 +0000

    Composable custom UI  (#2796)
    
    This PR refactors our menu systems and provides an interface to hide or
    replace individual user interface elements.
    
    # Background
    
    Previously, we've had two types of overrides:
    - "schema" overrides that would allow insertion or replacement of items
    in the different menus
    - "component" overrides that would replace components in the editor's
    user interface
    
    This PR is an attempt to unify the two and to provide for additional
    cases where the "schema-based" user interface had begun to break down.
    
    # Approach
    
    This PR makes no attempt to change the `actions` or `tools`
    overrides—the current system seems to be correct for those because they
    are not reactive. The challenge with the other ui schemas is that they
    _are_ reactive, and thus the overrides both need to a) be fed in from
    outside of the editor as props, and b) react to changes from the editor,
    which is an impossible situation.
    
    The new approach is to use React to declare menu items. (Surprise!)
    
    ```tsx
    function CustomHelpMenuContent() {
            return (
                    <>
                            <DefaultHelpMenuContent />
                            <TldrawUiMenuGroup id="custom stuff">
                                    <TldrawUiMenuItem
                                            id="about"
                                            label="Like my posts"
                                            icon="external-link"
                                            readonlyOk
                                            onSelect={() => {
                                                    window.open('https://x.com/tldraw', '_blank')
                                            }}
                                    />
                            </TldrawUiMenuGroup>
                    </>
            )
    }
    
    const components: TLComponents = {
            HelpMenuContent: CustomHelpMenuContent,
    }
    
    export default function CustomHelpMenuContentExample() {
            return (
                    <div className="tldraw__editor">
                            <Tldraw components={components} />
                    </div>
            )
    }
    ```
    
    We use a `components` prop with the combined editor and ui components.
    
    - [ ] Create a "layout" component?
    - [ ] Make UI components more isolated? If possible, they shouldn't
    depend on styles outside of themselves, so that they can be used in
    other layouts. Maybe we wait on this because I'm feeling a slippery
    slope toward presumptions about configurability.
    - [ ] OTOH maybe we go hard and consider these things as separate
    components, even packages, with their own interfaces for customizability
    / configurability, just go all the way with it, and see what that looks
    like.
    
    # Pros
    
    Top line: you can customize tldraw's user interface in a MUCH more
    granular / powerful way than before.
    
    It solves a case where menu items could not be made stateful from
    outside of the editor context, and provides the option to do things in
    the menus that we couldn't allow previously with the "schema-based"
    approach.
    
    It also may (who knows) be more performant because we can locate the
    state inside of the components for individual buttons and groups,
    instead of all at the top level above the "schema". Because items /
    groups decide their own state, we don't have to have big checks on how
    many items are selected, or whether we have a flippable state. Items and
    groups themselves are allowed to re-build as part of the regular React
    lifecycle. Menus aren't constantly being rebuilt, if that were ever an
    issue.
    
    Menu items can be shared between different menu types. We'll are
    sometimes able to re-use items between, for example, the menu and the
    context menu and the actions menu.
    
    Our overrides no longer mutate anything, so there's less weird searching
    and finding.
    
    # Cons
    
    This approach can make customization menu contents significantly more
    complex, as an end user would need to re-declare most of a menu in order
    to make any change to it. Luckily a user can add things to the top or
    bottom of the context menu fairly easily. (And who knows, folks may
    actually want to do deep customization, and this allows for it.)
    
    It's more code. We are shipping more react components, basically one for
    each menu item / group.
    
    Currently this PR does not export the subcomponents, i.e. menu items. If
    we do want to export these, then heaven help us, it's going to be a
    _lot_ of exports.
    
    # Progress
    
    - [x] Context menu
    - [x] Main menu
    - [x] Zoom menu
    - [x] Help menu
    - [x] Actions menu
    - [x] Keyboard shortcuts menu
    - [x] Quick actions in main menu? (new)
    - [x] Helper buttons? (new)
    - [x] Debug Menu
    
    And potentially
    - [x] Toolbar
    - [x] Style menu
    - [ ] Share zone
    - [x] Navigation zone
    - [ ] Other zones
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. use the context menu
    2. use the custom context menu example
    3. use cursor chat in the context menu
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index ba6b4f427..19acf59cf 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -30,9 +30,9 @@ export type TLExternalContentProps = {
 	// The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).
 	maxAssetSize: number
 	// The mime types of images that are allowed to be handled. Defaults to ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'].
-	acceptedImageMimeTypes: string[]
+	acceptedImageMimeTypes: readonly string[]
 	// The mime types of videos that are allowed to be handled. Defaults to ['video/mp4', 'video/webm', 'video/quicktime'].
-	acceptedVideoMimeTypes: string[]
+	acceptedVideoMimeTypes: readonly string[]
 }
 
 export function registerDefaultExternalContentHandlers(

commit 4639436aad2bcdfadd7998f1b9d805740762b6ca
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Feb 27 14:14:42 2024 +0000

    Show toast on upload error (#2959)
    
    A little toast for when image uploads fail. Solves #2944
    
    ![Kapture 2024-02-27 at 09 27
    12](https://github.com/tldraw/tldraw/assets/1242537/9e285622-8015-41fa-bc3d-92dccfaa7ba9)
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    
    ### Release Notes
    
    - Adds a quick toast to show when image uploads fail.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 19acf59cf..8fbb634fc 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -19,6 +19,8 @@ import {
 	getHashForString,
 } from '@tldraw/editor'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
+import { TLUiToastsContextType } from './ui/context/toasts'
+import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize, downsizeImage, isGifAnimated } from './utils/assets/assets'
 import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
@@ -42,7 +44,8 @@ export function registerDefaultExternalContentHandlers(
 		maxAssetSize,
 		acceptedImageMimeTypes,
 		acceptedVideoMimeTypes,
-	}: TLExternalContentProps
+	}: TLExternalContentProps,
+	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
 ) {
 	// files -> asset
 	editor.registerExternalAssetHandler('file', async ({ file: _file }) => {
@@ -122,6 +125,9 @@ export function registerDefaultExternalContentHandlers(
 			}
 		} catch (error) {
 			console.error(error)
+			toasts.addToast({
+				title: msg('assets.url.failed'),
+			})
 			meta = { image: '', title: truncateStringWithEllipsis(url, 32), description: '' }
 		}
 
@@ -241,6 +247,9 @@ export function registerDefaultExternalContentHandlers(
 
 					assets[i] = asset
 				} catch (error) {
+					toasts.addToast({
+						title: msg('assets.files.upload-failed'),
+					})
 					console.error(error)
 					return null
 				}
@@ -352,9 +361,16 @@ export function registerDefaultExternalContentHandlers(
 		let shouldAlsoCreateAsset = false
 		if (!asset) {
 			shouldAlsoCreateAsset = true
-			const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
-			if (!bookmarkAsset) throw Error('Could not create an asset')
-			asset = bookmarkAsset
+			try {
+				const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
+				if (!bookmarkAsset) throw Error('Could not create an asset')
+				asset = bookmarkAsset
+			} catch (e) {
+				toasts.addToast({
+					title: msg('assets.url.failed'),
+				})
+				return
+			}
 		}
 
 		editor.batch(() => {

commit 0a48aea7bb042ceaebf692e04cbdd0c97074d709
Author: alex <alex@dytry.ch>
Date:   Tue Mar 12 16:51:29 2024 +0000

    fixup file helpers (#3130)
    
    We had a couple regressions in #3110: first a missing `await` was
    causing fonts not to get properly embedded in exports. second, some
    `readAsText` calls were replaced with `readAsDataURL` calls.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 8fbb634fc..3d68610aa 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -1,6 +1,7 @@
 import {
 	AssetRecordType,
 	Editor,
+	FileHelpers,
 	MediaHelpers,
 	TLAsset,
 	TLAssetId,
@@ -96,7 +97,7 @@ export function registerDefaultExternalContentHandlers(
 			typeName: 'asset',
 			props: {
 				name,
-				src: await MediaHelpers.blobToDataUrl(file),
+				src: await FileHelpers.blobToDataUrl(file),
 				w: size.w,
 				h: size.h,
 				mimeType: file.type,

commit 6def201da2927847ef81c25bfcdaadf7b0b51b18
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Mar 27 09:41:13 2024 +0000

    ui: make toasts look more toasty (#2988)
    
    <img width="449" alt="Screenshot 2024-03-11 at 14 03 44"
    src="https://github.com/tldraw/tldraw/assets/469604/5b00dafc-abf1-44a3-b6c6-1d16db74b1be">
    
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Release Notes
    
    - UI: Add severity to toasts.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 3d68610aa..ba2ff614a 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -128,6 +128,7 @@ export function registerDefaultExternalContentHandlers(
 			console.error(error)
 			toasts.addToast({
 				title: msg('assets.url.failed'),
+				severity: 'error',
 			})
 			meta = { image: '', title: truncateStringWithEllipsis(url, 32), description: '' }
 		}
@@ -250,6 +251,7 @@ export function registerDefaultExternalContentHandlers(
 				} catch (error) {
 					toasts.addToast({
 						title: msg('assets.files.upload-failed'),
+						severity: 'error',
 					})
 					console.error(error)
 					return null
@@ -369,6 +371,7 @@ export function registerDefaultExternalContentHandlers(
 			} catch (e) {
 				toasts.addToast({
 					title: msg('assets.url.failed'),
+					severity: 'error',
 				})
 				return
 			}

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index ba2ff614a..d35def4c7 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -272,6 +272,22 @@ export function registerDefaultExternalContentHandlers(
 
 		const textToPaste = cleanupText(text)
 
+		// If we're pasting into a text shape, update the text.
+		const onlySelectedShape = editor.getOnlySelectedShape()
+		if (onlySelectedShape && 'text' in onlySelectedShape.props) {
+			editor.updateShapes([
+				{
+					id: onlySelectedShape.id,
+					type: onlySelectedShape.type,
+					props: {
+						text: textToPaste,
+					},
+				},
+			])
+
+			return
+		}
+
 		// Measure the text with default values
 		let w: number
 		let h: number

commit 5601d0ee22d34035f4ffe6244ec94901ca7be262
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Apr 29 11:58:15 2024 +0100

    Separate text-align property for shapes (#3627)
    
    This PR creates a new "text align" property for text shapes. Its default
    is left align.
    
    This means that text shapes now have their own alignment prop, separate
    from the vertical / horizontal alignment used in labels.
    
    The style panel for text has no visual change:
    
    <img width="400" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/aac80d2a-a069-4388-870b-1e0917d88eda">
    
    The style panel for labels has consistent icons for label position:
    
    <img width="487" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/0adf7f0e-8446-4d3e-b9ea-a61e43035207">
    
    Both may be configured separately.
    
    <img width="458" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/698dcfac-6eb2-4a8c-afb8-d1e5761019ef">
    
    
    # Icon refresh
    
    This PR also removes many unused icons.
    
    It adds a special toggle icon for the context menu.
    
    <img width="571" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/489551e6-a370-4528-9ad4-8f93e119f26b">
    <img width="492" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/cd3d77c7-8bae-4369-8b53-ca4685b2fd0e">
    
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `improvement` — Improving existing features
    
    ### Test Plan
    
    1. Load files.
    2. Paste excalidraw content.
    3. Load v1 files.
    4. Use the app as usual.
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Separates the text align property for text shapes and labels.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index d35def4c7..cfbf69883 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -292,7 +292,7 @@ export function registerDefaultExternalContentHandlers(
 		let w: number
 		let h: number
 		let autoSize: boolean
-		let align = 'middle' as TLTextShapeProps['align']
+		let align = 'middle' as TLTextShapeProps['textAlign']
 
 		const isMultiLine = textToPaste.split('\n').length > 1
 
@@ -346,7 +346,7 @@ export function registerDefaultExternalContentHandlers(
 				props: {
 					text: textToPaste,
 					// if the text has more than one line, align it to the left
-					align,
+					textAlign: align,
 					autoSize,
 					w,
 				},

commit fabba66c0f4b6c42ece30f409e70eb01e588f8e1
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat May 4 18:39:04 2024 +0100

    Camera options (#3282)
    
    This PR implements a camera options API.
    
    - [x] Initial PR
    - [x] Updated unit tests
    - [x] Feedback / review
    - [x] New unit tests
    - [x] Update use-case examples
    - [x] Ship?
    
    ## Public API
    
    A user can provide camera options to the `Tldraw` component via the
    `cameraOptions` prop. The prop is also available on the `TldrawEditor`
    component and the constructor parameters of the `Editor` class.
    
    ```tsx
    export default function CameraOptionsExample() {
            return (
                    <div className="tldraw__editor">
                            <Tldraw cameraOptions={CAMERA_OPTIONS} />
                    </div>
            )
    }
    ```
    
    At runtime, a user can:
    -  get the current camera options with `Editor.getCameraOptions`
    -  update the camera options with `Editor.setCameraOptions`
    
    Setting the camera options automatically applies them to the current
    camera.
    
    ```ts
    editor.setCameraOptions({...editor.getCameraOptions(), isLocked: true })
    ```
    
    A user can get the "camera fit zoom" via `editor.getCameraFitZoom()`.
    
    # Interface
    
    The camera options themselves can look a few different ways depending on
    the `type` provided.
    
    
    ```tsx
    export type TLCameraOptions = {
            /** Whether the camera is locked. */
            isLocked: boolean
            /** The speed of a scroll wheel / trackpad pan. Default is 1. */
            panSpeed: number
            /** The speed of a scroll wheel / trackpad zoom. Default is 1. */
            zoomSpeed: number
            /** The steps that a user can zoom between with zoom in / zoom out. The first and last value will determine the min and max zoom. */
            zoomSteps: number[]
            /** Controls whether the wheel pans or zooms.
             *
             * - `zoom`: The wheel will zoom in and out.
             * - `pan`: The wheel will pan the camera.
             * - `none`: The wheel will do nothing.
             */
            wheelBehavior: 'zoom' | 'pan' | 'none'
            /** The camera constraints. */
            constraints?: {
                    /** The bounds (in page space) of the constrained space */
                    bounds: BoxModel
                    /** The padding inside of the viewport (in screen space) */
                    padding: VecLike
                    /** The origin for placement. Used to position the bounds within the viewport when an axis is fixed or contained and zoom is below the axis fit. */
                    origin: VecLike
                    /** The camera's initial zoom, used also when the camera is reset.
                     *
                     * - `default`: Sets the initial zoom to 100%.
                     * - `fit-x`: The x axis will completely fill the viewport bounds.
                     * - `fit-y`: The y axis will completely fill the viewport bounds.
                     * - `fit-min`: The smaller axis will completely fill the viewport bounds.
                     * - `fit-max`: The larger axis will completely fill the viewport bounds.
                     * - `fit-x-100`: The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-y-100`: The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-min-100`: The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-max-100`: The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     */
                    initialZoom:
                            | 'fit-min'
                            | 'fit-max'
                            | 'fit-x'
                            | 'fit-y'
                            | 'fit-min-100'
                            | 'fit-max-100'
                            | 'fit-x-100'
                            | 'fit-y-100'
                            | 'default'
                    /** The camera's base for its zoom steps.
                     *
                     * - `default`: Sets the initial zoom to 100%.
                     * - `fit-x`: The x axis will completely fill the viewport bounds.
                     * - `fit-y`: The y axis will completely fill the viewport bounds.
                     * - `fit-min`: The smaller axis will completely fill the viewport bounds.
                     * - `fit-max`: The larger axis will completely fill the viewport bounds.
                     * - `fit-x-100`: The x axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-y-100`: The y axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-min-100`: The smaller axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     * - `fit-max-100`: The larger axis will completely fill the viewport bounds, or 100% zoom, whichever is smaller.
                     */
                    baseZoom:
                            | 'fit-min'
                            | 'fit-max'
                            | 'fit-x'
                            | 'fit-y'
                            | 'fit-min-100'
                            | 'fit-max-100'
                            | 'fit-x-100'
                            | 'fit-y-100'
                            | 'default'
                    /** The behavior for the constraints for both axes or each axis individually.
                     *
                     * - `free`: The bounds are ignored when moving the camera.
                     * - 'fixed': The bounds will be positioned within the viewport based on the origin
                     * - `contain`: The 'fixed' behavior will be used when the zoom is below the zoom level at which the bounds would fill the viewport; and when above this zoom, the bounds will use the 'inside' behavior.
                     * - `inside`: The bounds will stay completely within the viewport.
                     * - `outside`: The bounds will stay touching the viewport.
                     */
                    behavior:
                            | 'free'
                            | 'fixed'
                            | 'inside'
                            | 'outside'
                            | 'contain'
                            | {
                                            x: 'free' | 'fixed' | 'inside' | 'outside' | 'contain'
                                            y: 'free' | 'fixed' | 'inside' | 'outside' | 'contain'
                              }
            }
    }
    ```
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    These features combine in different ways, so we'll want to write some
    more tests to find surprises.
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - SDK: Adds camera options.
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index cfbf69883..647792061 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -152,7 +152,9 @@ export function registerDefaultExternalContentHandlers(
 	editor.registerExternalContentHandler('svg-text', async ({ point, text }) => {
 		const position =
 			point ??
-			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
+			(editor.inputs.shiftKey
+				? editor.inputs.currentPagePoint
+				: editor.getViewportPageBounds().center)
 
 		const svg = new DOMParser().parseFromString(text, 'image/svg+xml').querySelector('svg')
 		if (!svg) {
@@ -185,7 +187,9 @@ export function registerDefaultExternalContentHandlers(
 	editor.registerExternalContentHandler('embed', ({ point, url, embed }) => {
 		const position =
 			point ??
-			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
+			(editor.inputs.shiftKey
+				? editor.inputs.currentPagePoint
+				: editor.getViewportPageBounds().center)
 
 		const { width, height } = embed
 
@@ -210,7 +214,9 @@ export function registerDefaultExternalContentHandlers(
 	editor.registerExternalContentHandler('files', async ({ point, files }) => {
 		const position =
 			point ??
-			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
+			(editor.inputs.shiftKey
+				? editor.inputs.currentPagePoint
+				: editor.getViewportPageBounds().center)
 
 		const pagePoint = new Vec(position.x, position.y)
 
@@ -266,7 +272,9 @@ export function registerDefaultExternalContentHandlers(
 	editor.registerExternalContentHandler('text', async ({ point, text }) => {
 		const p =
 			point ??
-			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
+			(editor.inputs.shiftKey
+				? editor.inputs.currentPagePoint
+				: editor.getViewportPageBounds().center)
 
 		const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
 
@@ -370,7 +378,9 @@ export function registerDefaultExternalContentHandlers(
 
 		const position =
 			point ??
-			(editor.inputs.shiftKey ? editor.inputs.currentPagePoint : editor.getViewportPageCenter())
+			(editor.inputs.shiftKey
+				? editor.inputs.currentPagePoint
+				: editor.getViewportPageBounds().center)
 
 		const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
 		const shape = createEmptyBookmarkShape(editor, url, position)

commit d2d3e582e5c71bb15a710ed890270db728971ba6
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon May 13 09:29:43 2024 +0100

    assets: rework mime-type detection to be consistent/centralized; add support for webp/webm, apng, avif (#3730)
    
    As I started working on image LOD stuff and wrapping my head around the
    codebase, this was bothering me.
    - there are missing popular types, especially WebP
    - there are places where we're copy/pasting the same list of types but
    they can get out-of-date with each other (also, one place described
    supporting webm but we didn't actually do that)
    
    This adds animated apng/avif detection as well (alongside our animated
    gif detection). Furthermore, it moves the gif logic to be alongside the
    png logic (they were in separate packages unnecessarily)
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Release Notes
    
    - Images: unify list of acceptable types and expand to include webp,
    webm, apng, avif

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 647792061..18bcad4c5 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -22,7 +22,7 @@ import {
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
-import { containBoxSize, downsizeImage, isGifAnimated } from './utils/assets/assets'
+import { containBoxSize, downsizeImage } from './utils/assets/assets'
 import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
 
@@ -32,9 +32,9 @@ export type TLExternalContentProps = {
 	maxImageDimension: number
 	// The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).
 	maxAssetSize: number
-	// The mime types of images that are allowed to be handled. Defaults to ['image/jpeg', 'image/png', 'image/gif', 'image/svg+xml'].
+	// The mime types of images that are allowed to be handled. Defaults to DEFAULT_SUPPORTED_IMAGE_TYPES.
 	acceptedImageMimeTypes: readonly string[]
-	// The mime types of videos that are allowed to be handled. Defaults to ['video/mp4', 'video/webm', 'video/quicktime'].
+	// The mime types of videos that are allowed to be handled. Defaults to DEFAULT_SUPPORT_VIDEO_TYPES.
 	acceptedVideoMimeTypes: readonly string[]
 }
 
@@ -70,19 +70,19 @@ export function registerDefaultExternalContentHandlers(
 			? await MediaHelpers.getImageSize(file)
 			: await MediaHelpers.getVideoSize(file)
 
-		const isAnimated = file.type === 'image/gif' ? await isGifAnimated(file) : isVideoType
+		const isAnimated = (await MediaHelpers.isAnimated(file)) || isVideoType
 
 		const hash = await getHashForBuffer(await file.arrayBuffer())
 
 		if (isFinite(maxImageDimension)) {
 			const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
-			if (size !== resizedSize && (file.type === 'image/jpeg' || file.type === 'image/png')) {
+			if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
 				size = resizedSize
 			}
 		}
 
 		// Always rescale the image
-		if (file.type === 'image/jpeg' || file.type === 'image/png') {
+		if (!isAnimated && MediaHelpers.isStaticImageType(file.type)) {
 			file = await downsizeImage(file, size.w, size.h, {
 				type: file.type,
 				quality: 0.92,

commit f9ed1bf2c9480b1c49f591a8609adfb4fcf91eae
Author: alex <alex@dytry.ch>
Date:   Wed May 22 16:55:49 2024 +0100

    Force `interface` instead of `type` for better docs (#3815)
    
    Typescript's type aliases (`type X = thing`) can refer to basically
    anything, which makes it hard to write an automatic document formatter
    for them. Interfaces on the other hand are only object, so they play
    much nicer with docs. Currently, object-flavoured type aliases don't
    really get expanded at all on our docs site, which means we have a bunch
    of docs content that's not shown on the site.
    
    This diff introduces a lint rule that forces `interface X {foo: bar}`s
    instead of `type X = {foo: bar}` where possible, as it results in a much
    better documentation experience:
    
    Before:
    <img width="437" alt="Screenshot 2024-05-22 at 15 24 13"
    src="https://github.com/tldraw/tldraw/assets/1489520/32606fd1-6832-4a1e-aa5f-f0534d160c92">
    
    After:
    <img width="431" alt="Screenshot 2024-05-22 at 15 33 01"
    src="https://github.com/tldraw/tldraw/assets/1489520/4e0d59ee-c38e-4056-b9fd-6a7f15d28f0f">
    
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `docs` — Changes to the documentation, examples, or templates.
    - [x] `improvement` — Improving existing features

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 18bcad4c5..970a4fa81 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -27,7 +27,7 @@ import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
 
 /** @public */
-export type TLExternalContentProps = {
+export interface TLExternalContentProps {
 	// The maximum dimension (width or height) of an image. Images larger than this will be rescaled to fit. Defaults to infinity.
 	maxImageDimension: number
 	// The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).

commit b7bc2dbbce6a3c53c4ed7c95201c2f82ad5df4ef
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jun 5 11:52:10 2024 +0100

    security: don't send referrer paths for images and bookmarks (#3881)
    
    We're currently sending `referrer` with path for image/bookmark
    requests. We shouldn't do that as it exposes the rooms to other servers.
    
    ## `<img>`
    - `<img>` tags have the right referrerpolicy to be
    `strict-origin-when-cross-origin`:
    https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#referrerpolicy
    - _however_, because we use React, it looks like react creates a raw DOM
    node and adds properties one by one and it loses the default
    referrerpolicy it would otherwise get! So, in `BookmarkShapeUtil` we
    explicitly state the `referrerpolicy`
    - `background-image` does the right thing 👍
    - _also_, I added this to places we do programmatic `new Image()`
    
    ## `fetch`
    - _however_, fetch does not! wtf.
    https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    
    it's almost a footnote in this section of the docs
    (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options)
    that `no-referrer-when-downgrade` is the default.
    
    ## `new Image()`
    ugh, but _also_ doing a programmatic `new Image()` doesn't do the right
    thing and we need to set the referrerpolicy here as well
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test on staging that referrer with path isn't being sent anymore.
    
    ### Release Notes
    
    - Security: fix referrer being sent for bookmarks and images.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 970a4fa81..536e0c24b 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -113,7 +113,11 @@ export function registerDefaultExternalContentHandlers(
 		let meta: { image: string; title: string; description: string }
 
 		try {
-			const resp = await fetch(url, { method: 'GET', mode: 'no-cors' })
+			const resp = await fetch(url, {
+				method: 'GET',
+				mode: 'no-cors',
+				referrerPolicy: 'strict-origin-when-cross-origin',
+			})
 			const html = await resp.text()
 			const doc = new DOMParser().parseFromString(html, 'text/html')
 			meta = {

commit ccb6b918c51a6f9ccea72784b7b1b0ba9d43e94b
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Jun 10 11:50:49 2024 +0100

    bookmark: fix up double request and rework extractor (#3856)
    
    This code has started to bitrot a bit and this freshens it up a bit.
    - there's a double request happening for every bookmark paste at the
    moment, yikes! One request originates from the paste logic, and the
    other originates from the `onBeforeCreate` in `BookmarkShapeUtil`. They
    both see that an asset is missing and race to make the request at the
    same time. It _seems_ like we don't need the `onBeforeCreate` anymore.
    But, if I'm mistaken on some edge case here lemme know and we can
    address this in a different way.
    - the extractor is really crusty (the grabity code is from 5 yrs ago and
    hasn't been updated) and we don't have control over it. i've worked on
    unfurling stuff before with Paper and my other projects and this reworks
    things to use Cheerio, which is a more robust library.
    - this adds `favicon` to the response request which should usually
    default to the apple-touch-icon. this helps with some better bookmark
    displays (e.g. like Wikipedia if an image is empty)
    
    In general, this'll start to make this more maintainable and improvable
    on our end.
    
    Double request:
    <img width="1496" alt="Screenshot 2024-05-31 at 17 54 49"
    src="https://github.com/tldraw/tldraw/assets/469604/22033170-caaa-4fd2-854f-f19b61611978">
    
    Before:
    <img width="355" alt="Screenshot 2024-05-31 at 17 55 02"
    src="https://github.com/tldraw/tldraw/assets/469604/fd272669-ee52-4cc7-bed7-72a8ed8d53a0">
    
    After:
    <img width="351" alt="Screenshot 2024-05-31 at 17 55 44"
    src="https://github.com/tldraw/tldraw/assets/469604/87d27342-0d49-4cfc-a811-356370562d19">
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [ ] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test pasting links in, and pasting again.
    
    ### Release Notes
    
    - Bookmarks: fix up double request and rework extractor code.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 536e0c24b..8df006e6e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -24,7 +24,7 @@ import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize, downsizeImage } from './utils/assets/assets'
 import { getEmbedInfo } from './utils/embeds/embeds'
-import { cleanupText, isRightToLeftLanguage, truncateStringWithEllipsis } from './utils/text/text'
+import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
 /** @public */
 export interface TLExternalContentProps {
@@ -110,7 +110,7 @@ export function registerDefaultExternalContentHandlers(
 
 	// urls -> bookmark asset
 	editor.registerExternalAssetHandler('url', async ({ url }) => {
-		let meta: { image: string; title: string; description: string }
+		let meta: { image: string; favicon: string; title: string; description: string }
 
 		try {
 			const resp = await fetch(url, {
@@ -122,9 +122,11 @@ export function registerDefaultExternalContentHandlers(
 			const doc = new DOMParser().parseFromString(html, 'text/html')
 			meta = {
 				image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute('content') ?? '',
-				title:
-					doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ??
-					truncateStringWithEllipsis(url, 32),
+				favicon:
+					doc.head.querySelector('link[rel="apple-touch-icon"]')?.getAttribute('href') ??
+					doc.head.querySelector('link[rel="icon"]')?.getAttribute('href') ??
+					'',
+				title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ?? url,
 				description:
 					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
 			}
@@ -134,7 +136,7 @@ export function registerDefaultExternalContentHandlers(
 				title: msg('assets.url.failed'),
 				severity: 'error',
 			})
-			meta = { image: '', title: truncateStringWithEllipsis(url, 32), description: '' }
+			meta = { image: '', favicon: '', title: '', description: '' }
 		}
 
 		// Create the bookmark asset from the meta
@@ -146,6 +148,7 @@ export function registerDefaultExternalContentHandlers(
 				src: url,
 				description: meta.description,
 				image: meta.image,
+				favicon: meta.favicon,
 				title: meta.title,
 			},
 			meta: {},

commit 215ff308ba5a8000cbef09657d2a16a51b6a0210
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 12:04:29 2024 +0100

    bookmarks: resolve relative urls (#3914)
    
    fix relative url's
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [ ] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 8df006e6e..d77594a37 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -130,6 +130,12 @@ export function registerDefaultExternalContentHandlers(
 				description:
 					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
 			}
+			if (meta.image.startsWith('/')) {
+				meta.image = new URL(meta.image, url).href
+			}
+			if (meta.favicon.startsWith('/')) {
+				meta.favicon = new URL(meta.favicon, url).href
+			}
 		} catch (error) {
 			console.error(error)
 			toasts.addToast({

commit 3adae06d9c1db0b047bf44d2dc216841bcbc6ce8
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 14:59:25 2024 +0100

    security: enforce use of our fetch function and its default referrerpolicy (#3884)
    
    followup to https://github.com/tldraw/tldraw/pull/3881 to enforce this
    in the codebase
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index d77594a37..d30f83445 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -16,6 +16,7 @@ import {
 	assert,
 	compact,
 	createShapeId,
+	fetch,
 	getHashForBuffer,
 	getHashForString,
 } from '@tldraw/editor'
@@ -116,7 +117,6 @@ export function registerDefaultExternalContentHandlers(
 			const resp = await fetch(url, {
 				method: 'GET',
 				mode: 'no-cors',
-				referrerPolicy: 'strict-origin-when-cross-origin',
 			})
 			const html = await resp.text()
 			const doc = new DOMParser().parseFromString(html, 'text/html')

commit 6c846716c343e1ad40839f0f2bab758f58b4284d
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 15:17:09 2024 +0100

    assets: make option to transform urls dynamically / LOD (#3827)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3764
    
    This continues the idea kicked off in
    https://github.com/tldraw/tldraw/pull/3684 to explore LOD and takes it
    in a different direction.
    
    Several things here to call out:
    - our dotcom version would start to use Cloudflare's image transforms
    - we don't rewrite non-image assets
    - we debounce zooming so that we're not swapping out images while
    zooming (it creates jank)
    - we load different images based on steps of .25 (maybe we want to make
    this more, like 0.33). Feels like 0.5 might be a bit too much but we can
    play around with it.
    - we take into account network connection speed. if you're on 3g, for
    example, we have the size of the image.
    - dpr is taken into account - in our case, Cloudflare handles it. But if
    it wasn't Cloudflare, we could add it to our width equation.
    - we use Cloudflare's `fit=scale-down` setting to never scale _up_ an
    image.
    - we don't swap the image in until we've finished loading it
    programatically (to avoid a blank image while it loads)
    
    TODO
    - [x] We need to enable Cloudflare's pricing on image transforms btw
    @steveruizok 😉 - this won't work quite yet until we do that.
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [x] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test images on staging, small, medium, large, mega
    2. Test videos on staging
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Assets: make option to transform urls dynamically to provide different
    sized images on demand.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index d30f83445..c654adf1a 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -23,7 +23,7 @@ import {
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
-import { containBoxSize, downsizeImage } from './utils/assets/assets'
+import { containBoxSize } from './utils/assets/assets'
 import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
@@ -82,14 +82,6 @@ export function registerDefaultExternalContentHandlers(
 			}
 		}
 
-		// Always rescale the image
-		if (!isAnimated && MediaHelpers.isStaticImageType(file.type)) {
-			file = await downsizeImage(file, size.w, size.h, {
-				type: file.type,
-				quality: 0.92,
-			})
-		}
-
 		const assetId: TLAssetId = AssetRecordType.createId(hash)
 
 		const asset = AssetRecordType.create({
@@ -101,6 +93,7 @@ export function registerDefaultExternalContentHandlers(
 				src: await FileHelpers.blobToDataUrl(file),
 				w: size.w,
 				h: size.h,
+				fileSize: file.size,
 				mimeType: file.type,
 				isAnimated,
 			},

commit 735161c4a81fb617805ffb7f76a274954ec1d2f4
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Fri Jun 14 11:23:52 2024 +0100

    assets: store in indexedDB, not as base64 (#3836)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3745
    
    As I look at LOD holistically and whether we have multiple sources when
    working locally, I learned that our system used base64 encoding of
    assets directly. Issue https://github.com/tldraw/tldraw/issues/3728
    
    <img width="1350" alt="assetstore"
    src="https://github.com/tldraw/tldraw/assets/469604/e7b41e29-6656-4d9b-b462-72d43b98f3f7">
    
    
    The motivations and benefits are:
    - store size: not having a huge base64 blobs injected in room data
    - perf on loading snapshot: this helps with loading the room data more
    quickly
    - multiple sources: furthermore, if we do decide to have multiple
    sources locally (for each asset), then we won't get a multiplicative
    effect of even larger JSON blobs that have lots of base64 data in them
    - encoding/decoding perf: this also saves the (slow) step of having to
    base64 encode/decode our assets, we can just strictly with work with
    blobs.
    
    
    Todo:
    - [x] decodes video and images
    - [x] make sure it syncs to other tabs
    - [x] make sure it syncs to other multiplayer room
    - [x] fix tests
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test the shit out of uploading/downloading video/image assets,
    locally+multiplayer.
    
    - [ ] Need to fix current tests and write new ones
    
    ### Release Notes
    
    - Assets: store as reference to blob in indexedDB instead of storing
    directly as base64 in the snapshot.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index c654adf1a..3c024b739 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -13,6 +13,7 @@ import {
 	TLTextShapeProps,
 	Vec,
 	VecLike,
+	WeakCache,
 	assert,
 	compact,
 	createShapeId,
@@ -20,6 +21,7 @@ import {
 	getHashForBuffer,
 	getHashForString,
 } from '@tldraw/editor'
+import { getAssetFromIndexedDb, storeAssetInIndexedDb } from './AssetBlobStore'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
@@ -47,7 +49,8 @@ export function registerDefaultExternalContentHandlers(
 		acceptedImageMimeTypes,
 		acceptedVideoMimeTypes,
 	}: TLExternalContentProps,
-	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
+	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> },
+	persistenceKey?: string
 ) {
 	// files -> asset
 	editor.registerExternalAssetHandler('file', async ({ file: _file }) => {
@@ -83,23 +86,33 @@ export function registerDefaultExternalContentHandlers(
 		}
 
 		const assetId: TLAssetId = AssetRecordType.createId(hash)
-
-		const asset = AssetRecordType.create({
+		const assetInfo = {
 			id: assetId,
 			type: isImageType ? 'image' : 'video',
 			typeName: 'asset',
 			props: {
 				name,
-				src: await FileHelpers.blobToDataUrl(file),
+				src: '',
 				w: size.w,
 				h: size.h,
 				fileSize: file.size,
 				mimeType: file.type,
 				isAnimated,
 			},
-		})
+		} as TLAsset
+
+		if (persistenceKey) {
+			assetInfo.props.src = assetId
+			await storeAssetInIndexedDb({
+				persistenceKey,
+				assetId,
+				blob: file,
+			})
+		} else {
+			assetInfo.props.src = await FileHelpers.blobToDataUrl(file)
+		}
 
-		return asset
+		return AssetRecordType.create(assetInfo)
 	})
 
 	// urls -> bookmark asset
@@ -561,3 +574,36 @@ export function createEmptyBookmarkShape(
 
 	return editor.getShape(partial.id) as TLBookmarkShape
 }
+
+const objectURLCache = new WeakCache<TLAsset, ReturnType<typeof getLocalAssetObjectURL>>()
+export const defaultResolveAsset =
+	(persistenceKey?: string) => async (asset: TLAsset | null | undefined) => {
+		if (!asset || !asset.props.src) return null
+
+		// We don't deal with videos at the moment.
+		if (asset.type === 'video') return asset.props.src
+
+		// Assert it's an image to make TS happy.
+		if (asset.type !== 'image') return null
+
+		// Retrieve a local image from the DB.
+		if (persistenceKey && asset.props.src.startsWith('asset:')) {
+			return await objectURLCache.get(
+				asset,
+				async () => await getLocalAssetObjectURL(persistenceKey, asset.id)
+			)
+		}
+
+		return asset.props.src
+	}
+
+async function getLocalAssetObjectURL(persistenceKey: string, assetId: TLAssetId) {
+	const blob = await getAssetFromIndexedDb({
+		assetId: assetId,
+		persistenceKey,
+	})
+	if (blob) {
+		return URL.createObjectURL(blob)
+	}
+	return null
+}

commit 5b3fc7dffe381589a2d2e489d1871aca2e635fdb
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Jun 17 11:58:37 2024 +0100

    assets: fix up videos with indexedDB (#3954)
    
    Whoops, the logic needs to check for `asset:` first before videos.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 3c024b739..75d2c29e3 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -580,12 +580,6 @@ export const defaultResolveAsset =
 	(persistenceKey?: string) => async (asset: TLAsset | null | undefined) => {
 		if (!asset || !asset.props.src) return null
 
-		// We don't deal with videos at the moment.
-		if (asset.type === 'video') return asset.props.src
-
-		// Assert it's an image to make TS happy.
-		if (asset.type !== 'image') return null
-
 		// Retrieve a local image from the DB.
 		if (persistenceKey && asset.props.src.startsWith('asset:')) {
 			return await objectURLCache.get(
@@ -594,6 +588,12 @@ export const defaultResolveAsset =
 			)
 		}
 
+		// We don't deal with videos at the moment.
+		if (asset.type === 'video') return asset.props.src
+
+		// Assert it's an image to make TS happy.
+		if (asset.type !== 'image') return null
+
 		return asset.props.src
 	}
 

commit 487b1beb8503e6ac5dee1505bc5fd7cae972971e
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jun 18 11:46:55 2024 +0100

    Fix asset positions (#3965)
    
    This PR fixes the positions of assets created when multiple assets are
    created at once.
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `bugfix` — Bug fix
    
    ### Test Plan
    
    1. Drop / paste multiple images on the canvas.
    2. The shapes should be top aligned and positioned next to eachother.
    
    ### Release Notes
    
    - Fixes the position of multiple assets when pasted / dropped onto the
    canvas.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 75d2c29e3..8e9efef54 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -450,14 +450,15 @@ export async function createShapesForAssets(
 	const currentPoint = Vec.From(position)
 	const partials: TLShapePartial[] = []
 
-	for (const asset of assets) {
+	for (let i = 0; i < assets.length; i++) {
+		const asset = assets[i]
 		switch (asset.type) {
 			case 'bookmark': {
 				partials.push({
 					id: createShapeId(),
 					type: 'bookmark',
-					x: currentPoint.x - 150,
-					y: currentPoint.y - 160,
+					x: currentPoint.x,
+					y: currentPoint.y,
 					opacity: 1,
 					props: {
 						assetId: asset.id,
@@ -465,15 +466,15 @@ export async function createShapesForAssets(
 					},
 				})
 
-				currentPoint.x += 300
+				currentPoint.x += 300 // BOOKMARK_WIDTH
 				break
 			}
 			case 'image': {
 				partials.push({
 					id: createShapeId(),
 					type: 'image',
-					x: currentPoint.x - asset.props.w / 2,
-					y: currentPoint.y - asset.props.h / 2,
+					x: currentPoint.x,
+					y: currentPoint.y,
 					opacity: 1,
 					props: {
 						assetId: asset.id,
@@ -489,8 +490,8 @@ export async function createShapesForAssets(
 				partials.push({
 					id: createShapeId(),
 					type: 'video',
-					x: currentPoint.x - asset.props.w / 2,
-					y: currentPoint.y - asset.props.h / 2,
+					x: currentPoint.x,
+					y: currentPoint.y,
 					opacity: 1,
 					props: {
 						assetId: asset.id,

commit 4ccac5da96d55e3d3fbceb37a7ee65a1901939fc
Author: alex <alex@dytry.ch>
Date:   Mon Jun 24 16:55:46 2024 +0100

    better auto-generated docs for Tldraw and TldrawEditor (#4012)
    
    Simplify the types used by the props of the `Tldraw` and `TldrawEditor`
    components. This doesn't make the docs perfect, but it makes them quite
    a bit better than they were.
    
    
    ![image](https://github.com/tldraw/tldraw/assets/1489520/66c72e0e-c22b-4414-b194-f0598e4a3736)
    
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `docs` — Changes to the documentation, examples, or templates.
    - [x] `improvement` — Improving existing features

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 8e9efef54..856511e3d 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -31,14 +31,26 @@ import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
 /** @public */
 export interface TLExternalContentProps {
-	// The maximum dimension (width or height) of an image. Images larger than this will be rescaled to fit. Defaults to infinity.
-	maxImageDimension: number
-	// The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults to 10mb (10 * 1024 * 1024).
-	maxAssetSize: number
-	// The mime types of images that are allowed to be handled. Defaults to DEFAULT_SUPPORTED_IMAGE_TYPES.
-	acceptedImageMimeTypes: readonly string[]
-	// The mime types of videos that are allowed to be handled. Defaults to DEFAULT_SUPPORT_VIDEO_TYPES.
-	acceptedVideoMimeTypes: readonly string[]
+	/**
+	 * The maximum dimension (width or height) of an image. Images larger than this will be rescaled
+	 * to fit. Defaults to infinity.
+	 */
+	maxImageDimension?: number
+	/**
+	 * The maximum size (in bytes) of an asset. Assets larger than this will be rejected. Defaults
+	 * to 10mb (10 * 1024 * 1024).
+	 */
+	maxAssetSize?: number
+	/**
+	 * The mime types of images that are allowed to be handled. Defaults to
+	 * DEFAULT_SUPPORTED_IMAGE_TYPES.
+	 */
+	acceptedImageMimeTypes?: readonly string[]
+	/**
+	 * The mime types of videos that are allowed to be handled. Defaults to
+	 * DEFAULT_SUPPORT_VIDEO_TYPES.
+	 */
+	acceptedVideoMimeTypes?: readonly string[]
 }
 
 export function registerDefaultExternalContentHandlers(
@@ -48,7 +60,7 @@ export function registerDefaultExternalContentHandlers(
 		maxAssetSize,
 		acceptedImageMimeTypes,
 		acceptedVideoMimeTypes,
-	}: TLExternalContentProps,
+	}: Required<TLExternalContentProps>,
 	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> },
 	persistenceKey?: string
 ) {

commit 41c3b1e3df5d6e086a273d6df2a524a43fa22ba7
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jun 26 12:36:57 2024 +0100

    bookmarks: account for relative urls more robustly (#4022)
    
    Fixes up url's that don't have `/` in front or `http`
    
    ### Change Type
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `feature` — New feature
    - [x] `improvement` — Product improvement
    - [ ] `api` — API change
    - [ ] `bugfix` — Bug fix
    - [ ] `other` — Changes that don't affect SDK users, e.g. internal or
    .com changes
    
    ### Release Notes
    
    - Bookmark extractor: account for relative urls more robustly

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 856511e3d..9f3f6e37c 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -148,10 +148,10 @@ export function registerDefaultExternalContentHandlers(
 				description:
 					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
 			}
-			if (meta.image.startsWith('/')) {
+			if (!meta.image.startsWith('http')) {
 				meta.image = new URL(meta.image, url).href
 			}
-			if (meta.favicon.startsWith('/')) {
+			if (!meta.favicon.startsWith('http')) {
 				meta.favicon = new URL(meta.favicon, url).href
 			}
 		} catch (error) {

commit adbb0e9b3bf928eb321757740be31eceff90e052
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Jul 9 15:05:31 2024 +0200

    Add a toast for file upload failures. (#4114)
    
    Adds toasts for cases when the file type is not allowed or the file is
    too big.
    
    Resolves
    https://github.com/orgs/tldraw/projects/53?pane=issue&itemId=70298205
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Upload a file that is either too big (over 10mb) or of incorrect file
    type (pdf, docx,...).
    2. You should see a toast explaining what went wrong.
    
    ### Release notes
    
    - Show a toast when uploading an unsupported file type or a file that is
    too large (more than 10mb).

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 9f3f6e37c..2d886baec 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -71,7 +71,20 @@ export function registerDefaultExternalContentHandlers(
 		const isImageType = acceptedImageMimeTypes.includes(file.type)
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 
+		if (!isImageType && !isVideoType) {
+			toasts.addToast({
+				title: msg('assets.files.type-not-allowed'),
+				severity: 'error',
+			})
+		}
 		assert(isImageType || isVideoType, `File type not allowed: ${file.type}`)
+
+		if (file.size > maxAssetSize) {
+			toasts.addToast({
+				title: msg('assets.files.size-too-big'),
+				severity: 'error',
+			})
+		}
 		assert(
 			file.size <= maxAssetSize,
 			`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
@@ -256,6 +269,11 @@ export function registerDefaultExternalContentHandlers(
 		await Promise.all(
 			files.map(async (file, i) => {
 				if (file.size > maxAssetSize) {
+					toasts.addToast({
+						title: msg('assets.files.size-too-big'),
+						severity: 'error',
+					})
+
 					console.warn(
 						`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
 							maxAssetSize / 1024
@@ -273,6 +291,10 @@ export function registerDefaultExternalContentHandlers(
 
 				// We can only accept certain extensions (either images or a videos)
 				if (!acceptedImageMimeTypes.concat(acceptedVideoMimeTypes).includes(file.type)) {
+					toasts.addToast({
+						title: msg('assets.files.type-not-allowed'),
+						severity: 'error',
+					})
 					console.warn(`${file.name} not loaded - Extension not allowed.`)
 					return null
 				}

commit 965bc10997725a7e2e1484767165253d4352b21a
Author: alex <alex@dytry.ch>
Date:   Wed Jul 10 14:00:18 2024 +0100

    [1/4] Blob storage in TLStore (#4068)
    
    Reworks the store to include information about how blob assets
    (images/videos) are stored/retrieved. This replaces the old
    internal-only `assetOptions` prop, and supplements the existing
    `registerExternalAssetHandler` API.
    
    Previously, `registerExternalAssetHandler` had two responsibilities:
    1. Extracting asset metadata
    2. Uploading the asset and returning its URL
    
    Existing `registerExternalAssetHandler` implementation will still work,
    but now uploading is the responsibility of a new `editor.uploadAsset`
    method which calls the new store-based upload method. Our default asset
    handlers extract metadata, then call that new API. I think this is a
    pretty big improvement over what we had before: overriding uploads was a
    pretty common ask, but doing so meant having to copy paste our metadata
    extraction which felt pretty fragile. Just in this codebase, we had a
    bunch of very slightly different metadata extraction code-paths that had
    been copy-pasted around then diverged over time. Now, you can change how
    uploads work without having to mess with metadata extraction and
    vice-versa.
    
    As part of this we also:
    1. merge the old separate asset indexeddb store with the main one.
    because this warrants some pretty big migration stuff, i refactored our
    indexed-db helpers to work around an instance instead of being free
    functions
    2. move our existing asset stuff over to the new approach
    3. add a new hook in `sync-react` to create a demo store with the new
    assets
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    Introduce a new `assets` option for the store, describing how to save
    and retrieve asset blobs like images & videos from e.g. a user-content
    CDN. These are accessible through `editor.uploadAsset` and
    `editor.resolveAssetUrl`. This supplements the existing
    `registerExternalAssetHandler` API: `registerExternalAssetHandler` is
    for customising metadata extraction, and should call
    `editor.uploadAsset` to save assets. Existing
    `registerExternalAssetHandler` calls will still work, but if you're only
    using them to configure uploads and don't want to customise metadata
    extraction, consider switching to the new `assets` store prop.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 2d886baec..2db675601 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -1,7 +1,6 @@
 import {
 	AssetRecordType,
 	Editor,
-	FileHelpers,
 	MediaHelpers,
 	TLAsset,
 	TLAssetId,
@@ -13,7 +12,6 @@ import {
 	TLTextShapeProps,
 	Vec,
 	VecLike,
-	WeakCache,
 	assert,
 	compact,
 	createShapeId,
@@ -21,7 +19,6 @@ import {
 	getHashForBuffer,
 	getHashForString,
 } from '@tldraw/editor'
-import { getAssetFromIndexedDb, storeAssetInIndexedDb } from './AssetBlobStore'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
@@ -61,13 +58,12 @@ export function registerDefaultExternalContentHandlers(
 		acceptedImageMimeTypes,
 		acceptedVideoMimeTypes,
 	}: Required<TLExternalContentProps>,
-	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> },
-	persistenceKey?: string
+	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
 ) {
 	// files -> asset
 	editor.registerExternalAssetHandler('file', async ({ file: _file }) => {
 		const name = _file.name
-		let file: Blob = _file
+		let file: File = _file
 		const isImageType = acceptedImageMimeTypes.includes(file.type)
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 
@@ -92,7 +88,7 @@ export function registerDefaultExternalContentHandlers(
 
 		if (file.type === 'video/quicktime') {
 			// hack to make .mov videos work
-			file = new Blob([file], { type: 'video/mp4' })
+			file = new File([file], file.name, { type: 'video/mp4' })
 		}
 
 		let size = isImageType
@@ -101,7 +97,7 @@ export function registerDefaultExternalContentHandlers(
 
 		const isAnimated = (await MediaHelpers.isAnimated(file)) || isVideoType
 
-		const hash = await getHashForBuffer(await file.arrayBuffer())
+		const hash = getHashForBuffer(await file.arrayBuffer())
 
 		if (isFinite(maxImageDimension)) {
 			const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
@@ -126,16 +122,7 @@ export function registerDefaultExternalContentHandlers(
 			},
 		} as TLAsset
 
-		if (persistenceKey) {
-			assetInfo.props.src = assetId
-			await storeAssetInIndexedDb({
-				persistenceKey,
-				assetId,
-				blob: file,
-			})
-		} else {
-			assetInfo.props.src = await FileHelpers.blobToDataUrl(file)
-		}
+		assetInfo.props.src = await editor.uploadAsset(assetInfo, file)
 
 		return AssetRecordType.create(assetInfo)
 	})
@@ -609,36 +596,3 @@ export function createEmptyBookmarkShape(
 
 	return editor.getShape(partial.id) as TLBookmarkShape
 }
-
-const objectURLCache = new WeakCache<TLAsset, ReturnType<typeof getLocalAssetObjectURL>>()
-export const defaultResolveAsset =
-	(persistenceKey?: string) => async (asset: TLAsset | null | undefined) => {
-		if (!asset || !asset.props.src) return null
-
-		// Retrieve a local image from the DB.
-		if (persistenceKey && asset.props.src.startsWith('asset:')) {
-			return await objectURLCache.get(
-				asset,
-				async () => await getLocalAssetObjectURL(persistenceKey, asset.id)
-			)
-		}
-
-		// We don't deal with videos at the moment.
-		if (asset.type === 'video') return asset.props.src
-
-		// Assert it's an image to make TS happy.
-		if (asset.type !== 'image') return null
-
-		return asset.props.src
-	}
-
-async function getLocalAssetObjectURL(persistenceKey: string, assetId: TLAssetId) {
-	const blob = await getAssetFromIndexedDb({
-		assetId: assetId,
-		persistenceKey,
-	})
-	if (blob) {
-		return URL.createObjectURL(blob)
-	}
-	return null
-}

commit 01bc73e750a9450eb135ad080a7087f494020b48
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 15 15:10:09 2024 +0100

    Editor.run, locked shapes improvements (#4042)
    
    This PR:
    - creates `Editor.run` (previously `Editor.batch`)
    - deprecates `Editor.batch`
    - introduces a `ignoreShapeLock` option top the `Editor.run` method that
    allows the editor to update and delete locked shapes
    - fixes a bug with `updateShapes` that allowed updating locked shapes
    - fixes a bug with `ungroupShapes` that allowed ungrouping locked shapes
    - makes `Editor.history` private
    - adds `Editor.squashToMark`
    - adds `Editor.clearHistory`
    - removes `History.ignore`
    - removes `History.onBatchComplete`
    - makes `_updateCurrentPageState` private
    
    ```ts
    editor.run(() => {
      editor.updateShape({ ...myLockedShape })
      editor.deleteShape(myLockedShape)
    }, { ignoreShapeLock: true })
    ```
    
    It also:
    
    ## How it works
    
    Normally `updateShape`/`updateShapes` and `deleteShape`/`deleteShapes`
    do not effect locked shapes.
    
    ```ts
    const myLockedShape = editor.getShape(myShapeId)!
    
    // no change from update
    editor.updateShape({ ...myLockedShape, x: 100 })
    expect(editor.getShape(myShapeId)).toMatchObject(myLockedShape)
    
    // no change from delete
    editor.deleteShapes([myLockedShape])
    expect(editor.getShape(myShapeId)).toMatchObject(myLockedShape)
    ```
    
    The new `run` method adds the option to ignore shape lock.
    
    ```ts
    const myLockedShape = editor.getShape(myShapeId)!
    
    // update works
    editor.run(() => { editor.updateShape({ ...myLockedShape, x: 100 }) }, { ignoreShapeLock: true })
    expect(editor.getShape(myShapeId)).toMatchObject({ ...myLockedShape, x: 100 })
    
    // delete works
    editor.run(() => { editor.deleteShapes([myLockedShape]), { ignoreShapeLock: true })
    expect(editor.getShape(myShapeId)).toBeUndefined()
    ```
    
    ## History changes
    
    This is a related but not entirely related change in this PR.
    
    Previously, we had a few ways to run code that ignored the history.
    
    - `editor.history.ignore(() => { ... })`
    - `editor.batch(() => { ... }, { history: "ignore" })`
    - `editor.history.batch(() => { ... }, { history: "ignore" })`
    - `editor.updateCurrentPageState(() => { ... }, { history: "ignore" })`
    
    We now have one way to run code that ignores history:
    
    - `editor.run(() => { ... }, { history: "ignore" })`
    
    ## Design notes
    
    We want a user to be able to update or delete locked shapes
    programmatically.
    
    ### Callback vs. method options?
    
    We could have added a `{ force: boolean }` property to the
    `updateShapes` / `deleteShapes` methods, however there are places where
    those methods are called from other methods (such as
    `distributeShapes`). If we wanted to make these work, we would have also
    had to provide a `force` option / bag to those methods.
    
    Using a wrapper callback allows for "regular" tldraw editor code to work
    while allowing for updates and deletes.
    
    ### Interaction logic?
    
    We don't want this change to effect any of our interaction logic.
    
    A lot of our interaction logic depends on identifying which shapes are
    locked and which shapes aren't. For example, clicking on a locked shape
    will go to the `pointing_canvas` state rather than the `pointing_shape`.
    This PR has no effect on that part of the library.
    
    It only effects the updateShapes and deleteShapes methods. As an example
    of this, when `_force` is set to true by default, the only tests that
    should fail are in `lockedShapes.test.ts`. The "user land" experience of
    locked shapes is identical to what it is now.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape
    2. Lock it
    3. From the console, update it
    4. From the console, delete it
    
    - [x] Unit tests
    
    ### Release notes
    
    - SDK: Adds `Editor.force()` to permit updating / deleting locked shapes
    - Fixed a bug that would allow locked shapes to be updated
    programmatically
    - Fixed a bug that would allow locked group shapes to be ungrouped
    programmatically
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 2db675601..6f993ed37 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -443,7 +443,7 @@ export function registerDefaultExternalContentHandlers(
 			}
 		}
 
-		editor.batch(() => {
+		editor.run(() => {
 			if (shouldAlsoCreateAsset) {
 				editor.createAssets([asset])
 			}
@@ -526,7 +526,7 @@ export async function createShapesForAssets(
 		}
 	}
 
-	editor.batch(() => {
+	editor.run(() => {
 		// Create any assets
 		const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id))
 		if (assetsToCreate.length) {
@@ -589,7 +589,7 @@ export function createEmptyBookmarkShape(
 		},
 	}
 
-	editor.batch(() => {
+	editor.run(() => {
 		editor.createShapes([partial]).select(partial.id)
 		centerSelectionAroundPoint(editor, position)
 	})

commit c27d0d166f0fb55bd55eb8f64b5a9b9dcb2dcf7f
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Tue Jul 23 13:40:05 2024 +0100

    Export helpers for image paste (#4258)
    
    exports createShapeForAssets and centerSelectionAroundPoint closes
    TLD-2212 #2808
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    
    ### Release notes
    
    - Exports helpers for pasting external content.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 6f993ed37..b09757228 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -461,6 +461,18 @@ export function registerDefaultExternalContentHandlers(
 	})
 }
 
+/**
+ * A helper function for an external content handler. It creates bookmarks,
+ * images or video shapes corresponding to the type of assets provided.
+ *
+ * @param editor - The editor instance
+ *
+ * @param assets - An array of asset Ids
+ *
+ * @param position - the position at which to create the shapes
+ *
+ * @public
+ */
 export async function createShapesForAssets(
 	editor: Editor,
 	assets: TLAsset[],
@@ -543,7 +555,17 @@ export async function createShapesForAssets(
 	return partials.map((p) => p.id)
 }
 
-function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
+/**
+ * Repositions selected shapes do that the center of the group is
+ * at the provided position
+ *
+ * @param editor - The editor instance
+ *
+ * @param position - the point to center the shapes around
+ *
+ * @public
+ */
+export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	// Re-position shapes so that the center of the group is at the provided point
 	const viewportPageBounds = editor.getViewportPageBounds()
 	let selectionPageBounds = editor.getSelectionPageBounds()

commit ef89eedfce969daf4d119e2abb4b894b70da3c56
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 29 14:25:58 2024 +0100

    Add option for max pasted / dropped files (#4294)
    
    This PR adds an editor option for the maximum number of pasted or
    inserted files. The default is 100, a simple sanity check.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Test plan
    
    1. paste 101 files
    2. it should error
    
    ### Release notes
    
    - We now have an editor option for the maximum number of files that a
    user can paste at once.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index b09757228..f229bcfc1 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -253,6 +253,10 @@ export function registerDefaultExternalContentHandlers(
 
 		const assets: TLAsset[] = []
 
+		if (files.length > editor.options.maxFilesAtOnce) {
+			throw Error('Too many files')
+		}
+
 		await Promise.all(
 			files.map(async (file, i) => {
 				if (file.size > maxAssetSize) {

commit 20f0e6a28ad441253dcb688b4f51800930b50aca
Author: alex <alex@dytry.ch>
Date:   Wed Jul 31 12:14:04 2024 +0100

    Add missing bits to exploded example (#4323)
    
    We didn't have the default external content handlers or default side
    effects
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Expose `registerDefaultSideEffects` and
    `registerDefaultExternalContentHandler`

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index f229bcfc1..7027cc42e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -50,6 +50,7 @@ export interface TLExternalContentProps {
 	acceptedVideoMimeTypes?: readonly string[]
 }
 
+/** @public */
 export function registerDefaultExternalContentHandlers(
 	editor: Editor,
 	{

commit 88f7b572e5f7f1075e73c4d56f9ab7994a5c1268
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Aug 1 17:49:14 2024 +0100

    images: show ghost preview image whilst uploading (#3988)
    
    This adds feedback that an upload is happening, both for images and
    videos. For images, it creates a ghost image whilst uploading. For
    videos, it has the spinner (because creating the object blobs seems too
    memory heavy, but I could be convinced). The majority of the work was
    shifting `defaultExternalContentHandlers.ts` so that it's asynchronously
    creates the assets instead of synchronously when adding new assets.
    
    Also:
    - consolidated some asset creation logic around media, there was some
    duplication across the codebase
    - useMultiplayerAssets was unnecessary actually, got rid of it!
    
    Images:
    
    
    https://github.com/tldraw/tldraw/assets/469604/2633d7f1-121c-4d5f-8212-99bcd57a4ba9
    
    
    Videos:
    
    
    https://github.com/tldraw/tldraw/assets/469604/01cfa7b3-8863-45ab-b479-0a15683aa520
    
    Fixes https://github.com/tldraw/tldraw/issues/1567
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Release Notes
    
    - Media: add image and video upload indicators.
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 7027cc42e..7ec503025 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -6,14 +6,15 @@ import {
 	TLAssetId,
 	TLBookmarkShape,
 	TLEmbedShape,
+	TLImageAsset,
 	TLShapeId,
 	TLShapePartial,
 	TLTextShape,
 	TLTextShapeProps,
+	TLVideoAsset,
 	Vec,
 	VecLike,
 	assert,
-	compact,
 	createShapeId,
 	fetch,
 	getHashForBuffer,
@@ -62,9 +63,7 @@ export function registerDefaultExternalContentHandlers(
 	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
 ) {
 	// files -> asset
-	editor.registerExternalAssetHandler('file', async ({ file: _file }) => {
-		const name = _file.name
-		let file: File = _file
+	editor.registerExternalAssetHandler('file', async ({ file }) => {
 		const isImageType = acceptedImageMimeTypes.includes(file.type)
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 
@@ -87,42 +86,19 @@ export function registerDefaultExternalContentHandlers(
 			`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
 		)
 
-		if (file.type === 'video/quicktime') {
-			// hack to make .mov videos work
-			file = new File([file], file.name, { type: 'video/mp4' })
-		}
-
-		let size = isImageType
-			? await MediaHelpers.getImageSize(file)
-			: await MediaHelpers.getVideoSize(file)
-
-		const isAnimated = (await MediaHelpers.isAnimated(file)) || isVideoType
-
-		const hash = getHashForBuffer(await file.arrayBuffer())
+		const hash = await getHashForBuffer(await file.arrayBuffer())
+		const assetId: TLAssetId = AssetRecordType.createId(hash)
+		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
 
 		if (isFinite(maxImageDimension)) {
+			const size = { w: assetInfo.props.w, h: assetInfo.props.h }
 			const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
 			if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
-				size = resizedSize
+				assetInfo.props.w = resizedSize.w
+				assetInfo.props.h = resizedSize.h
 			}
 		}
 
-		const assetId: TLAssetId = AssetRecordType.createId(hash)
-		const assetInfo = {
-			id: assetId,
-			type: isImageType ? 'image' : 'video',
-			typeName: 'asset',
-			props: {
-				name,
-				src: '',
-				w: size.w,
-				h: size.h,
-				fileSize: file.size,
-				mimeType: file.type,
-				isAnimated,
-			},
-		} as TLAsset
-
 		assetInfo.props.src = await editor.uploadAsset(assetInfo, file)
 
 		return AssetRecordType.create(assetInfo)
@@ -244,6 +220,10 @@ export function registerDefaultExternalContentHandlers(
 
 	// files
 	editor.registerExternalContentHandler('files', async ({ point, files }) => {
+		if (files.length > editor.options.maxFilesAtOnce) {
+			throw Error('Too many files')
+		}
+
 		const position =
 			point ??
 			(editor.inputs.shiftKey
@@ -251,66 +231,89 @@ export function registerDefaultExternalContentHandlers(
 				: editor.getViewportPageBounds().center)
 
 		const pagePoint = new Vec(position.x, position.y)
-
 		const assets: TLAsset[] = []
+		const assetsToUpdate: {
+			asset: TLAsset
+			file: File
+			temporaryAssetPreview?: string
+		}[] = []
+		for (const file of files) {
+			if (file.size > maxAssetSize) {
+				toasts.addToast({
+					title: msg('assets.files.size-too-big'),
+					severity: 'error',
+				})
 
-		if (files.length > editor.options.maxFilesAtOnce) {
-			throw Error('Too many files')
-		}
+				console.warn(
+					`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
+						maxAssetSize / 1024
+					).toFixed()}kb`
+				)
+				continue
+			}
 
-		await Promise.all(
-			files.map(async (file, i) => {
-				if (file.size > maxAssetSize) {
-					toasts.addToast({
-						title: msg('assets.files.size-too-big'),
-						severity: 'error',
-					})
+			// Use mime type instead of file ext, this is because
+			// window.navigator.clipboard does not preserve file names
+			// of copied files.
+			if (!file.type) {
+				toasts.addToast({
+					title: msg('assets.files.upload-failed'),
+					severity: 'error',
+				})
+				console.error('No mime type')
+				continue
+			}
 
-					console.warn(
-						`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
-							maxAssetSize / 1024
-						).toFixed()}kb`
-					)
-					return null
-				}
+			// We can only accept certain extensions (either images or a videos)
+			if (!acceptedImageMimeTypes.concat(acceptedVideoMimeTypes).includes(file.type)) {
+				toasts.addToast({
+					title: msg('assets.files.type-not-allowed'),
+					severity: 'error',
+				})
 
-				// Use mime type instead of file ext, this is because
-				// window.navigator.clipboard does not preserve file names
-				// of copied files.
-				if (!file.type) {
-					throw new Error('No mime type')
-				}
+				console.warn(`${file.name} not loaded - Extension not allowed.`)
+				continue
+			}
 
-				// We can only accept certain extensions (either images or a videos)
-				if (!acceptedImageMimeTypes.concat(acceptedVideoMimeTypes).includes(file.type)) {
-					toasts.addToast({
-						title: msg('assets.files.type-not-allowed'),
-						severity: 'error',
-					})
-					console.warn(`${file.name} not loaded - Extension not allowed.`)
-					return null
-				}
+			const isImageType = acceptedImageMimeTypes.includes(file.type)
+			const isVideoType = acceptedVideoMimeTypes.includes(file.type)
+			const hash = await getHashForBuffer(await file.arrayBuffer())
+			const assetId: TLAssetId = AssetRecordType.createId(hash)
+			const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
+			let temporaryAssetPreview
+			if (isImageType) {
+				temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
+			}
+			assets.push(assetInfo)
+			assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
+		}
 
+		Promise.allSettled(
+			assetsToUpdate.map(async (assetAndFile) => {
 				try {
-					const asset = await editor.getAssetForExternalContent({ type: 'file', file })
+					const newAsset = await editor.getAssetForExternalContent({
+						type: 'file',
+						file: assetAndFile.file,
+					})
 
-					if (!asset) {
+					if (!newAsset) {
 						throw Error('Could not create an asset')
 					}
 
-					assets[i] = asset
+					// Save the new asset under the old asset's id
+					editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }])
 				} catch (error) {
 					toasts.addToast({
 						title: msg('assets.files.upload-failed'),
 						severity: 'error',
 					})
 					console.error(error)
-					return null
+					return
 				}
 			})
 		)
 
-		createShapesForAssets(editor, compact(assets), pagePoint)
+		createShapesForAssets(editor, assets, pagePoint)
 	})
 
 	// text
@@ -466,6 +469,45 @@ export function registerDefaultExternalContentHandlers(
 	})
 }
 
+/** @public */
+export async function getMediaAssetInfoPartial(
+	file: File,
+	assetId: TLAssetId,
+	isImageType: boolean,
+	isVideoType: boolean
+) {
+	let fileType = file.type
+
+	if (file.type === 'video/quicktime') {
+		// hack to make .mov videos work
+		fileType = 'video/mp4'
+	}
+
+	const size = isImageType
+		? await MediaHelpers.getImageSize(file)
+		: await MediaHelpers.getVideoSize(file)
+
+	const isAnimated = (await MediaHelpers.isAnimated(file)) || isVideoType
+
+	const assetInfo = {
+		id: assetId,
+		type: isImageType ? 'image' : 'video',
+		typeName: 'asset',
+		props: {
+			name: file.name,
+			src: '',
+			w: size.w,
+			h: size.h,
+			fileSize: file.size,
+			mimeType: fileType,
+			isAnimated,
+		},
+		meta: {},
+	} as TLAsset
+
+	return assetInfo as TLImageAsset | TLVideoAsset
+}
+
 /**
  * A helper function for an external content handler. It creates bookmarks,
  * images or video shapes corresponding to the type of assets provided.
@@ -491,22 +533,6 @@ export async function createShapesForAssets(
 	for (let i = 0; i < assets.length; i++) {
 		const asset = assets[i]
 		switch (asset.type) {
-			case 'bookmark': {
-				partials.push({
-					id: createShapeId(),
-					type: 'bookmark',
-					x: currentPoint.x,
-					y: currentPoint.y,
-					opacity: 1,
-					props: {
-						assetId: asset.id,
-						url: asset.props.src,
-					},
-				})
-
-				currentPoint.x += 300 // BOOKMARK_WIDTH
-				break
-			}
 			case 'image': {
 				partials.push({
 					id: createShapeId(),

commit b531f2ab9b92980928f112c76e6a6ca45f0ed6c9
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Aug 7 16:16:03 2024 +0200

    Custom embeds API (#4326)
    
    Adds the ability to add your own custom embeds and also to disable some
    of the built in embeds. Also includes [an
    example](https://github.com/tldraw/tldraw/pull/4326/files#diff-3ff116d77a8ba1d316abbc94386266cf875ee34b4fc312e27f54d158849af572).
    
    Few use cases and how you can achieve them:
    * **Remove some (or all) of the built in embeds**: start with the
    `DEFAULT_EMBED_DEFINITIONS` and filter it down to just the ones you
    want. Then pass this to the `Tldraw` or `TldrawEditor` components.
    * **Add a new custom embed on top of the existing ones**: create a new
    `CustomEmbedDefinition` (or an array of them), now create a new array of
    `TLEmbedDefinition` by concatenating `DEFAULT_EMBED_DEFINITIONS` and
    your custom defintions. Pass this to the `Tldraw` or `TldrawEditor`
    components.
    * **Reorder the embeds**: pick the different definitions from
    `DEFAULT_EMBED_DEFINTIONS` and add them to a new array in the order you
    wish the embeds to be displayed. Pass this to the `Tldraw` or
    `TldrawEditor` components.
    * **Change the icon of an existing embed**: there's two options for
    this. 1. You can remove the embed from the `DEFAULT_EMBED_DEFINITIONS`
    then add a new `CustomEmbedDefition` that includes the `icon` field that
    points to the new icon. 2. You can override the asset url just for that
    embed.
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    Adds the ability to customize the embeds that are supported. You can now
    customize or reorder the existing embeds, as well as add completely new
    ones.
    
    ## Breaking changes
    * `EMBED_DEFINITIONS` has been renamed to `DEFAULT_EMBED_DEFINTIONS`
    * `matchEmbedUrl`, `matchUrl`, `getEmbedInfo`, `getEmbedInfoUnsafely`
    now also expect `readonly TLEmbedDefinition[]` as their first parameter.
    If you don't have any custom embeds you can pass in the
    `DEFAULT_EMBED_DEFINITIONS`.
    * `registerExternalContentHandler` and `putExternalContent` have an
    additional generic argument for specifying the type of the embeds that
    the content handle supports. Example on how to update
    [here](https://github.com/tldraw/tldraw/pull/4326/files#diff-51f3e244dba5247299a2153f96348efdca84e0e8fb8fe27cff4443dd9d8d4161R196).
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 7ec503025..12939ee3a 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -20,11 +20,12 @@ import {
 	getHashForBuffer,
 	getHashForString,
 } from '@tldraw/editor'
+import { EmbedDefinition } from './defaultEmbedDefinitions'
+import { EmbedShapeUtil } from './shapes/embed/EmbedShapeUtil'
 import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-shape-constants'
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize } from './utils/assets/assets'
-import { getEmbedInfo } from './utils/embeds/embeds'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
 /** @public */
@@ -86,7 +87,7 @@ export function registerDefaultExternalContentHandlers(
 			`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
 		)
 
-		const hash = await getHashForBuffer(await file.arrayBuffer())
+		const hash = getHashForBuffer(await file.arrayBuffer())
 		const assetId: TLAssetId = AssetRecordType.createId(hash)
 		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
 
@@ -192,31 +193,34 @@ export function registerDefaultExternalContentHandlers(
 	})
 
 	// embeds
-	editor.registerExternalContentHandler('embed', ({ point, url, embed }) => {
-		const position =
-			point ??
-			(editor.inputs.shiftKey
-				? editor.inputs.currentPagePoint
-				: editor.getViewportPageBounds().center)
+	editor.registerExternalContentHandler<'embed', EmbedDefinition>(
+		'embed',
+		({ point, url, embed }) => {
+			const position =
+				point ??
+				(editor.inputs.shiftKey
+					? editor.inputs.currentPagePoint
+					: editor.getViewportPageBounds().center)
 
-		const { width, height } = embed
+			const { width, height } = embed
 
-		const id = createShapeId()
+			const id = createShapeId()
 
-		const shapePartial: TLShapePartial<TLEmbedShape> = {
-			id,
-			type: 'embed',
-			x: position.x - (width || 450) / 2,
-			y: position.y - (height || 450) / 2,
-			props: {
-				w: width,
-				h: height,
-				url,
-			},
-		}
+			const shapePartial: TLShapePartial<TLEmbedShape> = {
+				id,
+				type: 'embed',
+				x: position.x - (width || 450) / 2,
+				y: position.y - (height || 450) / 2,
+				props: {
+					w: width,
+					h: height,
+					url,
+				},
+			}
 
-		editor.createShapes([shapePartial]).select(id)
-	})
+			editor.createShapes([shapePartial]).select(id)
+		}
+	)
 
 	// files
 	editor.registerExternalContentHandler('files', async ({ point, files }) => {
@@ -277,7 +281,7 @@ export function registerDefaultExternalContentHandlers(
 
 			const isImageType = acceptedImageMimeTypes.includes(file.type)
 			const isVideoType = acceptedVideoMimeTypes.includes(file.type)
-			const hash = await getHashForBuffer(await file.arrayBuffer())
+			const hash = getHashForBuffer(await file.arrayBuffer())
 			const assetId: TLAssetId = AssetRecordType.createId(hash)
 			const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
 			let temporaryAssetPreview
@@ -413,7 +417,8 @@ export function registerDefaultExternalContentHandlers(
 	// url
 	editor.registerExternalContentHandler('url', async ({ point, url }) => {
 		// try to paste as an embed first
-		const embedInfo = getEmbedInfo(url)
+		const embedUtil = editor.getShapeUtil('embed') as EmbedShapeUtil | undefined
+		const embedInfo = embedUtil?.getEmbedDefinition(url)
 
 		if (embedInfo) {
 			return editor.putExternalContent({

commit 762359ec4d3c47c2ea2186c5bf3300b8a4d7e93f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Sep 4 13:47:51 2024 +0100

    Use custom mime types in useInsertMedia hook (#4453)
    
    Before this PR, the `useInsertMedia` hook was hard-coded to use our
    default list of supported mime types for uploads. This fixes that by
    passing the user-given list down through context
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Make the 'insert media' action use custom mime type configurations to
    restrict which files can be selected in the picker.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 12939ee3a..42e634a7e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -275,7 +275,7 @@ export function registerDefaultExternalContentHandlers(
 					severity: 'error',
 				})
 
-				console.warn(`${file.name} not loaded - Extension not allowed.`)
+				console.warn(`${file.name} not loaded - Mime type not allowed ${file.type}.`)
 				continue
 			}
 

commit 9ac19fdc55f7a4ca009514143ae80409ccd16de7
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Fri Sep 13 10:12:10 2024 +0100

    paste: fix pasting images from excalidraw (#4462)
    
    I didn't dig into when/where this regressed but we've changed a lot in
    this logic so I'm not surprised.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Pasting: fix image pasting from Excalidraw.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 42e634a7e..6fff9bc04 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -64,7 +64,7 @@ export function registerDefaultExternalContentHandlers(
 	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
 ) {
 	// files -> asset
-	editor.registerExternalAssetHandler('file', async ({ file }) => {
+	editor.registerExternalAssetHandler('file', async ({ file, assetId }) => {
 		const isImageType = acceptedImageMimeTypes.includes(file.type)
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 
@@ -88,7 +88,7 @@ export function registerDefaultExternalContentHandlers(
 		)
 
 		const hash = getHashForBuffer(await file.arrayBuffer())
-		const assetId: TLAssetId = AssetRecordType.createId(hash)
+		assetId = assetId ?? AssetRecordType.createId(hash)
 		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
 
 		if (isFinite(maxImageDimension)) {

commit 9636546a09b34e7519658ae836e4ce76d475fb81
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Oct 5 08:45:57 2024 +0100

    prevent accidental image drops (#4651)
    
    This PR handles a case where users drop images or videos on top of our
    user interface (on tldraw.com).
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fixed a bug where dropping images or other things on user interface
    elements would navigate away from the canvas

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 6fff9bc04..3462627f0 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -626,7 +626,7 @@ export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	// Zoom out to fit the shapes, if necessary
 	selectionPageBounds = editor.getSelectionPageBounds()
 	if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {
-		editor.zoomToSelection()
+		editor.zoomToSelection({ animation: { duration: editor.options.animationMediumMs } })
 	}
 }
 

commit b301aeb64e5ff7bcd55928d7200a39092da8c501
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Oct 23 15:55:42 2024 +0100

    npm: upgrade eslint v8 → v9 (#4757)
    
    As I worked on the i18n PR (https://github.com/tldraw/tldraw/pull/4719)
    I noticed that `react-intl` required a new version of `eslint`. That led
    me down a bit of a rabbit hole of upgrading v8 → v9. There were a couple
    things to upgrade to make this work.
    
    - ran `npx @eslint/migrate-config .eslintrc.js` to upgrade to the new
    `eslint.config.mjs`
    - `.eslintignore` is now deprecated and part of `eslint.config.mjs`
    - some packages are no longer relevant, of note: `eslint-plugin-local`
    and `eslint-plugin-deprecation`
    - the upgrade caught a couple bugs/dead code
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Upgrade eslint v8 → v9
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 3462627f0..fdaa70d5d 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -447,7 +447,7 @@ export function registerDefaultExternalContentHandlers(
 				const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
 				if (!bookmarkAsset) throw Error('Could not create an asset')
 				asset = bookmarkAsset
-			} catch (e) {
+			} catch {
 				toasts.addToast({
 					title: msg('assets.url.failed'),
 					severity: 'error',

commit 106c984c74945d5cba15176dff695ec2a8746308
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Wed Nov 13 11:51:30 2024 +0000

    Snap to grid when creating shapes (#4875)
    
    TLD-2817
    
    TLD-2816
    
    This PR makes sure that shapes snap to the grid when created. It adds a
    ```maybeSnapToGrid``` function, which can be used to push a shape onto
    the grid if grid mode is enabled, both when click-creating and when
    drag-creating.
    
    1. Any shapes using the basebox shape tool (i.e frames)
    2. Geo shapes
    3. Both arrow handles
    4. Line shapes, including shift-clicking
    5. Note shapes (when translating, note shapes prefer adjacent note
    positions over grid)
    6. Text shapes
    7. Aligns uploaded assets using the top left of the selection bounds.
    8. Does not snap to the grid when snap indicators are being shown
    
    It also adds tests for this behaviour
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Enable grid
    9. Click-create a note shape off the grid
    10. It should snap to the grid
    11. Add an asset, it should align with the grid
    
    - [x] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Shapes snap to grid on creation, or when adding points.
    
    ---------
    
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index fdaa70d5d..75671553b 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -622,7 +622,25 @@ export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 			})
 		)
 	}
-
+	selectionPageBounds = editor.getSelectionPageBounds()
+	// align selection with the grid if necessary
+	if (selectionPageBounds && editor.getInstanceState().isGridMode) {
+		const gridSize = editor.getDocumentSettings().gridSize
+		const topLeft = new Vec(selectionPageBounds.minX, selectionPageBounds.minY)
+		const gridSnappedPoint = topLeft.clone().snapToGrid(gridSize)
+		const delta = Vec.Sub(topLeft, gridSnappedPoint)
+		editor.updateShapes(
+			editor.getSelectedShapes().map((shape) => {
+				const newPoint = { x: shape.x! - delta.x, y: shape.y! - delta.y }
+				return {
+					id: shape.id,
+					type: shape.type,
+					x: newPoint.x,
+					y: newPoint.y,
+				}
+			})
+		)
+	}
 	// Zoom out to fit the shapes, if necessary
 	selectionPageBounds = editor.getSelectionPageBounds()
 	if (selectionPageBounds && !viewportPageBounds.contains(selectionPageBounds)) {

commit 5694568e2b2de6c839c8d8bb1fcc7dfe35e7e32e
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Jan 7 10:57:59 2025 +0100

    Fix max image dimension prop not getting applied. (#5176)
    
    The problem was twofold:
    - we weren't awaiting the updating of the assets
    - we used old asset values when creating the shapes.
    
    fixes https://github.com/tldraw/tldraw/issues/5173 / TLD-2910
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. In `develop.tsx` set `maxImageDimension` to some value.
    2. Paste an image.
    3. The image should be within the max dimension.
    
    ### Release notes
    
    - Fix a bug with `maxImageDimension` not getting applied to pasted
    images.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 75671553b..76a6f760a 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -235,7 +235,6 @@ export function registerDefaultExternalContentHandlers(
 				: editor.getViewportPageBounds().center)
 
 		const pagePoint = new Vec(position.x, position.y)
-		const assets: TLAsset[] = []
 		const assetsToUpdate: {
 			asset: TLAsset
 			file: File
@@ -288,11 +287,11 @@ export function registerDefaultExternalContentHandlers(
 			if (isImageType) {
 				temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
 			}
-			assets.push(assetInfo)
 			assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
 		}
 
-		Promise.allSettled(
+		const assets: TLAsset[] = []
+		await Promise.allSettled(
 			assetsToUpdate.map(async (assetAndFile) => {
 				try {
 					const newAsset = await editor.getAssetForExternalContent({
@@ -304,8 +303,10 @@ export function registerDefaultExternalContentHandlers(
 						throw Error('Could not create an asset')
 					}
 
+					const updated = { ...newAsset, id: assetAndFile.asset.id }
+					assets.push(updated)
 					// Save the new asset under the old asset's id
-					editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }])
+					editor.updateAssets([updated])
 				} catch (error) {
 					toasts.addToast({
 						title: msg('assets.files.upload-failed'),

commit 9d961047c9d7f308c94ab6e30a3bef55499d1c9d
Author: Alexander Melnik <47505999+melnikkk@users.noreply.github.com>
Date:   Mon Jan 20 10:21:27 2025 +0100

    Added toast instead of throwing an error for the case when the amount… (#5201)
    
    This PR solves the issue #5188. Throwing an error for the case when a
    user is trying to upload more files than maxFilesAtOnce is replaced with
    toast.
    
    _(for testing purposes and screen recording, I reduced the max amount of
    files)_
    
    https://github.com/user-attachments/assets/b7468fd0-f14f-41c0-96d9-01f7326a0ecd
    
    P.S.: I'm not sure about the correction of the text, so feel free to
    notify me, and I'll change it :)
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - added toast instead of throwing an error for the case when the amount
    of files is bigger than `maxFilesAtOnce`

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 76a6f760a..fe9484f5e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -225,7 +225,9 @@ export function registerDefaultExternalContentHandlers(
 	// files
 	editor.registerExternalContentHandler('files', async ({ point, files }) => {
 		if (files.length > editor.options.maxFilesAtOnce) {
-			throw Error('Too many files')
+			toasts.addToast({ title: msg('assets.files.amount-too-big'), severity: 'error' })
+
+			return
 		}
 
 		const position =

commit 5c4b0489690d5cc4fe1f444c015b9d0fba51f0e8
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Jan 22 14:05:00 2025 +0100

    Asset uploads (#5218)
    
    Changes:
    * We now use the main sync worker for tldraw app asset uploads. For old
    assets we still continue to use the assets worker.
    * Image resize worker is now deployed as part of our deploy dotcom
    action. It receives the multiplayer worker url. If the asset origin is
    same as the multiplayer url (we are fetching tldraw app asset) it uses a
    service binding to request the asset. This is to avoid some permissions
    issues we encountered when the image worker fetched directly from the
    multiplayer worker. The fetching for existing assets should remain the
    same. I added `IMAGE_WORKER` env variable to different environments for
    our github actions.
    * We now associate assets with files. We do this in two ways: 1. when
    users upload the files we immediately add the `fileId` to the asset's
    `meta` property. We then also write an entry into a new postgres table
    called `asset`. 2. in some cases we do this server side (duplicating a
    room, copy pasting tldraw content, slurping legacy multiplayer rooms).
    The way it works is that the server checks all the tldraw app assets and
    makes sure their meta is associated to the correct file. If it is not it
    re-uploads the file to the uploads bucket and it updates the asset. It
    does this when persisting a file and also on restore.
    * There are some public API changes listed that were necessary to make
    this work. They are listed below.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    **Breaking change**
    
    - `@tldraw/tlschema`: `TLAssetStore.upload` used to return just the
    `src` of the uploaded asset. It now returns `{src: string, meta?:
    JsonObject}`. The returned metadata will be added to the asset record
    and thus allows the users to add some additional data to them when
    uploading.
    - `@tldraw/editor`: `Editor.uploadAsset` used to return
    `Promise<string>` and now returns `Promise<{ src: string; meta?:
    JsonObject }> `

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index fe9484f5e..5286a1464 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -100,7 +100,9 @@ export function registerDefaultExternalContentHandlers(
 			}
 		}
 
-		assetInfo.props.src = await editor.uploadAsset(assetInfo, file)
+		const result = await editor.uploadAsset(assetInfo, file)
+		assetInfo.props.src = result.src
+		if (result.meta) assetInfo.meta = { ...assetInfo.meta, ...result.meta }
 
 		return AssetRecordType.create(assetInfo)
 	})

commit 9b13f6b7554c52facf2bd81ce1377ec57a397944
Author: alex <alex@dytry.ch>
Date:   Thu Jan 30 10:34:05 2025 +0000

    separately export default external content/asset handlers (#5298)
    
    Currently, if you want to e.g. augment but not override one of our
    default content handlers (e.g. to add audio file support to pasting),
    you have to copy-paste the entirety of that handler into your app. This
    kind of sucks. Now, you can call our default handlers yourself, so you
    can augment how they work without having to completely re-implement
    them.
    
    For reviewers: it's easiest to read this diff with [whitespace changed
    hidden](https://github.com/tldraw/tldraw/pull/5298/files?diff=split&w=1#diff-51f3e244dba5247299a2153f96348efdca84e0e8fb8fe27cff4443dd9d8d4161)
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    - You can now import each of our external asset/content handlers, so you
    can augment them without having to copy-paste them into your app
    
    #### BREAKING
    - `TLExternalAssetContent` has been renamed to `TLExternalAsset`

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 5286a1464..00185050e 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -1,16 +1,20 @@
 import {
 	AssetRecordType,
+	DEFAULT_SUPPORTED_IMAGE_TYPES,
+	DEFAULT_SUPPORT_VIDEO_TYPES,
 	Editor,
 	MediaHelpers,
 	TLAsset,
 	TLAssetId,
+	TLBookmarkAsset,
 	TLBookmarkShape,
-	TLEmbedShape,
+	TLFileExternalAsset,
 	TLImageAsset,
 	TLShapeId,
 	TLShapePartial,
 	TLTextShape,
 	TLTextShapeProps,
+	TLUrlExternalAsset,
 	TLVideoAsset,
 	Vec,
 	VecLike,
@@ -28,6 +32,17 @@ import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize } from './utils/assets/assets'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
+/**
+ * 5000px
+ * @public
+ */
+export const DEFAULT_MAX_IMAGE_DIMENSION = 5000
+/**
+ * 10mb
+ * @public
+ */
+export const DEFAULT_MAX_ASSET_SIZE = 10 * 1024 * 1024
+
 /** @public */
 export interface TLExternalContentProps {
 	/**
@@ -52,431 +67,501 @@ export interface TLExternalContentProps {
 	acceptedVideoMimeTypes?: readonly string[]
 }
 
+/** @public */
+export interface TLDefaultExternalContentHandlerOpts extends TLExternalContentProps {
+	toasts: TLUiToastsContextType
+	msg: ReturnType<typeof useTranslation>
+}
+
 /** @public */
 export function registerDefaultExternalContentHandlers(
 	editor: Editor,
-	{
-		maxImageDimension,
-		maxAssetSize,
-		acceptedImageMimeTypes,
-		acceptedVideoMimeTypes,
-	}: Required<TLExternalContentProps>,
-	{ toasts, msg }: { toasts: TLUiToastsContextType; msg: ReturnType<typeof useTranslation> }
+	options: TLDefaultExternalContentHandlerOpts
 ) {
 	// files -> asset
-	editor.registerExternalAssetHandler('file', async ({ file, assetId }) => {
-		const isImageType = acceptedImageMimeTypes.includes(file.type)
-		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
+	editor.registerExternalAssetHandler('file', async (externalAsset) => {
+		return defaultHandleExternalFileAsset(editor, externalAsset, options)
+	})
 
-		if (!isImageType && !isVideoType) {
-			toasts.addToast({
-				title: msg('assets.files.type-not-allowed'),
-				severity: 'error',
-			})
-		}
-		assert(isImageType || isVideoType, `File type not allowed: ${file.type}`)
+	// urls -> bookmark asset
+	editor.registerExternalAssetHandler('url', async (externalAsset) => {
+		return defaultHandleExternalUrlAsset(editor, externalAsset, options)
+	})
 
-		if (file.size > maxAssetSize) {
-			toasts.addToast({
-				title: msg('assets.files.size-too-big'),
-				severity: 'error',
-			})
-		}
-		assert(
-			file.size <= maxAssetSize,
-			`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
-		)
+	// svg text
+	editor.registerExternalContentHandler('svg-text', async (externalContent) => {
+		return defaultHandleExternalSvgTextContent(editor, externalContent)
+	})
 
-		const hash = getHashForBuffer(await file.arrayBuffer())
-		assetId = assetId ?? AssetRecordType.createId(hash)
-		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
+	// embeds
+	editor.registerExternalContentHandler<'embed', EmbedDefinition>('embed', (externalContent) => {
+		return defaultHandleExternalEmbedContent(editor, externalContent)
+	})
 
-		if (isFinite(maxImageDimension)) {
-			const size = { w: assetInfo.props.w, h: assetInfo.props.h }
-			const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
-			if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
-				assetInfo.props.w = resizedSize.w
-				assetInfo.props.h = resizedSize.h
-			}
-		}
+	// files
+	editor.registerExternalContentHandler('files', async (externalContent) => {
+		return defaultHandleExternalFileContent(editor, externalContent, options)
+	})
 
-		const result = await editor.uploadAsset(assetInfo, file)
-		assetInfo.props.src = result.src
-		if (result.meta) assetInfo.meta = { ...assetInfo.meta, ...result.meta }
+	// text
+	editor.registerExternalContentHandler('text', async (externalContent) => {
+		return defaultHandleExternalTextContent(editor, externalContent)
+	})
 
-		return AssetRecordType.create(assetInfo)
+	// url
+	editor.registerExternalContentHandler('url', async (externalContent) => {
+		return defaultHandleExternalUrlContent(editor, externalContent, options)
 	})
+}
 
-	// urls -> bookmark asset
-	editor.registerExternalAssetHandler('url', async ({ url }) => {
-		let meta: { image: string; favicon: string; title: string; description: string }
+/** @public */
+export async function defaultHandleExternalFileAsset(
+	editor: Editor,
+	{ file, assetId }: TLFileExternalAsset,
+	{
+		acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
+		acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
+		maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
+		maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION,
+		toasts,
+		msg,
+	}: TLDefaultExternalContentHandlerOpts
+) {
+	const isImageType = acceptedImageMimeTypes.includes(file.type)
+	const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 
-		try {
-			const resp = await fetch(url, {
-				method: 'GET',
-				mode: 'no-cors',
-			})
-			const html = await resp.text()
-			const doc = new DOMParser().parseFromString(html, 'text/html')
-			meta = {
-				image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute('content') ?? '',
-				favicon:
-					doc.head.querySelector('link[rel="apple-touch-icon"]')?.getAttribute('href') ??
-					doc.head.querySelector('link[rel="icon"]')?.getAttribute('href') ??
-					'',
-				title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ?? url,
-				description:
-					doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
-			}
-			if (!meta.image.startsWith('http')) {
-				meta.image = new URL(meta.image, url).href
-			}
-			if (!meta.favicon.startsWith('http')) {
-				meta.favicon = new URL(meta.favicon, url).href
-			}
-		} catch (error) {
-			console.error(error)
-			toasts.addToast({
-				title: msg('assets.url.failed'),
-				severity: 'error',
-			})
-			meta = { image: '', favicon: '', title: '', description: '' }
-		}
+	if (!isImageType && !isVideoType) {
+		toasts.addToast({
+			title: msg('assets.files.type-not-allowed'),
+			severity: 'error',
+		})
+	}
+	assert(isImageType || isVideoType, `File type not allowed: ${file.type}`)
 
-		// Create the bookmark asset from the meta
-		return {
-			id: AssetRecordType.createId(getHashForString(url)),
-			typeName: 'asset',
-			type: 'bookmark',
-			props: {
-				src: url,
-				description: meta.description,
-				image: meta.image,
-				favicon: meta.favicon,
-				title: meta.title,
-			},
-			meta: {},
-		}
-	})
+	if (file.size > maxAssetSize) {
+		toasts.addToast({
+			title: msg('assets.files.size-too-big'),
+			severity: 'error',
+		})
+	}
+	assert(
+		file.size <= maxAssetSize,
+		`File size too big: ${(file.size / 1024).toFixed()}kb > ${(maxAssetSize / 1024).toFixed()}kb`
+	)
 
-	// svg text
-	editor.registerExternalContentHandler('svg-text', async ({ point, text }) => {
-		const position =
-			point ??
-			(editor.inputs.shiftKey
-				? editor.inputs.currentPagePoint
-				: editor.getViewportPageBounds().center)
-
-		const svg = new DOMParser().parseFromString(text, 'image/svg+xml').querySelector('svg')
-		if (!svg) {
-			throw new Error('No <svg/> element present')
+	const hash = getHashForBuffer(await file.arrayBuffer())
+	assetId = assetId ?? AssetRecordType.createId(hash)
+	const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
+
+	if (isFinite(maxImageDimension)) {
+		const size = { w: assetInfo.props.w, h: assetInfo.props.h }
+		const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
+		if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
+			assetInfo.props.w = resizedSize.w
+			assetInfo.props.h = resizedSize.h
 		}
+	}
 
-		let width = parseFloat(svg.getAttribute('width') || '0')
-		let height = parseFloat(svg.getAttribute('height') || '0')
+	const result = await editor.uploadAsset(assetInfo, file)
+	assetInfo.props.src = result.src
+	if (result.meta) assetInfo.meta = { ...assetInfo.meta, ...result.meta }
 
-		if (!(width && height)) {
-			document.body.appendChild(svg)
-			const box = svg.getBoundingClientRect()
-			document.body.removeChild(svg)
+	return AssetRecordType.create(assetInfo)
+}
 
-			width = box.width
-			height = box.height
+/** @public */
+export async function defaultHandleExternalUrlAsset(
+	editor: Editor,
+	{ url }: TLUrlExternalAsset,
+	{ toasts, msg }: TLDefaultExternalContentHandlerOpts
+): Promise<TLBookmarkAsset> {
+	let meta: { image: string; favicon: string; title: string; description: string }
+
+	try {
+		const resp = await fetch(url, {
+			method: 'GET',
+			mode: 'no-cors',
+		})
+		const html = await resp.text()
+		const doc = new DOMParser().parseFromString(html, 'text/html')
+		meta = {
+			image: doc.head.querySelector('meta[property="og:image"]')?.getAttribute('content') ?? '',
+			favicon:
+				doc.head.querySelector('link[rel="apple-touch-icon"]')?.getAttribute('href') ??
+				doc.head.querySelector('link[rel="icon"]')?.getAttribute('href') ??
+				'',
+			title: doc.head.querySelector('meta[property="og:title"]')?.getAttribute('content') ?? url,
+			description:
+				doc.head.querySelector('meta[property="og:description"]')?.getAttribute('content') ?? '',
 		}
-
-		const asset = await editor.getAssetForExternalContent({
-			type: 'file',
-			file: new File([text], 'asset.svg', { type: 'image/svg+xml' }),
+		if (!meta.image.startsWith('http')) {
+			meta.image = new URL(meta.image, url).href
+		}
+		if (!meta.favicon.startsWith('http')) {
+			meta.favicon = new URL(meta.favicon, url).href
+		}
+	} catch (error) {
+		console.error(error)
+		toasts.addToast({
+			title: msg('assets.url.failed'),
+			severity: 'error',
 		})
+		meta = { image: '', favicon: '', title: '', description: '' }
+	}
+
+	// Create the bookmark asset from the meta
+	return {
+		id: AssetRecordType.createId(getHashForString(url)),
+		typeName: 'asset',
+		type: 'bookmark',
+		props: {
+			src: url,
+			description: meta.description,
+			image: meta.image,
+			favicon: meta.favicon,
+			title: meta.title,
+		},
+		meta: {},
+	} as TLBookmarkAsset
+}
+
+/** @public */
+export async function defaultHandleExternalSvgTextContent(
+	editor: Editor,
+	{ point, text }: { point?: VecLike; text: string }
+) {
+	const position =
+		point ??
+		(editor.inputs.shiftKey
+			? editor.inputs.currentPagePoint
+			: editor.getViewportPageBounds().center)
+
+	const svg = new DOMParser().parseFromString(text, 'image/svg+xml').querySelector('svg')
+	if (!svg) {
+		throw new Error('No <svg/> element present')
+	}
+
+	let width = parseFloat(svg.getAttribute('width') || '0')
+	let height = parseFloat(svg.getAttribute('height') || '0')
+
+	if (!(width && height)) {
+		document.body.appendChild(svg)
+		const box = svg.getBoundingClientRect()
+		document.body.removeChild(svg)
 
-		if (!asset) throw Error('Could not create an asset')
+		width = box.width
+		height = box.height
+	}
 
-		createShapesForAssets(editor, [asset], position)
+	const asset = await editor.getAssetForExternalContent({
+		type: 'file',
+		file: new File([text], 'asset.svg', { type: 'image/svg+xml' }),
 	})
 
-	// embeds
-	editor.registerExternalContentHandler<'embed', EmbedDefinition>(
-		'embed',
-		({ point, url, embed }) => {
-			const position =
-				point ??
-				(editor.inputs.shiftKey
-					? editor.inputs.currentPagePoint
-					: editor.getViewportPageBounds().center)
-
-			const { width, height } = embed
-
-			const id = createShapeId()
-
-			const shapePartial: TLShapePartial<TLEmbedShape> = {
-				id,
-				type: 'embed',
-				x: position.x - (width || 450) / 2,
-				y: position.y - (height || 450) / 2,
-				props: {
-					w: width,
-					h: height,
-					url,
-				},
-			}
+	if (!asset) throw Error('Could not create an asset')
+
+	createShapesForAssets(editor, [asset], position)
+}
+
+/** @public */
+export function defaultHandleExternalEmbedContent<T>(
+	editor: Editor,
+	{ point, url, embed }: { point?: VecLike; url: string; embed: T }
+) {
+	const position =
+		point ??
+		(editor.inputs.shiftKey
+			? editor.inputs.currentPagePoint
+			: editor.getViewportPageBounds().center)
+
+	const { width, height } = embed as { width: number; height: number }
+
+	const id = createShapeId()
+
+	const shapePartial: TLShapePartial = {
+		id,
+		type: 'embed',
+		x: position.x - (width || 450) / 2,
+		y: position.y - (height || 450) / 2,
+		props: {
+			w: width,
+			h: height,
+			url,
+		},
+	}
+
+	editor.createShapes([shapePartial]).select(id)
+}
+
+/** @public */
+export async function defaultHandleExternalFileContent(
+	editor: Editor,
+	{ point, files }: { point?: VecLike; files: File[] },
+	{
+		maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
+		acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
+		acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
+		toasts,
+		msg,
+	}: TLDefaultExternalContentHandlerOpts
+) {
+	if (files.length > editor.options.maxFilesAtOnce) {
+		toasts.addToast({ title: msg('assets.files.amount-too-big'), severity: 'error' })
+		return
+	}
+
+	const position =
+		point ??
+		(editor.inputs.shiftKey
+			? editor.inputs.currentPagePoint
+			: editor.getViewportPageBounds().center)
+
+	const pagePoint = new Vec(position.x, position.y)
+	const assetsToUpdate: {
+		asset: TLAsset
+		file: File
+		temporaryAssetPreview?: string
+	}[] = []
+	for (const file of files) {
+		if (file.size > maxAssetSize) {
+			toasts.addToast({
+				title: msg('assets.files.size-too-big'),
+				severity: 'error',
+			})
 
-			editor.createShapes([shapePartial]).select(id)
+			console.warn(
+				`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
+					maxAssetSize / 1024
+				).toFixed()}kb`
+			)
+			continue
 		}
-	)
 
-	// files
-	editor.registerExternalContentHandler('files', async ({ point, files }) => {
-		if (files.length > editor.options.maxFilesAtOnce) {
-			toasts.addToast({ title: msg('assets.files.amount-too-big'), severity: 'error' })
+		// Use mime type instead of file ext, this is because
+		// window.navigator.clipboard does not preserve file names
+		// of copied files.
+		if (!file.type) {
+			toasts.addToast({
+				title: msg('assets.files.upload-failed'),
+				severity: 'error',
+			})
+			console.error('No mime type')
+			continue
+		}
 
-			return
+		// We can only accept certain extensions (either images or a videos)
+		const acceptedTypes = [...acceptedImageMimeTypes, ...acceptedVideoMimeTypes]
+		if (!acceptedTypes.includes(file.type)) {
+			toasts.addToast({
+				title: msg('assets.files.type-not-allowed'),
+				severity: 'error',
+			})
+
+			console.warn(`${file.name} not loaded - Mime type not allowed ${file.type}.`)
+			continue
 		}
 
-		const position =
-			point ??
-			(editor.inputs.shiftKey
-				? editor.inputs.currentPagePoint
-				: editor.getViewportPageBounds().center)
-
-		const pagePoint = new Vec(position.x, position.y)
-		const assetsToUpdate: {
-			asset: TLAsset
-			file: File
-			temporaryAssetPreview?: string
-		}[] = []
-		for (const file of files) {
-			if (file.size > maxAssetSize) {
-				toasts.addToast({
-					title: msg('assets.files.size-too-big'),
-					severity: 'error',
+		const isImageType = acceptedImageMimeTypes.includes(file.type)
+		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
+		const hash = getHashForBuffer(await file.arrayBuffer())
+		const assetId: TLAssetId = AssetRecordType.createId(hash)
+		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
+		let temporaryAssetPreview
+		if (isImageType) {
+			temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
+		}
+		assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
+	}
+
+	const assets: TLAsset[] = []
+	await Promise.allSettled(
+		assetsToUpdate.map(async (assetAndFile) => {
+			try {
+				const newAsset = await editor.getAssetForExternalContent({
+					type: 'file',
+					file: assetAndFile.file,
 				})
 
-				console.warn(
-					`File size too big: ${(file.size / 1024).toFixed()}kb > ${(
-						maxAssetSize / 1024
-					).toFixed()}kb`
-				)
-				continue
-			}
+				if (!newAsset) {
+					throw Error('Could not create an asset')
+				}
 
-			// Use mime type instead of file ext, this is because
-			// window.navigator.clipboard does not preserve file names
-			// of copied files.
-			if (!file.type) {
+				const updated = { ...newAsset, id: assetAndFile.asset.id }
+				assets.push(updated)
+				// Save the new asset under the old asset's id
+				editor.updateAssets([updated])
+			} catch (error) {
 				toasts.addToast({
 					title: msg('assets.files.upload-failed'),
 					severity: 'error',
 				})
-				console.error('No mime type')
-				continue
+				console.error(error)
+				return
 			}
+		})
+	)
 
-			// We can only accept certain extensions (either images or a videos)
-			if (!acceptedImageMimeTypes.concat(acceptedVideoMimeTypes).includes(file.type)) {
-				toasts.addToast({
-					title: msg('assets.files.type-not-allowed'),
-					severity: 'error',
-				})
-
-				console.warn(`${file.name} not loaded - Mime type not allowed ${file.type}.`)
-				continue
-			}
+	createShapesForAssets(editor, assets, pagePoint)
+}
 
-			const isImageType = acceptedImageMimeTypes.includes(file.type)
-			const isVideoType = acceptedVideoMimeTypes.includes(file.type)
-			const hash = getHashForBuffer(await file.arrayBuffer())
-			const assetId: TLAssetId = AssetRecordType.createId(hash)
-			const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
-			let temporaryAssetPreview
-			if (isImageType) {
-				temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
-			}
-			assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
-		}
+/** @public */
+export async function defaultHandleExternalTextContent(
+	editor: Editor,
+	{ point, text }: { point?: VecLike; text: string }
+) {
+	const p =
+		point ??
+		(editor.inputs.shiftKey
+			? editor.inputs.currentPagePoint
+			: editor.getViewportPageBounds().center)
 
-		const assets: TLAsset[] = []
-		await Promise.allSettled(
-			assetsToUpdate.map(async (assetAndFile) => {
-				try {
-					const newAsset = await editor.getAssetForExternalContent({
-						type: 'file',
-						file: assetAndFile.file,
-					})
-
-					if (!newAsset) {
-						throw Error('Could not create an asset')
-					}
-
-					const updated = { ...newAsset, id: assetAndFile.asset.id }
-					assets.push(updated)
-					// Save the new asset under the old asset's id
-					editor.updateAssets([updated])
-				} catch (error) {
-					toasts.addToast({
-						title: msg('assets.files.upload-failed'),
-						severity: 'error',
-					})
-					console.error(error)
-					return
-				}
-			})
-		)
+	const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
 
-		createShapesForAssets(editor, assets, pagePoint)
-	})
+	const textToPaste = cleanupText(text)
 
-	// text
-	editor.registerExternalContentHandler('text', async ({ point, text }) => {
-		const p =
-			point ??
-			(editor.inputs.shiftKey
-				? editor.inputs.currentPagePoint
-				: editor.getViewportPageBounds().center)
-
-		const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
-
-		const textToPaste = cleanupText(text)
-
-		// If we're pasting into a text shape, update the text.
-		const onlySelectedShape = editor.getOnlySelectedShape()
-		if (onlySelectedShape && 'text' in onlySelectedShape.props) {
-			editor.updateShapes([
-				{
-					id: onlySelectedShape.id,
-					type: onlySelectedShape.type,
-					props: {
-						text: textToPaste,
-					},
+	// If we're pasting into a text shape, update the text.
+	const onlySelectedShape = editor.getOnlySelectedShape()
+	if (onlySelectedShape && 'text' in onlySelectedShape.props) {
+		editor.updateShapes([
+			{
+				id: onlySelectedShape.id,
+				type: onlySelectedShape.type,
+				props: {
+					text: textToPaste,
 				},
-			])
+			},
+		])
 
-			return
-		}
+		return
+	}
 
-		// Measure the text with default values
-		let w: number
-		let h: number
-		let autoSize: boolean
-		let align = 'middle' as TLTextShapeProps['textAlign']
+	// Measure the text with default values
+	let w: number
+	let h: number
+	let autoSize: boolean
+	let align = 'middle' as TLTextShapeProps['textAlign']
 
-		const isMultiLine = textToPaste.split('\n').length > 1
+	const isMultiLine = textToPaste.split('\n').length > 1
 
-		// check whether the text contains the most common characters in RTL languages
-		const isRtl = isRightToLeftLanguage(textToPaste)
+	// check whether the text contains the most common characters in RTL languages
+	const isRtl = isRightToLeftLanguage(textToPaste)
 
-		if (isMultiLine) {
-			align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
-		}
+	if (isMultiLine) {
+		align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
+	}
+
+	const rawSize = editor.textMeasure.measureText(textToPaste, {
+		...TEXT_PROPS,
+		fontFamily: FONT_FAMILIES[defaultProps.font],
+		fontSize: FONT_SIZES[defaultProps.size],
+		maxWidth: null,
+	})
+
+	const minWidth = Math.min(
+		isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
+		Math.max(200, editor.getViewportPageBounds().width * 0.9)
+	)
 
-		const rawSize = editor.textMeasure.measureText(textToPaste, {
+	if (rawSize.w > minWidth) {
+		const shrunkSize = editor.textMeasure.measureText(textToPaste, {
 			...TEXT_PROPS,
 			fontFamily: FONT_FAMILIES[defaultProps.font],
 			fontSize: FONT_SIZES[defaultProps.size],
-			maxWidth: null,
+			maxWidth: minWidth,
 		})
+		w = shrunkSize.w
+		h = shrunkSize.h
+		autoSize = false
+		align = isRtl ? 'end' : 'start'
+	} else {
+		// autosize is fine
+		w = rawSize.w
+		h = rawSize.h
+		autoSize = true
+	}
 
-		const minWidth = Math.min(
-			isMultiLine ? editor.getViewportPageBounds().width * 0.9 : 920,
-			Math.max(200, editor.getViewportPageBounds().width * 0.9)
-		)
+	if (p.y - h / 2 < editor.getViewportPageBounds().minY + 40) {
+		p.y = editor.getViewportPageBounds().minY + 40 + h / 2
+	}
 
-		if (rawSize.w > minWidth) {
-			const shrunkSize = editor.textMeasure.measureText(textToPaste, {
-				...TEXT_PROPS,
-				fontFamily: FONT_FAMILIES[defaultProps.font],
-				fontSize: FONT_SIZES[defaultProps.size],
-				maxWidth: minWidth,
+	editor.createShapes<TLTextShape>([
+		{
+			id: createShapeId(),
+			type: 'text',
+			x: p.x - w / 2,
+			y: p.y - h / 2,
+			props: {
+				text: textToPaste,
+				// if the text has more than one line, align it to the left
+				textAlign: align,
+				autoSize,
+				w,
+			},
+		},
+	])
+}
+
+/** @public */
+export async function defaultHandleExternalUrlContent(
+	editor: Editor,
+	{ point, url }: { point?: VecLike; url: string },
+	{ toasts, msg }: TLDefaultExternalContentHandlerOpts
+) {
+	// try to paste as an embed first
+	const embedUtil = editor.getShapeUtil('embed') as EmbedShapeUtil | undefined
+	const embedInfo = embedUtil?.getEmbedDefinition(url)
+
+	if (embedInfo) {
+		return editor.putExternalContent({
+			type: 'embed',
+			url: embedInfo.url,
+			point,
+			embed: embedInfo.definition,
+		})
+	}
+
+	const position =
+		point ??
+		(editor.inputs.shiftKey
+			? editor.inputs.currentPagePoint
+			: editor.getViewportPageBounds().center)
+
+	const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
+	const shape = createEmptyBookmarkShape(editor, url, position)
+
+	// Use an existing asset if we have one, or else else create a new one
+	let asset = editor.getAsset(assetId) as TLAsset
+	let shouldAlsoCreateAsset = false
+	if (!asset) {
+		shouldAlsoCreateAsset = true
+		try {
+			const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
+			if (!bookmarkAsset) throw Error('Could not create an asset')
+			asset = bookmarkAsset
+		} catch {
+			toasts.addToast({
+				title: msg('assets.url.failed'),
+				severity: 'error',
 			})
-			w = shrunkSize.w
-			h = shrunkSize.h
-			autoSize = false
-			align = isRtl ? 'end' : 'start'
-		} else {
-			// autosize is fine
-			w = rawSize.w
-			h = rawSize.h
-			autoSize = true
+			return
 		}
+	}
 
-		if (p.y - h / 2 < editor.getViewportPageBounds().minY + 40) {
-			p.y = editor.getViewportPageBounds().minY + 40 + h / 2
+	editor.run(() => {
+		if (shouldAlsoCreateAsset) {
+			editor.createAssets([asset])
 		}
 
-		editor.createShapes<TLTextShape>([
+		editor.updateShapes([
 			{
-				id: createShapeId(),
-				type: 'text',
-				x: p.x - w / 2,
-				y: p.y - h / 2,
+				id: shape.id,
+				type: shape.type,
 				props: {
-					text: textToPaste,
-					// if the text has more than one line, align it to the left
-					textAlign: align,
-					autoSize,
-					w,
+					assetId: asset.id,
 				},
 			},
 		])
 	})
-
-	// url
-	editor.registerExternalContentHandler('url', async ({ point, url }) => {
-		// try to paste as an embed first
-		const embedUtil = editor.getShapeUtil('embed') as EmbedShapeUtil | undefined
-		const embedInfo = embedUtil?.getEmbedDefinition(url)
-
-		if (embedInfo) {
-			return editor.putExternalContent({
-				type: 'embed',
-				url: embedInfo.url,
-				point,
-				embed: embedInfo.definition,
-			})
-		}
-
-		const position =
-			point ??
-			(editor.inputs.shiftKey
-				? editor.inputs.currentPagePoint
-				: editor.getViewportPageBounds().center)
-
-		const assetId: TLAssetId = AssetRecordType.createId(getHashForString(url))
-		const shape = createEmptyBookmarkShape(editor, url, position)
-
-		// Use an existing asset if we have one, or else else create a new one
-		let asset = editor.getAsset(assetId) as TLAsset
-		let shouldAlsoCreateAsset = false
-		if (!asset) {
-			shouldAlsoCreateAsset = true
-			try {
-				const bookmarkAsset = await editor.getAssetForExternalContent({ type: 'url', url })
-				if (!bookmarkAsset) throw Error('Could not create an asset')
-				asset = bookmarkAsset
-			} catch {
-				toasts.addToast({
-					title: msg('assets.url.failed'),
-					severity: 'error',
-				})
-				return
-			}
-		}
-
-		editor.run(() => {
-			if (shouldAlsoCreateAsset) {
-				editor.createAssets([asset])
-			}
-
-			editor.updateShapes([
-				{
-					id: shape.id,
-					type: shape.type,
-					props: {
-						assetId: asset.id,
-					},
-				},
-			])
-		})
-	})
 }
 
 /** @public */
@@ -653,6 +738,7 @@ export function centerSelectionAroundPoint(editor: Editor, position: VecLike) {
 	}
 }
 
+/** @public */
 export function createEmptyBookmarkShape(
 	editor: Editor,
 	url: string,

commit d14754ca7629205953c00615b2524286a2ec5353
Author: alex <alex@dytry.ch>
Date:   Wed Feb 12 13:53:55 2025 +0000

    Add tldraw and excalidraw to external content types (#5402)
    
    Almost all paste operations currently turn into calls to
    `putExternalContent`, which means they can be customized using
    `registerExternalContentHandler`. tldraw and excalidraw content are
    different: they're handled directly in the clipboard code, and so can't
    be customized.
    
    This diff changes that: these types now have external content handlers,
    and default implementations for how they work. We also add an example
    demonstrating how you can use this API to override pasting of e.g.
    single frame shapes to match how figma handles these (finding a space
    for them instead of pasting them in place).
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    - You can now customize how pasted tldraw and excalidraw content is
    handled with `registerExternalContentHandler`.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 00185050e..10c9e1d69 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -8,6 +8,7 @@ import {
 	TLAssetId,
 	TLBookmarkAsset,
 	TLBookmarkShape,
+	TLContent,
 	TLFileExternalAsset,
 	TLImageAsset,
 	TLShapeId,
@@ -30,6 +31,7 @@ import { FONT_FAMILIES, FONT_SIZES, TEXT_PROPS } from './shapes/shared/default-s
 import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize } from './utils/assets/assets'
+import { putExcalidrawContent } from './utils/excalidraw/putExcalidrawContent'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
 /**
@@ -112,6 +114,16 @@ export function registerDefaultExternalContentHandlers(
 	editor.registerExternalContentHandler('url', async (externalContent) => {
 		return defaultHandleExternalUrlContent(editor, externalContent, options)
 	})
+
+	// tldraw
+	editor.registerExternalContentHandler('tldraw', async (externalContent) => {
+		return defaultHandleExternalTldrawContent(editor, externalContent)
+	})
+
+	// excalidraw
+	editor.registerExternalContentHandler('excalidraw', async (externalContent) => {
+		return defaultHandleExternalExcalidrawContent(editor, externalContent)
+	})
 }
 
 /** @public */
@@ -564,6 +576,43 @@ export async function defaultHandleExternalUrlContent(
 	})
 }
 
+/** @public */
+export async function defaultHandleExternalTldrawContent(
+	editor: Editor,
+	{ point, content }: { point?: VecLike; content: TLContent }
+) {
+	editor.run(() => {
+		const selectionBoundsBefore = editor.getSelectionPageBounds()
+		editor.markHistoryStoppingPoint('paste')
+		editor.putContentOntoCurrentPage(content, {
+			point: point,
+			select: true,
+		})
+		const selectedBoundsAfter = editor.getSelectionPageBounds()
+		if (
+			selectionBoundsBefore &&
+			selectedBoundsAfter &&
+			selectionBoundsBefore?.collides(selectedBoundsAfter)
+		) {
+			// Creates a 'puff' to show content has been pasted
+			editor.updateInstanceState({ isChangingStyle: true })
+			editor.timers.setTimeout(() => {
+				editor.updateInstanceState({ isChangingStyle: false })
+			}, 150)
+		}
+	})
+}
+
+/** @public */
+export async function defaultHandleExternalExcalidrawContent(
+	editor: Editor,
+	{ point, content }: { point?: VecLike; content: any }
+) {
+	editor.run(() => {
+		putExcalidrawContent(editor, content, point)
+	})
+}
+
 /** @public */
 export async function getMediaAssetInfoPartial(
 	file: File,

commit c5400ad6b312d0414115a3b6f07cefb74846dcaa
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Feb 18 13:35:41 2025 +0000

    assets: fix up regression with temporaryAssetPreview (#5453)
    
    Fixes up a regression from https://github.com/tldraw/tldraw/pull/5176
    I missed this during the review that making it synchronous would block
    the temp image view.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fix a regression with temporary image previews while images are
    uploading.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 10c9e1d69..56f77eca1 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -163,16 +163,13 @@ export async function defaultHandleExternalFileAsset(
 
 	const hash = getHashForBuffer(await file.arrayBuffer())
 	assetId = assetId ?? AssetRecordType.createId(hash)
-	const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
-
-	if (isFinite(maxImageDimension)) {
-		const size = { w: assetInfo.props.w, h: assetInfo.props.h }
-		const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
-		if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
-			assetInfo.props.w = resizedSize.w
-			assetInfo.props.h = resizedSize.h
-		}
-	}
+	const assetInfo = await getMediaAssetInfoPartial(
+		file,
+		assetId,
+		isImageType,
+		isVideoType,
+		maxImageDimension
+	)
 
 	const result = await editor.uploadAsset(assetInfo, file)
 	assetInfo.props.src = result.src
@@ -311,6 +308,7 @@ export async function defaultHandleExternalFileContent(
 	{ point, files }: { point?: VecLike; files: File[] },
 	{
 		maxAssetSize = DEFAULT_MAX_ASSET_SIZE,
+		maxImageDimension = DEFAULT_MAX_IMAGE_DIMENSION,
 		acceptedImageMimeTypes = DEFAULT_SUPPORTED_IMAGE_TYPES,
 		acceptedVideoMimeTypes = DEFAULT_SUPPORT_VIDEO_TYPES,
 		toasts,
@@ -329,6 +327,7 @@ export async function defaultHandleExternalFileContent(
 			: editor.getViewportPageBounds().center)
 
 	const pagePoint = new Vec(position.x, position.y)
+	const assetPartials: TLAsset[] = []
 	const assetsToUpdate: {
 		asset: TLAsset
 		file: File
@@ -377,16 +376,22 @@ export async function defaultHandleExternalFileContent(
 		const isVideoType = acceptedVideoMimeTypes.includes(file.type)
 		const hash = getHashForBuffer(await file.arrayBuffer())
 		const assetId: TLAssetId = AssetRecordType.createId(hash)
-		const assetInfo = await getMediaAssetInfoPartial(file, assetId, isImageType, isVideoType)
+		const assetInfo = await getMediaAssetInfoPartial(
+			file,
+			assetId,
+			isImageType,
+			isVideoType,
+			maxImageDimension
+		)
 		let temporaryAssetPreview
 		if (isImageType) {
 			temporaryAssetPreview = editor.createTemporaryAssetPreview(assetId, file)
 		}
+		assetPartials.push(assetInfo)
 		assetsToUpdate.push({ asset: assetInfo, file, temporaryAssetPreview })
 	}
 
-	const assets: TLAsset[] = []
-	await Promise.allSettled(
+	Promise.allSettled(
 		assetsToUpdate.map(async (assetAndFile) => {
 			try {
 				const newAsset = await editor.getAssetForExternalContent({
@@ -398,10 +403,8 @@ export async function defaultHandleExternalFileContent(
 					throw Error('Could not create an asset')
 				}
 
-				const updated = { ...newAsset, id: assetAndFile.asset.id }
-				assets.push(updated)
 				// Save the new asset under the old asset's id
-				editor.updateAssets([updated])
+				editor.updateAssets([{ ...newAsset, id: assetAndFile.asset.id }])
 			} catch (error) {
 				toasts.addToast({
 					title: msg('assets.files.upload-failed'),
@@ -413,7 +416,7 @@ export async function defaultHandleExternalFileContent(
 		})
 	)
 
-	createShapesForAssets(editor, assets, pagePoint)
+	createShapesForAssets(editor, assetPartials, pagePoint)
 }
 
 /** @public */
@@ -618,7 +621,8 @@ export async function getMediaAssetInfoPartial(
 	file: File,
 	assetId: TLAssetId,
 	isImageType: boolean,
-	isVideoType: boolean
+	isVideoType: boolean,
+	maxImageDimension?: number
 ) {
 	let fileType = file.type
 
@@ -647,9 +651,18 @@ export async function getMediaAssetInfoPartial(
 			isAnimated,
 		},
 		meta: {},
-	} as TLAsset
+	} as TLImageAsset | TLVideoAsset
+
+	if (maxImageDimension && isFinite(maxImageDimension)) {
+		const size = { w: assetInfo.props.w, h: assetInfo.props.h }
+		const resizedSize = containBoxSize(size, { w: maxImageDimension, h: maxImageDimension })
+		if (size !== resizedSize && MediaHelpers.isStaticImageType(file.type)) {
+			assetInfo.props.w = resizedSize.w
+			assetInfo.props.h = resizedSize.h
+		}
+	}
 
-	return assetInfo as TLImageAsset | TLVideoAsset
+	return assetInfo
 }
 
 /**

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists↔headers, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster — I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool — can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 56f77eca1..55d63fa4f 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -24,6 +24,7 @@ import {
 	fetch,
 	getHashForBuffer,
 	getHashForString,
+	toRichText,
 } from '@tldraw/editor'
 import { EmbedDefinition } from './defaultEmbedDefinitions'
 import { EmbedShapeUtil } from './shapes/embed/EmbedShapeUtil'
@@ -32,6 +33,7 @@ import { TLUiToastsContextType } from './ui/context/toasts'
 import { useTranslation } from './ui/hooks/useTranslation/useTranslation'
 import { containBoxSize } from './utils/assets/assets'
 import { putExcalidrawContent } from './utils/excalidraw/putExcalidrawContent'
+import { renderRichTextFromHTML } from './utils/text/richText'
 import { cleanupText, isRightToLeftLanguage } from './utils/text/text'
 
 /**
@@ -422,7 +424,7 @@ export async function defaultHandleExternalFileContent(
 /** @public */
 export async function defaultHandleExternalTextContent(
 	editor: Editor,
-	{ point, text }: { point?: VecLike; text: string }
+	{ point, text, html }: { point?: VecLike; text: string; html?: string }
 ) {
 	const p =
 		point ??
@@ -432,23 +434,27 @@ export async function defaultHandleExternalTextContent(
 
 	const defaultProps = editor.getShapeUtil<TLTextShape>('text').getDefaultProps()
 
-	const textToPaste = cleanupText(text)
-
-	// If we're pasting into a text shape, update the text.
-	const onlySelectedShape = editor.getOnlySelectedShape()
-	if (onlySelectedShape && 'text' in onlySelectedShape.props) {
-		editor.updateShapes([
-			{
-				id: onlySelectedShape.id,
-				type: onlySelectedShape.type,
-				props: {
-					text: textToPaste,
-				},
-			},
-		])
-
-		return
-	}
+	const cleanedUpPlaintext = cleanupText(text)
+	const richTextToPaste = html
+		? renderRichTextFromHTML(editor, html)
+		: toRichText(cleanedUpPlaintext)
+
+	// todo: discuss
+	// If we have one shape with rich text selected, update the shape's text.
+	// const onlySelectedShape = editor.getOnlySelectedShape()
+	// if (onlySelectedShape && 'richText' in onlySelectedShape.props) {
+	// 	editor.updateShapes([
+	// 		{
+	// 			id: onlySelectedShape.id,
+	// 			type: onlySelectedShape.type,
+	// 			props: {
+	// 				richText: richTextToPaste,
+	// 			},
+	// 		},
+	// 	])
+
+	// 	return
+	// }
 
 	// Measure the text with default values
 	let w: number
@@ -456,16 +462,19 @@ export async function defaultHandleExternalTextContent(
 	let autoSize: boolean
 	let align = 'middle' as TLTextShapeProps['textAlign']
 
-	const isMultiLine = textToPaste.split('\n').length > 1
+	const htmlToMeasure = html ?? cleanedUpPlaintext.replace(/\n/g, '<br>')
+	const isMultiLine = html
+		? richTextToPaste.content.length > 1
+		: cleanedUpPlaintext.split('\n').length > 1
 
 	// check whether the text contains the most common characters in RTL languages
-	const isRtl = isRightToLeftLanguage(textToPaste)
+	const isRtl = isRightToLeftLanguage(cleanedUpPlaintext)
 
 	if (isMultiLine) {
 		align = isMultiLine ? (isRtl ? 'end' : 'start') : 'middle'
 	}
 
-	const rawSize = editor.textMeasure.measureText(textToPaste, {
+	const rawSize = editor.textMeasure.measureHtml(htmlToMeasure, {
 		...TEXT_PROPS,
 		fontFamily: FONT_FAMILIES[defaultProps.font],
 		fontSize: FONT_SIZES[defaultProps.size],
@@ -478,7 +487,7 @@ export async function defaultHandleExternalTextContent(
 	)
 
 	if (rawSize.w > minWidth) {
-		const shrunkSize = editor.textMeasure.measureText(textToPaste, {
+		const shrunkSize = editor.textMeasure.measureHtml(htmlToMeasure, {
 			...TEXT_PROPS,
 			fontFamily: FONT_FAMILIES[defaultProps.font],
 			fontSize: FONT_SIZES[defaultProps.size],
@@ -506,7 +515,7 @@ export async function defaultHandleExternalTextContent(
 			x: p.x - w / 2,
 			y: p.y - h / 2,
 			props: {
-				text: textToPaste,
+				richText: richTextToPaste,
 				// if the text has more than one line, align it to the left
 				textAlign: align,
 				autoSize,

commit 2544e84b57c47b8bd726385a056617c1470ecb86
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Mar 6 16:32:47 2025 +0000

    Display BrokenAssetIcon when file upload fails (#5552)
    
    rework PR https://github.com/tldraw/tldraw/pull/5031
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Improve UI around failed uploads to show that the asset is broken.
    
    Co-authored-by: kazu <64774307+kazu-2020@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 55d63fa4f..39c9ffc84 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -413,6 +413,7 @@ export async function defaultHandleExternalFileContent(
 					severity: 'error',
 				})
 				console.error(error)
+				editor.deleteAssets([assetAndFile.asset.id])
 				return
 			}
 		})

commit 3ab62f1ff84a3ff8842882b19fd663ea1e089d7d
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Apr 2 11:33:59 2025 +0100

    Make image pasting atomic (#5800)
    
    When you paste images, they are first added to the store, and then
    immediately repositioned. This leads to confusing behavior for people
    using the onAfterCreate side effect because it fires before the image
    has actually finished creating.
    
    
    ### Change type
    
    - [x] `improvement`
    
    
    ### Release notes
    
    - Cleans up image creation side effects, coalescing create + update
    effects into a single create effect.

diff --git a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
index 39c9ffc84..401a65b91 100644
--- a/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
+++ b/packages/tldraw/src/lib/defaultExternalContentHandlers.ts
@@ -739,15 +739,17 @@ export async function createShapesForAssets(
 	editor.run(() => {
 		// Create any assets
 		const assetsToCreate = assets.filter((asset) => !editor.getAsset(asset.id))
-		if (assetsToCreate.length) {
-			editor.createAssets(assetsToCreate)
-		}
 
-		// Create the shapes
-		editor.createShapes(partials).select(...partials.map((p) => p.id))
+		editor.store.atomic(() => {
+			if (assetsToCreate.length) {
+				editor.createAssets(assetsToCreate)
+			}
+			// Create the shapes
+			editor.createShapes(partials).select(...partials.map((p) => p.id))
 
-		// Re-position shapes so that the center of the group is at the provided point
-		centerSelectionAroundPoint(editor, position)
+			// Re-position shapes so that the center of the group is at the provided point
+			centerSelectionAroundPoint(editor, position)
+		})
 	})
 
 	return partials.map((p) => p.id)

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    