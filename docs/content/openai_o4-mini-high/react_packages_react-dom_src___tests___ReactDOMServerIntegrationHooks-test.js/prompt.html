<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js - o4-mini-high</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js</h1>
        <h2>Model: o4-mini-high</h2>
        <p><a href="../../../cases/openai_o4-mini-high/react_packages_react-dom_src___tests___ReactDOMServerIntegrationHooks-test.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js

commit 843b50cbe154bd6559236c3575ae707404292c23
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 14 07:43:00 2020 -0700

    Remove `.internal` from more test suites (#18597)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
new file mode 100644
index 0000000000..9664ea1cac
--- /dev/null
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -0,0 +1,1752 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+
+/* eslint-disable no-func-assign */
+
+'use strict';
+
+const ReactDOMServerIntegrationUtils = require('./utils/ReactDOMServerIntegrationTestUtils');
+
+let React;
+let ReactDOM;
+let ReactDOMServer;
+let ReactTestUtils;
+let Scheduler;
+let useState;
+let useReducer;
+let useEffect;
+let useContext;
+let useCallback;
+let useMemo;
+let useRef;
+let useImperativeHandle;
+let useLayoutEffect;
+let useDebugValue;
+let useOpaqueIdentifier;
+let forwardRef;
+let yieldedValues;
+let yieldValue;
+let clearYields;
+
+function initModules() {
+  // Reset warning cache.
+  jest.resetModuleRegistry();
+
+  React = require('react');
+  ReactDOM = require('react-dom');
+  ReactDOMServer = require('react-dom/server');
+  ReactTestUtils = require('react-dom/test-utils');
+  Scheduler = require('scheduler');
+  useState = React.useState;
+  useReducer = React.useReducer;
+  useEffect = React.useEffect;
+  useContext = React.useContext;
+  useCallback = React.useCallback;
+  useMemo = React.useMemo;
+  useRef = React.useRef;
+  useDebugValue = React.useDebugValue;
+  useImperativeHandle = React.useImperativeHandle;
+  useLayoutEffect = React.useLayoutEffect;
+  useOpaqueIdentifier = React.unstable_useOpaqueIdentifier;
+  forwardRef = React.forwardRef;
+
+  yieldedValues = [];
+  yieldValue = value => {
+    yieldedValues.push(value);
+  };
+  clearYields = () => {
+    const ret = yieldedValues;
+    yieldedValues = [];
+    return ret;
+  };
+
+  // Make them available to the helpers.
+  return {
+    ReactDOM,
+    ReactDOMServer,
+    ReactTestUtils,
+  };
+}
+
+const {
+  resetModules,
+  itRenders,
+  itThrowsWhenRendering,
+  serverRender,
+  streamRender,
+  clientCleanRender,
+  clientRenderOnServerString,
+} = ReactDOMServerIntegrationUtils(initModules);
+
+describe('ReactDOMServerHooks', () => {
+  beforeEach(() => {
+    resetModules();
+  });
+
+  function Text(props) {
+    yieldValue(props.text);
+    return <span>{props.text}</span>;
+  }
+
+  describe('useState', () => {
+    itRenders('basic render', async render => {
+      function Counter(props) {
+        const [count] = useState(0);
+        return <span>Count: {count}</span>;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    itRenders('lazy state initialization', async render => {
+      function Counter(props) {
+        const [count] = useState(() => {
+          return 0;
+        });
+        return <span>Count: {count}</span>;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    it('does not trigger a re-renders when updater is invoked outside current render function', async () => {
+      function UpdateCount({setCount, count, children}) {
+        if (count < 3) {
+          setCount(c => c + 1);
+        }
+        return <span>{children}</span>;
+      }
+      function Counter() {
+        const [count, setCount] = useState(0);
+        return (
+          <div>
+            <UpdateCount setCount={setCount} count={count}>
+              Count: {count}
+            </UpdateCount>
+          </div>
+        );
+      }
+
+      const domNode = await serverRender(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    itThrowsWhenRendering(
+      'if used inside a class component',
+      async render => {
+        class Counter extends React.Component {
+          render() {
+            const [count] = useState(0);
+            return <Text text={count} />;
+          }
+        }
+
+        return render(<Counter />);
+      },
+      'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
+        ' one of the following reasons:\n' +
+        '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
+        '2. You might be breaking the Rules of Hooks\n' +
+        '3. You might have more than one copy of React in the same app\n' +
+        'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',
+    );
+
+    itRenders('multiple times when an updater is called', async render => {
+      function Counter() {
+        const [count, setCount] = useState(0);
+        if (count < 12) {
+          setCount(c => c + 1);
+          setCount(c => c + 1);
+          setCount(c => c + 1);
+        }
+        return <Text text={'Count: ' + count} />;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 12');
+    });
+
+    itRenders('until there are no more new updates', async render => {
+      function Counter() {
+        const [count, setCount] = useState(0);
+        if (count < 3) {
+          setCount(count + 1);
+        }
+        return <span>Count: {count}</span>;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 3');
+    });
+
+    itThrowsWhenRendering(
+      'after too many iterations',
+      async render => {
+        function Counter() {
+          const [count, setCount] = useState(0);
+          setCount(count + 1);
+          return <span>{count}</span>;
+        }
+        return render(<Counter />);
+      },
+      'Too many re-renders. React limits the number of renders to prevent ' +
+        'an infinite loop.',
+    );
+  });
+
+  describe('useReducer', () => {
+    itRenders('with initial state', async render => {
+      function reducer(state, action) {
+        return action === 'increment' ? state + 1 : state;
+      }
+      function Counter() {
+        const [count] = useReducer(reducer, 0);
+        yieldValue('Render: ' + count);
+        return <Text text={count} />;
+      }
+
+      const domNode = await render(<Counter />);
+
+      expect(clearYields()).toEqual(['Render: 0', 0]);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('0');
+    });
+
+    itRenders('lazy initialization', async render => {
+      function reducer(state, action) {
+        return action === 'increment' ? state + 1 : state;
+      }
+      function Counter() {
+        const [count] = useReducer(reducer, 0, c => c + 1);
+        yieldValue('Render: ' + count);
+        return <Text text={count} />;
+      }
+
+      const domNode = await render(<Counter />);
+
+      expect(clearYields()).toEqual(['Render: 1', 1]);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('1');
+    });
+
+    itRenders(
+      'multiple times when updates happen during the render phase',
+      async render => {
+        function reducer(state, action) {
+          return action === 'increment' ? state + 1 : state;
+        }
+        function Counter() {
+          const [count, dispatch] = useReducer(reducer, 0);
+          if (count < 3) {
+            dispatch('increment');
+          }
+          yieldValue('Render: ' + count);
+          return <Text text={count} />;
+        }
+
+        const domNode = await render(<Counter />);
+
+        expect(clearYields()).toEqual([
+          'Render: 0',
+          'Render: 1',
+          'Render: 2',
+          'Render: 3',
+          3,
+        ]);
+        expect(domNode.tagName).toEqual('SPAN');
+        expect(domNode.textContent).toEqual('3');
+      },
+    );
+
+    itRenders(
+      'using reducer passed at time of render, not time of dispatch',
+      async render => {
+        // This test is a bit contrived but it demonstrates a subtle edge case.
+
+        // Reducer A increments by 1. Reducer B increments by 10.
+        function reducerA(state, action) {
+          switch (action) {
+            case 'increment':
+              return state + 1;
+            case 'reset':
+              return 0;
+          }
+        }
+        function reducerB(state, action) {
+          switch (action) {
+            case 'increment':
+              return state + 10;
+            case 'reset':
+              return 0;
+          }
+        }
+
+        function Counter() {
+          const [reducer, setReducer] = useState(() => reducerA);
+          const [count, dispatch] = useReducer(reducer, 0);
+          if (count < 20) {
+            dispatch('increment');
+            // Swap reducers each time we increment
+            if (reducer === reducerA) {
+              setReducer(() => reducerB);
+            } else {
+              setReducer(() => reducerA);
+            }
+          }
+          yieldValue('Render: ' + count);
+          return <Text text={count} />;
+        }
+
+        const domNode = await render(<Counter />);
+
+        expect(clearYields()).toEqual([
+          // The count should increase by alternating amounts of 10 and 1
+          // until we reach 21.
+          'Render: 0',
+          'Render: 10',
+          'Render: 11',
+          'Render: 21',
+          21,
+        ]);
+        expect(domNode.tagName).toEqual('SPAN');
+        expect(domNode.textContent).toEqual('21');
+      },
+    );
+  });
+
+  describe('useMemo', () => {
+    itRenders('basic render', async render => {
+      function CapitalizedText(props) {
+        const text = props.text;
+        const capitalizedText = useMemo(() => {
+          yieldValue(`Capitalize '${text}'`);
+          return text.toUpperCase();
+        }, [text]);
+        return <Text text={capitalizedText} />;
+      }
+
+      const domNode = await render(<CapitalizedText text="hello" />);
+      expect(clearYields()).toEqual(["Capitalize 'hello'", 'HELLO']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('HELLO');
+    });
+
+    itRenders('if no inputs are provided', async render => {
+      function LazyCompute(props) {
+        const computed = useMemo(props.compute);
+        return <Text text={computed} />;
+      }
+
+      function computeA() {
+        yieldValue('compute A');
+        return 'A';
+      }
+
+      const domNode = await render(<LazyCompute compute={computeA} />);
+      expect(clearYields()).toEqual(['compute A', 'A']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('A');
+    });
+
+    itRenders(
+      'multiple times when updates happen during the render phase',
+      async render => {
+        function CapitalizedText(props) {
+          const [text, setText] = useState(props.text);
+          const capitalizedText = useMemo(() => {
+            yieldValue(`Capitalize '${text}'`);
+            return text.toUpperCase();
+          }, [text]);
+
+          if (text === 'hello') {
+            setText('hello, world.');
+          }
+          return <Text text={capitalizedText} />;
+        }
+
+        const domNode = await render(<CapitalizedText text="hello" />);
+        expect(clearYields()).toEqual([
+          "Capitalize 'hello'",
+          "Capitalize 'hello, world.'",
+          'HELLO, WORLD.',
+        ]);
+        expect(domNode.tagName).toEqual('SPAN');
+        expect(domNode.textContent).toEqual('HELLO, WORLD.');
+      },
+    );
+
+    itRenders(
+      'should only invoke the memoized function when the inputs change',
+      async render => {
+        function CapitalizedText(props) {
+          const [text, setText] = useState(props.text);
+          const [count, setCount] = useState(0);
+          const capitalizedText = useMemo(() => {
+            yieldValue(`Capitalize '${text}'`);
+            return text.toUpperCase();
+          }, [text]);
+
+          yieldValue(count);
+
+          if (count < 3) {
+            setCount(count + 1);
+          }
+
+          if (text === 'hello' && count === 2) {
+            setText('hello, world.');
+          }
+          return <Text text={capitalizedText} />;
+        }
+
+        const domNode = await render(<CapitalizedText text="hello" />);
+        expect(clearYields()).toEqual([
+          "Capitalize 'hello'",
+          0,
+          1,
+          2,
+          // `capitalizedText` only recomputes when the text has changed
+          "Capitalize 'hello, world.'",
+          3,
+          'HELLO, WORLD.',
+        ]);
+        expect(domNode.tagName).toEqual('SPAN');
+        expect(domNode.textContent).toEqual('HELLO, WORLD.');
+      },
+    );
+
+    itRenders('with a warning for useState inside useMemo', async render => {
+      function App() {
+        useMemo(() => {
+          useState();
+          return 0;
+        });
+        return 'hi';
+      }
+
+      const domNode = await render(<App />, 1);
+      expect(domNode.textContent).toEqual('hi');
+    });
+
+    itThrowsWhenRendering(
+      'with a warning for useRef inside useReducer',
+      async render => {
+        function App() {
+          const [value, dispatch] = useReducer((state, action) => {
+            useRef(0);
+            return state + 1;
+          }, 0);
+          if (value === 0) {
+            dispatch();
+          }
+          return value;
+        }
+
+        const domNode = await render(<App />, 1);
+        expect(domNode.textContent).toEqual('1');
+      },
+      'Rendered more hooks than during the previous render',
+    );
+
+    itRenders('with a warning for useRef inside useState', async render => {
+      function App() {
+        const [value] = useState(() => {
+          useRef(0);
+          return 0;
+        });
+        return value;
+      }
+
+      const domNode = await render(<App />, 1);
+      expect(domNode.textContent).toEqual('0');
+    });
+  });
+
+  describe('useRef', () => {
+    itRenders('basic render', async render => {
+      function Counter(props) {
+        const count = useRef(0);
+        return <span>Count: {count.current}</span>;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    itRenders(
+      'multiple times when updates happen during the render phase',
+      async render => {
+        function Counter(props) {
+          const [count, setCount] = useState(0);
+          const ref = useRef(count);
+
+          if (count < 3) {
+            const newCount = count + 1;
+
+            ref.current = newCount;
+            setCount(newCount);
+          }
+
+          yieldValue(count);
+
+          return <span>Count: {ref.current}</span>;
+        }
+
+        const domNode = await render(<Counter />);
+        expect(clearYields()).toEqual([0, 1, 2, 3]);
+        expect(domNode.textContent).toEqual('Count: 3');
+      },
+    );
+
+    itRenders(
+      'always return the same reference through multiple renders',
+      async render => {
+        let firstRef = null;
+        function Counter(props) {
+          const [count, setCount] = useState(0);
+          const ref = useRef(count);
+          if (firstRef === null) {
+            firstRef = ref;
+          } else if (firstRef !== ref) {
+            throw new Error('should never change');
+          }
+
+          if (count < 3) {
+            setCount(count + 1);
+          } else {
+            firstRef = null;
+          }
+
+          yieldValue(count);
+
+          return <span>Count: {ref.current}</span>;
+        }
+
+        const domNode = await render(<Counter />);
+        expect(clearYields()).toEqual([0, 1, 2, 3]);
+        expect(domNode.textContent).toEqual('Count: 0');
+      },
+    );
+  });
+
+  describe('useEffect', () => {
+    const yields = [];
+    itRenders('should ignore effects on the server', async render => {
+      function Counter(props) {
+        useEffect(() => {
+          yieldValue('invoked on client');
+        });
+        return <Text text={'Count: ' + props.count} />;
+      }
+
+      const domNode = await render(<Counter count={0} />);
+      yields.push(clearYields());
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    it('verifies yields in order', () => {
+      expect(yields).toEqual([
+        ['Count: 0'], // server render
+        ['Count: 0'], // server stream
+        ['Count: 0', 'invoked on client'], // clean render
+        ['Count: 0', 'invoked on client'], // hydrated render
+        // nothing yielded for bad markup
+      ]);
+    });
+  });
+
+  describe('useCallback', () => {
+    itRenders('should ignore callbacks on the server', async render => {
+      function Counter(props) {
+        useCallback(() => {
+          yieldValue('should not be invoked');
+        });
+        return <Text text={'Count: ' + props.count} />;
+      }
+      const domNode = await render(<Counter count={0} />);
+      expect(clearYields()).toEqual(['Count: 0']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+
+    itRenders('should support render time callbacks', async render => {
+      function Counter(props) {
+        const renderCount = useCallback(increment => {
+          return 'Count: ' + (props.count + increment);
+        });
+        return <Text text={renderCount(3)} />;
+      }
+      const domNode = await render(<Counter count={2} />);
+      expect(clearYields()).toEqual(['Count: 5']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 5');
+    });
+  });
+
+  describe('useImperativeHandle', () => {
+    it('should not be invoked on the server', async () => {
+      function Counter(props, ref) {
+        useImperativeHandle(ref, () => {
+          throw new Error('should not be invoked');
+        });
+        return <Text text={props.label + ': ' + ref.current} />;
+      }
+      Counter = forwardRef(Counter);
+      const counter = React.createRef();
+      counter.current = 0;
+      const domNode = await serverRender(
+        <Counter label="Count" ref={counter} />,
+      );
+      expect(clearYields()).toEqual(['Count: 0']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+  });
+
+  describe('useLayoutEffect', () => {
+    it('should warn when invoked during render', async () => {
+      function Counter() {
+        useLayoutEffect(() => {
+          throw new Error('should not be invoked');
+        });
+
+        return <Text text="Count: 0" />;
+      }
+      const domNode = await serverRender(<Counter />, 1);
+      expect(clearYields()).toEqual(['Count: 0']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+  });
+
+  describe('useContext', () => {
+    itThrowsWhenRendering(
+      'if used inside a class component',
+      async render => {
+        const Context = React.createContext({}, () => {});
+        class Counter extends React.Component {
+          render() {
+            const [count] = useContext(Context);
+            return <Text text={count} />;
+          }
+        }
+
+        return render(<Counter />);
+      },
+      'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
+        ' one of the following reasons:\n' +
+        '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
+        '2. You might be breaking the Rules of Hooks\n' +
+        '3. You might have more than one copy of React in the same app\n' +
+        'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',
+    );
+  });
+
+  itRenders(
+    'can use the same context multiple times in the same function',
+    async render => {
+      const Context = React.createContext({foo: 0, bar: 0, baz: 0});
+
+      function Provider(props) {
+        return (
+          <Context.Provider
+            value={{foo: props.foo, bar: props.bar, baz: props.baz}}>
+            {props.children}
+          </Context.Provider>
+        );
+      }
+
+      function FooAndBar() {
+        const {foo} = useContext(Context);
+        const {bar} = useContext(Context);
+        return <Text text={`Foo: ${foo}, Bar: ${bar}`} />;
+      }
+
+      function Baz() {
+        const {baz} = useContext(Context);
+        return <Text text={'Baz: ' + baz} />;
+      }
+
+      class Indirection extends React.Component {
+        render() {
+          return this.props.children;
+        }
+      }
+
+      function App(props) {
+        return (
+          <div>
+            <Provider foo={props.foo} bar={props.bar} baz={props.baz}>
+              <Indirection>
+                <Indirection>
+                  <FooAndBar />
+                </Indirection>
+                <Indirection>
+                  <Baz />
+                </Indirection>
+              </Indirection>
+            </Provider>
+          </div>
+        );
+      }
+
+      const domNode = await render(<App foo={1} bar={3} baz={5} />);
+      expect(clearYields()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
+      expect(domNode.childNodes.length).toBe(2);
+      expect(domNode.firstChild.tagName).toEqual('SPAN');
+      expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');
+      expect(domNode.lastChild.tagName).toEqual('SPAN');
+      expect(domNode.lastChild.textContent).toEqual('Baz: 5');
+    },
+  );
+
+  itRenders('warns when bitmask is passed to useContext', async render => {
+    const Context = React.createContext('Hi');
+
+    function Foo() {
+      return <span>{useContext(Context, 1)}</span>;
+    }
+
+    const domNode = await render(<Foo />, 1);
+    expect(domNode.textContent).toBe('Hi');
+  });
+
+  describe('useDebugValue', () => {
+    itRenders('is a noop', async render => {
+      function Counter(props) {
+        const debugValue = useDebugValue(123);
+        return <Text text={typeof debugValue} />;
+      }
+
+      const domNode = await render(<Counter />);
+      expect(domNode.textContent).toEqual('undefined');
+    });
+  });
+
+  describe('readContext', () => {
+    function readContext(Context, observedBits) {
+      const dispatcher =
+        React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
+          .ReactCurrentDispatcher.current;
+      return dispatcher.readContext(Context, observedBits);
+    }
+
+    itRenders(
+      'can read the same context multiple times in the same function',
+      async render => {
+        const Context = React.createContext(
+          {foo: 0, bar: 0, baz: 0},
+          (a, b) => {
+            let result = 0;
+            if (a.foo !== b.foo) {
+              result |= 0b001;
+            }
+            if (a.bar !== b.bar) {
+              result |= 0b010;
+            }
+            if (a.baz !== b.baz) {
+              result |= 0b100;
+            }
+            return result;
+          },
+        );
+
+        function Provider(props) {
+          return (
+            <Context.Provider
+              value={{foo: props.foo, bar: props.bar, baz: props.baz}}>
+              {props.children}
+            </Context.Provider>
+          );
+        }
+
+        function FooAndBar() {
+          const {foo} = readContext(Context, 0b001);
+          const {bar} = readContext(Context, 0b010);
+          return <Text text={`Foo: ${foo}, Bar: ${bar}`} />;
+        }
+
+        function Baz() {
+          const {baz} = readContext(Context, 0b100);
+          return <Text text={'Baz: ' + baz} />;
+        }
+
+        class Indirection extends React.Component {
+          shouldComponentUpdate() {
+            return false;
+          }
+          render() {
+            return this.props.children;
+          }
+        }
+
+        function App(props) {
+          return (
+            <div>
+              <Provider foo={props.foo} bar={props.bar} baz={props.baz}>
+                <Indirection>
+                  <Indirection>
+                    <FooAndBar />
+                  </Indirection>
+                  <Indirection>
+                    <Baz />
+                  </Indirection>
+                </Indirection>
+              </Provider>
+            </div>
+          );
+        }
+
+        const domNode = await render(<App foo={1} bar={3} baz={5} />);
+        expect(clearYields()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
+        expect(domNode.childNodes.length).toBe(2);
+        expect(domNode.firstChild.tagName).toEqual('SPAN');
+        expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');
+        expect(domNode.lastChild.tagName).toEqual('SPAN');
+        expect(domNode.lastChild.textContent).toEqual('Baz: 5');
+      },
+    );
+
+    itRenders('with a warning inside useMemo and useReducer', async render => {
+      const Context = React.createContext(42);
+
+      function ReadInMemo(props) {
+        const count = React.useMemo(() => readContext(Context), []);
+        return <Text text={count} />;
+      }
+
+      function ReadInReducer(props) {
+        const [count, dispatch] = React.useReducer(() => readContext(Context));
+        if (count !== 42) {
+          dispatch();
+        }
+        return <Text text={count} />;
+      }
+
+      const domNode1 = await render(<ReadInMemo />, 1);
+      expect(domNode1.textContent).toEqual('42');
+
+      const domNode2 = await render(<ReadInReducer />, 1);
+      expect(domNode2.textContent).toEqual('42');
+    });
+  });
+
+  if (__EXPERIMENTAL__) {
+    describe('useOpaqueIdentifier', () => {
+      it('generates unique ids for server string render', async () => {
+        function App(props) {
+          const idOne = useOpaqueIdentifier();
+          const idTwo = useOpaqueIdentifier();
+          return (
+            <div>
+              <div aria-labelledby={idOne} />
+              <div id={idOne} />
+              <span aria-labelledby={idTwo} />
+              <span id={idTwo} />
+            </div>
+          );
+        }
+
+        const domNode = await serverRender(<App />);
+        expect(domNode.children.length).toEqual(4);
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[1].getAttribute('id'),
+        );
+        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[3].getAttribute('id'),
+        );
+        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        );
+        expect(
+          domNode.children[0].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+        expect(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+      });
+
+      it('generates unique ids for server stream render', async () => {
+        function App(props) {
+          const idOne = useOpaqueIdentifier();
+          const idTwo = useOpaqueIdentifier();
+          return (
+            <div>
+              <div aria-labelledby={idOne} />
+              <div id={idOne} />
+              <span aria-labelledby={idTwo} />
+              <span id={idTwo} />
+            </div>
+          );
+        }
+
+        const domNode = await streamRender(<App />);
+        expect(domNode.children.length).toEqual(4);
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[1].getAttribute('id'),
+        );
+        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[3].getAttribute('id'),
+        );
+        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        );
+        expect(
+          domNode.children[0].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+        expect(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+      });
+
+      it('generates unique ids for client render', async () => {
+        function App(props) {
+          const idOne = useOpaqueIdentifier();
+          const idTwo = useOpaqueIdentifier();
+          return (
+            <div>
+              <div aria-labelledby={idOne} />
+              <div id={idOne} />
+              <span aria-labelledby={idTwo} />
+              <span id={idTwo} />
+            </div>
+          );
+        }
+
+        const domNode = await clientCleanRender(<App />);
+        expect(domNode.children.length).toEqual(4);
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[1].getAttribute('id'),
+        );
+        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[3].getAttribute('id'),
+        );
+        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        );
+        expect(
+          domNode.children[0].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+        expect(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+      });
+
+      it('generates unique ids for client render on good server markup', async () => {
+        function App(props) {
+          const idOne = useOpaqueIdentifier();
+          const idTwo = useOpaqueIdentifier();
+          return (
+            <div>
+              <div aria-labelledby={idOne} />
+              <div id={idOne} />
+              <span aria-labelledby={idTwo} />
+              <span id={idTwo} />
+            </div>
+          );
+        }
+
+        const domNode = await clientRenderOnServerString(<App />);
+        expect(domNode.children.length).toEqual(4);
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[1].getAttribute('id'),
+        );
+        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[3].getAttribute('id'),
+        );
+        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        );
+        expect(
+          domNode.children[0].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+        expect(
+          domNode.children[2].getAttribute('aria-labelledby'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier does not change id even if the component updates during client render', async () => {
+        let _setShowId;
+        function App() {
+          const id = useOpaqueIdentifier();
+          const [showId, setShowId] = useState(false);
+          _setShowId = setShowId;
+          return (
+            <div>
+              <div aria-labelledby={id} />
+              {showId && <div id={id} />}
+            </div>
+          );
+        }
+
+        const domNode = await clientCleanRender(<App />);
+        const oldClientId = domNode.children[0].getAttribute('aria-labelledby');
+
+        expect(domNode.children.length).toEqual(1);
+        expect(oldClientId).not.toBeNull();
+
+        await ReactTestUtils.act(async () => _setShowId(true));
+
+        expect(domNode.children.length).toEqual(2);
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          domNode.children[1].getAttribute('id'),
+        );
+        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+          oldClientId,
+        );
+      });
+
+      it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
+        let _setShowDiv;
+        function App() {
+          const id = useOpaqueIdentifier();
+          const [showDiv, setShowDiv] = useState(false);
+          _setShowDiv = setShowDiv;
+
+          return (
+            <div>
+              <div id={id}>Child One</div>
+              {showDiv && <div id={id}>Child Two</div>}
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        root.render(<App />);
+        Scheduler.unstable_flushAll();
+        jest.runAllTimers();
+
+        expect(container.children[0].children.length).toEqual(1);
+        const oldServerId = container.children[0].children[0].getAttribute(
+          'id',
+        );
+        expect(oldServerId).not.toBeNull();
+
+        await ReactTestUtils.act(async () => {
+          _setShowDiv(true);
+        });
+        expect(container.children[0].children.length).toEqual(2);
+        expect(container.children[0].children[0].getAttribute('id')).toEqual(
+          container.children[0].children[1].getAttribute('id'),
+        );
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toEqual(oldServerId);
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered for legacy', async () => {
+        let _setShowDiv;
+        function App() {
+          const id = useOpaqueIdentifier();
+          const [showDiv, setShowDiv] = useState(false);
+          _setShowDiv = setShowDiv;
+
+          return (
+            <div>
+              <div id={id}>Child One</div>
+              {showDiv && <div id={id}>Child Two</div>}
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        ReactDOM.hydrate(<App />, container);
+
+        expect(container.children[0].children.length).toEqual(1);
+        const oldServerId = container.children[0].children[0].getAttribute(
+          'id',
+        );
+        expect(oldServerId).not.toBeNull();
+
+        await ReactTestUtils.act(async () => {
+          _setShowDiv(true);
+        });
+        expect(container.children[0].children.length).toEqual(2);
+        expect(container.children[0].children[0].getAttribute('id')).toEqual(
+          container.children[0].children[1].getAttribute('id'),
+        );
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toEqual(oldServerId);
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier: ID is not used during hydration but is used in an update', async () => {
+        let _setShow;
+        function App({unused}) {
+          Scheduler.unstable_yieldValue('App');
+          const id = useOpaqueIdentifier();
+          const [show, setShow] = useState(false);
+          _setShow = setShow;
+          return (
+            <div>
+              <span id={show ? id : null}>{'Child One'}</span>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        ReactTestUtils.act(() => {
+          root.render(<App />);
+        });
+        expect(Scheduler).toHaveYielded(['App', 'App']);
+        // The ID goes from not being used to being added to the page
+        ReactTestUtils.act(() => {
+          _setShow(true);
+        });
+        expect(Scheduler).toHaveYielded(['App', 'App']);
+        expect(
+          container.getElementsByTagName('span')[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier: ID is not used during hydration but is used in an update in legacy', async () => {
+        let _setShow;
+        function App({unused}) {
+          Scheduler.unstable_yieldValue('App');
+          const id = useOpaqueIdentifier();
+          const [show, setShow] = useState(false);
+          _setShow = setShow;
+          return (
+            <div>
+              <span id={show ? id : null}>{'Child One'}</span>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        ReactDOM.hydrate(<App />, container);
+        expect(Scheduler).toHaveYielded(['App', 'App']);
+        // The ID goes from not being used to being added to the page
+        ReactTestUtils.act(() => {
+          _setShow(true);
+        });
+        expect(Scheduler).toHaveYielded(['App']);
+        expect(
+          container.getElementsByTagName('span')[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifierr: flushSync', async () => {
+        let _setShow;
+        function App() {
+          const id = useOpaqueIdentifier();
+          const [show, setShow] = useState(false);
+          _setShow = setShow;
+          return (
+            <div>
+              <span id={show ? id : null}>{'Child One'}</span>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        ReactTestUtils.act(() => {
+          root.render(<App />);
+        });
+
+        // The ID goes from not being used to being added to the page
+        ReactTestUtils.act(() => {
+          ReactDOM.flushSync(() => {
+            _setShow(true);
+          });
+        });
+        expect(
+          container.getElementsByTagName('span')[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier: children with id hydrates before other children if ID updates', async () => {
+        let _setShow;
+
+        const child1Ref = React.createRef();
+        const childWithIDRef = React.createRef();
+        const setShowRef = React.createRef();
+
+        // RENAME THESE
+        function Child1() {
+          Scheduler.unstable_yieldValue('Child One');
+          return <span ref={child1Ref}>{'Child One'}</span>;
+        }
+
+        function Child2() {
+          Scheduler.unstable_yieldValue('Child Two');
+          return <span>{'Child Two'}</span>;
+        }
+
+        const Children = React.memo(function Children() {
+          return (
+            <React.Suspense fallback="Loading 1...">
+              <Child1 />
+              <Child2 />
+            </React.Suspense>
+          );
+        });
+
+        function ChildWithID({parentID}) {
+          Scheduler.unstable_yieldValue('Child with ID');
+          return (
+            <span id={parentID} ref={childWithIDRef}>
+              {'Child with ID'}
+            </span>
+          );
+        }
+
+        const ChildrenWithID = React.memo(function ChildrenWithID({parentID}) {
+          return (
+            <React.Suspense fallback="Loading 2...">
+              <ChildWithID parentID={parentID} />
+            </React.Suspense>
+          );
+        });
+
+        function App() {
+          const id = useOpaqueIdentifier();
+          const [show, setShow] = useState(false);
+          _setShow = setShow;
+          return (
+            <div>
+              <Children />
+              <ChildrenWithID parentID={id} />
+              {show && (
+                <span aria-labelledby={id} ref={setShowRef}>
+                  {'Child Three'}
+                </span>
+              )}
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        expect(Scheduler).toHaveYielded([
+          'Child One',
+          'Child Two',
+          'Child with ID',
+        ]);
+        expect(container.textContent).toEqual(
+          'Child OneChild TwoChild with ID',
+        );
+
+        const serverId = container
+          .getElementsByTagName('span')[2]
+          .getAttribute('id');
+        expect(serverId).not.toBeNull();
+
+        const childOneSpan = container.getElementsByTagName('span')[0];
+
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        root.render(<App show={false} />);
+        expect(Scheduler).toHaveYielded([]);
+
+        //Hydrate just child one before updating state
+        expect(Scheduler).toFlushAndYieldThrough(['Child One']);
+        expect(child1Ref.current).toBe(null);
+        expect(Scheduler).toHaveYielded([]);
+
+        ReactTestUtils.act(() => {
+          _setShow(true);
+
+          // State update should trigger the ID to update, which changes the props
+          // of ChildWithID. This should cause ChildWithID to hydrate before Children
+
+          expect(Scheduler).toFlushAndYieldThrough(
+            __DEV__
+              ? [
+                  'Child with ID',
+                  // Fallbacks are immdiately committed in TestUtils version
+                  // of act
+                  // 'Child with ID',
+                  // 'Child with ID',
+                  'Child One',
+                  'Child Two',
+                ]
+              : [
+                  'Child with ID',
+                  'Child with ID',
+                  'Child with ID',
+                  'Child One',
+                  'Child Two',
+                ],
+          );
+
+          expect(child1Ref.current).toBe(null);
+          expect(childWithIDRef.current).toEqual(
+            container.getElementsByTagName('span')[2],
+          );
+
+          expect(setShowRef.current).toEqual(
+            container.getElementsByTagName('span')[3],
+          );
+
+          expect(childWithIDRef.current.getAttribute('id')).toEqual(
+            setShowRef.current.getAttribute('aria-labelledby'),
+          );
+          expect(childWithIDRef.current.getAttribute('id')).not.toEqual(
+            serverId,
+          );
+        });
+
+        // Children hydrates after ChildWithID
+        expect(child1Ref.current).toBe(childOneSpan);
+
+        Scheduler.unstable_flushAll();
+
+        expect(Scheduler).toHaveYielded([]);
+      });
+
+      it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
+        let suspend = true;
+        let resolve;
+        const promise = new Promise(
+          resolvePromise => (resolve = resolvePromise),
+        );
+
+        function Child({text}) {
+          if (suspend) {
+            throw promise;
+          } else {
+            return text;
+          }
+        }
+
+        function RenderedChild() {
+          useEffect(() => {
+            Scheduler.unstable_yieldValue('Child did commit');
+          });
+          return null;
+        }
+
+        function App() {
+          const id = useOpaqueIdentifier();
+          useEffect(() => {
+            Scheduler.unstable_yieldValue('Did commit');
+          });
+          return (
+            <div>
+              <div id={id}>Child One</div>
+              <RenderedChild />
+              <React.Suspense fallback={'Fallback'}>
+                <div id={id}>
+                  <Child text="Child Two" />
+                </div>
+              </React.Suspense>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+        suspend = true;
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        await ReactTestUtils.act(async () => {
+          root.render(<App />);
+        });
+        jest.runAllTimers();
+        expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
+        expect(Scheduler).toFlushAndYield([]);
+
+        const serverId = container.children[0].children[0].getAttribute('id');
+        expect(container.children[0].children.length).toEqual(1);
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toBeNull();
+
+        await ReactTestUtils.act(async () => {
+          suspend = false;
+          resolve();
+          await promise;
+        });
+
+        expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
+        expect(Scheduler).toFlushAndYield([]);
+        jest.runAllTimers();
+
+        expect(container.children[0].children.length).toEqual(2);
+        expect(container.children[0].children[0].getAttribute('id')).toEqual(
+          container.children[0].children[1].getAttribute('id'),
+        );
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toEqual(serverId);
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier warn when there is a hydration error', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <Child appId={id} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        // This is the wrong HTML string
+        container.innerHTML = '<span></span>';
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(),
+        ).toErrorDev([
+          'Warning: Expected server HTML to contain a matching <div> in <div>.',
+        ]);
+      });
+
+      it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
+        let suspend = true;
+
+        function Child({text}) {
+          if (suspend) {
+            throw new Promise(() => {});
+          } else {
+            return text;
+          }
+        }
+
+        function RenderedChild() {
+          useEffect(() => {
+            Scheduler.unstable_yieldValue('Child did commit');
+          });
+          return null;
+        }
+
+        function App() {
+          const id = useOpaqueIdentifier();
+          useEffect(() => {
+            Scheduler.unstable_yieldValue('Did commit');
+          });
+          return (
+            <div>
+              <div id={id}>Child One</div>
+              <RenderedChild />
+              <React.Suspense fallback={'Fallback'}>
+                <div id={id}>
+                  <Child text="Child Two" />
+                </div>
+              </React.Suspense>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+        suspend = false;
+        const root = ReactDOM.createRoot(container, {hydrate: true});
+        await ReactTestUtils.act(async () => {
+          root.render(<App />);
+        });
+        jest.runAllTimers();
+        expect(Scheduler).toHaveYielded([
+          'Child did commit',
+          'Did commit',
+          'Child did commit',
+          'Did commit',
+        ]);
+        expect(Scheduler).toFlushAndYield([]);
+
+        expect(container.children[0].children.length).toEqual(2);
+        expect(container.children[0].children[0].getAttribute('id')).toEqual(
+          container.children[0].children[1].getAttribute('id'),
+        );
+        expect(
+          container.children[0].children[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+
+      it('useOpaqueIdentifier warn when there is a hydration error', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <Child appId={id} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        // This is the wrong HTML string
+        container.innerHTML = '<span></span>';
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(),
+        ).toErrorDev([
+          'Warning: Expected server HTML to contain a matching <div> in <div>.',
+        ]);
+      });
+
+      it('useOpaqueIdentifier throws when there is a hydration error and we are using ID as a string', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId + ''} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <Child appId={id} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        // This is the wrong HTML string
+        container.innerHTML = '<span></span>';
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev(
+          [
+            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+            'Warning: Did not expect server HTML to contain a <span> in <div>.',
+          ],
+          {withoutStack: 1},
+        );
+      });
+
+      it('useOpaqueIdentifier throws when there is a hydration error and we are using ID as a string', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId + ''} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <Child appId={id} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        // This is the wrong HTML string
+        container.innerHTML = '<span></span>';
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev(
+          [
+            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+            'Warning: Did not expect server HTML to contain a <span> in <div>.',
+          ],
+          {withoutStack: 1},
+        );
+      });
+
+      it('useOpaqueIdentifier throws if you try to use the result as a string in a child component', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId + ''} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <Child appId={id} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev(
+          [
+            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+            'Warning: Did not expect server HTML to contain a <div> in <div>.',
+          ],
+          {withoutStack: 1},
+        );
+      });
+
+      it('useOpaqueIdentifier throws if you try to use the result as a string', async () => {
+        function App() {
+          const id = useOpaqueIdentifier();
+          return <div aria-labelledby={id + ''} />;
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev(
+          [
+            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+            'Warning: Did not expect server HTML to contain a <div> in <div>.',
+          ],
+          {withoutStack: 1},
+        );
+      });
+
+      it('useOpaqueIdentifier throws if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={appId + ''} />;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          return (
+            <React.Suspense fallback={null}>
+              <Child appId={id} />
+            </React.Suspense>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      });
+
+      it('useOpaqueIdentifier throws if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
+        function Child({appId}) {
+          return <div aria-labelledby={+appId} />;
+        }
+        function App() {
+          const [show] = useState(false);
+          const id = useOpaqueIdentifier();
+          return (
+            <React.Suspense fallback={null}>
+              {show && <div id={id} />}
+              <Child appId={id} />
+            </React.Suspense>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ),
+        ).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      });
+
+      it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {
+        let _setShow;
+
+        function App() {
+          const id1 = useOpaqueIdentifier();
+          const id2 = useOpaqueIdentifier();
+          const [show, setShow] = useState(true);
+          _setShow = setShow;
+
+          return (
+            <div>
+              <React.Suspense fallback={null}>
+                {show ? (
+                  <span id={id1}>{'Child'}</span>
+                ) : (
+                  <span id={id2}>{'Child'}</span>
+                )}
+              </React.Suspense>
+              <span aria-labelledby={id1}>{'test'}</span>
+            </div>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.appendChild(container);
+
+        container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+        const serverID = container
+          .getElementsByTagName('span')[0]
+          .getAttribute('id');
+        expect(serverID).not.toBeNull();
+        expect(
+          container
+            .getElementsByTagName('span')[1]
+            .getAttribute('aria-labelledby'),
+        ).toEqual(serverID);
+
+        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        jest.runAllTimers();
+        expect(Scheduler).toHaveYielded([]);
+        expect(Scheduler).toFlushAndYield([]);
+
+        ReactTestUtils.act(() => {
+          _setShow(false);
+        });
+
+        expect(
+          container
+            .getElementsByTagName('span')[1]
+            .getAttribute('aria-labelledby'),
+        ).toEqual(serverID);
+        expect(
+          container.getElementsByTagName('span')[0].getAttribute('id'),
+        ).not.toEqual(serverID);
+        expect(
+          container.getElementsByTagName('span')[0].getAttribute('id'),
+        ).not.toBeNull();
+      });
+    });
+  }
+});

commit db6513914f99c260090f26f0a547ee1432c934e6
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 24 23:26:04 2020 -0700

    Make ExpirationTime an opaque type (#18732)
    
    * Add LanePriority type
    
    React's internal scheduler has more priority levels than the external
    Scheduler package. Let's use React as the source of truth for tracking
    the priority of updates so we have more control. We'll still fall back
    to Scheduler in the default case. In the future, we should consider
    removing `runWithPriority` from Scheduler and replacing the valid use
    cases with React-specific APIs.
    
    This commit adds a new type, called a LanePriority to disambiguate from
    the Scheduler one.
    
    ("Lane" refers to another type that I'm planning. It roughly translates
    to "thread." Each lane will have a priority associated with it.)
    
    I'm not actually using the lane anywhere, yet. Only setting stuff up.
    
    * Remove expiration times train model
    
    In the old reconciler, expiration times are computed by applying an
    offset to the current system time. This has the effect of increasing
    the priority of updates as time progresses. Because we also use
    expiration times as a kind of "thread" identifier, it turns out this
    is quite limiting because we can only flush work sequentially along
    the timeline.
    
    The new model will use a bitmask to represent parallel threads that
    can be worked on in any combination and in any order.
    
    In this commit, expiration times and the linear timeline are still in
    place, but they are no longer based on a timestamp. Effectively, they
    are constants based on their priority level.
    
    * Stop using ExpirationTime to represent timestamps
    
    Follow up to the previous commit. This converts the remaining places
    where we were using the ExpirationTime type to represent a timestamp,
    like Suspense timeouts.
    
    * Fork Dependencies and PendingInteractionMap types
    
    These contain expiration times
    
    * Make ExpirationTime an opaque type
    
    ExpirationTime is currently just an alias for the `number` type, for a
    few reasons. One is that it predates Flow's opaque type feature. Another
    is that making it opaque means we have to move all our comparisons and
    number math to the ExpirationTime module, and use utility functions
    everywhere else.
    
    However, this is actually what we want in the new system, because the
    Lanes type that will replace ExpirationTime is a bitmask with a
    particular layout, and performing operations on it will involve more
    than just number comparisions and artihmetic. I don't want this logic to
    spread ad hoc around the whole codebase.
    
    The utility functions get inlined by Closure so it doesn't matter
    performance-wise.
    
    I automated most of the changes with JSCodeshift, with only a few manual
    tweaks to stuff like imports. My goal was to port the logic exactly to
    prevent subtle mistakes, without trying to simplify anything in the
    process. I'll likely need to audit many of these sites again when I
    replace them with the new type, though, especially the ones
    in ReactFiberRoot.
    
    I added the codemods I used to the `scripts` directory. I won't merge
    these to master. I'll remove them in a subsequent commit. I'm only
    committing them here so they show up in the PR for future reference.
    
    I had a lot of trouble getting Flow to pass. Somehow it was not
    inferring the correct type of the constants exported from the
    ExpirationTime module, despite being annotated correctly.
    
    I tried converting them them to constructor functions — `NoWork`
    becomes `NoWork()` — and that made it work. I used that to unblock me,
    and fixed all the other type errors. Once there were no more type
    errors, I tried converting the constructors back to constants. Started
    getting errors again.
    
    Then I added a type constraint everywhere a constant was referenced.
    That fixed it. I also figured out that you only have to add a constraint
    when the constant is passed to another function, even if the function is
    annotated. So this indicates to me that it's probably a Flow bug. I'll
    file an issue with Flow.
    
    * Delete temporary codemods used in previous commit
    
    I only added these to the previous commit so that I can easily run it
    again when rebasing. When the stack is squashed, it will be as if they
    never existed.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 9664ea1cac..afd366aaa2 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1278,25 +1278,44 @@ describe('ReactDOMServerHooks', () => {
           // State update should trigger the ID to update, which changes the props
           // of ChildWithID. This should cause ChildWithID to hydrate before Children
 
-          expect(Scheduler).toFlushAndYieldThrough(
-            __DEV__
-              ? [
-                  'Child with ID',
-                  // Fallbacks are immdiately committed in TestUtils version
-                  // of act
-                  // 'Child with ID',
-                  // 'Child with ID',
-                  'Child One',
-                  'Child Two',
-                ]
-              : [
-                  'Child with ID',
-                  'Child with ID',
-                  'Child with ID',
-                  'Child One',
-                  'Child Two',
-                ],
-          );
+          gate(flags => {
+            if (__DEV__) {
+              expect(Scheduler).toFlushAndYieldThrough([
+                'Child with ID',
+                // Fallbacks are immdiately committed in TestUtils version
+                // of act
+                // 'Child with ID',
+                // 'Child with ID',
+                'Child One',
+                'Child Two',
+              ]);
+            } else if (flags.new) {
+              // Upgrading a dehyrdating boundary works a little differently in
+              // the new reconciler. After the update on the boundary is
+              // scheduled, it waits until the end of the current time slice
+              // before restarting at the higher priority.
+              expect(Scheduler).toFlushAndYieldThrough([
+                'Child with ID',
+                'Child with ID',
+                'Child with ID',
+                'Child with ID',
+                'Child One',
+                'Child Two',
+              ]);
+            } else {
+              // Whereas the old reconciler relies on a Scheduler hack to
+              // interrupt the current task. It's not clear if this is any
+              // better or worse, though. Regardless it's not a big deal since
+              // the time slices aren't that big.
+              expect(Scheduler).toFlushAndYieldThrough([
+                'Child with ID',
+                'Child with ID',
+                'Child with ID',
+                'Child One',
+                'Child Two',
+              ]);
+            }
+          });
 
           expect(child1Ref.current).toBe(null);
           expect(childWithIDRef.current).toEqual(

commit e71f5df9c32b3b486bf4efce861834389c395d47
Author: Alex Taylor <alta@fb.com>
Date:   Wed Apr 29 16:22:10 2020 -0700

    Consistent useCallback implementation in ReactDOMServer (#18783)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index afd366aaa2..65e4188dc9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -564,7 +564,7 @@ describe('ReactDOMServerHooks', () => {
   });
 
   describe('useCallback', () => {
-    itRenders('should ignore callbacks on the server', async render => {
+    itRenders('should not invoke the passed callbacks', async render => {
       function Counter(props) {
         useCallback(() => {
           yieldValue('should not be invoked');
@@ -589,6 +589,34 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 5');
     });
+
+    itRenders(
+      'should only change the returned reference when the inputs change',
+      async render => {
+        function CapitalizedText(props) {
+          const [text, setText] = useState(props.text);
+          const [count, setCount] = useState(0);
+          const capitalizeText = useCallback(() => text.toUpperCase(), [text]);
+          yieldValue(capitalizeText);
+          if (count < 3) {
+            setCount(count + 1);
+          }
+          if (text === 'hello' && count === 2) {
+            setText('hello, world.');
+          }
+          return <Text text={capitalizeText()} />;
+        }
+
+        const domNode = await render(<CapitalizedText text="hello" />);
+        const [first, second, third, fourth, result] = clearYields();
+        expect(first).toBe(second);
+        expect(second).toBe(third);
+        expect(third).not.toBe(fourth);
+        expect(result).toEqual('HELLO, WORLD.');
+        expect(domNode.tagName).toEqual('SPAN');
+        expect(domNode.textContent).toEqual('HELLO, WORLD.');
+      },
+    );
   });
 
   describe('useImperativeHandle', () => {

commit 93e078ddf274636b0a40bd5501ce3549aec700fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat May 2 17:09:31 2020 -0700

    Initial Lanes implementation (#18796)
    
    See PR #18796 for more information.
    
    All of the changes I've made in this commit are behind the
    `enableNewReconciler` flag. Merging this to master will not affect the
    open source builds or the build that we ship to Facebook.
    
    The only build that is affected is the `ReactDOMForked` build, which is
    deployed to Facebook **behind an experimental flag (currently disabled
    for all users)**. We will use this flag to gradually roll out the new
    reconciler, and quickly roll it back if we find any problems.
    
    Because we have those protections in place, what I'm aiming for with
    this initial PR is the **smallest possible atomic change that lands
    cleanly and doesn't rely on too many hacks**. The goal has not been to
    get every single test or feature passing, and it definitely is not to
    implement all the features that we intend to build on top of the new
    model. When possible, I have chosen to preserve existing semantics and
    defer changes to follow-up steps. (Listed in the section below.)
    
    (I did not end up having to disable any tests, although if I had, that
    should not have necessarily been a merge blocker.)
    
    For example, even though one of the primary goals of this project is to
    improve our model for parallel Suspense transitions, in this initial
    implementation, I have chosen to keep the same core heuristics for
    sequencing and flushing that existed in the ExpirationTimes model: low
    priority updates cannot finish without also finishing high priority
    ones.
    
    Despite all these precautions, **because the scope of this refactor is
    inherently large, I do expect we will find regressions.** The flip side
    is that I also expect the new model to improve the stability of the
    codebase and make it easier to fix bugs when they arise.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 65e4188dc9..c087ec9376 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1306,44 +1306,25 @@ describe('ReactDOMServerHooks', () => {
           // State update should trigger the ID to update, which changes the props
           // of ChildWithID. This should cause ChildWithID to hydrate before Children
 
-          gate(flags => {
-            if (__DEV__) {
-              expect(Scheduler).toFlushAndYieldThrough([
-                'Child with ID',
-                // Fallbacks are immdiately committed in TestUtils version
-                // of act
-                // 'Child with ID',
-                // 'Child with ID',
-                'Child One',
-                'Child Two',
-              ]);
-            } else if (flags.new) {
-              // Upgrading a dehyrdating boundary works a little differently in
-              // the new reconciler. After the update on the boundary is
-              // scheduled, it waits until the end of the current time slice
-              // before restarting at the higher priority.
-              expect(Scheduler).toFlushAndYieldThrough([
-                'Child with ID',
-                'Child with ID',
-                'Child with ID',
-                'Child with ID',
-                'Child One',
-                'Child Two',
-              ]);
-            } else {
-              // Whereas the old reconciler relies on a Scheduler hack to
-              // interrupt the current task. It's not clear if this is any
-              // better or worse, though. Regardless it's not a big deal since
-              // the time slices aren't that big.
-              expect(Scheduler).toFlushAndYieldThrough([
-                'Child with ID',
-                'Child with ID',
-                'Child with ID',
-                'Child One',
-                'Child Two',
-              ]);
-            }
-          });
+          expect(Scheduler).toFlushAndYieldThrough(
+            __DEV__
+              ? [
+                  'Child with ID',
+                  // Fallbacks are immediately committed in TestUtils version
+                  // of act
+                  // 'Child with ID',
+                  // 'Child with ID',
+                  'Child One',
+                  'Child Two',
+                ]
+              : [
+                  'Child with ID',
+                  'Child with ID',
+                  'Child with ID',
+                  'Child One',
+                  'Child Two',
+                ],
+          );
 
           expect(child1Ref.current).toBe(null);
           expect(childWithIDRef.current).toEqual(
@@ -1691,15 +1672,24 @@ describe('ReactDOMServerHooks', () => {
 
         ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
 
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
+        if (gate(flags => flags.new)) {
+          expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
-          ),
-        ).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
+          ]);
+        } else {
+          // In the old reconciler, the error isn't surfaced to the user. That
+          // part isn't important, as long as It warns.
+          expect(() =>
+            expect(() => Scheduler.unstable_flushAll()).toThrow(
+              'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+                'Do not read the value directly.',
+            ),
+          ).toErrorDev([
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ]);
+        }
       });
 
       it('useOpaqueIdentifier throws if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
@@ -1724,15 +1714,24 @@ describe('ReactDOMServerHooks', () => {
 
         ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
 
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
+        if (gate(flags => flags.new)) {
+          expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
-          ),
-        ).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
+          ]);
+        } else {
+          // In the old reconciler, the error isn't surfaced to the user. That
+          // part isn't important, as long as It warns.
+          expect(() =>
+            expect(() => Scheduler.unstable_flushAll()).toThrow(
+              'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+                'Do not read the value directly.',
+            ),
+          ).toErrorDev([
+            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+              'Do not read the value directly.',
+          ]);
+        }
       });
 
       it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {

commit fe7163e73dadceda2655736d97cdd745d7abc8ea
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 4 22:25:41 2020 -0700

    Add unstable prefix to experimental APIs (#18825)
    
    We've been shipping unprefixed experimental APIs (like `createRoot` and
    `useTransition`) to the Experimental release channel, with the rationale
    that because these APIs do not appear in any stable release, we're free
    to change or remove them later without breaking any downstream projects.
    
    What we didn't consider is that downstream projects might be tempted to
    use feature detection:
    
    ```js
    const useTransition = React.useTransition || fallbackUseTransition;
    ```
    
    This pattern assumes that the version of `useTransition` that exists in
    the Experimental channel today has the same API contract as the final
    `useTransition` API that we'll eventually ship to stable.
    
    To discourage feature detection, I've added an `unstable_` prefix to
    all of our unstable APIs.
    
    The Facebook builds still have the unprefixed APIs, though. We will
    continue to support those; if we make any breaking changes, we'll
    migrate the internal callers like we usually do. To make testing easier,
    I added the `unstable_`-prefixed APIs to the www builds, too. That way
    our tests can always use the prefixed ones without gating on the
    release channel.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index c087ec9376..8c90d593a7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1051,7 +1051,7 @@ describe('ReactDOMServerHooks', () => {
         document.body.append(container);
 
         container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         root.render(<App />);
         Scheduler.unstable_flushAll();
         jest.runAllTimers();
@@ -1136,7 +1136,7 @@ describe('ReactDOMServerHooks', () => {
         const container = document.createElement('div');
         document.body.append(container);
         container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         ReactTestUtils.act(() => {
           root.render(<App />);
         });
@@ -1196,7 +1196,7 @@ describe('ReactDOMServerHooks', () => {
         const container = document.createElement('div');
         document.body.append(container);
         container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         ReactTestUtils.act(() => {
           root.render(<App />);
         });
@@ -1291,7 +1291,7 @@ describe('ReactDOMServerHooks', () => {
 
         const childOneSpan = container.getElementsByTagName('span')[0];
 
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         root.render(<App show={false} />);
         expect(Scheduler).toHaveYielded([]);
 
@@ -1397,7 +1397,7 @@ describe('ReactDOMServerHooks', () => {
         container.innerHTML = ReactDOMServer.renderToString(<App />);
 
         suspend = true;
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         await ReactTestUtils.act(async () => {
           root.render(<App />);
         });
@@ -1447,7 +1447,9 @@ describe('ReactDOMServerHooks', () => {
 
         // This is the wrong HTML string
         container.innerHTML = '<span></span>';
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(),
         ).toErrorDev([
@@ -1497,7 +1499,7 @@ describe('ReactDOMServerHooks', () => {
         container.innerHTML = ReactDOMServer.renderToString(<App />);
 
         suspend = false;
-        const root = ReactDOM.createRoot(container, {hydrate: true});
+        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         await ReactTestUtils.act(async () => {
           root.render(<App />);
         });
@@ -1533,7 +1535,9 @@ describe('ReactDOMServerHooks', () => {
 
         // This is the wrong HTML string
         container.innerHTML = '<span></span>';
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(),
         ).toErrorDev([
@@ -1555,7 +1559,9 @@ describe('ReactDOMServerHooks', () => {
 
         // This is the wrong HTML string
         container.innerHTML = '<span></span>';
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
@@ -1584,7 +1590,9 @@ describe('ReactDOMServerHooks', () => {
 
         // This is the wrong HTML string
         container.innerHTML = '<span></span>';
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
@@ -1612,7 +1620,9 @@ describe('ReactDOMServerHooks', () => {
         document.body.appendChild(container);
 
         container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
@@ -1637,7 +1647,9 @@ describe('ReactDOMServerHooks', () => {
         document.body.appendChild(container);
 
         container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         expect(() =>
           expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
@@ -1670,7 +1682,9 @@ describe('ReactDOMServerHooks', () => {
 
         container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
 
         if (gate(flags => flags.new)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
@@ -1712,7 +1726,9 @@ describe('ReactDOMServerHooks', () => {
 
         container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
 
         if (gate(flags => flags.new)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
@@ -1772,7 +1788,9 @@ describe('ReactDOMServerHooks', () => {
             .getAttribute('aria-labelledby'),
         ).toEqual(serverID);
 
-        ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
+        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
+          <App />,
+        );
         jest.runAllTimers();
         expect(Scheduler).toHaveYielded([]);
         expect(Scheduler).toFlushAndYield([]);

commit 47ebc90b08be7a2e6955dd3cfd468318e0b8fdfd
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 6 19:19:14 2020 -0700

    Put render phase update change behind a flag (#18850)
    
    In the new reconciler, I made a change to how render phase updates
    work. (By render phase updates, I mean when a component updates
    another component during its render phase. Or when a class component
    updates itself during the render phase. It does not include when
    a hook updates its own component during the render phase. Those have
    their own semantics. So really I mean anything triggers the "`setState`
    in render" warning.)
    
    The old behavior is to give the update the same "thread" (expiration
    time) as whatever is currently rendering. So if you call `setState` on a
    component that happens later in the same render, it will flush during
    that render. Ideally, we want to remove the special case and treat them
    as if they came from an interleaved event.
    
    Regardless, this pattern is not officially supported. This behavior is
    only a fallback. The flag only exists until we can roll out the
    `setState` warnning, since existing code might accidentally rely on the
    current behavior.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 8c90d593a7..79345cc146 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1686,7 +1686,9 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (gate(flags => flags.new)) {
+        if (
+          gate(flags => flags.new && flags.deferRenderPhaseUpdateToNextBatch)
+        ) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
@@ -1730,7 +1732,9 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (gate(flags => flags.new)) {
+        if (
+          gate(flags => flags.new && flags.deferRenderPhaseUpdateToNextBatch)
+        ) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',

commit df14b5bcc163516fc0f1ad35e9b93732c66c1085
Author: Luna Ruan <luna@fb.com>
Date:   Thu May 7 20:46:27 2020 -0700

    add new IDs for each each server renderer instance and prefixes to distinguish between each server render (#18576)
    
    There is a worry that `useOpaqueIdentifier` might run out of unique IDs if running for long enough. This PR moves the unique ID counter so it's generated per server renderer object instead. For people who render different subtrees, this PR adds a prefix option to `renderToString`, `renderToStaticMarkup`, `renderToNodeStream`, and `renderToStaticNodeStream` so identifiers can be differentiated for each individual subtree.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 79345cc146..c69ea90721 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1032,6 +1032,162 @@ describe('ReactDOMServerHooks', () => {
         );
       });
 
+      it('useOpaqueIdentifier identifierPrefix works for server renderer and does not clash', async () => {
+        function ChildTwo({id}) {
+          return <div id={id}>Child Three</div>;
+        }
+        function App() {
+          const id = useOpaqueIdentifier();
+          const idTwo = useOpaqueIdentifier();
+
+          return (
+            <div>
+              <div aria-labelledby={id}>Chid One</div>
+              <ChildTwo id={id} />
+              <div aria-labelledby={idTwo}>Child Three</div>
+              <div id={idTwo}>Child Four</div>
+            </div>
+          );
+        }
+
+        const containerOne = document.createElement('div');
+        document.body.append(containerOne);
+
+        containerOne.innerHTML = ReactDOMServer.renderToString(<App />, {
+          identifierPrefix: 'one',
+        });
+
+        const containerTwo = document.createElement('div');
+        document.body.append(containerTwo);
+
+        containerTwo.innerHTML = ReactDOMServer.renderToString(<App />, {
+          identifierPrefix: 'two',
+        });
+
+        expect(document.body.children.length).toEqual(2);
+        const childOne = document.body.children[0];
+        const childTwo = document.body.children[1];
+
+        expect(
+          childOne.children[0].children[0].getAttribute('aria-labelledby'),
+        ).toEqual(childOne.children[0].children[1].getAttribute('id'));
+        expect(
+          childOne.children[0].children[2].getAttribute('aria-labelledby'),
+        ).toEqual(childOne.children[0].children[3].getAttribute('id'));
+
+        expect(
+          childOne.children[0].children[0].getAttribute('aria-labelledby'),
+        ).not.toEqual(
+          childOne.children[0].children[2].getAttribute('aria-labelledby'),
+        );
+
+        expect(
+          childOne.children[0].children[0]
+            .getAttribute('aria-labelledby')
+            .startsWith('one'),
+        ).toBe(true);
+        expect(
+          childOne.children[0].children[2]
+            .getAttribute('aria-labelledby')
+            .includes('one'),
+        ).toBe(true);
+
+        expect(
+          childTwo.children[0].children[0].getAttribute('aria-labelledby'),
+        ).toEqual(childTwo.children[0].children[1].getAttribute('id'));
+        expect(
+          childTwo.children[0].children[2].getAttribute('aria-labelledby'),
+        ).toEqual(childTwo.children[0].children[3].getAttribute('id'));
+
+        expect(
+          childTwo.children[0].children[0].getAttribute('aria-labelledby'),
+        ).not.toEqual(
+          childTwo.children[0].children[2].getAttribute('aria-labelledby'),
+        );
+
+        expect(
+          childTwo.children[0].children[0]
+            .getAttribute('aria-labelledby')
+            .startsWith('two'),
+        ).toBe(true);
+        expect(
+          childTwo.children[0].children[2]
+            .getAttribute('aria-labelledby')
+            .startsWith('two'),
+        ).toBe(true);
+      });
+
+      it('useOpaqueIdentifier identifierPrefix works for multiple reads on a streaming server renderer', async () => {
+        function ChildTwo() {
+          const id = useOpaqueIdentifier();
+
+          return <div id={id}>Child Two</div>;
+        }
+
+        function App() {
+          const id = useOpaqueIdentifier();
+
+          return (
+            <>
+              <div id={id}>Child One</div>
+              <ChildTwo />
+              <div aria-labelledby={id}>Aria One</div>
+            </>
+          );
+        }
+
+        const container = document.createElement('div');
+        document.body.append(container);
+
+        const streamOne = ReactDOMServer.renderToNodeStream(<App />, {
+          identifierPrefix: 'one',
+        }).setEncoding('utf8');
+        const streamTwo = ReactDOMServer.renderToNodeStream(<App />, {
+          identifierPrefix: 'two',
+        }).setEncoding('utf8');
+
+        const containerOne = document.createElement('div');
+        const containerTwo = document.createElement('div');
+
+        streamOne._read(10);
+        streamTwo._read(10);
+
+        containerOne.innerHTML = streamOne.read();
+        containerTwo.innerHTML = streamTwo.read();
+
+        expect(containerOne.children[0].getAttribute('id')).not.toEqual(
+          containerOne.children[1].getAttribute('id'),
+        );
+        expect(containerTwo.children[0].getAttribute('id')).not.toEqual(
+          containerTwo.children[1].getAttribute('id'),
+        );
+        expect(containerOne.children[0].getAttribute('id')).not.toEqual(
+          containerTwo.children[0].getAttribute('id'),
+        );
+        expect(
+          containerOne.children[0].getAttribute('id').includes('one'),
+        ).toBe(true);
+        expect(
+          containerOne.children[1].getAttribute('id').includes('one'),
+        ).toBe(true);
+        expect(
+          containerTwo.children[0].getAttribute('id').includes('two'),
+        ).toBe(true);
+        expect(
+          containerTwo.children[1].getAttribute('id').includes('two'),
+        ).toBe(true);
+
+        expect(containerOne.children[1].getAttribute('id')).not.toEqual(
+          containerTwo.children[1].getAttribute('id'),
+        );
+        expect(containerOne.children[0].getAttribute('id')).toEqual(
+          containerOne.children[2].getAttribute('aria-labelledby'),
+        );
+        expect(containerTwo.children[0].getAttribute('id')).toEqual(
+          containerTwo.children[2].getAttribute('aria-labelledby'),
+        );
+      });
+
       it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
         let _setShowDiv;
         function App() {

commit 142d4f1c00c66f3d728177082dbc027fd6335115
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu May 21 16:00:46 2020 -0700

    useMutableSource hydration support (#18771)
    
    * useMutableSource hydration support
    
    * Remove unnecessary ReactMutableSource fork
    
    * Replaced root.registerMutableSourceForHydration() with mutableSources option
    
    * Response to PR feedback:
    
    1. Moved mutableSources root option to hydrationOptions object
    2. Only initialize root mutableSourceEagerHydrationData if supportsHydration config is true
    3. Lazily initialize mutableSourceEagerHydrationData on root object

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index c69ea90721..ea5dfc1be7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1445,8 +1445,6 @@ describe('ReactDOMServerHooks', () => {
           .getAttribute('id');
         expect(serverId).not.toBeNull();
 
-        const childOneSpan = container.getElementsByTagName('span')[0];
-
         const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
         root.render(<App show={false} />);
         expect(Scheduler).toHaveYielded([]);
@@ -1462,25 +1460,15 @@ describe('ReactDOMServerHooks', () => {
           // State update should trigger the ID to update, which changes the props
           // of ChildWithID. This should cause ChildWithID to hydrate before Children
 
-          expect(Scheduler).toFlushAndYieldThrough(
-            __DEV__
-              ? [
-                  'Child with ID',
-                  // Fallbacks are immediately committed in TestUtils version
-                  // of act
-                  // 'Child with ID',
-                  // 'Child with ID',
-                  'Child One',
-                  'Child Two',
-                ]
-              : [
-                  'Child with ID',
-                  'Child with ID',
-                  'Child with ID',
-                  'Child One',
-                  'Child Two',
-                ],
-          );
+          expect(Scheduler).toFlushAndYieldThrough([
+            'Child with ID',
+            // Fallbacks are immediately committed in TestUtils version
+            // of act
+            // 'Child with ID',
+            // 'Child with ID',
+            'Child One',
+            'Child Two',
+          ]);
 
           expect(child1Ref.current).toBe(null);
           expect(childWithIDRef.current).toEqual(
@@ -1500,7 +1488,9 @@ describe('ReactDOMServerHooks', () => {
         });
 
         // Children hydrates after ChildWithID
-        expect(child1Ref.current).toBe(childOneSpan);
+        expect(child1Ref.current).toBe(
+          container.getElementsByTagName('span')[0],
+        );
 
         Scheduler.unstable_flushAll();
 
@@ -1606,9 +1596,7 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(),
-        ).toErrorDev([
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
           'Warning: Expected server HTML to contain a matching <div> in <div>.',
         ]);
       });
@@ -1694,14 +1682,12 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(),
-        ).toErrorDev([
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
           'Warning: Expected server HTML to contain a matching <div> in <div>.',
         ]);
       });
 
-      it('useOpaqueIdentifier throws when there is a hydration error and we are using ID as a string', async () => {
+      it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
         function Child({appId}) {
           return <div aria-labelledby={appId + ''} />;
         }
@@ -1718,12 +1704,7 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev(
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
           [
             'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
             'Warning: Did not expect server HTML to contain a <span> in <div>.',
@@ -1732,7 +1713,7 @@ describe('ReactDOMServerHooks', () => {
         );
       });
 
-      it('useOpaqueIdentifier throws when there is a hydration error and we are using ID as a string', async () => {
+      it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
         function Child({appId}) {
           return <div aria-labelledby={appId + ''} />;
         }
@@ -1749,12 +1730,7 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev(
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
           [
             'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
             'Warning: Did not expect server HTML to contain a <span> in <div>.',
@@ -1763,7 +1739,7 @@ describe('ReactDOMServerHooks', () => {
         );
       });
 
-      it('useOpaqueIdentifier throws if you try to use the result as a string in a child component', async () => {
+      it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
         function Child({appId}) {
           return <div aria-labelledby={appId + ''} />;
         }
@@ -1779,12 +1755,7 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev(
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
           [
             'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
             'Warning: Did not expect server HTML to contain a <div> in <div>.',
@@ -1793,7 +1764,7 @@ describe('ReactDOMServerHooks', () => {
         );
       });
 
-      it('useOpaqueIdentifier throws if you try to use the result as a string', async () => {
+      it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
         function App() {
           const id = useOpaqueIdentifier();
           return <div aria-labelledby={id + ''} />;
@@ -1806,12 +1777,7 @@ describe('ReactDOMServerHooks', () => {
         ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
           <App />,
         );
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev(
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
           [
             'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
             'Warning: Did not expect server HTML to contain a <div> in <div>.',
@@ -1820,7 +1786,7 @@ describe('ReactDOMServerHooks', () => {
         );
       });
 
-      it('useOpaqueIdentifier throws if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
+      it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
         function Child({appId}) {
           return <div aria-labelledby={appId + ''} />;
         }
@@ -1842,16 +1808,14 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (
-          gate(flags => flags.new && flags.deferRenderPhaseUpdateToNextBatch)
-        ) {
+        if (gate(flags => !flags.new)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
           ]);
         } else {
-          // In the old reconciler, the error isn't surfaced to the user. That
-          // part isn't important, as long as It warns.
+          // This error isn't surfaced to the user; only the warning is.
+          // The error is just the mechanism that restarts the render.
           expect(() =>
             expect(() => Scheduler.unstable_flushAll()).toThrow(
               'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
@@ -1864,7 +1828,7 @@ describe('ReactDOMServerHooks', () => {
         }
       });
 
-      it('useOpaqueIdentifier throws if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
+      it('useOpaqueIdentifier warns if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
         function Child({appId}) {
           return <div aria-labelledby={+appId} />;
         }
@@ -1888,16 +1852,14 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (
-          gate(flags => flags.new && flags.deferRenderPhaseUpdateToNextBatch)
-        ) {
+        if (gate(flags => !flags.new)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
           ]);
         } else {
-          // In the old reconciler, the error isn't surfaced to the user. That
-          // part isn't important, as long as It warns.
+          // This error isn't surfaced to the user; only the warning is.
+          // The error is just the mechanism that restarts the render.
           expect(() =>
             expect(() => Scheduler.unstable_flushAll()).toThrow(
               'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index ea5dfc1be7..8ca8f665f1 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1808,7 +1808,7 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (gate(flags => !flags.new)) {
+        if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
@@ -1852,7 +1852,7 @@ describe('ReactDOMServerHooks', () => {
           <App />,
         );
 
-        if (gate(flags => !flags.new)) {
+        if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
           expect(() => Scheduler.unstable_flushAll()).toErrorDev([
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',

commit 30b47103d4354d9187dc0f1fb804855a5208ca9f
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 15 19:59:44 2020 -0400

    Fix spelling errors and typos (#19138)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 8ca8f665f1..7dfcb4fc77 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1042,7 +1042,7 @@ describe('ReactDOMServerHooks', () => {
 
           return (
             <div>
-              <div aria-labelledby={id}>Chid One</div>
+              <div aria-labelledby={id}>Child One</div>
               <ChildTwo id={id} />
               <div aria-labelledby={idTwo}>Child Three</div>
               <div id={idTwo}>Child Four</div>
@@ -1336,7 +1336,7 @@ describe('ReactDOMServerHooks', () => {
         ).not.toBeNull();
       });
 
-      it('useOpaqueIdentifierr: flushSync', async () => {
+      it('useOpaqueIdentifier: flushSync', async () => {
         let _setShow;
         function App() {
           const id = useOpaqueIdentifier();

commit b85b47630be57c7031b0a9ab741cf858dc0ca215
Author: Phil MacCart <pmaccart@gmail.com>
Date:   Tue Jul 7 19:10:23 2020 -0700

    Fix state leaking when a function component throws on server render (#19212)
    
    * add unit test asserting internal hooks state is reset
    
    * Reset internal hooks state before rendering
    
    * reset hooks state on error
    
    * Use expect...toThrow instead of try/catch in test
    
    * reset dev-only hooks state inside resetHooksState
    
    * reset currentlyRenderingComponent to null

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 7dfcb4fc77..813c0fe1e7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -867,6 +867,44 @@ describe('ReactDOMServerHooks', () => {
     });
   });
 
+  it('renders successfully after a component using hooks throws an error', () => {
+    function ThrowingComponent() {
+      const [value, dispatch] = useReducer((state, action) => {
+        return state + 1;
+      }, 0);
+
+      // throw an error if the count gets too high during the re-render phase
+      if (value >= 3) {
+        throw new Error('Error from ThrowingComponent');
+      } else {
+        // dispatch to trigger a re-render of the component
+        dispatch();
+      }
+
+      return <div>{value}</div>;
+    }
+
+    function NonThrowingComponent() {
+      const [count] = useState(0);
+      return <div>{count}</div>;
+    }
+
+    // First, render a component that will throw an error during a re-render triggered
+    // by a dispatch call.
+    expect(() => ReactDOMServer.renderToString(<ThrowingComponent />)).toThrow(
+      'Error from ThrowingComponent',
+    );
+
+    // Next, assert that we can render a function component using hooks immediately
+    // after an error occurred, which indictates the internal hooks state has been
+    // reset.
+    const container = document.createElement('div');
+    container.innerHTML = ReactDOMServer.renderToString(
+      <NonThrowingComponent />,
+    );
+    expect(container.children[0].textContent).toEqual('0');
+  });
+
   if (__EXPERIMENTAL__) {
     describe('useOpaqueIdentifier', () => {
       it('generates unique ids for server string render', async () => {

commit 702fad4b1b48ac8f626ed3f35e8f86f5ea728084
Author: CY Lim <5622951+cylim@users.noreply.github.com>
Date:   Mon Aug 17 20:25:50 2020 +0800

    refactor fb.me redirect link to reactjs.org/link (#19598)
    
    * refactor fb.me url to reactjs.org/link
    
    * Update ESLintRuleExhaustiveDeps-test.js
    
    * Update ReactDOMServerIntegrationUntrustedURL-test.internal.js
    
    * Update createReactClassIntegration-test.js
    
    * Update ReactDOMServerIntegrationUntrustedURL-test.internal.js
    
    Co-authored-by: Dan Abramov <dan.abramov@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 813c0fe1e7..0497a69671 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -156,7 +156,7 @@ describe('ReactDOMServerHooks', () => {
         '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
         '2. You might be breaking the Rules of Hooks\n' +
         '3. You might have more than one copy of React in the same app\n' +
-        'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',
+        'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
     );
 
     itRenders('multiple times when an updater is called', async render => {
@@ -674,7 +674,7 @@ describe('ReactDOMServerHooks', () => {
         '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
         '2. You might be breaking the Rules of Hooks\n' +
         '3. You might have more than one copy of React in the same app\n' +
-        'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',
+        'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
     );
   });
 

commit 4f5fb56100fac50f2c8bb33f984301b550e71407
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 28 16:21:01 2020 -0500

    Use gate pragma instead of if (__EXPERIMENTAL__) (#19722)
    
    * Use gate pragma instead of if (__EXPERIMENTAL__)
    
    * Fix stream error handling in tests
    
    Added an error listener so that the tests fail within their Jest scope,
    instead of crashing the whole process.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 0497a69671..a66a868667 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -905,1072 +905,1084 @@ describe('ReactDOMServerHooks', () => {
     expect(container.children[0].textContent).toEqual('0');
   });
 
-  if (__EXPERIMENTAL__) {
-    describe('useOpaqueIdentifier', () => {
-      it('generates unique ids for server string render', async () => {
-        function App(props) {
-          const idOne = useOpaqueIdentifier();
-          const idTwo = useOpaqueIdentifier();
-          return (
-            <div>
-              <div aria-labelledby={idOne} />
-              <div id={idOne} />
-              <span aria-labelledby={idTwo} />
-              <span id={idTwo} />
-            </div>
-          );
-        }
-
-        const domNode = await serverRender(<App />);
-        expect(domNode.children.length).toEqual(4);
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[1].getAttribute('id'),
-        );
-        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[3].getAttribute('id'),
-        );
-        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-          domNode.children[2].getAttribute('aria-labelledby'),
+  describe('useOpaqueIdentifier', () => {
+    // @gate experimental
+    it('generates unique ids for server string render', async () => {
+      function App(props) {
+        const idOne = useOpaqueIdentifier();
+        const idTwo = useOpaqueIdentifier();
+        return (
+          <div>
+            <div aria-labelledby={idOne} />
+            <div id={idOne} />
+            <span aria-labelledby={idTwo} />
+            <span id={idTwo} />
+          </div>
         );
-        expect(
-          domNode.children[0].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-        expect(
-          domNode.children[2].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('generates unique ids for server stream render', async () => {
-        function App(props) {
-          const idOne = useOpaqueIdentifier();
-          const idTwo = useOpaqueIdentifier();
-          return (
-            <div>
-              <div aria-labelledby={idOne} />
-              <div id={idOne} />
-              <span aria-labelledby={idTwo} />
-              <span id={idTwo} />
-            </div>
-          );
-        }
+      const domNode = await serverRender(<App />);
+      expect(domNode.children.length).toEqual(4);
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[1].getAttribute('id'),
+      );
+      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[3].getAttribute('id'),
+      );
+      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      );
+      expect(
+        domNode.children[0].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+      expect(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+    });
 
-        const domNode = await streamRender(<App />);
-        expect(domNode.children.length).toEqual(4);
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[1].getAttribute('id'),
-        );
-        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[3].getAttribute('id'),
-        );
-        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-          domNode.children[2].getAttribute('aria-labelledby'),
+    // @gate experimental
+    it('generates unique ids for server stream render', async () => {
+      function App(props) {
+        const idOne = useOpaqueIdentifier();
+        const idTwo = useOpaqueIdentifier();
+        return (
+          <div>
+            <div aria-labelledby={idOne} />
+            <div id={idOne} />
+            <span aria-labelledby={idTwo} />
+            <span id={idTwo} />
+          </div>
         );
-        expect(
-          domNode.children[0].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-        expect(
-          domNode.children[2].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('generates unique ids for client render', async () => {
-        function App(props) {
-          const idOne = useOpaqueIdentifier();
-          const idTwo = useOpaqueIdentifier();
-          return (
-            <div>
-              <div aria-labelledby={idOne} />
-              <div id={idOne} />
-              <span aria-labelledby={idTwo} />
-              <span id={idTwo} />
-            </div>
-          );
-        }
+      const domNode = await streamRender(<App />);
+      expect(domNode.children.length).toEqual(4);
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[1].getAttribute('id'),
+      );
+      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[3].getAttribute('id'),
+      );
+      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      );
+      expect(
+        domNode.children[0].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+      expect(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+    });
 
-        const domNode = await clientCleanRender(<App />);
-        expect(domNode.children.length).toEqual(4);
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[1].getAttribute('id'),
-        );
-        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[3].getAttribute('id'),
-        );
-        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-          domNode.children[2].getAttribute('aria-labelledby'),
+    // @gate experimental
+    it('generates unique ids for client render', async () => {
+      function App(props) {
+        const idOne = useOpaqueIdentifier();
+        const idTwo = useOpaqueIdentifier();
+        return (
+          <div>
+            <div aria-labelledby={idOne} />
+            <div id={idOne} />
+            <span aria-labelledby={idTwo} />
+            <span id={idTwo} />
+          </div>
         );
-        expect(
-          domNode.children[0].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-        expect(
-          domNode.children[2].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('generates unique ids for client render on good server markup', async () => {
-        function App(props) {
-          const idOne = useOpaqueIdentifier();
-          const idTwo = useOpaqueIdentifier();
-          return (
-            <div>
-              <div aria-labelledby={idOne} />
-              <div id={idOne} />
-              <span aria-labelledby={idTwo} />
-              <span id={idTwo} />
-            </div>
-          );
-        }
+      const domNode = await clientCleanRender(<App />);
+      expect(domNode.children.length).toEqual(4);
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[1].getAttribute('id'),
+      );
+      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[3].getAttribute('id'),
+      );
+      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      );
+      expect(
+        domNode.children[0].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+      expect(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+    });
 
-        const domNode = await clientRenderOnServerString(<App />);
-        expect(domNode.children.length).toEqual(4);
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[1].getAttribute('id'),
-        );
-        expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[3].getAttribute('id'),
+    // @gate experimental
+    it('generates unique ids for client render on good server markup', async () => {
+      function App(props) {
+        const idOne = useOpaqueIdentifier();
+        const idTwo = useOpaqueIdentifier();
+        return (
+          <div>
+            <div aria-labelledby={idOne} />
+            <div id={idOne} />
+            <span aria-labelledby={idTwo} />
+            <span id={idTwo} />
+          </div>
         );
-        expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-          domNode.children[2].getAttribute('aria-labelledby'),
+      }
+
+      const domNode = await clientRenderOnServerString(<App />);
+      expect(domNode.children.length).toEqual(4);
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[1].getAttribute('id'),
+      );
+      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[3].getAttribute('id'),
+      );
+      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      );
+      expect(
+        domNode.children[0].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+      expect(
+        domNode.children[2].getAttribute('aria-labelledby'),
+      ).not.toBeNull();
+    });
+
+    // @gate experimental
+    it('useOpaqueIdentifier does not change id even if the component updates during client render', async () => {
+      let _setShowId;
+      function App() {
+        const id = useOpaqueIdentifier();
+        const [showId, setShowId] = useState(false);
+        _setShowId = setShowId;
+        return (
+          <div>
+            <div aria-labelledby={id} />
+            {showId && <div id={id} />}
+          </div>
         );
-        expect(
-          domNode.children[0].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-        expect(
-          domNode.children[2].getAttribute('aria-labelledby'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('useOpaqueIdentifier does not change id even if the component updates during client render', async () => {
-        let _setShowId;
-        function App() {
-          const id = useOpaqueIdentifier();
-          const [showId, setShowId] = useState(false);
-          _setShowId = setShowId;
-          return (
-            <div>
-              <div aria-labelledby={id} />
-              {showId && <div id={id} />}
-            </div>
-          );
-        }
+      const domNode = await clientCleanRender(<App />);
+      const oldClientId = domNode.children[0].getAttribute('aria-labelledby');
 
-        const domNode = await clientCleanRender(<App />);
-        const oldClientId = domNode.children[0].getAttribute('aria-labelledby');
+      expect(domNode.children.length).toEqual(1);
+      expect(oldClientId).not.toBeNull();
 
-        expect(domNode.children.length).toEqual(1);
-        expect(oldClientId).not.toBeNull();
+      await ReactTestUtils.act(async () => _setShowId(true));
 
-        await ReactTestUtils.act(async () => _setShowId(true));
+      expect(domNode.children.length).toEqual(2);
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        domNode.children[1].getAttribute('id'),
+      );
+      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
+        oldClientId,
+      );
+    });
 
-        expect(domNode.children.length).toEqual(2);
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          domNode.children[1].getAttribute('id'),
-        );
-        expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-          oldClientId,
+    // @gate experimental
+    it('useOpaqueIdentifier identifierPrefix works for server renderer and does not clash', async () => {
+      function ChildTwo({id}) {
+        return <div id={id}>Child Three</div>;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        const idTwo = useOpaqueIdentifier();
+
+        return (
+          <div>
+            <div aria-labelledby={id}>Child One</div>
+            <ChildTwo id={id} />
+            <div aria-labelledby={idTwo}>Child Three</div>
+            <div id={idTwo}>Child Four</div>
+          </div>
         );
+      }
+
+      const containerOne = document.createElement('div');
+      document.body.append(containerOne);
+
+      containerOne.innerHTML = ReactDOMServer.renderToString(<App />, {
+        identifierPrefix: 'one',
       });
 
-      it('useOpaqueIdentifier identifierPrefix works for server renderer and does not clash', async () => {
-        function ChildTwo({id}) {
-          return <div id={id}>Child Three</div>;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          const idTwo = useOpaqueIdentifier();
+      const containerTwo = document.createElement('div');
+      document.body.append(containerTwo);
 
-          return (
-            <div>
-              <div aria-labelledby={id}>Child One</div>
-              <ChildTwo id={id} />
-              <div aria-labelledby={idTwo}>Child Three</div>
-              <div id={idTwo}>Child Four</div>
-            </div>
-          );
-        }
+      containerTwo.innerHTML = ReactDOMServer.renderToString(<App />, {
+        identifierPrefix: 'two',
+      });
 
-        const containerOne = document.createElement('div');
-        document.body.append(containerOne);
+      expect(document.body.children.length).toEqual(2);
+      const childOne = document.body.children[0];
+      const childTwo = document.body.children[1];
+
+      expect(
+        childOne.children[0].children[0].getAttribute('aria-labelledby'),
+      ).toEqual(childOne.children[0].children[1].getAttribute('id'));
+      expect(
+        childOne.children[0].children[2].getAttribute('aria-labelledby'),
+      ).toEqual(childOne.children[0].children[3].getAttribute('id'));
+
+      expect(
+        childOne.children[0].children[0].getAttribute('aria-labelledby'),
+      ).not.toEqual(
+        childOne.children[0].children[2].getAttribute('aria-labelledby'),
+      );
 
-        containerOne.innerHTML = ReactDOMServer.renderToString(<App />, {
-          identifierPrefix: 'one',
-        });
+      expect(
+        childOne.children[0].children[0]
+          .getAttribute('aria-labelledby')
+          .startsWith('one'),
+      ).toBe(true);
+      expect(
+        childOne.children[0].children[2]
+          .getAttribute('aria-labelledby')
+          .includes('one'),
+      ).toBe(true);
+
+      expect(
+        childTwo.children[0].children[0].getAttribute('aria-labelledby'),
+      ).toEqual(childTwo.children[0].children[1].getAttribute('id'));
+      expect(
+        childTwo.children[0].children[2].getAttribute('aria-labelledby'),
+      ).toEqual(childTwo.children[0].children[3].getAttribute('id'));
+
+      expect(
+        childTwo.children[0].children[0].getAttribute('aria-labelledby'),
+      ).not.toEqual(
+        childTwo.children[0].children[2].getAttribute('aria-labelledby'),
+      );
 
-        const containerTwo = document.createElement('div');
-        document.body.append(containerTwo);
+      expect(
+        childTwo.children[0].children[0]
+          .getAttribute('aria-labelledby')
+          .startsWith('two'),
+      ).toBe(true);
+      expect(
+        childTwo.children[0].children[2]
+          .getAttribute('aria-labelledby')
+          .startsWith('two'),
+      ).toBe(true);
+    });
 
-        containerTwo.innerHTML = ReactDOMServer.renderToString(<App />, {
-          identifierPrefix: 'two',
-        });
+    // @gate experimental
+    it('useOpaqueIdentifier identifierPrefix works for multiple reads on a streaming server renderer', async () => {
+      function ChildTwo() {
+        const id = useOpaqueIdentifier();
 
-        expect(document.body.children.length).toEqual(2);
-        const childOne = document.body.children[0];
-        const childTwo = document.body.children[1];
-
-        expect(
-          childOne.children[0].children[0].getAttribute('aria-labelledby'),
-        ).toEqual(childOne.children[0].children[1].getAttribute('id'));
-        expect(
-          childOne.children[0].children[2].getAttribute('aria-labelledby'),
-        ).toEqual(childOne.children[0].children[3].getAttribute('id'));
-
-        expect(
-          childOne.children[0].children[0].getAttribute('aria-labelledby'),
-        ).not.toEqual(
-          childOne.children[0].children[2].getAttribute('aria-labelledby'),
-        );
+        return <div id={id}>Child Two</div>;
+      }
 
-        expect(
-          childOne.children[0].children[0]
-            .getAttribute('aria-labelledby')
-            .startsWith('one'),
-        ).toBe(true);
-        expect(
-          childOne.children[0].children[2]
-            .getAttribute('aria-labelledby')
-            .includes('one'),
-        ).toBe(true);
-
-        expect(
-          childTwo.children[0].children[0].getAttribute('aria-labelledby'),
-        ).toEqual(childTwo.children[0].children[1].getAttribute('id'));
-        expect(
-          childTwo.children[0].children[2].getAttribute('aria-labelledby'),
-        ).toEqual(childTwo.children[0].children[3].getAttribute('id'));
-
-        expect(
-          childTwo.children[0].children[0].getAttribute('aria-labelledby'),
-        ).not.toEqual(
-          childTwo.children[0].children[2].getAttribute('aria-labelledby'),
+      function App() {
+        const id = useOpaqueIdentifier();
+
+        return (
+          <>
+            <div id={id}>Child One</div>
+            <ChildTwo />
+            <div aria-labelledby={id}>Aria One</div>
+          </>
         );
+      }
 
-        expect(
-          childTwo.children[0].children[0]
-            .getAttribute('aria-labelledby')
-            .startsWith('two'),
-        ).toBe(true);
-        expect(
-          childTwo.children[0].children[2]
-            .getAttribute('aria-labelledby')
-            .startsWith('two'),
-        ).toBe(true);
-      });
+      const container = document.createElement('div');
+      document.body.append(container);
 
-      it('useOpaqueIdentifier identifierPrefix works for multiple reads on a streaming server renderer', async () => {
-        function ChildTwo() {
-          const id = useOpaqueIdentifier();
+      const streamOne = ReactDOMServer.renderToNodeStream(<App />, {
+        identifierPrefix: 'one',
+      }).setEncoding('utf8');
+      const streamTwo = ReactDOMServer.renderToNodeStream(<App />, {
+        identifierPrefix: 'two',
+      }).setEncoding('utf8');
 
-          return <div id={id}>Child Two</div>;
-        }
+      const streamOneIsDone = new Promise((resolve, reject) => {
+        streamOne.on('end', () => resolve());
+        streamOne.on('error', e => reject(e));
+      });
+      const streamTwoIsDone = new Promise((resolve, reject) => {
+        streamTwo.on('end', () => resolve());
+        streamTwo.on('error', e => reject(e));
+      });
 
-        function App() {
-          const id = useOpaqueIdentifier();
+      const containerOne = document.createElement('div');
+      const containerTwo = document.createElement('div');
 
-          return (
-            <>
-              <div id={id}>Child One</div>
-              <ChildTwo />
-              <div aria-labelledby={id}>Aria One</div>
-            </>
-          );
-        }
+      streamOne._read(10);
+      streamTwo._read(10);
 
-        const container = document.createElement('div');
-        document.body.append(container);
+      containerOne.innerHTML = streamOne.read();
+      containerTwo.innerHTML = streamTwo.read();
 
-        const streamOne = ReactDOMServer.renderToNodeStream(<App />, {
-          identifierPrefix: 'one',
-        }).setEncoding('utf8');
-        const streamTwo = ReactDOMServer.renderToNodeStream(<App />, {
-          identifierPrefix: 'two',
-        }).setEncoding('utf8');
+      expect(containerOne.children[0].getAttribute('id')).not.toEqual(
+        containerOne.children[1].getAttribute('id'),
+      );
+      expect(containerTwo.children[0].getAttribute('id')).not.toEqual(
+        containerTwo.children[1].getAttribute('id'),
+      );
+      expect(containerOne.children[0].getAttribute('id')).not.toEqual(
+        containerTwo.children[0].getAttribute('id'),
+      );
+      expect(containerOne.children[0].getAttribute('id').includes('one')).toBe(
+        true,
+      );
+      expect(containerOne.children[1].getAttribute('id').includes('one')).toBe(
+        true,
+      );
+      expect(containerTwo.children[0].getAttribute('id').includes('two')).toBe(
+        true,
+      );
+      expect(containerTwo.children[1].getAttribute('id').includes('two')).toBe(
+        true,
+      );
+
+      expect(containerOne.children[1].getAttribute('id')).not.toEqual(
+        containerTwo.children[1].getAttribute('id'),
+      );
+      expect(containerOne.children[0].getAttribute('id')).toEqual(
+        containerOne.children[2].getAttribute('aria-labelledby'),
+      );
+      expect(containerTwo.children[0].getAttribute('id')).toEqual(
+        containerTwo.children[2].getAttribute('aria-labelledby'),
+      );
 
-        const containerOne = document.createElement('div');
-        const containerTwo = document.createElement('div');
+      // Exhaust the rest of the stream
+      class Sink extends require('stream').Writable {
+        _write(chunk, encoding, done) {
+          done();
+        }
+      }
+      streamOne.pipe(new Sink());
+      streamTwo.pipe(new Sink());
 
-        streamOne._read(10);
-        streamTwo._read(10);
+      await Promise.all([streamOneIsDone, streamTwoIsDone]);
+    });
 
-        containerOne.innerHTML = streamOne.read();
-        containerTwo.innerHTML = streamTwo.read();
+    // @gate experimental
+    it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
+      let _setShowDiv;
+      function App() {
+        const id = useOpaqueIdentifier();
+        const [showDiv, setShowDiv] = useState(false);
+        _setShowDiv = setShowDiv;
 
-        expect(containerOne.children[0].getAttribute('id')).not.toEqual(
-          containerOne.children[1].getAttribute('id'),
-        );
-        expect(containerTwo.children[0].getAttribute('id')).not.toEqual(
-          containerTwo.children[1].getAttribute('id'),
-        );
-        expect(containerOne.children[0].getAttribute('id')).not.toEqual(
-          containerTwo.children[0].getAttribute('id'),
-        );
-        expect(
-          containerOne.children[0].getAttribute('id').includes('one'),
-        ).toBe(true);
-        expect(
-          containerOne.children[1].getAttribute('id').includes('one'),
-        ).toBe(true);
-        expect(
-          containerTwo.children[0].getAttribute('id').includes('two'),
-        ).toBe(true);
-        expect(
-          containerTwo.children[1].getAttribute('id').includes('two'),
-        ).toBe(true);
-
-        expect(containerOne.children[1].getAttribute('id')).not.toEqual(
-          containerTwo.children[1].getAttribute('id'),
-        );
-        expect(containerOne.children[0].getAttribute('id')).toEqual(
-          containerOne.children[2].getAttribute('aria-labelledby'),
-        );
-        expect(containerTwo.children[0].getAttribute('id')).toEqual(
-          containerTwo.children[2].getAttribute('aria-labelledby'),
+        return (
+          <div>
+            <div id={id}>Child One</div>
+            {showDiv && <div id={id}>Child Two</div>}
+          </div>
         );
-      });
+      }
 
-      it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
-        let _setShowDiv;
-        function App() {
-          const id = useOpaqueIdentifier();
-          const [showDiv, setShowDiv] = useState(false);
-          _setShowDiv = setShowDiv;
+      const container = document.createElement('div');
+      document.body.append(container);
 
-          return (
-            <div>
-              <div id={id}>Child One</div>
-              {showDiv && <div id={id}>Child Two</div>}
-            </div>
-          );
-        }
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      root.render(<App />);
+      Scheduler.unstable_flushAll();
+      jest.runAllTimers();
 
-        const container = document.createElement('div');
-        document.body.append(container);
+      expect(container.children[0].children.length).toEqual(1);
+      const oldServerId = container.children[0].children[0].getAttribute('id');
+      expect(oldServerId).not.toBeNull();
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        root.render(<App />);
-        Scheduler.unstable_flushAll();
-        jest.runAllTimers();
+      await ReactTestUtils.act(async () => {
+        _setShowDiv(true);
+      });
+      expect(container.children[0].children.length).toEqual(2);
+      expect(container.children[0].children[0].getAttribute('id')).toEqual(
+        container.children[0].children[1].getAttribute('id'),
+      );
+      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
+        oldServerId,
+      );
+      expect(
+        container.children[0].children[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-        expect(container.children[0].children.length).toEqual(1);
-        const oldServerId = container.children[0].children[0].getAttribute(
-          'id',
-        );
-        expect(oldServerId).not.toBeNull();
+    // @gate experimental
+    it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered for legacy', async () => {
+      let _setShowDiv;
+      function App() {
+        const id = useOpaqueIdentifier();
+        const [showDiv, setShowDiv] = useState(false);
+        _setShowDiv = setShowDiv;
 
-        await ReactTestUtils.act(async () => {
-          _setShowDiv(true);
-        });
-        expect(container.children[0].children.length).toEqual(2);
-        expect(container.children[0].children[0].getAttribute('id')).toEqual(
-          container.children[0].children[1].getAttribute('id'),
+        return (
+          <div>
+            <div id={id}>Child One</div>
+            {showDiv && <div id={id}>Child Two</div>}
+          </div>
         );
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toEqual(oldServerId);
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered for legacy', async () => {
-        let _setShowDiv;
-        function App() {
-          const id = useOpaqueIdentifier();
-          const [showDiv, setShowDiv] = useState(false);
-          _setShowDiv = setShowDiv;
+      const container = document.createElement('div');
+      document.body.append(container);
 
-          return (
-            <div>
-              <div id={id}>Child One</div>
-              {showDiv && <div id={id}>Child Two</div>}
-            </div>
-          );
-        }
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      ReactDOM.hydrate(<App />, container);
 
-        const container = document.createElement('div');
-        document.body.append(container);
+      expect(container.children[0].children.length).toEqual(1);
+      const oldServerId = container.children[0].children[0].getAttribute('id');
+      expect(oldServerId).not.toBeNull();
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.hydrate(<App />, container);
+      await ReactTestUtils.act(async () => {
+        _setShowDiv(true);
+      });
+      expect(container.children[0].children.length).toEqual(2);
+      expect(container.children[0].children[0].getAttribute('id')).toEqual(
+        container.children[0].children[1].getAttribute('id'),
+      );
+      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
+        oldServerId,
+      );
+      expect(
+        container.children[0].children[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-        expect(container.children[0].children.length).toEqual(1);
-        const oldServerId = container.children[0].children[0].getAttribute(
-          'id',
+    // @gate experimental
+    it('useOpaqueIdentifier: ID is not used during hydration but is used in an update', async () => {
+      let _setShow;
+      function App({unused}) {
+        Scheduler.unstable_yieldValue('App');
+        const id = useOpaqueIdentifier();
+        const [show, setShow] = useState(false);
+        _setShow = setShow;
+        return (
+          <div>
+            <span id={show ? id : null}>{'Child One'}</span>
+          </div>
         );
-        expect(oldServerId).not.toBeNull();
+      }
 
-        await ReactTestUtils.act(async () => {
-          _setShowDiv(true);
-        });
-        expect(container.children[0].children.length).toEqual(2);
-        expect(container.children[0].children[0].getAttribute('id')).toEqual(
-          container.children[0].children[1].getAttribute('id'),
-        );
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toEqual(oldServerId);
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toBeNull();
+      const container = document.createElement('div');
+      document.body.append(container);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      ReactTestUtils.act(() => {
+        root.render(<App />);
       });
-
-      it('useOpaqueIdentifier: ID is not used during hydration but is used in an update', async () => {
-        let _setShow;
-        function App({unused}) {
-          Scheduler.unstable_yieldValue('App');
-          const id = useOpaqueIdentifier();
-          const [show, setShow] = useState(false);
-          _setShow = setShow;
-          return (
-            <div>
-              <span id={show ? id : null}>{'Child One'}</span>
-            </div>
-          );
-        }
-
-        const container = document.createElement('div');
-        document.body.append(container);
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        ReactTestUtils.act(() => {
-          root.render(<App />);
-        });
-        expect(Scheduler).toHaveYielded(['App', 'App']);
-        // The ID goes from not being used to being added to the page
-        ReactTestUtils.act(() => {
-          _setShow(true);
-        });
-        expect(Scheduler).toHaveYielded(['App', 'App']);
-        expect(
-          container.getElementsByTagName('span')[0].getAttribute('id'),
-        ).not.toBeNull();
+      expect(Scheduler).toHaveYielded(['App', 'App']);
+      // The ID goes from not being used to being added to the page
+      ReactTestUtils.act(() => {
+        _setShow(true);
       });
+      expect(Scheduler).toHaveYielded(['App', 'App']);
+      expect(
+        container.getElementsByTagName('span')[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-      it('useOpaqueIdentifier: ID is not used during hydration but is used in an update in legacy', async () => {
-        let _setShow;
-        function App({unused}) {
-          Scheduler.unstable_yieldValue('App');
-          const id = useOpaqueIdentifier();
-          const [show, setShow] = useState(false);
-          _setShow = setShow;
-          return (
-            <div>
-              <span id={show ? id : null}>{'Child One'}</span>
-            </div>
-          );
-        }
+    // @gate experimental
+    it('useOpaqueIdentifier: ID is not used during hydration but is used in an update in legacy', async () => {
+      let _setShow;
+      function App({unused}) {
+        Scheduler.unstable_yieldValue('App');
+        const id = useOpaqueIdentifier();
+        const [show, setShow] = useState(false);
+        _setShow = setShow;
+        return (
+          <div>
+            <span id={show ? id : null}>{'Child One'}</span>
+          </div>
+        );
+      }
 
-        const container = document.createElement('div');
-        document.body.append(container);
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.hydrate(<App />, container);
-        expect(Scheduler).toHaveYielded(['App', 'App']);
-        // The ID goes from not being used to being added to the page
-        ReactTestUtils.act(() => {
-          _setShow(true);
-        });
-        expect(Scheduler).toHaveYielded(['App']);
-        expect(
-          container.getElementsByTagName('span')[0].getAttribute('id'),
-        ).not.toBeNull();
+      const container = document.createElement('div');
+      document.body.append(container);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      ReactDOM.hydrate(<App />, container);
+      expect(Scheduler).toHaveYielded(['App', 'App']);
+      // The ID goes from not being used to being added to the page
+      ReactTestUtils.act(() => {
+        _setShow(true);
       });
+      expect(Scheduler).toHaveYielded(['App']);
+      expect(
+        container.getElementsByTagName('span')[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-      it('useOpaqueIdentifier: flushSync', async () => {
-        let _setShow;
-        function App() {
-          const id = useOpaqueIdentifier();
-          const [show, setShow] = useState(false);
-          _setShow = setShow;
-          return (
-            <div>
-              <span id={show ? id : null}>{'Child One'}</span>
-            </div>
-          );
-        }
+    // @gate experimental
+    it('useOpaqueIdentifier: flushSync', async () => {
+      let _setShow;
+      function App() {
+        const id = useOpaqueIdentifier();
+        const [show, setShow] = useState(false);
+        _setShow = setShow;
+        return (
+          <div>
+            <span id={show ? id : null}>{'Child One'}</span>
+          </div>
+        );
+      }
 
-        const container = document.createElement('div');
-        document.body.append(container);
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        ReactTestUtils.act(() => {
-          root.render(<App />);
-        });
+      const container = document.createElement('div');
+      document.body.append(container);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      ReactTestUtils.act(() => {
+        root.render(<App />);
+      });
 
-        // The ID goes from not being used to being added to the page
-        ReactTestUtils.act(() => {
-          ReactDOM.flushSync(() => {
-            _setShow(true);
-          });
+      // The ID goes from not being used to being added to the page
+      ReactTestUtils.act(() => {
+        ReactDOM.flushSync(() => {
+          _setShow(true);
         });
-        expect(
-          container.getElementsByTagName('span')[0].getAttribute('id'),
-        ).not.toBeNull();
       });
+      expect(
+        container.getElementsByTagName('span')[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-      it('useOpaqueIdentifier: children with id hydrates before other children if ID updates', async () => {
-        let _setShow;
-
-        const child1Ref = React.createRef();
-        const childWithIDRef = React.createRef();
-        const setShowRef = React.createRef();
+    // @gate experimental
+    it('useOpaqueIdentifier: children with id hydrates before other children if ID updates', async () => {
+      let _setShow;
 
-        // RENAME THESE
-        function Child1() {
-          Scheduler.unstable_yieldValue('Child One');
-          return <span ref={child1Ref}>{'Child One'}</span>;
-        }
+      const child1Ref = React.createRef();
+      const childWithIDRef = React.createRef();
+      const setShowRef = React.createRef();
 
-        function Child2() {
-          Scheduler.unstable_yieldValue('Child Two');
-          return <span>{'Child Two'}</span>;
-        }
+      // RENAME THESE
+      function Child1() {
+        Scheduler.unstable_yieldValue('Child One');
+        return <span ref={child1Ref}>{'Child One'}</span>;
+      }
 
-        const Children = React.memo(function Children() {
-          return (
-            <React.Suspense fallback="Loading 1...">
-              <Child1 />
-              <Child2 />
-            </React.Suspense>
-          );
-        });
+      function Child2() {
+        Scheduler.unstable_yieldValue('Child Two');
+        return <span>{'Child Two'}</span>;
+      }
 
-        function ChildWithID({parentID}) {
-          Scheduler.unstable_yieldValue('Child with ID');
-          return (
-            <span id={parentID} ref={childWithIDRef}>
-              {'Child with ID'}
-            </span>
-          );
-        }
+      const Children = React.memo(function Children() {
+        return (
+          <React.Suspense fallback="Loading 1...">
+            <Child1 />
+            <Child2 />
+          </React.Suspense>
+        );
+      });
 
-        const ChildrenWithID = React.memo(function ChildrenWithID({parentID}) {
-          return (
-            <React.Suspense fallback="Loading 2...">
-              <ChildWithID parentID={parentID} />
-            </React.Suspense>
-          );
-        });
+      function ChildWithID({parentID}) {
+        Scheduler.unstable_yieldValue('Child with ID');
+        return (
+          <span id={parentID} ref={childWithIDRef}>
+            {'Child with ID'}
+          </span>
+        );
+      }
 
-        function App() {
-          const id = useOpaqueIdentifier();
-          const [show, setShow] = useState(false);
-          _setShow = setShow;
-          return (
-            <div>
-              <Children />
-              <ChildrenWithID parentID={id} />
-              {show && (
-                <span aria-labelledby={id} ref={setShowRef}>
-                  {'Child Three'}
-                </span>
-              )}
-            </div>
-          );
-        }
+      const ChildrenWithID = React.memo(function ChildrenWithID({parentID}) {
+        return (
+          <React.Suspense fallback="Loading 2...">
+            <ChildWithID parentID={parentID} />
+          </React.Suspense>
+        );
+      });
 
-        const container = document.createElement('div');
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        expect(Scheduler).toHaveYielded([
-          'Child One',
-          'Child Two',
-          'Child with ID',
-        ]);
-        expect(container.textContent).toEqual(
-          'Child OneChild TwoChild with ID',
+      function App() {
+        const id = useOpaqueIdentifier();
+        const [show, setShow] = useState(false);
+        _setShow = setShow;
+        return (
+          <div>
+            <Children />
+            <ChildrenWithID parentID={id} />
+            {show && (
+              <span aria-labelledby={id} ref={setShowRef}>
+                {'Child Three'}
+              </span>
+            )}
+          </div>
         );
+      }
 
-        const serverId = container
-          .getElementsByTagName('span')[2]
-          .getAttribute('id');
-        expect(serverId).not.toBeNull();
+      const container = document.createElement('div');
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      expect(Scheduler).toHaveYielded([
+        'Child One',
+        'Child Two',
+        'Child with ID',
+      ]);
+      expect(container.textContent).toEqual('Child OneChild TwoChild with ID');
 
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        root.render(<App show={false} />);
-        expect(Scheduler).toHaveYielded([]);
+      const serverId = container
+        .getElementsByTagName('span')[2]
+        .getAttribute('id');
+      expect(serverId).not.toBeNull();
 
-        //Hydrate just child one before updating state
-        expect(Scheduler).toFlushAndYieldThrough(['Child One']);
-        expect(child1Ref.current).toBe(null);
-        expect(Scheduler).toHaveYielded([]);
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      root.render(<App show={false} />);
+      expect(Scheduler).toHaveYielded([]);
 
-        ReactTestUtils.act(() => {
-          _setShow(true);
+      //Hydrate just child one before updating state
+      expect(Scheduler).toFlushAndYieldThrough(['Child One']);
+      expect(child1Ref.current).toBe(null);
+      expect(Scheduler).toHaveYielded([]);
 
-          // State update should trigger the ID to update, which changes the props
-          // of ChildWithID. This should cause ChildWithID to hydrate before Children
-
-          expect(Scheduler).toFlushAndYieldThrough([
-            'Child with ID',
-            // Fallbacks are immediately committed in TestUtils version
-            // of act
-            // 'Child with ID',
-            // 'Child with ID',
-            'Child One',
-            'Child Two',
-          ]);
-
-          expect(child1Ref.current).toBe(null);
-          expect(childWithIDRef.current).toEqual(
-            container.getElementsByTagName('span')[2],
-          );
+      ReactTestUtils.act(() => {
+        _setShow(true);
 
-          expect(setShowRef.current).toEqual(
-            container.getElementsByTagName('span')[3],
-          );
+        // State update should trigger the ID to update, which changes the props
+        // of ChildWithID. This should cause ChildWithID to hydrate before Children
 
-          expect(childWithIDRef.current.getAttribute('id')).toEqual(
-            setShowRef.current.getAttribute('aria-labelledby'),
-          );
-          expect(childWithIDRef.current.getAttribute('id')).not.toEqual(
-            serverId,
-          );
-        });
+        expect(Scheduler).toFlushAndYieldThrough([
+          'Child with ID',
+          // Fallbacks are immediately committed in TestUtils version
+          // of act
+          // 'Child with ID',
+          // 'Child with ID',
+          'Child One',
+          'Child Two',
+        ]);
 
-        // Children hydrates after ChildWithID
-        expect(child1Ref.current).toBe(
-          container.getElementsByTagName('span')[0],
+        expect(child1Ref.current).toBe(null);
+        expect(childWithIDRef.current).toEqual(
+          container.getElementsByTagName('span')[2],
         );
 
-        Scheduler.unstable_flushAll();
-
-        expect(Scheduler).toHaveYielded([]);
-      });
+        expect(setShowRef.current).toEqual(
+          container.getElementsByTagName('span')[3],
+        );
 
-      it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
-        let suspend = true;
-        let resolve;
-        const promise = new Promise(
-          resolvePromise => (resolve = resolvePromise),
+        expect(childWithIDRef.current.getAttribute('id')).toEqual(
+          setShowRef.current.getAttribute('aria-labelledby'),
         );
+        expect(childWithIDRef.current.getAttribute('id')).not.toEqual(serverId);
+      });
 
-        function Child({text}) {
-          if (suspend) {
-            throw promise;
-          } else {
-            return text;
-          }
-        }
+      // Children hydrates after ChildWithID
+      expect(child1Ref.current).toBe(container.getElementsByTagName('span')[0]);
 
-        function RenderedChild() {
-          useEffect(() => {
-            Scheduler.unstable_yieldValue('Child did commit');
-          });
-          return null;
-        }
+      Scheduler.unstable_flushAll();
 
-        function App() {
-          const id = useOpaqueIdentifier();
-          useEffect(() => {
-            Scheduler.unstable_yieldValue('Did commit');
-          });
-          return (
-            <div>
-              <div id={id}>Child One</div>
-              <RenderedChild />
-              <React.Suspense fallback={'Fallback'}>
-                <div id={id}>
-                  <Child text="Child Two" />
-                </div>
-              </React.Suspense>
-            </div>
-          );
-        }
+      expect(Scheduler).toHaveYielded([]);
+    });
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+    // @gate experimental
+    it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
+      let suspend = true;
+      let resolve;
+      const promise = new Promise(resolvePromise => (resolve = resolvePromise));
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
+      function Child({text}) {
+        if (suspend) {
+          throw promise;
+        } else {
+          return text;
+        }
+      }
 
-        suspend = true;
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        await ReactTestUtils.act(async () => {
-          root.render(<App />);
-        });
-        jest.runAllTimers();
-        expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
-        expect(Scheduler).toFlushAndYield([]);
-
-        const serverId = container.children[0].children[0].getAttribute('id');
-        expect(container.children[0].children.length).toEqual(1);
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toBeNull();
-
-        await ReactTestUtils.act(async () => {
-          suspend = false;
-          resolve();
-          await promise;
+      function RenderedChild() {
+        useEffect(() => {
+          Scheduler.unstable_yieldValue('Child did commit');
         });
+        return null;
+      }
 
-        expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
-        expect(Scheduler).toFlushAndYield([]);
-        jest.runAllTimers();
-
-        expect(container.children[0].children.length).toEqual(2);
-        expect(container.children[0].children[0].getAttribute('id')).toEqual(
-          container.children[0].children[1].getAttribute('id'),
+      function App() {
+        const id = useOpaqueIdentifier();
+        useEffect(() => {
+          Scheduler.unstable_yieldValue('Did commit');
+        });
+        return (
+          <div>
+            <div id={id}>Child One</div>
+            <RenderedChild />
+            <React.Suspense fallback={'Fallback'}>
+              <div id={id}>
+                <Child text="Child Two" />
+              </div>
+            </React.Suspense>
+          </div>
         );
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toEqual(serverId);
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toBeNull();
-      });
+      }
 
-      it('useOpaqueIdentifier warn when there is a hydration error', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <Child appId={id} />;
-        }
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        // This is the wrong HTML string
-        container.innerHTML = '<span></span>';
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-          'Warning: Expected server HTML to contain a matching <div> in <div>.',
-        ]);
+      suspend = true;
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      await ReactTestUtils.act(async () => {
+        root.render(<App />);
       });
+      jest.runAllTimers();
+      expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
+      expect(Scheduler).toFlushAndYield([]);
 
-      it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
-        let suspend = true;
+      const serverId = container.children[0].children[0].getAttribute('id');
+      expect(container.children[0].children.length).toEqual(1);
+      expect(
+        container.children[0].children[0].getAttribute('id'),
+      ).not.toBeNull();
 
-        function Child({text}) {
-          if (suspend) {
-            throw new Promise(() => {});
-          } else {
-            return text;
-          }
-        }
+      await ReactTestUtils.act(async () => {
+        suspend = false;
+        resolve();
+        await promise;
+      });
 
-        function RenderedChild() {
-          useEffect(() => {
-            Scheduler.unstable_yieldValue('Child did commit');
-          });
-          return null;
-        }
+      expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
+      expect(Scheduler).toFlushAndYield([]);
+      jest.runAllTimers();
 
-        function App() {
-          const id = useOpaqueIdentifier();
-          useEffect(() => {
-            Scheduler.unstable_yieldValue('Did commit');
-          });
-          return (
-            <div>
-              <div id={id}>Child One</div>
-              <RenderedChild />
-              <React.Suspense fallback={'Fallback'}>
-                <div id={id}>
-                  <Child text="Child Two" />
-                </div>
-              </React.Suspense>
-            </div>
-          );
-        }
+      expect(container.children[0].children.length).toEqual(2);
+      expect(container.children[0].children[0].getAttribute('id')).toEqual(
+        container.children[0].children[1].getAttribute('id'),
+      );
+      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
+        serverId,
+      );
+      expect(
+        container.children[0].children[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+    // @gate experimental
+    it('useOpaqueIdentifier warn when there is a hydration error', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <Child appId={id} />;
+      }
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-        suspend = false;
-        const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-        await ReactTestUtils.act(async () => {
-          root.render(<App />);
-        });
-        jest.runAllTimers();
-        expect(Scheduler).toHaveYielded([
-          'Child did commit',
-          'Did commit',
-          'Child did commit',
-          'Did commit',
-        ]);
-        expect(Scheduler).toFlushAndYield([]);
+      // This is the wrong HTML string
+      container.innerHTML = '<span></span>';
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev([
+        'Warning: Expected server HTML to contain a matching <div> in <div>.',
+      ]);
+    });
 
-        expect(container.children[0].children.length).toEqual(2);
-        expect(container.children[0].children[0].getAttribute('id')).toEqual(
-          container.children[0].children[1].getAttribute('id'),
-        );
-        expect(
-          container.children[0].children[0].getAttribute('id'),
-        ).not.toBeNull();
-      });
+    // @gate experimental
+    it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
+      let suspend = true;
 
-      it('useOpaqueIdentifier warn when there is a hydration error', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <Child appId={id} />;
+      function Child({text}) {
+        if (suspend) {
+          throw new Promise(() => {});
+        } else {
+          return text;
         }
+      }
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+      function RenderedChild() {
+        useEffect(() => {
+          Scheduler.unstable_yieldValue('Child did commit');
+        });
+        return null;
+      }
 
-        // This is the wrong HTML string
-        container.innerHTML = '<span></span>';
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
+      function App() {
+        const id = useOpaqueIdentifier();
+        useEffect(() => {
+          Scheduler.unstable_yieldValue('Did commit');
+        });
+        return (
+          <div>
+            <div id={id}>Child One</div>
+            <RenderedChild />
+            <React.Suspense fallback={'Fallback'}>
+              <div id={id}>
+                <Child text="Child Two" />
+              </div>
+            </React.Suspense>
+          </div>
         );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-          'Warning: Expected server HTML to contain a matching <div> in <div>.',
-        ]);
-      });
+      }
 
-      it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId + ''} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <Child appId={id} />;
-        }
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        // This is the wrong HTML string
-        container.innerHTML = '<span></span>';
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-          [
-            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-            'Warning: Did not expect server HTML to contain a <span> in <div>.',
-          ],
-          {withoutStack: 1},
-        );
+      suspend = false;
+      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      await ReactTestUtils.act(async () => {
+        root.render(<App />);
       });
+      jest.runAllTimers();
+      expect(Scheduler).toHaveYielded([
+        'Child did commit',
+        'Did commit',
+        'Child did commit',
+        'Did commit',
+      ]);
+      expect(Scheduler).toFlushAndYield([]);
 
-      it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId + ''} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <Child appId={id} />;
-        }
+      expect(container.children[0].children.length).toEqual(2);
+      expect(container.children[0].children[0].getAttribute('id')).toEqual(
+        container.children[0].children[1].getAttribute('id'),
+      );
+      expect(
+        container.children[0].children[0].getAttribute('id'),
+      ).not.toBeNull();
+    });
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+    // @gate experimental
+    it('useOpaqueIdentifier warn when there is a hydration error', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <Child appId={id} />;
+      }
 
-        // This is the wrong HTML string
-        container.innerHTML = '<span></span>';
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-          [
-            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-            'Warning: Did not expect server HTML to contain a <span> in <div>.',
-          ],
-          {withoutStack: 1},
-        );
-      });
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-      it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId + ''} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <Child appId={id} />;
-        }
+      // This is the wrong HTML string
+      container.innerHTML = '<span></span>';
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev([
+        'Warning: Expected server HTML to contain a matching <div> in <div>.',
+      ]);
+    });
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+    // @gate experimental
+    it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId + ''} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <Child appId={id} />;
+      }
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-          [
-            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-            'Warning: Did not expect server HTML to contain a <div> in <div>.',
-          ],
-          {withoutStack: 1},
-        );
-      });
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+
+      // This is the wrong HTML string
+      container.innerHTML = '<span></span>';
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+          'Warning: Did not expect server HTML to contain a <span> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
+    });
 
-      it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
-        function App() {
-          const id = useOpaqueIdentifier();
-          return <div aria-labelledby={id + ''} />;
-        }
+    // @gate experimental
+    it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId + ''} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <Child appId={id} />;
+      }
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+
+      // This is the wrong HTML string
+      container.innerHTML = '<span></span>';
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+          'Warning: Did not expect server HTML to contain a <span> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
+    });
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-          [
-            'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-            'Warning: Did not expect server HTML to contain a <div> in <div>.',
-          ],
-          {withoutStack: 1},
-        );
-      });
+    // @gate experimental
+    it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId + ''} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <Child appId={id} />;
+      }
 
-      it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={appId + ''} />;
-        }
-        function App() {
-          const id = useOpaqueIdentifier();
-          return (
-            <React.Suspense fallback={null}>
-              <Child appId={id} />
-            </React.Suspense>
-          );
-        }
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+          'Warning: Did not expect server HTML to contain a <div> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
+    });
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+    // @gate experimental
+    it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
+      function App() {
+        const id = useOpaqueIdentifier();
+        return <div aria-labelledby={id + ''} />;
+      }
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
+          'Warning: Did not expect server HTML to contain a <div> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
+    });
 
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
+    // @gate experimental
+    it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={appId + ''} />;
+      }
+      function App() {
+        const id = useOpaqueIdentifier();
+        return (
+          <React.Suspense fallback={null}>
+            <Child appId={id} />
+          </React.Suspense>
         );
+      }
 
-        if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-          expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ]);
-        } else {
-          // This error isn't surfaced to the user; only the warning is.
-          // The error is just the mechanism that restarts the render.
-          expect(() =>
-            expect(() => Scheduler.unstable_flushAll()).toThrow(
-              'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-                'Do not read the value directly.',
-            ),
-          ).toErrorDev([
+      const container = document.createElement('div');
+      document.body.appendChild(container);
+
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+
+      if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      } else {
+        // This error isn't surfaced to the user; only the warning is.
+        // The error is just the mechanism that restarts the render.
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
-          ]);
-        }
-      });
+          ),
+        ).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      }
+    });
 
-      it('useOpaqueIdentifier warns if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
-        function Child({appId}) {
-          return <div aria-labelledby={+appId} />;
-        }
-        function App() {
-          const [show] = useState(false);
-          const id = useOpaqueIdentifier();
-          return (
-            <React.Suspense fallback={null}>
-              {show && <div id={id} />}
-              <Child appId={id} />
-            </React.Suspense>
-          );
-        }
+    // @gate experimental
+    it('useOpaqueIdentifier warns if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
+      function Child({appId}) {
+        return <div aria-labelledby={+appId} />;
+      }
+      function App() {
+        const [show] = useState(false);
+        const id = useOpaqueIdentifier();
+        return (
+          <React.Suspense fallback={null}>
+            {show && <div id={id} />}
+            <Child appId={id} />
+          </React.Suspense>
+        );
+      }
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
 
-        if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-          expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ]);
-        } else {
-          // This error isn't surfaced to the user; only the warning is.
-          // The error is just the mechanism that restarts the render.
-          expect(() =>
-            expect(() => Scheduler.unstable_flushAll()).toThrow(
-              'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-                'Do not read the value directly.',
-            ),
-          ).toErrorDev([
+      if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
+        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      } else {
+        // This error isn't surfaced to the user; only the warning is.
+        // The error is just the mechanism that restarts the render.
+        expect(() =>
+          expect(() => Scheduler.unstable_flushAll()).toThrow(
             'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
               'Do not read the value directly.',
-          ]);
-        }
-      });
-
-      it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {
-        let _setShow;
+          ),
+        ).toErrorDev([
+          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
+            'Do not read the value directly.',
+        ]);
+      }
+    });
 
-        function App() {
-          const id1 = useOpaqueIdentifier();
-          const id2 = useOpaqueIdentifier();
-          const [show, setShow] = useState(true);
-          _setShow = setShow;
+    // @gate experimental
+    it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {
+      let _setShow;
 
-          return (
-            <div>
-              <React.Suspense fallback={null}>
-                {show ? (
-                  <span id={id1}>{'Child'}</span>
-                ) : (
-                  <span id={id2}>{'Child'}</span>
-                )}
-              </React.Suspense>
-              <span aria-labelledby={id1}>{'test'}</span>
-            </div>
-          );
-        }
+      function App() {
+        const id1 = useOpaqueIdentifier();
+        const id2 = useOpaqueIdentifier();
+        const [show, setShow] = useState(true);
+        _setShow = setShow;
 
-        const container = document.createElement('div');
-        document.body.appendChild(container);
+        return (
+          <div>
+            <React.Suspense fallback={null}>
+              {show ? (
+                <span id={id1}>{'Child'}</span>
+              ) : (
+                <span id={id2}>{'Child'}</span>
+              )}
+            </React.Suspense>
+            <span aria-labelledby={id1}>{'test'}</span>
+          </div>
+        );
+      }
 
-        container.innerHTML = ReactDOMServer.renderToString(<App />);
+      const container = document.createElement('div');
+      document.body.appendChild(container);
 
-        const serverID = container
-          .getElementsByTagName('span')[0]
-          .getAttribute('id');
-        expect(serverID).not.toBeNull();
-        expect(
-          container
-            .getElementsByTagName('span')[1]
-            .getAttribute('aria-labelledby'),
-        ).toEqual(serverID);
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-        ReactDOM.unstable_createRoot(container, {hydrate: true}).render(
-          <App />,
-        );
-        jest.runAllTimers();
-        expect(Scheduler).toHaveYielded([]);
-        expect(Scheduler).toFlushAndYield([]);
+      const serverID = container
+        .getElementsByTagName('span')[0]
+        .getAttribute('id');
+      expect(serverID).not.toBeNull();
+      expect(
+        container
+          .getElementsByTagName('span')[1]
+          .getAttribute('aria-labelledby'),
+      ).toEqual(serverID);
 
-        ReactTestUtils.act(() => {
-          _setShow(false);
-        });
+      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      jest.runAllTimers();
+      expect(Scheduler).toHaveYielded([]);
+      expect(Scheduler).toFlushAndYield([]);
 
-        expect(
-          container
-            .getElementsByTagName('span')[1]
-            .getAttribute('aria-labelledby'),
-        ).toEqual(serverID);
-        expect(
-          container.getElementsByTagName('span')[0].getAttribute('id'),
-        ).not.toEqual(serverID);
-        expect(
-          container.getElementsByTagName('span')[0].getAttribute('id'),
-        ).not.toBeNull();
+      ReactTestUtils.act(() => {
+        _setShow(false);
       });
+
+      expect(
+        container
+          .getElementsByTagName('span')[1]
+          .getAttribute('aria-labelledby'),
+      ).toEqual(serverID);
+      expect(
+        container.getElementsByTagName('span')[0].getAttribute('id'),
+      ).not.toEqual(serverID);
+      expect(
+        container.getElementsByTagName('span')[0].getAttribute('id'),
+      ).not.toBeNull();
     });
-  }
+  });
 });

commit d17086c7c813402a550d15a2f56dc43f1dbd1735
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 8 10:11:45 2020 -0500

    Decouple public, internal act implementation (#19745)
    
    In the next major release, we intend to drop support for using the `act`
    testing helper in production. (It already fires a warning.) The
    rationale is that, in order for `act` to work, you must either mock the
    testing environment or add extra logic at runtime. Mocking the testing
    environment isn't ideal because it requires extra set up for the user.
    Extra logic at runtime is fine only in development mode — we don't want
    to slow down the production builds.
    
    Since most people only run their tests in development mode, dropping
    support for production should be fine; if there's demand, we can add it
    back later using a special testing build that is identical to the
    production build except for the additional testing logic.
    
    One blocker for removing production support is that we currently use
    `act` to test React itself. We must test React in both development and
    production modes.
    
    So, the solution is to fork `act` into separate public and
    internal implementations:
    
    - *public implementation of `act`* – exposed to users, only works in
      development mode, uses special runtime logic, does not support partial
      rendering
    - *internal implementation of `act`* – private, works in both
      development and productionm modes, only used by the React Core test
      suite, uses no special runtime logic, supports partial rendering (i.e.
      `toFlushAndYieldThrough`)
    
    The internal implementation should mostly match the public
    implementation's behavior, but since it's a private API, it doesn't have
    to match exactly. It works by mocking the test environment: it uses a
    mock build of Scheduler to flush rendering tasks, and Jest's mock timers
    to flush Suspense placeholders.
    
    ---
    
    In this first commit, I've added the internal forks of `act` and
    migrated our tests to use them. The public `act` implementation is
    unaffected for now; I will leave refactoring/clean-up for a later step.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index a66a868667..6cb57a8560 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -17,6 +17,7 @@ let React;
 let ReactDOM;
 let ReactDOMServer;
 let ReactTestUtils;
+let act;
 let Scheduler;
 let useState;
 let useReducer;
@@ -43,6 +44,7 @@ function initModules() {
   ReactDOMServer = require('react-dom/server');
   ReactTestUtils = require('react-dom/test-utils');
   Scheduler = require('scheduler');
+  act = ReactTestUtils.unstable_concurrentAct;
   useState = React.useState;
   useReducer = React.useReducer;
   useEffect = React.useEffect;
@@ -1063,7 +1065,7 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.children.length).toEqual(1);
       expect(oldClientId).not.toBeNull();
 
-      await ReactTestUtils.act(async () => _setShowId(true));
+      await act(async () => _setShowId(true));
 
       expect(domNode.children.length).toEqual(2);
       expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
@@ -1281,7 +1283,7 @@ describe('ReactDOMServerHooks', () => {
       const oldServerId = container.children[0].children[0].getAttribute('id');
       expect(oldServerId).not.toBeNull();
 
-      await ReactTestUtils.act(async () => {
+      await act(async () => {
         _setShowDiv(true);
       });
       expect(container.children[0].children.length).toEqual(2);
@@ -1322,7 +1324,7 @@ describe('ReactDOMServerHooks', () => {
       const oldServerId = container.children[0].children[0].getAttribute('id');
       expect(oldServerId).not.toBeNull();
 
-      await ReactTestUtils.act(async () => {
+      await act(async () => {
         _setShowDiv(true);
       });
       expect(container.children[0].children.length).toEqual(2);
@@ -1356,12 +1358,12 @@ describe('ReactDOMServerHooks', () => {
       document.body.append(container);
       container.innerHTML = ReactDOMServer.renderToString(<App />);
       const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-      ReactTestUtils.act(() => {
+      act(() => {
         root.render(<App />);
       });
       expect(Scheduler).toHaveYielded(['App', 'App']);
       // The ID goes from not being used to being added to the page
-      ReactTestUtils.act(() => {
+      act(() => {
         _setShow(true);
       });
       expect(Scheduler).toHaveYielded(['App', 'App']);
@@ -1391,7 +1393,7 @@ describe('ReactDOMServerHooks', () => {
       ReactDOM.hydrate(<App />, container);
       expect(Scheduler).toHaveYielded(['App', 'App']);
       // The ID goes from not being used to being added to the page
-      ReactTestUtils.act(() => {
+      act(() => {
         _setShow(true);
       });
       expect(Scheduler).toHaveYielded(['App']);
@@ -1418,12 +1420,12 @@ describe('ReactDOMServerHooks', () => {
       document.body.append(container);
       container.innerHTML = ReactDOMServer.renderToString(<App />);
       const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-      ReactTestUtils.act(() => {
+      act(() => {
         root.render(<App />);
       });
 
       // The ID goes from not being used to being added to the page
-      ReactTestUtils.act(() => {
+      act(() => {
         ReactDOM.flushSync(() => {
           _setShow(true);
         });
@@ -1518,7 +1520,7 @@ describe('ReactDOMServerHooks', () => {
       expect(child1Ref.current).toBe(null);
       expect(Scheduler).toHaveYielded([]);
 
-      ReactTestUtils.act(() => {
+      act(() => {
         _setShow(true);
 
         // State update should trigger the ID to update, which changes the props
@@ -1603,7 +1605,7 @@ describe('ReactDOMServerHooks', () => {
 
       suspend = true;
       const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-      await ReactTestUtils.act(async () => {
+      await act(async () => {
         root.render(<App />);
       });
       jest.runAllTimers();
@@ -1616,7 +1618,7 @@ describe('ReactDOMServerHooks', () => {
         container.children[0].children[0].getAttribute('id'),
       ).not.toBeNull();
 
-      await ReactTestUtils.act(async () => {
+      await act(async () => {
         suspend = false;
         resolve();
         await promise;
@@ -1703,7 +1705,7 @@ describe('ReactDOMServerHooks', () => {
 
       suspend = false;
       const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
-      await ReactTestUtils.act(async () => {
+      await act(async () => {
         root.render(<App />);
       });
       jest.runAllTimers();
@@ -1968,7 +1970,7 @@ describe('ReactDOMServerHooks', () => {
       expect(Scheduler).toHaveYielded([]);
       expect(Scheduler).toFlushAndYield([]);
 
-      ReactTestUtils.act(() => {
+      act(() => {
         _setShow(false);
       });
 

commit c59c3dfe554dafb64864f3bbcfff6ffe51f32275
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Oct 19 16:05:00 2020 -0400

    useRef: Warn about reading or writing mutable values during render (#18545)
    
    Reading or writing a ref value during render is only safe if you are implementing the lazy initialization pattern.
    
    Other types of reading are unsafe as the ref is a mutable source.
    
    Other types of writing are unsafe as they are effectively side effects.
    
    This change also refactors useTransition to no longer use a ref hook, but instead manage its own (stable) hook state.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 6cb57a8560..397b739546 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -474,12 +474,12 @@ describe('ReactDOMServerHooks', () => {
   describe('useRef', () => {
     itRenders('basic render', async render => {
       function Counter(props) {
-        const count = useRef(0);
-        return <span>Count: {count.current}</span>;
+        const ref = useRef();
+        return <span ref={ref}>Hi</span>;
       }
 
       const domNode = await render(<Counter />);
-      expect(domNode.textContent).toEqual('Count: 0');
+      expect(domNode.textContent).toEqual('Hi');
     });
 
     itRenders(
@@ -487,18 +487,16 @@ describe('ReactDOMServerHooks', () => {
       async render => {
         function Counter(props) {
           const [count, setCount] = useState(0);
-          const ref = useRef(count);
+          const ref = useRef();
 
           if (count < 3) {
             const newCount = count + 1;
-
-            ref.current = newCount;
             setCount(newCount);
           }
 
           yieldValue(count);
 
-          return <span>Count: {ref.current}</span>;
+          return <span ref={ref}>Count: {count}</span>;
         }
 
         const domNode = await render(<Counter />);
@@ -513,7 +511,7 @@ describe('ReactDOMServerHooks', () => {
         let firstRef = null;
         function Counter(props) {
           const [count, setCount] = useState(0);
-          const ref = useRef(count);
+          const ref = useRef();
           if (firstRef === null) {
             firstRef = ref;
           } else if (firstRef !== ref) {
@@ -528,12 +526,12 @@ describe('ReactDOMServerHooks', () => {
 
           yieldValue(count);
 
-          return <span>Count: {ref.current}</span>;
+          return <span ref={ref}>Count: {count}</span>;
         }
 
         const domNode = await render(<Counter />);
         expect(clearYields()).toEqual([0, 1, 2, 3]);
-        expect(domNode.textContent).toEqual('Count: 0');
+        expect(domNode.textContent).toEqual('Count: 3');
       },
     );
   });

commit 825c3021f0477bf8bd4b57693f3303078e7c77db
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Mar 17 11:18:42 2021 -0400

    Don't delete trailing mismatches during hydration at the root (#21021)
    
    * Don't delete any trailing nodes in the container during hydration error
    
    * Warn when an error during hydration causes us to clear the container
    
    * Encode unfortunate case in test
    
    * Wrap the root for tests that are applicable to nested cases
    
    * Now we can pipe Fizz into a container
    
    * Grammatical fix

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 397b739546..3014ecd810 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1654,9 +1654,13 @@ describe('ReactDOMServerHooks', () => {
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
       ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-        'Warning: Expected server HTML to contain a matching <div> in <div>.',
-      ]);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
+          'Warning: Expected server HTML to contain a matching <div> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
     });
 
     // @gate experimental
@@ -1740,9 +1744,13 @@ describe('ReactDOMServerHooks', () => {
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
       ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-        'Warning: Expected server HTML to contain a matching <div> in <div>.',
-      ]);
+      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
+        [
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
+          'Warning: Expected server HTML to contain a matching <div> in <div>.',
+        ],
+        {withoutStack: 1},
+      );
     });
 
     // @gate experimental
@@ -1764,7 +1772,7 @@ describe('ReactDOMServerHooks', () => {
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: Did not expect server HTML to contain a <span> in <div>.',
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
         ],
         {withoutStack: 1},
       );
@@ -1789,7 +1797,7 @@ describe('ReactDOMServerHooks', () => {
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: Did not expect server HTML to contain a <span> in <div>.',
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
         ],
         {withoutStack: 1},
       );
@@ -1813,7 +1821,7 @@ describe('ReactDOMServerHooks', () => {
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: Did not expect server HTML to contain a <div> in <div>.',
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
         ],
         {withoutStack: 1},
       );
@@ -1834,7 +1842,7 @@ describe('ReactDOMServerHooks', () => {
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: Did not expect server HTML to contain a <div> in <div>.',
+          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
         ],
         {withoutStack: 1},
       );

commit 6d3ecb70dceb225af0cd990b46d6c44b852c1d82
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 19 17:36:51 2021 -0500

    Remove unstable_changedBits (#20953)
    
    We added this unstable feature a few years ago, as a way to opt out of
    context updates, but it didn't prove useful in practice.
    
    We have other proposals for how to address the same problem, like
    context selectors.
    
    Since it was prefixed with `unstable_`, we should be able to remove it
    without consequence. The hook API already warned if you used it.
    
    Even if someone is using it somewhere, it's meant to be an optimization
    only, so if they are using the API properly, it should not have any
    semantic impact.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 3014ecd810..659a408e67 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -736,17 +736,6 @@ describe('ReactDOMServerHooks', () => {
     },
   );
 
-  itRenders('warns when bitmask is passed to useContext', async render => {
-    const Context = React.createContext('Hi');
-
-    function Foo() {
-      return <span>{useContext(Context, 1)}</span>;
-    }
-
-    const domNode = await render(<Foo />, 1);
-    expect(domNode.textContent).toBe('Hi');
-  });
-
   describe('useDebugValue', () => {
     itRenders('is a noop', async render => {
       function Counter(props) {
@@ -760,11 +749,11 @@ describe('ReactDOMServerHooks', () => {
   });
 
   describe('readContext', () => {
-    function readContext(Context, observedBits) {
+    function readContext(Context) {
       const dispatcher =
         React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
           .ReactCurrentDispatcher.current;
-      return dispatcher.readContext(Context, observedBits);
+      return dispatcher.readContext(Context);
     }
 
     itRenders(

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 659a408e67..7d6e894a9b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -895,7 +895,6 @@ describe('ReactDOMServerHooks', () => {
   });
 
   describe('useOpaqueIdentifier', () => {
-    // @gate experimental
     it('generates unique ids for server string render', async () => {
       function App(props) {
         const idOne = useOpaqueIdentifier();
@@ -929,7 +928,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('generates unique ids for server stream render', async () => {
       function App(props) {
         const idOne = useOpaqueIdentifier();
@@ -963,7 +961,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('generates unique ids for client render', async () => {
       function App(props) {
         const idOne = useOpaqueIdentifier();
@@ -997,7 +994,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('generates unique ids for client render on good server markup', async () => {
       function App(props) {
         const idOne = useOpaqueIdentifier();
@@ -1031,7 +1027,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier does not change id even if the component updates during client render', async () => {
       let _setShowId;
       function App() {
@@ -1063,7 +1058,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier identifierPrefix works for server renderer and does not clash', async () => {
       function ChildTwo({id}) {
         return <div id={id}>Child Three</div>;
@@ -1149,7 +1143,6 @@ describe('ReactDOMServerHooks', () => {
       ).toBe(true);
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier identifierPrefix works for multiple reads on a streaming server renderer', async () => {
       function ChildTwo() {
         const id = useOpaqueIdentifier();
@@ -1241,7 +1234,6 @@ describe('ReactDOMServerHooks', () => {
       await Promise.all([streamOneIsDone, streamTwoIsDone]);
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
       let _setShowDiv;
       function App() {
@@ -1261,7 +1253,7 @@ describe('ReactDOMServerHooks', () => {
       document.body.append(container);
 
       container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       root.render(<App />);
       Scheduler.unstable_flushAll();
       jest.runAllTimers();
@@ -1285,7 +1277,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered for legacy', async () => {
       let _setShowDiv;
       function App() {
@@ -1326,7 +1317,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: ID is not used during hydration but is used in an update', async () => {
       let _setShow;
       function App({unused}) {
@@ -1344,7 +1334,7 @@ describe('ReactDOMServerHooks', () => {
       const container = document.createElement('div');
       document.body.append(container);
       container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       act(() => {
         root.render(<App />);
       });
@@ -1359,7 +1349,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: ID is not used during hydration but is used in an update in legacy', async () => {
       let _setShow;
       function App({unused}) {
@@ -1389,7 +1378,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: flushSync', async () => {
       let _setShow;
       function App() {
@@ -1406,7 +1394,7 @@ describe('ReactDOMServerHooks', () => {
       const container = document.createElement('div');
       document.body.append(container);
       container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       act(() => {
         root.render(<App />);
       });
@@ -1422,7 +1410,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: children with id hydrates before other children if ID updates', async () => {
       let _setShow;
 
@@ -1498,7 +1485,7 @@ describe('ReactDOMServerHooks', () => {
         .getAttribute('id');
       expect(serverId).not.toBeNull();
 
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       root.render(<App show={false} />);
       expect(Scheduler).toHaveYielded([]);
 
@@ -1546,7 +1533,6 @@ describe('ReactDOMServerHooks', () => {
       expect(Scheduler).toHaveYielded([]);
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
       let suspend = true;
       let resolve;
@@ -1591,7 +1577,7 @@ describe('ReactDOMServerHooks', () => {
       container.innerHTML = ReactDOMServer.renderToString(<App />);
 
       suspend = true;
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       await act(async () => {
         root.render(<App />);
       });
@@ -1627,7 +1613,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warn when there is a hydration error', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId} />;
@@ -1642,7 +1627,7 @@ describe('ReactDOMServerHooks', () => {
 
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
@@ -1652,7 +1637,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
       let suspend = true;
 
@@ -1695,7 +1679,7 @@ describe('ReactDOMServerHooks', () => {
       container.innerHTML = ReactDOMServer.renderToString(<App />);
 
       suspend = false;
-      const root = ReactDOM.unstable_createRoot(container, {hydrate: true});
+      const root = ReactDOM.createRoot(container, {hydrate: true});
       await act(async () => {
         root.render(<App />);
       });
@@ -1717,7 +1701,6 @@ describe('ReactDOMServerHooks', () => {
       ).not.toBeNull();
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warn when there is a hydration error', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId} />;
@@ -1732,7 +1715,7 @@ describe('ReactDOMServerHooks', () => {
 
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
@@ -1742,7 +1725,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId + ''} />;
@@ -1757,7 +1739,7 @@ describe('ReactDOMServerHooks', () => {
 
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
@@ -1767,7 +1749,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId + ''} />;
@@ -1782,7 +1763,7 @@ describe('ReactDOMServerHooks', () => {
 
       // This is the wrong HTML string
       container.innerHTML = '<span></span>';
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
@@ -1792,7 +1773,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId + ''} />;
@@ -1806,7 +1786,7 @@ describe('ReactDOMServerHooks', () => {
       document.body.appendChild(container);
 
       container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
@@ -1816,7 +1796,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
       function App() {
         const id = useOpaqueIdentifier();
@@ -1827,7 +1806,7 @@ describe('ReactDOMServerHooks', () => {
       document.body.appendChild(container);
 
       container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       expect(() => Scheduler.unstable_flushAll()).toErrorDev(
         [
           'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
@@ -1837,7 +1816,6 @@ describe('ReactDOMServerHooks', () => {
       );
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
       function Child({appId}) {
         return <div aria-labelledby={appId + ''} />;
@@ -1856,7 +1834,7 @@ describe('ReactDOMServerHooks', () => {
 
       container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
 
       if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
         expect(() => Scheduler.unstable_flushAll()).toErrorDev([
@@ -1878,7 +1856,6 @@ describe('ReactDOMServerHooks', () => {
       }
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier warns if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
       function Child({appId}) {
         return <div aria-labelledby={+appId} />;
@@ -1899,7 +1876,7 @@ describe('ReactDOMServerHooks', () => {
 
       container.innerHTML = ReactDOMServer.renderToString(<App />);
 
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
 
       if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
         expect(() => Scheduler.unstable_flushAll()).toErrorDev([
@@ -1921,7 +1898,6 @@ describe('ReactDOMServerHooks', () => {
       }
     });
 
-    // @gate experimental
     it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {
       let _setShow;
 
@@ -1960,7 +1936,7 @@ describe('ReactDOMServerHooks', () => {
           .getAttribute('aria-labelledby'),
       ).toEqual(serverID);
 
-      ReactDOM.unstable_createRoot(container, {hydrate: true}).render(<App />);
+      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
       jest.runAllTimers();
       expect(Scheduler).toHaveYielded([]);
       expect(Scheduler).toFlushAndYield([]);

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 7d6e894a9b..cfd23f843c 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -44,7 +44,7 @@ function initModules() {
   ReactDOMServer = require('react-dom/server');
   ReactTestUtils = require('react-dom/test-utils');
   Scheduler = require('scheduler');
-  act = ReactTestUtils.unstable_concurrentAct;
+  act = require('jest-react').act;
   useState = React.useState;
   useReducer = React.useReducer;
   useEffect = React.useEffect;

commit 263cfa6ecb9879ecb629d4e04a8c26422b4c4ff9
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Sep 14 10:27:09 2021 -0400

    [Experimental] Add useInsertionEffect (#21913)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index cfd23f843c..53a34b25ff 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -27,6 +27,7 @@ let useCallback;
 let useMemo;
 let useRef;
 let useImperativeHandle;
+let useInsertionEffect;
 let useLayoutEffect;
 let useDebugValue;
 let useOpaqueIdentifier;
@@ -54,6 +55,7 @@ function initModules() {
   useRef = React.useRef;
   useDebugValue = React.useDebugValue;
   useImperativeHandle = React.useImperativeHandle;
+  useInsertionEffect = React.unstable_useInsertionEffect;
   useLayoutEffect = React.useLayoutEffect;
   useOpaqueIdentifier = React.unstable_useOpaqueIdentifier;
   forwardRef = React.forwardRef;
@@ -638,6 +640,22 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.textContent).toEqual('Count: 0');
     });
   });
+  describe('useInsertionEffect', () => {
+    // @gate experimental || www
+    it('should warn when invoked during render', async () => {
+      function Counter() {
+        useInsertionEffect(() => {
+          throw new Error('should not be invoked');
+        });
+
+        return <Text text="Count: 0" />;
+      }
+      const domNode = await serverRender(<Counter />, 1);
+      expect(clearYields()).toEqual(['Count: 0']);
+      expect(domNode.tagName).toEqual('SPAN');
+      expect(domNode.textContent).toEqual('Count: 0');
+    });
+  });
 
   describe('useLayoutEffect', () => {
     it('should warn when invoked during render', async () => {

commit c88fb49d37fd01024e0a254a37b7810d107bdd1d
Author: Justin Grant <justingrant@users.noreply.github.com>
Date:   Mon Sep 27 10:05:07 2021 -0700

    Improve DEV errors if string coercion throws (Temporal.*, Symbol, etc.) (#22064)
    
    * Revise ESLint rules for string coercion
    
    Currently, react uses `'' + value` to coerce mixed values to strings.
    This code will throw for Temporal objects or symbols.
    
    To make string-coercion safer and to improve user-facing error messages,
    This commit adds a new ESLint rule called `safe-string-coercion`.
    
    This rule has two modes: a production mode and a non-production mode.
    * If the `isProductionUserAppCode` option is true, then `'' + value`
      coercions are allowed (because they're faster, although they may
      throw) and `String(value)` coercions are disallowed. Exception:
      when building error messages or running DEV-only code in prod
      files, `String()` should be used because it won't throw.
    * If the `isProductionUserAppCode` option is false, then `'' + value`
      coercions are disallowed (because they may throw, and in non-prod
      code it's not worth the risk) and `String(value)` are allowed.
    
    Production mode is used for all files which will be bundled with
    developers' userland apps. Non-prod mode is used for all other React
    code: tests, DEV blocks, devtools extension, etc.
    
    In production mode, in addiiton to flagging `String(value)` calls,
    the rule will also flag `'' + value` or `value + ''` coercions that may
    throw. The rule is smart enough to silence itself in the following
    "will never throw" cases:
    * When the coercion is wrapped in a `typeof` test that restricts to safe
      (non-symbol, non-object) types. Example:
        if (typeof value === 'string' || typeof value === 'number') {
          thisWontReport('' + value);
        }
    * When what's being coerced is a unary function result, because unary
       functions never return an object or a symbol.
    * When the coerced value is a commonly-used numeric identifier:
      `i`, `idx`, or `lineNumber`.
    * When the statement immeidately before the coercion is a DEV-only
      call to a function from shared/CheckStringCoercion.js. This call is a
      no-op in production, but in DEV it will show a console error
      explaining the problem, then will throw right after a long explanatory
      code comment so that debugger users will have an idea what's going on.
      The check function call must be in the following format:
        if (__DEV__) {
          checkXxxxxStringCoercion(value);
        };
    
    Manually disabling the rule is usually not necessary because almost all
    prod use of the `'' + value` pattern falls into one of the categories
    above. But in the rare cases where the rule isn't smart enough to detect
    safe usage (e.g. when a coercion is inside a nested ternary operator),
    manually disabling the rule will be needed.
    
    The rule should also be manually disabled in prod error handling code
    where `String(value)` should be used for coercions, because it'd be
    bad to throw while building an error message or stack trace!
    
    The prod and non-prod modes have differentiated error messages to
    explain how to do a proper coercion in that mode.
    
    If a production check call is needed but is missing or incorrect
    (e.g. not in a DEV block or not immediately before the coercion), then
    a context-sensitive error message will be reported so that developers
    can figure out what's wrong and how to fix the problem.
    
    Because string coercions are now handled by the `safe-string-coercion`
    rule, the `no-primitive-constructor` rule no longer flags `String()`
    usage. It still flags `new String(value)` because that usage is almost
    always a bug.
    
    * Add DEV-only string coercion check functions
    
    This commit adds DEV-only functions to check whether coercing
    values to strings using the `'' + value` pattern will throw. If it will
    throw, these functions will:
    1. Display a console error with a friendly error message describing
       the problem and the developer can fix it.
    2. Perform the coercion, which will throw. Right before the line where
       the throwing happens, there's a long code comment that will help
       debugger users (or others looking at the exception call stack) figure
       out what happened and how to fix the problem.
    
    One of these check functions should be called before all string coercion
    of user-provided values, except when the the coercion is guaranteed not
    to throw, e.g.
    * if inside a typeof check like `if (typeof value === 'string')`
    * if coercing the result of a unary function like `+value` or `value++`
    * if coercing a variable named in a whitelist of numeric identifiers:
      `i`, `idx`, or `lineNumber`.
    
    The new `safe-string-coercion` internal ESLint rule enforces that
    these check functions are called when they are required.
    
    Only use these check functions in production code that will be bundled
    with user apps.  For non-prod code (and for production error-handling
    code), use `String(value)` instead which may be a little slower but will
    never throw.
    
    * Add failing tests for string coercion
    
    Added failing tests to verify:
    * That input, select, and textarea elements with value and defaultValue
      set to Temporal-like objects which will throw when coerced to string
      using the `'' + value` pattern.
    * That text elements will throw for Temporal-like objects
    * That dangerouslySetInnerHTML will *not* throw for Temporal-like
      objects because this value is not cast to a string before passing to
      the DOM.
    * That keys that are Temporal-like objects will throw
    
    All tests above validate the friendly error messages thrown.
    
    * Use `String(value)` for coercion in non-prod files
    
    This commit switches non-production code from `'' + value` (which
    throws for Temporal objects and symbols) to instead use `String(value)`
    which won't throw for these or other future plus-phobic types.
    
    "Non-produciton code" includes anything not bundled into user apps:
    * Tests and test utilities. Note that I didn't change legacy React
      test fixtures because I assumed it was good for those files to
      act just like old React, including coercion behavior.
    * Build scripts
    * Dev tools package - In addition to switching to `String`, I also
      removed special-case code for coercing symbols which is now
      unnecessary.
    
    * Add DEV-only string coercion checks to prod files
    
    This commit adds DEV-only function calls to to check if string coercion
    using `'' + value` will throw, which it will if the value is a Temporal
    object or a symbol because those types can't be added with `+`.
    
    If it will throw, then in DEV these checks will show a console error
    to help the user undertsand what went wrong and how to fix the
    problem. After emitting the console error, the check functions will
    retry the coercion which will throw with a call stack that's easy (or
    at least easier!) to troubleshoot because the exception happens right
    after a long comment explaining the issue. So whether the user is in
    a debugger, looking at the browser console, or viewing the in-browser
    DEV call stack, it should be easy to understand and fix the problem.
    
    In most cases, the safe-string-coercion ESLint rule is smart enough to
    detect when a coercion is safe. But in rare cases (e.g. when a coercion
    is inside a ternary) this rule will have to be manually disabled.
    
    This commit also switches error-handling code to use `String(value)`
    for coercion, because it's bad to crash when you're trying to build
    an error message or a call stack!  Because `String()` is usually
    disallowed by the `safe-string-coercion` ESLint rule in production
    code, the rule must be disabled when `String()` is used.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 53a34b25ff..a27954785f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1745,7 +1745,7 @@ describe('ReactDOMServerHooks', () => {
 
     it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
       function Child({appId}) {
-        return <div aria-labelledby={appId + ''} />;
+        return <div aria-labelledby={String(appId)} />;
       }
       function App() {
         const id = useOpaqueIdentifier();
@@ -1769,7 +1769,7 @@ describe('ReactDOMServerHooks', () => {
 
     it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
       function Child({appId}) {
-        return <div aria-labelledby={appId + ''} />;
+        return <div aria-labelledby={String(appId)} />;
       }
       function App() {
         const id = useOpaqueIdentifier();
@@ -1793,7 +1793,7 @@ describe('ReactDOMServerHooks', () => {
 
     it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
       function Child({appId}) {
-        return <div aria-labelledby={appId + ''} />;
+        return <div aria-labelledby={String(appId)} />;
       }
       function App() {
         const id = useOpaqueIdentifier();
@@ -1817,7 +1817,7 @@ describe('ReactDOMServerHooks', () => {
     it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
       function App() {
         const id = useOpaqueIdentifier();
-        return <div aria-labelledby={id + ''} />;
+        return <div aria-labelledby={String(id)} />;
       }
 
       const container = document.createElement('div');
@@ -1836,7 +1836,7 @@ describe('ReactDOMServerHooks', () => {
 
     it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
       function Child({appId}) {
-        return <div aria-labelledby={appId + ''} />;
+        return <div aria-labelledby={String(appId)} />;
       }
       function App() {
         const id = useOpaqueIdentifier();

commit 7142d110b00ecb5bb7566128c431fee02963e543
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Oct 13 18:44:36 2021 -0400

    Bugfix: Nested useOpaqueIdentifier references (#22553)
    
    * Handle render phase updates explicitly
    
    We fire a warning in development if a component is updated during
    the render phase (with the exception of local hook updates, which have
    their own defined behavior).
    
    Because it's not a supported React pattern, we don't have that many
    tests that trigger this path. But it is meant to have reasonable
    semantics when it does happen, so that if it accidentally ships to
    production, the app doesn't crash unnecessarily. The behavior is not
    super well-defined, though.
    
    There are also some _internal_ React implementation details that
    intentionally to rely on this behavior. Most prominently, selective
    hydration and useOpaqueIdentifier.
    
    I need to tweak the behavior of render phase updates slightly as part
    of a fix for useOpaqueIdentifier. This shouldn't cause a user-facing
    change in behavior outside of useOpaqueIdentifier, but it does require
    that we explicitly model render phase updates.
    
    * Bugfix: Nested useOpaqueIdentifier calls
    
    Fixes an issue where multiple useOpaqueIdentifier hooks are upgraded
    to client ids within the same render.
    
    The way the upgrade works is that useOpaqueIdentifier schedules a
    render phase update then throws an error to trigger React's error
    recovery mechanism.
    
    The normal error recovery mechanism is designed for errors that occur
    as a result of interleaved mutations, so we usually only retry a single
    time, synchronously, before giving up.
    
    useOpaqueIdentifier is different because the error its throws when
    upgrading is not caused by an interleaved mutation. Rather, it happens
    when an ID is referenced for the first time inside a client-rendered
    tree (i.e. sommething that wasn't part of the initial server render).
    The fact that it relies on the error recovery mechanism is an
    implementation detail. And a single recovery attempt may be
    insufficient. For example, if a parent and a child component may
    reference different ids, and both are mounted as a result of the same
    client update, that will trigger two separate error recovery attempts.
    
    Because render phase updates are not allowed when triggered from
    userspace — we log a warning in developement to prevent them —
    we can assume that if something does update during the render phase, it
    is one of our "legit" implementation details like useOpaqueIdentifier.
    So we can keep retrying until we succeed — up to a limit, to protect
    against inifite loops. I chose 50 since that's the limit we use for
    commit phase updates.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index a27954785f..daf3453314 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1975,5 +1975,40 @@ describe('ReactDOMServerHooks', () => {
         container.getElementsByTagName('span')[0].getAttribute('id'),
       ).not.toBeNull();
     });
+
+    it('useOpaqueIdentifier with multiple ids in nested components', async () => {
+      function DivWithId({id, children}) {
+        return <div id={id}>{children}</div>;
+      }
+
+      let setShowMore;
+      function App() {
+        const outerId = useOpaqueIdentifier();
+        const innerId = useOpaqueIdentifier();
+        const [showMore, _setShowMore] = useState(false);
+        setShowMore = _setShowMore;
+        return showMore ? (
+          <DivWithId id={outerId}>
+            <DivWithId id={innerId} />
+          </DivWithId>
+        ) : null;
+      }
+
+      const container = document.createElement('div');
+      container.innerHTML = ReactDOMServer.renderToString(<App />);
+
+      await act(async () => {
+        ReactDOM.hydrateRoot(container, <App />);
+      });
+
+      // Show additional content that wasn't part of the initial server-
+      // rendered repsonse.
+      await act(async () => {
+        setShowMore(true);
+      });
+      const [div1, div2] = container.getElementsByTagName('div');
+      expect(typeof div1.getAttribute('id')).toBe('string');
+      expect(typeof div2.getAttribute('id')).toBe('string');
+    });
   });
 });

commit 02f411578a8e58af8ec28e385f6b0dcb768cdc41
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 19 17:32:54 2021 -0400

    Upgrade useInsertionEffect to stable (#22589)
    
    @huozhi tried this out and says it's working as expected. I think we
    can go ahead and move this into the stable channel, so that it is
    available in the React 18 alpha releases.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index daf3453314..ba2b22437b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -55,7 +55,7 @@ function initModules() {
   useRef = React.useRef;
   useDebugValue = React.useDebugValue;
   useImperativeHandle = React.useImperativeHandle;
-  useInsertionEffect = React.unstable_useInsertionEffect;
+  useInsertionEffect = React.useInsertionEffect;
   useLayoutEffect = React.useLayoutEffect;
   useOpaqueIdentifier = React.unstable_useOpaqueIdentifier;
   forwardRef = React.forwardRef;
@@ -641,7 +641,6 @@ describe('ReactDOMServerHooks', () => {
     });
   });
   describe('useInsertionEffect', () => {
-    // @gate experimental || www
     it('should warn when invoked during render', async () => {
       function Counter() {
         useInsertionEffect(() => {

commit 75f3ddebfa0d9885ce8df42571cf0c09ad6c0a3b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 1 18:02:39 2021 -0400

    Remove experimental useOpaqueIdentifier API (#22672)
    
    useId is the updated version of this API.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index ba2b22437b..114c522313 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -17,8 +17,6 @@ let React;
 let ReactDOM;
 let ReactDOMServer;
 let ReactTestUtils;
-let act;
-let Scheduler;
 let useState;
 let useReducer;
 let useEffect;
@@ -30,7 +28,6 @@ let useImperativeHandle;
 let useInsertionEffect;
 let useLayoutEffect;
 let useDebugValue;
-let useOpaqueIdentifier;
 let forwardRef;
 let yieldedValues;
 let yieldValue;
@@ -44,8 +41,6 @@ function initModules() {
   ReactDOM = require('react-dom');
   ReactDOMServer = require('react-dom/server');
   ReactTestUtils = require('react-dom/test-utils');
-  Scheduler = require('scheduler');
-  act = require('jest-react').act;
   useState = React.useState;
   useReducer = React.useReducer;
   useEffect = React.useEffect;
@@ -57,7 +52,6 @@ function initModules() {
   useImperativeHandle = React.useImperativeHandle;
   useInsertionEffect = React.useInsertionEffect;
   useLayoutEffect = React.useLayoutEffect;
-  useOpaqueIdentifier = React.unstable_useOpaqueIdentifier;
   forwardRef = React.forwardRef;
 
   yieldedValues = [];
@@ -83,9 +77,6 @@ const {
   itRenders,
   itThrowsWhenRendering,
   serverRender,
-  streamRender,
-  clientCleanRender,
-  clientRenderOnServerString,
 } = ReactDOMServerIntegrationUtils(initModules);
 
 describe('ReactDOMServerHooks', () => {
@@ -910,1104 +901,4 @@ describe('ReactDOMServerHooks', () => {
     );
     expect(container.children[0].textContent).toEqual('0');
   });
-
-  describe('useOpaqueIdentifier', () => {
-    it('generates unique ids for server string render', async () => {
-      function App(props) {
-        const idOne = useOpaqueIdentifier();
-        const idTwo = useOpaqueIdentifier();
-        return (
-          <div>
-            <div aria-labelledby={idOne} />
-            <div id={idOne} />
-            <span aria-labelledby={idTwo} />
-            <span id={idTwo} />
-          </div>
-        );
-      }
-
-      const domNode = await serverRender(<App />);
-      expect(domNode.children.length).toEqual(4);
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[1].getAttribute('id'),
-      );
-      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[3].getAttribute('id'),
-      );
-      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      );
-      expect(
-        domNode.children[0].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-      expect(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-    });
-
-    it('generates unique ids for server stream render', async () => {
-      function App(props) {
-        const idOne = useOpaqueIdentifier();
-        const idTwo = useOpaqueIdentifier();
-        return (
-          <div>
-            <div aria-labelledby={idOne} />
-            <div id={idOne} />
-            <span aria-labelledby={idTwo} />
-            <span id={idTwo} />
-          </div>
-        );
-      }
-
-      const domNode = await streamRender(<App />);
-      expect(domNode.children.length).toEqual(4);
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[1].getAttribute('id'),
-      );
-      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[3].getAttribute('id'),
-      );
-      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      );
-      expect(
-        domNode.children[0].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-      expect(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-    });
-
-    it('generates unique ids for client render', async () => {
-      function App(props) {
-        const idOne = useOpaqueIdentifier();
-        const idTwo = useOpaqueIdentifier();
-        return (
-          <div>
-            <div aria-labelledby={idOne} />
-            <div id={idOne} />
-            <span aria-labelledby={idTwo} />
-            <span id={idTwo} />
-          </div>
-        );
-      }
-
-      const domNode = await clientCleanRender(<App />);
-      expect(domNode.children.length).toEqual(4);
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[1].getAttribute('id'),
-      );
-      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[3].getAttribute('id'),
-      );
-      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      );
-      expect(
-        domNode.children[0].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-      expect(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-    });
-
-    it('generates unique ids for client render on good server markup', async () => {
-      function App(props) {
-        const idOne = useOpaqueIdentifier();
-        const idTwo = useOpaqueIdentifier();
-        return (
-          <div>
-            <div aria-labelledby={idOne} />
-            <div id={idOne} />
-            <span aria-labelledby={idTwo} />
-            <span id={idTwo} />
-          </div>
-        );
-      }
-
-      const domNode = await clientRenderOnServerString(<App />);
-      expect(domNode.children.length).toEqual(4);
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[1].getAttribute('id'),
-      );
-      expect(domNode.children[2].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[3].getAttribute('id'),
-      );
-      expect(domNode.children[0].getAttribute('aria-labelledby')).not.toEqual(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      );
-      expect(
-        domNode.children[0].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-      expect(
-        domNode.children[2].getAttribute('aria-labelledby'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier does not change id even if the component updates during client render', async () => {
-      let _setShowId;
-      function App() {
-        const id = useOpaqueIdentifier();
-        const [showId, setShowId] = useState(false);
-        _setShowId = setShowId;
-        return (
-          <div>
-            <div aria-labelledby={id} />
-            {showId && <div id={id} />}
-          </div>
-        );
-      }
-
-      const domNode = await clientCleanRender(<App />);
-      const oldClientId = domNode.children[0].getAttribute('aria-labelledby');
-
-      expect(domNode.children.length).toEqual(1);
-      expect(oldClientId).not.toBeNull();
-
-      await act(async () => _setShowId(true));
-
-      expect(domNode.children.length).toEqual(2);
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        domNode.children[1].getAttribute('id'),
-      );
-      expect(domNode.children[0].getAttribute('aria-labelledby')).toEqual(
-        oldClientId,
-      );
-    });
-
-    it('useOpaqueIdentifier identifierPrefix works for server renderer and does not clash', async () => {
-      function ChildTwo({id}) {
-        return <div id={id}>Child Three</div>;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        const idTwo = useOpaqueIdentifier();
-
-        return (
-          <div>
-            <div aria-labelledby={id}>Child One</div>
-            <ChildTwo id={id} />
-            <div aria-labelledby={idTwo}>Child Three</div>
-            <div id={idTwo}>Child Four</div>
-          </div>
-        );
-      }
-
-      const containerOne = document.createElement('div');
-      document.body.append(containerOne);
-
-      containerOne.innerHTML = ReactDOMServer.renderToString(<App />, {
-        identifierPrefix: 'one',
-      });
-
-      const containerTwo = document.createElement('div');
-      document.body.append(containerTwo);
-
-      containerTwo.innerHTML = ReactDOMServer.renderToString(<App />, {
-        identifierPrefix: 'two',
-      });
-
-      expect(document.body.children.length).toEqual(2);
-      const childOne = document.body.children[0];
-      const childTwo = document.body.children[1];
-
-      expect(
-        childOne.children[0].children[0].getAttribute('aria-labelledby'),
-      ).toEqual(childOne.children[0].children[1].getAttribute('id'));
-      expect(
-        childOne.children[0].children[2].getAttribute('aria-labelledby'),
-      ).toEqual(childOne.children[0].children[3].getAttribute('id'));
-
-      expect(
-        childOne.children[0].children[0].getAttribute('aria-labelledby'),
-      ).not.toEqual(
-        childOne.children[0].children[2].getAttribute('aria-labelledby'),
-      );
-
-      expect(
-        childOne.children[0].children[0]
-          .getAttribute('aria-labelledby')
-          .startsWith('one'),
-      ).toBe(true);
-      expect(
-        childOne.children[0].children[2]
-          .getAttribute('aria-labelledby')
-          .includes('one'),
-      ).toBe(true);
-
-      expect(
-        childTwo.children[0].children[0].getAttribute('aria-labelledby'),
-      ).toEqual(childTwo.children[0].children[1].getAttribute('id'));
-      expect(
-        childTwo.children[0].children[2].getAttribute('aria-labelledby'),
-      ).toEqual(childTwo.children[0].children[3].getAttribute('id'));
-
-      expect(
-        childTwo.children[0].children[0].getAttribute('aria-labelledby'),
-      ).not.toEqual(
-        childTwo.children[0].children[2].getAttribute('aria-labelledby'),
-      );
-
-      expect(
-        childTwo.children[0].children[0]
-          .getAttribute('aria-labelledby')
-          .startsWith('two'),
-      ).toBe(true);
-      expect(
-        childTwo.children[0].children[2]
-          .getAttribute('aria-labelledby')
-          .startsWith('two'),
-      ).toBe(true);
-    });
-
-    it('useOpaqueIdentifier identifierPrefix works for multiple reads on a streaming server renderer', async () => {
-      function ChildTwo() {
-        const id = useOpaqueIdentifier();
-
-        return <div id={id}>Child Two</div>;
-      }
-
-      function App() {
-        const id = useOpaqueIdentifier();
-
-        return (
-          <>
-            <div id={id}>Child One</div>
-            <ChildTwo />
-            <div aria-labelledby={id}>Aria One</div>
-          </>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-
-      const streamOne = ReactDOMServer.renderToNodeStream(<App />, {
-        identifierPrefix: 'one',
-      }).setEncoding('utf8');
-      const streamTwo = ReactDOMServer.renderToNodeStream(<App />, {
-        identifierPrefix: 'two',
-      }).setEncoding('utf8');
-
-      const streamOneIsDone = new Promise((resolve, reject) => {
-        streamOne.on('end', () => resolve());
-        streamOne.on('error', e => reject(e));
-      });
-      const streamTwoIsDone = new Promise((resolve, reject) => {
-        streamTwo.on('end', () => resolve());
-        streamTwo.on('error', e => reject(e));
-      });
-
-      const containerOne = document.createElement('div');
-      const containerTwo = document.createElement('div');
-
-      streamOne._read(10);
-      streamTwo._read(10);
-
-      containerOne.innerHTML = streamOne.read();
-      containerTwo.innerHTML = streamTwo.read();
-
-      expect(containerOne.children[0].getAttribute('id')).not.toEqual(
-        containerOne.children[1].getAttribute('id'),
-      );
-      expect(containerTwo.children[0].getAttribute('id')).not.toEqual(
-        containerTwo.children[1].getAttribute('id'),
-      );
-      expect(containerOne.children[0].getAttribute('id')).not.toEqual(
-        containerTwo.children[0].getAttribute('id'),
-      );
-      expect(containerOne.children[0].getAttribute('id').includes('one')).toBe(
-        true,
-      );
-      expect(containerOne.children[1].getAttribute('id').includes('one')).toBe(
-        true,
-      );
-      expect(containerTwo.children[0].getAttribute('id').includes('two')).toBe(
-        true,
-      );
-      expect(containerTwo.children[1].getAttribute('id').includes('two')).toBe(
-        true,
-      );
-
-      expect(containerOne.children[1].getAttribute('id')).not.toEqual(
-        containerTwo.children[1].getAttribute('id'),
-      );
-      expect(containerOne.children[0].getAttribute('id')).toEqual(
-        containerOne.children[2].getAttribute('aria-labelledby'),
-      );
-      expect(containerTwo.children[0].getAttribute('id')).toEqual(
-        containerTwo.children[2].getAttribute('aria-labelledby'),
-      );
-
-      // Exhaust the rest of the stream
-      class Sink extends require('stream').Writable {
-        _write(chunk, encoding, done) {
-          done();
-        }
-      }
-      streamOne.pipe(new Sink());
-      streamTwo.pipe(new Sink());
-
-      await Promise.all([streamOneIsDone, streamTwoIsDone]);
-    });
-
-    it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered', async () => {
-      let _setShowDiv;
-      function App() {
-        const id = useOpaqueIdentifier();
-        const [showDiv, setShowDiv] = useState(false);
-        _setShowDiv = setShowDiv;
-
-        return (
-          <div>
-            <div id={id}>Child One</div>
-            {showDiv && <div id={id}>Child Two</div>}
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      root.render(<App />);
-      Scheduler.unstable_flushAll();
-      jest.runAllTimers();
-
-      expect(container.children[0].children.length).toEqual(1);
-      const oldServerId = container.children[0].children[0].getAttribute('id');
-      expect(oldServerId).not.toBeNull();
-
-      await act(async () => {
-        _setShowDiv(true);
-      });
-      expect(container.children[0].children.length).toEqual(2);
-      expect(container.children[0].children[0].getAttribute('id')).toEqual(
-        container.children[0].children[1].getAttribute('id'),
-      );
-      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
-        oldServerId,
-      );
-      expect(
-        container.children[0].children[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier: IDs match when, after hydration, a new component that uses the ID is rendered for legacy', async () => {
-      let _setShowDiv;
-      function App() {
-        const id = useOpaqueIdentifier();
-        const [showDiv, setShowDiv] = useState(false);
-        _setShowDiv = setShowDiv;
-
-        return (
-          <div>
-            <div id={id}>Child One</div>
-            {showDiv && <div id={id}>Child Two</div>}
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.hydrate(<App />, container);
-
-      expect(container.children[0].children.length).toEqual(1);
-      const oldServerId = container.children[0].children[0].getAttribute('id');
-      expect(oldServerId).not.toBeNull();
-
-      await act(async () => {
-        _setShowDiv(true);
-      });
-      expect(container.children[0].children.length).toEqual(2);
-      expect(container.children[0].children[0].getAttribute('id')).toEqual(
-        container.children[0].children[1].getAttribute('id'),
-      );
-      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
-        oldServerId,
-      );
-      expect(
-        container.children[0].children[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier: ID is not used during hydration but is used in an update', async () => {
-      let _setShow;
-      function App({unused}) {
-        Scheduler.unstable_yieldValue('App');
-        const id = useOpaqueIdentifier();
-        const [show, setShow] = useState(false);
-        _setShow = setShow;
-        return (
-          <div>
-            <span id={show ? id : null}>{'Child One'}</span>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      act(() => {
-        root.render(<App />);
-      });
-      expect(Scheduler).toHaveYielded(['App', 'App']);
-      // The ID goes from not being used to being added to the page
-      act(() => {
-        _setShow(true);
-      });
-      expect(Scheduler).toHaveYielded(['App', 'App']);
-      expect(
-        container.getElementsByTagName('span')[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier: ID is not used during hydration but is used in an update in legacy', async () => {
-      let _setShow;
-      function App({unused}) {
-        Scheduler.unstable_yieldValue('App');
-        const id = useOpaqueIdentifier();
-        const [show, setShow] = useState(false);
-        _setShow = setShow;
-        return (
-          <div>
-            <span id={show ? id : null}>{'Child One'}</span>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.hydrate(<App />, container);
-      expect(Scheduler).toHaveYielded(['App', 'App']);
-      // The ID goes from not being used to being added to the page
-      act(() => {
-        _setShow(true);
-      });
-      expect(Scheduler).toHaveYielded(['App']);
-      expect(
-        container.getElementsByTagName('span')[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier: flushSync', async () => {
-      let _setShow;
-      function App() {
-        const id = useOpaqueIdentifier();
-        const [show, setShow] = useState(false);
-        _setShow = setShow;
-        return (
-          <div>
-            <span id={show ? id : null}>{'Child One'}</span>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.append(container);
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      act(() => {
-        root.render(<App />);
-      });
-
-      // The ID goes from not being used to being added to the page
-      act(() => {
-        ReactDOM.flushSync(() => {
-          _setShow(true);
-        });
-      });
-      expect(
-        container.getElementsByTagName('span')[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier: children with id hydrates before other children if ID updates', async () => {
-      let _setShow;
-
-      const child1Ref = React.createRef();
-      const childWithIDRef = React.createRef();
-      const setShowRef = React.createRef();
-
-      // RENAME THESE
-      function Child1() {
-        Scheduler.unstable_yieldValue('Child One');
-        return <span ref={child1Ref}>{'Child One'}</span>;
-      }
-
-      function Child2() {
-        Scheduler.unstable_yieldValue('Child Two');
-        return <span>{'Child Two'}</span>;
-      }
-
-      const Children = React.memo(function Children() {
-        return (
-          <React.Suspense fallback="Loading 1...">
-            <Child1 />
-            <Child2 />
-          </React.Suspense>
-        );
-      });
-
-      function ChildWithID({parentID}) {
-        Scheduler.unstable_yieldValue('Child with ID');
-        return (
-          <span id={parentID} ref={childWithIDRef}>
-            {'Child with ID'}
-          </span>
-        );
-      }
-
-      const ChildrenWithID = React.memo(function ChildrenWithID({parentID}) {
-        return (
-          <React.Suspense fallback="Loading 2...">
-            <ChildWithID parentID={parentID} />
-          </React.Suspense>
-        );
-      });
-
-      function App() {
-        const id = useOpaqueIdentifier();
-        const [show, setShow] = useState(false);
-        _setShow = setShow;
-        return (
-          <div>
-            <Children />
-            <ChildrenWithID parentID={id} />
-            {show && (
-              <span aria-labelledby={id} ref={setShowRef}>
-                {'Child Three'}
-              </span>
-            )}
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      expect(Scheduler).toHaveYielded([
-        'Child One',
-        'Child Two',
-        'Child with ID',
-      ]);
-      expect(container.textContent).toEqual('Child OneChild TwoChild with ID');
-
-      const serverId = container
-        .getElementsByTagName('span')[2]
-        .getAttribute('id');
-      expect(serverId).not.toBeNull();
-
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      root.render(<App show={false} />);
-      expect(Scheduler).toHaveYielded([]);
-
-      //Hydrate just child one before updating state
-      expect(Scheduler).toFlushAndYieldThrough(['Child One']);
-      expect(child1Ref.current).toBe(null);
-      expect(Scheduler).toHaveYielded([]);
-
-      act(() => {
-        _setShow(true);
-
-        // State update should trigger the ID to update, which changes the props
-        // of ChildWithID. This should cause ChildWithID to hydrate before Children
-
-        expect(Scheduler).toFlushAndYieldThrough([
-          'Child with ID',
-          // Fallbacks are immediately committed in TestUtils version
-          // of act
-          // 'Child with ID',
-          // 'Child with ID',
-          'Child One',
-          'Child Two',
-        ]);
-
-        expect(child1Ref.current).toBe(null);
-        expect(childWithIDRef.current).toEqual(
-          container.getElementsByTagName('span')[2],
-        );
-
-        expect(setShowRef.current).toEqual(
-          container.getElementsByTagName('span')[3],
-        );
-
-        expect(childWithIDRef.current.getAttribute('id')).toEqual(
-          setShowRef.current.getAttribute('aria-labelledby'),
-        );
-        expect(childWithIDRef.current.getAttribute('id')).not.toEqual(serverId);
-      });
-
-      // Children hydrates after ChildWithID
-      expect(child1Ref.current).toBe(container.getElementsByTagName('span')[0]);
-
-      Scheduler.unstable_flushAll();
-
-      expect(Scheduler).toHaveYielded([]);
-    });
-
-    it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
-      let suspend = true;
-      let resolve;
-      const promise = new Promise(resolvePromise => (resolve = resolvePromise));
-
-      function Child({text}) {
-        if (suspend) {
-          throw promise;
-        } else {
-          return text;
-        }
-      }
-
-      function RenderedChild() {
-        useEffect(() => {
-          Scheduler.unstable_yieldValue('Child did commit');
-        });
-        return null;
-      }
-
-      function App() {
-        const id = useOpaqueIdentifier();
-        useEffect(() => {
-          Scheduler.unstable_yieldValue('Did commit');
-        });
-        return (
-          <div>
-            <div id={id}>Child One</div>
-            <RenderedChild />
-            <React.Suspense fallback={'Fallback'}>
-              <div id={id}>
-                <Child text="Child Two" />
-              </div>
-            </React.Suspense>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      suspend = true;
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      await act(async () => {
-        root.render(<App />);
-      });
-      jest.runAllTimers();
-      expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
-      expect(Scheduler).toFlushAndYield([]);
-
-      const serverId = container.children[0].children[0].getAttribute('id');
-      expect(container.children[0].children.length).toEqual(1);
-      expect(
-        container.children[0].children[0].getAttribute('id'),
-      ).not.toBeNull();
-
-      await act(async () => {
-        suspend = false;
-        resolve();
-        await promise;
-      });
-
-      expect(Scheduler).toHaveYielded(['Child did commit', 'Did commit']);
-      expect(Scheduler).toFlushAndYield([]);
-      jest.runAllTimers();
-
-      expect(container.children[0].children.length).toEqual(2);
-      expect(container.children[0].children[0].getAttribute('id')).toEqual(
-        container.children[0].children[1].getAttribute('id'),
-      );
-      expect(container.children[0].children[0].getAttribute('id')).not.toEqual(
-        serverId,
-      );
-      expect(
-        container.children[0].children[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier warn when there is a hydration error', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={appId} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <Child appId={id} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      // This is the wrong HTML string
-      container.innerHTML = '<span></span>';
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-          'Warning: Expected server HTML to contain a matching <div> in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier: IDs match when part of the DOM tree is server rendered and part is client rendered', async () => {
-      let suspend = true;
-
-      function Child({text}) {
-        if (suspend) {
-          throw new Promise(() => {});
-        } else {
-          return text;
-        }
-      }
-
-      function RenderedChild() {
-        useEffect(() => {
-          Scheduler.unstable_yieldValue('Child did commit');
-        });
-        return null;
-      }
-
-      function App() {
-        const id = useOpaqueIdentifier();
-        useEffect(() => {
-          Scheduler.unstable_yieldValue('Did commit');
-        });
-        return (
-          <div>
-            <div id={id}>Child One</div>
-            <RenderedChild />
-            <React.Suspense fallback={'Fallback'}>
-              <div id={id}>
-                <Child text="Child Two" />
-              </div>
-            </React.Suspense>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      suspend = false;
-      const root = ReactDOM.createRoot(container, {hydrate: true});
-      await act(async () => {
-        root.render(<App />);
-      });
-      jest.runAllTimers();
-      expect(Scheduler).toHaveYielded([
-        'Child did commit',
-        'Did commit',
-        'Child did commit',
-        'Did commit',
-      ]);
-      expect(Scheduler).toFlushAndYield([]);
-
-      expect(container.children[0].children.length).toEqual(2);
-      expect(container.children[0].children[0].getAttribute('id')).toEqual(
-        container.children[0].children[1].getAttribute('id'),
-      );
-      expect(
-        container.children[0].children[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier warn when there is a hydration error', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={appId} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <Child appId={id} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      // This is the wrong HTML string
-      container.innerHTML = '<span></span>';
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-          'Warning: Expected server HTML to contain a matching <div> in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={String(appId)} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <Child appId={id} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      // This is the wrong HTML string
-      container.innerHTML = '<span></span>';
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier warns when there is a hydration error and we are using ID as a string', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={String(appId)} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <Child appId={id} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      // This is the wrong HTML string
-      container.innerHTML = '<span></span>';
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier warns if you try to use the result as a string in a child component', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={String(appId)} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <Child appId={id} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier warns if you try to use the result as a string', async () => {
-      function App() {
-        const id = useOpaqueIdentifier();
-        return <div aria-labelledby={String(id)} />;
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      expect(() => Scheduler.unstable_flushAll()).toErrorDev(
-        [
-          'Warning: The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.',
-          'Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.',
-        ],
-        {withoutStack: 1},
-      );
-    });
-
-    it('useOpaqueIdentifier warns if you try to use the result as a string in a child component wrapped in a Suspense', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={String(appId)} />;
-      }
-      function App() {
-        const id = useOpaqueIdentifier();
-        return (
-          <React.Suspense fallback={null}>
-            <Child appId={id} />
-          </React.Suspense>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-
-      if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
-      } else {
-        // This error isn't surfaced to the user; only the warning is.
-        // The error is just the mechanism that restarts the render.
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
-      }
-    });
-
-    it('useOpaqueIdentifier warns if you try to add the result as a number in a child component wrapped in a Suspense', async () => {
-      function Child({appId}) {
-        return <div aria-labelledby={+appId} />;
-      }
-      function App() {
-        const [show] = useState(false);
-        const id = useOpaqueIdentifier();
-        return (
-          <React.Suspense fallback={null}>
-            {show && <div id={id} />}
-            <Child appId={id} />
-          </React.Suspense>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-
-      if (gate(flags => flags.deferRenderPhaseUpdateToNextBatch)) {
-        expect(() => Scheduler.unstable_flushAll()).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
-      } else {
-        // This error isn't surfaced to the user; only the warning is.
-        // The error is just the mechanism that restarts the render.
-        expect(() =>
-          expect(() => Scheduler.unstable_flushAll()).toThrow(
-            'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-              'Do not read the value directly.',
-          ),
-        ).toErrorDev([
-          'The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. ' +
-            'Do not read the value directly.',
-        ]);
-      }
-    });
-
-    it('useOpaqueIdentifier with two opaque identifiers on the same page', () => {
-      let _setShow;
-
-      function App() {
-        const id1 = useOpaqueIdentifier();
-        const id2 = useOpaqueIdentifier();
-        const [show, setShow] = useState(true);
-        _setShow = setShow;
-
-        return (
-          <div>
-            <React.Suspense fallback={null}>
-              {show ? (
-                <span id={id1}>{'Child'}</span>
-              ) : (
-                <span id={id2}>{'Child'}</span>
-              )}
-            </React.Suspense>
-            <span aria-labelledby={id1}>{'test'}</span>
-          </div>
-        );
-      }
-
-      const container = document.createElement('div');
-      document.body.appendChild(container);
-
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      const serverID = container
-        .getElementsByTagName('span')[0]
-        .getAttribute('id');
-      expect(serverID).not.toBeNull();
-      expect(
-        container
-          .getElementsByTagName('span')[1]
-          .getAttribute('aria-labelledby'),
-      ).toEqual(serverID);
-
-      ReactDOM.createRoot(container, {hydrate: true}).render(<App />);
-      jest.runAllTimers();
-      expect(Scheduler).toHaveYielded([]);
-      expect(Scheduler).toFlushAndYield([]);
-
-      act(() => {
-        _setShow(false);
-      });
-
-      expect(
-        container
-          .getElementsByTagName('span')[1]
-          .getAttribute('aria-labelledby'),
-      ).toEqual(serverID);
-      expect(
-        container.getElementsByTagName('span')[0].getAttribute('id'),
-      ).not.toEqual(serverID);
-      expect(
-        container.getElementsByTagName('span')[0].getAttribute('id'),
-      ).not.toBeNull();
-    });
-
-    it('useOpaqueIdentifier with multiple ids in nested components', async () => {
-      function DivWithId({id, children}) {
-        return <div id={id}>{children}</div>;
-      }
-
-      let setShowMore;
-      function App() {
-        const outerId = useOpaqueIdentifier();
-        const innerId = useOpaqueIdentifier();
-        const [showMore, _setShowMore] = useState(false);
-        setShowMore = _setShowMore;
-        return showMore ? (
-          <DivWithId id={outerId}>
-            <DivWithId id={innerId} />
-          </DivWithId>
-        ) : null;
-      }
-
-      const container = document.createElement('div');
-      container.innerHTML = ReactDOMServer.renderToString(<App />);
-
-      await act(async () => {
-        ReactDOM.hydrateRoot(container, <App />);
-      });
-
-      // Show additional content that wasn't part of the initial server-
-      // rendered repsonse.
-      await act(async () => {
-        setShowMore(true);
-      });
-      const [div1, div2] = container.getElementsByTagName('div');
-      expect(typeof div1.getAttribute('id')).toBe('string');
-      expect(typeof div2.getAttribute('id')).toBe('string');
-    });
-  });
 });

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 114c522313..9e59cee39a 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 4387d752dadada921938f9ea171d065b44a769c1
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Nov 2 22:50:45 2022 -0400

    Allow more hooks to be added when replaying mount
    
    Currently, if you call setState in render, you must render the exact
    same hooks as during the first render pass.
    
    I'm about to add a behavior where if something suspends, we can reuse
    the hooks from the previous attempt. That means during initial render,
    if something suspends, we should be able to reuse the hooks that were
    already created and continue adding more after that. This will error
    in the current implementation because of the expectation that every
    render produces the same list of hooks.
    
    In this commit, I've changed the logic to allow more hooks to be added
    when replaying. But only during a mount — if there's already a current
    fiber, then the logic is unchanged, because we shouldn't add any
    additional hooks that aren't in the current fiber's list. Mounts are
    special because there's no current fiber to compare to.
    
    I haven't change any other behavior yet. The reason I've put this into
    its own step is there are a couple tests that intentionally break the
    Hook rule, to assert that React errors in these cases, and those happen
    to be coupled to the behavior. This is undefined behavior that is always
    accompanied by a warning and/or error. So the change should be safe.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 9e59cee39a..48ab3565c6 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -430,26 +430,6 @@ describe('ReactDOMServerHooks', () => {
       expect(domNode.textContent).toEqual('hi');
     });
 
-    itThrowsWhenRendering(
-      'with a warning for useRef inside useReducer',
-      async render => {
-        function App() {
-          const [value, dispatch] = useReducer((state, action) => {
-            useRef(0);
-            return state + 1;
-          }, 0);
-          if (value === 0) {
-            dispatch();
-          }
-          return value;
-        }
-
-        const domNode = await render(<App />, 1);
-        expect(domNode.textContent).toEqual('1');
-      },
-      'Rendered more hooks than during the previous render',
-    );
-
     itRenders('with a warning for useRef inside useState', async render => {
       function App() {
         const [value] = useState(() => {
@@ -686,6 +666,32 @@ describe('ReactDOMServerHooks', () => {
     );
   });
 
+  describe('invalid hooks', () => {
+    it('warns when calling useRef inside useReducer', async () => {
+      function App() {
+        const [value, dispatch] = useReducer((state, action) => {
+          useRef(0);
+          return state + 1;
+        }, 0);
+        if (value === 0) {
+          dispatch();
+        }
+        return value;
+      }
+
+      let error;
+      try {
+        await serverRender(<App />);
+      } catch (x) {
+        error = x;
+      }
+      expect(error).not.toBe(undefined);
+      expect(error.message).toContain(
+        'Rendered more hooks than during the previous render',
+      );
+    });
+  });
+
   itRenders(
     'can use the same context multiple times in the same function',
     async render => {

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 48ab3565c6..b68fc5266b 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -72,12 +72,8 @@ function initModules() {
   };
 }
 
-const {
-  resetModules,
-  itRenders,
-  itThrowsWhenRendering,
-  serverRender,
-} = ReactDOMServerIntegrationUtils(initModules);
+const {resetModules, itRenders, itThrowsWhenRendering, serverRender} =
+  ReactDOMServerIntegrationUtils(initModules);
 
 describe('ReactDOMServerHooks', () => {
   beforeEach(() => {

commit 59409349671d7c096975025ff21996c525e4ae2b
Author: Ming Ye <ymqyit@gmail.com>
Date:   Fri Feb 10 00:07:49 2023 +0800

    Update to Jest 29 (#26088)
    
    ## Summary
    
    - yarn.lock diff +-6249, **small pr**
    - use jest-environment-jsdom by default
    - uncaught error from jsdom is an error object instead of strings
    - abortSignal.reason is read-only in jsdom and node,
    https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason
    
    ## How did you test this change?
    
    ci green
    
    ---------
    
    Co-authored-by: Sebastian Silbermann <silbermann.sebastian@gmail.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index b68fc5266b..96f64b70db 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -5,6 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @emails react-core
+ * @jest-environment ./scripts/jest/ReactDOMServerIntegrationEnvironment
  */
 
 /* eslint-disable no-func-assign */
@@ -35,7 +36,7 @@ let clearYields;
 
 function initModules() {
   // Reset warning cache.
-  jest.resetModuleRegistry();
+  jest.resetModules();
 
   React = require('react');
   ReactDOM = require('react-dom');

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 96f64b70db..08f0b1a8a7 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -32,7 +32,7 @@ let useDebugValue;
 let forwardRef;
 let yieldedValues;
 let yieldValue;
-let clearYields;
+let clearLog;
 
 function initModules() {
   // Reset warning cache.
@@ -59,7 +59,7 @@ function initModules() {
   yieldValue = value => {
     yieldedValues.push(value);
   };
-  clearYields = () => {
+  clearLog = () => {
     const ret = yieldedValues;
     yieldedValues = [];
     return ret;
@@ -207,7 +207,7 @@ describe('ReactDOMServerHooks', () => {
 
       const domNode = await render(<Counter />);
 
-      expect(clearYields()).toEqual(['Render: 0', 0]);
+      expect(clearLog()).toEqual(['Render: 0', 0]);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('0');
     });
@@ -224,7 +224,7 @@ describe('ReactDOMServerHooks', () => {
 
       const domNode = await render(<Counter />);
 
-      expect(clearYields()).toEqual(['Render: 1', 1]);
+      expect(clearLog()).toEqual(['Render: 1', 1]);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('1');
     });
@@ -246,7 +246,7 @@ describe('ReactDOMServerHooks', () => {
 
         const domNode = await render(<Counter />);
 
-        expect(clearYields()).toEqual([
+        expect(clearLog()).toEqual([
           'Render: 0',
           'Render: 1',
           'Render: 2',
@@ -299,7 +299,7 @@ describe('ReactDOMServerHooks', () => {
 
         const domNode = await render(<Counter />);
 
-        expect(clearYields()).toEqual([
+        expect(clearLog()).toEqual([
           // The count should increase by alternating amounts of 10 and 1
           // until we reach 21.
           'Render: 0',
@@ -326,7 +326,7 @@ describe('ReactDOMServerHooks', () => {
       }
 
       const domNode = await render(<CapitalizedText text="hello" />);
-      expect(clearYields()).toEqual(["Capitalize 'hello'", 'HELLO']);
+      expect(clearLog()).toEqual(["Capitalize 'hello'", 'HELLO']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('HELLO');
     });
@@ -343,7 +343,7 @@ describe('ReactDOMServerHooks', () => {
       }
 
       const domNode = await render(<LazyCompute compute={computeA} />);
-      expect(clearYields()).toEqual(['compute A', 'A']);
+      expect(clearLog()).toEqual(['compute A', 'A']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('A');
     });
@@ -365,7 +365,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<CapitalizedText text="hello" />);
-        expect(clearYields()).toEqual([
+        expect(clearLog()).toEqual([
           "Capitalize 'hello'",
           "Capitalize 'hello, world.'",
           'HELLO, WORLD.',
@@ -399,7 +399,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<CapitalizedText text="hello" />);
-        expect(clearYields()).toEqual([
+        expect(clearLog()).toEqual([
           "Capitalize 'hello'",
           0,
           1,
@@ -470,7 +470,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<Counter />);
-        expect(clearYields()).toEqual([0, 1, 2, 3]);
+        expect(clearLog()).toEqual([0, 1, 2, 3]);
         expect(domNode.textContent).toEqual('Count: 3');
       },
     );
@@ -500,7 +500,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<Counter />);
-        expect(clearYields()).toEqual([0, 1, 2, 3]);
+        expect(clearLog()).toEqual([0, 1, 2, 3]);
         expect(domNode.textContent).toEqual('Count: 3');
       },
     );
@@ -517,7 +517,7 @@ describe('ReactDOMServerHooks', () => {
       }
 
       const domNode = await render(<Counter count={0} />);
-      yields.push(clearYields());
+      yields.push(clearLog());
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 0');
     });
@@ -542,7 +542,7 @@ describe('ReactDOMServerHooks', () => {
         return <Text text={'Count: ' + props.count} />;
       }
       const domNode = await render(<Counter count={0} />);
-      expect(clearYields()).toEqual(['Count: 0']);
+      expect(clearLog()).toEqual(['Count: 0']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 0');
     });
@@ -555,7 +555,7 @@ describe('ReactDOMServerHooks', () => {
         return <Text text={renderCount(3)} />;
       }
       const domNode = await render(<Counter count={2} />);
-      expect(clearYields()).toEqual(['Count: 5']);
+      expect(clearLog()).toEqual(['Count: 5']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 5');
     });
@@ -578,7 +578,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<CapitalizedText text="hello" />);
-        const [first, second, third, fourth, result] = clearYields();
+        const [first, second, third, fourth, result] = clearLog();
         expect(first).toBe(second);
         expect(second).toBe(third);
         expect(third).not.toBe(fourth);
@@ -603,7 +603,7 @@ describe('ReactDOMServerHooks', () => {
       const domNode = await serverRender(
         <Counter label="Count" ref={counter} />,
       );
-      expect(clearYields()).toEqual(['Count: 0']);
+      expect(clearLog()).toEqual(['Count: 0']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 0');
     });
@@ -618,7 +618,7 @@ describe('ReactDOMServerHooks', () => {
         return <Text text="Count: 0" />;
       }
       const domNode = await serverRender(<Counter />, 1);
-      expect(clearYields()).toEqual(['Count: 0']);
+      expect(clearLog()).toEqual(['Count: 0']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 0');
     });
@@ -634,7 +634,7 @@ describe('ReactDOMServerHooks', () => {
         return <Text text="Count: 0" />;
       }
       const domNode = await serverRender(<Counter />, 1);
-      expect(clearYields()).toEqual(['Count: 0']);
+      expect(clearLog()).toEqual(['Count: 0']);
       expect(domNode.tagName).toEqual('SPAN');
       expect(domNode.textContent).toEqual('Count: 0');
     });
@@ -738,7 +738,7 @@ describe('ReactDOMServerHooks', () => {
       }
 
       const domNode = await render(<App foo={1} bar={3} baz={5} />);
-      expect(clearYields()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
+      expect(clearLog()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
       expect(domNode.childNodes.length).toBe(2);
       expect(domNode.firstChild.tagName).toEqual('SPAN');
       expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');
@@ -834,7 +834,7 @@ describe('ReactDOMServerHooks', () => {
         }
 
         const domNode = await render(<App foo={1} bar={3} baz={5} />);
-        expect(clearYields()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
+        expect(clearLog()).toEqual(['Foo: 1, Bar: 3', 'Baz: 5']);
         expect(domNode.childNodes.length).toBe(2);
         expect(domNode.firstChild.tagName).toEqual('SPAN');
         expect(domNode.firstChild.textContent).toEqual('Foo: 1, Bar: 3');

commit fa6674b5bcf52610e92d19a5105308e56091c386
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Feb 1 18:32:27 2024 -0500

    Add ReactDOMClient to ServerIntegration(Hooks|NewContext) (#28135)
    
    ## Overview
    
    Branched off https://github.com/facebook/react/pull/28130
    
    ### ~Failing~ Fixed by @eps1lon
    Most of the tests pass, but there are 3 tests that have additional
    warnings due to client render error retries.
    
    For example, before we would log:
    
    ```
    Warning: Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks.
    Warning: Expected server HTML to contain a matching text node for "0" in <div>.
    ```
    
    And now we log
    
    ```
    Warning: Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks.
    Warning: Expected server HTML to contain a matching text node for "0" in <div>.
    Warning: Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks.
    ```
    
    We can't just update the expected error count for these tests, because
    the additional error only happens on the client. So I need some guidance
    on how to fix these.
    
    ---------
    
    Co-authored-by: Sebastian Silbermann <sebastian.silbermann@klarna.com>

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 08f0b1a8a7..7e46bea5f9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -15,7 +15,7 @@
 const ReactDOMServerIntegrationUtils = require('./utils/ReactDOMServerIntegrationTestUtils');
 
 let React;
-let ReactDOM;
+let ReactDOMClient;
 let ReactDOMServer;
 let ReactTestUtils;
 let useState;
@@ -39,7 +39,7 @@ function initModules() {
   jest.resetModules();
 
   React = require('react');
-  ReactDOM = require('react-dom');
+  ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
   ReactTestUtils = require('react-dom/test-utils');
   useState = React.useState;
@@ -67,14 +67,19 @@ function initModules() {
 
   // Make them available to the helpers.
   return {
-    ReactDOM,
+    ReactDOMClient,
     ReactDOMServer,
     ReactTestUtils,
   };
 }
 
-const {resetModules, itRenders, itThrowsWhenRendering, serverRender} =
-  ReactDOMServerIntegrationUtils(initModules);
+const {
+  resetModules,
+  itRenders,
+  itThrowsWhenRendering,
+  clientRenderOnBadMarkup,
+  serverRender,
+} = ReactDOMServerIntegrationUtils(initModules);
 
 describe('ReactDOMServerHooks', () => {
   beforeEach(() => {
@@ -422,8 +427,13 @@ describe('ReactDOMServerHooks', () => {
         });
         return 'hi';
       }
-
-      const domNode = await render(<App />, 1);
+      const domNode = await render(
+        <App />,
+        render === clientRenderOnBadMarkup
+          ? // On hydration mismatch we retry and therefore log the warning again.
+            2
+          : 1,
+      );
       expect(domNode.textContent).toEqual('hi');
     });
 
@@ -436,7 +446,13 @@ describe('ReactDOMServerHooks', () => {
         return value;
       }
 
-      const domNode = await render(<App />, 1);
+      const domNode = await render(
+        <App />,
+        render === clientRenderOnBadMarkup
+          ? // On hydration mismatch we retry and therefore log the warning again.
+            2
+          : 1,
+      );
       expect(domNode.textContent).toEqual('0');
     });
   });
@@ -859,7 +875,13 @@ describe('ReactDOMServerHooks', () => {
         return <Text text={count} />;
       }
 
-      const domNode1 = await render(<ReadInMemo />, 1);
+      const domNode1 = await render(
+        <ReadInMemo />,
+        render === clientRenderOnBadMarkup
+          ? // On hydration mismatch we retry and therefore log the warning again.
+            2
+          : 1,
+      );
       expect(domNode1.textContent).toEqual('42');
 
       const domNode2 = await render(<ReadInReducer />, 1);

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 7e46bea5f9..6f42b23ca9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -35,9 +35,6 @@ let yieldValue;
 let clearLog;
 
 function initModules() {
-  // Reset warning cache.
-  jest.resetModules();
-
   React = require('react');
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 6f42b23ca9..7e46bea5f9 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -35,6 +35,9 @@ let yieldValue;
 let clearLog;
 
 function initModules() {
+  // Reset warning cache.
+  jest.resetModules();
+
   React = require('react');
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');

commit cefc1c66c179e5cca255f1ff53610a0ed9f8e710
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Tue Feb 20 22:49:34 2024 +0100

    Remove unused ReactTestUtils from ReactDOMServerIntegration tests (#28379)

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 7e46bea5f9..22bd1df999 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -17,7 +17,6 @@ const ReactDOMServerIntegrationUtils = require('./utils/ReactDOMServerIntegratio
 let React;
 let ReactDOMClient;
 let ReactDOMServer;
-let ReactTestUtils;
 let useState;
 let useReducer;
 let useEffect;
@@ -41,7 +40,6 @@ function initModules() {
   React = require('react');
   ReactDOMClient = require('react-dom/client');
   ReactDOMServer = require('react-dom/server');
-  ReactTestUtils = require('react-dom/test-utils');
   useState = React.useState;
   useReducer = React.useReducer;
   useEffect = React.useEffect;
@@ -69,7 +67,6 @@ function initModules() {
   return {
     ReactDOMClient,
     ReactDOMServer,
-    ReactTestUtils,
   };
 }
 

commit 1940cb27b260c2eab79c76763d1151ba18353ff8
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Mar 3 17:34:33 2024 -0500

    Update /link URLs to react.dev (#28477)
    
    Depends on https://github.com/reactjs/react.dev/pull/6670 [merged]

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 22bd1df999..9bd7d2ec3f 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -150,7 +150,7 @@ describe('ReactDOMServerHooks', () => {
         '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
         '2. You might be breaking the Rules of Hooks\n' +
         '3. You might have more than one copy of React in the same app\n' +
-        'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
+        'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',
     );
 
     itRenders('multiple times when an updater is called', async render => {
@@ -672,7 +672,7 @@ describe('ReactDOMServerHooks', () => {
         '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
         '2. You might be breaking the Rules of Hooks\n' +
         '3. You might have more than one copy of React in the same app\n' +
-        'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.',
+        'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.',
     );
   });
 

commit d50323eb845c5fde0d720cae888bf35dedd05506
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Apr 8 19:23:23 2024 -0400

    Flatten ReactSharedInternals (#28783)
    
    This is similar to #28771 but for isomorphic. We need a make over for
    these dispatchers anyway so this is the first step. Also helps flush out
    some internals usage that will break anyway.
    
    It flattens the inner mutable objects onto the ReactSharedInternals.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 9bd7d2ec3f..464e71ed43 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -775,8 +775,7 @@ describe('ReactDOMServerHooks', () => {
   describe('readContext', () => {
     function readContext(Context) {
       const dispatcher =
-        React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
-          .ReactCurrentDispatcher.current;
+        React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.H;
       return dispatcher.readContext(Context);
     }
 

commit f6131653570bbbf62d642ba9343b9cd0ab1ae97c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 9 12:20:22 2024 -0400

    Rename SECRET INTERNALS to `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE` (#28789)
    
    Follow up to #28783 and #28786.
    
    Since we've changed the implementations of these we can rename them to
    something a bit more descriptive while we're at it, since anyone
    depending on them will need to upgrade their code anyway.
    
    "react" with no condition:
    `__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react" with "react-server" condition:
    `__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`
    "react-dom":
    `__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 464e71ed43..e1aeea70fd 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -775,7 +775,7 @@ describe('ReactDOMServerHooks', () => {
   describe('readContext', () => {
     function readContext(Context) {
       const dispatcher =
-        React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.H;
+        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.H;
       return dispatcher.readContext(Context);
     }
 

commit 17ca4b157fcba6c734583513353ba72376a7ba2d
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Dec 13 11:26:44 2024 -0500

    Fix useResourceEffect in Fizz (#31758)
    
    We're seeing errors when testing useResourceEffect in SSR and it turns
    out we're missing the noop dispatcher function on Fizz.
    
    I tested a local build with this change and it resolved the late
    mutation errors in the e2e tests.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index e1aeea70fd..b79e59ad00 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -27,6 +27,7 @@ let useRef;
 let useImperativeHandle;
 let useInsertionEffect;
 let useLayoutEffect;
+let useResourceEffect;
 let useDebugValue;
 let forwardRef;
 let yieldedValues;
@@ -51,6 +52,7 @@ function initModules() {
   useImperativeHandle = React.useImperativeHandle;
   useInsertionEffect = React.useInsertionEffect;
   useLayoutEffect = React.useLayoutEffect;
+  useResourceEffect = React.experimental_useResourceEffect;
   forwardRef = React.forwardRef;
 
   yieldedValues = [];
@@ -653,6 +655,52 @@ describe('ReactDOMServerHooks', () => {
     });
   });
 
+  describe('useResourceEffect', () => {
+    gate(flags => {
+      if (flags.enableUseResourceEffectHook) {
+        const yields = [];
+        itRenders(
+          'should ignore resource effects on the server',
+          async render => {
+            function Counter(props) {
+              useResourceEffect(
+                () => {
+                  yieldValue('created on client');
+                  return {resource_counter: props.count};
+                },
+                [props.count],
+                resource => {
+                  resource.resource_counter = props.count;
+                  yieldValue('updated on client');
+                },
+                [props.count],
+                () => {
+                  yieldValue('cleanup on client');
+                },
+              );
+              return <Text text={'Count: ' + props.count} />;
+            }
+
+            const domNode = await render(<Counter count={0} />);
+            yields.push(clearLog());
+            expect(domNode.tagName).toEqual('SPAN');
+            expect(domNode.textContent).toEqual('Count: 0');
+          },
+        );
+
+        it('verifies yields in order', () => {
+          expect(yields).toEqual([
+            ['Count: 0'], // server render
+            ['Count: 0'], // server stream
+            ['Count: 0', 'created on client'], // clean render
+            ['Count: 0', 'created on client'], // hydrated render
+            // nothing yielded for bad markup
+          ]);
+        });
+      }
+    });
+  });
+
   describe('useContext', () => {
     itThrowsWhenRendering(
       'if used inside a class component',

commit 0461c0d8a49730d1c8ebca2071d9bb7adfc8ac92
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:05:50 2025 -0500

    [crud] Rename useResourceEffect flag (#32204)
    
    Rename the flag in preparation for the overload.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32204).
    * #32206
    * #32205
    * __->__ #32204

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index b79e59ad00..bce830ddf0 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -657,7 +657,7 @@ describe('ReactDOMServerHooks', () => {
 
   describe('useResourceEffect', () => {
     gate(flags => {
-      if (flags.enableUseResourceEffectHook) {
+      if (flags.enableUseEffectCRUDOverload) {
         const yields = [];
         itRenders(
           'should ignore resource effects on the server',

commit 2c5fd26c07c0fb94ff21a6c10c5a757ef3c5d6a4
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:18:50 2025 -0500

    [crud] Merge useResourceEffect into useEffect (#32205)
    
    Merges the useResourceEffect API into useEffect while keeping the
    underlying implementation the same. useResourceEffect will be removed in
    the next diff.
    
    To fork between behavior we rely on a `typeof` check for the updater or
    destroy function in addition to the CRUD feature flag. This does now
    have to be checked every time (instead of inlined statically like before
    due to them being different hooks) which will incur some non-zero amount
    (possibly negligble) of overhead for every effect.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32205).
    * #32206
    * __->__ #32205

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index bce830ddf0..840d6c5b15 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -27,7 +27,6 @@ let useRef;
 let useImperativeHandle;
 let useInsertionEffect;
 let useLayoutEffect;
-let useResourceEffect;
 let useDebugValue;
 let forwardRef;
 let yieldedValues;
@@ -52,7 +51,6 @@ function initModules() {
   useImperativeHandle = React.useImperativeHandle;
   useInsertionEffect = React.useInsertionEffect;
   useLayoutEffect = React.useLayoutEffect;
-  useResourceEffect = React.experimental_useResourceEffect;
   forwardRef = React.forwardRef;
 
   yieldedValues = [];
@@ -655,7 +653,7 @@ describe('ReactDOMServerHooks', () => {
     });
   });
 
-  describe('useResourceEffect', () => {
+  describe('useEffect with CRUD overload', () => {
     gate(flags => {
       if (flags.enableUseEffectCRUDOverload) {
         const yields = [];
@@ -663,7 +661,7 @@ describe('ReactDOMServerHooks', () => {
           'should ignore resource effects on the server',
           async render => {
             function Counter(props) {
-              useResourceEffect(
+              useEffect(
                 () => {
                   yieldValue('created on client');
                   return {resource_counter: props.count};

commit 313332d111a2fba2db94c584334d8895e8d73c61
Author: lauren <poteto@users.noreply.github.com>
Date:   Wed Mar 26 12:04:57 2025 -0400

    [crud] Revert CRUD overload (#32741)
    
    Cleans up this experiment. After some internal experimentation we are
    deprioritizing this project for now and may revisit it at a later point.

diff --git a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
index 840d6c5b15..e1aeea70fd 100644
--- a/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
+++ b/packages/react-dom/src/__tests__/ReactDOMServerIntegrationHooks-test.js
@@ -653,52 +653,6 @@ describe('ReactDOMServerHooks', () => {
     });
   });
 
-  describe('useEffect with CRUD overload', () => {
-    gate(flags => {
-      if (flags.enableUseEffectCRUDOverload) {
-        const yields = [];
-        itRenders(
-          'should ignore resource effects on the server',
-          async render => {
-            function Counter(props) {
-              useEffect(
-                () => {
-                  yieldValue('created on client');
-                  return {resource_counter: props.count};
-                },
-                [props.count],
-                resource => {
-                  resource.resource_counter = props.count;
-                  yieldValue('updated on client');
-                },
-                [props.count],
-                () => {
-                  yieldValue('cleanup on client');
-                },
-              );
-              return <Text text={'Count: ' + props.count} />;
-            }
-
-            const domNode = await render(<Counter count={0} />);
-            yields.push(clearLog());
-            expect(domNode.tagName).toEqual('SPAN');
-            expect(domNode.textContent).toEqual('Count: 0');
-          },
-        );
-
-        it('verifies yields in order', () => {
-          expect(yields).toEqual([
-            ['Count: 0'], // server render
-            ['Count: 0'], // server stream
-            ['Count: 0', 'created on client'], // clean render
-            ['Count: 0', 'created on client'], // hydrated render
-            // nothing yielded for bad markup
-          ]);
-        });
-      }
-    });
-  });
-
   describe('useContext', () => {
     itThrowsWhenRendering(
       'if used inside a class component',

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    