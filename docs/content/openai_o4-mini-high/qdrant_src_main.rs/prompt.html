<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/main.rs - o4-mini-high</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/main.rs</h1>
        <h2>Model: o4-mini-high</h2>
        <p><a href="../../../cases/openai_o4-mini-high/qdrant_src_main.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/main.rs

commit e4452500a0228cccbf8dd37e3c9e8f81e8faaf33
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sat May 30 23:35:38 2020 +0200

    init

diff --git a/src/main.rs b/src/main.rs
new file mode 100644
index 000000000..0ecd5869a
--- /dev/null
+++ b/src/main.rs
@@ -0,0 +1,15 @@
+mod test_wal;
+mod settings;
+
+mod common;
+mod operations;
+
+fn main() {
+    // let settings = settings::Settings::new().expect("Can't read config.");
+    // println!("{:?}", settings);
+    
+    test_wal::write_wal();
+    test_wal::read_wal();
+    test_wal::truncate_wal();
+    test_wal::read_wal();
+}

commit 9a1b60ff76c99386faf5bd3ed39fbecf6f0d7f34
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sun May 31 22:08:14 2020 +0200

    Test for json and bincode serialization.

diff --git a/src/main.rs b/src/main.rs
index 0ecd5869a..5916b1737 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -4,12 +4,38 @@ mod settings;
 mod common;
 mod operations;
 
+use operations::collection_ops::CreateCollection;
+use common::index_def::{IndexType, BaseIndexParams, Distance, PlainIndex};
+
+extern crate serde_json;
+extern crate bincode;
+
 fn main() {
     // let settings = settings::Settings::new().expect("Can't read config.");
     // println!("{:?}", settings);
+
+    let op1 = CreateCollection {
+        collection_name: String::from("my_collection"),
+        dim: 50,
+        index: Some(IndexType::Plain(PlainIndex{
+            params: BaseIndexParams {
+                distance: Distance::Cosine
+            }
+        }))
+    };
+
+    println!("{:?}", op1);
+
+    let ops_json = bincode::serialize(&op1);
+
+    match ops_json {
+        Ok(json) => println!("{:?}", json),
+        Err(x) => println!("Error {:?}", x),
+    }
     
-    test_wal::write_wal();
-    test_wal::read_wal();
-    test_wal::truncate_wal();
-    test_wal::read_wal();
+    // test_wal::write_wal();
+    // test_wal::read_wal();
+    // test_wal::truncate_wal();
+    // test_wal::read_wal();
 }
+

commit 5dc00efbc56a3944c3ce79a2f8028d81ad7323bf
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sun May 31 23:12:24 2020 +0200

    refactor structs

diff --git a/src/main.rs b/src/main.rs
index 5916b1737..68da620ea 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,41 +1,38 @@
-mod test_wal;
 mod settings;
+mod test_wal;
 
 mod common;
 mod operations;
 
-use operations::collection_ops::CreateCollection;
-use common::index_def::{IndexType, BaseIndexParams, Distance, PlainIndex};
+use common::index_def::{BaseIndexParams, Distance, Indexes};
+use operations::collection_ops::CollectionOps;
 
-extern crate serde_json;
 extern crate bincode;
+extern crate serde_json;
 
 fn main() {
     // let settings = settings::Settings::new().expect("Can't read config.");
     // println!("{:?}", settings);
 
-    let op1 = CreateCollection {
+    let op1 = CollectionOps::CreateCollection {
         collection_name: String::from("my_collection"),
         dim: 50,
-        index: Some(IndexType::Plain(PlainIndex{
+        index: Some(Indexes::PlainIndex {
             params: BaseIndexParams {
-                distance: Distance::Cosine
-            }
-        }))
+                distance: Distance::Cosine,
+            },
+        }),
     };
 
     println!("{:?}", op1);
 
-    let ops_json = bincode::serialize(&op1);
+    let ops_bin = bincode::serialize(&op1).unwrap();
+
+    let dec_ops: CollectionOps = bincode::deserialize(&ops_bin).expect("Can't deserialize");
 
-    match ops_json {
-        Ok(json) => println!("{:?}", json),
-        Err(x) => println!("Error {:?}", x),
-    }
-    
+    println!("{:?}", dec_ops);
     // test_wal::write_wal();
     // test_wal::read_wal();
     // test_wal::truncate_wal();
     // test_wal::read_wal();
 }
-

commit 3206ceb4f1887e7021fb29fe7d454edc89c1e0f8
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 9 15:19:39 2020 +0200

    add actix web server

diff --git a/src/main.rs b/src/main.rs
index 68da620ea..326184a6b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,38 +1,70 @@
 mod settings;
-mod test_wal;
 
 mod common;
 mod operations;
 
-use common::index_def::{BaseIndexParams, Distance, Indexes};
-use operations::collection_ops::CollectionOps;
+use actix_web::middleware::Logger;
+use actix_web::{web, App, HttpResponse, HttpServer, Responder};
 
-extern crate bincode;
-extern crate serde_json;
+use env_logger;
 
-fn main() {
-    // let settings = settings::Settings::new().expect("Can't read config.");
-    // println!("{:?}", settings);
 
-    let op1 = CollectionOps::CreateCollection {
-        collection_name: String::from("my_collection"),
-        dim: 50,
-        index: Some(Indexes::PlainIndex {
-            params: BaseIndexParams {
-                distance: Distance::Cosine,
-            },
-        }),
-    };
-
-    println!("{:?}", op1);
+async fn index() -> impl Responder {
+    HttpResponse::Ok().body("Hello world!")
+}
 
-    let ops_bin = bincode::serialize(&op1).unwrap();
+async fn index2() -> impl Responder {
+    HttpResponse::Ok().body("Hello world again!")
+}
 
-    let dec_ops: CollectionOps = bincode::deserialize(&ops_bin).expect("Can't deserialize");
 
-    println!("{:?}", dec_ops);
-    // test_wal::write_wal();
-    // test_wal::read_wal();
-    // test_wal::truncate_wal();
-    // test_wal::read_wal();
+#[actix_rt::main]
+async fn main() -> std::io::Result<()> {
+    let settings = settings::Settings::new().expect("Can't read config.");
+    std::env::set_var("RUST_LOG",  settings.log_level);
+    env_logger::init();
+    
+    HttpServer::new(|| {
+        App::new()
+            .wrap(Logger::default())
+            .route("/", web::get().to(index))
+            .route("/again", web::get().to(index2))
+    })
+    .workers(1)
+    .bind(format!("{}:{}", settings.service.host, settings.service.port))?
+    .run()
+    .await
 }
+
+
+// extern crate bincode;
+// extern crate serde_json;
+
+// use common::index_def::{BaseIndexParams, Distance, Indexes};
+// use operations::collection_ops::CollectionOps;
+// fn main() {
+//     // 
+//     // println!("{:?}", settings);
+
+//     let op1 = CollectionOps::CreateCollection {
+//         collection_name: String::from("my_collection"),
+//         dim: 50,
+//         index: Some(Indexes::PlainIndex {
+//             params: BaseIndexParams {
+//                 distance: Distance::Cosine,
+//             },
+//         }),
+//     };
+
+//     println!("{:?}", op1);
+
+//     let ops_bin = bincode::serialize(&op1).unwrap();
+
+//     let dec_ops: CollectionOps = bincode::deserialize(&ops_bin).expect("Can't deserialize");
+
+//     println!("{:?}", dec_ops);
+//     // test_wal::write_wal();
+//     // test_wal::read_wal();
+//     // test_wal::truncate_wal();
+//     // test_wal::read_wal();
+// }

commit f0368c5c622fc5275fe6acbdde70678fd2fd5008
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 15 10:39:53 2020 +0200

    Better WAL interface

diff --git a/src/main.rs b/src/main.rs
index 326184a6b..d65600b89 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,70 +1,5 @@
-mod settings;
+mod storage;
 
-mod common;
-mod operations;
-
-use actix_web::middleware::Logger;
-use actix_web::{web, App, HttpResponse, HttpServer, Responder};
-
-use env_logger;
-
-
-async fn index() -> impl Responder {
-    HttpResponse::Ok().body("Hello world!")
-}
-
-async fn index2() -> impl Responder {
-    HttpResponse::Ok().body("Hello world again!")
-}
-
-
-#[actix_rt::main]
-async fn main() -> std::io::Result<()> {
-    let settings = settings::Settings::new().expect("Can't read config.");
-    std::env::set_var("RUST_LOG",  settings.log_level);
-    env_logger::init();
-    
-    HttpServer::new(|| {
-        App::new()
-            .wrap(Logger::default())
-            .route("/", web::get().to(index))
-            .route("/again", web::get().to(index2))
-    })
-    .workers(1)
-    .bind(format!("{}:{}", settings.service.host, settings.service.port))?
-    .run()
-    .await
+fn main() {
+    println!("Hello word");
 }
-
-
-// extern crate bincode;
-// extern crate serde_json;
-
-// use common::index_def::{BaseIndexParams, Distance, Indexes};
-// use operations::collection_ops::CollectionOps;
-// fn main() {
-//     // 
-//     // println!("{:?}", settings);
-
-//     let op1 = CollectionOps::CreateCollection {
-//         collection_name: String::from("my_collection"),
-//         dim: 50,
-//         index: Some(Indexes::PlainIndex {
-//             params: BaseIndexParams {
-//                 distance: Distance::Cosine,
-//             },
-//         }),
-//     };
-
-//     println!("{:?}", op1);
-
-//     let ops_bin = bincode::serialize(&op1).unwrap();
-
-//     let dec_ops: CollectionOps = bincode::deserialize(&ops_bin).expect("Can't deserialize");
-
-//     println!("{:?}", dec_ops);
-//     // test_wal::write_wal();
-//     // test_wal::read_wal();
-//     // test_wal::truncate_wal();
-//     // test_wal::read_wal();
-// }

commit 886c8bdc4771defda7663b2c6b3d4fd3eb101e7d
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 15 14:21:55 2020 +0200

    use CORB instead of bincode for better structure version compatibility

diff --git a/src/main.rs b/src/main.rs
index d65600b89..94044a68c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,7 @@
 mod storage;
 
+
 fn main() {
-    println!("Hello word");
+
+    println!("Hello");
 }

commit ffd0ac554c7c2fefa99855c5bb6508f2c864a137
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 15 22:41:29 2020 +0200

    replase tag ops with payload ops

diff --git a/src/main.rs b/src/main.rs
index 94044a68c..f558e7200 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,5 @@
 mod storage;
-
+mod common;
 
 fn main() {
 

commit 312a6d5f9fb1204168ac1c5763a3b6389e386d4c
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Wed Jun 17 23:48:15 2020 +0200

    add spaces + simple index struct

diff --git a/src/main.rs b/src/main.rs
index f558e7200..f80dd4b68 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,8 @@
 mod storage;
+mod spaces;
 mod common;
+mod operations;
+
 
 fn main() {
 

commit 73913ea61badae80937d44f65593830b79570955
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 23 17:26:20 2020 +0200

    move segment into separate crate

diff --git a/src/main.rs b/src/main.rs
index f80dd4b68..d263305e8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,10 +1,10 @@
+extern crate segment;
+
 mod storage;
-mod spaces;
 mod common;
 mod operations;
 
 
 fn main() {
-
     println!("Hello");
 }

commit b135c329c80b37ecf1927cef4ea25eda1d3cae70
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sun Sep 13 00:10:40 2020 +0200

    WIP: implement table of content

diff --git a/src/main.rs b/src/main.rs
index d263305e8..e8438d93e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -3,6 +3,7 @@ extern crate segment;
 mod storage;
 mod common;
 mod operations;
+mod settings;
 
 
 fn main() {

commit 1e651d1439dbf07cfc377ab797e88d6db3eac52a
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Oct 12 18:56:48 2020 +0200

    toc loading

diff --git a/src/main.rs b/src/main.rs
index e8438d93e..a26111523 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,9 +1,9 @@
 extern crate segment;
 
-mod storage;
 mod common;
 mod operations;
 mod settings;
+mod api_models;
 
 
 fn main() {

commit b8ed0f581fbc22e200a8201d51f74ebae1f55756
Author: Andrei Vasnetsov <andrei.vasnetsov@moberries.com>
Date:   Sun Oct 18 16:16:24 2020 +0200

    ApiResponse helper

diff --git a/src/main.rs b/src/main.rs
index a26111523..b040b61e7 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,11 +1,45 @@
-extern crate segment;
+#[macro_use] extern crate log;
 
-mod common;
-mod operations;
 mod settings;
-mod api_models;
 
+mod common;
+mod collections_api;
+
+use actix_web::middleware::Logger;
+
+use actix_web::{web, App, HttpServer};
+
+use env_logger;
+use storage::content_manager::toc::TableOfContent;
+use crate::collections_api::api::collections;
+
+
+#[actix_web::main]
+async fn main() -> std::io::Result<()> {
+    let settings = settings::Settings::new().expect("Can't read config.");
+    std::env::set_var("RUST_LOG",  settings.log_level);
+    env_logger::init();
+
+    let toc = TableOfContent::new(&settings.storage);
+
+    for collection in toc.all_collections() {
+        info!("loaded collection: {}", collection);
+    }
+
+    let toc_data = web::Data::new(toc);
+
+    HttpServer::new(move || {
+
+        let app = App::new()
+            .wrap(Logger::default())
+            .app_data(toc_data.clone())
+            .data(web::JsonConfig::default().limit(33554432)) // 32 Mb
+            .service(collections);
 
-fn main() {
-    println!("Hello");
+        app
+    })
+    // .workers(1)
+    .bind(format!("{}:{}", settings.service.host, settings.service.port))?
+    .run()
+    .await
 }

commit 21bf6e54b805b92345952409f051e87a87bb6862
Author: Andrei Vasnetsov <andrei.vasnetsov@moberries.com>
Date:   Sun Oct 18 23:34:51 2020 +0200

    API for creating collections

diff --git a/src/main.rs b/src/main.rs
index b040b61e7..350648def 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,4 +1,5 @@
-#[macro_use] extern crate log;
+#[macro_use]
+extern crate log;
 
 mod settings;
 
@@ -7,17 +8,33 @@ mod collections_api;
 
 use actix_web::middleware::Logger;
 
-use actix_web::{web, App, HttpServer};
+use actix_web::{web, App, HttpServer, error, HttpRequest, HttpResponse};
 
 use env_logger;
 use storage::content_manager::toc::TableOfContent;
-use crate::collections_api::api::collections;
-
+use crate::collections_api::api::{get_collections, get_collection, update_collections};
+
+
+fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
+    use actix_web::error::JsonPayloadError;
+
+    let detail = err.to_string();
+    let resp = match &err {
+        JsonPayloadError::ContentType => {
+            HttpResponse::UnsupportedMediaType().body(detail)
+        }
+        JsonPayloadError::Deserialize(json_err) if json_err.is_data() => {
+            HttpResponse::UnprocessableEntity().body(detail)
+        }
+        _ => HttpResponse::BadRequest().body(detail),
+    };
+    error::InternalError::from_response(err, resp).into()
+}
 
 #[actix_web::main]
 async fn main() -> std::io::Result<()> {
     let settings = settings::Settings::new().expect("Can't read config.");
-    std::env::set_var("RUST_LOG",  settings.log_level);
+    std::env::set_var("RUST_LOG", settings.log_level);
     env_logger::init();
 
     let toc = TableOfContent::new(&settings.storage);
@@ -29,17 +46,18 @@ async fn main() -> std::io::Result<()> {
     let toc_data = web::Data::new(toc);
 
     HttpServer::new(move || {
-
         let app = App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
-            .data(web::JsonConfig::default().limit(33554432)) // 32 Mb
-            .service(collections);
+            .data(web::JsonConfig::default().limit(33554432).error_handler(json_error_handler)) // 32 Mb
+            .service(get_collections)
+            .service(update_collections)
+            .service(get_collection);
 
         app
     })
-    // .workers(1)
-    .bind(format!("{}:{}", settings.service.host, settings.service.port))?
-    .run()
-    .await
+        // .workers(1)
+        .bind(format!("{}:{}", settings.service.host, settings.service.port))?
+        .run()
+        .await
 }

commit 8442d5921f39a9b7588b19a94f5cc7b4d9590349
Author: Andrei Vasnetsov <andrei.vasnetsov@moberries.com>
Date:   Mon Oct 19 18:48:03 2020 +0200

    upgrade tokio + retrieve API

diff --git a/src/main.rs b/src/main.rs
index 350648def..17d1efd09 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -4,7 +4,7 @@ extern crate log;
 mod settings;
 
 mod common;
-mod collections_api;
+mod api;
 
 use actix_web::middleware::Logger;
 
@@ -12,7 +12,9 @@ use actix_web::{web, App, HttpServer, error, HttpRequest, HttpResponse};
 
 use env_logger;
 use storage::content_manager::toc::TableOfContent;
-use crate::collections_api::api::{get_collections, get_collection, update_collections};
+use crate::api::collections_api::{get_collections, update_collections, get_collection};
+use crate::api::update_api::update_vectors;
+use crate::api::retrieve_api::{get_vectors, get_vector};
 
 
 fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
@@ -52,7 +54,15 @@ async fn main() -> std::io::Result<()> {
             .data(web::JsonConfig::default().limit(33554432).error_handler(json_error_handler)) // 32 Mb
             .service(get_collections)
             .service(update_collections)
-            .service(get_collection);
+            .service(get_collection)
+            .service(update_vectors)
+            .service(get_vector)
+            .service(get_vectors)
+            ;
+
+        // ToDo: API for updating vectors in collection
+        // ToDo: API for retrieving vectors
+        // ToDo: API for search
 
         app
     })

commit 40ed0ed98f2fe7de2bb86b081b8ab23ed396e58a
Author: Andrei Vasnetsov <andrei.vasnetsov@moberries.com>
Date:   Mon Oct 19 23:55:18 2020 +0200

    add search API

diff --git a/src/main.rs b/src/main.rs
index 17d1efd09..e96ffab32 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -15,6 +15,7 @@ use storage::content_manager::toc::TableOfContent;
 use crate::api::collections_api::{get_collections, update_collections, get_collection};
 use crate::api::update_api::update_vectors;
 use crate::api::retrieve_api::{get_vectors, get_vector};
+use crate::api::search_api::search_vectors;
 
 
 fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
@@ -58,12 +59,10 @@ async fn main() -> std::io::Result<()> {
             .service(update_vectors)
             .service(get_vector)
             .service(get_vectors)
+            .service(search_vectors)
             ;
 
-        // ToDo: API for updating vectors in collection
-        // ToDo: API for retrieving vectors
-        // ToDo: API for search
-
+        // ToDo: fix storage issue
         app
     })
         // .workers(1)

commit f50904c962d8911fb78482c9b033e11615159ad1
Author: Andrei Vasnetsov <andrei.vasnetsov@moberries.com>
Date:   Wed Oct 21 00:35:54 2020 +0200

    allow process points with payload in one API + allow upload points in list

diff --git a/src/main.rs b/src/main.rs
index e96ffab32..eb906dd1c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -62,7 +62,6 @@ async fn main() -> std::io::Result<()> {
             .service(search_vectors)
             ;
 
-        // ToDo: fix storage issue
         app
     })
         // .workers(1)

commit 3dd550b6b91529fb4f0ff038d1ebd8e9a7d4eec3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 26 17:44:31 2020 +0100

    OpenAPI 3.0 doc generation

diff --git a/src/main.rs b/src/main.rs
index eb906dd1c..6ad8fbfda 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -14,7 +14,7 @@ use env_logger;
 use storage::content_manager::toc::TableOfContent;
 use crate::api::collections_api::{get_collections, update_collections, get_collection};
 use crate::api::update_api::update_vectors;
-use crate::api::retrieve_api::{get_vectors, get_vector};
+use crate::api::retrieve_api::{get_vectors, get_point};
 use crate::api::search_api::search_vectors;
 
 
@@ -57,7 +57,7 @@ async fn main() -> std::io::Result<()> {
             .service(update_collections)
             .service(get_collection)
             .service(update_vectors)
-            .service(get_vector)
+            .service(get_point)
             .service(get_vectors)
             .service(search_vectors)
             ;

commit ee9f3646b604b5c63acecdad0870b83f1df5786e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 26 18:08:34 2020 +0100

    add API endpoints to OpenAPI doc

diff --git a/src/main.rs b/src/main.rs
index 6ad8fbfda..fda0730f4 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -13,9 +13,9 @@ use actix_web::{web, App, HttpServer, error, HttpRequest, HttpResponse};
 use env_logger;
 use storage::content_manager::toc::TableOfContent;
 use crate::api::collections_api::{get_collections, update_collections, get_collection};
-use crate::api::update_api::update_vectors;
+use crate::api::update_api::update_points;
 use crate::api::retrieve_api::{get_vectors, get_point};
-use crate::api::search_api::search_vectors;
+use crate::api::search_api::search_points;
 
 
 fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
@@ -56,10 +56,10 @@ async fn main() -> std::io::Result<()> {
             .service(get_collections)
             .service(update_collections)
             .service(get_collection)
-            .service(update_vectors)
+            .service(update_points)
             .service(get_point)
             .service(get_vectors)
-            .service(search_vectors)
+            .service(search_points)
             ;
 
         app

commit d8b0e6c283a49c73dbdbd3031095dbd3398b5545
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Oct 27 19:57:39 2020 +0100

    dockerfile + examples

diff --git a/src/main.rs b/src/main.rs
index fda0730f4..8ce92262d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,7 @@ mod api;
 
 use actix_web::middleware::Logger;
 
-use actix_web::{web, App, HttpServer, error, HttpRequest, HttpResponse};
+use actix_web::{get, web, App, HttpServer, error, HttpRequest, HttpResponse, Responder};
 
 use env_logger;
 use storage::content_manager::toc::TableOfContent;
@@ -16,7 +16,13 @@ use crate::api::collections_api::{get_collections, update_collections, get_colle
 use crate::api::update_api::update_points;
 use crate::api::retrieve_api::{get_vectors, get_point};
 use crate::api::search_api::search_points;
+use serde::{Deserialize, Serialize};
 
+#[derive(Serialize, Deserialize)]
+pub struct VersionInfo {
+    pub title: String,
+    pub version: String
+}
 
 fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
     use actix_web::error::JsonPayloadError;
@@ -34,6 +40,14 @@ fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error
     error::InternalError::from_response(err, resp).into()
 }
 
+#[get("/")]
+pub async fn index() -> impl Responder {
+    HttpResponse::Ok().json(VersionInfo {
+        title: "qdrant - vector search engine".to_string(),
+        version: option_env!("CARGO_PKG_VERSION").unwrap().to_string()
+    })
+}
+
 #[actix_web::main]
 async fn main() -> std::io::Result<()> {
     let settings = settings::Settings::new().expect("Can't read config.");
@@ -53,6 +67,7 @@ async fn main() -> std::io::Result<()> {
             .wrap(Logger::default())
             .app_data(toc_data.clone())
             .data(web::JsonConfig::default().limit(33554432).error_handler(json_error_handler)) // 32 Mb
+            .service(index)
             .service(get_collections)
             .service(update_collections)
             .service(get_collection)

commit 62768a81937ef5ac012575dd1da93530192421af
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jan 24 23:36:49 2021 +0100

    recommender API

diff --git a/src/main.rs b/src/main.rs
index 8ce92262d..32d3183eb 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -17,6 +17,7 @@ use crate::api::update_api::update_points;
 use crate::api::retrieve_api::{get_vectors, get_point};
 use crate::api::search_api::search_points;
 use serde::{Deserialize, Serialize};
+use crate::api::recommend_api::recommend_points;
 
 #[derive(Serialize, Deserialize)]
 pub struct VersionInfo {
@@ -75,6 +76,7 @@ async fn main() -> std::io::Result<()> {
             .service(get_point)
             .service(get_vectors)
             .service(search_points)
+            .service(recommend_points)
             ;
 
         app

commit cfc5beeac72aa041b8775b8cd425f8f7935105db
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 13 22:31:09 2021 +0200

    add payload schema to collection info + indexing fixes

diff --git a/src/main.rs b/src/main.rs
index 32d3183eb..3b024e7d9 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -81,7 +81,7 @@ async fn main() -> std::io::Result<()> {
 
         app
     })
-        // .workers(1)
+        // .workers(4)
         .bind(format!("{}:{}", settings.service.host, settings.service.port))?
         .run()
         .await

commit d30e6fa8ee7e5dc1d58298f099cffea5fa20f02f
Author: trean <trean.mi@gmail.com>
Date:   Sun Jun 20 15:30:12 2021 +0200

    Implementation of points scroll API #38 (#40)
    
    * WIP: filtered points iterator #38
    
    * add paginated filtered point request function #38
    
    * add scroll api + openapi definitions #38
    
    * fix openapi #38

diff --git a/src/main.rs b/src/main.rs
index 3b024e7d9..4575a2263 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -14,7 +14,7 @@ use env_logger;
 use storage::content_manager::toc::TableOfContent;
 use crate::api::collections_api::{get_collections, update_collections, get_collection};
 use crate::api::update_api::update_points;
-use crate::api::retrieve_api::{get_vectors, get_point};
+use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use serde::{Deserialize, Serialize};
 use crate::api::recommend_api::recommend_points;
@@ -74,7 +74,8 @@ async fn main() -> std::io::Result<()> {
             .service(get_collection)
             .service(update_points)
             .service(get_point)
-            .service(get_vectors)
+            .service(get_points)
+            .service(scroll_points)
             .service(search_points)
             .service(recommend_points)
             ;

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/src/main.rs b/src/main.rs
index 4575a2263..6d6173b16 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -3,26 +3,26 @@ extern crate log;
 
 mod settings;
 
-mod common;
 mod api;
+mod common;
 
 use actix_web::middleware::Logger;
 
-use actix_web::{get, web, App, HttpServer, error, HttpRequest, HttpResponse, Responder};
+use actix_web::{error, get, web, App, HttpRequest, HttpResponse, HttpServer, Responder};
 
-use env_logger;
-use storage::content_manager::toc::TableOfContent;
-use crate::api::collections_api::{get_collections, update_collections, get_collection};
-use crate::api::update_api::update_points;
+use crate::api::collections_api::{get_collection, get_collections, update_collections};
+use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
+use crate::api::update_api::update_points;
+use env_logger;
 use serde::{Deserialize, Serialize};
-use crate::api::recommend_api::recommend_points;
+use storage::content_manager::toc::TableOfContent;
 
 #[derive(Serialize, Deserialize)]
 pub struct VersionInfo {
     pub title: String,
-    pub version: String
+    pub version: String,
 }
 
 fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
@@ -30,9 +30,7 @@ fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error
 
     let detail = err.to_string();
     let resp = match &err {
-        JsonPayloadError::ContentType => {
-            HttpResponse::UnsupportedMediaType().body(detail)
-        }
+        JsonPayloadError::ContentType => HttpResponse::UnsupportedMediaType().body(detail),
         JsonPayloadError::Deserialize(json_err) if json_err.is_data() => {
             HttpResponse::UnprocessableEntity().body(detail)
         }
@@ -45,7 +43,7 @@ fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error
 pub async fn index() -> impl Responder {
     HttpResponse::Ok().json(VersionInfo {
         title: "qdrant - vector search engine".to_string(),
-        version: option_env!("CARGO_PKG_VERSION").unwrap().to_string()
+        version: option_env!("CARGO_PKG_VERSION").unwrap().to_string(),
     })
 }
 
@@ -67,7 +65,11 @@ async fn main() -> std::io::Result<()> {
         let app = App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
-            .data(web::JsonConfig::default().limit(33554432).error_handler(json_error_handler)) // 32 Mb
+            .data(
+                web::JsonConfig::default()
+                    .limit(33554432)
+                    .error_handler(json_error_handler),
+            ) // 32 Mb
             .service(index)
             .service(get_collections)
             .service(update_collections)
@@ -77,13 +79,15 @@ async fn main() -> std::io::Result<()> {
             .service(get_points)
             .service(scroll_points)
             .service(search_points)
-            .service(recommend_points)
-            ;
+            .service(recommend_points);
 
         app
     })
-        // .workers(4)
-        .bind(format!("{}:{}", settings.service.host, settings.service.port))?
-        .run()
-        .await
+    // .workers(4)
+    .bind(format!(
+        "{}:{}",
+        settings.service.host, settings.service.port
+    ))?
+    .run()
+    .await
 }

commit b253b03ae1fbe98083339e3d4491d7a38fc03294
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 09:41:01 2021 +0100

    [CLIPPY] Fix File::write and option_env! (#49)
    
    * Replace File::write to write_all to ensure the whole vector is written
    
    * [CLIPPY] Replace option_env! with env!

diff --git a/src/main.rs b/src/main.rs
index 6d6173b16..418e97798 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -43,7 +43,7 @@ fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error
 pub async fn index() -> impl Responder {
     HttpResponse::Ok().json(VersionInfo {
         title: "qdrant - vector search engine".to_string(),
-        version: option_env!("CARGO_PKG_VERSION").unwrap().to_string(),
+        version: env!("CARGO_PKG_VERSION").to_string(),
     })
 }
 

commit 0e1a6e17507d56e7f6a7f764e7fa56a494753d4d
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 16:51:54 2021 +0100

    [Clippy] Fix a range of warnings (#52)

diff --git a/src/main.rs b/src/main.rs
index 418e97798..dc3a5b452 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -15,7 +15,6 @@ use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use crate::api::update_api::update_points;
-use env_logger;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::toc::TableOfContent;
 
@@ -62,7 +61,7 @@ async fn main() -> std::io::Result<()> {
     let toc_data = web::Data::new(toc);
 
     HttpServer::new(move || {
-        let app = App::new()
+        App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
             .data(
@@ -79,9 +78,7 @@ async fn main() -> std::io::Result<()> {
             .service(get_points)
             .service(scroll_points)
             .service(search_points)
-            .service(recommend_points);
-
-        app
+            .service(recommend_points)
     })
     // .workers(4)
     .bind(format!(

commit 12e25089cb1669a3d67c6d5ce9e68fc47d10cb6f
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sun Jul 4 23:20:16 2021 +0100

    Actix update (#55)
    
    * Updated actix to 4.0.0-beta.8
    
    * Refactored search, scroll, update and collection operation APIs to be async

diff --git a/src/main.rs b/src/main.rs
index dc3a5b452..1a8f6cfb1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -15,6 +15,7 @@ use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use crate::api::update_api::update_points;
+use actix_web::web::Data;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::toc::TableOfContent;
 
@@ -64,11 +65,11 @@ async fn main() -> std::io::Result<()> {
         App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
-            .data(
+            .app_data(Data::new(
                 web::JsonConfig::default()
                     .limit(33554432)
                     .error_handler(json_error_handler),
-            ) // 32 Mb
+            )) // 32 Mb
             .service(index)
             .service(get_collections)
             .service(update_collections)

commit 53ddce350e994ab14062f0fef53d556116df3616
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 5 00:43:23 2021 +0200

    Revert "Actix update (#55)" (#56)
    
    This reverts commit 12e25089cb1669a3d67c6d5ce9e68fc47d10cb6f.

diff --git a/src/main.rs b/src/main.rs
index 1a8f6cfb1..dc3a5b452 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -15,7 +15,6 @@ use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use crate::api::update_api::update_points;
-use actix_web::web::Data;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::toc::TableOfContent;
 
@@ -65,11 +64,11 @@ async fn main() -> std::io::Result<()> {
         App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
-            .app_data(Data::new(
+            .data(
                 web::JsonConfig::default()
                     .limit(33554432)
                     .error_handler(json_error_handler),
-            )) // 32 Mb
+            ) // 32 Mb
             .service(index)
             .service(get_collections)
             .service(update_collections)

commit 910c3b9f8a9ddf42cb9077b794fc5b6a9fa40484
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 5 23:38:00 2021 +0200

    Revert "Revert "Actix update (#55)" (#56)" (#57)
    
    This reverts commit 53ddce350e994ab14062f0fef53d556116df3616.

diff --git a/src/main.rs b/src/main.rs
index dc3a5b452..1a8f6cfb1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -15,6 +15,7 @@ use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use crate::api::update_api::update_points;
+use actix_web::web::Data;
 use serde::{Deserialize, Serialize};
 use storage::content_manager::toc::TableOfContent;
 
@@ -64,11 +65,11 @@ async fn main() -> std::io::Result<()> {
         App::new()
             .wrap(Logger::default())
             .app_data(toc_data.clone())
-            .data(
+            .app_data(Data::new(
                 web::JsonConfig::default()
                     .limit(33554432)
                     .error_handler(json_error_handler),
-            ) // 32 Mb
+            )) // 32 Mb
             .service(index)
             .service(get_collections)
             .service(update_collections)

commit f70be9bb359582c52c711bb872484e93c8408f21
Author: Konstantin G <kgrech@mail.ru>
Date:   Mon Jul 5 22:32:23 2021 +0100

    Own search runtime out of the async scope

diff --git a/src/main.rs b/src/main.rs
index 1a8f6cfb1..8490f444e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,23 +1,23 @@
 #[macro_use]
 extern crate log;
 
-mod settings;
-
 mod api;
 mod common;
+mod settings;
 
 use actix_web::middleware::Logger;
-
+use actix_web::web::Data;
 use actix_web::{error, get, web, App, HttpRequest, HttpResponse, HttpServer, Responder};
+use serde::{Deserialize, Serialize};
+use storage::content_manager::toc::TableOfContent;
 
 use crate::api::collections_api::{get_collection, get_collections, update_collections};
 use crate::api::recommend_api::recommend_points;
 use crate::api::retrieve_api::{get_point, get_points, scroll_points};
 use crate::api::search_api::search_points;
 use crate::api::update_api::update_points;
-use actix_web::web::Data;
-use serde::{Deserialize, Serialize};
-use storage::content_manager::toc::TableOfContent;
+use crate::common::helpers::create_search_runtime;
+use crate::settings::Settings;
 
 #[derive(Serialize, Deserialize)]
 pub struct VersionInfo {
@@ -47,45 +47,51 @@ pub async fn index() -> impl Responder {
     })
 }
 
-#[actix_web::main]
-async fn main() -> std::io::Result<()> {
-    let settings = settings::Settings::new().expect("Can't read config.");
-    std::env::set_var("RUST_LOG", settings.log_level);
+fn main() -> std::io::Result<()> {
+    let settings = Settings::new().expect("Can't read config.");
+    std::env::set_var("RUST_LOG", &settings.log_level);
     env_logger::init();
 
-    let toc = TableOfContent::new(&settings.storage);
+    // Create and own search runtime out of the scope of async context to ensure correct
+    // destruction of it
+    let runtime = create_search_runtime(settings.storage.performance.max_search_threads).unwrap();
+    let handle = runtime.handle().clone();
+
+    actix_web::rt::System::new().block_on(async {
+        let toc = TableOfContent::new(&settings.storage, handle);
 
-    for collection in toc.all_collections() {
-        info!("loaded collection: {}", collection);
-    }
+        for collection in toc.all_collections() {
+            info!("loaded collection: {}", collection);
+        }
 
-    let toc_data = web::Data::new(toc);
+        let toc_data = web::Data::new(toc);
 
-    HttpServer::new(move || {
-        App::new()
-            .wrap(Logger::default())
-            .app_data(toc_data.clone())
-            .app_data(Data::new(
-                web::JsonConfig::default()
-                    .limit(33554432)
-                    .error_handler(json_error_handler),
-            )) // 32 Mb
-            .service(index)
-            .service(get_collections)
-            .service(update_collections)
-            .service(get_collection)
-            .service(update_points)
-            .service(get_point)
-            .service(get_points)
-            .service(scroll_points)
-            .service(search_points)
-            .service(recommend_points)
+        HttpServer::new(move || {
+            App::new()
+                .wrap(Logger::default())
+                .app_data(toc_data.clone())
+                .app_data(Data::new(
+                    web::JsonConfig::default()
+                        .limit(33554432)
+                        .error_handler(json_error_handler),
+                )) // 32 Mb
+                .service(index)
+                .service(get_collections)
+                .service(update_collections)
+                .service(get_collection)
+                .service(update_points)
+                .service(get_point)
+                .service(get_points)
+                .service(scroll_points)
+                .service(search_points)
+                .service(recommend_points)
+        })
+        // .workers(4)
+        .bind(format!(
+            "{}:{}",
+            settings.service.host, settings.service.port
+        ))?
+        .run()
+        .await
     })
-    // .workers(4)
-    .bind(format!(
-        "{}:{}",
-        settings.service.host, settings.service.port
-    ))?
-    .run()
-    .await
 }

commit dd304495f5084b08edd64048b05d72593a957adf
Author: Daniil Naumetc <11177808+kekonen@users.noreply.github.com>
Date:   Thu Jul 15 15:25:44 2021 +0200

    Small cosmetics (#66)
    
    * some small cosmetics
    
    * fixed "expect" linting
    
    * fix formation

diff --git a/src/main.rs b/src/main.rs
index 8490f444e..d48b69504 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -54,7 +54,8 @@ fn main() -> std::io::Result<()> {
 
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
-    let runtime = create_search_runtime(settings.storage.performance.max_search_threads).unwrap();
+    let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
+        .expect("Can't create runtime.");
     let handle = runtime.handle().clone();
 
     actix_web::rt::System::new().block_on(async {
@@ -72,7 +73,7 @@ fn main() -> std::io::Result<()> {
                 .app_data(toc_data.clone())
                 .app_data(Data::new(
                     web::JsonConfig::default()
-                        .limit(33554432)
+                        .limit(32 * 1024 * 1024)
                         .error_handler(json_error_handler),
                 )) // 32 Mb
                 .service(index)

commit 9b9991d6bbce15f785dacad47ad1a979330e54e2
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sun Aug 1 19:49:15 2021 +0100

    [GRPC] Introduce GRPC API based on tonic (#76)

diff --git a/src/main.rs b/src/main.rs
index d48b69504..294d2d403 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,52 +1,22 @@
 #[macro_use]
 extern crate log;
 
-mod api;
+#[cfg(feature = "web")]
+mod actix;
 mod common;
 mod settings;
+#[cfg(feature = "grpc")]
+mod tonic;
 
-use actix_web::middleware::Logger;
-use actix_web::web::Data;
-use actix_web::{error, get, web, App, HttpRequest, HttpResponse, HttpServer, Responder};
-use serde::{Deserialize, Serialize};
+use std::io::Error;
+use std::sync::Arc;
+use std::thread;
+use std::thread::JoinHandle;
 use storage::content_manager::toc::TableOfContent;
 
-use crate::api::collections_api::{get_collection, get_collections, update_collections};
-use crate::api::recommend_api::recommend_points;
-use crate::api::retrieve_api::{get_point, get_points, scroll_points};
-use crate::api::search_api::search_points;
-use crate::api::update_api::update_points;
 use crate::common::helpers::create_search_runtime;
 use crate::settings::Settings;
 
-#[derive(Serialize, Deserialize)]
-pub struct VersionInfo {
-    pub title: String,
-    pub version: String,
-}
-
-fn json_error_handler(err: error::JsonPayloadError, _req: &HttpRequest) -> error::Error {
-    use actix_web::error::JsonPayloadError;
-
-    let detail = err.to_string();
-    let resp = match &err {
-        JsonPayloadError::ContentType => HttpResponse::UnsupportedMediaType().body(detail),
-        JsonPayloadError::Deserialize(json_err) if json_err.is_data() => {
-            HttpResponse::UnprocessableEntity().body(detail)
-        }
-        _ => HttpResponse::BadRequest().body(detail),
-    };
-    error::InternalError::from_response(err, resp).into()
-}
-
-#[get("/")]
-pub async fn index() -> impl Responder {
-    HttpResponse::Ok().json(VersionInfo {
-        title: "qdrant - vector search engine".to_string(),
-        version: env!("CARGO_PKG_VERSION").to_string(),
-    })
-}
-
 fn main() -> std::io::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
     std::env::set_var("RUST_LOG", &settings.log_level);
@@ -56,43 +26,35 @@ fn main() -> std::io::Result<()> {
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
         .expect("Can't create runtime.");
-    let handle = runtime.handle().clone();
-
-    actix_web::rt::System::new().block_on(async {
-        let toc = TableOfContent::new(&settings.storage, handle);
-
-        for collection in toc.all_collections() {
-            info!("loaded collection: {}", collection);
-        }
-
-        let toc_data = web::Data::new(toc);
-
-        HttpServer::new(move || {
-            App::new()
-                .wrap(Logger::default())
-                .app_data(toc_data.clone())
-                .app_data(Data::new(
-                    web::JsonConfig::default()
-                        .limit(32 * 1024 * 1024)
-                        .error_handler(json_error_handler),
-                )) // 32 Mb
-                .service(index)
-                .service(get_collections)
-                .service(update_collections)
-                .service(get_collection)
-                .service(update_points)
-                .service(get_point)
-                .service(get_points)
-                .service(scroll_points)
-                .service(search_points)
-                .service(recommend_points)
-        })
-        // .workers(4)
-        .bind(format!(
-            "{}:{}",
-            settings.service.host, settings.service.port
-        ))?
-        .run()
-        .await
-    })
+    let search_runtime_handle = runtime.handle().clone();
+
+    let toc = TableOfContent::new(&settings.storage, search_runtime_handle);
+    for collection in toc.all_collections() {
+        info!("loaded collection: {}", collection);
+    }
+    let toc_arc = Arc::new(toc);
+
+    let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
+
+    #[cfg(feature = "web")]
+    {
+        let toc_arc = toc_arc.clone();
+        let settings = settings.clone();
+        let handle = thread::spawn(move || actix::init(toc_arc, settings));
+        handles.push(handle);
+    }
+    #[cfg(feature = "grpc")]
+    {
+        let toc_arc = toc_arc.clone();
+        let settings = settings.clone();
+        let handle = thread::spawn(move || tonic::init(toc_arc, settings));
+        handles.push(handle);
+    }
+
+    for handle in handles.into_iter() {
+        handle.join().expect("Couldn't join on the thread")?;
+    }
+    drop(toc_arc);
+    drop(settings);
+    Ok(())
 }

commit 446d0c29f70f1154025e644b154adbd270007290
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Aug 15 23:26:01 2021 +0200

    Deadlock fix (#91)
    
    * refactor: segment managers -> collection managers
    
    * fix segments holder deadlock
    
    * apply cargo fmt
    
    * fix cargo clippy
    
    * replace sequential segment locking with multiple try_lock attempts to prevent deadlocks

diff --git a/src/main.rs b/src/main.rs
index 294d2d403..616fe2c6f 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -51,6 +51,29 @@ fn main() -> std::io::Result<()> {
         handles.push(handle);
     }
 
+    #[cfg(feature = "service_debug")]
+    {
+        use parking_lot::deadlock;
+        use std::time::Duration;
+
+        thread::spawn(move || loop {
+            thread::sleep(Duration::from_secs(10));
+            let deadlocks = deadlock::check_deadlock();
+            if deadlocks.is_empty() {
+                continue;
+            }
+
+            println!("{} deadlocks detected", deadlocks.len());
+            for (i, threads) in deadlocks.iter().enumerate() {
+                println!("Deadlock #{}", i);
+                for t in threads {
+                    println!("Thread Id {:#?}", t.thread_id());
+                    println!("{:#?}", t.backtrace());
+                }
+            }
+        });
+    }
+
     for handle in handles.into_iter() {
         handle.join().expect("Couldn't join on the thread")?;
     }

commit 2cbe1d4f6b86ae6fc8b77da5f9c68ae4444d09e6
Author: Alexander Galibey <48586936+galibey@users.noreply.github.com>
Date:   Sun Aug 22 23:11:00 2021 +0300

    Decouple searcher and updater from collection (#93)

diff --git a/src/main.rs b/src/main.rs
index 616fe2c6f..4accb7865 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -26,9 +26,8 @@ fn main() -> std::io::Result<()> {
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
         .expect("Can't create runtime.");
-    let search_runtime_handle = runtime.handle().clone();
 
-    let toc = TableOfContent::new(&settings.storage, search_runtime_handle);
+    let toc = TableOfContent::new(&settings.storage, runtime);
     for collection in toc.all_collections() {
         info!("loaded collection: {}", collection);
     }

commit 20d454e8e0d8ec1bdeb369cef94890c3a4e8341c
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sun Sep 5 13:17:40 2021 +0100

    Exposed update_colletions operation over grpc (#89)

diff --git a/src/main.rs b/src/main.rs
index 4accb7865..8423b1b42 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -27,10 +27,15 @@ fn main() -> std::io::Result<()> {
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
         .expect("Can't create runtime.");
 
+    let runtime_handle = runtime.handle().clone();
+
     let toc = TableOfContent::new(&settings.storage, runtime);
-    for collection in toc.all_collections() {
-        info!("loaded collection: {}", collection);
-    }
+    runtime_handle.block_on(async {
+        for collection in toc.all_collections().await {
+            info!("loaded collection: {}", collection);
+        }
+    });
+
     let toc_arc = Arc::new(toc);
 
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];

commit a58b74e1d435abdf0ea3e4f123b1b4f1830932bb
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Mon Oct 4 17:56:02 2021 +0100

    [GRPC] Exposed get collections, update and delete collection RPCs (#96)
    
    * [GRPC] Exposed get collections, update and delete collection RPCs
    
    * Moved every collection operation into the separate rpc

diff --git a/src/main.rs b/src/main.rs
index 8423b1b42..f2f7b7fcb 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -3,7 +3,7 @@ extern crate log;
 
 #[cfg(feature = "web")]
 mod actix;
-mod common;
+pub mod common;
 mod settings;
 #[cfg(feature = "grpc")]
 mod tonic;

commit 009d473733a369428158ade21829e71ad9dcf106
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Thu Dec 23 15:00:07 2021 +0300

    Logging updates (#150)
    
    - Log deadlocks as `error` instead of printing them
    - Minor stylistic changes to messages for consistency
    - Removes global export of log macros with `macro_use`

diff --git a/src/main.rs b/src/main.rs
index f2f7b7fcb..b8cf858f6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,6 +1,3 @@
-#[macro_use]
-extern crate log;
-
 #[cfg(feature = "web")]
 mod actix;
 pub mod common;
@@ -32,7 +29,7 @@ fn main() -> std::io::Result<()> {
     let toc = TableOfContent::new(&settings.storage, runtime);
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
-            info!("loaded collection: {}", collection);
+            log::info!("Loaded collection: {}", collection);
         }
     });
 
@@ -60,21 +57,27 @@ fn main() -> std::io::Result<()> {
         use parking_lot::deadlock;
         use std::time::Duration;
 
+        const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
+
         thread::spawn(move || loop {
-            thread::sleep(Duration::from_secs(10));
+            thread::sleep(DEADLOCK_CHECK_PERIOD);
             let deadlocks = deadlock::check_deadlock();
             if deadlocks.is_empty() {
                 continue;
             }
 
-            println!("{} deadlocks detected", deadlocks.len());
+            let mut error = format!("{} deadlocks detected\n", deadlocks.len());
             for (i, threads) in deadlocks.iter().enumerate() {
-                println!("Deadlock #{}", i);
+                error.push_str(&format!("Deadlock #{}\n", i));
                 for t in threads {
-                    println!("Thread Id {:#?}", t.thread_id());
-                    println!("{:#?}", t.backtrace());
+                    error.push_str(&format!(
+                        "Thread Id {:#?}\n{:#?}\n",
+                        t.thread_id(),
+                        t.backtrace()
+                    ));
                 }
             }
+            log::error!("{}", error);
         });
     }
 

commit 4c73d1ba8f46b7dc1d41ecf91cda7571ffef89a0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jan 24 13:39:12 2022 +0100

    name threads for observability (#247)

diff --git a/src/main.rs b/src/main.rs
index b8cf858f6..93303c202 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -41,14 +41,20 @@ fn main() -> std::io::Result<()> {
     {
         let toc_arc = toc_arc.clone();
         let settings = settings.clone();
-        let handle = thread::spawn(move || actix::init(toc_arc, settings));
+        let handle = thread::Builder::new()
+            .name("web".to_string())
+            .spawn(move || actix::init(toc_arc, settings))
+            .unwrap();
         handles.push(handle);
     }
     #[cfg(feature = "grpc")]
     {
         let toc_arc = toc_arc.clone();
         let settings = settings.clone();
-        let handle = thread::spawn(move || tonic::init(toc_arc, settings));
+        let handle = thread::Builder::new()
+            .name("grpc".to_string())
+            .spawn(move || tonic::init(toc_arc, settings))
+            .unwrap();
         handles.push(handle);
     }
 
@@ -59,26 +65,29 @@ fn main() -> std::io::Result<()> {
 
         const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
 
-        thread::spawn(move || loop {
-            thread::sleep(DEADLOCK_CHECK_PERIOD);
-            let deadlocks = deadlock::check_deadlock();
-            if deadlocks.is_empty() {
-                continue;
-            }
+        thread::Builder::new()
+            .name("deadlock_checker".to_string())
+            .spawn(move || loop {
+                thread::sleep(DEADLOCK_CHECK_PERIOD);
+                let deadlocks = deadlock::check_deadlock();
+                if deadlocks.is_empty() {
+                    continue;
+                }
 
-            let mut error = format!("{} deadlocks detected\n", deadlocks.len());
-            for (i, threads) in deadlocks.iter().enumerate() {
-                error.push_str(&format!("Deadlock #{}\n", i));
-                for t in threads {
-                    error.push_str(&format!(
-                        "Thread Id {:#?}\n{:#?}\n",
-                        t.thread_id(),
-                        t.backtrace()
-                    ));
+                let mut error = format!("{} deadlocks detected\n", deadlocks.len());
+                for (i, threads) in deadlocks.iter().enumerate() {
+                    error.push_str(&format!("Deadlock #{}\n", i));
+                    for t in threads {
+                        error.push_str(&format!(
+                            "Thread Id {:#?}\n{:#?}\n",
+                            t.thread_id(),
+                            t.backtrace()
+                        ));
+                    }
                 }
-            }
-            log::error!("{}", error);
-        });
+                log::error!("{}", error);
+            })
+            .unwrap();
     }
 
     for handle in handles.into_iter() {

commit c928217a8cd85d2d4a8f6a57b8b84601424da947
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Mar 3 19:23:31 2022 +0100

    enable gRPC via a runtime config (#352)
    
    * enable gRPC via a runtime config
    
    * code review
    
    * code review: rename rest_port to http_port
    
    * Update config/config.yaml
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * disable grpc by default
    
    * enable gPRC in integration test
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index 93303c202..3fbd388db 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,7 +2,6 @@
 mod actix;
 pub mod common;
 mod settings;
-#[cfg(feature = "grpc")]
 mod tonic;
 
 use std::io::Error;
@@ -47,15 +46,17 @@ fn main() -> std::io::Result<()> {
             .unwrap();
         handles.push(handle);
     }
-    #[cfg(feature = "grpc")]
-    {
+
+    if let Some(grpc_port) = settings.service.grpc_port {
         let toc_arc = toc_arc.clone();
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("grpc".to_string())
-            .spawn(move || tonic::init(toc_arc, settings))
+            .spawn(move || tonic::init(toc_arc, settings.service.host, grpc_port))
             .unwrap();
         handles.push(handle);
+    } else {
+        log::info!("gRPC endpoint disabled");
     }
 
     #[cfg(feature = "service_debug")]

commit dcfb44de6f104798fcadb1864bcb1f0ace932210
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Thu Mar 17 15:15:06 2022 +0300

    Consensus with Raft feature (#385)
    
    Consensus will be used to synchronize global state which is:
    - Collection meta
    - Shard to Peer mapping

diff --git a/src/main.rs b/src/main.rs
index 3fbd388db..03952964a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,9 +1,15 @@
 #[cfg(feature = "web")]
 mod actix;
 pub mod common;
+#[cfg(feature = "consensus")]
+mod consensus;
 mod settings;
 mod tonic;
 
+#[cfg(feature = "consensus")]
+use consensus::Consensus;
+#[cfg(feature = "consensus")]
+use slog::Drain;
 use std::io::Error;
 use std::sync::Arc;
 use std::thread;
@@ -18,6 +24,18 @@ fn main() -> std::io::Result<()> {
     std::env::set_var("RUST_LOG", &settings.log_level);
     env_logger::init();
 
+    #[cfg(feature = "consensus")]
+    {
+        // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
+        // logs from it to `log` crate
+        let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
+
+        let (mut consensus, _message_sender) = Consensus::new(&slog_logger);
+        thread::Builder::new()
+            .name("raft".to_string())
+            .spawn(move || consensus.start())?;
+    }
+
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)

commit d3e0d7dcec4e8dadadb68814378d2e9221f219ff
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Thu Mar 31 17:54:55 2022 +0300

    Integrate consensus into execution pipeline (#410)
    
    * Integrate consensus into execution pipeline
    
    * Review: Remove unnecessary config

diff --git a/src/main.rs b/src/main.rs
index 03952964a..7e0775876 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -24,34 +24,58 @@ fn main() -> std::io::Result<()> {
     std::env::set_var("RUST_LOG", &settings.log_level);
     env_logger::init();
 
-    #[cfg(feature = "consensus")]
-    {
-        // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
-        // logs from it to `log` crate
-        let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
-
-        let (mut consensus, _message_sender) = Consensus::new(&slog_logger);
-        thread::Builder::new()
-            .name("raft".to_string())
-            .spawn(move || consensus.start())?;
-    }
-
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
         .expect("Can't create runtime.");
-
     let runtime_handle = runtime.handle().clone();
 
-    let toc = TableOfContent::new(&settings.storage, runtime);
+    #[allow(unused_mut)]
+    let mut toc = TableOfContent::new(&settings.storage, runtime);
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::info!("Loaded collection: {}", collection);
         }
     });
 
+    #[cfg(feature = "consensus")]
+    let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
+    #[cfg(feature = "consensus")]
+    toc.with_propose_sender(propose_sender);
+
     let toc_arc = Arc::new(toc);
 
+    #[cfg(feature = "consensus")]
+    {
+        // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
+        // logs from it to `log` crate
+        let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
+
+        let (mut consensus, message_sender) = Consensus::new(&slog_logger, toc_arc.clone().into())
+            .expect("Can't initialize consensus");
+        thread::Builder::new()
+            .name("raft".to_string())
+            .spawn(move || {
+                if let Err(err) = consensus.start() {
+                    log::error!("Consensus stopped with error: {err}")
+                }
+            })?;
+
+        thread::Builder::new()
+            .name("forward-proposals".to_string())
+            .spawn(move || {
+                while let Ok(entry) = propose_receiver.recv() {
+                    if message_sender
+                        .send(consensus::Message::FromClient(entry))
+                        .is_err()
+                    {
+                        log::error!("Can not forward new entry to consensus as it was stopped.");
+                        break;
+                    }
+                }
+            })?;
+    }
+
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
 
     #[cfg(feature = "web")]

commit 74a1eb8294914e7730314b813f79a7ca9f524365
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Apr 12 11:53:02 2022 +0200

    p2p gRPC API is now internal (#464)

diff --git a/src/main.rs b/src/main.rs
index 7e0775876..b785ae6b8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -44,6 +44,7 @@ fn main() -> std::io::Result<()> {
     toc.with_propose_sender(propose_sender);
 
     let toc_arc = Arc::new(toc);
+    let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
 
     #[cfg(feature = "consensus")]
     {
@@ -74,9 +75,21 @@ fn main() -> std::io::Result<()> {
                     }
                 }
             })?;
-    }
 
-    let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
+        if let Some(internal_grpc_port) = settings.service.internal_grpc_port {
+            let toc_arc = toc_arc.clone();
+            let settings = settings.clone();
+            let handle = thread::Builder::new()
+                .name("grpc_internal".to_string())
+                .spawn(move || {
+                    tonic::init_internal(toc_arc, settings.service.host, internal_grpc_port)
+                })
+                .unwrap();
+            handles.push(handle);
+        } else {
+            log::info!("gRPC internal endpoint disabled");
+        }
+    }
 
     #[cfg(feature = "web")]
     {

commit 77b7e666be9e39610500af52504176e5a1e9d9fd
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed Apr 20 14:23:26 2022 +0300

    Add gRPC `RaftService` (#490)
    
    * Add gRPC `RaftService`
    
    * Review: Back-pressure with bounded channel

diff --git a/src/main.rs b/src/main.rs
index b785ae6b8..48acc2f7a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -62,11 +62,12 @@ fn main() -> std::io::Result<()> {
                 }
             })?;
 
+        let message_sender_moved = message_sender.clone();
         thread::Builder::new()
             .name("forward-proposals".to_string())
             .spawn(move || {
                 while let Ok(entry) = propose_receiver.recv() {
-                    if message_sender
+                    if message_sender_moved
                         .send(consensus::Message::FromClient(entry))
                         .is_err()
                     {
@@ -82,7 +83,12 @@ fn main() -> std::io::Result<()> {
             let handle = thread::Builder::new()
                 .name("grpc_internal".to_string())
                 .spawn(move || {
-                    tonic::init_internal(toc_arc, settings.service.host, internal_grpc_port)
+                    tonic::init_internal(
+                        toc_arc,
+                        settings.service.host,
+                        internal_grpc_port,
+                        message_sender,
+                    )
                 })
                 .unwrap();
             handles.push(handle);

commit d4bb6e4f49f105bbe8d186b2dada51697a1a5df3
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed Apr 27 13:01:41 2022 +0300

    Send Raft messages with gRPC client (#509)
    
    * Send Raft messages with gRPC client
    
    * Review: more specific thread names

diff --git a/src/main.rs b/src/main.rs
index 48acc2f7a..9b6ebe8d5 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -55,7 +55,7 @@ fn main() -> std::io::Result<()> {
         let (mut consensus, message_sender) = Consensus::new(&slog_logger, toc_arc.clone().into())
             .expect("Can't initialize consensus");
         thread::Builder::new()
-            .name("raft".to_string())
+            .name("consensus".to_string())
             .spawn(move || {
                 if let Err(err) = consensus.start() {
                     log::error!("Consensus stopped with error: {err}")

commit 40c4c1ec2ce37121ca670f095661786a3c3c8ea9
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Mon May 2 18:02:35 2022 +0300

    Allows bootstrapping peer on addition (#529)
    
    * Allows bootstrapping peer on addition
    
    * Review: warn on address replacement
    
    * Review: more detailed comments

diff --git a/src/main.rs b/src/main.rs
index 9b6ebe8d5..7ab0d3089 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -14,12 +14,35 @@ use std::io::Error;
 use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
+
+use ::tonic::transport::Uri;
+use clap::Parser;
 use storage::content_manager::toc::TableOfContent;
 
 use crate::common::helpers::create_search_runtime;
 use crate::settings::Settings;
 
+/// Qdrant (read: quadrant ) is a vector similarity search engine.
+/// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
+///
+/// This CLI starts a Qdrant peer/server.
+#[derive(Parser, Debug)]
+#[clap(version, about)]
+struct Args {
+    /// Uri of the peer to bootstrap from in case of multi-peer deployment.
+    /// If not specified - this peer will be considered as a first in a new deployment.
+    #[clap(long, value_name = "URI")]
+    bootstrap: Option<Uri>,
+    /// Uri of this peer.
+    /// Other peers should be able to reach it by this uri.
+    /// Default is left for single peer deployments only.
+    #[clap(long, value_name = "URI", default_value_t=Uri::from_static("127.0.0.1:8080"))]
+    uri: Uri,
+}
+
 fn main() -> std::io::Result<()> {
+    #[cfg(feature = "consensus")]
+    let args = Args::parse();
     let settings = Settings::new().expect("Can't read config.");
     std::env::set_var("RUST_LOG", &settings.log_level);
     env_logger::init();
@@ -52,8 +75,13 @@ fn main() -> std::io::Result<()> {
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
 
-        let (mut consensus, message_sender) = Consensus::new(&slog_logger, toc_arc.clone().into())
-            .expect("Can't initialize consensus");
+        let (mut consensus, message_sender) = Consensus::new(
+            &slog_logger,
+            toc_arc.clone().into(),
+            args.bootstrap,
+            args.uri,
+        )
+        .expect("Can't initialize consensus");
         thread::Builder::new()
             .name("consensus".to_string())
             .spawn(move || {

commit f3fc921e51169d4ef7ffeeaf61d7b2dac0d763cc
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Tue May 3 16:17:06 2022 +0300

    Derive this peer uri if not supplied (#546)

diff --git a/src/main.rs b/src/main.rs
index 7ab0d3089..cef3abfb3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -35,9 +35,11 @@ struct Args {
     bootstrap: Option<Uri>,
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
-    /// Default is left for single peer deployments only.
-    #[clap(long, value_name = "URI", default_value_t=Uri::from_static("127.0.0.1:8080"))]
-    uri: Uri,
+    ///
+    /// If this value is not supplied and bootstrap is enabled
+    /// then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
+    #[clap(long, value_name = "URI")]
+    uri: Option<Uri>,
 }
 
 fn main() -> std::io::Result<()> {
@@ -79,7 +81,8 @@ fn main() -> std::io::Result<()> {
             &slog_logger,
             toc_arc.clone().into(),
             args.bootstrap,
-            args.uri,
+            args.uri.map(|uri| uri.to_string()),
+            settings.service.internal_grpc_port.map(|port| port as u32),
         )
         .expect("Can't initialize consensus");
         thread::Builder::new()

commit 841ba05850bbaa1e94b06de045867eaa52b1e03a
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed May 4 20:22:45 2022 +0200

    [Sharding] Introduce cluster configuration (#547)
    
    * cluster configuration
    
    * default cluster configuration to not pollute config.yaml
    
    * code review suggestions
    
    * please clippy

diff --git a/src/main.rs b/src/main.rs
index cef3abfb3..d70c0b12b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -82,7 +82,8 @@ fn main() -> std::io::Result<()> {
             toc_arc.clone().into(),
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
-            settings.service.internal_grpc_port.map(|port| port as u32),
+            settings.cluster.p2p.p2p_port.map(|port| port as u32),
+            settings.cluster.consensus.clone(),
         )
         .expect("Can't initialize consensus");
         thread::Builder::new()
@@ -108,7 +109,7 @@ fn main() -> std::io::Result<()> {
                 }
             })?;
 
-        if let Some(internal_grpc_port) = settings.service.internal_grpc_port {
+        if let Some(internal_grpc_port) = settings.cluster.p2p.p2p_port {
             let toc_arc = toc_arc.clone();
             let settings = settings.clone();
             let handle = thread::Builder::new()

commit c7396525f9bcf2c3becf60ee43deff9f1ab83fa5
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri May 6 17:56:00 2022 +0200

    Switch consensus to a runtime configuration (#565)
    
    * switch consensus to a runtime configuration
    
    * propose_sender is always present
    
    * better toggle switch with ConsensusEnabled

diff --git a/src/main.rs b/src/main.rs
index d70c0b12b..39519d1c0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,14 +1,11 @@
 #[cfg(feature = "web")]
 mod actix;
 pub mod common;
-#[cfg(feature = "consensus")]
 mod consensus;
 mod settings;
 mod tonic;
 
-#[cfg(feature = "consensus")]
 use consensus::Consensus;
-#[cfg(feature = "consensus")]
 use slog::Drain;
 use std::io::Error;
 use std::sync::Arc;
@@ -17,7 +14,7 @@ use std::thread::JoinHandle;
 
 use ::tonic::transport::Uri;
 use clap::Parser;
-use storage::content_manager::toc::TableOfContent;
+use storage::content_manager::toc::{ConsensusEnabled, TableOfContent};
 
 use crate::common::helpers::create_search_runtime;
 use crate::settings::Settings;
@@ -43,8 +40,6 @@ struct Args {
 }
 
 fn main() -> std::io::Result<()> {
-    #[cfg(feature = "consensus")]
-    let args = Args::parse();
     let settings = Settings::new().expect("Can't read config.");
     std::env::set_var("RUST_LOG", &settings.log_level);
     env_logger::init();
@@ -55,24 +50,25 @@ fn main() -> std::io::Result<()> {
         .expect("Can't create runtime.");
     let runtime_handle = runtime.handle().clone();
 
-    #[allow(unused_mut)]
-    let mut toc = TableOfContent::new(&settings.storage, runtime);
+    let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
+    let consensus_enabled = if settings.cluster.enabled {
+        Some(ConsensusEnabled { propose_sender })
+    } else {
+        None
+    };
+
+    let toc = TableOfContent::new(&settings.storage, runtime, consensus_enabled);
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::info!("Loaded collection: {}", collection);
         }
     });
 
-    #[cfg(feature = "consensus")]
-    let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
-    #[cfg(feature = "consensus")]
-    toc.with_propose_sender(propose_sender);
-
     let toc_arc = Arc::new(toc);
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
 
-    #[cfg(feature = "consensus")]
-    {
+    if settings.cluster.enabled {
+        let args = Args::parse();
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
@@ -127,6 +123,8 @@ fn main() -> std::io::Result<()> {
         } else {
             log::info!("gRPC internal endpoint disabled");
         }
+    } else {
+        log::info!("Distributed mode disabled");
     }
 
     #[cfg(feature = "web")]

commit 75f424a5ef673b5657293b3e5dfec2d0c42b55c8
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed May 11 17:10:18 2022 +0300

    Raft configuration updates - add peer (#578)
    
    * Raft configuration updates - add peer
    
    * Review: clarify send error
    
    * Review: move `first_peer` into `ConsensusEnabled`
    
    * Fix consensus test

diff --git a/src/main.rs b/src/main.rs
index 39519d1c0..b932b3175 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -33,8 +33,10 @@ struct Args {
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
     ///
-    /// If this value is not supplied and bootstrap is enabled
-    /// then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
+    /// This value has to be supplied if this is the first peer in a new deployment.
+    ///
+    /// In case this is not the first peer and it bootstraps the value is optional.
+    /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
     #[clap(long, value_name = "URI")]
     uri: Option<Uri>,
 }
@@ -52,7 +54,11 @@ fn main() -> std::io::Result<()> {
 
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
     let consensus_enabled = if settings.cluster.enabled {
-        Some(ConsensusEnabled { propose_sender })
+        let args = Args::parse();
+        Some(ConsensusEnabled {
+            propose_sender,
+            first_peer: args.bootstrap.is_none(),
+        })
     } else {
         None
     };

commit 0a33e00647cc30869b980396298d61f5c2e4b1c0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri May 13 14:44:06 2022 +0200

    Pool gRPC transport channels (#584)
    
    * Pool gRPC transport channels
    
    * code review: do not use an extra layer of Arc
    
    * code review: better naming

diff --git a/src/main.rs b/src/main.rs
index b932b3175..31d0977aa 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -11,8 +11,10 @@ use std::io::Error;
 use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
+use std::time::Duration;
 
 use ::tonic::transport::Uri;
+use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
 use storage::content_manager::toc::{ConsensusEnabled, TableOfContent};
 
@@ -55,9 +57,14 @@ fn main() -> std::io::Result<()> {
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
     let consensus_enabled = if settings.cluster.enabled {
         let args = Args::parse();
+        let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
         Some(ConsensusEnabled {
             propose_sender,
             first_peer: args.bootstrap.is_none(),
+            transport_channel_pool: TransportChannelPool::new(
+                p2p_grpc_timeout,
+                settings.cluster.p2p.connection_pool_size,
+            ),
         })
     } else {
         None
@@ -159,7 +166,6 @@ fn main() -> std::io::Result<()> {
     #[cfg(feature = "service_debug")]
     {
         use parking_lot::deadlock;
-        use std::time::Duration;
 
         const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
 

commit 27440937bcdb8ef5af0cd660a3e4fd9f03ef42f3
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed May 18 15:22:38 2022 +0300

    Add multipeer deployment test (#590)
    
    * Add multipeer deployment test
    
    And corresponding fixes for snapshot and wal logic to make test green
    
    * Add CI for multipeer test
    
    * Increase number of peers to 5
    
    * Fix pytest installation
    
    * Fix python version
    
    * Install requests lib

diff --git a/src/main.rs b/src/main.rs
index 31d0977aa..cdaa57834 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -91,7 +91,7 @@ fn main() -> std::io::Result<()> {
             toc_arc.clone().into(),
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
-            settings.cluster.p2p.p2p_port.map(|port| port as u32),
+            settings.cluster.p2p.port.map(|port| port as u32),
             settings.cluster.consensus.clone(),
         )
         .expect("Can't initialize consensus");
@@ -118,7 +118,7 @@ fn main() -> std::io::Result<()> {
                 }
             })?;
 
-        if let Some(internal_grpc_port) = settings.cluster.p2p.p2p_port {
+        if let Some(internal_grpc_port) = settings.cluster.p2p.port {
             let toc_arc = toc_arc.clone();
             let settings = settings.clone();
             let handle = thread::Builder::new()

commit 0cf8c070f84dcd7fb42d070a28a0234dff31966b
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Thu May 19 12:35:21 2022 +0300

    Log only h2 errors (#608)

diff --git a/src/main.rs b/src/main.rs
index cdaa57834..10cb17ced 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -6,6 +6,7 @@ mod settings;
 mod tonic;
 
 use consensus::Consensus;
+use log::LevelFilter;
 use slog::Drain;
 use std::io::Error;
 use std::sync::Arc;
@@ -45,8 +46,13 @@ struct Args {
 
 fn main() -> std::io::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
-    std::env::set_var("RUST_LOG", &settings.log_level);
-    env_logger::init();
+    env_logger::Builder::new()
+        // Parse user defined log level configuration
+        .parse_filters(&settings.log_level)
+        // h2 is very verbose and we have many network operations,
+        // so it is limited to only errors
+        .filter_module("h2", LevelFilter::Error)
+        .init();
 
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it

commit c82f11956bd99290ca003ea1322e0b3fa578c3e2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 14 10:31:02 2022 +0200

    Better logging (#681)
    
    * disable info level for non-essential logging
    
    * welcome banner
    
    * fmt + clippy
    
    * return debug log level in dev mode

diff --git a/src/main.rs b/src/main.rs
index 10cb17ced..82d16199f 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,6 +2,7 @@
 mod actix;
 pub mod common;
 mod consensus;
+mod greeting;
 mod settings;
 mod tonic;
 
@@ -20,6 +21,7 @@ use clap::Parser;
 use storage::content_manager::toc::{ConsensusEnabled, TableOfContent};
 
 use crate::common::helpers::create_search_runtime;
+use crate::greeting::welcome;
 use crate::settings::Settings;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
@@ -46,13 +48,26 @@ struct Args {
 
 fn main() -> std::io::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
-    env_logger::Builder::new()
+    let is_info = settings.log_level.to_ascii_uppercase() == "INFO";
+    let mut log_builder = env_logger::Builder::new();
+
+    log_builder
         // Parse user defined log level configuration
         .parse_filters(&settings.log_level)
         // h2 is very verbose and we have many network operations,
         // so it is limited to only errors
-        .filter_module("h2", LevelFilter::Error)
-        .init();
+        .filter_module("h2", LevelFilter::Error);
+
+    if is_info {
+        // Additionally filter verbose modules if no extended logging configuration is provided
+        log_builder
+            .filter_module("wal", LevelFilter::Warn)
+            .filter_module("raft::raft", LevelFilter::Warn);
+    };
+
+    log_builder.init();
+
+    welcome();
 
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
@@ -79,7 +94,7 @@ fn main() -> std::io::Result<()> {
     let toc = TableOfContent::new(&settings.storage, runtime, consensus_enabled);
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
-            log::info!("Loaded collection: {}", collection);
+            log::debug!("Loaded collection: {}", collection);
         }
     });
 

commit 40596a6ea9b157c785ea2a7a30bcb909a3978f1c
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Jun 14 11:09:36 2022 +0200

    Bump clap from 3.1.18 to 3.2.1 (#686)
    
    * Bump clap from 3.1.18 to 3.2.1
    
    Bumps [clap](https://github.com/clap-rs/clap) from 3.1.18 to 3.2.1.
    - [Release notes](https://github.com/clap-rs/clap/releases)
    - [Changelog](https://github.com/clap-rs/clap/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/clap-rs/clap/compare/v3.1.18...clap_complete-v3.2.1)
    
    ---
    updated-dependencies:
    - dependency-name: clap
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * fix clap's deprecations
    
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 82d16199f..b37be8dec 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -33,7 +33,7 @@ use crate::settings::Settings;
 struct Args {
     /// Uri of the peer to bootstrap from in case of multi-peer deployment.
     /// If not specified - this peer will be considered as a first in a new deployment.
-    #[clap(long, value_name = "URI")]
+    #[clap(long, value_parser, value_name = "URI")]
     bootstrap: Option<Uri>,
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
@@ -42,7 +42,7 @@ struct Args {
     ///
     /// In case this is not the first peer and it bootstraps the value is optional.
     /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
-    #[clap(long, value_name = "URI")]
+    #[clap(long, value_parser, value_name = "URI")]
     uri: Option<Uri>,
 }
 

commit 533fd208b62e1d3f19267ccbaa9509158d5891b5
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed Jun 15 16:18:26 2022 +0300

    Move out consensus logic from ToC (#675)

diff --git a/src/main.rs b/src/main.rs
index b37be8dec..893e40f9c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -6,6 +6,7 @@ mod greeting;
 mod settings;
 mod tonic;
 
+use collection::ChannelService;
 use consensus::Consensus;
 use log::LevelFilter;
 use slog::Drain;
@@ -14,11 +15,13 @@ use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
 use std::time::Duration;
+use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef, Persistent};
+use storage::Dispatcher;
 
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
-use storage::content_manager::toc::{ConsensusEnabled, TableOfContent};
+use storage::content_manager::toc::TableOfContent;
 
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;
@@ -46,7 +49,7 @@ struct Args {
     uri: Option<Uri>,
 }
 
-fn main() -> std::io::Result<()> {
+fn main() -> anyhow::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
     let is_info = settings.log_level.to_ascii_uppercase() == "INFO";
     let mut log_builder = env_logger::Builder::new();
@@ -76,22 +79,24 @@ fn main() -> std::io::Result<()> {
     let runtime_handle = runtime.handle().clone();
 
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
-    let consensus_enabled = if settings.cluster.enabled {
-        let args = Args::parse();
+    let args = Args::parse();
+    let persistent_consensus_state =
+        Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
+    let mut channel_service = ChannelService::default();
+    if settings.cluster.enabled {
         let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
-        Some(ConsensusEnabled {
-            propose_sender,
-            first_peer: args.bootstrap.is_none(),
-            transport_channel_pool: TransportChannelPool::new(
-                p2p_grpc_timeout,
-                settings.cluster.p2p.connection_pool_size,
-            ),
-        })
-    } else {
-        None
-    };
-
-    let toc = TableOfContent::new(&settings.storage, runtime, consensus_enabled);
+        channel_service.channel_pool = Arc::new(TransportChannelPool::new(
+            p2p_grpc_timeout,
+            settings.cluster.p2p.connection_pool_size,
+        ));
+        channel_service.id_to_address = persistent_consensus_state.peer_address_by_id.clone();
+    }
+    let toc = TableOfContent::new(
+        &settings.storage,
+        runtime,
+        channel_service.clone(),
+        persistent_consensus_state.this_peer_id(),
+    );
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::debug!("Loaded collection: {}", collection);
@@ -100,20 +105,27 @@ fn main() -> std::io::Result<()> {
 
     let toc_arc = Arc::new(toc);
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
+    let mut dispatcher = Dispatcher::new(toc_arc.clone());
+    let consensus_state: ConsensusStateRef =
+        ConsensusState::new(persistent_consensus_state, toc_arc.clone(), propose_sender).into();
+    if settings.cluster.enabled {
+        dispatcher = dispatcher.with_consensus(consensus_state.clone());
+    }
+    let dispatcher_arc = Arc::new(dispatcher);
 
     if settings.cluster.enabled {
-        let args = Args::parse();
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
 
         let (mut consensus, message_sender) = Consensus::new(
             &slog_logger,
-            toc_arc.clone().into(),
+            consensus_state,
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
             settings.cluster.p2p.port.map(|port| port as u32),
             settings.cluster.consensus.clone(),
+            channel_service.channel_pool,
         )
         .expect("Can't initialize consensus");
         thread::Builder::new()
@@ -140,13 +152,13 @@ fn main() -> std::io::Result<()> {
             })?;
 
         if let Some(internal_grpc_port) = settings.cluster.p2p.port {
-            let toc_arc = toc_arc.clone();
             let settings = settings.clone();
+            let dispatcher_arc = dispatcher_arc.clone();
             let handle = thread::Builder::new()
                 .name("grpc_internal".to_string())
                 .spawn(move || {
                     tonic::init_internal(
-                        toc_arc,
+                        dispatcher_arc.clone(),
                         settings.service.host,
                         internal_grpc_port,
                         message_sender,
@@ -163,21 +175,20 @@ fn main() -> std::io::Result<()> {
 
     #[cfg(feature = "web")]
     {
-        let toc_arc = toc_arc.clone();
+        let dispatcher_arc = dispatcher_arc.clone();
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
-            .spawn(move || actix::init(toc_arc, settings))
+            .spawn(move || actix::init(dispatcher_arc.clone(), settings))
             .unwrap();
         handles.push(handle);
     }
 
     if let Some(grpc_port) = settings.service.grpc_port {
-        let toc_arc = toc_arc.clone();
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("grpc".to_string())
-            .spawn(move || tonic::init(toc_arc, settings.service.host, grpc_port))
+            .spawn(move || tonic::init(dispatcher_arc, settings.service.host, grpc_port))
             .unwrap();
         handles.push(handle);
     } else {

commit 2371e2d0adbe6c42ae69538727dd2fb1e894bf69
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jun 16 15:31:09 2022 +0200

    Format timestamps with millis precision in log (#707)

diff --git a/src/main.rs b/src/main.rs
index 893e40f9c..bd314bf61 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -55,6 +55,8 @@ fn main() -> anyhow::Result<()> {
     let mut log_builder = env_logger::Builder::new();
 
     log_builder
+        // Timestamp in millis
+        .format_timestamp_millis()
         // Parse user defined log level configuration
         .parse_filters(&settings.log_level)
         // h2 is very verbose and we have many network operations,

commit a56f49135d02d0c09d52184d95cb581671a3b8ae
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jun 21 20:21:21 2022 +0400

    telemetry basic info (#718)

diff --git a/src/main.rs b/src/main.rs
index bd314bf61..39a5a5eed 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,6 +5,7 @@ mod consensus;
 mod greeting;
 mod settings;
 mod tonic;
+mod user_telemetry;
 
 use collection::ChannelService;
 use consensus::Consensus;
@@ -26,6 +27,7 @@ use storage::content_manager::toc::TableOfContent;
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;
 use crate::settings::Settings;
+use crate::user_telemetry::UserTelemetryCollector;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
@@ -74,6 +76,10 @@ fn main() -> anyhow::Result<()> {
 
     welcome();
 
+    // create user telemetry collector and put settings to telemetry
+    let mut telemetry_collector = UserTelemetryCollector::new();
+    telemetry_collector.put_settings(settings.clone());
+
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)

commit 17a6b25e296a392e06d1aeddfcd17aad5ea35769
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed Jun 22 19:50:27 2022 +0300

    Add new peers as learners (#710)
    
    * Add new peers as learners
    
    * Fix Storage impl
    
    * test added
    
    * Test fixes

diff --git a/src/main.rs b/src/main.rs
index 39a5a5eed..50666a8b1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -63,7 +63,8 @@ fn main() -> anyhow::Result<()> {
         .parse_filters(&settings.log_level)
         // h2 is very verbose and we have many network operations,
         // so it is limited to only errors
-        .filter_module("h2", LevelFilter::Error);
+        .filter_module("h2", LevelFilter::Error)
+        .filter_module("tower", LevelFilter::Warn);
 
     if is_info {
         // Additionally filter verbose modules if no extended logging configuration is provided

commit cb82b7be016e45e986cce786dbff67f48bb66286
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Jul 1 01:59:49 2022 +0200

    Fix clippy 1.62 (#771)
    
    * clippy let_unit_value
    
    error: this let-binding has unit value
       --> lib/segment/src/vector_storage/simple_vector_storage.rs:397:9
        |
    397 | /         let _top_idx = match closest.get(0) {
    398 | |             Some(scored_point) => {
    399 | |                 assert_ne!(scored_point.idx, 2);
    400 | |                 assert_eq!(&raw_res1[scored_point.idx as usize], scored_point);
    ...   |
    404 | |             }
    405 | |         };
        | |__________^
        |
        = note: `-D clippy::let-unit-value` implied by `-D warnings`
        = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_unit_value
    help: omit the `let` binding
        |
    397 ~         match closest.get(0) {
    398 +             Some(scored_point) => {
    399 +                 assert_ne!(scored_point.idx, 2);
    400 +                 assert_eq!(&raw_res1[scored_point.idx as usize], scored_point);
    401 +             }
    402 +             None => {
    
    * clippy format_push_string
    
    error: `format!(..)` appended to existing `String`
       --> src/main.rs:224:21
        |
    224 |                     error.push_str(&format!("Deadlock #{}\n", i));
        |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        |
        = note: `-D clippy::format-push-string` implied by `-D warnings`
        = help: consider using `write!` to avoid the extra allocation
        = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#format_push_string
    
    error: `format!(..)` appended to existing `String`
       --> src/main.rs:226:25
        |
    226 | /                         error.push_str(&format!(
    227 | |                             "Thread Id {:#?}\n{:#?}\n",
    228 | |                             t.thread_id(),
    229 | |                             t.backtrace()
    230 | |                         ));
        | |__________________________^
        |
        = help: consider using `write!` to avoid the extra allocation
        = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#format_push_string
    
    error: could not compile `qdrant` due to 2 previous errors
    warning: build failed, waiting for other jobs to finish...
    error: could not compile `qdrant` due to 2 previous errors

diff --git a/src/main.rs b/src/main.rs
index 50666a8b1..13e96f785 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -207,6 +207,7 @@ fn main() -> anyhow::Result<()> {
     #[cfg(feature = "service_debug")]
     {
         use parking_lot::deadlock;
+        use std::fmt::Write;
 
         const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
 
@@ -221,13 +222,15 @@ fn main() -> anyhow::Result<()> {
 
                 let mut error = format!("{} deadlocks detected\n", deadlocks.len());
                 for (i, threads) in deadlocks.iter().enumerate() {
-                    error.push_str(&format!("Deadlock #{}\n", i));
+                    writeln!(error, "Deadlock #{}", i).expect("fail to writeln!");
                     for t in threads {
-                        error.push_str(&format!(
-                            "Thread Id {:#?}\n{:#?}\n",
+                        writeln!(
+                            error,
+                            "Thread Id {:#?}\n{:#?}",
                             t.thread_id(),
                             t.backtrace()
-                        ));
+                        )
+                        .expect("fail to writeln!");
                     }
                 }
                 log::error!("{}", error);

commit fac87018c45b1bc7bc957dbe254ba26349464426
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jul 1 13:21:57 2022 +0200

    Snapshoting API (#764)
    
    * wip: rest api for snapshots
    
    * fmt
    
    * fix tests
    
    * fmt
    
    * wip: collection snapshoting and recovery
    
    * fmt
    
    * remote shard snapshots
    
    * remote shard test
    
    * fmt
    
    * extend proxy snapshot test + fix double read lock
    
    * fmt + clippy
    
    * openapi schema
    
    * Update openapi/openapi-snapshots.ytt.yaml
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update openapi/openapi-snapshots.ytt.yaml
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update src/main.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * Update src/main.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * reduce writes on snapshots location
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 13e96f785..f205f26ae 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -4,6 +4,7 @@ pub mod common;
 mod consensus;
 mod greeting;
 mod settings;
+mod snapshots;
 mod tonic;
 mod user_telemetry;
 
@@ -27,6 +28,7 @@ use storage::content_manager::toc::TableOfContent;
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;
 use crate::settings::Settings;
+use crate::snapshots::recover_snapshots;
 use crate::user_telemetry::UserTelemetryCollector;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
@@ -49,6 +51,17 @@ struct Args {
     /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
     #[clap(long, value_parser, value_name = "URI")]
     uri: Option<Uri>,
+
+    /// Force snapshot re-creation
+    /// If provided - existing collections will be replaced with snapshots.
+    /// Default is to not recreate from snapshots.
+    #[clap(short, long, action, default_value_t = false)]
+    force_snapshot: bool,
+
+    /// List of paths to snapshot files.
+    /// Format: <snapshot_file_path>:<target_collection_name>
+    #[clap(long, value_name = "PATH:NAME")]
+    snapshot: Option<Vec<String>>,
 }
 
 fn main() -> anyhow::Result<()> {
@@ -74,6 +87,16 @@ fn main() -> anyhow::Result<()> {
     };
 
     log_builder.init();
+    let args = Args::parse();
+
+    if let Some(snapshots) = args.snapshot {
+        // recover from snapshots
+        recover_snapshots(
+            &snapshots,
+            args.force_snapshot,
+            &settings.storage.storage_path,
+        );
+    }
 
     welcome();
 
@@ -88,7 +111,7 @@ fn main() -> anyhow::Result<()> {
     let runtime_handle = runtime.handle().clone();
 
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
-    let args = Args::parse();
+
     let persistent_consensus_state =
         Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
     let mut channel_service = ChannelService::default();

commit 1753811e6af3a244c47dc0eec066e5ccb44afcb2
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Mon Jul 4 15:38:09 2022 +0300

    Property tests for Storage trait impl (#760)
    
    * Property tests for Storage trait impl
    
    * Review fix: add comments to `CollectionContainer`

diff --git a/src/main.rs b/src/main.rs
index f205f26ae..387d22732 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -136,10 +136,16 @@ fn main() -> anyhow::Result<()> {
     });
 
     let toc_arc = Arc::new(toc);
+    let storage_path = toc_arc.storage_path();
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
-    let consensus_state: ConsensusStateRef =
-        ConsensusState::new(persistent_consensus_state, toc_arc.clone(), propose_sender).into();
+    let consensus_state: ConsensusStateRef = ConsensusState::new(
+        persistent_consensus_state,
+        toc_arc.clone(),
+        propose_sender,
+        storage_path,
+    )
+    .into();
     if settings.cluster.enabled {
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
     }

commit 4a6b185dada99de097cc31762b3ba8c8579597e0
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Tue Jul 5 11:21:02 2022 +0300

    Retry bootstrap if term is 0 (#776)

diff --git a/src/main.rs b/src/main.rs
index 387d22732..371f7c97c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -112,7 +112,7 @@ fn main() -> anyhow::Result<()> {
 
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
 
-    let persistent_consensus_state =
+    let (persistent_consensus_state, p_state_just_initialized) =
         Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
     let mut channel_service = ChannelService::default();
     if settings.cluster.enabled {
@@ -164,6 +164,7 @@ fn main() -> anyhow::Result<()> {
             settings.cluster.p2p.port.map(|port| port as u32),
             settings.cluster.consensus.clone(),
             channel_service.channel_pool,
+            p_state_just_initialized,
         )
         .expect("Can't initialize consensus");
         thread::Builder::new()

commit 18d4e2795bceb20a9933bed8c6eb3db82f0800bf
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Wed Jul 6 15:34:36 2022 +0300

    Warnings for big consensus tick period (#785)
    
    * Print info about approximate leader election time
    
    * Warn about exceeding timeout

diff --git a/src/main.rs b/src/main.rs
index 371f7c97c..0b812afdc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -155,7 +155,6 @@ fn main() -> anyhow::Result<()> {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
-
         let (mut consensus, message_sender) = Consensus::new(
             &slog_logger,
             consensus_state,

commit dba2c4ae0cda2393115a40f2db7d499c26c5355d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jul 12 13:49:29 2022 +0400

    Collect telemetry through toc (#748)
    
    * collection telemetry
    
    * anonymize collection data
    
    * fix build
    
    * fix build

diff --git a/src/main.rs b/src/main.rs
index 0b812afdc..d549c289d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -100,10 +100,6 @@ fn main() -> anyhow::Result<()> {
 
     welcome();
 
-    // create user telemetry collector and put settings to telemetry
-    let mut telemetry_collector = UserTelemetryCollector::new();
-    telemetry_collector.put_settings(settings.clone());
-
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
@@ -151,6 +147,9 @@ fn main() -> anyhow::Result<()> {
     }
     let dispatcher_arc = Arc::new(dispatcher);
 
+    let _telemetry_collector =
+        UserTelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+
     if settings.cluster.enabled {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate

commit 2f4acd91a0794eda433a22049c66ba5845080b21
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jul 15 10:12:39 2022 +0200

    Refactor collection lib rs (#819)
    
    * move collection state into separate file
    
    * move collection_shard_distribution into separate file
    
    * move collection struct into collection.rs
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index d549c289d..760798b66 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,7 +8,6 @@ mod snapshots;
 mod tonic;
 mod user_telemetry;
 
-use collection::ChannelService;
 use consensus::Consensus;
 use log::LevelFilter;
 use slog::Drain;
@@ -23,6 +22,7 @@ use storage::Dispatcher;
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
+use collection::shard::ChannelService;
 use storage::content_manager::toc::TableOfContent;
 
 use crate::common::helpers::create_search_runtime;

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/src/main.rs b/src/main.rs
index 760798b66..c9590b232 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -8,22 +8,22 @@ mod snapshots;
 mod tonic;
 mod user_telemetry;
 
-use consensus::Consensus;
-use log::LevelFilter;
-use slog::Drain;
 use std::io::Error;
 use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
 use std::time::Duration;
-use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef, Persistent};
-use storage::Dispatcher;
 
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
 use collection::shard::ChannelService;
+use consensus::Consensus;
+use log::LevelFilter;
+use slog::Drain;
+use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef, Persistent};
 use storage::content_manager::toc::TableOfContent;
+use storage::Dispatcher;
 
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;
@@ -234,9 +234,10 @@ fn main() -> anyhow::Result<()> {
 
     #[cfg(feature = "service_debug")]
     {
-        use parking_lot::deadlock;
         use std::fmt::Write;
 
+        use parking_lot::deadlock;
+
         const DEADLOCK_CHECK_PERIOD: Duration = Duration::from_secs(10);
 
         thread::Builder::new()

commit 123332c8678fc06bcc872d0390ec28dfb57a26cc
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 18 17:11:23 2022 +0200

    Full snapshot (#824)
    
    * full snapshot rest api
    
    * openapi for snapshots
    
    * openapi snapshot api
    
    * fmt + clippy
    
    * fix recovery + implement grpc methods
    
    * fmt
    
    * same aliases to full storage snapshot
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index c9590b232..2d482226c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -28,7 +28,7 @@ use storage::Dispatcher;
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;
 use crate::settings::Settings;
-use crate::snapshots::recover_snapshots;
+use crate::snapshots::{recover_full_snapshot, recover_snapshots};
 use crate::user_telemetry::UserTelemetryCollector;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
@@ -60,8 +60,13 @@ struct Args {
 
     /// List of paths to snapshot files.
     /// Format: <snapshot_file_path>:<target_collection_name>
-    #[clap(long, value_name = "PATH:NAME")]
+    #[clap(long, value_name = "PATH:NAME", alias = "collection-snapshot")]
     snapshot: Option<Vec<String>>,
+
+    /// Path to snapshot of multiple collections.
+    /// Format: <snapshot_file_path>
+    #[clap(long, value_name = "PATH")]
+    storage_snapshot: Option<String>,
 }
 
 fn main() -> anyhow::Result<()> {
@@ -89,7 +94,13 @@ fn main() -> anyhow::Result<()> {
     log_builder.init();
     let args = Args::parse();
 
-    if let Some(snapshots) = args.snapshot {
+    if let Some(full_snapshot) = args.storage_snapshot {
+        recover_full_snapshot(
+            &full_snapshot,
+            &settings.storage.storage_path,
+            args.force_snapshot,
+        );
+    } else if let Some(snapshots) = args.snapshot {
         // recover from snapshots
         recover_snapshots(
             &snapshots,

commit bd02f835aa489598b6e0a295662743ace1f50eb1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Jul 21 16:18:40 2022 +0200

    Refactoring: Split consensus state into multiple files (#838)
    
    * fmt
    
    * move dispatcher into separate file
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index 2d482226c..6a487930d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -21,9 +21,10 @@ use collection::shard::ChannelService;
 use consensus::Consensus;
 use log::LevelFilter;
 use slog::Drain;
-use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef, Persistent};
+use storage::content_manager::consensus::persistent::Persistent;
+use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
-use storage::Dispatcher;
+use storage::dispatcher::Dispatcher;
 
 use crate::common::helpers::create_search_runtime;
 use crate::greeting::welcome;

commit 42e930ab8f2fbda080511d5f4fc1092ee70e8c88
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Jul 22 19:27:07 2022 +0400

    Segment telemetry (#814)
    
    * segment telemetry
    
    * anonymize trait
    
    * fix build
    
    * are you happy fmt
    
    * anonimyze implementations
    
    * sliding window avg (#826)
    
    * Actix web telemetry (#828)
    
    * actix web telemetry
    
    * small as move
    
    * use tokio mutex instead of std
    
    * add comments
    
    * are you happy fmt
    
    * use u16 as http status code
    
    * telemetry structs rename
    
    * fix build
    
    * using parking lot mutex
    
    * telemetry web api (#842)
    
    * telemetry web api
    
    * telemetry openapi (#843)
    
    * use async mutex for telemetry collector
    
    * use tokio mutex for telemetry collector
    
    * are you happy fmt

diff --git a/src/main.rs b/src/main.rs
index 6a487930d..96e54dfec 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -6,7 +6,6 @@ mod greeting;
 mod settings;
 mod snapshots;
 mod tonic;
-mod user_telemetry;
 
 use std::io::Error;
 use std::sync::Arc;
@@ -25,12 +24,13 @@ use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
+use tokio::sync::Mutex;
 
 use crate::common::helpers::create_search_runtime;
+use crate::common::telemetry::TelemetryCollector;
 use crate::greeting::welcome;
 use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
-use crate::user_telemetry::UserTelemetryCollector;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
@@ -159,8 +159,10 @@ fn main() -> anyhow::Result<()> {
     }
     let dispatcher_arc = Arc::new(dispatcher);
 
-    let _telemetry_collector =
-        UserTelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+    let telemetry_collector = Arc::new(Mutex::new(TelemetryCollector::new(
+        settings.clone(),
+        dispatcher_arc.clone(),
+    )));
 
     if settings.cluster.enabled {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
@@ -228,7 +230,7 @@ fn main() -> anyhow::Result<()> {
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
-            .spawn(move || actix::init(dispatcher_arc.clone(), settings))
+            .spawn(move || actix::init(dispatcher_arc.clone(), telemetry_collector, settings))
             .unwrap();
         handles.push(handle);
     }

commit dfe2d591a55f29f6d3bd27792ef3bbbec3f5cdf7
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 25 18:42:56 2022 +0200

    Clever channel timeout (#851)
    
    * active connection liveness check for channels
    
    * clippy

diff --git a/src/main.rs b/src/main.rs
index 96e54dfec..4b6e580d0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -125,8 +125,10 @@ fn main() -> anyhow::Result<()> {
     let mut channel_service = ChannelService::default();
     if settings.cluster.enabled {
         let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
+        let connection_timeout = Duration::from_millis(settings.cluster.connection_timeout_ms);
         channel_service.channel_pool = Arc::new(TransportChannelPool::new(
             p2p_grpc_timeout,
+            connection_timeout,
             settings.cluster.p2p.connection_pool_size,
         ));
         channel_service.id_to_address = persistent_consensus_state.peer_address_by_id.clone();

commit 38cf82251848b7d1435cf2a51fac0febf8517f81
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jul 27 10:12:00 2022 +0200

    Shard transmission (#830)
    
    * forward proxy shard
    
    * fmt
    
    * transmission routine
    
    * fmt
    
    * add channel service to collection
    
    * WIP: shard transfer handlelling
    
    * WIP: transfer task pool
    
    * WIP: fmt
    
    * fmt
    
    * handle commands from consensus: start, finish & abort transmission
    
    * fmt
    
    * initiate temp shard on remote
    
    * Update lib/collection/src/collection.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/collection/src/collection.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * review fixes
    
    * fmt
    
    * review fixes 2
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 4b6e580d0..3efaa3999 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -20,6 +20,7 @@ use collection::shard::ChannelService;
 use consensus::Consensus;
 use log::LevelFilter;
 use slog::Drain;
+use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
@@ -119,6 +120,7 @@ fn main() -> anyhow::Result<()> {
     let runtime_handle = runtime.handle().clone();
 
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
+    let propose_operation_sender = OperationSender::new(propose_sender);
 
     let (persistent_consensus_state, p_state_just_initialized) =
         Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
@@ -138,6 +140,7 @@ fn main() -> anyhow::Result<()> {
         runtime,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
+        propose_operation_sender.clone(),
     );
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
@@ -152,7 +155,7 @@ fn main() -> anyhow::Result<()> {
     let consensus_state: ConsensusStateRef = ConsensusState::new(
         persistent_consensus_state,
         toc_arc.clone(),
-        propose_sender,
+        propose_operation_sender,
         storage_path,
     )
     .into();

commit 95019c74cabbba0ba399e2d43a9d8b883453f5be
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 29 18:17:41 2022 +0300

    Stop consensus on error (#872)

diff --git a/src/main.rs b/src/main.rs
index 3efaa3999..ff49bdc85 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -175,7 +175,7 @@ fn main() -> anyhow::Result<()> {
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
         let (mut consensus, message_sender) = Consensus::new(
             &slog_logger,
-            consensus_state,
+            consensus_state.clone(),
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
             settings.cluster.p2p.port.map(|port| port as u32),
@@ -188,7 +188,8 @@ fn main() -> anyhow::Result<()> {
             .name("consensus".to_string())
             .spawn(move || {
                 if let Err(err) = consensus.start() {
-                    log::error!("Consensus stopped with error: {err}")
+                    log::error!("Consensus stopped with error: {err}");
+                    consensus_state.on_consensus_thread_err(err);
                 }
             })?;
 

commit ddbd190aaa9b8ead88db66ef761ab143543099a1
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Jul 30 12:33:15 2022 +0400

    Grpc telemetry (#873)
    
    * grpc telemetry
    
    * fix avg calc
    
    * separate telemetry collectors
    
    * update openapi
    
    * use parking lot for actix
    
    * are you happy fmt
    
    * fix miskate in naming

diff --git a/src/main.rs b/src/main.rs
index ff49bdc85..bcf77dba3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -25,7 +25,6 @@ use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
-use tokio::sync::Mutex;
 
 use crate::common::helpers::create_search_runtime;
 use crate::common::telemetry::TelemetryCollector;
@@ -164,10 +163,8 @@ fn main() -> anyhow::Result<()> {
     }
     let dispatcher_arc = Arc::new(dispatcher);
 
-    let telemetry_collector = Arc::new(Mutex::new(TelemetryCollector::new(
-        settings.clone(),
-        dispatcher_arc.clone(),
-    )));
+    let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+    let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
     if settings.cluster.enabled {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
@@ -211,11 +208,13 @@ fn main() -> anyhow::Result<()> {
         if let Some(internal_grpc_port) = settings.cluster.p2p.port {
             let settings = settings.clone();
             let dispatcher_arc = dispatcher_arc.clone();
+            let tonic_telemetry_collector = tonic_telemetry_collector.clone();
             let handle = thread::Builder::new()
                 .name("grpc_internal".to_string())
                 .spawn(move || {
                     tonic::init_internal(
                         dispatcher_arc.clone(),
+                        tonic_telemetry_collector.clone(),
                         settings.service.host,
                         internal_grpc_port,
                         message_sender,
@@ -233,6 +232,7 @@ fn main() -> anyhow::Result<()> {
     #[cfg(feature = "web")]
     {
         let dispatcher_arc = dispatcher_arc.clone();
+        let telemetry_collector = Arc::new(tokio::sync::Mutex::new(telemetry_collector));
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
@@ -245,7 +245,14 @@ fn main() -> anyhow::Result<()> {
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("grpc".to_string())
-            .spawn(move || tonic::init(dispatcher_arc, settings.service.host, grpc_port))
+            .spawn(move || {
+                tonic::init(
+                    dispatcher_arc,
+                    tonic_telemetry_collector,
+                    settings.service.host,
+                    grpc_port,
+                )
+            })
             .unwrap();
         handles.push(handle);
     } else {

commit 93ab03b4f1c610894b61c90ee821c13656b85af2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 2 15:35:03 2022 +0200

    Refactor main startup foo (#891)
    
    * fmt
    
    * clippy
    
    * refactor consensus run
    
    * Update src/startup.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * review fix
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index bcf77dba3..0afdf2792 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,6 +5,7 @@ mod consensus;
 mod greeting;
 mod settings;
 mod snapshots;
+mod startup;
 mod tonic;
 
 use std::io::Error;
@@ -18,7 +19,6 @@ use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
 use collection::shard::ChannelService;
 use consensus::Consensus;
-use log::LevelFilter;
 use slog::Drain;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
@@ -31,6 +31,7 @@ use crate::common::telemetry::TelemetryCollector;
 use crate::greeting::welcome;
 use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
+use crate::startup::setup_logger;
 
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
@@ -72,27 +73,8 @@ struct Args {
 
 fn main() -> anyhow::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
-    let is_info = settings.log_level.to_ascii_uppercase() == "INFO";
-    let mut log_builder = env_logger::Builder::new();
-
-    log_builder
-        // Timestamp in millis
-        .format_timestamp_millis()
-        // Parse user defined log level configuration
-        .parse_filters(&settings.log_level)
-        // h2 is very verbose and we have many network operations,
-        // so it is limited to only errors
-        .filter_module("h2", LevelFilter::Error)
-        .filter_module("tower", LevelFilter::Warn);
-
-    if is_info {
-        // Additionally filter verbose modules if no extended logging configuration is provided
-        log_builder
-            .filter_module("wal", LevelFilter::Warn)
-            .filter_module("raft::raft", LevelFilter::Warn);
-    };
-
-    log_builder.init();
+
+    setup_logger(&settings.log_level);
     let args = Args::parse();
 
     if let Some(full_snapshot) = args.storage_snapshot {
@@ -118,13 +100,23 @@ fn main() -> anyhow::Result<()> {
         .expect("Can't create runtime.");
     let runtime_handle = runtime.handle().clone();
 
+    // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
+
+    // High-level channel which could be used to send User-space consensus operations
     let propose_operation_sender = OperationSender::new(propose_sender);
 
-    let (persistent_consensus_state, p_state_just_initialized) =
+    // Saved state of the consensus.
+    let persistent_consensus_state =
         Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
+
+    // Channel service is used to manage connections between peers.
+    // It allocates required number of channels and manages proper reconnection handling
     let mut channel_service = ChannelService::default();
+
     if settings.cluster.enabled {
+        // We only need channel_service in case if cluster is enabled.
+        // So we initialize it with real values here
         let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
         let connection_timeout = Duration::from_millis(settings.cluster.connection_timeout_ms);
         channel_service.channel_pool = Arc::new(TransportChannelPool::new(
@@ -134,6 +126,9 @@ fn main() -> anyhow::Result<()> {
         ));
         channel_service.id_to_address = persistent_consensus_state.peer_address_by_id.clone();
     }
+
+    // Table of content manages the list of collections.
+    // It is a main entry point for the storage.
     let toc = TableOfContent::new(
         &settings.storage,
         runtime,
@@ -141,6 +136,8 @@ fn main() -> anyhow::Result<()> {
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),
     );
+
+    // Here we load all stored collections.
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::debug!("Loaded collection: {}", collection);
@@ -149,7 +146,12 @@ fn main() -> anyhow::Result<()> {
 
     let toc_arc = Arc::new(toc);
     let storage_path = toc_arc.storage_path();
+
+    // Holder for all actively running threads of the service: web, gPRC, consensus, etc.
     let mut handles: Vec<JoinHandle<Result<(), Error>>> = vec![];
+
+    // Router for external queries.
+    // It decides if query should go directly to the ToC or through the consensus.
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
     let consensus_state: ConsensusStateRef = ConsensusState::new(
         persistent_consensus_state,
@@ -158,11 +160,13 @@ fn main() -> anyhow::Result<()> {
         storage_path,
     )
     .into();
+
     if settings.cluster.enabled {
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
     }
     let dispatcher_arc = Arc::new(dispatcher);
 
+    // Monitoring and telemetry.
     let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
     let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
@@ -170,61 +174,27 @@ fn main() -> anyhow::Result<()> {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
-        let (mut consensus, message_sender) = Consensus::new(
+
+        // Runs raft consensus in a separate thread.
+        // Create a pipe `message_sender` to communicate with the consensus
+        let p2p_port = settings.cluster.p2p.port.expect("P2P port is not set");
+
+        let handle = Consensus::run(
             &slog_logger,
-            consensus_state.clone(),
+            consensus_state,
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
-            settings.cluster.p2p.port.map(|port| port as u32),
+            settings.service.host.clone(),
+            p2p_port,
             settings.cluster.consensus.clone(),
-            channel_service.channel_pool,
-            p_state_just_initialized,
+            channel_service,
+            propose_receiver,
+            tonic_telemetry_collector.clone(),
+            toc_arc.clone(),
         )
         .expect("Can't initialize consensus");
-        thread::Builder::new()
-            .name("consensus".to_string())
-            .spawn(move || {
-                if let Err(err) = consensus.start() {
-                    log::error!("Consensus stopped with error: {err}");
-                    consensus_state.on_consensus_thread_err(err);
-                }
-            })?;
 
-        let message_sender_moved = message_sender.clone();
-        thread::Builder::new()
-            .name("forward-proposals".to_string())
-            .spawn(move || {
-                while let Ok(entry) = propose_receiver.recv() {
-                    if message_sender_moved
-                        .send(consensus::Message::FromClient(entry))
-                        .is_err()
-                    {
-                        log::error!("Can not forward new entry to consensus as it was stopped.");
-                        break;
-                    }
-                }
-            })?;
-
-        if let Some(internal_grpc_port) = settings.cluster.p2p.port {
-            let settings = settings.clone();
-            let dispatcher_arc = dispatcher_arc.clone();
-            let tonic_telemetry_collector = tonic_telemetry_collector.clone();
-            let handle = thread::Builder::new()
-                .name("grpc_internal".to_string())
-                .spawn(move || {
-                    tonic::init_internal(
-                        dispatcher_arc.clone(),
-                        tonic_telemetry_collector.clone(),
-                        settings.service.host,
-                        internal_grpc_port,
-                        message_sender,
-                    )
-                })
-                .unwrap();
-            handles.push(handle);
-        } else {
-            log::info!("gRPC internal endpoint disabled");
-        }
+        handles.push(handle);
     } else {
         log::info!("Distributed mode disabled");
     }

commit 178ed6fce6f4564b2fee282e1c1563950c535385
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 3 18:57:52 2022 +0200

    Abort transfer on restart (#905)
    
    * abort all outgoing transferts with the consensus on restart
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index 0afdf2792..876a875da 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -195,6 +195,14 @@ fn main() -> anyhow::Result<()> {
         .expect("Can't initialize consensus");
 
         handles.push(handle);
+
+        runtime_handle
+            .block_on(async {
+                toc_arc
+                    .cancel_outgoing_all_transfers("Source peer restarted")
+                    .await
+            })
+            .unwrap();
     } else {
         log::info!("Distributed mode disabled");
     }

commit abbd3bcbf1ed5298e1fc5ad33e5f977809c27700
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat Aug 6 14:53:35 2022 +0200

    Fix transfer abort on restart (#921)
    
    * await for consensus leader before submitting transfer abort + api
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index 876a875da..8dba20f2a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -181,7 +181,7 @@ fn main() -> anyhow::Result<()> {
 
         let handle = Consensus::run(
             &slog_logger,
-            consensus_state,
+            consensus_state.clone(),
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
             settings.service.host.clone(),
@@ -198,6 +198,7 @@ fn main() -> anyhow::Result<()> {
 
         runtime_handle
             .block_on(async {
+                consensus_state.is_leader_established.await_ready();
                 toc_arc
                     .cancel_outgoing_all_transfers("Source peer restarted")
                     .await

commit 993e94eaefb3cc9128712d579e5f0d4424066768
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 10 21:15:40 2022 +0200

    V0.9.1 (#939)
    
    * minor fix + upd version to 0.9.1
    
    * fmt
    
    * fix clippy
    
    * fix test

diff --git a/src/main.rs b/src/main.rs
index 8dba20f2a..217d1bbdf 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -196,14 +196,21 @@ fn main() -> anyhow::Result<()> {
 
         handles.push(handle);
 
-        runtime_handle
-            .block_on(async {
-                consensus_state.is_leader_established.await_ready();
-                toc_arc
-                    .cancel_outgoing_all_transfers("Source peer restarted")
-                    .await
-            })
-            .unwrap();
+        let toc_arc_clone = toc_arc.clone();
+        let _cancel_transfer_handle = runtime_handle.spawn(async move {
+            consensus_state.is_leader_established.await_ready();
+            match toc_arc_clone
+                .cancel_outgoing_all_transfers("Source peer restarted")
+                .await
+            {
+                Ok(_) => {
+                    log::debug!("All transfers if any cancelled");
+                }
+                Err(err) => {
+                    log::error!("Can't cancel outgoing transfers: {}", err);
+                }
+            }
+        });
     } else {
         log::info!("Distributed mode disabled");
     }

commit 4f3cfc1f92d83a62080e1c985b23be2c086542d5
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 16 11:32:11 2022 +0200

    Jemalloc (#949)
    
    * enable jemallocator
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index 217d1bbdf..a985d4023 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -25,6 +25,8 @@ use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
+#[cfg(not(target_env = "msvc"))]
+use tikv_jemallocator::Jemalloc;
 
 use crate::common::helpers::create_search_runtime;
 use crate::common::telemetry::TelemetryCollector;
@@ -33,6 +35,10 @@ use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
 use crate::startup::setup_logger;
 
+#[cfg(not(target_env = "msvc"))]
+#[global_allocator]
+static GLOBAL: Jemalloc = Jemalloc;
+
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
 ///

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index a985d4023..ceab84811 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,3 +1,5 @@
+#![allow(deprecated)]
+
 #[cfg(feature = "web")]
 mod actix;
 pub mod common;

commit a662ec430ab18513af9d92ebd3972284de3ec2b6
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Thu Sep 29 15:05:49 2022 +0200

    Bump clap from 3.2.22 to 4.0.0 (#1072)
    
    * Bump clap from 3.2.22 to 4.0.0
    
    Bumps [clap](https://github.com/clap-rs/clap) from 3.2.22 to 4.0.0.
    - [Release notes](https://github.com/clap-rs/clap/releases)
    - [Changelog](https://github.com/clap-rs/clap/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/clap-rs/clap/compare/v3.2.22...clap_complete-v4.0.0)
    
    ---
    updated-dependencies:
    - dependency-name: clap
      dependency-type: direct:production
      update-type: version-update:semver-major
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * fix clap 4.x
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index ceab84811..6548a8dd6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -46,11 +46,11 @@ static GLOBAL: Jemalloc = Jemalloc;
 ///
 /// This CLI starts a Qdrant peer/server.
 #[derive(Parser, Debug)]
-#[clap(version, about)]
+#[command(version, about)]
 struct Args {
     /// Uri of the peer to bootstrap from in case of multi-peer deployment.
     /// If not specified - this peer will be considered as a first in a new deployment.
-    #[clap(long, value_parser, value_name = "URI")]
+    #[arg(long, value_parser, value_name = "URI")]
     bootstrap: Option<Uri>,
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
@@ -59,23 +59,23 @@ struct Args {
     ///
     /// In case this is not the first peer and it bootstraps the value is optional.
     /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
-    #[clap(long, value_parser, value_name = "URI")]
+    #[arg(long, value_parser, value_name = "URI")]
     uri: Option<Uri>,
 
     /// Force snapshot re-creation
     /// If provided - existing collections will be replaced with snapshots.
     /// Default is to not recreate from snapshots.
-    #[clap(short, long, action, default_value_t = false)]
+    #[arg(short, long, action, default_value_t = false)]
     force_snapshot: bool,
 
     /// List of paths to snapshot files.
     /// Format: <snapshot_file_path>:<target_collection_name>
-    #[clap(long, value_name = "PATH:NAME", alias = "collection-snapshot")]
+    #[arg(long, value_name = "PATH:NAME", alias = "collection-snapshot")]
     snapshot: Option<Vec<String>>,
 
     /// Path to snapshot of multiple collections.
     /// Format: <snapshot_file_path>
-    #[clap(long, value_name = "PATH")]
+    #[arg(long, value_name = "PATH")]
     storage_snapshot: Option<String>,
 }
 

commit 03ec804bef83b2aa8bf88771f66d6c99dbfbf277
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Oct 7 19:17:08 2022 +0300

    Adds panic hook (#1106)

diff --git a/src/main.rs b/src/main.rs
index 6548a8dd6..0f92b6c43 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -22,6 +22,7 @@ use clap::Parser;
 use collection::shard::ChannelService;
 use consensus::Consensus;
 use slog::Drain;
+use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
@@ -83,6 +84,7 @@ fn main() -> anyhow::Result<()> {
     let settings = Settings::new().expect("Can't read config.");
 
     setup_logger(&settings.log_level);
+    setup_panic_hook();
     let args = Args::parse();
 
     if let Some(full_snapshot) = args.storage_snapshot {

commit 9324be1d6038b4ba66ca776eb7e753e69fe5d624
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Oct 17 20:12:10 2022 +0200

    [Replication] Add replicas (#1085)
    
    * Add replicas to ReplicaSet
    
    * unproxify shard & miscs
    
    * no exlusive write locking while adding replicas
    
    * on_optimizer_config_update on Shard with async. recursion
    
    * no exlusive write locking while removing replicas
    
    * shortcut replica set propagation #1101
    
    * remove unused field
    
    * make RequestShardTransfer callback sync.
    
    * promote local & remote to replica state
    
    * fixes for replica sync api (#1123)
    
    * code review
    
    * fix replica set update - fail only if all failed
    
    * Add replica redesign (#1131)
    
    * refactor shard/mod.rs
    
    * wip
    
    * fmt
    
    * it compiles
    
    * temporary disable replica placemeant change on replication factor
    
    * fmt
    
    * finish todos
    
    * small refactoring
    
    * remove change::add
    
    * replica-set -> shard-replica-set
    
    * fmt
    
    * upd openapi
    
    * fix finish transfer logic
    
    * fix existing integration tests
    
    * shard transfer validation
    
    * fmt
    
    * review fixes
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index 0f92b6c43..61e06e0dc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -19,7 +19,7 @@ use std::time::Duration;
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
-use collection::shard::ChannelService;
+use collection::shards::channel_service::ChannelService;
 use consensus::Consensus;
 use slog::Drain;
 use startup::setup_panic_hook;

commit 664d9bd93be71532061ffbc2ff9c2b4c11f3d20f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Oct 25 17:37:15 2022 +0200

    implement concern-factor, forbig disabling the last node, improve tes… (#1168)
    
    * implement concern-factor, forbig disabling the last node, improve test stability
    
    * upd docs
    
    * improve test_recover_dead_node
    
    * rename to write_consistency_factor
    
    * Fix bug: applied index higher than commit on restart (#1172)
    
    * create collection with default status = dead + await for activation on create_collecton_op_submit
    
    * fmt
    
    * fix unit tests
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 61e06e0dc..ab4255e7b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -113,8 +113,13 @@ fn main() -> anyhow::Result<()> {
     // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
 
-    // High-level channel which could be used to send User-space consensus operations
-    let propose_operation_sender = OperationSender::new(propose_sender);
+    let propose_operation_sender = if settings.cluster.enabled {
+        // High-level channel which could be used to send User-space consensus operations
+        Some(OperationSender::new(propose_sender))
+    } else {
+        // We don't need sender for the single-node mode
+        None
+    };
 
     // Saved state of the consensus.
     let persistent_consensus_state =
@@ -163,24 +168,23 @@ fn main() -> anyhow::Result<()> {
     // Router for external queries.
     // It decides if query should go directly to the ToC or through the consensus.
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
-    let consensus_state: ConsensusStateRef = ConsensusState::new(
-        persistent_consensus_state,
-        toc_arc.clone(),
-        propose_operation_sender,
-        storage_path,
-    )
-    .into();
 
-    if settings.cluster.enabled {
+    let (telemetry_collector, dispatcher_arc) = if settings.cluster.enabled {
+        let consensus_state: ConsensusStateRef = ConsensusState::new(
+            persistent_consensus_state,
+            toc_arc.clone(),
+            propose_operation_sender.unwrap(),
+            storage_path,
+        )
+        .into();
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
-    }
-    let dispatcher_arc = Arc::new(dispatcher);
 
-    // Monitoring and telemetry.
-    let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
-    let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
+        let dispatcher_arc = Arc::new(dispatcher);
+
+        // Monitoring and telemetry.
+        let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+        let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
-    if settings.cluster.enabled {
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
         // logs from it to `log` crate
         let slog_logger = slog::Logger::root(slog_stdlog::StdLog.fuse(), slog::o!());
@@ -199,7 +203,7 @@ fn main() -> anyhow::Result<()> {
             settings.cluster.consensus.clone(),
             channel_service,
             propose_receiver,
-            tonic_telemetry_collector.clone(),
+            tonic_telemetry_collector,
             toc_arc.clone(),
         )
         .expect("Can't initialize consensus");
@@ -221,9 +225,17 @@ fn main() -> anyhow::Result<()> {
                 }
             }
         });
+        (telemetry_collector, dispatcher_arc)
     } else {
         log::info!("Distributed mode disabled");
-    }
+        let dispatcher_arc = Arc::new(dispatcher);
+
+        // Monitoring and telemetry.
+        let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+        (telemetry_collector, dispatcher_arc)
+    };
+
+    let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
     #[cfg(feature = "web")]
     {

commit 8b0b28207931bb6b8ba41109eb56e5691eddc58b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Nov 4 12:52:51 2022 +0100

    handle collections transition from single-node to cluster (#1189)

diff --git a/src/main.rs b/src/main.rs
index ab4255e7b..6a02304ee 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,6 +5,7 @@ mod actix;
 pub mod common;
 mod consensus;
 mod greeting;
+mod migrations;
 mod settings;
 mod snapshots;
 mod startup;
@@ -34,6 +35,7 @@ use tikv_jemallocator::Jemalloc;
 use crate::common::helpers::create_search_runtime;
 use crate::common::telemetry::TelemetryCollector;
 use crate::greeting::welcome;
+use crate::migrations::single_to_cluster::handle_existing_collections;
 use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
 use crate::startup::setup_logger;
@@ -87,20 +89,22 @@ fn main() -> anyhow::Result<()> {
     setup_panic_hook();
     let args = Args::parse();
 
-    if let Some(full_snapshot) = args.storage_snapshot {
+    let restored_collections = if let Some(full_snapshot) = args.storage_snapshot {
         recover_full_snapshot(
             &full_snapshot,
             &settings.storage.storage_path,
             args.force_snapshot,
-        );
+        )
     } else if let Some(snapshots) = args.snapshot {
         // recover from snapshots
         recover_snapshots(
             &snapshots,
             args.force_snapshot,
             &settings.storage.storage_path,
-        );
-    }
+        )
+    } else {
+        vec![]
+    };
 
     welcome();
 
@@ -177,6 +181,8 @@ fn main() -> anyhow::Result<()> {
             storage_path,
         )
         .into();
+        let is_new_deployment = consensus_state.is_new_deployment();
+
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
 
         let dispatcher_arc = Arc::new(dispatcher);
@@ -211,8 +217,9 @@ fn main() -> anyhow::Result<()> {
         handles.push(handle);
 
         let toc_arc_clone = toc_arc.clone();
+        let consensus_state_clone = consensus_state.clone();
         let _cancel_transfer_handle = runtime_handle.spawn(async move {
-            consensus_state.is_leader_established.await_ready();
+            consensus_state_clone.is_leader_established.await_ready();
             match toc_arc_clone
                 .cancel_outgoing_all_transfers("Source peer restarted")
                 .await
@@ -225,6 +232,24 @@ fn main() -> anyhow::Result<()> {
                 }
             }
         });
+
+        let collections_to_recover_in_consensus = if is_new_deployment {
+            let existing_collections = runtime_handle.block_on(toc_arc.all_collections());
+            existing_collections
+        } else {
+            restored_collections
+        };
+
+        if !collections_to_recover_in_consensus.is_empty() {
+            runtime_handle.spawn(handle_existing_collections(
+                toc_arc.clone(),
+                consensus_state.clone(),
+                dispatcher_arc.clone(),
+                consensus_state.this_peer_id(),
+                collections_to_recover_in_consensus,
+            ));
+        }
+
         (telemetry_collector, dispatcher_arc)
     } else {
         log::info!("Distributed mode disabled");

commit e027db4d27255784715b727bbf67abd44dd0d5c0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Nov 9 14:03:49 2022 +0100

    V0.11.2 (#1209)
    
    * Update: unmaintained crate memmap -> memmap2 (#559) (#1160)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * Consensus q n a (#1169)
    
    * Expand comments and minor refactoring for raft state
    
    * fmt
    
    * add comments to consensus.rs
    
    * fix "Consensus q n a" compatibility
    
    * Use less ram for id tracker (#1176)
    
    * use less ram for id tracker
    
    * are you happy clippy
    
    * use vec for internals
    
    * use versions for internal ids
    
    * keys test
    
    * Use less ram for id tracker fixes (#1182)
    
    * WIP: internal_to_version
    
    * fmt
    
    * fix unit tests
    
    * add comment
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * remove suggesting changes in replications on replication factor change (#1177)
    
    * Bump actix-cors from 0.6.3 to 0.6.4 (#1185)
    
    Bumps [actix-cors](https://github.com/actix/actix-extras) from 0.6.3 to 0.6.4.
    - [Release notes](https://github.com/actix/actix-extras/releases)
    - [Commits](https://github.com/actix/actix-extras/compare/cors-v0.6.3...cors-v0.6.4)
    
    ---
    updated-dependencies:
    - dependency-name: actix-cors
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * enable HTTP compression middleware (#1184)
    
    * Use systematically assert_http_ok for better error reporting (#1183)
    
    * Use systematically assert_http_ok for better error reporting
    
    * extraction assertion to use it outside of pytest
    
    * Bump pprof from 0.10.1 to 0.11.0 (#1188)
    
    Bumps [pprof](https://github.com/tikv/pprof-rs) from 0.10.1 to 0.11.0.
    - [Release notes](https://github.com/tikv/pprof-rs/releases)
    - [Changelog](https://github.com/tikv/pprof-rs/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/tikv/pprof-rs/commits)
    
    ---
    updated-dependencies:
    - dependency-name: pprof
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Cosine dist zero vectors (#1198)
    
    * skip pre-processing of zero-length vector for cosine distance
    
    * fmt
    
    * Bump env_logger from 0.9.1 to 0.9.3 (#1201)
    
    Bumps [env_logger](https://github.com/env-logger-rs/env_logger) from 0.9.1 to 0.9.3.
    - [Release notes](https://github.com/env-logger-rs/env_logger/releases)
    - [Changelog](https://github.com/env-logger-rs/env_logger/blob/main/CHANGELOG.md)
    - [Commits](https://github.com/env-logger-rs/env_logger/compare/v0.9.1...v0.9.3)
    
    ---
    updated-dependencies:
    - dependency-name: env_logger
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump indicatif from 0.17.1 to 0.17.2 (#1202)
    
    Bumps [indicatif](https://github.com/console-rs/indicatif) from 0.17.1 to 0.17.2.
    - [Release notes](https://github.com/console-rs/indicatif/releases)
    - [Commits](https://github.com/console-rs/indicatif/compare/0.17.1...0.17.2)
    
    ---
    updated-dependencies:
    - dependency-name: indicatif
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump ordered-float from 3.3.0 to 3.4.0 (#1204)
    
    Bumps [ordered-float](https://github.com/reem/rust-ordered-float) from 3.3.0 to 3.4.0.
    - [Release notes](https://github.com/reem/rust-ordered-float/releases)
    - [Commits](https://github.com/reem/rust-ordered-float/compare/v3.3.0...v3.4.0)
    
    ---
    updated-dependencies:
    - dependency-name: ordered-float
      dependency-type: direct:production
      update-type: version-update:semver-minor
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump clap from 4.0.18 to 4.0.22 (#1205)
    
    Bumps [clap](https://github.com/clap-rs/clap) from 4.0.18 to 4.0.22.
    - [Release notes](https://github.com/clap-rs/clap/releases)
    - [Changelog](https://github.com/clap-rs/clap/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/clap-rs/clap/compare/v4.0.18...v4.0.22)
    
    ---
    updated-dependencies:
    - dependency-name: clap
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    
    * Bump num_cpus from 1.13.1 to 1.14.0 (#1203)
    
    * wait for state deactivation on replica update failure (#1200)
    
    * wait for state deactivation on replica update failure
    
    * review fixes
    
    * upd version to 0.11.2
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: erare-humanum <116254494+erare-humanum@users.noreply.github.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 6a02304ee..1a31c0ad2 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -26,7 +26,7 @@ use slog::Drain;
 use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
-use storage::content_manager::consensus_state::{ConsensusState, ConsensusStateRef};
+use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusStateRef};
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 #[cfg(not(target_env = "msvc"))]
@@ -174,7 +174,7 @@ fn main() -> anyhow::Result<()> {
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
 
     let (telemetry_collector, dispatcher_arc) = if settings.cluster.enabled {
-        let consensus_state: ConsensusStateRef = ConsensusState::new(
+        let consensus_state: ConsensusStateRef = ConsensusManager::new(
             persistent_consensus_state,
             toc_arc.clone(),
             propose_operation_sender.unwrap(),
@@ -328,7 +328,7 @@ fn main() -> anyhow::Result<()> {
     }
 
     for handle in handles.into_iter() {
-        handle.join().expect("Couldn't join on the thread")?;
+        handle.join().expect("thread is not panicking")?;
     }
     drop(toc_arc);
     drop(settings);

commit ec25e973fb69dcad520a07a02256692c7e732daa
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 15 13:33:22 2022 +0100

    Recover distributed collection (#1214)
    
    * WIP: shards recovering API: download snapshot
    
    * fmt
    
    * snapshot recovery API
    
    * fmt
    
    * snapshot recovery integration test + fixes
    
    * review fixes
    
    * review fixes 2
    
    * Update lib/storage/src/content_manager/snapshots/recover.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/main.rs b/src/main.rs
index 1a31c0ad2..3217c77d8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -73,11 +73,17 @@ struct Args {
 
     /// List of paths to snapshot files.
     /// Format: <snapshot_file_path>:<target_collection_name>
+    ///
+    /// WARN: Do not use this option if you are recovering collection in existing distributed cluster.
+    /// Use `/collections/<collection-name>/snapshots/recover` API instead.
     #[arg(long, value_name = "PATH:NAME", alias = "collection-snapshot")]
     snapshot: Option<Vec<String>>,
 
     /// Path to snapshot of multiple collections.
     /// Format: <snapshot_file_path>
+    ///
+    /// WARN: Do not use this option if you are recovering collection in existing distributed cluster.
+    /// Use `/collections/<collection-name>/snapshots/recover` API instead.
     #[arg(long, value_name = "PATH")]
     storage_snapshot: Option<String>,
 }

commit 3ef66f1e967cab8fa80c02fac8f087e91c108269
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 6 12:02:57 2023 +0100

    Add configuration option to select "memory advice" used for memmapped storage
    
    - Add a simple abstraction/wrapper over `memmap2::Advice` and a global switch
      to select "memory advice" used for memmapped storage to the `segment` crate
    - Add `mmap_advice` configuration option to the `storage::types::StorageConfig`
    - Implement `search-points` benchmark

diff --git a/src/main.rs b/src/main.rs
index 3217c77d8..b45ab7407 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -95,6 +95,8 @@ fn main() -> anyhow::Result<()> {
     setup_panic_hook();
     let args = Args::parse();
 
+    segment::madvise::set_global(settings.storage.mmap_advice);
+
     let restored_collections = if let Some(full_snapshot) = args.storage_snapshot {
         recover_full_snapshot(
             &full_snapshot,

commit 5c4a133451b0d24661d24ce76556b2bb24643da7
Author: Hozan <119854621+hozan23@users.noreply.github.com>
Date:   Tue Jan 10 19:34:57 2023 +0300

    Add the option to load alternative configuration file (#1328)
    
    * add the option to load alternative configuration file
    
    * minor fix & pass cargo clippy warning

diff --git a/src/main.rs b/src/main.rs
index b45ab7407..b8cbe69e4 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -86,14 +86,21 @@ struct Args {
     /// Use `/collections/<collection-name>/snapshots/recover` API instead.
     #[arg(long, value_name = "PATH")]
     storage_snapshot: Option<String>,
+
+    /// Path to an alternative configuration file.
+    /// Format: <config_file_path>
+    ///
+    /// Default path : config/config.yaml
+    #[arg(long, value_name = "PATH")]
+    config_path: Option<String>,
 }
 
 fn main() -> anyhow::Result<()> {
-    let settings = Settings::new().expect("Can't read config.");
+    let args = Args::parse();
+    let settings = Settings::new(args.config_path).expect("Can't read config.");
 
     setup_logger(&settings.log_level);
     setup_panic_hook();
-    let args = Args::parse();
 
     segment::madvise::set_global(settings.storage.mmap_advice);
 

commit 9638f2f915f4b96364b0f0b80f31399e5e4beb58
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Jan 25 08:05:50 2023 +0100

    Collections share a single optimizer runtime (#1396)
    
    * Collections share a single optimizer runtime
    
    * review fixes
    
    * rename: optimizer_runtime -> update_runtime
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index b8cbe69e4..7f80d88d1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,7 +32,7 @@ use storage::dispatcher::Dispatcher;
 #[cfg(not(target_env = "msvc"))]
 use tikv_jemallocator::Jemalloc;
 
-use crate::common::helpers::create_search_runtime;
+use crate::common::helpers::{create_search_runtime, create_update_runtime};
 use crate::common::telemetry::TelemetryCollector;
 use crate::greeting::welcome;
 use crate::migrations::single_to_cluster::handle_existing_collections;
@@ -125,9 +125,13 @@ fn main() -> anyhow::Result<()> {
 
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
-    let runtime = create_search_runtime(settings.storage.performance.max_search_threads)
-        .expect("Can't create runtime.");
-    let runtime_handle = runtime.handle().clone();
+    let search_runtime = create_search_runtime(settings.storage.performance.max_search_threads)
+        .expect("Can't search create runtime.");
+    let search_runtime_handle = search_runtime.handle().clone();
+
+    let update_runtime =
+        create_update_runtime(settings.storage.performance.max_optimization_threads)
+            .expect("Can't optimizer create runtime.");
 
     // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
@@ -165,14 +169,15 @@ fn main() -> anyhow::Result<()> {
     // It is a main entry point for the storage.
     let toc = TableOfContent::new(
         &settings.storage,
-        runtime,
+        search_runtime,
+        update_runtime,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),
     );
 
     // Here we load all stored collections.
-    runtime_handle.block_on(async {
+    search_runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::debug!("Loaded collection: {}", collection);
         }
@@ -233,7 +238,7 @@ fn main() -> anyhow::Result<()> {
 
         let toc_arc_clone = toc_arc.clone();
         let consensus_state_clone = consensus_state.clone();
-        let _cancel_transfer_handle = runtime_handle.spawn(async move {
+        let _cancel_transfer_handle = search_runtime_handle.spawn(async move {
             consensus_state_clone.is_leader_established.await_ready();
             match toc_arc_clone
                 .cancel_outgoing_all_transfers("Source peer restarted")
@@ -249,14 +254,14 @@ fn main() -> anyhow::Result<()> {
         });
 
         let collections_to_recover_in_consensus = if is_new_deployment {
-            let existing_collections = runtime_handle.block_on(toc_arc.all_collections());
+            let existing_collections = search_runtime_handle.block_on(toc_arc.all_collections());
             existing_collections
         } else {
             restored_collections
         };
 
         if !collections_to_recover_in_consensus.is_empty() {
-            runtime_handle.spawn(handle_existing_collections(
+            search_runtime_handle.spawn(handle_existing_collections(
                 toc_arc.clone(),
                 consensus_state.clone(),
                 dispatcher_arc.clone(),

commit 9d6543fbb5c5d9aef70fd12c5ba7330fcd176a93
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Jan 25 13:43:46 2023 +0100

    Merge remaining runtimes (#1398)
    
    * Collections share a single optimizer runtime
    
    * Merge remaining runtimes
    
    * complete optimizer runtime renaming
    
    * Give general_runtime ownership to toc to avoid shutdown issues

diff --git a/src/main.rs b/src/main.rs
index 7f80d88d1..77f3446fd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,7 +32,9 @@ use storage::dispatcher::Dispatcher;
 #[cfg(not(target_env = "msvc"))]
 use tikv_jemallocator::Jemalloc;
 
-use crate::common::helpers::{create_search_runtime, create_update_runtime};
+use crate::common::helpers::{
+    create_general_purpose_runtime, create_search_runtime, create_update_runtime,
+};
 use crate::common::telemetry::TelemetryCollector;
 use crate::greeting::welcome;
 use crate::migrations::single_to_cluster::handle_existing_collections;
@@ -127,12 +129,15 @@ fn main() -> anyhow::Result<()> {
     // destruction of it
     let search_runtime = create_search_runtime(settings.storage.performance.max_search_threads)
         .expect("Can't search create runtime.");
-    let search_runtime_handle = search_runtime.handle().clone();
 
     let update_runtime =
         create_update_runtime(settings.storage.performance.max_optimization_threads)
             .expect("Can't optimizer create runtime.");
 
+    let general_runtime =
+        create_general_purpose_runtime().expect("Can't optimizer general purpose runtime.");
+    let runtime_handle = general_runtime.handle().clone();
+
     // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
 
@@ -171,13 +176,14 @@ fn main() -> anyhow::Result<()> {
         &settings.storage,
         search_runtime,
         update_runtime,
+        general_runtime,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),
     );
 
     // Here we load all stored collections.
-    search_runtime_handle.block_on(async {
+    runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
             log::debug!("Loaded collection: {}", collection);
         }
@@ -231,6 +237,7 @@ fn main() -> anyhow::Result<()> {
             propose_receiver,
             tonic_telemetry_collector,
             toc_arc.clone(),
+            runtime_handle.clone(),
         )
         .expect("Can't initialize consensus");
 
@@ -238,7 +245,7 @@ fn main() -> anyhow::Result<()> {
 
         let toc_arc_clone = toc_arc.clone();
         let consensus_state_clone = consensus_state.clone();
-        let _cancel_transfer_handle = search_runtime_handle.spawn(async move {
+        let _cancel_transfer_handle = runtime_handle.spawn(async move {
             consensus_state_clone.is_leader_established.await_ready();
             match toc_arc_clone
                 .cancel_outgoing_all_transfers("Source peer restarted")
@@ -254,14 +261,14 @@ fn main() -> anyhow::Result<()> {
         });
 
         let collections_to_recover_in_consensus = if is_new_deployment {
-            let existing_collections = search_runtime_handle.block_on(toc_arc.all_collections());
+            let existing_collections = runtime_handle.block_on(toc_arc.all_collections());
             existing_collections
         } else {
             restored_collections
         };
 
         if !collections_to_recover_in_consensus.is_empty() {
-            search_runtime_handle.spawn(handle_existing_collections(
+            runtime_handle.spawn(handle_existing_collections(
                 toc_arc.clone(),
                 consensus_state.clone(),
                 dispatcher_arc.clone(),
@@ -304,6 +311,7 @@ fn main() -> anyhow::Result<()> {
                     tonic_telemetry_collector,
                     settings.service.host,
                     grpc_port,
+                    runtime_handle,
                 )
             })
             .unwrap();
@@ -348,6 +356,10 @@ fn main() -> anyhow::Result<()> {
     }
 
     for handle in handles.into_iter() {
+        log::debug!(
+            "Waiting for thread {} to finish",
+            handle.thread().name().unwrap()
+        );
         handle.join().expect("thread is not panicking")?;
     }
     drop(toc_arc);

commit 2f0b8ec20e6b4d2fdb1ae50789386e866ca467ab
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Jan 26 00:49:18 2023 +0100

    Telemetry collection (#1401)
    
    * sending telemetry requests
    
    * report panics
    
    * fmt
    
    * remove extra runtime
    
    * fix telemetry lock release

diff --git a/src/main.rs b/src/main.rs
index 77f3446fd..f37b5fbdd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,7 +2,7 @@
 
 #[cfg(feature = "web")]
 mod actix;
-pub mod common;
+mod common;
 mod consensus;
 mod greeting;
 mod migrations;
@@ -36,6 +36,7 @@ use crate::common::helpers::{
     create_general_purpose_runtime, create_search_runtime, create_update_runtime,
 };
 use crate::common::telemetry::TelemetryCollector;
+use crate::common::telemetry_reporting::TelemetryReporter;
 use crate::greeting::welcome;
 use crate::migrations::single_to_cluster::handle_existing_collections;
 use crate::settings::Settings;
@@ -95,14 +96,24 @@ struct Args {
     /// Default path : config/config.yaml
     #[arg(long, value_name = "PATH")]
     config_path: Option<String>,
+
+    /// Disable telemetry sending to developers
+    /// If provided - telemetry collection will be disabled.
+    /// Read more: https://qdrant.tech/documentation/telemetry
+    #[arg(long, action, default_value_t = false)]
+    disable_telemetry: bool,
 }
 
 fn main() -> anyhow::Result<()> {
     let args = Args::parse();
     let settings = Settings::new(args.config_path).expect("Can't read config.");
 
+    let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
+
+    let reporting_id = TelemetryCollector::generate_id();
+
     setup_logger(&settings.log_level);
-    setup_panic_hook();
+    setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     segment::madvise::set_global(settings.storage.mmap_advice);
 
@@ -214,7 +225,8 @@ fn main() -> anyhow::Result<()> {
         let dispatcher_arc = Arc::new(dispatcher);
 
         // Monitoring and telemetry.
-        let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+        let telemetry_collector =
+            TelemetryCollector::new(settings.clone(), dispatcher_arc.clone(), reporting_id);
         let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
         // `raft` crate uses `slog` crate so it is needed to use `slog_stdlog::StdLog` to forward
@@ -283,16 +295,35 @@ fn main() -> anyhow::Result<()> {
         let dispatcher_arc = Arc::new(dispatcher);
 
         // Monitoring and telemetry.
-        let telemetry_collector = TelemetryCollector::new(settings.clone(), dispatcher_arc.clone());
+        let telemetry_collector =
+            TelemetryCollector::new(settings.clone(), dispatcher_arc.clone(), reporting_id);
         (telemetry_collector, dispatcher_arc)
     };
 
     let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
 
+    //
+    // Telemetry reporting
+    //
+
+    let reporting_id = telemetry_collector.reporting_id();
+    let telemetry_collector = Arc::new(tokio::sync::Mutex::new(telemetry_collector));
+
+    if reporting_enabled {
+        log::info!("Telemetry reporting enabled, id: {}", reporting_id);
+
+        runtime_handle.spawn(TelemetryReporter::run(telemetry_collector.clone()));
+    } else {
+        log::info!("Telemetry reporting disabled");
+    }
+
+    //
+    // REST API server
+    //
+
     #[cfg(feature = "web")]
     {
         let dispatcher_arc = dispatcher_arc.clone();
-        let telemetry_collector = Arc::new(tokio::sync::Mutex::new(telemetry_collector));
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
@@ -301,6 +332,10 @@ fn main() -> anyhow::Result<()> {
         handles.push(handle);
     }
 
+    //
+    // gRPC server
+    //
+
     if let Some(grpc_port) = settings.service.grpc_port {
         let settings = settings.clone();
         let handle = thread::Builder::new()

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index f37b5fbdd..a8a9dfb7e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -374,7 +374,7 @@ fn main() -> anyhow::Result<()> {
 
                 let mut error = format!("{} deadlocks detected\n", deadlocks.len());
                 for (i, threads) in deadlocks.iter().enumerate() {
-                    writeln!(error, "Deadlock #{}", i).expect("fail to writeln!");
+                    writeln!(error, "Deadlock #{i}").expect("fail to writeln!");
                     for t in threads {
                         writeln!(
                             error,

commit d7379f07067b928eed7c5b6c878c2d075517abb1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 7 17:03:01 2023 +0100

    Fix recover snapshot peer (#1534)
    
    * allow to recover distributed snapshot on local intance + allow recover non-existing collections
    
    * async snapshot recovery
    
    * fix tests
    
    * be polite earlier

diff --git a/src/main.rs b/src/main.rs
index a8a9dfb7e..0624c9e67 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -117,11 +117,21 @@ fn main() -> anyhow::Result<()> {
 
     segment::madvise::set_global(settings.storage.mmap_advice);
 
+    welcome();
+
+    // Saved state of the consensus.
+    let persistent_consensus_state =
+        Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
+
+    let is_distributed_deployment = settings.cluster.enabled;
+
     let restored_collections = if let Some(full_snapshot) = args.storage_snapshot {
         recover_full_snapshot(
             &full_snapshot,
             &settings.storage.storage_path,
             args.force_snapshot,
+            persistent_consensus_state.this_peer_id(),
+            is_distributed_deployment,
         )
     } else if let Some(snapshots) = args.snapshot {
         // recover from snapshots
@@ -129,13 +139,13 @@ fn main() -> anyhow::Result<()> {
             &snapshots,
             args.force_snapshot,
             &settings.storage.storage_path,
+            persistent_consensus_state.this_peer_id(),
+            is_distributed_deployment,
         )
     } else {
         vec![]
     };
 
-    welcome();
-
     // Create and own search runtime out of the scope of async context to ensure correct
     // destruction of it
     let search_runtime = create_search_runtime(settings.storage.performance.max_search_threads)
@@ -160,10 +170,6 @@ fn main() -> anyhow::Result<()> {
         None
     };
 
-    // Saved state of the consensus.
-    let persistent_consensus_state =
-        Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
-
     // Channel service is used to manage connections between peers.
     // It allocates required number of channels and manages proper reconnection handling
     let mut channel_service = ChannelService::default();

commit d50b93f06f452da0611e3470f63945da8158a207
Author: stencillogic <59373360+stencillogic@users.noreply.github.com>
Date:   Mon Mar 20 22:59:49 2023 +0300

    Add tls support (#1581)
    
    * add TLS support
    
    * update github workflow
    
    * fix formatting
    
    * fix tests
    
    * fix clippy warning
    
    * fix PR remarks

diff --git a/src/main.rs b/src/main.rs
index 0624c9e67..454e78cbc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -34,6 +34,7 @@ use tikv_jemallocator::Jemalloc;
 
 use crate::common::helpers::{
     create_general_purpose_runtime, create_search_runtime, create_update_runtime,
+    load_tls_client_config,
 };
 use crate::common::telemetry::TelemetryCollector;
 use crate::common::telemetry_reporting::TelemetryReporter;
@@ -179,10 +180,14 @@ fn main() -> anyhow::Result<()> {
         // So we initialize it with real values here
         let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
         let connection_timeout = Duration::from_millis(settings.cluster.connection_timeout_ms);
+
+        let tls_config = load_tls_client_config(&settings)?;
+
         channel_service.channel_pool = Arc::new(TransportChannelPool::new(
             p2p_grpc_timeout,
             connection_timeout,
             settings.cluster.p2p.connection_pool_size,
+            tls_config,
         ));
         channel_service.id_to_address = persistent_consensus_state.peer_address_by_id.clone();
     }
@@ -241,16 +246,12 @@ fn main() -> anyhow::Result<()> {
 
         // Runs raft consensus in a separate thread.
         // Create a pipe `message_sender` to communicate with the consensus
-        let p2p_port = settings.cluster.p2p.port.expect("P2P port is not set");
-
         let handle = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
             args.bootstrap,
             args.uri.map(|uri| uri.to_string()),
-            settings.service.host.clone(),
-            p2p_port,
-            settings.cluster.consensus.clone(),
+            settings.clone(),
             channel_service,
             propose_receiver,
             tonic_telemetry_collector,
@@ -350,7 +351,7 @@ fn main() -> anyhow::Result<()> {
                 tonic::init(
                     dispatcher_arc,
                     tonic_telemetry_collector,
-                    settings.service.host,
+                    settings,
                     grpc_port,
                     runtime_handle,
                 )

commit f0f92292e022e3ddfde82f96d393efc8b6addcf9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Apr 3 11:43:55 2023 +0400

    Add Actix and config validation (#1463)
    
    * actix validation
    
    * add check for memmap/indexing_threshold
    
    * fix actix json settings
    
    * Validate settings configuration on start, print pretty warnings on fail
    
    * Add more validation rules for settings and nested types
    
    * Move shared validation logic into collection/operations
    
    * Show validation warning in log when loading some internal configs
    
    * Show prettier actix JSON validation errors
    
    * Stubs for pretty handling of query errors, reformat validation errors
    
    * Use crate flatten function, the hard work was already done for us
    
    We don't have to flatten validation errors into their qualified field
    names ourselves because there is a utility function for this.
    
    * Configure actix path validator
    
    * Actix endpoints don't require public
    
    * Extend validation to more actix types
    
    * Validate all remaining actix path and query properties
    
    * Rephrase range validation messages to clearly describe they're inclusive
    
    * Validate all query params to respond with pretty deserialize errors
    
    * Nicely format JSON payload deserialize error responses
    
    * Improve error reporting for upsert point batches
    
    * Add basic validation test that checks a path, query and payload value
    
    * Add some validation constraints
    
    * Add simple validation error render test
    
    * Update Cargo.lock
    
    ---------
    
    Co-authored-by: timvisee <tim+github@visee.me>

diff --git a/src/main.rs b/src/main.rs
index 454e78cbc..2193631a6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -120,6 +120,9 @@ fn main() -> anyhow::Result<()> {
 
     welcome();
 
+    // Validate as soon as possible, but we must initialize logging first
+    settings.validate_and_warn();
+
     // Saved state of the consensus.
     let persistent_consensus_state =
         Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;

commit b7d0d67a589b122a0ba0304068ff330580b76a48
Author: paulotten <paulotten@users.noreply.github.com>
Date:   Wed Apr 26 03:23:34 2023 -0400

    feat: embed default config file at compile time (#1776)
    
    * feat: embed default config file at compile time
    
    * Add `test_no_config_files` and supporting `find_config_files` parameter
    
    * Error if `RUN_MODE` set but can't find config files
    
    * feat: warn if config files not found
    
    * remove find_config_files flag
    
    * Add test to deserialize just the embedded default config
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/main.rs b/src/main.rs
index 2193631a6..d4b65abba 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -107,7 +107,7 @@ struct Args {
 
 fn main() -> anyhow::Result<()> {
     let args = Args::parse();
-    let settings = Settings::new(args.config_path).expect("Can't read config.");
+    let settings = Settings::new(args.config_path)?;
 
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 

commit 93d784f269eb54eeec7e1c68e925119241eeeebb
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue May 2 20:54:13 2023 +0200

    Improve handling out-of-RAM errors during Qdrant startup (#1777)
    
    * WIP: Start working on out-of-RAM errors handling [skip ci]
    
    * Implement basic handling of out-of-RAM errors during Qdrant startup
    
    * Try to fix CI fail by allowing both V1 and V2 cgroups
    
    * Try to fix CI fail by improving cgroups handling
    
    * Fix cgroups path detection/handling (+ some minor stylistic changes)
    
    * fixup! Fix cgroups path detection/handling (+ some minor stylistic changes)
    
    * Add test
    
    * Enable low RAM test
    
    * fixup! Add test
    
    * free memory checks
    
    * rm unused function
    
    * Oom fallback script (#1809)
    
    * add recover mode in qdrant + script for handelling OOM
    
    * fix clippy
    
    * reformat entrypoint.sh
    
    * fix test
    
    * add logging to test
    
    * fix test
    
    * fix test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index d4b65abba..eedfe34ad 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -42,7 +42,7 @@ use crate::greeting::welcome;
 use crate::migrations::single_to_cluster::handle_existing_collections;
 use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
-use crate::startup::setup_logger;
+use crate::startup::{remove_started_file_indicator, setup_logger, touch_started_file_indicator};
 
 #[cfg(not(target_env = "msvc"))]
 #[global_allocator]
@@ -106,6 +106,8 @@ struct Args {
 }
 
 fn main() -> anyhow::Result<()> {
+    remove_started_file_indicator();
+
     let args = Args::parse();
     let settings = Settings::new(args.config_path)?;
 
@@ -120,6 +122,11 @@ fn main() -> anyhow::Result<()> {
 
     welcome();
 
+    if let Some(recovery_warning) = &settings.storage.recovery_mode {
+        log::warn!("Qdrant is loaded in recovery mode: {}", recovery_warning);
+        log::warn!("Read more: https://qdrant.tech/documentation/administration/#recovery-mode");
+    }
+
     // Validate as soon as possible, but we must initialize logging first
     settings.validate_and_warn();
 
@@ -400,6 +407,8 @@ fn main() -> anyhow::Result<()> {
             .unwrap();
     }
 
+    touch_started_file_indicator();
+
     for handle in handles.into_iter() {
         log::debug!(
             "Waiting for thread {} to finish",

commit a80d4cb3711f57439323d39001c9b0a1ad69dc4b
Author: Russ Cam <russ.cam@forloop.co.uk>
Date:   Wed May 31 18:02:10 2023 +1000

    Fix documentation links (#2000)
    
    * Update documentation links
    
    This commit updates documentation links to point to
    the correct locations.
    
    * formatting

diff --git a/src/main.rs b/src/main.rs
index eedfe34ad..790f442f8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -100,7 +100,7 @@ struct Args {
 
     /// Disable telemetry sending to developers
     /// If provided - telemetry collection will be disabled.
-    /// Read more: https://qdrant.tech/documentation/telemetry
+    /// Read more: https://qdrant.tech/documentation/guides/telemetry
     #[arg(long, action, default_value_t = false)]
     disable_telemetry: bool,
 }
@@ -124,7 +124,9 @@ fn main() -> anyhow::Result<()> {
 
     if let Some(recovery_warning) = &settings.storage.recovery_mode {
         log::warn!("Qdrant is loaded in recovery mode: {}", recovery_warning);
-        log::warn!("Read more: https://qdrant.tech/documentation/administration/#recovery-mode");
+        log::warn!(
+            "Read more: https://qdrant.tech/documentation/guides/administration/#recovery-mode"
+        );
     }
 
     // Validate as soon as possible, but we must initialize logging first

commit 8215410411f89e08fc1b07bc9d73bd090b63de1b
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri May 26 17:31:27 2023 +0200

    Add optional `tracing` support (#1708)
    
    * Add optional `tracing` support
    
    TODO:
    - add documentation
    
    * Add explicit compile-time check for `--cfg tokio_unstable` rust flags...
    
    ...if `console-subscriber` feature is enabled
    
    * Add basic documentation
    
    * fixup! Add basic documentation
    
    Add links, reworded few phrases and document `tracing` feature
    
    * fixup! fixup! Add basic documentation
    
    - Fix `tokio-tracing` link
    
    * fixup! Add basic documentation
    
    Too much code-blocks...
    
    * Move tracing setup into a separate function
    
    * fixup! Move tracing setup into a separate function
    
    - move tracing setup to a separate file
    - fix error handling
    
    * fixup! Move tracing setup into a separate function
    
    Add missing file 🙈

diff --git a/src/main.rs b/src/main.rs
index 790f442f8..1b1efa1cf 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -10,6 +10,7 @@ mod settings;
 mod snapshots;
 mod startup;
 mod tonic;
+mod tracing;
 
 use std::io::Error;
 use std::sync::Arc;
@@ -106,6 +107,8 @@ struct Args {
 }
 
 fn main() -> anyhow::Result<()> {
+    tracing::setup()?;
+
     remove_started_file_indicator();
 
     let args = Args::parse();

commit 794fa9d724ec4825574325e0cf580a7433e29086
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Jun 1 11:22:51 2023 +0200

    Log better TLS and REST/gRPC start errors (#2004)
    
    * Add tls directory to .gitignore
    
    * Add error type to certificate helpers
    
    * Log REST and gRPC server errors
    
    * Cleanup
    
    * Rename log_err to log_err_if_any
    
    * Add distinction between no and invalid private key

diff --git a/src/main.rs b/src/main.rs
index 1b1efa1cf..60a796fab 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -339,6 +339,15 @@ fn main() -> anyhow::Result<()> {
         log::info!("Telemetry reporting disabled");
     }
 
+    // Helper to better log start errors
+    let log_err_if_any = |server_name, result| match result {
+        Err(err) => {
+            log::error!("Error while starting {} server: {}", server_name, err);
+            Err(err)
+        }
+        ok => ok,
+    };
+
     //
     // REST API server
     //
@@ -349,7 +358,12 @@ fn main() -> anyhow::Result<()> {
         let settings = settings.clone();
         let handle = thread::Builder::new()
             .name("web".to_string())
-            .spawn(move || actix::init(dispatcher_arc.clone(), telemetry_collector, settings))
+            .spawn(move || {
+                log_err_if_any(
+                    "REST",
+                    actix::init(dispatcher_arc.clone(), telemetry_collector, settings),
+                )
+            })
             .unwrap();
         handles.push(handle);
     }
@@ -363,12 +377,15 @@ fn main() -> anyhow::Result<()> {
         let handle = thread::Builder::new()
             .name("grpc".to_string())
             .spawn(move || {
-                tonic::init(
-                    dispatcher_arc,
-                    tonic_telemetry_collector,
-                    settings,
-                    grpc_port,
-                    runtime_handle,
+                log_err_if_any(
+                    "gRPC",
+                    tonic::init(
+                        dispatcher_arc,
+                        tonic_telemetry_collector,
+                        settings,
+                        grpc_port,
+                        runtime_handle,
+                    ),
                 )
             })
             .unwrap();

commit a048be2217e6b71a966c2a656c584e0af0a0023e
Author: Tim <dev@timsueberkrueb.io>
Date:   Mon Jun 5 10:20:21 2023 +0200

    Fix warnings pointed out by `cargo doc` (#1997)

diff --git a/src/main.rs b/src/main.rs
index 60a796fab..4948996da 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -101,7 +101,7 @@ struct Args {
 
     /// Disable telemetry sending to developers
     /// If provided - telemetry collection will be disabled.
-    /// Read more: https://qdrant.tech/documentation/guides/telemetry
+    /// Read more: <https://qdrant.tech/documentation/guides/telemetry>
     #[arg(long, action, default_value_t = false)]
     disable_telemetry: bool,
 }

commit 16ddb98134704791c397413966103ff28104977b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 6 21:42:24 2023 +0200

    Web UI integration (#2009)
    
    * wip: integrate UI web interface
    
    * fmt
    
    * Api key exclusion rule + fixes
    
    * upd welcome url
    
    * rollback api key in config

diff --git a/src/main.rs b/src/main.rs
index 4948996da..cb98f4a18 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -123,7 +123,7 @@ fn main() -> anyhow::Result<()> {
 
     segment::madvise::set_global(settings.storage.mmap_advice);
 
-    welcome();
+    welcome(&settings);
 
     if let Some(recovery_warning) = &settings.storage.recovery_mode {
         log::warn!("Qdrant is loaded in recovery mode: {}", recovery_warning);

commit 3867bf85c75c290128a83477c76415093c8c4dac
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jun 12 19:53:23 2023 +0200

    WIP: Async uring vector storage (#2024)
    
    * async raw scorer
    
    * fmt
    
    * Disable `async_raw_scorer` on non-Linux platforms
    
    * Refactor `async_raw_scorer.rs`
    
    * Conditionally enable `async_raw_scorer` in `segment` crate
    
    * Add `async_scorer` config parameter to the config...
    
    ...and enable `async_raw_scorer`, if config parameter is set to `true`
    
    * fixup! Add `async_scorer` config parameter to the config...
    
    Fix tests
    
    * Add basic `async_raw_scorer` test
    
    * Extend `async_raw_scorer` tests to be more extensive
    
    * Async uring vector storage io uring (#2041)
    
    * replace tokio-uring with just low level io-uring
    
    * fnt
    
    * minor fixes
    
    * add sync
    
    * wip: try to use less submissions
    
    * fmt
    
    * fix uring size
    
    * larger buffer
    
    * check for overflow
    
    * submit with re-try
    
    * mmap owns uring context
    
    * large disk parallelism
    
    * rollbacK: large disk parallelism
    
    * fix windows build
    
    * explicitly panic on uring fail
    
    * fix windows build again
    
    * use async scorer in the quantization re-scoring
    
    * refactor
    
    * rename UringReader
    
    * refactor buffers
    
    * fix for windows
    
    * error checking
    
    * fix handing
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/src/main.rs b/src/main.rs
index cb98f4a18..2d24d20dd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -122,6 +122,7 @@ fn main() -> anyhow::Result<()> {
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     segment::madvise::set_global(settings.storage.mmap_advice);
+    segment::vector_storage::raw_scorer::set_async_scorer(settings.storage.async_scorer);
 
     welcome(&settings);
 

commit cedd8c5a990586cfaf848fafa04b05df92ac81de
Author: Denis Bazhenov <dotsid@gmail.com>
Date:   Sun Jul 2 20:28:47 2023 +0700

    TableOfContent now accepts Handle, not Runtime (#2096)
    
    * TableOfContent now accepts Handle, not Runtime
    
    Runtime is left within main() and dropped there to shutdown the system
    
    * Correct termination of consensus loop
    
    Now consensus loop is joined by main thread and
    correctly terminated between iterations of the loop
    
    * Add clippy #[allow]
    
    * Move complicated type into definition
    
    * Remove duplicate on_consensus_stopped call
    
    * wait_unwrap() is now time bounded
    
    Drop is happening only if Arc<TableOfContent> is droped by all threads
    in 30 seconds to limit shutdown time
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/main.rs b/src/main.rs
index 2d24d20dd..2e1354362 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -16,7 +16,7 @@ use std::io::Error;
 use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
-use std::time::Duration;
+use std::time::{Duration, Instant};
 
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
@@ -212,9 +212,9 @@ fn main() -> anyhow::Result<()> {
     // It is a main entry point for the storage.
     let toc = TableOfContent::new(
         &settings.storage,
-        search_runtime,
-        update_runtime,
-        general_runtime,
+        search_runtime.handle().clone(),
+        update_runtime.handle().clone(),
+        general_runtime.handle().clone(),
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),
@@ -262,7 +262,7 @@ fn main() -> anyhow::Result<()> {
 
         // Runs raft consensus in a separate thread.
         // Create a pipe `message_sender` to communicate with the consensus
-        let handle = Consensus::run(
+        let (grpc_handle, consensus_handle) = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
             args.bootstrap,
@@ -276,7 +276,8 @@ fn main() -> anyhow::Result<()> {
         )
         .expect("Can't initialize consensus");
 
-        handles.push(handle);
+        handles.push(grpc_handle);
+        handles.push(consensus_handle);
 
         let toc_arc_clone = toc_arc.clone();
         let consensus_state_clone = consensus_state.clone();
@@ -439,7 +440,34 @@ fn main() -> anyhow::Result<()> {
         );
         handle.join().expect("thread is not panicking")?;
     }
-    drop(toc_arc);
+    drop(search_runtime);
+    drop(update_runtime);
+    drop(general_runtime);
     drop(settings);
+    if let Ok(toc) = wait_unwrap(toc_arc, Duration::from_secs(30)) {
+        drop(toc);
+    }
     Ok(())
 }
+
+/// Blocks current thread for up to specified amount of time to become the single referent
+/// of an [`Arc`] and returns it.
+///
+/// This methods move a value out from an [`Arc`] when there is only one reference left
+/// and it is safe to do so. `Err()` is returned if an [`Arc`] still has more than 1 reference
+/// after given duration is passed.
+fn wait_unwrap<T>(mut input: Arc<T>, duration: Duration) -> Result<T, ()> {
+    let start_time = Instant::now();
+    while start_time.elapsed() < duration {
+        match Arc::try_unwrap(input) {
+            Ok(input) => {
+                return Ok(input);
+            }
+            Err(new_input) => {
+                input = new_input;
+                thread::sleep_ms(100);
+            }
+        }
+    }
+    Err(())
+}

commit 248ca7fb11bbc861c383dd1df7b1ace763f68e8b
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jul 3 14:05:47 2023 +0200

    Revert "TableOfContent now accepts Handle, not Runtime (#2096)" (#2191)
    
    This reverts commit fd87ca2c6d130781b766522c7c78e66125928cdb.

diff --git a/src/main.rs b/src/main.rs
index 2e1354362..2d24d20dd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -16,7 +16,7 @@ use std::io::Error;
 use std::sync::Arc;
 use std::thread;
 use std::thread::JoinHandle;
-use std::time::{Duration, Instant};
+use std::time::Duration;
 
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
@@ -212,9 +212,9 @@ fn main() -> anyhow::Result<()> {
     // It is a main entry point for the storage.
     let toc = TableOfContent::new(
         &settings.storage,
-        search_runtime.handle().clone(),
-        update_runtime.handle().clone(),
-        general_runtime.handle().clone(),
+        search_runtime,
+        update_runtime,
+        general_runtime,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),
@@ -262,7 +262,7 @@ fn main() -> anyhow::Result<()> {
 
         // Runs raft consensus in a separate thread.
         // Create a pipe `message_sender` to communicate with the consensus
-        let (grpc_handle, consensus_handle) = Consensus::run(
+        let handle = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
             args.bootstrap,
@@ -276,8 +276,7 @@ fn main() -> anyhow::Result<()> {
         )
         .expect("Can't initialize consensus");
 
-        handles.push(grpc_handle);
-        handles.push(consensus_handle);
+        handles.push(handle);
 
         let toc_arc_clone = toc_arc.clone();
         let consensus_state_clone = consensus_state.clone();
@@ -440,34 +439,7 @@ fn main() -> anyhow::Result<()> {
         );
         handle.join().expect("thread is not panicking")?;
     }
-    drop(search_runtime);
-    drop(update_runtime);
-    drop(general_runtime);
+    drop(toc_arc);
     drop(settings);
-    if let Ok(toc) = wait_unwrap(toc_arc, Duration::from_secs(30)) {
-        drop(toc);
-    }
     Ok(())
 }
-
-/// Blocks current thread for up to specified amount of time to become the single referent
-/// of an [`Arc`] and returns it.
-///
-/// This methods move a value out from an [`Arc`] when there is only one reference left
-/// and it is safe to do so. `Err()` is returned if an [`Arc`] still has more than 1 reference
-/// after given duration is passed.
-fn wait_unwrap<T>(mut input: Arc<T>, duration: Duration) -> Result<T, ()> {
-    let start_time = Instant::now();
-    while start_time.elapsed() < duration {
-        match Arc::try_unwrap(input) {
-            Ok(input) => {
-                return Ok(input);
-            }
-            Err(new_input) => {
-                input = new_input;
-                thread::sleep_ms(100);
-            }
-        }
-    }
-    Err(())
-}

commit 8749bf19741cefc30ccaf13c81ba2ec33866eb8c
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Jul 5 15:26:21 2023 +0200

    Use configured temporary directory for recovering snapshots (#2157)
    
    * Use configured temporary directory for recovering snapshots
    
    * Replace qualified std::fs path with use
    
    * Remove UUID from temporary snapshot path

diff --git a/src/main.rs b/src/main.rs
index 2d24d20dd..ef38fb170 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -142,8 +142,11 @@ fn main() -> anyhow::Result<()> {
 
     let is_distributed_deployment = settings.cluster.enabled;
 
+    let temp_path = settings.storage.temp_path.as_deref();
+
     let restored_collections = if let Some(full_snapshot) = args.storage_snapshot {
         recover_full_snapshot(
+            temp_path,
             &full_snapshot,
             &settings.storage.storage_path,
             args.force_snapshot,
@@ -155,6 +158,7 @@ fn main() -> anyhow::Result<()> {
         recover_snapshots(
             &snapshots,
             args.force_snapshot,
+            temp_path,
             &settings.storage.storage_path,
             persistent_consensus_state.this_peer_id(),
             is_distributed_deployment,

commit 3839e75081fd22f607b83df70b580c3af8d6cdde
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 2 12:46:26 2023 +0200

    do not initialize io-uring object if async scorer is not enabled (#2372)
    
    * do not initialize io-uring object if async scorer is not enabled
    
    * explicilty example async scorer in test
    
    * fmt

diff --git a/src/main.rs b/src/main.rs
index ef38fb170..3e9d20062 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -122,7 +122,7 @@ fn main() -> anyhow::Result<()> {
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     segment::madvise::set_global(settings.storage.mmap_advice);
-    segment::vector_storage::raw_scorer::set_async_scorer(settings.storage.async_scorer);
+    segment::vector_storage::common::set_async_scorer(settings.storage.async_scorer);
 
     welcome(&settings);
 

commit 087dfa59d82e950d385ab6d0ab6f0a3f0474f7b8
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Aug 15 18:44:44 2023 +0200

    `tracing` improvements (#2187)
    
    * Add optional `tracing` crate dependency to all `lib/*` sub-crates
    
    * Add optional alternative "tracing-logger"...
    
    ...that works a bit better with logs produced by the `tracing` crate
    
    * Make `tracing-logger` reuse `log_level` config parameter (and `QDRANT__LOG_LEVEL` env-var)...
    
    ...instead of default `RUST_LOG` env-var only
    
    * Replace `env_logger` with `tracing` (#2381)
    
    * Replace `env_logger` with `tracing`/`tracing-subscriber`/`tracing-log`
    
    TODO:
    - Implement slog drain that would *properly* convert slog records into tracing events
      (`slog-stdlog` is fine for now, though)
    
    * fixup! Replace `env_logger` with `tracing`/`tracing-subscriber`/`tracing-log`
    
    Fix `consensus` test
    
    * fixup! fixup! Replace `env_logger` with `tracing`/`tracing-subscriber`/`tracing-log`
    
    Forget to `unwrap` the result 🙈
    
    * fixup! fixup! Replace `env_logger` with `tracing`/`tracing-subscriber`/`tracing-log`
    
    `tracing_subscriber::fmt::init` initializes `tracing_log::LogTracer`
    automatically with default `tracing-subscriber` features enabled 💁‍♀️
    
    * Update `DEVELOPMENT.md` documentation regarding `tracing`
    
    * Update default log level for development to make it less noisy
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Implement "intelligent" default log-level filtering
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/main.rs b/src/main.rs
index 3e9d20062..9af86202b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -43,7 +43,7 @@ use crate::greeting::welcome;
 use crate::migrations::single_to_cluster::handle_existing_collections;
 use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
-use crate::startup::{remove_started_file_indicator, setup_logger, touch_started_file_indicator};
+use crate::startup::{remove_started_file_indicator, touch_started_file_indicator};
 
 #[cfg(not(target_env = "msvc"))]
 #[global_allocator]
@@ -107,8 +107,6 @@ struct Args {
 }
 
 fn main() -> anyhow::Result<()> {
-    tracing::setup()?;
-
     remove_started_file_indicator();
 
     let args = Args::parse();
@@ -118,7 +116,8 @@ fn main() -> anyhow::Result<()> {
 
     let reporting_id = TelemetryCollector::generate_id();
 
-    setup_logger(&settings.log_level);
+    tracing::setup(&settings.log_level)?;
+
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     segment::madvise::set_global(settings.storage.mmap_advice);

commit 8a974630d2d9f9af2eea101598b6082c5de72d9b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Aug 17 13:50:34 2023 +0200

    Stacktrace API (#2457)
    
    * enable /stacktrace API in docker builds
    
    * fmt
    
    * fix ci

diff --git a/src/main.rs b/src/main.rs
index 9af86202b..965ebffc8 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -104,12 +104,26 @@ struct Args {
     /// Read more: <https://qdrant.tech/documentation/guides/telemetry>
     #[arg(long, action, default_value_t = false)]
     disable_telemetry: bool,
+
+    /// Run stacktrace collector. Used for debugging.
+    #[arg(long, action, default_value_t = false)]
+    stacktrace: bool,
 }
 
 fn main() -> anyhow::Result<()> {
+    let args = Args::parse();
+
+    // Run backtrace collector, expected to used by `rstack` crate
+    if args.stacktrace {
+        #[cfg(feature = "stacktrace")]
+        {
+            let _ = rstack_self::child();
+        }
+        return Ok(());
+    }
+
     remove_started_file_indicator();
 
-    let args = Args::parse();
     let settings = Settings::new(args.config_path)?;
 
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;

commit 55f4acdca831f1bb7f7aef8b70ea1eecda0b453a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Aug 31 11:32:29 2023 +0200

    directories cleanup + refactoring (#2536)

diff --git a/src/main.rs b/src/main.rs
index 965ebffc8..e08d57dfb 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -237,6 +237,8 @@ fn main() -> anyhow::Result<()> {
         propose_operation_sender.clone(),
     );
 
+    toc.clear_all_tmp_directories()?;
+
     // Here we load all stored collections.
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {

commit e16b3634f8623e4c33eb9e0d6fec7816518d8973
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Sep 1 05:40:08 2023 -0400

    add target_os flag for rstack-self dependency (#2555)

diff --git a/src/main.rs b/src/main.rs
index e08d57dfb..9fd07df59 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -115,7 +115,7 @@ fn main() -> anyhow::Result<()> {
 
     // Run backtrace collector, expected to used by `rstack` crate
     if args.stacktrace {
-        #[cfg(feature = "stacktrace")]
+        #[cfg(all(target_os = "linux", feature = "stacktrace"))]
         {
             let _ = rstack_self::child();
         }

commit abd0d57d5d73e5530f5f356a86c7c4b478be9561
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 25 11:30:50 2023 +0200

    Introduce Memory common module (#2712)
    
    * Introduce Memory common module
    
    * fix Windaube build
    
    * move mmap_ops as well

diff --git a/src/main.rs b/src/main.rs
index 9fd07df59..01f7abb41 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -134,7 +134,7 @@ fn main() -> anyhow::Result<()> {
 
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
-    segment::madvise::set_global(settings.storage.mmap_advice);
+    memory::madvise::set_global(settings.storage.mmap_advice);
     segment::vector_storage::common::set_async_scorer(settings.storage.async_scorer);
 
     welcome(&settings);

commit 0f9a42ef53bed4ef3ba4486fb3f0799c5ae1070b
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Oct 4 14:45:15 2023 +0200

    Change local shard stuck in Initializing to Active on load (#2759)
    
    * Change local shard stuck in Initializing to Active on load
    
    * Add test for changing local initializing shard to active on load
    
    * Spelling fix
    
    * Remove function that is too specialized
    
    * Reuse variable for settings distributed parameter
    
    * Only set shard state from init to active on load if not distributed

diff --git a/src/main.rs b/src/main.rs
index 01f7abb41..d8b314a28 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -208,7 +208,7 @@ fn main() -> anyhow::Result<()> {
     // It allocates required number of channels and manages proper reconnection handling
     let mut channel_service = ChannelService::default();
 
-    if settings.cluster.enabled {
+    if is_distributed_deployment {
         // We only need channel_service in case if cluster is enabled.
         // So we initialize it with real values here
         let p2p_grpc_timeout = Duration::from_millis(settings.cluster.grpc_timeout_ms);
@@ -256,7 +256,7 @@ fn main() -> anyhow::Result<()> {
     // It decides if query should go directly to the ToC or through the consensus.
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
 
-    let (telemetry_collector, dispatcher_arc) = if settings.cluster.enabled {
+    let (telemetry_collector, dispatcher_arc) = if is_distributed_deployment {
         let consensus_state: ConsensusStateRef = ConsensusManager::new(
             persistent_consensus_state,
             toc_arc.clone(),

commit 5bdf5e4bfe5ca2de32aff603a755ad263d5eca56
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Oct 30 12:44:39 2023 +0100

    Shard snapshot transfer integration (#2467)
    
    * Clone inside blocks
    
    * Add shard transfer method to distinguish between batching and snapshots
    
    * Add stub method to drive snapshot transfer
    
    * Store remote shard in forward proxy, merge unproxy methods
    
    * On snapshot shard transfer, create a shard snapshot
    
    * Unify logic for unproxifying forward and queue proxy
    
    * Error snapshot transfer if shard is not a queue proxy
    
    * Add remote shard function to request remote HTTP port
    
    * Handle all specific shard types when proxifying
    
    * Allow queue proxy for some shard holder snapshot methods
    
    * Bring local and remote shard snapshot transfer URLs into transfer logic
    
    * Expose optional shard transfer method parameter in REST and gRPC API
    
    * Expose shard transfer method in list of active transfers
    
    * Fix off-by-one error in queue proxy shard batch transfer logic
    
    * Do not set max ack version for WAL twice, already set when finalizing
    
    * Merge comment for two similar calls
    
    * Use reqwest client to transfer and recover shard snapshot on remote
    
    Using the reqwest client should be temporary. We better switch to a gRPC
    call here eventually to use our existing channels. That way we don't
    require an extra HTTP client (and dependency) just for this.
    
    * Send queue proxy updates to remote when shard is transferred
    
    * On shard queue transfer, set max WAL ack to last transferred
    
    * Add safe queue proxy destructor, skip destructing in error
    
    This adds a finalize method to safely destruct a queue proxy shard. It
    ensures that all remaining updates are transferred to the remote, and
    that the max acknowledged version for our WAL is released. Only then is
    the queue proxy shard destructed unwrapping the inner local shard.
    
    Our unproxify logic now ensures that the queue proxy shard remains if
    transferring the updates fails.
    
    * Clean up method driving shard snapshot transfer a bit
    
    * Change default shard transfer method to stream records
    
    This changes the default transfer method to stream records rather than
    using a snaphsot transfer. We can switch this once snapshot transfer is
    fully integrated.
    
    * Improve error handling, don't panic but return proper error
    
    * Do not unwrap in type conversions
    
    * Update OpenAPI and gRPC specification
    
    * Resolve and remove some TODOs
    
    * During shard snapshot transfer, use REST port from config
    
    * Always release max acknowledged WAL version on queue proxy finalize
    
    * Rework queue unproxying, transform into forward proxy to handle errors
    
    When a queue or forward proxy shard needs to be unproxified into a local
    shard again we typically don't have room to handle errors. A queue proxy
    shard may error if it fails to send updates to the remote shard, while a
    forward proxy does not fail at all when transforming.
    
    We now transfer queued updates before a shard is unproxified. This
    allows for proper error handling. After everything is transferred the
    shard is transformed into a forward proxy which can eventually be safely
    unproxified later.
    
    * Add trace logging for transferring queue proxy updates in batch
    
    * Simplify snapshot method conversion from gRPC
    
    * Remove remote shard parameter
    
    * Add safe guard to queue proxy handler, panic in debug if not finalized
    
    * Improve safety and architecture of queue proxy shard
    
    Switch from an explicit finalized flag to an outer-inner architecture.
    This improves the interface and robustness of the type.
    
    * Do not panic on drop if already unwinding
    
    * Make REST port interface in channel service for local node explicitly
    
    * Recover shard on remote over gRPC, remove reqwest client
    
    * Use shard transfer priority for shard snapshot recovery
    
    * Remove obsolete comment
    
    * Simplify qualified path with use
    
    * Don't construct URLs ourselves as a string, use `parse` and `set_port`
    
    * Use `set_path` when building shard download URL
    
    * Fix error handling in queue to forward proxy transformation
    
    Before, we didn't handle finalization errors properly. If this failed,
    tie shard would be lost.  With this change the queue proxy shard is put
    back.
    
    * Set default shard transfer method to stream records, eliminate panics
    
    * Fix shard snapshot transfer not correctly aborting due to queue proxy
    
    When a shard transfer fails (for any reason), the transfer is aborted.
    If we still have a queue proxy shard it should also be reverted, and
    collected updates should be forgotten. Before this change it would try
    to send all collected updates to the remote, even if the transfer
    failed.
    
    * Review fixes
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * Review fixes
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * Initiate forward and queue proxy shard in specialized transfer methods
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * Add consensus interface to shard transfer, repurpose dispatcher (#2873)
    
    * Add shard transfer consensus interface
    
    * Integrate shard transfer consensus interface into toc and transfer logic
    
    * Repurpose dispatcher for getting consensus into shard transfer
    
    * Derive clone
    
    * Mark consensus as unused for now
    
    * Use custom dispatcher with weak ref to prevent Arc cycle for ToC
    
    * Add comment on why a weak reference is used
    
    * Do exhaustive match in shard unproxy logic
    
    * Restructure match statement, use match if
    
    * When queue proxifying shard, allow forward proxy state if same remote
    
    * Before retrying a shard transfer after error, destruct queue proxy
    
    * Synchronize consensus across all nodes for shard snapshot transfer (#2874)
    
    * Move await consensus commit functions into channel service
    
    * Add shard consensus method to synchronize consensus across all nodes
    
    * Move transfer config, channels and local address into snapshot transfer
    
    * Await other nodes to reach consensus before finalizing shard transfer
    
    * Do not fail right away awaiting consensus if still on older term
    
    Instead, give the node time to reach the same term.
    
    * Fix `await_commit_on_all_peers` not catching peer errors properly
    
    * Change return type of `wait_for_consensus_commit` to `Result`
    
    This is of course more conventional, and automatically sets `must_use`.
    
    * Explicitly note number of peers when awaiting consensus
    
    * Before consensus sync, wait for local shard to reach partial state
    
    * Fix timeout error handling when waiting for replica set state
    
    * Wait for replica set to have remote in partial state instead
    
    * Set `(Partial)Snapshot` states for shard snapshot transfer through consensus (#2881)
    
    * When doing a shard snapshot transfer, set shard to `PartialSnapshot`
    
    * Add shard transfer method to set shard state to partial
    
    It currently uses a naive implementation. Using a custom consensus
    operation to also confirm a transfer is still active will be implemented
    later.
    
    * Add consensus snapshot transfer operation to change shard to partial
    
    The operation `ShardTransferOperations::SnapshotRecovered` is called
    after the shard snapshot is recovered on the remote and it progresses
    the transfer further.
    
    The operation sets the shard state from `PartialSnapshot` to `Partial`
    and ensures the transfer is still active.
    
    * Confirm consensus put shard into partial state, retry 3 times
    
    * Get replica set once
    
    * Add extensive shard snapshot transfer process docs, clean up function
    
    * Fix typo
    
    * Review suggestion
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * Add delay between consensus confirmation retries
    
    * Rename retry timeout to retry delay
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * On replicate shard, remember specified method
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>

diff --git a/src/main.rs b/src/main.rs
index d8b314a28..d2d4efe34 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -28,6 +28,7 @@ use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusStateRef};
+use storage::content_manager::toc::transfer::ShardTransferDispatcher;
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 #[cfg(not(target_env = "msvc"))]
@@ -206,7 +207,7 @@ fn main() -> anyhow::Result<()> {
 
     // Channel service is used to manage connections between peers.
     // It allocates required number of channels and manages proper reconnection handling
-    let mut channel_service = ChannelService::default();
+    let mut channel_service = ChannelService::new(settings.service.http_port);
 
     if is_distributed_deployment {
         // We only need channel_service in case if cluster is enabled.
@@ -268,6 +269,10 @@ fn main() -> anyhow::Result<()> {
 
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
 
+        let shard_transfer_dispatcher =
+            ShardTransferDispatcher::new(Arc::downgrade(&toc_arc), consensus_state.clone());
+        toc_arc.with_shard_transfer_dispatcher(shard_transfer_dispatcher);
+
         let dispatcher_arc = Arc::new(dispatcher);
 
         // Monitoring and telemetry.

commit 293745fa767536ac4ff6302b60459692fabe2b2c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Nov 24 11:40:09 2023 +0100

    spare one extra worker by replacing spawn with block_on (#3086)

diff --git a/src/main.rs b/src/main.rs
index d2d4efe34..2294edadb 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -327,7 +327,7 @@ fn main() -> anyhow::Result<()> {
         };
 
         if !collections_to_recover_in_consensus.is_empty() {
-            runtime_handle.spawn(handle_existing_collections(
+            runtime_handle.block_on(handle_existing_collections(
                 toc_arc.clone(),
                 consensus_state.clone(),
                 dispatcher_arc.clone(),

commit cb46a73609aaa79d2d8bb1b6389778740d3f1935
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Dec 5 17:59:46 2023 +0100

    Extend `/readyz` with shards readiness check (#3053, #3084)
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/main.rs b/src/main.rs
index 2294edadb..411ca196c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -257,7 +257,7 @@ fn main() -> anyhow::Result<()> {
     // It decides if query should go directly to the ToC or through the consensus.
     let mut dispatcher = Dispatcher::new(toc_arc.clone());
 
-    let (telemetry_collector, dispatcher_arc) = if is_distributed_deployment {
+    let (telemetry_collector, dispatcher_arc, health_checker) = if is_distributed_deployment {
         let consensus_state: ConsensusStateRef = ConsensusManager::new(
             persistent_consensus_state,
             toc_arc.clone(),
@@ -286,6 +286,12 @@ fn main() -> anyhow::Result<()> {
 
         // Runs raft consensus in a separate thread.
         // Create a pipe `message_sender` to communicate with the consensus
+        let health_checker = Arc::new(common::health::HealthChecker::spawn(
+            toc_arc.clone(),
+            consensus_state.clone(),
+            runtime_handle.clone(),
+        ));
+
         let handle = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
@@ -336,7 +342,7 @@ fn main() -> anyhow::Result<()> {
             ));
         }
 
-        (telemetry_collector, dispatcher_arc)
+        (telemetry_collector, dispatcher_arc, Some(health_checker))
     } else {
         log::info!("Distributed mode disabled");
         let dispatcher_arc = Arc::new(dispatcher);
@@ -344,7 +350,7 @@ fn main() -> anyhow::Result<()> {
         // Monitoring and telemetry.
         let telemetry_collector =
             TelemetryCollector::new(settings.clone(), dispatcher_arc.clone(), reporting_id);
-        (telemetry_collector, dispatcher_arc)
+        (telemetry_collector, dispatcher_arc, None)
     };
 
     let tonic_telemetry_collector = telemetry_collector.tonic_telemetry_collector.clone();
@@ -386,7 +392,12 @@ fn main() -> anyhow::Result<()> {
             .spawn(move || {
                 log_err_if_any(
                     "REST",
-                    actix::init(dispatcher_arc.clone(), telemetry_collector, settings),
+                    actix::init(
+                        dispatcher_arc.clone(),
+                        telemetry_collector,
+                        health_checker,
+                        settings,
+                    ),
                 )
             })
             .unwrap();

commit 19514265330ac9a1049b9439517deb104a5a19ed
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Jan 31 11:56:34 2024 +0100

    Dynamic CPU saturation internals (#3364)
    
    * Move CPU count function to common, fix wrong CPU count in visited list
    
    * Change default number of rayon threads to 8
    
    * Use CPU budget and CPU permits for optimizer tasks to limit utilization
    
    * Respect configured thread limits, use new sane defaults in config
    
    * Fix spelling issues
    
    * Fix test compilation error
    
    * Improve breaking if there is no CPU budget
    
    * Block optimizations until CPU budget, fix potentially getting stuck
    
    Our optimization worker now blocks until CPU budget is available to
    perform the task.
    
    Fix potential issue where optimization worker could get stuck. This
    would happen if no optimization task is started because there's no
    available CPU budget. This ensures the worker is woken up again to
    retry.
    
    * Utilize n-1 CPUs with optimization tasks
    
    * Better handle situations where CPU budget is drained
    
    * Dynamically scale rayon CPU count based on CPU size
    
    * Fix incorrect default for max_indexing_threads conversion
    
    * Respect max_indexing_threads for collection
    
    * Make max_indexing_threads optional, use none to set no limit
    
    * Update property documentation and comments
    
    * Property max_optimization_threads is per shard, not per collection
    
    * If we reached shard optimization limit, skip further checks
    
    * Add remaining TODOs
    
    * Fix spelling mistake
    
    * Align gRPC comment blocks
    
    * Fix compilation errors since last rebase
    
    * Make tests aware of CPU budget
    
    * Use new CPU budget calculation function everywhere
    
    * Make CPU budget configurable in settings, move static budget to common
    
    * Do not use static CPU budget, instance it and pass it through
    
    * Update CPU budget description
    
    * Move heuristic into defaults
    
    * Fix spelling issues
    
    * Move cpu_budget property to a better place
    
    * Move some things around
    
    * Minor review improvements
    
    * Use range match statement for CPU count heuristics
    
    * Systems with 1 or 2 CPUs do not keep cores unallocated by default
    
    * Fix compilation errors since last rebase
    
    * Update lib/segment/src/types.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * Update lib/storage/src/content_manager/toc/transfer.rs
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * Rename cpu_budget to optimizer_cpu_budget
    
    * Update OpenAPI specification
    
    * Require at least half of the desired CPUs for optimizers
    
    This prevents running optimizations with just one CPU, which could be
    very slow.
    
    * Don't use wildcard in CPU heuristic match statements
    
    * Rename cpu_budget setting to optimizer_cpu_budget
    
    * Update CPU budget comments
    
    * Spell acquire correctly
    
    * Change if-else into match
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    
    * Rename max_rayon_threads to num_rayon_threads, add explanation
    
    * Explain limit in update handler
    
    * Remove numbers for automatic selection of indexing threads
    
    * Inline max_workers variable
    
    * Remove CPU budget from ShardTransferConsensus trait, it is in collection
    
    * small allow(dead_code) => cfg(test)
    
    * Remove now obsolete lazy_static
    
    * Fix incorrect CPU calculation in CPU saturation test
    
    * Make waiting for CPU budget async, don't block current thread
    
    * Prevent deadlock on optimizer signal channel
    
    Do not block the optimization worker task anymore to wait for CPU budget
    to be available. That prevents our optimizer signal channel from being
    drained, blocking incoming updates because the cannot send another
    optimizer signal. Now, prevent blocking this task all together and
    retrigger the optimizers separately when CPU budget is available again.
    
    * Fix incorrect CPU calculation in optimization cancel test
    
    * Rename CPU budget wait function to notify
    
    * Detach API changes from CPU saturation internals
    
    This allows us to merge into a patch version of Qdrant. We can
    reintroduce the API changes in the upcoming minor release to make all of
    it fully functional.
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/src/main.rs b/src/main.rs
index 411ca196c..e656a661e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -18,6 +18,7 @@ use std::thread;
 use std::thread::JoinHandle;
 use std::time::Duration;
 
+use ::common::cpu::{get_cpu_budget, CpuBudget};
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
@@ -194,6 +195,11 @@ fn main() -> anyhow::Result<()> {
         create_general_purpose_runtime().expect("Can't optimizer general purpose runtime.");
     let runtime_handle = general_runtime.handle().clone();
 
+    // Use global CPU budget for optimizations based on settings
+    let optimizer_cpu_budget = CpuBudget::new(get_cpu_budget(
+        settings.storage.performance.optimizer_cpu_budget,
+    ));
+
     // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
 
@@ -233,6 +239,7 @@ fn main() -> anyhow::Result<()> {
         search_runtime,
         update_runtime,
         general_runtime,
+        optimizer_cpu_budget,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),

commit 8d1fd9419e01070c96cafd2418096ca0b09cbb9f
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Mar 4 16:48:44 2024 +0100

    Add peer metadata to consensus, tracking Qdrant versions (#3702)
    
    * Add peer metadata state to consensus, update on sync local state
    
    * Minor formatting improvements
    
    * Use Qdrant version from constant
    
    * Initialize empty metadata if not present on disk
    
    * Refactor old parameter name
    
    * Logging improvements based on review feedback
    
    * Assert that Qdrant version matches crate version
    
    * Do not use a custom (de)serializer for peer metadata
    
    * Use semver directly for handling Qdrant versions
    
    * Rename is_outdated to is_different_version
    
    * Assert Qdrant version in build.rs
    
    * Disable updating peer metadata until Qdrant 1.9
    
    We do this, because if a node is running 1.8, there may still be nodes
    running 1.7. Those nodes do not support this operation.
    
    * clippy
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index e656a661e..40dc59e06 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -250,7 +250,7 @@ fn main() -> anyhow::Result<()> {
     // Here we load all stored collections.
     runtime_handle.block_on(async {
         for collection in toc.all_collections().await {
-            log::debug!("Loaded collection: {}", collection);
+            log::debug!("Loaded collection: {collection}");
         }
     });
 

commit d4c7bbf18ffc3cb6bc31deaa922c14d70ee1bc3b
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Mar 13 21:10:29 2024 +0100

    Try to make `/readyz` check more reliable (#3776)
    
    * Try to make `/readyz` check a bit more reliable
    
    * Explicitly wait until node joined the cluster for the first time in `/readyz`
    
    * a bit more comment
    
    * fmt
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index 40dc59e06..903c0501a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -297,6 +297,8 @@ fn main() -> anyhow::Result<()> {
             toc_arc.clone(),
             consensus_state.clone(),
             runtime_handle.clone(),
+            // NOTE: `wait_for_bootstrap` should be calculated *before* starting `Consensus` thread
+            consensus_state.is_new_deployment() && args.bootstrap.is_some(),
         ));
 
         let handle = Consensus::run(

commit 0368ce57342d8fc8e7506542bf17aadc0e02fe16
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Mar 19 17:08:49 2024 +0100

    Use WAL delta transfer by default for shard recovery for 1.9 (#3800)
    
    * Move peer metadata type around
    
    * Expose peer metadata in channel service
    
    * Use WAL delta transfer by default for recovery, if all nodes are 1.8+
    
    * Add check for missing metadata, assume versionless if we have less
    
    * Use user configured shard transfer method, fall back to WAL delta/stream
    
    * Minor improvements
    
    * Update variable name

diff --git a/src/main.rs b/src/main.rs
index 903c0501a..e27a6db08 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -230,6 +230,7 @@ fn main() -> anyhow::Result<()> {
             tls_config,
         ));
         channel_service.id_to_address = persistent_consensus_state.peer_address_by_id.clone();
+        channel_service.id_to_metadata = persistent_consensus_state.peer_metadata_by_id.clone();
     }
 
     // Table of content manages the list of collections.

commit 2d6153f448f4b390472740bb53c13debb4c7dc34
Author: Abhishek Kumar Gupta <abhishekguptaatweb17@gmail.com>
Date:   Wed Apr 3 15:04:52 2024 +0530

    keep jemalloc dependency only for builds on aarch64 and amd64 platforms, fixes #2474 (#3945)
    
    * keep jemalloc dependency only for builds on aarch64 and amd64 platform, fixes #2474
    
    * dummy commit to trigger github actions
    
    * include jemalloc for powerpc64le linux platform also.
    
    * revert change: inclusion of jemalloc dependency for PowerPC linux platform
    
    * revert change: exclude jemalloc dependency for msvc platform

diff --git a/src/main.rs b/src/main.rs
index e27a6db08..e76950e2a 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,7 +32,10 @@ use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusSta
 use storage::content_manager::toc::transfer::ShardTransferDispatcher;
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
-#[cfg(not(target_env = "msvc"))]
+#[cfg(all(
+    not(target_env = "msvc"),
+    any(target_arch = "x86_64", target_arch = "aarch64")
+))]
 use tikv_jemallocator::Jemalloc;
 
 use crate::common::helpers::{
@@ -47,7 +50,10 @@ use crate::settings::Settings;
 use crate::snapshots::{recover_full_snapshot, recover_snapshots};
 use crate::startup::{remove_started_file_indicator, touch_started_file_indicator};
 
-#[cfg(not(target_env = "msvc"))]
+#[cfg(all(
+    not(target_env = "msvc"),
+    any(target_arch = "x86_64", target_arch = "aarch64")
+))]
 #[global_allocator]
 static GLOBAL: Jemalloc = Jemalloc;
 

commit 41c817c2a16f270dcab376e94b2ec0c5e7d8f149
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 4 10:52:59 2024 +0200

    Non-blocking snapshots (#3420)
    
    * Initial non-blocking snapshot implementation
    
    * Minor refactoring
    
    * Add some comments, improve log messages
    
    * Propagate proxy segment changes into wrapped segment when unproxying
    
    * Use upgradable read lock for propagating proxy segment changes
    
    * Extract proxy/unproxy functions for segments, better error handling
    
    * Don't stop early on error, always clean up proxied segments
    
    * Propagate proxy changes in two batches to minimize write locking
    
    * Use upgradable read lock when propagating proxy changes in two batches
    
    * Do not fall back to non-appendable segment configurations
    
    * Resolve remaining TODOs
    
    * Use LockedSegmentHolder type alias everywhere
    
    * Better state handling in method to proxy all segments
    
    * When proxying all segments, lock only after creating temporary segment
    
    * Pass actual proxied segments around to minimize segment holder locking
    
    * Propagate proxy segment changes to wrapped on drop, not to writable
    
    * Minor improvements
    
    * Fix proxy logic returning non-proxied segments
    
    * Share single segment holder lock and upgrade/downgrade it
    
    * Minor improvements
    
    * Make appendable segment check more efficient
    
    * Do not explicitly drop segments lock, it's not necessary
    
    * Add consensus test to assert data consistency while snapshotting
    
    * Fix incorrect documentation
    
    * Extract payload storage type decision logic to collection params function
    
    * Resolve TODO, we always expect to get a shard here
    
    * Only upgrade propagate to wrapped readers if lists are not empty
    
    * Set correct operation versions
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index e76950e2a..12e010133 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -103,7 +103,7 @@ struct Args {
     /// Path to an alternative configuration file.
     /// Format: <config_file_path>
     ///
-    /// Default path : config/config.yaml
+    /// Default path: config/config.yaml
     #[arg(long, value_name = "PATH")]
     config_path: Option<String>,
 

commit ae08d856b764cbe762047dbfdc318f2adfe85627
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Apr 8 22:19:43 2024 +0000

    RBAC: require access token in ToC functions (#3972)
    
    * claims -> access
    
    * Require access for Dispatcher::toc()
    
    * Require Access for various collection functions
    
    * review fixes
    
    * comment nit
    
    * Add periods to docsting
    
    * Disallow creating and deleting sharding keys for non-manage access
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/src/main.rs b/src/main.rs
index 12e010133..26c562943 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -32,6 +32,7 @@ use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusSta
 use storage::content_manager::toc::transfer::ShardTransferDispatcher;
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
+use storage::rbac::Access;
 #[cfg(all(
     not(target_env = "msvc"),
     any(target_arch = "x86_64", target_arch = "aarch64")
@@ -57,6 +58,8 @@ use crate::startup::{remove_started_file_indicator, touch_started_file_indicator
 #[global_allocator]
 static GLOBAL: Jemalloc = Jemalloc;
 
+const FULL_ACCESS: Access = Access::full("For main");
+
 /// Qdrant (read: quadrant ) is a vector similarity search engine.
 /// It provides a production-ready service with a convenient API to store, search, and manage points - vectors with an additional payload.
 ///
@@ -256,7 +259,7 @@ fn main() -> anyhow::Result<()> {
 
     // Here we load all stored collections.
     runtime_handle.block_on(async {
-        for collection in toc.all_collections().await {
+        for collection in toc.all_collections(&FULL_ACCESS).await {
             log::debug!("Loaded collection: {collection}");
         }
     });
@@ -342,8 +345,12 @@ fn main() -> anyhow::Result<()> {
         });
 
         let collections_to_recover_in_consensus = if is_new_deployment {
-            let existing_collections = runtime_handle.block_on(toc_arc.all_collections());
+            let existing_collections =
+                runtime_handle.block_on(toc_arc.all_collections(&FULL_ACCESS));
             existing_collections
+                .into_iter()
+                .map(|pass| pass.name().to_string())
+                .collect()
         } else {
             restored_collections
         };

commit fe1458dc2ee84a4ee56851ecd5eec6b03908ef3f
Author: Tim Visée <tim+github@visee.me>
Date:   Thu May 2 17:10:34 2024 +0200

    Add API key field to snapshot restore, fix snapshot recovery with API key (#4155)
    
    * Add API key to HTTP client
    
    * Add API key field to snapshot recovery requests
    
    * Add API key to channel service
    
    * Provide API key when doing snapshot transfer
    
    * Configure API key header name constant in a central place
    
    * Reformat
    
    * Update OpenAPI spec
    
    * Remove suffixed spaces from configuration file
    
    * Allow to specify HTTP headers in some consensus test utility functions
    
    * Add snapshot transfer test with configured API key
    
    * Use random API key in test
    
    * Fix compilation errors and clippy warnings

diff --git a/src/main.rs b/src/main.rs
index 26c562943..c576e83e3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -222,7 +222,8 @@ fn main() -> anyhow::Result<()> {
 
     // Channel service is used to manage connections between peers.
     // It allocates required number of channels and manages proper reconnection handling
-    let mut channel_service = ChannelService::new(settings.service.http_port);
+    let mut channel_service =
+        ChannelService::new(settings.service.http_port, settings.service.api_key.clone());
 
     if is_distributed_deployment {
         // We only need channel_service in case if cluster is enabled.

commit b9a1b466f3610a1101c7d67af222299754a71bbe
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu May 2 11:22:48 2024 -0400

    Issues API: Listen for issues events in main app (#4123)
    
    * listen for issues events in main app
    
    * don't setup subscribers if `issues` feature is disabled
    
    * Revert "don't setup subscribers if `issues` feature is disabled"
    
    This reverts commit 6754537dd51faa8ebc6f96d03f83b98f2c01c497.

diff --git a/src/main.rs b/src/main.rs
index c576e83e3..22d18ce0c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -5,6 +5,7 @@ mod actix;
 mod common;
 mod consensus;
 mod greeting;
+mod issues_setup;
 mod migrations;
 mod settings;
 mod snapshots;
@@ -394,6 +395,9 @@ fn main() -> anyhow::Result<()> {
         log::info!("Telemetry reporting disabled");
     }
 
+    // Setup subscribers to listen for issue-able events
+    issues_setup::setup_subscribers(dispatcher_arc.clone());
+
     // Helper to better log start errors
     let log_err_if_any = |server_name, result| match result {
         Err(err) => {

commit 2701cf1d1844e81024e390b045cf589c6b9ac7ff
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu May 9 09:39:01 2024 -0400

    Issues API: Unindexed fields (#4139)
    
    * submit an issue for unindexed field
    
    solve unindexed field issue when an index is created for the field
    
    also log a warning when issue is submitted
    
    fmt
    
    fix rebase problems
    
    get collection name without panicking
    
    better solving of issue
    
    remove outdated TODO
    
    add tests, fix GET /issues
    
    review fixes
    
    use `/` instead of `.` as separator
    
    fmt
    
    prepare extractor for time-based submission
    
    smol rename
    
    add check in search
    
    hook unindexed field creation in search and search_batch of rest
    
    update after rebase on `dev`
    
    remove submit from `struct_payload_index`
    
    solve issues inside of handlers, not in match router
    
    post-process at Collection level
    
    don't clone filters
    
    remove from openapi spec
    
    - Add hidden env variable to adjust slow search threshold
    - Remove Solution::None
    - Fix UnindexedField issue extractor
    - Add endpoint to openapi, but without response body spec
    - Move integration test to consensus_tests to set lower threshold
    
    * event-based integration
    
    * use typed Code
    
    * remove payload_index_schema hack, get through collection info
    
    * rename `notify` to `publish`
    
    * update after rebase
    
    * remove breakpoint
    
    * update after rebase
    
    * attach current payload schema to SlowQueryEvent
    
    * collect filters refs lazily
    
    * review fixes
    
    * review fixes
    
    * use regular config for setting the threshold, use 1.2 secs as default
    
    * fix checking against current schema for all conditions

diff --git a/src/main.rs b/src/main.rs
index 22d18ce0c..eb0fab123 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -396,7 +396,7 @@ fn main() -> anyhow::Result<()> {
     }
 
     // Setup subscribers to listen for issue-able events
-    issues_setup::setup_subscribers(dispatcher_arc.clone());
+    issues_setup::setup_subscribers(&settings);
 
     // Helper to better log start errors
     let log_err_if_any = |server_name, result| match result {

commit 53536bd688715d75c5163840a667626e3f6e5482
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon May 13 11:56:08 2024 +0200

    Add `/logger` HTTP endpoint to get/update logger config at runtime (#2507)
    
    * Move stuff around
    
    * Refactor logger configuration
    
    * Implement `/logger` HTTP endpoint to get/set logger config at runtime
    
    * review refactoring
    
    * fix test
    
    * rm unused
    
    * Move stuff around
    
    * Simplify `deseriailze_logger_config` test
    
    * Simplify `SpanEvents` methods and usage
    
    * Simplify `Color` serialization/deserialization format
    
    * Implement logger config diff update
    
    * Add some simple unit-tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index eb0fab123..ae26d89c3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -142,7 +142,11 @@ fn main() -> anyhow::Result<()> {
 
     let reporting_id = TelemetryCollector::generate_id();
 
-    tracing::setup(&settings.log_level)?;
+    let logger_handle = tracing::setup(
+        settings
+            .logger
+            .with_top_level_directive(settings.log_level.clone()),
+    )?;
 
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
@@ -425,6 +429,7 @@ fn main() -> anyhow::Result<()> {
                         telemetry_collector,
                         health_checker,
                         settings,
+                        logger_handle,
                     ),
                 )
             })

commit c0621cff54983cb422da66f635465d03681db79c
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Jun 12 17:11:09 2024 +0200

    Remove unecessary Clippy allows (#4456)

diff --git a/src/main.rs b/src/main.rs
index ae26d89c3..4dbc22a8f 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,3 @@
-#![allow(deprecated)]
-
 #[cfg(feature = "web")]
 mod actix;
 mod common;

commit 5111aa7d6cd20c085457408806d5aa03bf3a9a11
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Jul 17 17:02:16 2024 +0200

    Resume resharding driver on node restart (#4666)
    
    * Resume resharding driver on restart if resharding is active
    
    * Update resharding state comment started text
    
    Using since versus started. 'Since' better clarifies that the current
    state has been active since that time. While 'started at' could lead to
    confusion on whether that time is for starting the whole resharding
    operation or just that state.
    
    * Add resharding resumption test during migrating points
    
    * Recover resharding hash ring after loading shards
    
    * Update resharding resume test, interrupt at multiple stages, less points
    
    * Remove unused parameter
    
    * Update collection shard count at resharding shard creation/destruction
    
    * Apply suggestions from code review
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * Use debug_assert_eq
    
    * Remove trailing comma
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/src/main.rs b/src/main.rs
index 4dbc22a8f..bc76eb3d3 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -348,6 +348,10 @@ fn main() -> anyhow::Result<()> {
             }
         });
 
+        runtime_handle.block_on(async {
+            toc_arc.resume_resharding_tasks().await;
+        });
+
         let collections_to_recover_in_consensus = if is_new_deployment {
             let existing_collections =
                 runtime_handle.block_on(toc_arc.all_collections(&FULL_ACCESS));

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/src/main.rs b/src/main.rs
index bc76eb3d3..bf22ac6dc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -502,7 +502,7 @@ fn main() -> anyhow::Result<()> {
 
     touch_started_file_indicator();
 
-    for handle in handles.into_iter() {
+    for handle in handles {
         log::debug!(
             "Waiting for thread {} to finish",
             handle.thread().name().unwrap()

commit 9ab060b565b7101dcdc19a5e0dbed6b04b4cd55e
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Sep 11 11:11:05 2024 +0200

    Split operations into `update_all`/`update_existing` during resharding (#4928)
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index bf22ac6dc..8bb1ef291 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -348,9 +348,11 @@ fn main() -> anyhow::Result<()> {
             }
         });
 
-        runtime_handle.block_on(async {
-            toc_arc.resume_resharding_tasks().await;
-        });
+        // TODO(resharding): Remove resharding driver?
+        //
+        // runtime_handle.block_on(async {
+        //     toc_arc.resume_resharding_tasks().await;
+        // });
 
         let collections_to_recover_in_consensus = if is_new_deployment {
             let existing_collections =

commit 76e167a069bf98c3077f5a18fe315e5a197b9f9e
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Oct 8 13:03:59 2024 +0200

    Add wait parameter to cluster metadata API (#5174)
    
    * Add blocking implementation of update cluster metadata
    
    * Expose wait parameter to cluster metadata API
    
    * Refactor shard transfer dispatcher into toc dispatcher
    
    * Reformat

diff --git a/src/main.rs b/src/main.rs
index 8bb1ef291..5775f52f4 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -28,7 +28,7 @@ use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusStateRef};
-use storage::content_manager::toc::transfer::ShardTransferDispatcher;
+use storage::content_manager::toc::dispatcher::TocDispatcher;
 use storage::content_manager::toc::TableOfContent;
 use storage::dispatcher::Dispatcher;
 use storage::rbac::Access;
@@ -290,9 +290,8 @@ fn main() -> anyhow::Result<()> {
 
         dispatcher = dispatcher.with_consensus(consensus_state.clone());
 
-        let shard_transfer_dispatcher =
-            ShardTransferDispatcher::new(Arc::downgrade(&toc_arc), consensus_state.clone());
-        toc_arc.with_shard_transfer_dispatcher(shard_transfer_dispatcher);
+        let toc_dispatcher = TocDispatcher::new(Arc::downgrade(&toc_arc), consensus_state.clone());
+        toc_arc.with_toc_dispatcher(toc_dispatcher);
 
         let dispatcher_arc = Arc::new(dispatcher);
 

commit cf8f22fbe7ab7d708fb956e140f9f068c8c840d5
Author: n0x29a <15330763+n0x29a@users.noreply.github.com>
Date:   Wed Oct 16 19:37:38 2024 +0200

    Inference Service Integration (#5240)
    
    * Inference Service Integration
    
    * Update src/common/inference/service.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * Inference Service Integration
    
    * review fixes
    
    ---------
    
    Co-authored-by: n0x29a <n0x29a@example.com>
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index 5775f52f4..809ab5d77 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -42,6 +42,7 @@ use crate::common::helpers::{
     create_general_purpose_runtime, create_search_runtime, create_update_runtime,
     load_tls_client_config,
 };
+use crate::common::inference::service::InferenceService;
 use crate::common::telemetry::TelemetryCollector;
 use crate::common::telemetry_reporting::TelemetryReporter;
 use crate::greeting::welcome;
@@ -136,6 +137,13 @@ fn main() -> anyhow::Result<()> {
 
     let settings = Settings::new(args.config_path)?;
 
+    // Inference Service initialization
+    if let Some(inference_config) = settings.inference.clone() {
+        let _ = InferenceService::init(inference_config);
+    } else {
+        log::info!("Inference service is not configured.");
+    }
+
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 
     let reporting_id = TelemetryCollector::generate_id();

commit 62380a742adb2bca94415c66283429ee3fd5ab6a
Author: n0x29a <15330763+n0x29a@users.noreply.github.com>
Date:   Tue Oct 22 12:49:00 2024 +0200

    Inference Service, billing-id (#5287)
    
    * Inference Service, token
    
    ---------
    
    Co-authored-by: n0x29a <n0x29a@example.com>

diff --git a/src/main.rs b/src/main.rs
index 809ab5d77..f081f746c 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -137,13 +137,6 @@ fn main() -> anyhow::Result<()> {
 
     let settings = Settings::new(args.config_path)?;
 
-    // Inference Service initialization
-    if let Some(inference_config) = settings.inference.clone() {
-        let _ = InferenceService::init(inference_config);
-    } else {
-        log::info!("Inference service is not configured.");
-    }
-
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 
     let reporting_id = TelemetryCollector::generate_id();
@@ -422,6 +415,22 @@ fn main() -> anyhow::Result<()> {
         ok => ok,
     };
 
+    //
+    // Inference Service
+    //
+    if let Some(inference_config) = settings.inference.clone() {
+        match InferenceService::init(inference_config) {
+            Ok(_) => {
+                log::info!("Inference service is configured.");
+            }
+            Err(err) => {
+                log::error!("{err}");
+            }
+        }
+    } else {
+        log::info!("Inference service is not configured.");
+    }
+
     //
     // REST API server
     //

commit c71b008e694db517212544e0e822d40666c94e2e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Oct 29 11:48:28 2024 +0100

    Reinit consensus (#5265)
    
    * option to clear consensus state while preserving peer id
    
    * compact or clear consensus WAL on re-init
    
    * Add test on reinit
    
    * minor changes
    
    * more points check suggestion
    
    ---------
    
    Co-authored-by: tellet-q <elena.dubrovina@qdrant.com>

diff --git a/src/main.rs b/src/main.rs
index f081f746c..302b67b14 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -119,6 +119,17 @@ struct Args {
     /// Run stacktrace collector. Used for debugging.
     #[arg(long, action, default_value_t = false)]
     stacktrace: bool,
+
+    /// Reinit consensus state.
+    /// When enabled, the service will assume the consensus should be reinitialized.
+    /// The exact behavior depends on if this current node has bootstrap URI or not.
+    /// If it has - it'll remove current consensus state and consensus WAL (while keeping peer ID)
+    ///             and will try to receive state from the bootstrap peer.
+    /// If it doesn't have - it'll remove other peers from voters promote
+    ///             the current peer to the leader and the single member of the cluster.
+    ///             It'll also compact consensus WAL to force snapshot
+    #[arg(long, action, default_value_t = false)]
+    reinit: bool,
 }
 
 fn main() -> anyhow::Result<()> {
@@ -165,8 +176,11 @@ fn main() -> anyhow::Result<()> {
     settings.validate_and_warn();
 
     // Saved state of the consensus.
-    let persistent_consensus_state =
-        Persistent::load_or_init(&settings.storage.storage_path, args.bootstrap.is_none())?;
+    let persistent_consensus_state = Persistent::load_or_init(
+        &settings.storage.storage_path,
+        args.bootstrap.is_none(),
+        args.reinit,
+    )?;
 
     let is_distributed_deployment = settings.cluster.enabled;
 
@@ -326,6 +340,7 @@ fn main() -> anyhow::Result<()> {
             tonic_telemetry_collector,
             toc_arc.clone(),
             runtime_handle.clone(),
+            args.reinit,
         )
         .expect("Can't initialize consensus");
 

commit 097508d07d46794f8b880f2ac4f5a7b929a4e9fc
Author: n0x29a <15330763+n0x29a@users.noreply.github.com>
Date:   Mon Nov 4 14:19:37 2024 +0100

    Inference Service, query requests (batch processing) (#5329)
    
    * Inference Service, query requests (batch processing)
    
    ---------
    
    Co-authored-by: n0x29a <n0x29a@example.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index 302b67b14..dae2672bc 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -434,7 +434,7 @@ fn main() -> anyhow::Result<()> {
     // Inference Service
     //
     if let Some(inference_config) = settings.inference.clone() {
-        match InferenceService::init(inference_config) {
+        match InferenceService::init_global(inference_config) {
             Ok(_) => {
                 log::info!("Inference service is configured.");
             }

commit 98633cbd3fdd01ee3c486a3573ff27dc180e3b6d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 11 10:26:17 2024 +0100

    Use references for less cloning when possible (#5409)

diff --git a/src/main.rs b/src/main.rs
index dae2672bc..b8ae50d9f 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -324,7 +324,7 @@ fn main() -> anyhow::Result<()> {
         let health_checker = Arc::new(common::health::HealthChecker::spawn(
             toc_arc.clone(),
             consensus_state.clone(),
-            runtime_handle.clone(),
+            &runtime_handle,
             // NOTE: `wait_for_bootstrap` should be calculated *before* starting `Consensus` thread
             consensus_state.is_new_deployment() && args.bootstrap.is_some(),
         ));

commit 17bce6e4587900f52cfbac79e4575fb696c75985
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 12 12:31:03 2024 +0100

    Async fixes (#5426)
    
    * expose async in telemetry
    
    * move async scorer config to proper section (as it was documented)
    
    * temporary disable mmap prefault
    
    * rollback prefault_mmap_pages
    
    * upd openapi

diff --git a/src/main.rs b/src/main.rs
index b8ae50d9f..ba15e98bd 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -161,7 +161,13 @@ fn main() -> anyhow::Result<()> {
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     memory::madvise::set_global(settings.storage.mmap_advice);
-    segment::vector_storage::common::set_async_scorer(settings.storage.async_scorer);
+    segment::vector_storage::common::set_async_scorer(
+        settings
+            .storage
+            .performance
+            .async_scorer
+            .unwrap_or_default(),
+    );
 
     welcome(&settings);
 

commit e43b5987292503cab2eb73fe1b13b396fcae3367
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Nov 19 14:32:20 2024 +0100

    On start, don't just cancel outgoing but all related transfers (#5478)

diff --git a/src/main.rs b/src/main.rs
index ba15e98bd..fcc44a31b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -357,14 +357,14 @@ fn main() -> anyhow::Result<()> {
         let _cancel_transfer_handle = runtime_handle.spawn(async move {
             consensus_state_clone.is_leader_established.await_ready();
             match toc_arc_clone
-                .cancel_outgoing_all_transfers("Source peer restarted")
+                .cancel_related_transfers("Source or target peer restarted")
                 .await
             {
                 Ok(_) => {
                     log::debug!("All transfers if any cancelled");
                 }
                 Err(err) => {
-                    log::error!("Can't cancel outgoing transfers: {}", err);
+                    log::error!("Can't cancel related transfers: {err}");
                 }
             }
         });

commit 4f99e728aa0aff938211c6085050a0c803d61765
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Dec 5 00:58:49 2024 +0100

    GPU HNSW integration (#5535)
    
    * gpu hnsw
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/main.rs b/src/main.rs
index fcc44a31b..1282c31b6 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -171,6 +171,33 @@ fn main() -> anyhow::Result<()> {
 
     welcome(&settings);
 
+    #[cfg(feature = "gpu")]
+    if let Some(settings_gpu) = &settings.gpu {
+        use segment::index::hnsw_index::gpu::*;
+
+        // initialize GPU devices manager.
+        if settings_gpu.indexing {
+            set_gpu_force_half_precision(settings_gpu.force_half_precision);
+            set_gpu_groups_count(settings_gpu.groups_count);
+
+            let mut gpu_device_manager = GPU_DEVICES_MANAGER.write();
+            *gpu_device_manager = match gpu_devices_manager::GpuDevicesMaganer::new(
+                &settings_gpu.device_filter,
+                settings_gpu.devices.as_deref(),
+                settings_gpu.allow_integrated,
+                settings_gpu.allow_emulated,
+                true, // Currently we always wait for the free gpu device.
+                settings_gpu.parallel_indexes.unwrap_or(1),
+            ) {
+                Ok(gpu_device_manager) => Some(gpu_device_manager),
+                Err(err) => {
+                    log::error!("Can't initialize GPU devices manager: {err}");
+                    None
+                }
+            }
+        }
+    }
+
     if let Some(recovery_warning) = &settings.storage.recovery_mode {
         log::warn!("Qdrant is loaded in recovery mode: {}", recovery_warning);
         log::warn!(

commit 2191b792d4e74a8c8c83e14579359c492575a3af
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Jan 15 16:07:06 2025 +0100

    Add `resharding_enabled` option to `ClusterConfig` (#5770)
    
    * Add `resharding_enabled` option to `ClusterConfig`
    
    If `resharding_enabled` is *not* set, `StartResharding` API returns an error
    
    * Enable `resharding_enabled` option in development config
    
    * fixup! Add `resharding_enabled` option to `ClusterConfig`
    
    Fix tests
    
    * fixup! Enable `resharding_enabled` option in development config
    
    😅
    
    * fixup! Enable `resharding_enabled` option in development config
    
    🙄🙄🙄

diff --git a/src/main.rs b/src/main.rs
index 1282c31b6..d2869d1d5 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -336,7 +336,8 @@ fn main() -> anyhow::Result<()> {
         .into();
         let is_new_deployment = consensus_state.is_new_deployment();
 
-        dispatcher = dispatcher.with_consensus(consensus_state.clone());
+        dispatcher =
+            dispatcher.with_consensus(consensus_state.clone(), settings.cluster.resharding_enabled);
 
         let toc_dispatcher = TocDispatcher::new(Arc::downgrade(&toc_arc), consensus_state.clone());
         toc_arc.with_toc_dispatcher(toc_dispatcher);

commit d279de9f0ee62c22cf490a5cb014a28dee0eee21
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Jan 29 16:03:44 2025 +0100

    Allow to set peer and boostrap URI through environment variable (#5904)

diff --git a/src/main.rs b/src/main.rs
index d2869d1d5..46cf09322 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -69,7 +69,7 @@ const FULL_ACCESS: Access = Access::full("For main");
 struct Args {
     /// Uri of the peer to bootstrap from in case of multi-peer deployment.
     /// If not specified - this peer will be considered as a first in a new deployment.
-    #[arg(long, value_parser, value_name = "URI")]
+    #[arg(long, value_parser, value_name = "URI", env = "QDRANT_BOOTSTRAP")]
     bootstrap: Option<Uri>,
     /// Uri of this peer.
     /// Other peers should be able to reach it by this uri.
@@ -78,7 +78,7 @@ struct Args {
     ///
     /// In case this is not the first peer and it bootstraps the value is optional.
     /// If not supplied then qdrant will take internal grpc port from config and derive the IP address of this peer on bootstrap peer (receiving side)
-    #[arg(long, value_parser, value_name = "URI")]
+    #[arg(long, value_parser, value_name = "URI", env = "QDRANT_URI")]
     uri: Option<Uri>,
 
     /// Force snapshot re-creation

commit 361daad1c9ab241485b66eaad108e4405cc81b4c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 6 09:45:33 2025 +0100

    check if bootrap is the same as URI (#5950)

diff --git a/src/main.rs b/src/main.rs
index 46cf09322..fc9a43bd2 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -208,10 +208,17 @@ fn main() -> anyhow::Result<()> {
     // Validate as soon as possible, but we must initialize logging first
     settings.validate_and_warn();
 
+    let bootstrap = if args.bootstrap == args.uri {
+        log::warn!("Bootstrap URI is the same as this peer URI. Consider this peer as a first in a new deployment.");
+        None
+    } else {
+        args.bootstrap
+    };
+
     // Saved state of the consensus.
     let persistent_consensus_state = Persistent::load_or_init(
         &settings.storage.storage_path,
-        args.bootstrap.is_none(),
+        bootstrap.is_none(),
         args.reinit,
     )?;
 
@@ -360,13 +367,13 @@ fn main() -> anyhow::Result<()> {
             consensus_state.clone(),
             &runtime_handle,
             // NOTE: `wait_for_bootstrap` should be calculated *before* starting `Consensus` thread
-            consensus_state.is_new_deployment() && args.bootstrap.is_some(),
+            consensus_state.is_new_deployment() && bootstrap.is_some(),
         ));
 
         let handle = Consensus::run(
             &slog_logger,
             consensus_state.clone(),
-            args.bootstrap,
+            bootstrap,
             args.uri.map(|uri| uri.to_string()),
             settings.clone(),
             channel_service,

commit caed5729e5b7ff3db9dcb4531a4af0929b186682
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 09:05:00 2025 +0100

    IO resource usage permit (#6015)
    
    * rename cpu_budget -> resource_budget
    
    * clippy
    
    * add io budget to resources
    
    * fmt
    
    * move budget structures into a separate file
    
    * add extend permit function
    
    * dont extend existing permit
    
    * switch from IO to CPU permit
    
    * do not release resource before aquiring an extension
    
    * fmt
    
    * Review remarks
    
    * Improve resource permit number assertion
    
    * Make resource permit replace_with only acquire extra needed permits
    
    * Remove obsolete drop implementation
    
    * allocate IO budget same as CPU
    
    * review fixes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/main.rs b/src/main.rs
index fc9a43bd2..8e188f59e 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -17,7 +17,8 @@ use std::thread;
 use std::thread::JoinHandle;
 use std::time::Duration;
 
-use ::common::cpu::{get_cpu_budget, CpuBudget};
+use ::common::budget::{get_io_budget, ResourceBudget};
+use ::common::cpu::get_cpu_budget;
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
@@ -263,9 +264,9 @@ fn main() -> anyhow::Result<()> {
     let runtime_handle = general_runtime.handle().clone();
 
     // Use global CPU budget for optimizations based on settings
-    let optimizer_cpu_budget = CpuBudget::new(get_cpu_budget(
-        settings.storage.performance.optimizer_cpu_budget,
-    ));
+    let cpu_budget = get_cpu_budget(settings.storage.performance.optimizer_cpu_budget);
+    let io_budget = get_io_budget(settings.storage.performance.optimizer_io_budget, cpu_budget);
+    let optimizer_resource_budget = ResourceBudget::new(cpu_budget, io_budget);
 
     // Create a signal sender and receiver. It is used to communicate with the consensus thread.
     let (propose_sender, propose_receiver) = std::sync::mpsc::channel();
@@ -308,7 +309,7 @@ fn main() -> anyhow::Result<()> {
         search_runtime,
         update_runtime,
         general_runtime,
-        optimizer_cpu_budget,
+        optimizer_resource_budget,
         channel_service.clone(),
         persistent_consensus_state.this_peer_id(),
         propose_operation_sender.clone(),

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/src/main.rs b/src/main.rs
index 8e188f59e..721fa8a45 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -17,7 +17,7 @@ use std::thread;
 use std::thread::JoinHandle;
 use std::time::Duration;
 
-use ::common::budget::{get_io_budget, ResourceBudget};
+use ::common::budget::{ResourceBudget, get_io_budget};
 use ::common::cpu::get_cpu_budget;
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
@@ -29,8 +29,8 @@ use startup::setup_panic_hook;
 use storage::content_manager::consensus::operation_sender::OperationSender;
 use storage::content_manager::consensus::persistent::Persistent;
 use storage::content_manager::consensus_manager::{ConsensusManager, ConsensusStateRef};
-use storage::content_manager::toc::dispatcher::TocDispatcher;
 use storage::content_manager::toc::TableOfContent;
+use storage::content_manager::toc::dispatcher::TocDispatcher;
 use storage::dispatcher::Dispatcher;
 use storage::rbac::Access;
 #[cfg(all(
@@ -210,7 +210,9 @@ fn main() -> anyhow::Result<()> {
     settings.validate_and_warn();
 
     let bootstrap = if args.bootstrap == args.uri {
-        log::warn!("Bootstrap URI is the same as this peer URI. Consider this peer as a first in a new deployment.");
+        log::warn!(
+            "Bootstrap URI is the same as this peer URI. Consider this peer as a first in a new deployment.",
+        );
         None
     } else {
         args.bootstrap
@@ -550,27 +552,29 @@ fn main() -> anyhow::Result<()> {
 
         thread::Builder::new()
             .name("deadlock_checker".to_string())
-            .spawn(move || loop {
-                thread::sleep(DEADLOCK_CHECK_PERIOD);
-                let deadlocks = deadlock::check_deadlock();
-                if deadlocks.is_empty() {
-                    continue;
-                }
+            .spawn(move || {
+                loop {
+                    thread::sleep(DEADLOCK_CHECK_PERIOD);
+                    let deadlocks = deadlock::check_deadlock();
+                    if deadlocks.is_empty() {
+                        continue;
+                    }
 
-                let mut error = format!("{} deadlocks detected\n", deadlocks.len());
-                for (i, threads) in deadlocks.iter().enumerate() {
-                    writeln!(error, "Deadlock #{i}").expect("fail to writeln!");
-                    for t in threads {
-                        writeln!(
-                            error,
-                            "Thread Id {:#?}\n{:#?}",
-                            t.thread_id(),
-                            t.backtrace()
-                        )
-                        .expect("fail to writeln!");
+                    let mut error = format!("{} deadlocks detected\n", deadlocks.len());
+                    for (i, threads) in deadlocks.iter().enumerate() {
+                        writeln!(error, "Deadlock #{i}").expect("fail to writeln!");
+                        for t in threads {
+                            writeln!(
+                                error,
+                                "Thread Id {:#?}\n{:#?}",
+                                t.thread_id(),
+                                t.backtrace(),
+                            )
+                            .expect("fail to writeln!");
+                        }
                     }
+                    log::error!("{}", error);
                 }
-                log::error!("{}", error);
             })
             .unwrap();
     }

commit eec3328424b0de0b13740585ac5687da2893e714
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 26 09:19:52 2025 +0100

    remove warning about bootstrap URI if it is not provided (#6065)

diff --git a/src/main.rs b/src/main.rs
index 721fa8a45..3970747f0 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -210,9 +210,11 @@ fn main() -> anyhow::Result<()> {
     settings.validate_and_warn();
 
     let bootstrap = if args.bootstrap == args.uri {
-        log::warn!(
-            "Bootstrap URI is the same as this peer URI. Consider this peer as a first in a new deployment.",
-        );
+        if args.bootstrap.is_some() {
+            log::warn!(
+                "Bootstrap URI is the same as this peer URI. Consider this peer as a first in a new deployment.",
+            );
+        }
         None
     } else {
         args.bootstrap

commit 5fdc6c068e930bf71034fdc5ffce23bae4bfc2e1
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Mar 3 16:11:07 2025 +0100

    Fix logging for remove_started_file_indicator (#6090)

diff --git a/src/main.rs b/src/main.rs
index 3970747f0..addc54f9b 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -145,20 +145,21 @@ fn main() -> anyhow::Result<()> {
         return Ok(());
     }
 
-    remove_started_file_indicator();
-
     let settings = Settings::new(args.config_path)?;
 
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 
     let reporting_id = TelemetryCollector::generate_id();
 
+    // Setup logging (no logging before this point)
     let logger_handle = tracing::setup(
         settings
             .logger
             .with_top_level_directive(settings.log_level.clone()),
     )?;
 
+    remove_started_file_indicator();
+
     setup_panic_hook(reporting_enabled, reporting_id.to_string());
 
     memory::madvise::set_global(settings.storage.mmap_advice);

commit 754ef8c135aeb146524c98d6bc1e6c9c0d093cd3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Mar 13 17:42:44 2025 +0100

    Log hardware reporting enabled at startup (#6165)

diff --git a/src/main.rs b/src/main.rs
index addc54f9b..8aab986ba 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -465,6 +465,10 @@ fn main() -> anyhow::Result<()> {
         log::info!("Telemetry reporting disabled");
     }
 
+    if settings.service.hardware_reporting == Some(true) {
+        log::info!("Hardware reporting enabled");
+    }
+
     // Setup subscribers to listen for issue-able events
     issues_setup::setup_subscribers(&settings);
 

commit 01be51e2516c7d123fcd5f79374e1ecad35f2447
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Mar 19 11:15:40 2025 +0100

    Add global feature flags (#6194)
    
    * Add global feature flags structure, load on start
    
    * Feature flag use of new shard key format
    
    * Enable feature flag for new shard key format by default in dev builds
    
    * Prevent unwrapping everywhere; Single place for initialization (#6198)
    
    * Disable shard key feature flag by default for now, it causes problems
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/src/main.rs b/src/main.rs
index 8aab986ba..c26811e25 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -19,6 +19,7 @@ use std::time::Duration;
 
 use ::common::budget::{ResourceBudget, get_io_budget};
 use ::common::cpu::get_cpu_budget;
+use ::common::flags::init_feature_flags;
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
@@ -147,6 +148,9 @@ fn main() -> anyhow::Result<()> {
 
     let settings = Settings::new(args.config_path)?;
 
+    // Set global feature flags, sourced from configuration
+    init_feature_flags(&settings.feature_flags);
+
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 
     let reporting_id = TelemetryCollector::generate_id();

commit 41826145954a087d83e753e6bcdf624c22520128
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Mar 24 14:11:28 2025 +0100

    Add `all` feature flag, report enabled flags on start (#6228)
    
    * Add magic all flag, if set all features will be enabled
    
    * Report enabled feature flags on start, if any is enabled
    
    * Remove pub visibility from all, add comment it's only applied on init
    
    * Don't check all flag in is_empty

diff --git a/src/main.rs b/src/main.rs
index c26811e25..2676246cb 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -19,7 +19,7 @@ use std::time::Duration;
 
 use ::common::budget::{ResourceBudget, get_io_budget};
 use ::common::cpu::get_cpu_budget;
-use ::common::flags::init_feature_flags;
+use ::common::flags::{feature_flags, init_feature_flags};
 use ::tonic::transport::Uri;
 use api::grpc::transport_channel_pool::TransportChannelPool;
 use clap::Parser;
@@ -149,7 +149,7 @@ fn main() -> anyhow::Result<()> {
     let settings = Settings::new(args.config_path)?;
 
     // Set global feature flags, sourced from configuration
-    init_feature_flags(&settings.feature_flags);
+    init_feature_flags(settings.feature_flags);
 
     let reporting_enabled = !settings.telemetry_disabled && !args.disable_telemetry;
 
@@ -214,6 +214,12 @@ fn main() -> anyhow::Result<()> {
     // Validate as soon as possible, but we must initialize logging first
     settings.validate_and_warn();
 
+    // Report feature flags that are enabled for easier debugging
+    let flags = feature_flags();
+    if !flags.is_empty() {
+        log::debug!("Feature flags: {flags:?}");
+    }
+
     let bootstrap = if args.bootstrap == args.uri {
         if args.bootstrap.is_some() {
             log::warn!(

commit f230629fa0e62e069e683cce60e24319ab3cc84b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 25 10:08:21 2025 +0100

    build(deps): bump log from 0.4.26 to 0.4.27 (#6247)
    
    * build(deps): bump log from 0.4.26 to 0.4.27
    
    Bumps [log](https://github.com/rust-lang/log) from 0.4.26 to 0.4.27.
    - [Release notes](https://github.com/rust-lang/log/releases)
    - [Changelog](https://github.com/rust-lang/log/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/rust-lang/log/compare/0.4.26...0.4.27)
    
    ---
    updated-dependencies:
    - dependency-name: log
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * put variables inside the strings for log macros
    
    * also for pyroscope
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/src/main.rs b/src/main.rs
index 2676246cb..7cab425f1 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -205,7 +205,7 @@ fn main() -> anyhow::Result<()> {
     }
 
     if let Some(recovery_warning) = &settings.storage.recovery_mode {
-        log::warn!("Qdrant is loaded in recovery mode: {}", recovery_warning);
+        log::warn!("Qdrant is loaded in recovery mode: {recovery_warning}");
         log::warn!(
             "Read more: https://qdrant.tech/documentation/guides/administration/#recovery-mode"
         );
@@ -468,7 +468,7 @@ fn main() -> anyhow::Result<()> {
     let telemetry_collector = Arc::new(tokio::sync::Mutex::new(telemetry_collector));
 
     if reporting_enabled {
-        log::info!("Telemetry reporting enabled, id: {}", reporting_id);
+        log::info!("Telemetry reporting enabled, id: {reporting_id}");
 
         runtime_handle.spawn(TelemetryReporter::run(telemetry_collector.clone()));
     } else {
@@ -485,7 +485,7 @@ fn main() -> anyhow::Result<()> {
     // Helper to better log start errors
     let log_err_if_any = |server_name, result| match result {
         Err(err) => {
-            log::error!("Error while starting {} server: {}", server_name, err);
+            log::error!("Error while starting {server_name} server: {err}");
             Err(err)
         }
         ok => ok,
@@ -590,7 +590,7 @@ fn main() -> anyhow::Result<()> {
                             .expect("fail to writeln!");
                         }
                     }
-                    log::error!("{}", error);
+                    log::error!("{error}");
                 }
             })
             .unwrap();

commit feb06c9113c69645a7a3e50cd7505e8c7c3fabd8
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Apr 11 13:30:31 2025 +0000

    Enable incremental_hnsw_building default (#6355)

diff --git a/src/main.rs b/src/main.rs
index 7cab425f1..bff1aaac4 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -216,7 +216,7 @@ fn main() -> anyhow::Result<()> {
 
     // Report feature flags that are enabled for easier debugging
     let flags = feature_flags();
-    if !flags.is_empty() {
+    if !flags.is_default() {
         log::debug!("Feature flags: {flags:?}");
     }
 

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    