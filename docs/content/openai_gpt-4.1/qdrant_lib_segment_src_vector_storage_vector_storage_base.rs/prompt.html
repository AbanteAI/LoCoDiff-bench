<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/vector_storage/vector_storage_base.rs - GPT-4.1</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/vector_storage/vector_storage_base.rs</h1>
        <h2>Model: GPT-4.1</h2>
        <p><a href="../../../cases/openai_gpt-4.1/qdrant_lib_segment_src_vector_storage_vector_storage_base.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/vector_storage/vector_storage_base.rs

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
new file mode 100644
index 000000000..b20a5f91d
--- /dev/null
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -0,0 +1,119 @@
+use crate::entry::entry_point::OperationResult;
+use crate::types::{PointOffsetType, ScoreType, VectorElementType};
+use ordered_float::OrderedFloat;
+use rand::Rng;
+use std::cmp::Ordering;
+use std::ops::Range;
+
+#[derive(Copy, Clone, PartialEq, Debug)]
+pub struct ScoredPointOffset {
+    pub idx: PointOffsetType,
+    pub score: ScoreType,
+}
+
+impl Eq for ScoredPointOffset {}
+
+impl Ord for ScoredPointOffset {
+    fn cmp(&self, other: &Self) -> Ordering {
+        OrderedFloat(self.score).cmp(&OrderedFloat(other.score))
+    }
+}
+
+impl PartialOrd for ScoredPointOffset {
+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
+/// Optimized scorer for multiple scoring requests comparing with a single query
+/// Holds current query and params, receives only subset of points to score
+pub trait RawScorer {
+    // ToDo: Replace boxed iterator with callback and make a benchmark (-4% on benchmarks, but ugly)
+    fn score_points<'a>(
+        &'a self,
+        points: &'a mut dyn Iterator<Item = PointOffsetType>,
+    ) -> Box<dyn Iterator<Item = ScoredPointOffset> + 'a>;
+    /// Return true if point satisfies current search context (exists and not deleted)
+    fn check_point(&self, point: PointOffsetType) -> bool;
+    /// Score stored vector with vector under the given index
+    fn score_point(&self, point: PointOffsetType) -> ScoreType;
+
+    /// Return distance between stored points selected by ids
+    /// Panics if any id is out of range
+    fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
+}
+
+/// Trait for vector storage
+/// El - type of vector element, expected numerical type
+/// Storage operates with internal IDs (PointOffsetType), which always starts with zero and have no skips
+pub trait VectorStorage {
+    fn vector_dim(&self) -> usize;
+    fn vector_count(&self) -> usize;
+    /// Number of searchable vectors (not deleted)
+    fn deleted_count(&self) -> usize;
+    /// Number of vectors, marked as deleted but still stored
+    fn total_vector_count(&self) -> usize;
+    /// Number of all stored vectors including deleted
+    fn get_vector(&self, key: PointOffsetType) -> Option<Vec<VectorElementType>>;
+    fn put_vector(&mut self, vector: Vec<VectorElementType>) -> OperationResult<PointOffsetType>;
+    fn update_vector(
+        &mut self,
+        key: PointOffsetType,
+        vector: Vec<VectorElementType>,
+    ) -> OperationResult<PointOffsetType>;
+    fn update_from(&mut self, other: &dyn VectorStorage)
+        -> OperationResult<Range<PointOffsetType>>;
+    fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
+    fn is_deleted(&self, key: PointOffsetType) -> bool;
+    fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;
+    /// Iterator over not-deleted ids
+    fn flush(&self) -> OperationResult<()>;
+
+    /// Generate a RawScorer object which contains all required context for searching similar vector
+    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
+    /// Same as `raw_scorer` but uses internal vector for search, avoids double pre-processing
+    fn raw_scorer_internal(&self, point_id: PointOffsetType) -> Box<dyn RawScorer + '_>;
+
+    fn score_points(
+        &self,
+        vector: &[VectorElementType],
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+    fn score_all(&self, vector: &[VectorElementType], top: usize) -> Vec<ScoredPointOffset>;
+    fn score_internal(
+        &self,
+        point: PointOffsetType,
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+
+    /// Iterator over `n` random ids which are not deleted
+    fn sample_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
+        let total = self.total_vector_count() as PointOffsetType;
+        let mut rng = rand::thread_rng();
+        Box::new(
+            (0..total)
+                .map(move |_| rng.gen_range(0..total))
+                .filter(move |x| !self.is_deleted(*x)),
+        )
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_ordering() {
+        assert!(
+            ScoredPointOffset {
+                idx: 10,
+                score: 0.9
+            } > ScoredPointOffset {
+                idx: 20,
+                score: 0.6
+            }
+        )
+    }
+}

commit e196ce025bcbb1aad04c892205fe07deaa519f7a
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:21 2022 +0400

    fix clippy warnings (#175)
    
    * fix clippy warnings
    
    - doc links
    - explicit deref
    - if instead of match for single bool condition
    - combine similar match branches
    
    * revert removal of transmute
    
    * return Some when vec is not empty

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index b20a5f91d..01c01647f 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -45,7 +45,7 @@ pub trait RawScorer {
 
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type
-/// Storage operates with internal IDs (PointOffsetType), which always starts with zero and have no skips
+/// Storage operates with internal IDs (`PointOffsetType`), which always starts with zero and have no skips
 pub trait VectorStorage {
     fn vector_dim(&self) -> usize;
     fn vector_count(&self) -> usize;
@@ -69,7 +69,7 @@ pub trait VectorStorage {
     /// Iterator over not-deleted ids
     fn flush(&self) -> OperationResult<()>;
 
-    /// Generate a RawScorer object which contains all required context for searching similar vector
+    /// Generate a `RawScorer` object which contains all required context for searching similar vector
     fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
     /// Same as `raw_scorer` but uses internal vector for search, avoids double pre-processing
     fn raw_scorer_internal(&self, point_id: PointOffsetType) -> Box<dyn RawScorer + '_>;

commit ee461ce0a6cc031e8289bc7a238bb2e807e85b20
Author: Prokudin Alexander <prok20@inbox.ru>
Date:   Tue Jan 18 01:33:26 2022 +0300

    Extend clippy to workspace and fix some warnings (#199)
    
    * Fix clippy in linting workflow
    
    * Add toolchain override flag
    
    * Add components to toolchain installation explicitly
    
    * Add --workspace flag to clippy to check all packages
    
    * Remove unnecessary clones
    
    * remove redundant .clone() calls
    
    * fix wrong arguments order in tests (typo)
    
    * Fix vec! macro usage in test
    
    * Correct redundant assert! usages
    
    * Provide a quick fix for 'unused' test function lint
    
    * fix unsound Send + Sync
    
    * fix clippy complains
    
    * fmt
    
    * fix clippy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 01c01647f..d7b4b57c2 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -61,8 +61,7 @@ pub trait VectorStorage {
         key: PointOffsetType,
         vector: Vec<VectorElementType>,
     ) -> OperationResult<PointOffsetType>;
-    fn update_from(&mut self, other: &dyn VectorStorage)
-        -> OperationResult<Range<PointOffsetType>>;
+    fn update_from(&mut self, other: &VectorStorageSS) -> OperationResult<Range<PointOffsetType>>;
     fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
     fn is_deleted(&self, key: PointOffsetType) -> bool;
     fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;
@@ -100,6 +99,8 @@ pub trait VectorStorage {
     }
 }
 
+pub type VectorStorageSS = dyn VectorStorage + Sync + Send;
+
 #[cfg(test)]
 mod tests {
     use super::*;

commit ff21a1308325a99d30639cee5bc5d49354280116
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Apr 8 18:04:59 2022 +0400

    Remove overcomplicated iterator (#409)
    
    remove dyn iterator from filtered scorer
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index d7b4b57c2..43a19398d 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -5,7 +5,7 @@ use rand::Rng;
 use std::cmp::Ordering;
 use std::ops::Range;
 
-#[derive(Copy, Clone, PartialEq, Debug)]
+#[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {
     pub idx: PointOffsetType,
     pub score: ScoreType,
@@ -28,11 +28,8 @@ impl PartialOrd for ScoredPointOffset {
 /// Optimized scorer for multiple scoring requests comparing with a single query
 /// Holds current query and params, receives only subset of points to score
 pub trait RawScorer {
-    // ToDo: Replace boxed iterator with callback and make a benchmark (-4% on benchmarks, but ugly)
-    fn score_points<'a>(
-        &'a self,
-        points: &'a mut dyn Iterator<Item = PointOffsetType>,
-    ) -> Box<dyn Iterator<Item = ScoredPointOffset> + 'a>;
+    fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
+
     /// Return true if point satisfies current search context (exists and not deleted)
     fn check_point(&self, point: PointOffsetType) -> bool;
     /// Score stored vector with vector under the given index

commit ef67a2ec59180ca599b0c61cc957c45a56454410
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:43:02 2022 +0200

    Condition search benchmark (#435)
    
    * decouple payload index and vector storage
    
    * wip: test fixtures
    
    * conditional search benchmark
    
    * fmt
    
    * use arc iterator for filtered queries
    
    * fmt
    
    * enable all benches
    
    * fix warn
    
    * upd tests
    
    * fmt
    
    * Update lib/segment/src/fixtures/payload_context_fixture.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 43a19398d..dc21207c3 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -96,6 +96,8 @@ pub trait VectorStorage {
     }
 }
 
+trait SuperVectorStorage {}
+
 pub type VectorStorageSS = dyn VectorStorage + Sync + Send;
 
 #[cfg(test)]

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index dc21207c3..5fc12bba6 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,10 +1,12 @@
-use crate::entry::entry_point::OperationResult;
-use crate::types::{PointOffsetType, ScoreType, VectorElementType};
-use ordered_float::OrderedFloat;
-use rand::Rng;
 use std::cmp::Ordering;
 use std::ops::Range;
 
+use ordered_float::OrderedFloat;
+use rand::Rng;
+
+use crate::entry::entry_point::OperationResult;
+use crate::types::{PointOffsetType, ScoreType, VectorElementType};
+
 #[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {
     pub idx: PointOffsetType,

commit f357bd5d9bc8cdc05915111419894d4f25512d83
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 15 13:47:52 2022 +0400

    Allow to flush segment in separate thread (#927)
    
    * allow to flush segment in separate thread
    
    * flush as separate function (#928)
    
    * flush as separate function
    
    * review suggestion
    
    * reduce locks during vector scoring
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * don't run background flush twice
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    * increase flush interval
    
    * Update lib/segment/src/segment.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * are you happy fmt
    
    * test background flush
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 5fc12bba6..06ad8160e 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -4,6 +4,7 @@ use std::ops::Range;
 use ordered_float::OrderedFloat;
 use rand::Rng;
 
+use crate::common::Flusher;
 use crate::entry::entry_point::OperationResult;
 use crate::types::{PointOffsetType, ScoreType, VectorElementType};
 
@@ -64,8 +65,7 @@ pub trait VectorStorage {
     fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
     fn is_deleted(&self, key: PointOffsetType) -> bool;
     fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;
-    /// Iterator over not-deleted ids
-    fn flush(&self) -> OperationResult<()>;
+    fn flusher(&self) -> Flusher;
 
     /// Generate a `RawScorer` object which contains all required context for searching similar vector
     fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 06ad8160e..36740b9be 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -5,8 +5,9 @@ use ordered_float::OrderedFloat;
 use rand::Rng;
 
 use crate::common::Flusher;
+use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
-use crate::types::{PointOffsetType, ScoreType, VectorElementType};
+use crate::types::{PointOffsetType, ScoreType};
 
 #[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {

commit ab19576c5d2329b547ab2dbf5a0b137d0582072d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Oct 11 09:29:56 2022 +0200

    Force sync vector storage offset (#1110)
    
    * simplify vector storage `update` semantic, always assume inplace vector replacement
    
    * fmt

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 36740b9be..9cbc3d6b0 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -57,11 +57,13 @@ pub trait VectorStorage {
     /// Number of all stored vectors including deleted
     fn get_vector(&self, key: PointOffsetType) -> Option<Vec<VectorElementType>>;
     fn put_vector(&mut self, vector: Vec<VectorElementType>) -> OperationResult<PointOffsetType>;
-    fn update_vector(
+    fn insert_vector(
         &mut self,
         key: PointOffsetType,
         vector: Vec<VectorElementType>,
-    ) -> OperationResult<PointOffsetType>;
+    ) -> OperationResult<()>;
+    /// Returns next available id
+    fn next_id(&self) -> PointOffsetType;
     fn update_from(&mut self, other: &VectorStorageSS) -> OperationResult<Range<PointOffsetType>>;
     fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
     fn is_deleted(&self, key: PointOffsetType) -> bool;

commit 8e8ed800f4cb4995d3449a6c1de0f41960042c8b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Dec 14 10:11:46 2022 +0100

    Shard build refactoring (#1280)
    
    * refactor some code of shard creation and optimizers
    
    * Shard build refactoring debug (#1279)
    
    * add debig code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * debug code
    
    * refactor stop-checking during the optimization
    
    * remove debug logs
    
    * improve delete-renaming schema
    
    * fmt
    
    * move collection file removing to the async task
    
    * rename check_optimization_stopped into more general check_process_stopped

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 9cbc3d6b0..fe7de441a 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,5 +1,6 @@
 use std::cmp::Ordering;
 use std::ops::Range;
+use std::sync::atomic::AtomicBool;
 
 use ordered_float::OrderedFloat;
 use rand::Rng;
@@ -64,7 +65,11 @@ pub trait VectorStorage {
     ) -> OperationResult<()>;
     /// Returns next available id
     fn next_id(&self) -> PointOffsetType;
-    fn update_from(&mut self, other: &VectorStorageSS) -> OperationResult<Range<PointOffsetType>>;
+    fn update_from(
+        &mut self,
+        other: &VectorStorageSS,
+        stopped: &AtomicBool,
+    ) -> OperationResult<Range<PointOffsetType>>;
     fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
     fn is_deleted(&self, key: PointOffsetType) -> bool;
     fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;

commit 8b35d90e25f6306a9b0f2463ee6c518a948cb5e1
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Dec 14 14:47:22 2022 +0400

    remove obsolete internal scorer (#1271)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index fe7de441a..ac59b449c 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -77,8 +77,6 @@ pub trait VectorStorage {
 
     /// Generate a `RawScorer` object which contains all required context for searching similar vector
     fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
-    /// Same as `raw_scorer` but uses internal vector for search, avoids double pre-processing
-    fn raw_scorer_internal(&self, point_id: PointOffsetType) -> Box<dyn RawScorer + '_>;
 
     fn score_points(
         &self,

commit bcb52f9aee210d02a10eb250ab3e602d29e17313
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Dec 25 22:36:31 2022 +0100

    Id mapper inconsistency (#1302)
    
    * always flush wal
    
    * always flush wal fix
    
    * always flush wal fmt
    
    * flush wal during background flush
    
    * async wal flush
    
    * use id-tracker internal id for next-id instead of vector storage
    
    * add flush order and recovery comment
    
    fix merge bug
    
    * longer timeout in test

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index ac59b449c..d0d6f0d6e 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -63,8 +63,6 @@ pub trait VectorStorage {
         key: PointOffsetType,
         vector: Vec<VectorElementType>,
     ) -> OperationResult<()>;
-    /// Returns next available id
-    fn next_id(&self) -> PointOffsetType;
     fn update_from(
         &mut self,
         other: &VectorStorageSS,

commit 6eca194f71bc20ca3e945560d47414eb10c14874
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 13 11:44:42 2023 +0100

    Fix segment snapshotting (#1321) (#1334)
    
    * WIP: Fix `Segment::take_snapshot`
    
    TODO:
    - This commit, probably, breaks snapshotting of segments with memmapped vector storage
    - `ProxySegment::take_snapshot` seems to potentially similar bug
    
    * WIP: Fix `Segment::take_snapshot`
    
    - Fix snapshotting of `StructPayloadIndex`
    - Fix snapshotting of segments with memmapped vector storage
    - Temporarily break `ProxySegment::take_snapshot`
    
    * Fix `ProxySegment::take_snapshot`
    
    * Remove `copy_segment_directory` test
    
    * nitpicking
    
    * clippy fixes
    
    * use OperationError::service_error
    
    * Cleanup `TinyMap` trait bounds and derive `Debug`
    
    * Fix `test_snapshot` test
    
    - Derive `Debug` for `NamedVectors`
    
    * Move utility functions from `segment.rs` to `utils` module
    
    * Contextualize `segment::utils::fs::move_all` a bit more carefully
    
    * Fix a typo
    
    * add backward compatibility with old snapshot formats
    
    * fmt
    
    * add snapshot for compatibility test
    
    * git lfs is a piece of shit
    
    * Nitpicking
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index d0d6f0d6e..90b7e0105 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,5 +1,6 @@
 use std::cmp::Ordering;
 use std::ops::Range;
+use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 
 use ordered_float::OrderedFloat;
@@ -90,6 +91,8 @@ pub trait VectorStorage {
         top: usize,
     ) -> Vec<ScoredPointOffset>;
 
+    fn files(&self) -> Vec<PathBuf>;
+
     /// Iterator over `n` random ids which are not deleted
     fn sample_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
         let total = self.total_vector_count() as PointOffsetType;

commit 128e49fcc3633e361df33818de6cca0aab95da10
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Mar 3 20:46:17 2023 +0400

    integrate quantized data to storages (#1311)
    
    * integrate quantized data to storages
    
    * revert gitignore
    
    * are you happy clippy
    
    * quantize in optimizer
    
    * provide flag
    
    * fix segfault
    
    * skip quantization flag, update scores
    
    * use quantization flag
    
    * are you happy fmt
    
    * use quantization flag
    
    * quantized search test
    
    * are you happy fmt
    
    * refactor test, refactor scorer choosing
    
    * are you happy fmt
    
    * run quantization on segment builder
    
    * decrease testing parameters
    
    * simplify segment
    
    * update version
    
    * remove use_quantization flag
    
    * provide quantization config
    
    * quantization version up
    
    * euclid dist
    
    * add euclid test
    
    * saveload
    
    * fix initialization bugs
    
    * quantization lib version up
    
    * fix arm build
    
    * refactor scorer selecting
    
    * quant lib version up
    
    * are you happy fmt
    
    * are you happy fmt
    
    * are you happy clippy
    
    * add save/load test for simple storage
    
    * add comments
    
    * quantiles
    
    * quantization mmap
    
    * remove f32
    
    * mmap test
    
    * fix mmap slice
    
    * fix mmap test
    
    * use chunks for quantization storage
    
    * fix build
    
    * are you happy fmt
    
    * update quantization library
    
    * update quantization lib
    
    * update quantization lib
    
    * integrate api changes
    
    * are you happy fmt
    
    * change quantization api
    
    * additional checks in tests
    
    * update quantization version
    
    * fix unit tests
    
    * add quantization to storage config
    
    * use quantization for all cardinality search cases
    
    * Integrate quantization suggestions 2 (#1520)
    
    * review api
    
    * wip: refactor quantization integrations
    
    * wip: refactor quantization integrations
    
    * wip: fmt
    
    * include quantization into snapshot
    
    * fmt
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 90b7e0105..00bd7f8c9 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,6 +1,6 @@
 use std::cmp::Ordering;
 use std::ops::Range;
-use std::path::PathBuf;
+use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
 use ordered_float::OrderedFloat;
@@ -9,7 +9,7 @@ use rand::Rng;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
-use crate::types::{PointOffsetType, ScoreType};
+use crate::types::{PointOffsetType, QuantizationConfig, ScoreType};
 
 #[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {
@@ -77,6 +77,28 @@ pub trait VectorStorage {
     /// Generate a `RawScorer` object which contains all required context for searching similar vector
     fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
 
+    // Generate RawScorer on quantized vectors if present
+    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
+        -> Option<Box<dyn RawScorer + '_>>;
+
+    // Try peek top nearest points from quantized vectors. If quantized vectors are not present, do it on raw vectors
+    fn score_quantized_points(
+        &self,
+        vector: &[VectorElementType],
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+
+    // Generate quantized vectors and store them on disk
+    fn quantize(
+        &mut self,
+        data_path: &Path,
+        quantization_config: &QuantizationConfig,
+    ) -> OperationResult<()>;
+
+    // Load quantized vectors from disk
+    fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()>;
+
     fn score_points(
         &self,
         vector: &[VectorElementType],
@@ -105,24 +127,4 @@ pub trait VectorStorage {
     }
 }
 
-trait SuperVectorStorage {}
-
 pub type VectorStorageSS = dyn VectorStorage + Sync + Send;
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn test_ordering() {
-        assert!(
-            ScoredPointOffset {
-                idx: 10,
-                score: 0.9
-            } > ScoredPointOffset {
-                idx: 20,
-                score: 0.6
-            }
-        )
-    }
-}

commit 9bb29c26a6ddf3aa0092d45f797aca45735b9ba3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 9 09:43:20 2023 +0400

    Vector storages enum (#1533)
    
    * separate scoring and data containing
    
    * vector storage enum
    
    * fix test build
    
    * are you happy clippy
    
    * review fixes

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 00bd7f8c9..ff172f09c 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -6,6 +6,8 @@ use std::sync::atomic::AtomicBool;
 use ordered_float::OrderedFloat;
 use rand::Rng;
 
+use super::memmap_vector_storage::MemmapVectorStorage;
+use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
@@ -46,6 +48,32 @@ pub trait RawScorer {
     fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
 }
 
+pub trait VectorScorer {
+    /// Generate a `RawScorer` object which contains all required context for searching similar vector
+    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
+
+    // Generate RawScorer on quantized vectors if present
+    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
+        -> Option<Box<dyn RawScorer + '_>>;
+
+    // Try peek top nearest points from quantized vectors. If quantized vectors are not present, do it on raw vectors
+    fn score_quantized_points(
+        &self,
+        vector: &[VectorElementType],
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+
+    fn score_points(
+        &self,
+        vector: &[VectorElementType],
+        points: &mut dyn Iterator<Item = PointOffsetType>,
+        top: usize,
+    ) -> Vec<ScoredPointOffset>;
+
+    fn score_all(&self, vector: &[VectorElementType], top: usize) -> Vec<ScoredPointOffset>;
+}
+
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type
 /// Storage operates with internal IDs (`PointOffsetType`), which always starts with zero and have no skips
@@ -66,7 +94,7 @@ pub trait VectorStorage {
     ) -> OperationResult<()>;
     fn update_from(
         &mut self,
-        other: &VectorStorageSS,
+        other: &VectorStorageEnum,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
     fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
@@ -74,21 +102,6 @@ pub trait VectorStorage {
     fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;
     fn flusher(&self) -> Flusher;
 
-    /// Generate a `RawScorer` object which contains all required context for searching similar vector
-    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
-
-    // Generate RawScorer on quantized vectors if present
-    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
-        -> Option<Box<dyn RawScorer + '_>>;
-
-    // Try peek top nearest points from quantized vectors. If quantized vectors are not present, do it on raw vectors
-    fn score_quantized_points(
-        &self,
-        vector: &[VectorElementType],
-        points: &mut dyn Iterator<Item = PointOffsetType>,
-        top: usize,
-    ) -> Vec<ScoredPointOffset>;
-
     // Generate quantized vectors and store them on disk
     fn quantize(
         &mut self,
@@ -99,20 +112,6 @@ pub trait VectorStorage {
     // Load quantized vectors from disk
     fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()>;
 
-    fn score_points(
-        &self,
-        vector: &[VectorElementType],
-        points: &mut dyn Iterator<Item = PointOffsetType>,
-        top: usize,
-    ) -> Vec<ScoredPointOffset>;
-    fn score_all(&self, vector: &[VectorElementType], top: usize) -> Vec<ScoredPointOffset>;
-    fn score_internal(
-        &self,
-        point: PointOffsetType,
-        points: &mut dyn Iterator<Item = PointOffsetType>,
-        top: usize,
-    ) -> Vec<ScoredPointOffset>;
-
     fn files(&self) -> Vec<PathBuf>;
 
     /// Iterator over `n` random ids which are not deleted
@@ -125,6 +124,137 @@ pub trait VectorStorage {
                 .filter(move |x| !self.is_deleted(*x)),
         )
     }
+
+    fn scorer(&self) -> Box<dyn VectorScorer + Sync + Send + '_>;
 }
 
-pub type VectorStorageSS = dyn VectorStorage + Sync + Send;
+pub enum VectorStorageEnum {
+    Simple(SimpleVectorStorage),
+    Memmap(Box<MemmapVectorStorage>),
+}
+
+impl VectorStorage for VectorStorageEnum {
+    fn vector_dim(&self) -> usize {
+        match self {
+            VectorStorageEnum::Simple(v) => v.vector_dim(),
+            VectorStorageEnum::Memmap(v) => v.vector_dim(),
+        }
+    }
+
+    fn vector_count(&self) -> usize {
+        match self {
+            VectorStorageEnum::Simple(v) => v.vector_count(),
+            VectorStorageEnum::Memmap(v) => v.vector_count(),
+        }
+    }
+
+    fn deleted_count(&self) -> usize {
+        match self {
+            VectorStorageEnum::Simple(v) => v.deleted_count(),
+            VectorStorageEnum::Memmap(v) => v.deleted_count(),
+        }
+    }
+
+    fn total_vector_count(&self) -> usize {
+        match self {
+            VectorStorageEnum::Simple(v) => v.total_vector_count(),
+            VectorStorageEnum::Memmap(v) => v.total_vector_count(),
+        }
+    }
+
+    fn get_vector(&self, key: PointOffsetType) -> Option<Vec<VectorElementType>> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.get_vector(key),
+            VectorStorageEnum::Memmap(v) => v.get_vector(key),
+        }
+    }
+
+    fn put_vector(&mut self, vector: Vec<VectorElementType>) -> OperationResult<PointOffsetType> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.put_vector(vector),
+            VectorStorageEnum::Memmap(v) => v.put_vector(vector),
+        }
+    }
+
+    fn insert_vector(
+        &mut self,
+        key: PointOffsetType,
+        vector: Vec<VectorElementType>,
+    ) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),
+        }
+    }
+
+    fn update_from(
+        &mut self,
+        other: &VectorStorageEnum,
+        stopped: &AtomicBool,
+    ) -> OperationResult<Range<PointOffsetType>> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.update_from(other, stopped),
+            VectorStorageEnum::Memmap(v) => v.update_from(other, stopped),
+        }
+    }
+
+    fn delete(&mut self, key: PointOffsetType) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.delete(key),
+            VectorStorageEnum::Memmap(v) => v.delete(key),
+        }
+    }
+
+    fn is_deleted(&self, key: PointOffsetType) -> bool {
+        match self {
+            VectorStorageEnum::Simple(v) => v.is_deleted(key),
+            VectorStorageEnum::Memmap(v) => v.is_deleted(key),
+        }
+    }
+
+    fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.iter_ids(),
+            VectorStorageEnum::Memmap(v) => v.iter_ids(),
+        }
+    }
+
+    fn flusher(&self) -> Flusher {
+        match self {
+            VectorStorageEnum::Simple(v) => v.flusher(),
+            VectorStorageEnum::Memmap(v) => v.flusher(),
+        }
+    }
+
+    fn quantize(
+        &mut self,
+        data_path: &Path,
+        quantization_config: &QuantizationConfig,
+    ) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.quantize(data_path, quantization_config),
+            VectorStorageEnum::Memmap(v) => v.quantize(data_path, quantization_config),
+        }
+    }
+
+    fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.load_quantization(data_path),
+            VectorStorageEnum::Memmap(v) => v.load_quantization(data_path),
+        }
+    }
+
+    fn files(&self) -> Vec<PathBuf> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.files(),
+            VectorStorageEnum::Memmap(v) => v.files(),
+        }
+    }
+
+    fn scorer(&self) -> Box<dyn VectorScorer + Sync + Send + '_> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.scorer(),
+            VectorStorageEnum::Memmap(v) => v.scorer(),
+        }
+    }
+}

commit 9639df19985bfa6d13d6bb8fb0c8beb1031ce51e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Mar 11 23:13:24 2023 +0400

    Remove vector scorer trait (#1546)
    
    * remove vector scorer
    
    * nits
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index ff172f09c..a5d0dd486 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -46,32 +46,14 @@ pub trait RawScorer {
     /// Return distance between stored points selected by ids
     /// Panics if any id is out of range
     fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
-}
-
-pub trait VectorScorer {
-    /// Generate a `RawScorer` object which contains all required context for searching similar vector
-    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
-
-    // Generate RawScorer on quantized vectors if present
-    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
-        -> Option<Box<dyn RawScorer + '_>>;
 
-    // Try peek top nearest points from quantized vectors. If quantized vectors are not present, do it on raw vectors
-    fn score_quantized_points(
+    fn peek_top_iter(
         &self,
-        vector: &[VectorElementType],
         points: &mut dyn Iterator<Item = PointOffsetType>,
         top: usize,
     ) -> Vec<ScoredPointOffset>;
 
-    fn score_points(
-        &self,
-        vector: &[VectorElementType],
-        points: &mut dyn Iterator<Item = PointOffsetType>,
-        top: usize,
-    ) -> Vec<ScoredPointOffset>;
-
-    fn score_all(&self, vector: &[VectorElementType], top: usize) -> Vec<ScoredPointOffset>;
+    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
 }
 
 /// Trait for vector storage
@@ -125,7 +107,12 @@ pub trait VectorStorage {
         )
     }
 
-    fn scorer(&self) -> Box<dyn VectorScorer + Sync + Send + '_>;
+    /// Generate a `RawScorer` object which contains all required context for searching similar vector
+    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
+
+    // Generate RawScorer on quantized vectors if present
+    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
+        -> Option<Box<dyn RawScorer + '_>>;
 }
 
 pub enum VectorStorageEnum {
@@ -251,10 +238,20 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn scorer(&self) -> Box<dyn VectorScorer + Sync + Send + '_> {
+    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.raw_scorer(vector),
+            VectorStorageEnum::Memmap(v) => v.raw_scorer(vector),
+        }
+    }
+
+    fn quantized_raw_scorer(
+        &self,
+        vector: &[VectorElementType],
+    ) -> Option<Box<dyn RawScorer + '_>> {
         match self {
-            VectorStorageEnum::Simple(v) => v.scorer(),
-            VectorStorageEnum::Memmap(v) => v.scorer(),
+            VectorStorageEnum::Simple(v) => v.quantized_raw_scorer(vector),
+            VectorStorageEnum::Memmap(v) => v.quantized_raw_scorer(vector),
         }
     }
 }

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index a5d0dd486..0d72a0bfa 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -4,14 +4,14 @@ use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
 use ordered_float::OrderedFloat;
-use rand::Rng;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
+use super::quantized::quantized_vectors_base::QuantizedVectorsStorage;
 use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
-use crate::types::{PointOffsetType, QuantizationConfig, ScoreType};
+use crate::types::{Distance, PointOffsetType, QuantizationConfig, ScoreType};
 
 #[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {
@@ -33,55 +33,33 @@ impl PartialOrd for ScoredPointOffset {
     }
 }
 
-/// Optimized scorer for multiple scoring requests comparing with a single query
-/// Holds current query and params, receives only subset of points to score
-pub trait RawScorer {
-    fn score_points(&self, points: &[PointOffsetType], scores: &mut [ScoredPointOffset]) -> usize;
-
-    /// Return true if point satisfies current search context (exists and not deleted)
-    fn check_point(&self, point: PointOffsetType) -> bool;
-    /// Score stored vector with vector under the given index
-    fn score_point(&self, point: PointOffsetType) -> ScoreType;
-
-    /// Return distance between stored points selected by ids
-    /// Panics if any id is out of range
-    fn score_internal(&self, point_a: PointOffsetType, point_b: PointOffsetType) -> ScoreType;
-
-    fn peek_top_iter(
-        &self,
-        points: &mut dyn Iterator<Item = PointOffsetType>,
-        top: usize,
-    ) -> Vec<ScoredPointOffset>;
-
-    fn peek_top_all(&self, top: usize) -> Vec<ScoredPointOffset>;
-}
-
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type
 /// Storage operates with internal IDs (`PointOffsetType`), which always starts with zero and have no skips
 pub trait VectorStorage {
     fn vector_dim(&self) -> usize;
-    fn vector_count(&self) -> usize;
-    /// Number of searchable vectors (not deleted)
-    fn deleted_count(&self) -> usize;
+
+    fn distance(&self) -> Distance;
+
     /// Number of vectors, marked as deleted but still stored
     fn total_vector_count(&self) -> usize;
+
     /// Number of all stored vectors including deleted
-    fn get_vector(&self, key: PointOffsetType) -> Option<Vec<VectorElementType>>;
-    fn put_vector(&mut self, vector: Vec<VectorElementType>) -> OperationResult<PointOffsetType>;
+    fn get_vector(&self, key: PointOffsetType) -> &[VectorElementType];
+
     fn insert_vector(
         &mut self,
         key: PointOffsetType,
-        vector: Vec<VectorElementType>,
+        vector: &[VectorElementType],
     ) -> OperationResult<()>;
+
     fn update_from(
         &mut self,
         other: &VectorStorageEnum,
+        other_ids: &mut dyn Iterator<Item = PointOffsetType>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
-    fn delete(&mut self, key: PointOffsetType) -> OperationResult<()>;
-    fn is_deleted(&self, key: PointOffsetType) -> bool;
-    fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_>;
+
     fn flusher(&self) -> Flusher;
 
     // Generate quantized vectors and store them on disk
@@ -94,25 +72,9 @@ pub trait VectorStorage {
     // Load quantized vectors from disk
     fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()>;
 
-    fn files(&self) -> Vec<PathBuf>;
-
-    /// Iterator over `n` random ids which are not deleted
-    fn sample_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
-        let total = self.total_vector_count() as PointOffsetType;
-        let mut rng = rand::thread_rng();
-        Box::new(
-            (0..total)
-                .map(move |_| rng.gen_range(0..total))
-                .filter(move |x| !self.is_deleted(*x)),
-        )
-    }
+    fn quantized_storage(&self) -> Option<&QuantizedVectorsStorage>;
 
-    /// Generate a `RawScorer` object which contains all required context for searching similar vector
-    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_>;
-
-    // Generate RawScorer on quantized vectors if present
-    fn quantized_raw_scorer(&self, vector: &[VectorElementType])
-        -> Option<Box<dyn RawScorer + '_>>;
+    fn files(&self) -> Vec<PathBuf>;
 }
 
 pub enum VectorStorageEnum {
@@ -128,17 +90,10 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn vector_count(&self) -> usize {
-        match self {
-            VectorStorageEnum::Simple(v) => v.vector_count(),
-            VectorStorageEnum::Memmap(v) => v.vector_count(),
-        }
-    }
-
-    fn deleted_count(&self) -> usize {
+    fn distance(&self) -> Distance {
         match self {
-            VectorStorageEnum::Simple(v) => v.deleted_count(),
-            VectorStorageEnum::Memmap(v) => v.deleted_count(),
+            VectorStorageEnum::Simple(v) => v.distance(),
+            VectorStorageEnum::Memmap(v) => v.distance(),
         }
     }
 
@@ -149,24 +104,17 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn get_vector(&self, key: PointOffsetType) -> Option<Vec<VectorElementType>> {
+    fn get_vector(&self, key: PointOffsetType) -> &[VectorElementType] {
         match self {
             VectorStorageEnum::Simple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),
         }
     }
 
-    fn put_vector(&mut self, vector: Vec<VectorElementType>) -> OperationResult<PointOffsetType> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.put_vector(vector),
-            VectorStorageEnum::Memmap(v) => v.put_vector(vector),
-        }
-    }
-
     fn insert_vector(
         &mut self,
         key: PointOffsetType,
-        vector: Vec<VectorElementType>,
+        vector: &[VectorElementType],
     ) -> OperationResult<()> {
         match self {
             VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
@@ -177,32 +125,12 @@ impl VectorStorage for VectorStorageEnum {
     fn update_from(
         &mut self,
         other: &VectorStorageEnum,
+        other_ids: &mut dyn Iterator<Item = PointOffsetType>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
-            VectorStorageEnum::Simple(v) => v.update_from(other, stopped),
-            VectorStorageEnum::Memmap(v) => v.update_from(other, stopped),
-        }
-    }
-
-    fn delete(&mut self, key: PointOffsetType) -> OperationResult<()> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.delete(key),
-            VectorStorageEnum::Memmap(v) => v.delete(key),
-        }
-    }
-
-    fn is_deleted(&self, key: PointOffsetType) -> bool {
-        match self {
-            VectorStorageEnum::Simple(v) => v.is_deleted(key),
-            VectorStorageEnum::Memmap(v) => v.is_deleted(key),
-        }
-    }
-
-    fn iter_ids(&self) -> Box<dyn Iterator<Item = PointOffsetType> + '_> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.iter_ids(),
-            VectorStorageEnum::Memmap(v) => v.iter_ids(),
+            VectorStorageEnum::Simple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::Memmap(v) => v.update_from(other, other_ids, stopped),
         }
     }
 
@@ -231,27 +159,17 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn files(&self) -> Vec<PathBuf> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.files(),
-            VectorStorageEnum::Memmap(v) => v.files(),
-        }
-    }
-
-    fn raw_scorer(&self, vector: Vec<VectorElementType>) -> Box<dyn RawScorer + '_> {
+    fn quantized_storage(&self) -> Option<&QuantizedVectorsStorage> {
         match self {
-            VectorStorageEnum::Simple(v) => v.raw_scorer(vector),
-            VectorStorageEnum::Memmap(v) => v.raw_scorer(vector),
+            VectorStorageEnum::Simple(v) => v.quantized_storage(),
+            VectorStorageEnum::Memmap(v) => v.quantized_storage(),
         }
     }
 
-    fn quantized_raw_scorer(
-        &self,
-        vector: &[VectorElementType],
-    ) -> Option<Box<dyn RawScorer + '_>> {
+    fn files(&self) -> Vec<PathBuf> {
         match self {
-            VectorStorageEnum::Simple(v) => v.quantized_raw_scorer(vector),
-            VectorStorageEnum::Memmap(v) => v.quantized_raw_scorer(vector),
+            VectorStorageEnum::Simple(v) => v.files(),
+            VectorStorageEnum::Memmap(v) => v.files(),
         }
     }
 }

commit 511704d88d8f915eb142e5873edbf20d249c3132
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 20 12:06:29 2023 +0200

    Add support for deleted vectors in segments (#1724)
    
    * Use resize rather than while-push loop
    
    * Add deleted flags to simple vector storage
    
    * Add deleted flag to memmap vector storage
    
    * Map BitSlice on mmap file for deleted flags
    
    * Use vector specific deletion BitSlice in RawScorer
    
    * Use BitSlice for deleted points, fix check point logic, clarify names
    
    * Extract div_ceil function to shared module
    
    * We can use unchecked set and replace because we just checked the length
    
    * Add deleted count function to vector storage
    
    * Add vector storage point deletion tests
    
    * Keep deleted state in simple vector storage with update_from, add test
    
    * Keep deleted state in memmap vector storage with update_from, add test
    
    * Simplify div_ceil
    
    * Improve deletion handling in update_from in mmap vector storage
    
    * Improve performance, use trickery to get BitSlice view over deleted mmap
    
    * Use BitSlice where possible, construct BitVec more efficiently
    
    * Incorporate vector specific delete flags in quantized raw scorer
    
    * Don't pin MmapMut, it is not required
    
    * With quantization, keep mmap deleted flags in RAM for better performance
    
    * Advice the kernel to prepare deleted flags mmap for faster future access
    
    * Simplify deleted bitslice access, add bound check, remove unused function
    
    * Fix compilation on Windows
    
    * Cleanup
    
    * Rename delete functions to delete_{point,vec} to prevent confusion
    
    * Use then_some rather than match a boolean
    
    * Lock deleted flags in memory only when quantization is available
    
    * Add docs and stabilize issue link to dev_ceil
    
    * Flush deleted mmap when closing segment
    
    This requires us to to wrap the memory map struct in an Arc and Mutex.
    Though this may look inefficient, it doesn't have a negative side effect
    on deleted flag performance, because the flags are accessed through a
    BitSlice that is separate and doesn't use locking.
    
    * Rename some point functions to vec because that makes more sense
    
    * Simplify delete flag fetching option, use deref func instead of asterisk
    
    * Do not calculate slice size manually, use size_of_val
    
    * remove test raw scorer
    
    * use deref in check
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 0d72a0bfa..f3708a601 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -3,6 +3,7 @@ use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
+use bitvec::prelude::BitSlice;
 use ordered_float::OrderedFloat;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
@@ -75,6 +76,21 @@ pub trait VectorStorage {
     fn quantized_storage(&self) -> Option<&QuantizedVectorsStorage>;
 
     fn files(&self) -> Vec<PathBuf>;
+
+    /// Flag the vector by the given key as deleted
+    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<()>;
+
+    /// Check whether the vector at the given key is flagged as deleted
+    fn is_deleted_vec(&self, key: PointOffsetType) -> bool;
+
+    /// Get number of deleted vectors
+    fn deleted_vec_count(&self) -> usize;
+
+    /// Get [`BitSlice`] representation for deleted vectors with deletion flags
+    ///
+    /// The size of this slice is not guaranteed. It may be smaller/larger than the number of
+    /// vectors in this segment.
+    fn deleted_vec_bitslice(&self) -> &BitSlice;
 }
 
 pub enum VectorStorageEnum {
@@ -172,4 +188,32 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Memmap(v) => v.files(),
         }
     }
+
+    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.delete_vec(key),
+            VectorStorageEnum::Memmap(v) => v.delete_vec(key),
+        }
+    }
+
+    fn is_deleted_vec(&self, key: PointOffsetType) -> bool {
+        match self {
+            VectorStorageEnum::Simple(v) => v.is_deleted_vec(key),
+            VectorStorageEnum::Memmap(v) => v.is_deleted_vec(key),
+        }
+    }
+
+    fn deleted_vec_count(&self) -> usize {
+        match self {
+            VectorStorageEnum::Simple(v) => v.deleted_vec_count(),
+            VectorStorageEnum::Memmap(v) => v.deleted_vec_count(),
+        }
+    }
+
+    fn deleted_vec_bitslice(&self) -> &BitSlice {
+        match self {
+            VectorStorageEnum::Simple(v) => v.deleted_vec_bitslice(),
+            VectorStorageEnum::Memmap(v) => v.deleted_vec_bitslice(),
+        }
+    }
 }

commit 7edf599d73cd65b47476be72009684451b7533a9
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Apr 25 14:31:04 2023 +0200

    Make query planner aware of deleted points and vectors (#1757)
    
    * Exclude deleted vectors from HNSW graph building stage
    
    * When estimating query cardinality, use available points as baseline
    
    We should not use the total number of points in a segment, because a
    portion of it may be soft deleted. Instead, we use the available
    (non-deleted) points as baseline.
    
    * Add plain search check to unfiltered HNSW search due to deleted points
    
    * Cardinality sampling on available points, ignore deleted named vectors
    
    * Estimate available vectors in query planner, now consider deleted points
    
    In the query planner, we want to know the number of available points as
    accurately as possible. This isn't possible because we only know the
    number of deletions and vectors can be deleted in two places: as point
    or as vector. These deletions may overlap. This now estimates the number
    of deleted vectors based on the segment state. It assumes that point and
    vector deletions have an overlap of 20%. This is an arbitrary
    percentage, but reflects an almost-worst scenario.
    
    This improves because the number of deleted points wasn't considered at
    all before.
    
    * Remove unused function from trait
    
    * Fix bench compilation error
    
    * Fix typo in docs
    
    * Base whether to do plain search in HNSW upon full scan threshold
    
    * Remove index threshold from HNSW config, only use full scan threshold
    
    * Simplify timer aggregator assignment in HNSW search
    
    * Remove vector storage type from cardinality function parameters
    
    * Propagate point deletes to all its vectors
    
    * Check for deleted vectors first, this makes early return possible
    
    Since point deletes are now propagated to vectors, deleted points are
    included in vector deletions. Because of that we can check if the vector
    is deleted first so we can return early and skip the point deletion
    check.
    
    For integrity we also check if the point is deleted, if the vector was
    not. That is because it may happen that point deletions are not properly
    propagated to vectors.
    
    * Don't use arbitrary vector count estimation, use vector count directly
    
    Before we had to estimate the number of vectors (for a named vector)
    because vectors could be deleted as point or vector. Point deletes are
    now propagated to vector deletes, that means we can simply use the
    deleted vector count which is now much more accurate.
    
    * When sampling IDs, check deleted vecs before deleted points
    
    * On segment consistency check, delete vectors for deleted points
    
    * Fix vector delete state not being kept when updating storage from other
    
    * Fix segment builder skipping deleted vectors breaking offsets
    
    * update segment to handle optional vectors + add test (#1781)
    
    * update segment to handle optional vectors + add test
    
    * Only update stored record when deleting if it wasn't deleted already
    
    * Reformat comment
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Fix missed vector name test, these are now marked as deleted
    
    * upd test
    
    * upd test
    
    * Update consensus test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index f3708a601..369587121 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -45,6 +45,18 @@ pub trait VectorStorage {
     /// Number of vectors, marked as deleted but still stored
     fn total_vector_count(&self) -> usize;
 
+    /// Get the number of available vectors, considering deleted points and vectors
+    ///
+    /// This uses [`total_vector_count`] and [`deleted_vec_count`] internally.
+    ///
+    /// # Warning
+    ///
+    /// This number may not always be accurate. See warning in [`deleted_vec_count`] documentation.
+    fn available_vec_count(&self) -> usize {
+        self.total_vector_count()
+            .saturating_sub(self.deleted_vec_count())
+    }
+
     /// Number of all stored vectors including deleted
     fn get_vector(&self, key: PointOffsetType) -> &[VectorElementType];
 
@@ -78,12 +90,24 @@ pub trait VectorStorage {
     fn files(&self) -> Vec<PathBuf>;
 
     /// Flag the vector by the given key as deleted
-    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<()>;
+    /// Returns true if the vector was not deleted before and is now deleted
+    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<bool>;
 
     /// Check whether the vector at the given key is flagged as deleted
     fn is_deleted_vec(&self, key: PointOffsetType) -> bool;
 
-    /// Get number of deleted vectors
+    /// Get the number of deleted vectors, considering deleted points and vectors
+    ///
+    /// Vectors may be deleted at two levels, as point or as vector. Deleted points should
+    /// propagate to deleting the vectors. That means that the deleted vector count includes the
+    /// number of deleted points as well.
+    ///
+    /// # Warning
+    ///
+    /// In some very exceptional cases it is possible for this count not to include some deleted
+    /// points. That may happen when flushing a segment to disk fails. This should be recovered
+    /// when loading/recovering the segment, but that isn't guaranteed. You should therefore use
+    /// the deleted count with care.
     fn deleted_vec_count(&self) -> usize;
 
     /// Get [`BitSlice`] representation for deleted vectors with deletion flags
@@ -189,7 +213,7 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<()> {
+    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<bool> {
         match self {
             VectorStorageEnum::Simple(v) => v.delete_vec(key),
             VectorStorageEnum::Memmap(v) => v.delete_vec(key),

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 369587121..6553ccdbf 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -42,19 +42,21 @@ pub trait VectorStorage {
 
     fn distance(&self) -> Distance;
 
-    /// Number of vectors, marked as deleted but still stored
+    /// Number of vectors
+    ///
+    /// - includes soft deleted vectors, as they are still stored
     fn total_vector_count(&self) -> usize;
 
     /// Get the number of available vectors, considering deleted points and vectors
     ///
-    /// This uses [`total_vector_count`] and [`deleted_vec_count`] internally.
+    /// This uses [`total_vector_count`] and [`deleted_vector_count`] internally.
     ///
     /// # Warning
     ///
-    /// This number may not always be accurate. See warning in [`deleted_vec_count`] documentation.
-    fn available_vec_count(&self) -> usize {
+    /// This number may not always be accurate. See warning in [`deleted_vector_count`] documentation.
+    fn available_vector_count(&self) -> usize {
         self.total_vector_count()
-            .saturating_sub(self.deleted_vec_count())
+            .saturating_sub(self.deleted_vector_count())
     }
 
     /// Number of all stored vectors including deleted
@@ -90,11 +92,12 @@ pub trait VectorStorage {
     fn files(&self) -> Vec<PathBuf>;
 
     /// Flag the vector by the given key as deleted
+    ///
     /// Returns true if the vector was not deleted before and is now deleted
-    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<bool>;
+    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool>;
 
     /// Check whether the vector at the given key is flagged as deleted
-    fn is_deleted_vec(&self, key: PointOffsetType) -> bool;
+    fn is_deleted_vector(&self, key: PointOffsetType) -> bool;
 
     /// Get the number of deleted vectors, considering deleted points and vectors
     ///
@@ -102,19 +105,21 @@ pub trait VectorStorage {
     /// propagate to deleting the vectors. That means that the deleted vector count includes the
     /// number of deleted points as well.
     ///
+    /// This includes any vectors that were deleted at creation.
+    ///
     /// # Warning
     ///
     /// In some very exceptional cases it is possible for this count not to include some deleted
     /// points. That may happen when flushing a segment to disk fails. This should be recovered
     /// when loading/recovering the segment, but that isn't guaranteed. You should therefore use
     /// the deleted count with care.
-    fn deleted_vec_count(&self) -> usize;
+    fn deleted_vector_count(&self) -> usize;
 
     /// Get [`BitSlice`] representation for deleted vectors with deletion flags
     ///
     /// The size of this slice is not guaranteed. It may be smaller/larger than the number of
     /// vectors in this segment.
-    fn deleted_vec_bitslice(&self) -> &BitSlice;
+    fn deleted_vector_bitslice(&self) -> &BitSlice;
 }
 
 pub enum VectorStorageEnum {
@@ -213,31 +218,31 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn delete_vec(&mut self, key: PointOffsetType) -> OperationResult<bool> {
+    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
         match self {
-            VectorStorageEnum::Simple(v) => v.delete_vec(key),
-            VectorStorageEnum::Memmap(v) => v.delete_vec(key),
+            VectorStorageEnum::Simple(v) => v.delete_vector(key),
+            VectorStorageEnum::Memmap(v) => v.delete_vector(key),
         }
     }
 
-    fn is_deleted_vec(&self, key: PointOffsetType) -> bool {
+    fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
         match self {
-            VectorStorageEnum::Simple(v) => v.is_deleted_vec(key),
-            VectorStorageEnum::Memmap(v) => v.is_deleted_vec(key),
+            VectorStorageEnum::Simple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::Memmap(v) => v.is_deleted_vector(key),
         }
     }
 
-    fn deleted_vec_count(&self) -> usize {
+    fn deleted_vector_count(&self) -> usize {
         match self {
-            VectorStorageEnum::Simple(v) => v.deleted_vec_count(),
-            VectorStorageEnum::Memmap(v) => v.deleted_vec_count(),
+            VectorStorageEnum::Simple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::Memmap(v) => v.deleted_vector_count(),
         }
     }
 
-    fn deleted_vec_bitslice(&self) -> &BitSlice {
+    fn deleted_vector_bitslice(&self) -> &BitSlice {
         match self {
-            VectorStorageEnum::Simple(v) => v.deleted_vec_bitslice(),
-            VectorStorageEnum::Memmap(v) => v.deleted_vec_bitslice(),
+            VectorStorageEnum::Simple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::Memmap(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 45ae3e048b15f10e71b5825a9fc00ee7b7676390
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue May 9 18:01:01 2023 +0200

    Dynamic mmap vector storage (#1838)
    
    * wip: chunked mmap
    
    * Fix typo
    
    * insert and get methods
    
    * dynamic bitvec
    
    * clippy
    
    * wip: vector storage
    
    * wip: fmt
    
    * wip: mmap chunks
    
    * wip: mmap problems
    
    * Share transmuted mutable reference over mmap
    
    * option to enable appendable mmap vectors
    
    * fmt
    
    * rename storage status file
    
    * update tests
    
    * fix get deleted value range
    
    * add recovery to vector storage tests
    
    * add flush to tests
    
    * fix transmute from immutable to mutable
    
    * make transmuted pointer private
    
    * remove unused unsafe functions
    
    * force WAL flush if wait=true
    
    * move wal flush into updater thread
    
    * remove flush from update api
    
    * Minimize pub visibility for specialized/dangerous functions
    
    * Allocate vector with predefined capacity
    
    * Inline format parameters
    
    * Assert we have multiple chunks while testing, test is useless otherwise
    
    * Remove unnecessary scope
    
    * Remove unnecessary dereference
    
    * Random bool has 0.5 as standard distribution, use iter::repeat_with
    
    * Replace RemovableMmap::new with Default derive
    
    * Rename len to num_flags
    
    * Use Option replace as it is convention alongside take
    
    * Add FileId enum to replace error prone manual ID rotating
    
    * Use debug_assert_eq where applicable
    
    * Refactor drop and set to replace
    
    * Change default chunk size for chunked mmap vectors to 32MB
    
    This change is made as per GitHub review, because allocating a few
    storages with 128MB would take a significant amount of time and storage.
    
    See: https://github.com/qdrant/qdrant/pull/1838#discussion_r1187215475
    
    * Replace for-loops with iterators
    
    * Draft: add typed mmap to improve code safety (#1860)
    
    * Add typed mmap
    
    * Replace some crude mmap usages with typed mmap
    
    * Use typed mmap for deleted flags
    
    * Simplify dynamic mmap flags a lot with new typed mmap, remove flags option
    
    * Reformat
    
    * Remove old mmap functions that are now unused
    
    * Reimplement mmap locking for mmap_vectors
    
    * Add MmapBitSlice tests
    
    * Replace MmapChunk with new typed mmap
    
    * Update docs
    
    * Clean-up
    
    * Disable alignment assertions on Windows for now
    
    * Rename mmap lock to mlock to prevent confusion with lockable types
    
    * one more small test
    
    * Some review fixes
    
    * Add aliasing note
    
    * Add basic error handling in typed mmap constructors
    
    * Use typed mmap error handling throughout project
    
    * Move mmap type module to common
    
    * Fix transmute functions being unsound
    
    See https://github.com/qdrant/qdrant/pull/1860#discussion_r1188593854
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 6553ccdbf..8cc759d86 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -13,6 +13,7 @@ use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
 use crate::types::{Distance, PointOffsetType, QuantizationConfig, ScoreType};
+use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
 
 #[derive(Copy, Clone, PartialEq, Debug, Default)]
 pub struct ScoredPointOffset {
@@ -125,6 +126,7 @@ pub trait VectorStorage {
 pub enum VectorStorageEnum {
     Simple(SimpleVectorStorage),
     Memmap(Box<MemmapVectorStorage>),
+    AppendableMemmap(Box<AppendableMmapVectorStorage>),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -132,6 +134,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.vector_dim(),
             VectorStorageEnum::Memmap(v) => v.vector_dim(),
+            VectorStorageEnum::AppendableMemmap(v) => v.vector_dim(),
         }
     }
 
@@ -139,6 +142,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.distance(),
             VectorStorageEnum::Memmap(v) => v.distance(),
+            VectorStorageEnum::AppendableMemmap(v) => v.distance(),
         }
     }
 
@@ -146,6 +150,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.total_vector_count(),
             VectorStorageEnum::Memmap(v) => v.total_vector_count(),
+            VectorStorageEnum::AppendableMemmap(v) => v.total_vector_count(),
         }
     }
 
@@ -153,6 +158,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),
+            VectorStorageEnum::AppendableMemmap(v) => v.get_vector(key),
         }
     }
 
@@ -164,6 +170,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::AppendableMemmap(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -176,6 +183,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::Memmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::AppendableMemmap(v) => v.update_from(other, other_ids, stopped),
         }
     }
 
@@ -183,6 +191,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.flusher(),
             VectorStorageEnum::Memmap(v) => v.flusher(),
+            VectorStorageEnum::AppendableMemmap(v) => v.flusher(),
         }
     }
 
@@ -194,6 +203,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.quantize(data_path, quantization_config),
             VectorStorageEnum::Memmap(v) => v.quantize(data_path, quantization_config),
+            VectorStorageEnum::AppendableMemmap(v) => v.quantize(data_path, quantization_config),
         }
     }
 
@@ -201,6 +211,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.load_quantization(data_path),
             VectorStorageEnum::Memmap(v) => v.load_quantization(data_path),
+            VectorStorageEnum::AppendableMemmap(v) => v.load_quantization(data_path),
         }
     }
 
@@ -208,6 +219,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.quantized_storage(),
             VectorStorageEnum::Memmap(v) => v.quantized_storage(),
+            VectorStorageEnum::AppendableMemmap(v) => v.quantized_storage(),
         }
     }
 
@@ -215,6 +227,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.files(),
             VectorStorageEnum::Memmap(v) => v.files(),
+            VectorStorageEnum::AppendableMemmap(v) => v.files(),
         }
     }
 
@@ -222,6 +235,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.delete_vector(key),
             VectorStorageEnum::Memmap(v) => v.delete_vector(key),
+            VectorStorageEnum::AppendableMemmap(v) => v.delete_vector(key),
         }
     }
 
@@ -229,6 +243,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::Memmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::AppendableMemmap(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -236,6 +251,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.deleted_vector_count(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_count(),
         }
     }
 
@@ -243,6 +259,7 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::Simple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 75cb07c7e490f7654fe5908a9c8862e0912e0c99
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 10 20:20:52 2023 +0400

    Product quantization (#1615)
    
    * product quantization
    
    * update quantization version
    
    * refactor
    
    * change api
    
    * PQ -> product rename
    
    * fix grpc comment
    
    * fix tests
    
    * are you happy clippy
    
    * quantization version up
    
    * update quantization
    
    * provide max threads for kmeans
    
    * fix test build
    
    * pq unit tests
    
    * update quantization lib
    
    * update quantization version
    
    * update deleted flags for quantized raw scorer
    
    * fix build
    
    * are you happy fmt
    
    * update grpc docs
    
    * update openapi
    
    * restore storage_builder.try_reserve_exact
    
    * Update lib/segment/src/segment_constructor/segment_builder.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Update lib/segment/src/vector_storage/quantized/quantized_raw_scorer.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * change pub to pub(super)
    
    * Update lib/segment/src/vector_storage/quantized/quantized_vectors.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * rename to config_exists
    
    * Product quantization compression api (#1834)
    
    * product quantization compression api
    
    * update openapi and grpc docs
    
    * Update lib/api/src/grpc/proto/collections.proto
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * fix test build
    
    * are you happy fmt
    
    * update grpc docs
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * product quantization with stopper (#1874)
    
    * product quantization with stopper
    
    * quantization version up
    
    * fix build
    
    * small comment fix
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 8cc759d86..cb9dc9648 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -7,7 +7,7 @@ use bitvec::prelude::BitSlice;
 use ordered_float::OrderedFloat;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
-use super::quantized::quantized_vectors_base::QuantizedVectorsStorage;
+use super::quantized::quantized_vectors::QuantizedVectors;
 use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
@@ -83,12 +83,14 @@ pub trait VectorStorage {
         &mut self,
         data_path: &Path,
         quantization_config: &QuantizationConfig,
+        max_threads: usize,
+        stopped: &AtomicBool,
     ) -> OperationResult<()>;
 
     // Load quantized vectors from disk
     fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()>;
 
-    fn quantized_storage(&self) -> Option<&QuantizedVectorsStorage>;
+    fn quantized_storage(&self) -> Option<&QuantizedVectors>;
 
     fn files(&self) -> Vec<PathBuf>;
 
@@ -199,11 +201,19 @@ impl VectorStorage for VectorStorageEnum {
         &mut self,
         data_path: &Path,
         quantization_config: &QuantizationConfig,
+        max_threads: usize,
+        stopped: &AtomicBool,
     ) -> OperationResult<()> {
         match self {
-            VectorStorageEnum::Simple(v) => v.quantize(data_path, quantization_config),
-            VectorStorageEnum::Memmap(v) => v.quantize(data_path, quantization_config),
-            VectorStorageEnum::AppendableMemmap(v) => v.quantize(data_path, quantization_config),
+            VectorStorageEnum::Simple(v) => {
+                v.quantize(data_path, quantization_config, max_threads, stopped)
+            }
+            VectorStorageEnum::Memmap(v) => {
+                v.quantize(data_path, quantization_config, max_threads, stopped)
+            }
+            VectorStorageEnum::AppendableMemmap(v) => {
+                v.quantize(data_path, quantization_config, max_threads, stopped)
+            }
         }
     }
 
@@ -215,7 +225,7 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn quantized_storage(&self) -> Option<&QuantizedVectorsStorage> {
+    fn quantized_storage(&self) -> Option<&QuantizedVectors> {
         match self {
             VectorStorageEnum::Simple(v) => v.quantized_storage(),
             VectorStorageEnum::Memmap(v) => v.quantized_storage(),

commit df711b7c2e64ec4baf9c086fab2ba68dcdf0966e
Author: Tim Visée <tim+github@visee.me>
Date:   Wed May 17 09:49:55 2023 +0200

    Refactor segment config (#1894)
    
    * Clone current segment config to deprecated type
    
    * Remove segment level quantization config from segment config
    
    * Also deprecate current VectorDataConfig
    
    * Update old segment migration to work with new refactoring
    
    * Move index into vector data config
    
    * Move vector data config migration logic into segment level
    
    * Remove hnsw_config from vector data config
    
    * Rename collection params to vector data conversions function
    
    * Move storage type into vector data config
    
    * Set appendable flag correctly
    
    * Clean up and reformat
    
    * Make segment on disk flag not optional
    
    * Add appendable flag to segment config to replace storage type
    
    * Remove storage type from segment config
    
    * Deprecate storage type enum
    
    * Use consistent variable naming
    
    * Cleanup
    
    * Add segment config migration for v0.5.0 to current
    
    * Bump segment to 0.6.0
    
    * Remove serde defaults for new storage and vector data config types
    
    These default value configurations are not needed anymore, because these
    structs are not used to deserialize old data. All current fields should
    always be available in these structs. When new fields are added in new
    functions, the serde default annotation must be set again.
    
    * Cleanup
    
    * Update OpenAPI specification
    
    This updates the returned data structure on telemetry endpoints, as a
    result of segment configuration refactoring.
    
    * Fix quantization configuration not falling back to collection config
    
    * Fix compiler warning when building in release mode
    
    * Move deprecated type structs into compat module
    
    * Update allow deprecated attributes
    
    * Assign quantization config only in segment optimizer
    
    * Remove unsued parameter
    
    * Add vector storage type enum to vector data config
    
    * Remove appendable and on_disk flags from segment and vector config
    
    * Update OpenAPI specification
    
    * add tests
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index cb9dc9648..fed15bbcb 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -123,6 +123,9 @@ pub trait VectorStorage {
     /// The size of this slice is not guaranteed. It may be smaller/larger than the number of
     /// vectors in this segment.
     fn deleted_vector_bitslice(&self) -> &BitSlice;
+
+    /// Whether this vector storage type support appending.
+    fn is_appendable(&self) -> bool;
 }
 
 pub enum VectorStorageEnum {
@@ -272,4 +275,12 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
         }
     }
+
+    fn is_appendable(&self) -> bool {
+        match self {
+            VectorStorageEnum::Simple(v) => v.is_appendable(),
+            VectorStorageEnum::Memmap(v) => v.is_appendable(),
+            VectorStorageEnum::AppendableMemmap(v) => v.is_appendable(),
+        }
+    }
 }

commit a048be2217e6b71a966c2a656c584e0af0a0023e
Author: Tim <dev@timsueberkrueb.io>
Date:   Mon Jun 5 10:20:21 2023 +0200

    Fix warnings pointed out by `cargo doc` (#1997)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index fed15bbcb..e42470f57 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -50,11 +50,11 @@ pub trait VectorStorage {
 
     /// Get the number of available vectors, considering deleted points and vectors
     ///
-    /// This uses [`total_vector_count`] and [`deleted_vector_count`] internally.
+    /// This uses [`VectorStorage::total_vector_count`] and [`VectorStorage::deleted_vector_count`] internally.
     ///
     /// # Warning
     ///
-    /// This number may not always be accurate. See warning in [`deleted_vector_count`] documentation.
+    /// This number may not always be accurate. See warning in [`VectorStorage::deleted_vector_count`] documentation.
     fn available_vector_count(&self) -> usize {
         self.total_vector_count()
             .saturating_sub(self.deleted_vector_count())

commit 8ef51525235655112ab08adac644455d86a3d608
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Sep 4 15:24:52 2023 +0200

    immutable map index integration (#2524)
    
    * immutable map index integration
    
    * remove wipe
    
    * fix unit tests
    
    * get appendable flag from config
    
    * minor refactoring
    
    * fix chunked mmap appendable flag
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index e42470f57..640f43dac 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -123,9 +123,6 @@ pub trait VectorStorage {
     /// The size of this slice is not guaranteed. It may be smaller/larger than the number of
     /// vectors in this segment.
     fn deleted_vector_bitslice(&self) -> &BitSlice;
-
-    /// Whether this vector storage type support appending.
-    fn is_appendable(&self) -> bool;
 }
 
 pub enum VectorStorageEnum {
@@ -275,12 +272,4 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
         }
     }
-
-    fn is_appendable(&self) -> bool {
-        match self {
-            VectorStorageEnum::Simple(v) => v.is_appendable(),
-            VectorStorageEnum::Memmap(v) => v.is_appendable(),
-            VectorStorageEnum::AppendableMemmap(v) => v.is_appendable(),
-        }
-    }
 }

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 640f43dac..22c7ca7e5 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,10 +1,9 @@
-use std::cmp::Ordering;
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
-use ordered_float::OrderedFloat;
+use common::types::PointOffsetType;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
 use super::quantized::quantized_vectors::QuantizedVectors;
@@ -12,29 +11,9 @@ use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
 use crate::entry::entry_point::OperationResult;
-use crate::types::{Distance, PointOffsetType, QuantizationConfig, ScoreType};
+use crate::types::{Distance, QuantizationConfig};
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
 
-#[derive(Copy, Clone, PartialEq, Debug, Default)]
-pub struct ScoredPointOffset {
-    pub idx: PointOffsetType,
-    pub score: ScoreType,
-}
-
-impl Eq for ScoredPointOffset {}
-
-impl Ord for ScoredPointOffset {
-    fn cmp(&self, other: &Self) -> Ordering {
-        OrderedFloat(self.score).cmp(&OrderedFloat(other.score))
-    }
-}
-
-impl PartialOrd for ScoredPointOffset {
-    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
-        Some(self.cmp(other))
-    }
-}
-
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type
 /// Storage operates with internal IDs (`PointOffsetType`), which always starts with zero and have no skips

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 22c7ca7e5..2a9f0f205 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -8,9 +8,9 @@ use common::types::PointOffsetType;
 use super::memmap_vector_storage::MemmapVectorStorage;
 use super::quantized::quantized_vectors::QuantizedVectors;
 use super::simple_vector_storage::SimpleVectorStorage;
+use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
-use crate::entry::entry_point::OperationResult;
 use crate::types::{Distance, QuantizationConfig};
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
 

commit 047e4bb8bec7d2526c26ce866cc56e1f2bf816ed
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 12 11:21:34 2023 +0200

    Quantization storage as separate entity (#2797)
    
    * quantization storage as separate entity
    
    * simplify max threads calculation

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 2a9f0f205..f63341550 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,17 +1,16 @@
 use std::ops::Range;
-use std::path::{Path, PathBuf};
+use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
-use super::quantized::quantized_vectors::QuantizedVectors;
 use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::vectors::VectorElementType;
-use crate::types::{Distance, QuantizationConfig};
+use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
 
 /// Trait for vector storage
@@ -22,6 +21,8 @@ pub trait VectorStorage {
 
     fn distance(&self) -> Distance;
 
+    fn is_on_disk(&self) -> bool;
+
     /// Number of vectors
     ///
     /// - includes soft deleted vectors, as they are still stored
@@ -57,20 +58,6 @@ pub trait VectorStorage {
 
     fn flusher(&self) -> Flusher;
 
-    // Generate quantized vectors and store them on disk
-    fn quantize(
-        &mut self,
-        data_path: &Path,
-        quantization_config: &QuantizationConfig,
-        max_threads: usize,
-        stopped: &AtomicBool,
-    ) -> OperationResult<()>;
-
-    // Load quantized vectors from disk
-    fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()>;
-
-    fn quantized_storage(&self) -> Option<&QuantizedVectors>;
-
     fn files(&self) -> Vec<PathBuf>;
 
     /// Flag the vector by the given key as deleted
@@ -127,6 +114,14 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
+    fn is_on_disk(&self) -> bool {
+        match self {
+            VectorStorageEnum::Simple(v) => v.is_on_disk(),
+            VectorStorageEnum::Memmap(v) => v.is_on_disk(),
+            VectorStorageEnum::AppendableMemmap(v) => v.is_on_disk(),
+        }
+    }
+
     fn total_vector_count(&self) -> usize {
         match self {
             VectorStorageEnum::Simple(v) => v.total_vector_count(),
@@ -176,42 +171,6 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn quantize(
-        &mut self,
-        data_path: &Path,
-        quantization_config: &QuantizationConfig,
-        max_threads: usize,
-        stopped: &AtomicBool,
-    ) -> OperationResult<()> {
-        match self {
-            VectorStorageEnum::Simple(v) => {
-                v.quantize(data_path, quantization_config, max_threads, stopped)
-            }
-            VectorStorageEnum::Memmap(v) => {
-                v.quantize(data_path, quantization_config, max_threads, stopped)
-            }
-            VectorStorageEnum::AppendableMemmap(v) => {
-                v.quantize(data_path, quantization_config, max_threads, stopped)
-            }
-        }
-    }
-
-    fn load_quantization(&mut self, data_path: &Path) -> OperationResult<()> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.load_quantization(data_path),
-            VectorStorageEnum::Memmap(v) => v.load_quantization(data_path),
-            VectorStorageEnum::AppendableMemmap(v) => v.load_quantization(data_path),
-        }
-    }
-
-    fn quantized_storage(&self) -> Option<&QuantizedVectors> {
-        match self {
-            VectorStorageEnum::Simple(v) => v.quantized_storage(),
-            VectorStorageEnum::Memmap(v) => v.quantized_storage(),
-            VectorStorageEnum::AppendableMemmap(v) => v.quantized_storage(),
-        }
-    }
-
     fn files(&self) -> Vec<PathBuf> {
         match self {
             VectorStorageEnum::Simple(v) => v.files(),

commit 3a1a4343273e9883c33c620d77e926e24ec3d2da
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Oct 13 22:30:49 2023 +0200

    dense vector storage (#2817)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index f63341550..402c4437b 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -91,6 +91,10 @@ pub trait VectorStorage {
     fn deleted_vector_bitslice(&self) -> &BitSlice;
 }
 
+pub trait DenseVectorStorage: VectorStorage {
+    fn get_dense(&self, key: PointOffsetType) -> &[VectorElementType];
+}
+
 pub enum VectorStorageEnum {
     Simple(SimpleVectorStorage),
     Memmap(Box<MemmapVectorStorage>),

commit 5517cfbc9aa3923bea72ecac05c62eb1c72ee387
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 19 14:49:31 2023 +0200

    Use enum vector type in vector storage (#2841)
    
    * use enum vector type in vector storage
    
    * add to_vec_ref

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 402c4437b..7ad095e94 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -9,7 +9,7 @@ use super::memmap_vector_storage::MemmapVectorStorage;
 use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
-use crate::data_types::vectors::VectorElementType;
+use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
 
@@ -41,13 +41,9 @@ pub trait VectorStorage {
     }
 
     /// Number of all stored vectors including deleted
-    fn get_vector(&self, key: PointOffsetType) -> &[VectorElementType];
+    fn get_vector(&self, key: PointOffsetType) -> VectorRef;
 
-    fn insert_vector(
-        &mut self,
-        key: PointOffsetType,
-        vector: &[VectorElementType],
-    ) -> OperationResult<()>;
+    fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
     fn update_from(
         &mut self,
@@ -134,7 +130,7 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn get_vector(&self, key: PointOffsetType) -> &[VectorElementType] {
+    fn get_vector(&self, key: PointOffsetType) -> VectorRef {
         match self {
             VectorStorageEnum::Simple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),
@@ -142,11 +138,7 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn insert_vector(
-        &mut self,
-        key: PointOffsetType,
-        vector: &[VectorElementType],
-    ) -> OperationResult<()> {
+    fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
         match self {
             VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),

commit cc69ec7fec5b8ec3d1b2cf4f63fdac33bf1c50da
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Oct 30 11:27:36 2023 +0100

    Simple sparse vector storage (#2806)
    
    * Simple sparse vector storage
    
    * better todo

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 7ad095e94..d25af4cf4 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -12,6 +12,7 @@ use crate::common::Flusher;
 use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
+use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type
@@ -40,7 +41,7 @@ pub trait VectorStorage {
             .saturating_sub(self.deleted_vector_count())
     }
 
-    /// Number of all stored vectors including deleted
+    /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> VectorRef;
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
@@ -95,6 +96,7 @@ pub enum VectorStorageEnum {
     Simple(SimpleVectorStorage),
     Memmap(Box<MemmapVectorStorage>),
     AppendableMemmap(Box<AppendableMmapVectorStorage>),
+    SparseSimple(SimpleSparseVectorStorage),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -103,6 +105,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.vector_dim(),
             VectorStorageEnum::Memmap(v) => v.vector_dim(),
             VectorStorageEnum::AppendableMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
         }
     }
 
@@ -111,6 +114,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.distance(),
             VectorStorageEnum::Memmap(v) => v.distance(),
             VectorStorageEnum::AppendableMemmap(v) => v.distance(),
+            VectorStorageEnum::SparseSimple(v) => v.distance(),
         }
     }
 
@@ -119,6 +123,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.is_on_disk(),
             VectorStorageEnum::Memmap(v) => v.is_on_disk(),
             VectorStorageEnum::AppendableMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
         }
     }
 
@@ -127,6 +132,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.total_vector_count(),
             VectorStorageEnum::Memmap(v) => v.total_vector_count(),
             VectorStorageEnum::AppendableMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
         }
     }
 
@@ -135,6 +141,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
         }
     }
 
@@ -143,6 +150,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::AppendableMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -156,6 +164,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::Memmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::AppendableMemmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
         }
     }
 
@@ -164,6 +173,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.flusher(),
             VectorStorageEnum::Memmap(v) => v.flusher(),
             VectorStorageEnum::AppendableMemmap(v) => v.flusher(),
+            VectorStorageEnum::SparseSimple(v) => v.flusher(),
         }
     }
 
@@ -172,6 +182,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.files(),
             VectorStorageEnum::Memmap(v) => v.files(),
             VectorStorageEnum::AppendableMemmap(v) => v.files(),
+            VectorStorageEnum::SparseSimple(v) => v.files(),
         }
     }
 
@@ -180,6 +191,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.delete_vector(key),
             VectorStorageEnum::Memmap(v) => v.delete_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
         }
     }
 
@@ -188,6 +200,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::Memmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -196,6 +209,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.deleted_vector_count(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
         }
     }
 
@@ -204,6 +218,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::Simple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit cbf1811eaa3e2e0de68c07fb2cd484a16faf8b3d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Nov 2 14:59:18 2023 +0100

    Raw scorer for sparse vectors (#2915)
    
    * Raw scorer for sparse vectors
    
    * sparse vector storage trait
    
    * use get sparse vector fn
    
    * remove dedicated types
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index d25af4cf4..0c1994ef2 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -4,6 +4,7 @@ use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
+use sparse::common::sparse_vector::SparseVector;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
 use super::simple_vector_storage::SimpleVectorStorage;
@@ -92,6 +93,10 @@ pub trait DenseVectorStorage: VectorStorage {
     fn get_dense(&self, key: PointOffsetType) -> &[VectorElementType];
 }
 
+pub trait SparseVectorStorage: VectorStorage {
+    fn get_sparse(&self, key: PointOffsetType) -> &SparseVector;
+}
+
 pub enum VectorStorageEnum {
     Simple(SimpleVectorStorage),
     Memmap(Box<MemmapVectorStorage>),

commit 684c58fbdc62a1abe7ed54e70277592457867507
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Nov 30 17:48:19 2023 +0100

    Sparse vector storage rocksdb only (#3112)
    
    * sparse vector storage rocksdb only
    
    * fix build
    
    * spelling fix
    
    * simplify get_cf
    
    * restore deleted flags loading

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 0c1994ef2..ec343b422 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -10,6 +10,7 @@ use super::memmap_vector_storage::MemmapVectorStorage;
 use super::simple_vector_storage::SimpleVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
+use crate::data_types::named_vectors::CowVector;
 use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
@@ -43,7 +44,7 @@ pub trait VectorStorage {
     }
 
     /// Get the vector by the given key
-    fn get_vector(&self, key: PointOffsetType) -> VectorRef;
+    fn get_vector(&self, key: PointOffsetType) -> CowVector;
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
@@ -94,7 +95,7 @@ pub trait DenseVectorStorage: VectorStorage {
 }
 
 pub trait SparseVectorStorage: VectorStorage {
-    fn get_sparse(&self, key: PointOffsetType) -> &SparseVector;
+    fn get_sparse(&self, key: PointOffsetType) -> SparseVector;
 }
 
 pub enum VectorStorageEnum {
@@ -141,7 +142,7 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn get_vector(&self, key: PointOffsetType) -> VectorRef {
+    fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
             VectorStorageEnum::Simple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),

commit a229f2a56d945db6febbeb62e582b6b008ba05c6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Dec 7 14:47:53 2023 +0100

    Sparse vector index build handles missing points in storage (#3178)
    
    * Sparse vector index build handle missing points in storage
    
    * review
    
    * spelling bee

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index ec343b422..2e8e4ef85 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -46,6 +46,12 @@ pub trait VectorStorage {
     /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
 
+    /// Get the vector by the given key if it exists
+    /// Blanket implementation - override if necessary
+    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
+        Some(self.get_vector(key))
+    }
+
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
     fn update_from(
@@ -95,7 +101,7 @@ pub trait DenseVectorStorage: VectorStorage {
 }
 
 pub trait SparseVectorStorage: VectorStorage {
-    fn get_sparse(&self, key: PointOffsetType) -> SparseVector;
+    fn get_sparse(&self, key: PointOffsetType) -> OperationResult<SparseVector>;
 }
 
 pub enum VectorStorageEnum {
@@ -151,6 +157,15 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
+    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
+        match self {
+            VectorStorageEnum::Simple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::Memmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::AppendableMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
+        }
+    }
+
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
         match self {
             VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),

commit 8c93500998e7fb1fa8d6435d6561dd4316ab7b2d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 13 17:08:37 2023 +0000

    Rename SimpleDenseVectorStorage (#3223)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 2e8e4ef85..673c3defe 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -7,7 +7,7 @@ use common::types::PointOffsetType;
 use sparse::common::sparse_vector::SparseVector;
 
 use super::memmap_vector_storage::MemmapVectorStorage;
-use super::simple_vector_storage::SimpleVectorStorage;
+use super::simple_dense_vector_storage::SimpleDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
@@ -105,7 +105,7 @@ pub trait SparseVectorStorage: VectorStorage {
 }
 
 pub enum VectorStorageEnum {
-    Simple(SimpleVectorStorage),
+    DenseSimple(SimpleDenseVectorStorage),
     Memmap(Box<MemmapVectorStorage>),
     AppendableMemmap(Box<AppendableMmapVectorStorage>),
     SparseSimple(SimpleSparseVectorStorage),
@@ -114,7 +114,7 @@ pub enum VectorStorageEnum {
 impl VectorStorage for VectorStorageEnum {
     fn vector_dim(&self) -> usize {
         match self {
-            VectorStorageEnum::Simple(v) => v.vector_dim(),
+            VectorStorageEnum::DenseSimple(v) => v.vector_dim(),
             VectorStorageEnum::Memmap(v) => v.vector_dim(),
             VectorStorageEnum::AppendableMemmap(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
@@ -123,7 +123,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn distance(&self) -> Distance {
         match self {
-            VectorStorageEnum::Simple(v) => v.distance(),
+            VectorStorageEnum::DenseSimple(v) => v.distance(),
             VectorStorageEnum::Memmap(v) => v.distance(),
             VectorStorageEnum::AppendableMemmap(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
@@ -132,7 +132,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn is_on_disk(&self) -> bool {
         match self {
-            VectorStorageEnum::Simple(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::Memmap(v) => v.is_on_disk(),
             VectorStorageEnum::AppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
@@ -141,7 +141,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn total_vector_count(&self) -> usize {
         match self {
-            VectorStorageEnum::Simple(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::Memmap(v) => v.total_vector_count(),
             VectorStorageEnum::AppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
@@ -150,7 +150,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
-            VectorStorageEnum::Simple(v) => v.get_vector(key),
+            VectorStorageEnum::DenseSimple(v) => v.get_vector(key),
             VectorStorageEnum::Memmap(v) => v.get_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
@@ -159,7 +159,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
         match self {
-            VectorStorageEnum::Simple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::Memmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::AppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
@@ -168,7 +168,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
         match self {
-            VectorStorageEnum::Simple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::AppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
@@ -182,7 +182,7 @@ impl VectorStorage for VectorStorageEnum {
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
-            VectorStorageEnum::Simple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::Memmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::AppendableMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
@@ -191,7 +191,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn flusher(&self) -> Flusher {
         match self {
-            VectorStorageEnum::Simple(v) => v.flusher(),
+            VectorStorageEnum::DenseSimple(v) => v.flusher(),
             VectorStorageEnum::Memmap(v) => v.flusher(),
             VectorStorageEnum::AppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
@@ -200,7 +200,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn files(&self) -> Vec<PathBuf> {
         match self {
-            VectorStorageEnum::Simple(v) => v.files(),
+            VectorStorageEnum::DenseSimple(v) => v.files(),
             VectorStorageEnum::Memmap(v) => v.files(),
             VectorStorageEnum::AppendableMemmap(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
@@ -209,7 +209,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
         match self {
-            VectorStorageEnum::Simple(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::Memmap(v) => v.delete_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
@@ -218,7 +218,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
         match self {
-            VectorStorageEnum::Simple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::Memmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::AppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
@@ -227,7 +227,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn deleted_vector_count(&self) -> usize {
         match self {
-            VectorStorageEnum::Simple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
@@ -236,7 +236,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn deleted_vector_bitslice(&self) -> &BitSlice {
         match self {
-            VectorStorageEnum::Simple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::Memmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),

commit 016a80cafd38c1c4bc953e3ec5bd38b066c83cf6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Feb 26 13:18:16 2024 -0300

    refactor: dyn -> impl in vector storage (#3690)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 673c3defe..05fc172b4 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -57,7 +57,7 @@ pub trait VectorStorage {
     fn update_from(
         &mut self,
         other: &VectorStorageEnum,
-        other_ids: &mut dyn Iterator<Item = PointOffsetType>,
+        other_ids: &mut impl Iterator<Item = PointOffsetType>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
 
@@ -178,7 +178,7 @@ impl VectorStorage for VectorStorageEnum {
     fn update_from(
         &mut self,
         other: &VectorStorageEnum,
-        other_ids: &mut dyn Iterator<Item = PointOffsetType>,
+        other_ids: &mut impl Iterator<Item = PointOffsetType>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {

commit d1d69d12e6d9b8c0f8d2302c494bc7c1e2601e40
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Feb 28 12:30:44 2024 +0100

    Clearer names for dense storage implementations (#3712)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 05fc172b4..9b544424b 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -6,14 +6,14 @@ use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 use sparse::common::sparse_vector::SparseVector;
 
-use super::memmap_vector_storage::MemmapVectorStorage;
+use super::memmap_dense_vector_storage::MemmapDenseVectorStorage;
 use super::simple_dense_vector_storage::SimpleDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::Distance;
-use crate::vector_storage::appendable_mmap_vector_storage::AppendableMmapVectorStorage;
+use crate::vector_storage::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
@@ -106,8 +106,8 @@ pub trait SparseVectorStorage: VectorStorage {
 
 pub enum VectorStorageEnum {
     DenseSimple(SimpleDenseVectorStorage),
-    Memmap(Box<MemmapVectorStorage>),
-    AppendableMemmap(Box<AppendableMmapVectorStorage>),
+    DenseMemmap(Box<MemmapDenseVectorStorage>),
+    DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage>),
     SparseSimple(SimpleSparseVectorStorage),
 }
 
@@ -115,8 +115,8 @@ impl VectorStorage for VectorStorageEnum {
     fn vector_dim(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.vector_dim(),
-            VectorStorageEnum::Memmap(v) => v.vector_dim(),
-            VectorStorageEnum::AppendableMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::DenseMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
         }
     }
@@ -124,8 +124,8 @@ impl VectorStorage for VectorStorageEnum {
     fn distance(&self) -> Distance {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.distance(),
-            VectorStorageEnum::Memmap(v) => v.distance(),
-            VectorStorageEnum::AppendableMemmap(v) => v.distance(),
+            VectorStorageEnum::DenseMemmap(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
         }
     }
@@ -133,8 +133,8 @@ impl VectorStorage for VectorStorageEnum {
     fn is_on_disk(&self) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),
-            VectorStorageEnum::Memmap(v) => v.is_on_disk(),
-            VectorStorageEnum::AppendableMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
         }
     }
@@ -142,8 +142,8 @@ impl VectorStorage for VectorStorageEnum {
     fn total_vector_count(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.total_vector_count(),
-            VectorStorageEnum::Memmap(v) => v.total_vector_count(),
-            VectorStorageEnum::AppendableMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
         }
     }
@@ -151,8 +151,8 @@ impl VectorStorage for VectorStorageEnum {
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector(key),
-            VectorStorageEnum::Memmap(v) => v.get_vector(key),
-            VectorStorageEnum::AppendableMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::DenseMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
         }
     }
@@ -160,8 +160,8 @@ impl VectorStorage for VectorStorageEnum {
     fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector_opt(key),
-            VectorStorageEnum::Memmap(v) => v.get_vector_opt(key),
-            VectorStorageEnum::AppendableMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
         }
     }
@@ -169,8 +169,8 @@ impl VectorStorage for VectorStorageEnum {
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::Memmap(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::AppendableMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
         }
     }
@@ -183,8 +183,8 @@ impl VectorStorage for VectorStorageEnum {
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::Memmap(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::AppendableMemmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseMemmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
         }
     }
@@ -192,8 +192,8 @@ impl VectorStorage for VectorStorageEnum {
     fn flusher(&self) -> Flusher {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.flusher(),
-            VectorStorageEnum::Memmap(v) => v.flusher(),
-            VectorStorageEnum::AppendableMemmap(v) => v.flusher(),
+            VectorStorageEnum::DenseMemmap(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
         }
     }
@@ -201,8 +201,8 @@ impl VectorStorage for VectorStorageEnum {
     fn files(&self) -> Vec<PathBuf> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.files(),
-            VectorStorageEnum::Memmap(v) => v.files(),
-            VectorStorageEnum::AppendableMemmap(v) => v.files(),
+            VectorStorageEnum::DenseMemmap(v) => v.files(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
         }
     }
@@ -210,8 +210,8 @@ impl VectorStorage for VectorStorageEnum {
     fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.delete_vector(key),
-            VectorStorageEnum::Memmap(v) => v.delete_vector(key),
-            VectorStorageEnum::AppendableMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
         }
     }
@@ -219,8 +219,8 @@ impl VectorStorage for VectorStorageEnum {
     fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_deleted_vector(key),
-            VectorStorageEnum::Memmap(v) => v.is_deleted_vector(key),
-            VectorStorageEnum::AppendableMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
         }
     }
@@ -228,8 +228,8 @@ impl VectorStorage for VectorStorageEnum {
     fn deleted_vector_count(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_count(),
-            VectorStorageEnum::Memmap(v) => v.deleted_vector_count(),
-            VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
         }
     }
@@ -237,8 +237,8 @@ impl VectorStorage for VectorStorageEnum {
     fn deleted_vector_bitslice(&self) -> &BitSlice {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_bitslice(),
-            VectorStorageEnum::Memmap(v) => v.deleted_vector_bitslice(),
-            VectorStorageEnum::AppendableMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
         }
     }

commit 1808d2a9c11c1d67aaa43febbe0191681c4b48ae
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Mar 20 19:11:22 2024 +0100

    Multi dense vector simple storage (#3718)
    
    * Multi dense vector simple storage
    
    * code review first pass
    
    * fix in-memory storage
    
    * comment type
    
    * fix vector insertion for open as well

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 9b544424b..151aed142 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -14,6 +14,7 @@ use crate::data_types::named_vectors::CowVector;
 use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
+use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
@@ -109,6 +110,7 @@ pub enum VectorStorageEnum {
     DenseMemmap(Box<MemmapDenseVectorStorage>),
     DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage>),
     SparseSimple(SimpleSparseVectorStorage),
+    MultiDenseSimple(SimpleMultiDenseVectorStorage),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -118,6 +120,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.vector_dim(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
         }
     }
 
@@ -127,6 +130,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
         }
     }
 
@@ -136,6 +140,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
         }
     }
 
@@ -145,6 +150,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
         }
     }
 
@@ -154,6 +160,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
         }
     }
 
@@ -163,6 +170,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
         }
     }
 
@@ -172,6 +180,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -186,6 +195,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
         }
     }
 
@@ -195,6 +205,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
         }
     }
 
@@ -204,6 +215,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.files(),
         }
     }
 
@@ -213,6 +225,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
         }
     }
 
@@ -222,6 +235,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -231,6 +245,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
         }
     }
 
@@ -240,6 +255,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 77ef7b473041e1f89030b760639f2ff25fe5838a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 21 10:31:57 2024 +0100

    colbert query scorers (#3713)
    
    * colbert query scorers
    
    fix build after rebase
    
    * review remarks

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 151aed142..6529030df 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -11,7 +11,7 @@ use super::simple_dense_vector_storage::SimpleDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
-use crate::data_types::vectors::{VectorElementType, VectorRef};
+use crate::data_types::vectors::{MultiDenseVector, VectorElementType, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
@@ -105,6 +105,10 @@ pub trait SparseVectorStorage: VectorStorage {
     fn get_sparse(&self, key: PointOffsetType) -> OperationResult<SparseVector>;
 }
 
+pub trait MultiVectorStorage: VectorStorage {
+    fn get_multi(&self, key: PointOffsetType) -> &MultiDenseVector;
+}
+
 pub enum VectorStorageEnum {
     DenseSimple(SimpleDenseVectorStorage),
     DenseMemmap(Box<MemmapDenseVectorStorage>),

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 6529030df..f1aa9538a 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -6,14 +6,15 @@ use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 use sparse::common::sparse_vector::SparseVector;
 
-use super::memmap_dense_vector_storage::MemmapDenseVectorStorage;
-use super::simple_dense_vector_storage::SimpleDenseVectorStorage;
+use super::dense::memmap_dense_vector_storage::MemmapDenseVectorStorage;
+use super::dense::simple_dense_vector_storage::SimpleDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
+use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{MultiDenseVector, VectorElementType, VectorRef};
 use crate::types::Distance;
-use crate::vector_storage::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
+use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
@@ -97,8 +98,8 @@ pub trait VectorStorage {
     fn deleted_vector_bitslice(&self) -> &BitSlice;
 }
 
-pub trait DenseVectorStorage: VectorStorage {
-    fn get_dense(&self, key: PointOffsetType) -> &[VectorElementType];
+pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
+    fn get_dense(&self, key: PointOffsetType) -> &[T];
 }
 
 pub trait SparseVectorStorage: VectorStorage {
@@ -110,9 +111,9 @@ pub trait MultiVectorStorage: VectorStorage {
 }
 
 pub enum VectorStorageEnum {
-    DenseSimple(SimpleDenseVectorStorage),
-    DenseMemmap(Box<MemmapDenseVectorStorage>),
-    DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage>),
+    DenseSimple(SimpleDenseVectorStorage<VectorElementType>),
+    DenseMemmap(Box<MemmapDenseVectorStorage<VectorElementType>>),
+    DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage<VectorElementType>>),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage),
 }

commit ffa363cbff245b81b225c8f09b2d4159d3a5f3a2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Apr 4 16:38:09 2024 +0200

    Multivec knob for SegmentConfig (#3963)
    
    * Multivec knob for SegmentConfig
    
    * regen openapi
    
    * add TODO for next step
    
    * introduce multivecconfig to support more similarity aggregation
    
    * update openapi

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index f1aa9538a..9d2401b8c 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -13,7 +13,7 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{MultiDenseVector, VectorElementType, VectorRef};
-use crate::types::Distance;
+use crate::types::{Distance, MultiVectorConfig};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
@@ -108,6 +108,7 @@ pub trait SparseVectorStorage: VectorStorage {
 
 pub trait MultiVectorStorage: VectorStorage {
     fn get_multi(&self, key: PointOffsetType) -> &MultiDenseVector;
+    fn multi_vector_config(&self) -> &MultiVectorConfig;
 }
 
 pub enum VectorStorageEnum {

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 9d2401b8c..f3cfbfa3e 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -12,7 +12,9 @@ use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
-use crate::data_types::vectors::{MultiDenseVector, VectorElementType, VectorRef};
+use crate::data_types::vectors::{
+    MultiDenseVector, VectorElementType, VectorElementTypeByte, VectorRef,
+};
 use crate::types::{Distance, MultiVectorConfig};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
@@ -113,8 +115,11 @@ pub trait MultiVectorStorage: VectorStorage {
 
 pub enum VectorStorageEnum {
     DenseSimple(SimpleDenseVectorStorage<VectorElementType>),
+    DenseSimpleByte(SimpleDenseVectorStorage<VectorElementTypeByte>),
     DenseMemmap(Box<MemmapDenseVectorStorage<VectorElementType>>),
+    DenseMemmapByte(Box<MemmapDenseVectorStorage<VectorElementTypeByte>>),
     DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage<VectorElementType>>),
+    DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage),
 }
@@ -123,8 +128,11 @@ impl VectorStorage for VectorStorageEnum {
     fn vector_dim(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.vector_dim(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.vector_dim(),
             VectorStorageEnum::DenseMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.vector_dim(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
         }
@@ -133,8 +141,11 @@ impl VectorStorage for VectorStorageEnum {
     fn distance(&self) -> Distance {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.distance(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.distance(),
             VectorStorageEnum::DenseMemmap(v) => v.distance(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
         }
@@ -143,8 +154,11 @@ impl VectorStorage for VectorStorageEnum {
     fn is_on_disk(&self) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.is_on_disk(),
             VectorStorageEnum::DenseMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
         }
@@ -153,8 +167,11 @@ impl VectorStorage for VectorStorageEnum {
     fn total_vector_count(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.total_vector_count(),
             VectorStorageEnum::DenseMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
         }
@@ -163,8 +180,11 @@ impl VectorStorage for VectorStorageEnum {
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector(key),
+            VectorStorageEnum::DenseSimpleByte(v) => v.get_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::DenseMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
         }
@@ -173,8 +193,11 @@ impl VectorStorage for VectorStorageEnum {
     fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseSimpleByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
         }
@@ -183,8 +206,11 @@ impl VectorStorage for VectorStorageEnum {
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseSimpleByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
         }
@@ -198,8 +224,13 @@ impl VectorStorage for VectorStorageEnum {
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseMemmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                v.update_from(other, other_ids, stopped)
+            }
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
         }
@@ -208,8 +239,11 @@ impl VectorStorage for VectorStorageEnum {
     fn flusher(&self) -> Flusher {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.flusher(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.flusher(),
             VectorStorageEnum::DenseMemmap(v) => v.flusher(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
         }
@@ -218,8 +252,11 @@ impl VectorStorage for VectorStorageEnum {
     fn files(&self) -> Vec<PathBuf> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.files(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.files(),
             VectorStorageEnum::DenseMemmap(v) => v.files(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.files(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
         }
@@ -228,8 +265,11 @@ impl VectorStorage for VectorStorageEnum {
     fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseSimpleByte(v) => v.delete_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
         }
@@ -238,8 +278,11 @@ impl VectorStorage for VectorStorageEnum {
     fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseSimpleByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
         }
@@ -248,8 +291,11 @@ impl VectorStorage for VectorStorageEnum {
     fn deleted_vector_count(&self) -> usize {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
         }
@@ -258,8 +304,11 @@ impl VectorStorage for VectorStorageEnum {
     fn deleted_vector_bitslice(&self) -> &BitSlice {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
         }

commit fed7dadd641e5967da4a5413363ea57f08579bf4
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Apr 19 11:04:09 2024 +0200

    byte storage quantization fix and test (#4063)
    
    * byte storage quantization fix and test
    
    * apply quantization_preprocess in quantization scorers
    
    * exact true
    
    * exact true
    
    * calculate sames count
    
    * wrong distance getter
    
    * fix Manhattan distance getter
    
    * less acc check
    
    * fix build
    
    * update acc

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index f3cfbfa3e..646259532 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -15,7 +15,7 @@ use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
     MultiDenseVector, VectorElementType, VectorElementTypeByte, VectorRef,
 };
-use crate::types::{Distance, MultiVectorConfig};
+use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
@@ -28,6 +28,8 @@ pub trait VectorStorage {
 
     fn distance(&self) -> Distance;
 
+    fn datatype(&self) -> VectorStorageDatatype;
+
     fn is_on_disk(&self) -> bool;
 
     /// Number of vectors
@@ -151,6 +153,19 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
+    fn datatype(&self) -> VectorStorageDatatype {
+        match self {
+            VectorStorageEnum::DenseSimple(v) => v.datatype(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.datatype(),
+            VectorStorageEnum::DenseMemmap(v) => v.datatype(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.datatype(),
+            VectorStorageEnum::SparseSimple(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
+        }
+    }
+
     fn is_on_disk(&self) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),

commit e452b6f3adef40afad594773e102e273f888e5d9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Apr 24 11:35:16 2024 +0200

    generic multidense vector storage (#4104)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 646259532..bc3b32053 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -13,7 +13,7 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    MultiDenseVector, VectorElementType, VectorElementTypeByte, VectorRef,
+    TypedMultiDenseVector, VectorElementType, VectorElementTypeByte, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
@@ -110,8 +110,8 @@ pub trait SparseVectorStorage: VectorStorage {
     fn get_sparse(&self, key: PointOffsetType) -> OperationResult<SparseVector>;
 }
 
-pub trait MultiVectorStorage: VectorStorage {
-    fn get_multi(&self, key: PointOffsetType) -> &MultiDenseVector;
+pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
+    fn get_multi(&self, key: PointOffsetType) -> &TypedMultiDenseVector<T>;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }
 
@@ -123,7 +123,7 @@ pub enum VectorStorageEnum {
     DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage<VectorElementType>>),
     DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
     SparseSimple(SimpleSparseVectorStorage),
-    MultiDenseSimple(SimpleMultiDenseVectorStorage),
+    MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
 }
 
 impl VectorStorage for VectorStorageEnum {

commit 916c7c7607bd0e5f1e6918d9de27328a228af137
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 25 13:41:16 2024 +0200

    generic multivector scorer (#4115)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index bc3b32053..0fd9f5d00 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -13,7 +13,7 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    TypedMultiDenseVector, VectorElementType, VectorElementTypeByte, VectorRef,
+    TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
@@ -111,7 +111,7 @@ pub trait SparseVectorStorage: VectorStorage {
 }
 
 pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
-    fn get_multi(&self, key: PointOffsetType) -> &TypedMultiDenseVector<T>;
+    fn get_multi(&self, key: PointOffsetType) -> TypedMultiDenseVectorRef<T>;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }
 

commit 8bdc8a3caf49d34f7bd6f90239f791684a473a5a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 10:28:31 2024 +0200

    Mmap multivector storage (#4106)
    
    * mmap multivector storage
    
    update_from
    
    fix build
    
    are you happy fmt
    
    fix bug
    
    share multivector storages tests
    
    * review remarks

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 0fd9f5d00..01ccb7d5e 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -8,6 +8,8 @@ use sparse::common::sparse_vector::SparseVector;
 
 use super::dense::memmap_dense_vector_storage::MemmapDenseVectorStorage;
 use super::dense::simple_dense_vector_storage::SimpleDenseVectorStorage;
+use super::multi_dense::appendable_mmap_multi_dense_vector_storage::AppendableMmapMultiDenseVectorStorage;
+use super::multi_dense::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
@@ -17,7 +19,6 @@ use crate::data_types::vectors::{
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
-use crate::vector_storage::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
@@ -124,6 +125,7 @@ pub enum VectorStorageEnum {
     DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
+    MultiDenseAppendableMemmap(Box<AppendableMmapMultiDenseVectorStorage<VectorElementType>>),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -137,6 +139,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.vector_dim(),
         }
     }
 
@@ -150,6 +153,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.distance(),
         }
     }
 
@@ -163,6 +167,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.datatype(),
             VectorStorageEnum::SparseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.datatype(),
         }
     }
 
@@ -176,6 +181,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_on_disk(),
         }
     }
 
@@ -189,6 +195,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.total_vector_count(),
         }
     }
 
@@ -202,6 +209,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector(key),
         }
     }
 
@@ -215,6 +223,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector_opt(key),
         }
     }
 
@@ -228,6 +237,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -248,6 +258,9 @@ impl VectorStorage for VectorStorageEnum {
             }
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                v.update_from(other, other_ids, stopped)
+            }
         }
     }
 
@@ -261,6 +274,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.flusher(),
         }
     }
 
@@ -274,6 +288,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.files(),
         }
     }
 
@@ -287,6 +302,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.delete_vector(key),
         }
     }
 
@@ -300,6 +316,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -313,6 +330,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_count(),
         }
     }
 
@@ -326,6 +344,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit f7113e678c2be8eec0866631fc14e887dbd6e06e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 7 13:27:58 2024 +0200

    integrate multivector mmap and byte storages (#4194)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 01ccb7d5e..7d252392b 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -125,7 +125,11 @@ pub enum VectorStorageEnum {
     DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
+    MultiDenseSimpleByte(SimpleMultiDenseVectorStorage<VectorElementTypeByte>),
     MultiDenseAppendableMemmap(Box<AppendableMmapMultiDenseVectorStorage<VectorElementType>>),
+    MultiDenseAppendableMemmapByte(
+        Box<AppendableMmapMultiDenseVectorStorage<VectorElementTypeByte>>,
+    ),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -139,7 +143,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.vector_dim(),
         }
     }
 
@@ -153,7 +159,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.distance(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.distance(),
         }
     }
 
@@ -167,7 +175,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.datatype(),
             VectorStorageEnum::SparseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.datatype(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.datatype(),
         }
     }
 
@@ -181,7 +191,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_on_disk(),
         }
     }
 
@@ -195,7 +207,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.total_vector_count(),
         }
     }
 
@@ -209,7 +223,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector(key),
         }
     }
 
@@ -223,7 +239,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector_opt(key),
         }
     }
 
@@ -237,7 +255,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -258,9 +278,13 @@ impl VectorStorage for VectorStorageEnum {
             }
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
                 v.update_from(other, other_ids, stopped)
             }
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
+                v.update_from(other, other_ids, stopped)
+            }
         }
     }
 
@@ -274,7 +298,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.flusher(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.flusher(),
         }
     }
 
@@ -288,7 +314,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.files(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.files(),
         }
     }
 
@@ -302,7 +330,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.delete_vector(key),
         }
     }
 
@@ -316,7 +346,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -330,7 +362,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_count(),
         }
     }
 
@@ -344,7 +378,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 78b16a16a40919218339114bfc723048731ab4b3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 15 10:36:55 2024 +0200

    Float16 integration and API (#4234)
    
    * f16 integration
    
    tests
    
    api
    
    fix test
    
    are you happy clippy
    
    * fix build

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 7d252392b..0e66f7c0a 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -15,7 +15,8 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte, VectorRef,
+    TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte, VectorElementTypeHalf,
+    VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
@@ -119,17 +120,24 @@ pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
 pub enum VectorStorageEnum {
     DenseSimple(SimpleDenseVectorStorage<VectorElementType>),
     DenseSimpleByte(SimpleDenseVectorStorage<VectorElementTypeByte>),
+    DenseSimpleHalf(SimpleDenseVectorStorage<VectorElementTypeHalf>),
     DenseMemmap(Box<MemmapDenseVectorStorage<VectorElementType>>),
     DenseMemmapByte(Box<MemmapDenseVectorStorage<VectorElementTypeByte>>),
+    DenseMemmapHalf(Box<MemmapDenseVectorStorage<VectorElementTypeHalf>>),
     DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage<VectorElementType>>),
     DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
+    DenseAppendableMemmapHalf(Box<AppendableMmapDenseVectorStorage<VectorElementTypeHalf>>),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
     MultiDenseSimpleByte(SimpleMultiDenseVectorStorage<VectorElementTypeByte>),
+    MultiDenseSimpleHalf(SimpleMultiDenseVectorStorage<VectorElementTypeHalf>),
     MultiDenseAppendableMemmap(Box<AppendableMmapMultiDenseVectorStorage<VectorElementType>>),
     MultiDenseAppendableMemmapByte(
         Box<AppendableMmapMultiDenseVectorStorage<VectorElementTypeByte>>,
     ),
+    MultiDenseAppendableMemmapHalf(
+        Box<AppendableMmapMultiDenseVectorStorage<VectorElementTypeHalf>>,
+    ),
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -137,15 +145,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.vector_dim(),
             VectorStorageEnum::DenseSimpleByte(v) => v.vector_dim(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.vector_dim(),
             VectorStorageEnum::DenseMemmap(v) => v.vector_dim(),
             VectorStorageEnum::DenseMemmapByte(v) => v.vector_dim(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.vector_dim(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.vector_dim(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.vector_dim(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.vector_dim(),
             VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.vector_dim(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.vector_dim(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.vector_dim(),
         }
     }
 
@@ -153,15 +166,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.distance(),
             VectorStorageEnum::DenseSimpleByte(v) => v.distance(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.distance(),
             VectorStorageEnum::DenseMemmap(v) => v.distance(),
             VectorStorageEnum::DenseMemmapByte(v) => v.distance(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.distance(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.distance(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.distance(),
         }
     }
 
@@ -169,15 +187,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.datatype(),
             VectorStorageEnum::DenseSimpleByte(v) => v.datatype(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.datatype(),
             VectorStorageEnum::DenseMemmap(v) => v.datatype(),
             VectorStorageEnum::DenseMemmapByte(v) => v.datatype(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.datatype(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.datatype(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.datatype(),
             VectorStorageEnum::SparseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.datatype(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.datatype(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.datatype(),
         }
     }
 
@@ -185,15 +208,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::DenseSimpleByte(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.is_on_disk(),
             VectorStorageEnum::DenseMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::DenseMemmapByte(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.is_on_disk(),
         }
     }
 
@@ -201,15 +229,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::DenseSimpleByte(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.total_vector_count(),
             VectorStorageEnum::DenseMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::DenseMemmapByte(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.total_vector_count(),
         }
     }
 
@@ -217,15 +250,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector(key),
             VectorStorageEnum::DenseSimpleByte(v) => v.get_vector(key),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.get_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.get_vector(key),
             VectorStorageEnum::DenseMemmapByte(v) => v.get_vector(key),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.get_vector(key),
         }
     }
 
@@ -233,15 +271,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseSimpleByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseMemmapByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.get_vector_opt(key),
         }
     }
 
@@ -249,15 +292,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseSimpleByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseMemmapByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -270,21 +318,30 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => {
                 v.update_from(other, other_ids, stopped)
             }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                v.update_from(other, other_ids, stopped)
+            }
             VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other, other_ids, stopped),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
                 v.update_from(other, other_ids, stopped)
             }
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
                 v.update_from(other, other_ids, stopped)
             }
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
+                v.update_from(other, other_ids, stopped)
+            }
         }
     }
 
@@ -292,15 +349,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.flusher(),
             VectorStorageEnum::DenseSimpleByte(v) => v.flusher(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.flusher(),
             VectorStorageEnum::DenseMemmap(v) => v.flusher(),
             VectorStorageEnum::DenseMemmapByte(v) => v.flusher(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.flusher(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.flusher(),
         }
     }
 
@@ -308,15 +370,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.files(),
             VectorStorageEnum::DenseSimpleByte(v) => v.files(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.files(),
             VectorStorageEnum::DenseMemmap(v) => v.files(),
             VectorStorageEnum::DenseMemmapByte(v) => v.files(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.files(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.files(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.files(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.files(),
         }
     }
 
@@ -324,15 +391,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::DenseSimpleByte(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.delete_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::DenseMemmapByte(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.delete_vector(key),
         }
     }
 
@@ -340,15 +412,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseSimpleByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseMemmapByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -356,15 +433,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseSimpleByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseMemmapByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.deleted_vector_count(),
         }
     }
 
@@ -372,15 +454,20 @@ impl VectorStorage for VectorStorageEnum {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseSimpleByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseMemmapByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 62ec5fb5fa6093eba62c7953ec17d0b070099eb8
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 21 15:45:15 2024 +0200

    multivector storage iterate over all inner vectors (#4288)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 0e66f7c0a..a7769cd15 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -114,6 +114,7 @@ pub trait SparseVectorStorage: VectorStorage {
 
 pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn get_multi(&self, key: PointOffsetType) -> TypedMultiDenseVectorRef<T>;
+    fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }
 

commit 25c410ec70ffb59553511c0031efc89ce7c776e4
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 28 12:36:09 2024 +0200

    Multidense vectors quantization (#4202)
    
    * quantized multivector definition
    
    new multiquantization scorers
    
    encode query
    
    maxsim for quantized vectors
    
    remove obsolete todo
    
    reuse existing scorers
    
    create multivector quantized storage
    
    save load offsets
    
    add test
    
    fix vectors count
    
    tempopery disable test while debugging
    
    fix tests
    
    fix build
    
    less static lifetimes
    
    less static lifetimes
    
    fix build
    
    * fix build after rebase
    
    * add persistence test
    
    * fix codespell
    
    * increase accuracy in tests
    
    * review remarks
    
    * add comment references
    
    * are you happy codespell
    
    * don't use bincode

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index a7769cd15..462e83385 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -141,6 +141,29 @@ pub enum VectorStorageEnum {
     ),
 }
 
+impl VectorStorageEnum {
+    pub fn try_multi_vector_config(&self) -> Option<&MultiVectorConfig> {
+        match self {
+            VectorStorageEnum::DenseSimple(_) => None,
+            VectorStorageEnum::DenseSimpleByte(_) => None,
+            VectorStorageEnum::DenseSimpleHalf(_) => None,
+            VectorStorageEnum::DenseMemmap(_) => None,
+            VectorStorageEnum::DenseMemmapByte(_) => None,
+            VectorStorageEnum::DenseMemmapHalf(_) => None,
+            VectorStorageEnum::DenseAppendableMemmap(_) => None,
+            VectorStorageEnum::DenseAppendableMemmapByte(_) => None,
+            VectorStorageEnum::DenseAppendableMemmapHalf(_) => None,
+            VectorStorageEnum::SparseSimple(_) => None,
+            VectorStorageEnum::MultiDenseSimple(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseSimpleByte(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseSimpleHalf(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableMemmap(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(s) => Some(s.multi_vector_config()),
+        }
+    }
+}
+
 impl VectorStorage for VectorStorageEnum {
     fn vector_dim(&self) -> usize {
         match self {

commit 21a3fb5f38a796f37883017adc993d0322bbca8f
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 28 16:38:56 2024 +0200

    Use correct vector storage size (#4312)
    
    * use correct vector storage size
    
    * remove dim from segment entry
    
    * are you happy fmt
    
    * codespell and proportions
    
    * remove obsolete comment
    
    * remove `try_vector_dim`
    
    * are you happy fmt
    
    * remove todo
    
    * revert code of conduct
    
    * check div 0
    
    * Simplify a bit with max iterator
    
    * Update lib/segment/src/index/hnsw_index/hnsw.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * are you happy fmt
    
    * Update lib/segment/src/index/plain_payload_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * review fix
    
    * set full scan threshold 0 for test
    
    * use u128 also for multivector storages
    
    * fix sparse vector size calculation
    
    * Move size calculation into if-branch
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 462e83385..8fe4d62df 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -26,8 +26,6 @@ use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStora
 /// El - type of vector element, expected numerical type
 /// Storage operates with internal IDs (`PointOffsetType`), which always starts with zero and have no skips
 pub trait VectorStorage {
-    fn vector_dim(&self) -> usize;
-
     fn distance(&self) -> Distance;
 
     fn datatype(&self) -> VectorStorageDatatype;
@@ -51,6 +49,8 @@ pub trait VectorStorage {
             .saturating_sub(self.deleted_vector_count())
     }
 
+    fn available_size_in_bytes(&self) -> usize;
+
     /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
 
@@ -105,6 +105,7 @@ pub trait VectorStorage {
 }
 
 pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
+    fn vector_dim(&self) -> usize;
     fn get_dense(&self, key: PointOffsetType) -> &[T];
 }
 
@@ -113,6 +114,7 @@ pub trait SparseVectorStorage: VectorStorage {
 }
 
 pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
+    fn vector_dim(&self) -> usize;
     fn get_multi(&self, key: PointOffsetType) -> TypedMultiDenseVectorRef<T>;
     fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
@@ -165,27 +167,6 @@ impl VectorStorageEnum {
 }
 
 impl VectorStorage for VectorStorageEnum {
-    fn vector_dim(&self) -> usize {
-        match self {
-            VectorStorageEnum::DenseSimple(v) => v.vector_dim(),
-            VectorStorageEnum::DenseSimpleByte(v) => v.vector_dim(),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.vector_dim(),
-            VectorStorageEnum::DenseMemmap(v) => v.vector_dim(),
-            VectorStorageEnum::DenseMemmapByte(v) => v.vector_dim(),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.vector_dim(),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.vector_dim(),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.vector_dim(),
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.vector_dim(),
-            VectorStorageEnum::SparseSimple(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseSimple(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.vector_dim(),
-            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.vector_dim(),
-        }
-    }
-
     fn distance(&self) -> Distance {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.distance(),
@@ -270,6 +251,27 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
+    fn available_size_in_bytes(&self) -> usize {
+        match self {
+            VectorStorageEnum::DenseSimple(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseMemmap(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::SparseSimple(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
+        }
+    }
+
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector(key),

commit d448d28c6d23ace94556bdaa9a237ba24bd2eeee
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jun 6 18:07:06 2024 +0200

    Add get optional vector for all storages (#4368)
    
    * Add get optional vector for dense simple storage
    
    * more bound checks
    
    * remove storage get_opt blanket implementation
    
    * remove duplication
    
    * remove duplication
    
    * Update lib/segment/src/vector_storage/multi_dense/simple_multi_dense_vector_storage.rs
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 8fe4d62df..976c5dbed 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -55,10 +55,7 @@ pub trait VectorStorage {
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
 
     /// Get the vector by the given key if it exists
-    /// Blanket implementation - override if necessary
-    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
-        Some(self.get_vector(key))
-    }
+    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector>;
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
@@ -116,6 +113,7 @@ pub trait SparseVectorStorage: VectorStorage {
 pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn vector_dim(&self) -> usize;
     fn get_multi(&self, key: PointOffsetType) -> TypedMultiDenseVectorRef<T>;
+    fn get_multi_opt(&self, key: PointOffsetType) -> Option<TypedMultiDenseVectorRef<T>>;
     fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }

commit df3aa29654269fa4a5948bdaf6ce067ef54622fc
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 12 12:13:49 2024 +0200

    Fix inplace updates for sparse index (#4375)
    
    * include old vector into update function and clean posting lists accordingly
    
    * add integration test
    
    * fix counter
    
    * also remove old vector if the insertion is empty
    
    * clippy
    
    * borrow once
    
    * fix max_next_weight correcton on delete + test
    
    * vector index responsible for updating vector storage
    
    * review fixes
    
    * add debug assert

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 976c5dbed..ff74fefc3 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -15,8 +15,8 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte, VectorElementTypeHalf,
-    VectorRef,
+    MultiDenseVector, TypedMultiDenseVectorRef, Vector, VectorElementType, VectorElementTypeByte,
+    VectorElementTypeHalf, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
@@ -162,6 +162,43 @@ impl VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(s) => Some(s.multi_vector_config()),
         }
     }
+
+    pub(crate) fn default_vector(&self) -> Vector {
+        match self {
+            VectorStorageEnum::DenseSimple(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseSimpleByte(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseSimpleHalf(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseMemmap(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseMemmapByte(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseMemmapHalf(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseAppendableMemmap(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                Vector::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                Vector::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::SparseSimple(_) => Vector::from(SparseVector::default()),
+            VectorStorageEnum::MultiDenseSimple(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseSimpleByte(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
+                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+            }
+        }
+    }
 }
 
 impl VectorStorage for VectorStorageEnum {

commit 49a9d05e7c180c2a4828686a54b9a7a8fbc946f3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 18 20:38:24 2024 +0200

    Fix multivector for unnamed vectors (#4482)
    
    * minor conversion improvement
    
    * use NamedVectors in update_vectors
    
    * remove merge from VectorStruct
    
    * rename Multi -> Named in vector struct
    
    * add multi-dense vectors option into VectorStruct
    
    * generate openapi
    
    * rename VectorStruct -> VectorStructInternal
    
    * add conversion for anonymous multivec in grpc
    
    * renames for BatchVectorStruct
    
    * implement multi-dense for batch
    
    * allow multi-dense in batch upserts
    
    * test and fixes

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index ff74fefc3..0b6cdcc95 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -15,8 +15,8 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    MultiDenseVector, TypedMultiDenseVectorRef, Vector, VectorElementType, VectorElementTypeByte,
-    VectorElementTypeHalf, VectorRef,
+    MultiDenseVectorInternal, TypedMultiDenseVectorRef, Vector, VectorElementType,
+    VectorElementTypeByte, VectorElementTypeHalf, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
@@ -180,22 +180,22 @@ impl VectorStorageEnum {
             }
             VectorStorageEnum::SparseSimple(_) => Vector::from(SparseVector::default()),
             VectorStorageEnum::MultiDenseSimple(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseSimpleByte(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseSimpleHalf(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
-                Vector::from(MultiDenseVector::placeholder(v.vector_dim()))
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
         }
     }

commit 54c0d94f5ab76ca80a69b7d60dfedf7d7e2b32c2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Jul 9 14:19:42 2024 +0200

    Derive/implement `fmt::Debug` for `Segment` (#4632)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 0b6cdcc95..cd27aae67 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -118,6 +118,7 @@ pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }
 
+#[derive(Debug)]
 pub enum VectorStorageEnum {
     DenseSimple(SimpleDenseVectorStorage<VectorElementType>),
     DenseSimpleByte(SimpleDenseVectorStorage<VectorElementTypeByte>),

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index cd27aae67..2c5e60538 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -59,10 +59,9 @@ pub trait VectorStorage {
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
-    fn update_from(
+    fn update_from<'a>(
         &mut self,
-        other: &VectorStorageEnum,
-        other_ids: &mut impl Iterator<Item = PointOffsetType>,
+        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
 
@@ -371,38 +370,31 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn update_from(
+    fn update_from<'a>(
         &mut self,
-        other: &VectorStorageEnum,
-        other_ids: &mut impl Iterator<Item = PointOffsetType>,
+        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
-            VectorStorageEnum::DenseSimple(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseMemmap(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
-                v.update_from(other, other_ids, stopped)
-            }
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
-                v.update_from(other, other_ids, stopped)
-            }
-            VectorStorageEnum::SparseSimple(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other, other_ids, stopped),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
-                v.update_from(other, other_ids, stopped)
-            }
+            VectorStorageEnum::DenseSimple(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseMemmap(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::SparseSimple(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
-                v.update_from(other, other_ids, stopped)
+                v.update_from(other_ids, stopped)
             }
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
-                v.update_from(other, other_ids, stopped)
+                v.update_from(other_ids, stopped)
             }
         }
     }

commit 649560fefd0cce811d8ada7d5c280991bfbb233f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 7 16:34:58 2024 +0200

    Use mmap lock as default vector storage (#4828)
    
    * add force_ram parameter to chuncked mmap vector storage
    
    * enable mlocked mmap vector storage on unix by default
    
    * regen openapi
    
    * add mlock on creation of chunck
    
    * minor unrelated renaming
    
    * rollback changes in LockedChunkedMmap
    
    * fmt
    
    * make AppendableMmapDenseVectorStorage generic of storage type
    
    * make AppendableMmapMultiDenseVectorStorage generic of storage type
    
    * implement initialization of InRamChunkedMmap
    
    * implement MultiDenseAppendableInRam and variations
    
    * enable InRamChunkedMmap for multivectors
    
    * use same CHUNK_SIZE for mmap and regular chuncked vectors
    
    * enable InRamChunkedMmap by default
    
    * fix tests
    
    * rollback usage of InRamChunkedMmap by default
    
    * review changes
    
    * add assertion on chunk_capacity [skip-ci]

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 2c5e60538..af98ab322 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -8,7 +8,9 @@ use sparse::common::sparse_vector::SparseVector;
 
 use super::dense::memmap_dense_vector_storage::MemmapDenseVectorStorage;
 use super::dense::simple_dense_vector_storage::SimpleDenseVectorStorage;
-use super::multi_dense::appendable_mmap_multi_dense_vector_storage::AppendableMmapMultiDenseVectorStorage;
+use super::multi_dense::appendable_mmap_multi_dense_vector_storage::{
+    AppendableMmapMultiDenseVectorStorage, MultivectorMmapOffset,
+};
 use super::multi_dense::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
@@ -19,7 +21,9 @@ use crate::data_types::vectors::{
     VectorElementTypeByte, VectorElementTypeHalf, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
-use crate::vector_storage::dense::appendable_mmap_dense_vector_storage::AppendableMmapDenseVectorStorage;
+use crate::vector_storage::chunked_mmap_vectors::ChunkedMmapVectors;
+use crate::vector_storage::dense::appendable_dense_vector_storage::AppendableMmapDenseVectorStorage;
+use crate::vector_storage::in_ram_persisted_vectors::InRamPersistedVectors;
 use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
@@ -125,19 +129,111 @@ pub enum VectorStorageEnum {
     DenseMemmap(Box<MemmapDenseVectorStorage<VectorElementType>>),
     DenseMemmapByte(Box<MemmapDenseVectorStorage<VectorElementTypeByte>>),
     DenseMemmapHalf(Box<MemmapDenseVectorStorage<VectorElementTypeHalf>>),
-    DenseAppendableMemmap(Box<AppendableMmapDenseVectorStorage<VectorElementType>>),
-    DenseAppendableMemmapByte(Box<AppendableMmapDenseVectorStorage<VectorElementTypeByte>>),
-    DenseAppendableMemmapHalf(Box<AppendableMmapDenseVectorStorage<VectorElementTypeHalf>>),
+    DenseAppendableMemmap(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementType,
+                ChunkedMmapVectors<VectorElementType>,
+            >,
+        >,
+    ),
+    DenseAppendableMemmapByte(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementTypeByte,
+                ChunkedMmapVectors<VectorElementTypeByte>,
+            >,
+        >,
+    ),
+    DenseAppendableMemmapHalf(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementTypeHalf,
+                ChunkedMmapVectors<VectorElementTypeHalf>,
+            >,
+        >,
+    ),
+    DenseAppendableInRam(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementType,
+                InRamPersistedVectors<VectorElementType>,
+            >,
+        >,
+    ),
+    DenseAppendableInRamByte(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementTypeByte,
+                InRamPersistedVectors<VectorElementTypeByte>,
+            >,
+        >,
+    ),
+    DenseAppendableInRamHalf(
+        Box<
+            AppendableMmapDenseVectorStorage<
+                VectorElementTypeHalf,
+                InRamPersistedVectors<VectorElementTypeHalf>,
+            >,
+        >,
+    ),
     SparseSimple(SimpleSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
     MultiDenseSimpleByte(SimpleMultiDenseVectorStorage<VectorElementTypeByte>),
     MultiDenseSimpleHalf(SimpleMultiDenseVectorStorage<VectorElementTypeHalf>),
-    MultiDenseAppendableMemmap(Box<AppendableMmapMultiDenseVectorStorage<VectorElementType>>),
+    MultiDenseAppendableMemmap(
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementType,
+                ChunkedMmapVectors<VectorElementType>,
+                ChunkedMmapVectors<MultivectorMmapOffset>,
+            >,
+        >,
+    ),
     MultiDenseAppendableMemmapByte(
-        Box<AppendableMmapMultiDenseVectorStorage<VectorElementTypeByte>>,
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementTypeByte,
+                ChunkedMmapVectors<VectorElementTypeByte>,
+                ChunkedMmapVectors<MultivectorMmapOffset>,
+            >,
+        >,
     ),
     MultiDenseAppendableMemmapHalf(
-        Box<AppendableMmapMultiDenseVectorStorage<VectorElementTypeHalf>>,
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementTypeHalf,
+                ChunkedMmapVectors<VectorElementTypeHalf>,
+                ChunkedMmapVectors<MultivectorMmapOffset>,
+            >,
+        >,
+    ),
+    MultiDenseAppendableInRam(
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementType,
+                InRamPersistedVectors<VectorElementType>,
+                InRamPersistedVectors<MultivectorMmapOffset>,
+            >,
+        >,
+    ),
+    MultiDenseAppendableInRamByte(
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementTypeByte,
+                InRamPersistedVectors<VectorElementTypeByte>,
+                InRamPersistedVectors<MultivectorMmapOffset>,
+            >,
+        >,
+    ),
+    MultiDenseAppendableInRamHalf(
+        Box<
+            AppendableMmapMultiDenseVectorStorage<
+                VectorElementTypeHalf,
+                InRamPersistedVectors<VectorElementTypeHalf>,
+                InRamPersistedVectors<MultivectorMmapOffset>,
+            >,
+        >,
     ),
 }
 
@@ -153,6 +249,9 @@ impl VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(_) => None,
             VectorStorageEnum::DenseAppendableMemmapByte(_) => None,
             VectorStorageEnum::DenseAppendableMemmapHalf(_) => None,
+            VectorStorageEnum::DenseAppendableInRam(_) => None,
+            VectorStorageEnum::DenseAppendableInRamByte(_) => None,
+            VectorStorageEnum::DenseAppendableInRamHalf(_) => None,
             VectorStorageEnum::SparseSimple(_) => None,
             VectorStorageEnum::MultiDenseSimple(s) => Some(s.multi_vector_config()),
             VectorStorageEnum::MultiDenseSimpleByte(s) => Some(s.multi_vector_config()),
@@ -160,6 +259,9 @@ impl VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(s) => Some(s.multi_vector_config()),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(s) => Some(s.multi_vector_config()),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableInRam(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(s) => Some(s.multi_vector_config()),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(s) => Some(s.multi_vector_config()),
         }
     }
 
@@ -178,6 +280,13 @@ impl VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
                 Vector::from(vec![1.0; v.vector_dim()])
             }
+            VectorStorageEnum::DenseAppendableInRam(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => {
+                Vector::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => {
+                Vector::from(vec![1.0; v.vector_dim()])
+            }
             VectorStorageEnum::SparseSimple(_) => Vector::from(SparseVector::default()),
             VectorStorageEnum::MultiDenseSimple(v) => {
                 Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
@@ -197,6 +306,15 @@ impl VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
                 Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
+                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+            }
         }
     }
 }
@@ -213,6 +331,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.distance(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.distance(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.distance(),
@@ -220,6 +341,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.distance(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.distance(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.distance(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.distance(),
         }
     }
 
@@ -234,6 +358,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.datatype(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.datatype(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.datatype(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.datatype(),
             VectorStorageEnum::SparseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.datatype(),
@@ -241,6 +368,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.datatype(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.datatype(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.datatype(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.datatype(),
         }
     }
 
@@ -255,6 +385,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.is_on_disk(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_on_disk(),
@@ -262,6 +395,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.is_on_disk(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.is_on_disk(),
         }
     }
 
@@ -276,6 +412,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.total_vector_count(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.total_vector_count(),
@@ -283,6 +422,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.total_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.total_vector_count(),
         }
     }
 
@@ -297,6 +439,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.available_size_in_bytes(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.available_size_in_bytes(),
             VectorStorageEnum::SparseSimple(v) => v.available_size_in_bytes(),
             VectorStorageEnum::MultiDenseSimple(v) => v.available_size_in_bytes(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.available_size_in_bytes(),
@@ -304,6 +449,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.available_size_in_bytes(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.available_size_in_bytes(),
         }
     }
 
@@ -318,6 +466,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.get_vector(key),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector(key),
@@ -325,6 +476,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.get_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.get_vector(key),
         }
     }
 
@@ -339,6 +493,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector_opt(key),
@@ -346,6 +503,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.get_vector_opt(key),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.get_vector_opt(key),
         }
     }
 
@@ -360,6 +520,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector),
@@ -367,6 +530,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.insert_vector(key, vector),
         }
     }
 
@@ -385,6 +551,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::SparseSimple(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other_ids, stopped),
@@ -396,6 +565,13 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
                 v.update_from(other_ids, stopped)
             }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
+                v.update_from(other_ids, stopped)
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
+                v.update_from(other_ids, stopped)
+            }
         }
     }
 
@@ -410,6 +586,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.flusher(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.flusher(),
@@ -417,6 +596,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.flusher(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.flusher(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.flusher(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.flusher(),
         }
     }
 
@@ -431,6 +613,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.files(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.files(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.files(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.files(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.files(),
@@ -438,6 +623,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.files(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.files(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.files(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.files(),
         }
     }
 
@@ -452,6 +640,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.delete_vector(key),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.delete_vector(key),
@@ -459,6 +650,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.delete_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.delete_vector(key),
         }
     }
 
@@ -473,6 +667,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_deleted_vector(key),
@@ -480,6 +677,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.is_deleted_vector(key),
         }
     }
 
@@ -494,6 +694,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_count(),
@@ -501,6 +704,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.deleted_vector_count(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.deleted_vector_count(),
         }
     }
 
@@ -515,6 +721,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_bitslice(),
@@ -522,6 +731,9 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.deleted_vector_bitslice(),
         }
     }
 }

commit 6e48f588a1de3090b2959e1589fc08984634ebe6
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Aug 26 20:02:08 2024 +0200

    Fix point deletions on mmap segment optimization (#4952)
    
    * Don't use ID but current point offset when optimizing dense mmap storage
    
    This change now matches the implementation in all other storage types.
    
    * Remove now obsolete point offsets in update_from point iterator
    
    * Fix test

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index af98ab322..1cba4e726 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -65,7 +65,7 @@ pub trait VectorStorage {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
+        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
 
@@ -538,7 +538,7 @@ impl VectorStorage for VectorStorageEnum {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
+        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {

commit 1d0ee7ea32043598f8b240e6a3a52be20663fa44
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Oct 9 10:15:46 2024 +0200

    Inference interface in REST and gRPC (#5165)
    
    * include document & image objects into grpc API
    
    * introduce image and object to rest api
    
    * minor refactoring
    
    * rename Vector -> VectorInternal
    
    * decompose vector data structures
    
    * add schema
    
    * fmt
    
    * grpc docs
    
    * fix conversion
    
    * fix clippy
    
    * fix another conversion
    
    * rename VectorInput -> VectorInputInternal
    
    * replace grpc TryFrom with async functions
    
    * fmt
    
    * replace rest TryFrom with async functions
    
    * add image and object into query rest
    
    * separate inference related conversions
    
    * move json-related conversions into a separate file
    
    * move vector-related transformations into a separate file
    
    * move more vector related-conversions into dedicated module

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 1cba4e726..3be63e57a 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -17,8 +17,8 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{
-    MultiDenseVectorInternal, TypedMultiDenseVectorRef, Vector, VectorElementType,
-    VectorElementTypeByte, VectorElementTypeHalf, VectorRef,
+    MultiDenseVectorInternal, TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte,
+    VectorElementTypeHalf, VectorInternal, VectorRef,
 };
 use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::chunked_mmap_vectors::ChunkedMmapVectors;
@@ -265,55 +265,67 @@ impl VectorStorageEnum {
         }
     }
 
-    pub(crate) fn default_vector(&self) -> Vector {
+    pub(crate) fn default_vector(&self) -> VectorInternal {
         match self {
-            VectorStorageEnum::DenseSimple(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseSimpleByte(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseSimpleHalf(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseMemmap(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseMemmapByte(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseMemmapHalf(v) => Vector::from(vec![1.0; v.vector_dim()]),
-            VectorStorageEnum::DenseAppendableMemmap(v) => Vector::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseSimple(v) => VectorInternal::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseSimpleByte(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseSimpleHalf(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseMemmap(v) => VectorInternal::from(vec![1.0; v.vector_dim()]),
+            VectorStorageEnum::DenseMemmapByte(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseMemmapHalf(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseAppendableMemmap(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
             VectorStorageEnum::DenseAppendableMemmapByte(v) => {
-                Vector::from(vec![1.0; v.vector_dim()])
+                VectorInternal::from(vec![1.0; v.vector_dim()])
             }
             VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
-                Vector::from(vec![1.0; v.vector_dim()])
+                VectorInternal::from(vec![1.0; v.vector_dim()])
+            }
+            VectorStorageEnum::DenseAppendableInRam(v) => {
+                VectorInternal::from(vec![1.0; v.vector_dim()])
             }
-            VectorStorageEnum::DenseAppendableInRam(v) => Vector::from(vec![1.0; v.vector_dim()]),
             VectorStorageEnum::DenseAppendableInRamByte(v) => {
-                Vector::from(vec![1.0; v.vector_dim()])
+                VectorInternal::from(vec![1.0; v.vector_dim()])
             }
             VectorStorageEnum::DenseAppendableInRamHalf(v) => {
-                Vector::from(vec![1.0; v.vector_dim()])
+                VectorInternal::from(vec![1.0; v.vector_dim()])
             }
-            VectorStorageEnum::SparseSimple(_) => Vector::from(SparseVector::default()),
+            VectorStorageEnum::SparseSimple(_) => VectorInternal::from(SparseVector::default()),
             VectorStorageEnum::MultiDenseSimple(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseSimpleByte(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseSimpleHalf(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableInRam(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
             VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
-                Vector::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
+                VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
         }
     }

commit 8736f8ed661cb6ac583c3ca37f29f20872c885f0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Oct 15 11:07:01 2024 +0200

    [perf] Do not capture backtrace on get_sparse_vector_opt (#5219)
    
    * Do not capture backtrace on get_sparse_vector_opt
    
    * clean import

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 3be63e57a..95138728b 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -111,6 +111,7 @@ pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
 
 pub trait SparseVectorStorage: VectorStorage {
     fn get_sparse(&self, key: PointOffsetType) -> OperationResult<SparseVector>;
+    fn get_sparse_opt(&self, key: PointOffsetType) -> OperationResult<Option<SparseVector>>;
 }
 
 pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {

commit 390d4c45035739bc78cdeb0fe6eccda4fec09946
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Fri Oct 25 15:09:31 2024 +0530

    Track vector storage usage in bytes for each of the segments (#5292)
    
    * Track disk usage for each of the vectors and segments
    
    * Dont extend vector_data field
    
    * Remove comment and improve var name
    
    * Introduce vectors_size_bytes and rename available_size_in_bytes
    
    * Introduce vectors_size_bytes and rename available_size_in_bytes
    
    * fix linter
    
    * Avoid converting to u64
    
    * calculate vectors_size_bytes for proxy segments
    
    * Fix OpenAPI spec
    
    * fix typo

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 95138728b..1bd2cb8c3 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -53,7 +53,7 @@ pub trait VectorStorage {
             .saturating_sub(self.deleted_vector_count())
     }
 
-    fn available_size_in_bytes(&self) -> usize;
+    fn size_in_bytes(&self) -> usize;
 
     /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
@@ -441,30 +441,30 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn available_size_in_bytes(&self) -> usize {
+    fn size_in_bytes(&self) -> usize {
         match self {
-            VectorStorageEnum::DenseSimple(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseSimpleByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseMemmap(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseMemmapByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRam(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRamByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::SparseSimple(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimple(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.available_size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.available_size_in_bytes(),
+            VectorStorageEnum::DenseSimple(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseMemmap(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRam(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::SparseSimple(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.size_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.size_in_bytes(),
         }
     }
 

commit 28a89060d1d2464bb33c49891fd2397cd77a1bf2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Nov 13 16:52:14 2024 +0100

    use more stable computation of vectors_size_bytes + refactoring (#5437)
    
    * use more stable computation of vectors_size_bytes + refactoring
    
    * sync openapi

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 1bd2cb8c3..ce84c7093 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -53,7 +53,7 @@ pub trait VectorStorage {
             .saturating_sub(self.deleted_vector_count())
     }
 
-    fn size_in_bytes(&self) -> usize;
+    fn size_of_available_vectors_in_bytes(&self) -> usize;
 
     /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
@@ -441,30 +441,50 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn size_in_bytes(&self) -> usize {
+    fn size_of_available_vectors_in_bytes(&self) -> usize {
         match self {
-            VectorStorageEnum::DenseSimple(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseSimpleByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseMemmap(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseMemmapByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRam(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRamByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::SparseSimple(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimple(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.size_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.size_in_bytes(),
+            VectorStorageEnum::DenseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmap(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableInRam(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::SparseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
         }
     }
 

commit d15ef49719c6d3ef3bc66da73d510e386553596b
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 15 17:14:37 2024 +0100

    Optimize mmap sequential access for large scoring (#5440)
    
    * Optimize mmap sequential access for large scoring
    
    * use it
    
    * make windows happy
    
    * add missing CPU counters
    
    * Will not need
    
    * more unix build
    
    * add benchmark
    
    * fix and bench cmp
    
    * larger batch size
    
    * start appendable mmap implem
    
    * reenable debug for bench
    
    * remove old impl for comparison
    
    * impl for chunk mmap
    
    * fix windows
    
    * debug assert
    
    * errare human est
    
    * windows cfg
    
    * generalize peek_top_iter
    
    * remove blanket implementation to force explicit decision
    
    * less TODO
    
    * account for size of T
    
    * fmr
    
    * simplify chunk impl
    
    * relax constraint on contiguous ids
    
    * remove madvice WILLNEED and clean batching infra
    
    * some premature optimizations
    
    * extra sequential mmap for MMapVectorStorage
    
    * add read-only typed mmap
    
    * add read-only typed mmap
    
    * fix comments
    
    * implement batch reads for chuncked mmap
    
    * fix is_read_with_prefetch_efficient
    
    * cleanup
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index ce84c7093..9fbbc9b15 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -107,6 +107,15 @@ pub trait VectorStorage {
 pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn vector_dim(&self) -> usize;
     fn get_dense(&self, key: PointOffsetType) -> &[T];
+
+    /// Get the dense vectors by the given keys
+    ///
+    /// Implementation can assume that the keys are consecutive
+    fn get_dense_batch<'a>(&'a self, keys: &[PointOffsetType], vectors: &mut [&'a [T]]) {
+        for (idx, key) in keys.iter().enumerate() {
+            vectors[idx] = self.get_dense(*key);
+        }
+    }
 }
 
 pub trait SparseVectorStorage: VectorStorage {
@@ -118,6 +127,11 @@ pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn vector_dim(&self) -> usize;
     fn get_multi(&self, key: PointOffsetType) -> TypedMultiDenseVectorRef<T>;
     fn get_multi_opt(&self, key: PointOffsetType) -> Option<TypedMultiDenseVectorRef<T>>;
+    fn get_batch_multi<'a>(
+        &'a self,
+        keys: &[PointOffsetType],
+        vectors: &mut [TypedMultiDenseVectorRef<'a, T>],
+    );
     fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 }

commit c10c145a754b3825a60aaaa143fe91b5b98502b0
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 27 11:45:16 2024 -0600

    Compatibility for mmap sparse vectors (#5454)
    
    * implement mmap sparse vector storage
    
    * add to VectorStorageEnum
    
    * clippy
    
    * add tests, fix both simple and mmap storages
    
    * smol correction on total_vector_count
    
    * add sparse storage type to config
    
    * fix reading config without storage type
    
    * generate openapi
    
    * use blob_store by path
    
    * hidden setting to enable new storage
    
    * validate existing path in `BlobStore::open()`
    
    * use new dir for each sparse vector name
    
    * fix and rename `max_point_offset`
    
    Plus some extra refactors
    
    * add storage compat test, to always check both storages work
    
    * fix opening of storage + other misc fixes
    
    * FIX!!!
    
    `Unset` operations in the Tracker weren't updating the
    `next_pointer_id`. So, when reopening the storage, those points wouldn't
    get marked as deleted in the bitslice, thus creating the illusion that
    they should exist, when they did not.
    
    * refactor naming from `iter_*` to `for_each_*`
    
    * fix checking for BlobStore existance
    
    * fix typo
    
    * fix error message
    
    * better docs for open_or_create
    
    * fix after rebase

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 9fbbc9b15..342e00090 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -8,6 +8,7 @@ use sparse::common::sparse_vector::SparseVector;
 
 use super::dense::memmap_dense_vector_storage::MemmapDenseVectorStorage;
 use super::dense::simple_dense_vector_storage::SimpleDenseVectorStorage;
+use super::mmap_sparse_vector_storage::MmapSparseVectorStorage;
 use super::multi_dense::appendable_mmap_multi_dense_vector_storage::{
     AppendableMmapMultiDenseVectorStorage, MultivectorMmapOffset,
 };
@@ -65,7 +66,7 @@ pub trait VectorStorage {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
+        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>>;
 
@@ -193,6 +194,7 @@ pub enum VectorStorageEnum {
         >,
     ),
     SparseSimple(SimpleSparseVectorStorage),
+    SparseMmap(MmapSparseVectorStorage),
     MultiDenseSimple(SimpleMultiDenseVectorStorage<VectorElementType>),
     MultiDenseSimpleByte(SimpleMultiDenseVectorStorage<VectorElementTypeByte>),
     MultiDenseSimpleHalf(SimpleMultiDenseVectorStorage<VectorElementTypeHalf>),
@@ -268,6 +270,7 @@ impl VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(_) => None,
             VectorStorageEnum::DenseAppendableInRamHalf(_) => None,
             VectorStorageEnum::SparseSimple(_) => None,
+            VectorStorageEnum::SparseMmap(_) => None,
             VectorStorageEnum::MultiDenseSimple(s) => Some(s.multi_vector_config()),
             VectorStorageEnum::MultiDenseSimpleByte(s) => Some(s.multi_vector_config()),
             VectorStorageEnum::MultiDenseSimpleHalf(s) => Some(s.multi_vector_config()),
@@ -315,6 +318,7 @@ impl VectorStorageEnum {
                 VectorInternal::from(vec![1.0; v.vector_dim()])
             }
             VectorStorageEnum::SparseSimple(_) => VectorInternal::from(SparseVector::default()),
+            VectorStorageEnum::SparseMmap(_) => VectorInternal::from(SparseVector::default()),
             VectorStorageEnum::MultiDenseSimple(v) => {
                 VectorInternal::from(MultiDenseVectorInternal::placeholder(v.vector_dim()))
             }
@@ -362,6 +366,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.distance(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.distance(),
             VectorStorageEnum::SparseSimple(v) => v.distance(),
+            VectorStorageEnum::SparseMmap(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimple(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.distance(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.distance(),
@@ -389,6 +394,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.datatype(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.datatype(),
             VectorStorageEnum::SparseSimple(v) => v.datatype(),
+            VectorStorageEnum::SparseMmap(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimple(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.datatype(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.datatype(),
@@ -416,6 +422,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.is_on_disk(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.is_on_disk(),
             VectorStorageEnum::SparseSimple(v) => v.is_on_disk(),
+            VectorStorageEnum::SparseMmap(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_on_disk(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.is_on_disk(),
@@ -443,6 +450,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.total_vector_count(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.total_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.total_vector_count(),
+            VectorStorageEnum::SparseMmap(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.total_vector_count(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.total_vector_count(),
@@ -478,6 +486,7 @@ impl VectorStorage for VectorStorageEnum {
                 v.size_of_available_vectors_in_bytes()
             }
             VectorStorageEnum::SparseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::SparseMmap(v) => v.size_of_available_vectors_in_bytes(),
             VectorStorageEnum::MultiDenseSimple(v) => v.size_of_available_vectors_in_bytes(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
@@ -517,6 +526,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.get_vector(key),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.get_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector(key),
+            VectorStorageEnum::SparseMmap(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector(key),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.get_vector(key),
@@ -544,6 +554,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.get_vector_opt(key),
             VectorStorageEnum::SparseSimple(v) => v.get_vector_opt(key),
+            VectorStorageEnum::SparseMmap(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.get_vector_opt(key),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.get_vector_opt(key),
@@ -571,6 +582,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.insert_vector(key, vector),
             VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::SparseMmap(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.insert_vector(key, vector),
@@ -602,6 +614,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::SparseSimple(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::SparseMmap(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other_ids, stopped),
@@ -637,6 +650,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.flusher(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.flusher(),
             VectorStorageEnum::SparseSimple(v) => v.flusher(),
+            VectorStorageEnum::SparseMmap(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimple(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.flusher(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.flusher(),
@@ -664,6 +678,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.files(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.files(),
             VectorStorageEnum::SparseSimple(v) => v.files(),
+            VectorStorageEnum::SparseMmap(v) => v.files(),
             VectorStorageEnum::MultiDenseSimple(v) => v.files(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.files(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.files(),
@@ -691,6 +706,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.delete_vector(key),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.delete_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.delete_vector(key),
+            VectorStorageEnum::SparseMmap(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.delete_vector(key),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.delete_vector(key),
@@ -718,6 +734,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.is_deleted_vector(key),
             VectorStorageEnum::SparseSimple(v) => v.is_deleted_vector(key),
+            VectorStorageEnum::SparseMmap(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimple(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.is_deleted_vector(key),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.is_deleted_vector(key),
@@ -745,6 +762,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.deleted_vector_count(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_count(),
+            VectorStorageEnum::SparseMmap(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_count(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.deleted_vector_count(),
@@ -772,6 +790,7 @@ impl VectorStorage for VectorStorageEnum {
             VectorStorageEnum::DenseAppendableInRamByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::DenseAppendableInRamHalf(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::SparseSimple(v) => v.deleted_vector_bitslice(),
+            VectorStorageEnum::SparseMmap(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimple(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimpleByte(v) => v.deleted_vector_bitslice(),
             VectorStorageEnum::MultiDenseSimpleHalf(v) => v.deleted_vector_bitslice(),

commit 443358dbe71139d5f6fe5fdf17531c5b005396ce
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 27 13:46:57 2024 -0600

    restructure sparse storages module (#5532)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 342e00090..df03abc7d 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -8,11 +8,11 @@ use sparse::common::sparse_vector::SparseVector;
 
 use super::dense::memmap_dense_vector_storage::MemmapDenseVectorStorage;
 use super::dense::simple_dense_vector_storage::SimpleDenseVectorStorage;
-use super::mmap_sparse_vector_storage::MmapSparseVectorStorage;
 use super::multi_dense::appendable_mmap_multi_dense_vector_storage::{
     AppendableMmapMultiDenseVectorStorage, MultivectorMmapOffset,
 };
 use super::multi_dense::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
+use super::sparse::mmap_sparse_vector_storage::MmapSparseVectorStorage;
 use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
@@ -25,7 +25,7 @@ use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
 use crate::vector_storage::chunked_mmap_vectors::ChunkedMmapVectors;
 use crate::vector_storage::dense::appendable_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::in_ram_persisted_vectors::InRamPersistedVectors;
-use crate::vector_storage::simple_sparse_vector_storage::SimpleSparseVectorStorage;
+use crate::vector_storage::sparse::simple_sparse_vector_storage::SimpleSparseVectorStorage;
 
 /// Trait for vector storage
 /// El - type of vector element, expected numerical type

commit 3725c7c72366eaa2873edd8201fc7b60f05979a1
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Dec 18 13:04:07 2024 -0300

    Prefer vector index for `size_of_available_vectors_in_bytes` (#5587)
    
    * get total sparse size from inverted index
    
    * populate on load if not present
    
    * use debug assertion
    
    * correct size calculation
    
    * r u happy clippy
    
    * fix total sparse size in immutable ram
    
    * don't use options. move size_of_available_vectors to other traits
    
    * adjust test
    
    * fix rebase

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index df03abc7d..feb9e057b 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -54,8 +54,6 @@ pub trait VectorStorage {
             .saturating_sub(self.deleted_vector_count())
     }
 
-    fn size_of_available_vectors_in_bytes(&self) -> usize;
-
     /// Get the vector by the given key
     fn get_vector(&self, key: PointOffsetType) -> CowVector;
 
@@ -117,6 +115,10 @@ pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
             vectors[idx] = self.get_dense(*key);
         }
     }
+
+    fn size_of_available_vectors_in_bytes(&self) -> usize {
+        self.available_vector_count() * self.vector_dim() * std::mem::size_of::<T>()
+    }
 }
 
 pub trait SparseVectorStorage: VectorStorage {
@@ -135,6 +137,8 @@ pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     );
     fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
+
+    fn size_of_available_vectors_in_bytes(&self) -> usize;
 }
 
 #[derive(Debug)]
@@ -348,6 +352,58 @@ impl VectorStorageEnum {
             }
         }
     }
+
+    pub fn size_of_available_vectors_in_bytes(&self) -> usize {
+        match self {
+            VectorStorageEnum::DenseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmap(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmapByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableInRam(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::SparseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::SparseMmap(_v) => {
+                unreachable!(
+                    "Mmap sparse storage does not know its total size, get from index instead"
+                )
+            }
+            VectorStorageEnum::MultiDenseSimple(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
+                v.size_of_available_vectors_in_bytes()
+            }
+        }
+    }
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -463,54 +519,6 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn size_of_available_vectors_in_bytes(&self) -> usize {
-        match self {
-            VectorStorageEnum::DenseSimple(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseMemmap(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseMemmapByte(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::DenseAppendableInRam(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::DenseAppendableInRamByte(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::DenseAppendableInRamHalf(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::SparseSimple(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::SparseMmap(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::MultiDenseSimple(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.size_of_available_vectors_in_bytes(),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
-                v.size_of_available_vectors_in_bytes()
-            }
-        }
-    }
-
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.get_vector(key),

commit b4328bb7c5c5052ce68d31bb7c00055a3b33c5d6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Feb 3 19:25:22 2025 -0300

    [mmap sparse vector storage] return cancelled error if stopped (#5938)
    
    * return cancelled error if stopped
    
    * add doc comment and renames

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index feb9e057b..c6e1dcaec 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -62,6 +62,12 @@ pub trait VectorStorage {
 
     fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
 
+    /// Add the given vectors to the storage.
+    ///
+    /// # Returns
+    /// The range of point offsets that were added to the storage.
+    ///
+    /// If stopped, the operation returns a cancellation error.
     fn update_from<'a>(
         &mut self,
         other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
@@ -605,40 +611,48 @@ impl VectorStorage for VectorStorageEnum {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
+        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         match self {
-            VectorStorageEnum::DenseSimple(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseMemmap(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableInRam(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableInRamByte(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::SparseSimple(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::SparseMmap(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other_ids, stopped),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.update_from(other_ids, stopped),
+            VectorStorageEnum::DenseSimple(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseSimpleByte(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseMemmap(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseMemmapByte(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                v.update_from(other_vectors, stopped)
+            }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                v.update_from(other_vectors, stopped)
+            }
+            VectorStorageEnum::DenseAppendableInRam(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::SparseSimple(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::SparseMmap(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::MultiDenseSimple(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.update_from(other_vectors, stopped),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                v.update_from(other_vectors, stopped)
+            }
             VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
-                v.update_from(other_ids, stopped)
+                v.update_from(other_vectors, stopped)
             }
             VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
-                v.update_from(other_ids, stopped)
+                v.update_from(other_vectors, stopped)
+            }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
+                v.update_from(other_vectors, stopped)
             }
-            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.update_from(other_ids, stopped),
             VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
-                v.update_from(other_ids, stopped)
+                v.update_from(other_vectors, stopped)
             }
             VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
-                v.update_from(other_ids, stopped)
+                v.update_from(other_vectors, stopped)
             }
         }
     }

commit 4a26134bec2cfe048c0efea004b5fddc3e086dbe
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Feb 18 11:08:17 2025 +0100

    Prototype partial segment snapshots and `SegmentManifest` format (#5928)
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index c6e1dcaec..138877f5d 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -21,7 +21,7 @@ use crate::data_types::vectors::{
     MultiDenseVectorInternal, TypedMultiDenseVectorRef, VectorElementType, VectorElementTypeByte,
     VectorElementTypeHalf, VectorInternal, VectorRef,
 };
-use crate::types::{Distance, MultiVectorConfig, VectorStorageDatatype};
+use crate::types::{Distance, MultiVectorConfig, SeqNumberType, VectorStorageDatatype};
 use crate::vector_storage::chunked_mmap_vectors::ChunkedMmapVectors;
 use crate::vector_storage::dense::appendable_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::in_ram_persisted_vectors::InRamPersistedVectors;
@@ -78,6 +78,10 @@ pub trait VectorStorage {
 
     fn files(&self) -> Vec<PathBuf>;
 
+    fn versioned_files(&self) -> Vec<(PathBuf, SeqNumberType)> {
+        Vec::new()
+    }
+
     /// Flag the vector by the given key as deleted
     ///
     /// Returns true if the vector was not deleted before and is now deleted

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 138877f5d..5227ab8d9 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -13,8 +13,8 @@ use super::multi_dense::appendable_mmap_multi_dense_vector_storage::{
 };
 use super::multi_dense::simple_multi_dense_vector_storage::SimpleMultiDenseVectorStorage;
 use super::sparse::mmap_sparse_vector_storage::MmapSparseVectorStorage;
-use crate::common::operation_error::OperationResult;
 use crate::common::Flusher;
+use crate::common::operation_error::OperationResult;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{

commit a2d7947917ca8d58c85360d1f07a387289b67a1b
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 10 15:27:06 2025 +0100

    Measure io writes for vector upsertions (#5944)
    
    * Add counter to vector storage API
    
    * Measuring IO write for dense vectors
    
    * Tests, GPU and sparse
    
    * Measure multi vectors too
    
    * Fix comment

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 5227ab8d9..96a62faa2 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -3,6 +3,7 @@ use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use sparse::common::sparse_vector::SparseVector;
 
@@ -60,7 +61,12 @@ pub trait VectorStorage {
     /// Get the vector by the given key if it exists
     fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector>;
 
-    fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()>;
+    fn insert_vector(
+        &mut self,
+        key: PointOffsetType,
+        vector: VectorRef,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()>;
 
     /// Add the given vectors to the storage.
     ///
@@ -585,31 +591,56 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
-    fn insert_vector(&mut self, key: PointOffsetType, vector: VectorRef) -> OperationResult<()> {
+    fn insert_vector(
+        &mut self,
+        key: PointOffsetType,
+        vector: VectorRef,
+        hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         match self {
-            VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseSimpleByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseSimpleHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseMemmapByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseMemmapHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableInRam(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableInRamByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::DenseAppendableInRamHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::SparseMmap(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableMemmap(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableInRam(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => v.insert_vector(key, vector),
-            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => v.insert_vector(key, vector),
+            VectorStorageEnum::DenseSimple(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseSimpleByte(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseSimpleHalf(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseMemmap(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseMemmapByte(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseMemmapHalf(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseAppendableMemmap(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseAppendableMemmapByte(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::DenseAppendableMemmapHalf(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::DenseAppendableInRam(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::DenseAppendableInRamByte(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::DenseAppendableInRamHalf(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::SparseSimple(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::SparseMmap(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::MultiDenseSimple(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::MultiDenseSimpleByte(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::MultiDenseSimpleHalf(v) => v.insert_vector(key, vector, hw_counter),
+            VectorStorageEnum::MultiDenseAppendableMemmap(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::MultiDenseAppendableInRam(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamByte(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(v) => {
+                v.insert_vector(key, vector, hw_counter)
+            }
         }
     }
 

commit ee7b7644290dff12e3dca616a105e6100588e802
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Apr 3 09:44:57 2025 +0000

    Use MaybeUninit in vector storages and query scorers (#6303)

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index 96a62faa2..c9fa21b77 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -1,9 +1,11 @@
+use std::mem::MaybeUninit;
 use std::ops::Range;
 use std::path::PathBuf;
 use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
+use common::maybe_uninit::maybe_uninit_fill_from;
 use common::types::PointOffsetType;
 use sparse::common::sparse_vector::SparseVector;
 
@@ -24,6 +26,7 @@ use crate::data_types::vectors::{
 };
 use crate::types::{Distance, MultiVectorConfig, SeqNumberType, VectorStorageDatatype};
 use crate::vector_storage::chunked_mmap_vectors::ChunkedMmapVectors;
+use crate::vector_storage::common::VECTOR_READ_BATCH_SIZE;
 use crate::vector_storage::dense::appendable_dense_vector_storage::AppendableMmapDenseVectorStorage;
 use crate::vector_storage::in_ram_persisted_vectors::InRamPersistedVectors;
 use crate::vector_storage::sparse::simple_sparse_vector_storage::SimpleSparseVectorStorage;
@@ -126,10 +129,12 @@ pub trait DenseVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     /// Get the dense vectors by the given keys
     ///
     /// Implementation can assume that the keys are consecutive
-    fn get_dense_batch<'a>(&'a self, keys: &[PointOffsetType], vectors: &mut [&'a [T]]) {
-        for (idx, key) in keys.iter().enumerate() {
-            vectors[idx] = self.get_dense(*key);
-        }
+    fn get_dense_batch<'a>(
+        &'a self,
+        keys: &[PointOffsetType],
+        vectors: &'a mut [MaybeUninit<&'a [T]>],
+    ) -> &'a [&'a [T]] {
+        maybe_uninit_fill_from(vectors, keys.iter().map(|key| self.get_dense(*key))).0
     }
 
     fn size_of_available_vectors_in_bytes(&self) -> usize {
@@ -149,8 +154,12 @@ pub trait MultiVectorStorage<T: PrimitiveVectorElement>: VectorStorage {
     fn get_batch_multi<'a>(
         &'a self,
         keys: &[PointOffsetType],
-        vectors: &mut [TypedMultiDenseVectorRef<'a, T>],
-    );
+        vectors: &'a mut [MaybeUninit<TypedMultiDenseVectorRef<'a, T>>],
+    ) -> &'a [TypedMultiDenseVectorRef<'a, T>] {
+        debug_assert_eq!(keys.len(), vectors.len());
+        debug_assert!(keys.len() <= VECTOR_READ_BATCH_SIZE);
+        maybe_uninit_fill_from(vectors, keys.iter().map(|key| self.get_multi(*key))).0
+    }
     fn iterate_inner_vectors(&self) -> impl Iterator<Item = &[T]> + Clone + Send;
     fn multi_vector_config(&self) -> &MultiVectorConfig;
 

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/vector_storage/vector_storage_base.rs b/lib/segment/src/vector_storage/vector_storage_base.rs
index c9fa21b77..e7bac0eaf 100644
--- a/lib/segment/src/vector_storage/vector_storage_base.rs
+++ b/lib/segment/src/vector_storage/vector_storage_base.rs
@@ -429,6 +429,64 @@ impl VectorStorageEnum {
             }
         }
     }
+
+    pub fn populate(&self) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::DenseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseSimpleByte(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseSimpleHalf(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseMemmap(vs) => vs.populate()?,
+            VectorStorageEnum::DenseMemmapByte(vs) => vs.populate()?,
+            VectorStorageEnum::DenseMemmapHalf(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableMemmap(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableMemmapByte(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableMemmapHalf(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableInRam(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableInRamByte(vs) => vs.populate()?,
+            VectorStorageEnum::DenseAppendableInRamHalf(vs) => vs.populate()?,
+            VectorStorageEnum::SparseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::SparseMmap(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseSimpleByte(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseSimpleHalf(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseAppendableMemmap(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseAppendableInRam(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => vs.populate()?,
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => vs.populate()?,
+        }
+        Ok(())
+    }
+
+    pub fn clear_cache(&self) -> OperationResult<()> {
+        match self {
+            VectorStorageEnum::DenseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseSimpleByte(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseSimpleHalf(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::DenseMemmap(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseMemmapByte(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseMemmapHalf(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableMemmap(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableMemmapByte(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableMemmapHalf(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableInRam(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableInRamByte(vs) => vs.clear_cache()?,
+            VectorStorageEnum::DenseAppendableInRamHalf(vs) => vs.clear_cache()?,
+            VectorStorageEnum::SparseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::SparseMmap(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseSimple(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseSimpleByte(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseSimpleHalf(_) => {} // Can't populate as it is not mmap
+            VectorStorageEnum::MultiDenseAppendableMemmap(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseAppendableMemmapByte(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseAppendableMemmapHalf(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseAppendableInRam(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseAppendableInRamByte(vs) => vs.clear_cache()?,
+            VectorStorageEnum::MultiDenseAppendableInRamHalf(vs) => vs.clear_cache()?,
+        }
+        Ok(())
+    }
 }
 
 impl VectorStorage for VectorStorageEnum {
@@ -488,6 +546,8 @@ impl VectorStorage for VectorStorageEnum {
         }
     }
 
+    /// If false - data is stored in RAM (and persisted on disk)
+    /// If true - data is stored on disk, and is not forced to be in RAM
     fn is_on_disk(&self) -> bool {
         match self {
             VectorStorageEnum::DenseSimple(v) => v.is_on_disk(),

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    