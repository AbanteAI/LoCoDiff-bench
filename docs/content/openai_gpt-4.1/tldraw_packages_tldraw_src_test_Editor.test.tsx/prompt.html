<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/tldraw/src/test/Editor.test.tsx - GPT-4.1</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/tldraw/src/test/Editor.test.tsx</h1>
        <p><a href="../../../cases/openai_gpt-4.1/tldraw_packages_tldraw_src_test_Editor.test.tsx.html">← Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/test/Editor.test.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
new file mode 100644
index 000000000..938e0773c
--- /dev/null
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -0,0 +1,493 @@
+import { BaseBoxShapeUtil, PageRecordType, TLShape, createShapeId } from '@tldraw/editor'
+import { TestEditor } from './TestEditor'
+import { TL } from './test-jsx'
+
+let editor: TestEditor
+
+const ids = {
+	box1: createShapeId('box1'),
+	box2: createShapeId('box2'),
+	box3: createShapeId('box3'),
+	frame1: createShapeId('frame1'),
+	group1: createShapeId('group1'),
+
+	page2: PageRecordType.createId('page2'),
+}
+
+beforeEach(() => {
+	editor = new TestEditor()
+
+	editor.createShapes([
+		// on it's own
+		{ id: ids.box1, type: 'geo', x: 100, y: 100, props: { w: 100, h: 100 } },
+		// in a frame
+		{ id: ids.frame1, type: 'frame', x: 100, y: 100, props: { w: 100, h: 100 } },
+		{ id: ids.box2, type: 'geo', x: 700, y: 700, props: { w: 100, h: 100 }, parentId: ids.frame1 },
+
+		{ id: ids.group1, type: 'group', x: 100, y: 100, props: {} },
+		{ id: ids.box3, type: 'geo', x: 500, y: 500, props: { w: 100, h: 100 }, parentId: ids.group1 },
+	])
+
+	const page1 = editor.currentPageId
+	editor.createPage('page 2', ids.page2)
+	editor.setCurrentPageId(page1)
+})
+
+const moveShapesToPage2 = () => {
+	// directly maniuplate parentId like would happen in multiplayer situations
+
+	editor.updateShapes([
+		{ id: ids.box1, type: 'geo', parentId: ids.page2 },
+		{ id: ids.box2, type: 'geo', parentId: ids.page2 },
+		{ id: ids.group1, type: 'group', parentId: ids.page2 },
+	])
+}
+
+describe('shapes that are moved to another page', () => {
+	it("should be excluded from the previous page's focusLayerId", () => {
+		editor.focusLayerId = ids.group1
+		expect(editor.focusLayerId).toBe(ids.group1)
+		moveShapesToPage2()
+		expect(editor.focusLayerId).toBe(editor.currentPageId)
+	})
+
+	describe("should be excluded from the previous page's hintingIds", () => {
+		test('[boxes]', () => {
+			editor.hintingIds = [ids.box1, ids.box2, ids.box3]
+			expect(editor.hintingIds).toEqual([ids.box1, ids.box2, ids.box3])
+			moveShapesToPage2()
+			expect(editor.hintingIds).toEqual([])
+		})
+		test('[frame that does not move]', () => {
+			editor.hintingIds = [ids.frame1]
+			expect(editor.hintingIds).toEqual([ids.frame1])
+			moveShapesToPage2()
+			expect(editor.hintingIds).toEqual([ids.frame1])
+		})
+	})
+
+	describe("should be excluded from the previous page's editingId", () => {
+		test('[root shape]', () => {
+			editor.editingId = ids.box1
+			expect(editor.editingId).toBe(ids.box1)
+			moveShapesToPage2()
+			expect(editor.editingId).toBe(null)
+		})
+		test('[child of frame]', () => {
+			editor.editingId = ids.box2
+			expect(editor.editingId).toBe(ids.box2)
+			moveShapesToPage2()
+			expect(editor.editingId).toBe(null)
+		})
+		test('[child of group]', () => {
+			editor.editingId = ids.box3
+			expect(editor.editingId).toBe(ids.box3)
+			moveShapesToPage2()
+			expect(editor.editingId).toBe(null)
+		})
+		test('[frame that doesnt move]', () => {
+			editor.editingId = ids.frame1
+			expect(editor.editingId).toBe(ids.frame1)
+			moveShapesToPage2()
+			expect(editor.editingId).toBe(ids.frame1)
+		})
+	})
+
+	describe("should be excluded from the previous page's erasingIds", () => {
+		test('[boxes]', () => {
+			editor.erasingIds = [ids.box1, ids.box2, ids.box3]
+			expect(editor.erasingIds).toEqual([ids.box1, ids.box2, ids.box3])
+			moveShapesToPage2()
+			expect(editor.erasingIds).toEqual([])
+		})
+		test('[frame that does not move]', () => {
+			editor.erasingIds = [ids.frame1]
+			expect(editor.erasingIds).toEqual([ids.frame1])
+			moveShapesToPage2()
+			expect(editor.erasingIds).toEqual([ids.frame1])
+		})
+	})
+
+	describe("should be excluded from the previous page's selectedIds", () => {
+		test('[boxes]', () => {
+			editor.setSelectedIds([ids.box1, ids.box2, ids.box3])
+			expect(editor.selectedIds).toEqual([ids.box1, ids.box2, ids.box3])
+			moveShapesToPage2()
+			expect(editor.selectedIds).toEqual([])
+		})
+		test('[frame that does not move]', () => {
+			editor.setSelectedIds([ids.frame1])
+			expect(editor.selectedIds).toEqual([ids.frame1])
+			moveShapesToPage2()
+			expect(editor.selectedIds).toEqual([ids.frame1])
+		})
+	})
+})
+
+it('Begins dragging from pointer move', () => {
+	editor.pointerDown(0, 0)
+	editor.pointerMove(2, 2)
+	expect(editor.inputs.isDragging).toBe(false)
+	editor.pointerMove(10, 10)
+	expect(editor.inputs.isDragging).toBe(true)
+})
+
+it('Begins dragging from wheel', () => {
+	editor.pointerDown(0, 0)
+	editor.wheel(2, 2)
+	expect(editor.inputs.isDragging).toBe(false)
+	editor.wheel(10, 10)
+	expect(editor.inputs.isDragging).toBe(true)
+})
+
+it('Does not create an undo stack item when first clicking on an empty canvas', () => {
+	editor = new TestEditor()
+	editor.pointerMove(50, 50)
+	editor.click(0, 0)
+	expect(editor.canUndo).toBe(false)
+})
+
+describe('Editor.sharedOpacity', () => {
+	it('should return the current opacity', () => {
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
+		editor.setOpacity(0.5)
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
+	})
+
+	it('should return opacity for a single selected shape', () => {
+		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
+		editor.setSelectedIds([A])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+
+	it('should return opacity for multiple selected shapes', () => {
+		const { A, B } = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
+		])
+		editor.setSelectedIds([A, B])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+
+	it('should return mixed when multiple selected shapes have different opacity', () => {
+		const { A, B } = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
+		])
+		editor.setSelectedIds([A, B])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
+	})
+
+	it('ignores the opacity of groups and returns the opacity of their children', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.group ref="group" x={0} y={0}>
+				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
+			</TL.group>,
+		])
+		editor.setSelectedIds([ids.group])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+})
+
+describe('Editor.setOpacity', () => {
+	it('should set opacity for selected shapes', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
+		])
+
+		editor.setSelectedIds([ids.A, ids.B])
+		editor.setOpacity(0.5)
+
+		expect(editor.getShapeById(ids.A)!.opacity).toBe(0.5)
+		expect(editor.getShapeById(ids.B)!.opacity).toBe(0.5)
+	})
+
+	it('should traverse into groups and set opacity in their children', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.geo ref="boxA" x={0} y={0} />,
+			<TL.group ref="groupA" x={0} y={0}>
+				<TL.geo ref="boxB" x={0} y={0} />
+				<TL.group ref="groupB" x={0} y={0}>
+					<TL.geo ref="boxC" x={0} y={0} />
+					<TL.geo ref="boxD" x={0} y={0} />
+				</TL.group>
+			</TL.group>,
+		])
+
+		editor.setSelectedIds([ids.groupA])
+		editor.setOpacity(0.5)
+
+		// a wasn't selected...
+		expect(editor.getShapeById(ids.boxA)!.opacity).toBe(1)
+
+		// b, c, & d were within a selected group...
+		expect(editor.getShapeById(ids.boxB)!.opacity).toBe(0.5)
+		expect(editor.getShapeById(ids.boxC)!.opacity).toBe(0.5)
+		expect(editor.getShapeById(ids.boxD)!.opacity).toBe(0.5)
+
+		// groups get skipped
+		expect(editor.getShapeById(ids.groupA)!.opacity).toBe(1)
+		expect(editor.getShapeById(ids.groupB)!.opacity).toBe(1)
+	})
+
+	it('stores opacity on opacityForNextShape', () => {
+		editor.setOpacity(0.5)
+		expect(editor.instanceState.opacityForNextShape).toBe(0.5)
+		editor.setOpacity(0.6)
+		expect(editor.instanceState.opacityForNextShape).toBe(0.6)
+	})
+})
+
+describe('Editor.TickManager', () => {
+	it('Does not produce NaN values when elapsed is 0', () => {
+		// a helper that calls update pointer velocity with a given elapsed time.
+		// usually this is called by the app's tick manager, using the elapsed time
+		// between two animation frames, but we're calling it directly here.
+		const tick = (ms: number) => {
+			// @ts-ignore
+			editor._tickManager.updatePointerVelocity(ms)
+		}
+
+		// 1. pointer velocity should be 0 when there is no movement
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0, y: 0 })
+
+		editor.pointerMove(10, 10)
+
+		// 2. moving is not enough, we also need to wait a frame before the velocity is updated
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0, y: 0 })
+
+		// 3. once time passes, the pointer velocity should be updated
+		tick(16)
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.3125, y: 0.3125 })
+
+		// 4. let's do it again, it should be updated again. move, tick, measure
+		editor.pointerMove(20, 20)
+		tick(16)
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.46875, y: 0.46875 })
+
+		// 5. if we tick again without movement, the velocity should decay
+		tick(16)
+
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.23437, y: 0.23437 })
+
+		// 6. if updatePointerVelocity is (for whatever reason) called with an elapsed time of zero milliseconds, it should be ignored
+		tick(0)
+
+		expect(editor.inputs.pointerVelocity.toJson()).toCloselyMatchObject({ x: 0.23437, y: 0.23437 })
+	})
+})
+
+describe("App's default tool", () => {
+	it('Is select for regular app', () => {
+		editor = new TestEditor()
+		expect(editor.currentToolId).toBe('select')
+	})
+	it('Is hand for readonly mode', () => {
+		editor = new TestEditor()
+		editor.isReadOnly = true
+		expect(editor.currentToolId).toBe('hand')
+	})
+})
+
+describe('currentToolId', () => {
+	it('is select by default', () => {
+		expect(editor.currentToolId).toBe('select')
+	})
+	it('is set to the last used tool', () => {
+		editor.setCurrentTool('draw')
+		expect(editor.currentToolId).toBe('draw')
+
+		editor.setCurrentTool('geo')
+		expect(editor.currentToolId).toBe('geo')
+	})
+	it('stays the selected tool during shape creation interactions that technically use the select tool', () => {
+		expect(editor.currentToolId).toBe('select')
+
+		editor.setCurrentTool('geo')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(100, 100)
+
+		expect(editor.currentToolId).toBe('geo')
+		expect(editor.root.path.value).toBe('root.select.resizing')
+	})
+
+	it('reverts back to select if we finish the interaction', () => {
+		expect(editor.currentToolId).toBe('select')
+
+		editor.setCurrentTool('geo')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(100, 100)
+
+		expect(editor.currentToolId).toBe('geo')
+		expect(editor.root.path.value).toBe('root.select.resizing')
+
+		editor.pointerUp(100, 100)
+
+		expect(editor.currentToolId).toBe('select')
+	})
+
+	it('stays on the selected tool if we cancel the interaction', () => {
+		expect(editor.currentToolId).toBe('select')
+
+		editor.setCurrentTool('geo')
+		editor.pointerDown(0, 0)
+		editor.pointerMove(100, 100)
+
+		expect(editor.currentToolId).toBe('geo')
+		expect(editor.root.path.value).toBe('root.select.resizing')
+
+		editor.cancel()
+
+		expect(editor.currentToolId).toBe('geo')
+	})
+})
+
+describe('isFocused', () => {
+	it('is false by default', () => {
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('becomes true when you call .focus()', () => {
+		editor.isFocused = true
+		expect(editor.isFocused).toBe(true)
+	})
+
+	it('becomes false when you call .blur()', () => {
+		editor.isFocused = true
+		expect(editor.isFocused).toBe(true)
+
+		editor.isFocused = false
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('remains false when you call .blur()', () => {
+		expect(editor.isFocused).toBe(false)
+		editor.isFocused = false
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('becomes true when the container div receives a focus event', () => {
+		expect(editor.isFocused).toBe(false)
+
+		editor.elm.focus()
+
+		expect(editor.isFocused).toBe(true)
+	})
+
+	it('becomes false when the container div receives a blur event', () => {
+		editor.isFocused = true
+		expect(editor.isFocused).toBe(true)
+
+		editor.elm.blur()
+
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('becomes true when a child of the app container div receives a focusin event', () => {
+		editor.elm.blur()
+
+		const child = document.createElement('div')
+		editor.elm.appendChild(child)
+
+		expect(editor.isFocused).toBe(false)
+
+		child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
+
+		expect(editor.isFocused).toBe(true)
+
+		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
+
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('becomes false when a child of the app container div receives a focusout event', () => {
+		const child = document.createElement('div')
+		editor.elm.appendChild(child)
+
+		editor.isFocused = true
+
+		expect(editor.isFocused).toBe(true)
+
+		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
+
+		expect(editor.isFocused).toBe(false)
+	})
+
+	it('calls .focus() and .blur() on the container div when you call .focus() and .blur() on the editor', () => {
+		const focusMock = jest.spyOn(editor.elm, 'focus').mockImplementation()
+		const blurMock = jest.spyOn(editor.elm, 'blur').mockImplementation()
+
+		expect(focusMock).not.toHaveBeenCalled()
+		expect(blurMock).not.toHaveBeenCalled()
+
+		editor.isFocused = true
+
+		expect(focusMock).toHaveBeenCalled()
+		expect(blurMock).not.toHaveBeenCalled()
+
+		editor.isFocused = false
+
+		expect(blurMock).toHaveBeenCalled()
+	})
+})
+
+describe('getShapeUtil', () => {
+	let myUtil: any
+
+	beforeEach(() => {
+		class _MyFakeShapeUtil extends BaseBoxShapeUtil<any> {
+			static override type = 'blorg'
+
+			getDefaultProps() {
+				return {
+					w: 100,
+					h: 100,
+				}
+			}
+			component() {
+				throw new Error('Method not implemented.')
+			}
+			indicator() {
+				throw new Error('Method not implemented.')
+			}
+		}
+
+		myUtil = _MyFakeShapeUtil
+
+		editor = new TestEditor({
+			shapeUtils: [_MyFakeShapeUtil],
+		})
+
+		editor.createShapes([
+			{ id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 100, h: 100 } },
+		])
+		const page1 = editor.currentPageId
+		editor.createPage('page 2', ids.page2)
+		editor.setCurrentPageId(page1)
+	})
+
+	it('accepts shapes', () => {
+		const shape = editor.getShapeById(ids.box1)!
+		const util = editor.getShapeUtil(shape)
+		expect(util).toBeInstanceOf(myUtil)
+	})
+
+	it('accepts shape types', () => {
+		const util = editor.getShapeUtil('blorg')
+		expect(util).toBeInstanceOf(myUtil)
+	})
+
+	it('throws if that shape type isnt registered', () => {
+		const myMissingShape = { type: 'missing' } as TLShape
+		expect(() => editor.getShapeUtil(myMissingShape)).toThrowErrorMatchingInlineSnapshot(
+			`"No shape util found for type \\"missing\\""`
+		)
+	})
+
+	it('throws if that type isnt registered', () => {
+		expect(() => editor.getShapeUtil('missing')).toThrowErrorMatchingInlineSnapshot(
+			`"No shape util found for type \\"missing\\""`
+		)
+	})
+})

commit 3e31ef2a7d01467ef92ca4f7aed13ee708db73ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 18 22:50:23 2023 +0100

    Remove helpers / extraneous API methods. (#1745)
    
    This PR removes several extraneous computed values from the editor. It
    adds some silly instance state onto the instance state record and
    unifies a few methods which were inconsistent. This is fit and finish
    work 🧽
    
    ## Computed Values
    
    In general, where once we had a getter and setter for `isBlahMode`,
    which really masked either an `_isBlahMode` atom on the editor or
    `instanceState.isBlahMode`, these are merged into `instanceState`; they
    can be accessed / updated via `editor.instanceState` /
    `editor.updateInstanceState`.
    
    ## tldraw select tool specific things
    
    This PR also removes some tldraw specific state checks and creates new
    component overrides to allow us to include them in tldraw/tldraw.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [tldraw] rename `useReadonly` to `useReadOnly`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isChangingStyle`
    - [editor] remove `Editor.isCoarsePointer`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isFocused`
    - [editor] remove `Editor.isGridMode`
    - [editor] remove `Editor.isPenMode`
    - [editor] remove `Editor.isReadOnly`
    - [editor] remove `Editor.isSnapMode`
    - [editor] remove `Editor.isToolLocked`
    - [editor] remove `Editor.locale`
    - [editor] rename `Editor.pageState` to `Editor.currentPageState`
    - [editor] add `Editor.pageStates`
    - [editor] add `Editor.setErasingIds`
    - [editor] add `Editor.setEditingId`
    - [editor] add several new component overrides

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 938e0773c..b1f7a3148 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -68,25 +68,25 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's editingId", () => {
 		test('[root shape]', () => {
-			editor.editingId = ids.box1
+			editor.setEditingId(ids.box1)
 			expect(editor.editingId).toBe(ids.box1)
 			moveShapesToPage2()
 			expect(editor.editingId).toBe(null)
 		})
 		test('[child of frame]', () => {
-			editor.editingId = ids.box2
+			editor.setEditingId(ids.box2)
 			expect(editor.editingId).toBe(ids.box2)
 			moveShapesToPage2()
 			expect(editor.editingId).toBe(null)
 		})
 		test('[child of group]', () => {
-			editor.editingId = ids.box3
+			editor.setEditingId(ids.box3)
 			expect(editor.editingId).toBe(ids.box3)
 			moveShapesToPage2()
 			expect(editor.editingId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
-			editor.editingId = ids.frame1
+			editor.setEditingId(ids.frame1)
 			expect(editor.editingId).toBe(ids.frame1)
 			moveShapesToPage2()
 			expect(editor.editingId).toBe(ids.frame1)
@@ -95,13 +95,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's erasingIds", () => {
 		test('[boxes]', () => {
-			editor.erasingIds = [ids.box1, ids.box2, ids.box3]
+			editor.setErasingIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.erasingIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.erasingIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.erasingIds = [ids.frame1]
+			editor.setErasingIds([ids.frame1])
 			expect(editor.erasingIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.erasingIds).toEqual([ids.frame1])
@@ -285,7 +285,8 @@ describe("App's default tool", () => {
 	})
 	it('Is hand for readonly mode', () => {
 		editor = new TestEditor()
-		editor.isReadOnly = true
+		editor.updateInstanceState({ isReadOnly: true })
+		editor.setCurrentTool('hand')
 		expect(editor.currentToolId).toBe('hand')
 	})
 })
@@ -345,43 +346,44 @@ describe('currentToolId', () => {
 
 describe('isFocused', () => {
 	it('is false by default', () => {
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('becomes true when you call .focus()', () => {
-		editor.isFocused = true
-		expect(editor.isFocused).toBe(true)
+		editor.updateInstanceState({ isFocused: true })
+		expect(editor.instanceState.isFocused).toBe(true)
 	})
 
 	it('becomes false when you call .blur()', () => {
-		editor.isFocused = true
-		expect(editor.isFocused).toBe(true)
+		editor.updateInstanceState({ isFocused: true })
+		expect(editor.instanceState.isFocused).toBe(true)
 
-		editor.isFocused = false
-		expect(editor.isFocused).toBe(false)
+		editor.updateInstanceState({ isFocused: false })
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('remains false when you call .blur()', () => {
-		expect(editor.isFocused).toBe(false)
-		editor.isFocused = false
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
+		editor.updateInstanceState({ isFocused: false })
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('becomes true when the container div receives a focus event', () => {
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 
 		editor.elm.focus()
 
-		expect(editor.isFocused).toBe(true)
+		expect(editor.instanceState.isFocused).toBe(true)
 	})
 
 	it('becomes false when the container div receives a blur event', () => {
-		editor.isFocused = true
-		expect(editor.isFocused).toBe(true)
+		editor.elm.focus()
+
+		expect(editor.instanceState.isFocused).toBe(true)
 
 		editor.elm.blur()
 
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('becomes true when a child of the app container div receives a focusin event', () => {
@@ -390,28 +392,28 @@ describe('isFocused', () => {
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
 
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 
 		child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
 
-		expect(editor.isFocused).toBe(true)
+		expect(editor.instanceState.isFocused).toBe(true)
 
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
 
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('becomes false when a child of the app container div receives a focusout event', () => {
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
 
-		editor.isFocused = true
+		editor.updateInstanceState({ isFocused: true })
 
-		expect(editor.isFocused).toBe(true)
+		expect(editor.instanceState.isFocused).toBe(true)
 
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
 
-		expect(editor.isFocused).toBe(false)
+		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
 	it('calls .focus() and .blur() on the container div when you call .focus() and .blur() on the editor', () => {
@@ -421,12 +423,12 @@ describe('isFocused', () => {
 		expect(focusMock).not.toHaveBeenCalled()
 		expect(blurMock).not.toHaveBeenCalled()
 
-		editor.isFocused = true
+		editor.focus()
 
 		expect(focusMock).toHaveBeenCalled()
 		expect(blurMock).not.toHaveBeenCalled()
 
-		editor.isFocused = false
+		editor.blur()
 
 		expect(blurMock).toHaveBeenCalled()
 	})

commit b22ea7cd4e6c27dcebd6615daa07116ecacbf554
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jul 19 11:52:21 2023 +0100

    More cleanup, focus bug fixes (#1749)
    
    This PR is another grab bag:
    - renames `readOnly` to `readonly` throughout editor
    - fixes a regression related to focus and keyboard shortcuts
    - adds a small outline for focused editors
    
    ### Change Type
    
    - [x] `major`
    
    ### Test Plan
    
    - [x] End to end tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index b1f7a3148..09b19b15b 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -285,7 +285,7 @@ describe("App's default tool", () => {
 	})
 	it('Is hand for readonly mode', () => {
 		editor = new TestEditor()
-		editor.updateInstanceState({ isReadOnly: true })
+		editor.updateInstanceState({ isReadonly: true })
 		editor.setCurrentTool('hand')
 		expect(editor.currentToolId).toBe('hand')
 	})
@@ -369,37 +369,42 @@ describe('isFocused', () => {
 	})
 
 	it('becomes true when the container div receives a focus event', () => {
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
 
 		editor.elm.focus()
 
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(true)
 	})
 
 	it('becomes false when the container div receives a blur event', () => {
 		editor.elm.focus()
 
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(true)
 
 		editor.elm.blur()
 
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
-	it('becomes true when a child of the app container div receives a focusin event', () => {
+	it.skip('becomes true when a child of the app container div receives a focusin event', () => {
+		// We need to skip this one because it's not actually true: the focusin event will bubble
+		// to the document.body, resulting in that being the active element. In reality, the editor's
+		// container would also have received a focus event, and after the editor's debounce ends,
+		// the container (or one of its descendants) will be the focused element.
 		editor.elm.blur()
-
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
-
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
-
 		child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
-
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(true)
-
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
-
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
 	})
 
@@ -413,6 +418,7 @@ describe('isFocused', () => {
 
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
 
+		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
 	})
 

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 09b19b15b..59310cfd3 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -30,7 +30,7 @@ beforeEach(() => {
 
 	const page1 = editor.currentPageId
 	editor.createPage('page 2', ids.page2)
-	editor.setCurrentPageId(page1)
+	editor.setCurrentPage(page1)
 })
 
 const moveShapesToPage2 = () => {
@@ -44,82 +44,82 @@ const moveShapesToPage2 = () => {
 }
 
 describe('shapes that are moved to another page', () => {
-	it("should be excluded from the previous page's focusLayerId", () => {
-		editor.focusLayerId = ids.group1
-		expect(editor.focusLayerId).toBe(ids.group1)
+	it("should be excluded from the previous page's focusedGroupId", () => {
+		editor.setFocusedGroupId(ids.group1)
+		expect(editor.focusedGroupId).toBe(ids.group1)
 		moveShapesToPage2()
-		expect(editor.focusLayerId).toBe(editor.currentPageId)
+		expect(editor.focusedGroupId).toBe(editor.currentPageId)
 	})
 
-	describe("should be excluded from the previous page's hintingIds", () => {
+	describe("should be excluded from the previous page's hintingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.hintingIds = [ids.box1, ids.box2, ids.box3]
-			expect(editor.hintingIds).toEqual([ids.box1, ids.box2, ids.box3])
+			editor.setHintingIds([ids.box1, ids.box2, ids.box3])
+			expect(editor.hintingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.hintingIds).toEqual([])
+			expect(editor.hintingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.hintingIds = [ids.frame1]
-			expect(editor.hintingIds).toEqual([ids.frame1])
+			editor.setHintingIds([ids.frame1])
+			expect(editor.hintingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.hintingIds).toEqual([ids.frame1])
+			expect(editor.hintingShapeIds).toEqual([ids.frame1])
 		})
 	})
 
-	describe("should be excluded from the previous page's editingId", () => {
+	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
 			editor.setEditingId(ids.box1)
-			expect(editor.editingId).toBe(ids.box1)
+			expect(editor.editingShapeId).toBe(ids.box1)
 			moveShapesToPage2()
-			expect(editor.editingId).toBe(null)
+			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of frame]', () => {
 			editor.setEditingId(ids.box2)
-			expect(editor.editingId).toBe(ids.box2)
+			expect(editor.editingShapeId).toBe(ids.box2)
 			moveShapesToPage2()
-			expect(editor.editingId).toBe(null)
+			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of group]', () => {
 			editor.setEditingId(ids.box3)
-			expect(editor.editingId).toBe(ids.box3)
+			expect(editor.editingShapeId).toBe(ids.box3)
 			moveShapesToPage2()
-			expect(editor.editingId).toBe(null)
+			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
 			editor.setEditingId(ids.frame1)
-			expect(editor.editingId).toBe(ids.frame1)
+			expect(editor.editingShapeId).toBe(ids.frame1)
 			moveShapesToPage2()
-			expect(editor.editingId).toBe(ids.frame1)
+			expect(editor.editingShapeId).toBe(ids.frame1)
 		})
 	})
 
-	describe("should be excluded from the previous page's erasingIds", () => {
+	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
 			editor.setErasingIds([ids.box1, ids.box2, ids.box3])
-			expect(editor.erasingIds).toEqual([ids.box1, ids.box2, ids.box3])
+			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.erasingIds).toEqual([])
+			expect(editor.erasingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
 			editor.setErasingIds([ids.frame1])
-			expect(editor.erasingIds).toEqual([ids.frame1])
+			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.erasingIds).toEqual([ids.frame1])
+			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 		})
 	})
 
-	describe("should be excluded from the previous page's selectedIds", () => {
+	describe("should be excluded from the previous page's selectedShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setSelectedIds([ids.box1, ids.box2, ids.box3])
-			expect(editor.selectedIds).toEqual([ids.box1, ids.box2, ids.box3])
+			editor.setSelectedShapeIds([ids.box1, ids.box2, ids.box3])
+			expect(editor.selectedShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.selectedIds).toEqual([])
+			expect(editor.selectedShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setSelectedIds([ids.frame1])
-			expect(editor.selectedIds).toEqual([ids.frame1])
+			editor.setSelectedShapeIds([ids.frame1])
+			expect(editor.selectedShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.selectedIds).toEqual([ids.frame1])
+			expect(editor.selectedShapeIds).toEqual([ids.frame1])
 		})
 	})
 })
@@ -156,7 +156,7 @@ describe('Editor.sharedOpacity', () => {
 
 	it('should return opacity for a single selected shape', () => {
 		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
-		editor.setSelectedIds([A])
+		editor.setSelectedShapeIds([A])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
@@ -165,7 +165,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
 			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
 		])
-		editor.setSelectedIds([A, B])
+		editor.setSelectedShapeIds([A, B])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
@@ -174,7 +174,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
 			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
 		])
-		editor.setSelectedIds([A, B])
+		editor.setSelectedShapeIds([A, B])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
 	})
 
@@ -184,7 +184,7 @@ describe('Editor.sharedOpacity', () => {
 				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
 			</TL.group>,
 		])
-		editor.setSelectedIds([ids.group])
+		editor.setSelectedShapeIds([ids.group])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 })
@@ -196,11 +196,11 @@ describe('Editor.setOpacity', () => {
 			<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
 		])
 
-		editor.setSelectedIds([ids.A, ids.B])
+		editor.setSelectedShapeIds([ids.A, ids.B])
 		editor.setOpacity(0.5)
 
-		expect(editor.getShapeById(ids.A)!.opacity).toBe(0.5)
-		expect(editor.getShapeById(ids.B)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
 	})
 
 	it('should traverse into groups and set opacity in their children', () => {
@@ -215,20 +215,20 @@ describe('Editor.setOpacity', () => {
 			</TL.group>,
 		])
 
-		editor.setSelectedIds([ids.groupA])
+		editor.setSelectedShapeIds([ids.groupA])
 		editor.setOpacity(0.5)
 
 		// a wasn't selected...
-		expect(editor.getShapeById(ids.boxA)!.opacity).toBe(1)
+		expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
 
 		// b, c, & d were within a selected group...
-		expect(editor.getShapeById(ids.boxB)!.opacity).toBe(0.5)
-		expect(editor.getShapeById(ids.boxC)!.opacity).toBe(0.5)
-		expect(editor.getShapeById(ids.boxD)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.boxC)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.boxD)!.opacity).toBe(0.5)
 
 		// groups get skipped
-		expect(editor.getShapeById(ids.groupA)!.opacity).toBe(1)
-		expect(editor.getShapeById(ids.groupB)!.opacity).toBe(1)
+		expect(editor.getShape(ids.groupA)!.opacity).toBe(1)
+		expect(editor.getShape(ids.groupB)!.opacity).toBe(1)
 	})
 
 	it('stores opacity on opacityForNextShape', () => {
@@ -472,11 +472,11 @@ describe('getShapeUtil', () => {
 		])
 		const page1 = editor.currentPageId
 		editor.createPage('page 2', ids.page2)
-		editor.setCurrentPageId(page1)
+		editor.setCurrentPage(page1)
 	})
 
 	it('accepts shapes', () => {
-		const shape = editor.getShapeById(ids.box1)!
+		const shape = editor.getShape(ids.box1)!
 		const util = editor.getShapeUtil(shape)
 		expect(util).toBeInstanceOf(myUtil)
 	})

commit e17074a8b3a60d26a2e54ca5b5d47622db7676be
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 14:21:14 2023 +0100

    Editor commands API / effects (#1778)
    
    This PR shrinks the commands API surface and adds a manager
    (`CleanupManager`) for side effects.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    Use the app! Especially undo and redo. Our tests are passing but I've
    found more cases where our coverage fails to catch issues.
    
    ### Release Notes
    
    - tbd

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 59310cfd3..eb855aca7 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -1,6 +1,5 @@
 import { BaseBoxShapeUtil, PageRecordType, TLShape, createShapeId } from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
-import { TL } from './test-jsx'
 
 let editor: TestEditor
 
@@ -53,13 +52,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setHintingIds([ids.box1, ids.box2, ids.box3])
+			editor.setHintingShapeIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.hintingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setHintingIds([ids.frame1])
+			editor.setHintingShapeIds([ids.frame1])
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
@@ -68,25 +67,25 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
-			editor.setEditingId(ids.box1)
+			editor.setEditingShapeId(ids.box1)
 			expect(editor.editingShapeId).toBe(ids.box1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of frame]', () => {
-			editor.setEditingId(ids.box2)
+			editor.setEditingShapeId(ids.box2)
 			expect(editor.editingShapeId).toBe(ids.box2)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of group]', () => {
-			editor.setEditingId(ids.box3)
+			editor.setEditingShapeId(ids.box3)
 			expect(editor.editingShapeId).toBe(ids.box3)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
-			editor.setEditingId(ids.frame1)
+			editor.setEditingShapeId(ids.frame1)
 			expect(editor.editingShapeId).toBe(ids.frame1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(ids.frame1)
@@ -95,13 +94,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setErasingIds([ids.box1, ids.box2, ids.box3])
+			editor.setErasingShapeIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setErasingIds([ids.frame1])
+			editor.setErasingShapeIds([ids.frame1])
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
@@ -147,89 +146,89 @@ it('Does not create an undo stack item when first clicking on an empty canvas',
 	expect(editor.canUndo).toBe(false)
 })
 
-describe('Editor.sharedOpacity', () => {
-	it('should return the current opacity', () => {
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
-		editor.setOpacity(0.5)
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
-	})
-
-	it('should return opacity for a single selected shape', () => {
-		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
-		editor.setSelectedShapeIds([A])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-	})
-
-	it('should return opacity for multiple selected shapes', () => {
-		const { A, B } = editor.createShapesFromJsx([
-			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
-		])
-		editor.setSelectedShapeIds([A, B])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-	})
-
-	it('should return mixed when multiple selected shapes have different opacity', () => {
-		const { A, B } = editor.createShapesFromJsx([
-			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
-		])
-		editor.setSelectedShapeIds([A, B])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
-	})
-
-	it('ignores the opacity of groups and returns the opacity of their children', () => {
-		const ids = editor.createShapesFromJsx([
-			<TL.group ref="group" x={0} y={0}>
-				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
-			</TL.group>,
-		])
-		editor.setSelectedShapeIds([ids.group])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-	})
-})
+// describe('Editor.sharedOpacity', () => {
+// 	it('should return the current opacity', () => {
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
+// 		editor.setOpacity(0.5)
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
+// 	})
+
+// 	it('should return opacity for a single selected shape', () => {
+// 		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
+// 		editor.setSelectedShapeIds([A])
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+// 	})
+
+// 	it('should return opacity for multiple selected shapes', () => {
+// 		const { A, B } = editor.createShapesFromJsx([
+// 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+// 			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
+// 		])
+// 		editor.setSelectedShapeIds([A, B])
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+// 	})
+
+// 	it('should return mixed when multiple selected shapes have different opacity', () => {
+// 		const { A, B } = editor.createShapesFromJsx([
+// 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+// 			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
+// 		])
+// 		editor.setSelectedShapeIds([A, B])
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
+// 	})
+
+// 	it('ignores the opacity of groups and returns the opacity of their children', () => {
+// 		const ids = editor.createShapesFromJsx([
+// 			<TL.group ref="group" x={0} y={0}>
+// 				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
+// 			</TL.group>,
+// 		])
+// 		editor.setSelectedShapeIds([ids.group])
+// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+// 	})
+// })
 
 describe('Editor.setOpacity', () => {
-	it('should set opacity for selected shapes', () => {
-		const ids = editor.createShapesFromJsx([
-			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-			<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
-		])
-
-		editor.setSelectedShapeIds([ids.A, ids.B])
-		editor.setOpacity(0.5)
-
-		expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
-		expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
-	})
-
-	it('should traverse into groups and set opacity in their children', () => {
-		const ids = editor.createShapesFromJsx([
-			<TL.geo ref="boxA" x={0} y={0} />,
-			<TL.group ref="groupA" x={0} y={0}>
-				<TL.geo ref="boxB" x={0} y={0} />
-				<TL.group ref="groupB" x={0} y={0}>
-					<TL.geo ref="boxC" x={0} y={0} />
-					<TL.geo ref="boxD" x={0} y={0} />
-				</TL.group>
-			</TL.group>,
-		])
-
-		editor.setSelectedShapeIds([ids.groupA])
-		editor.setOpacity(0.5)
-
-		// a wasn't selected...
-		expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
-
-		// b, c, & d were within a selected group...
-		expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
-		expect(editor.getShape(ids.boxC)!.opacity).toBe(0.5)
-		expect(editor.getShape(ids.boxD)!.opacity).toBe(0.5)
-
-		// groups get skipped
-		expect(editor.getShape(ids.groupA)!.opacity).toBe(1)
-		expect(editor.getShape(ids.groupB)!.opacity).toBe(1)
-	})
+	// it('should set opacity for selected shapes', () => {
+	// 	const ids = editor.createShapesFromJsx([
+	// 		<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+	// 		<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
+	// 	])
+
+	// 	editor.setSelectedShapeIds([ids.A, ids.B])
+	// 	editor.setOpacity(0.5)
+
+	// 	expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
+	// 	expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
+	// })
+
+	// it('should traverse into groups and set opacity in their children', () => {
+	// 	const ids = editor.createShapesFromJsx([
+	// 		<TL.geo ref="boxA" x={0} y={0} />,
+	// 		<TL.group ref="groupA" x={0} y={0}>
+	// 			<TL.geo ref="boxB" x={0} y={0} />
+	// 			<TL.group ref="groupB" x={0} y={0}>
+	// 				<TL.geo ref="boxC" x={0} y={0} />
+	// 				<TL.geo ref="boxD" x={0} y={0} />
+	// 			</TL.group>
+	// 		</TL.group>,
+	// 	])
+
+	// 	editor.setSelectedShapeIds([ids.groupA])
+	// 	editor.setOpacity(0.5)
+
+	// 	// a wasn't selected...
+	// 	expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
+
+	// 	// b, c, & d were within a selected group...
+	// 	expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
+	// 	expect(editor.getShape(ids.boxC)!.opacity).toBe(0.5)
+	// 	expect(editor.getShape(ids.boxD)!.opacity).toBe(0.5)
+
+	// 	// groups get skipped
+	// 	expect(editor.getShape(ids.groupA)!.opacity).toBe(1)
+	// 	expect(editor.getShape(ids.groupB)!.opacity).toBe(1)
+	// })
 
 	it('stores opacity on opacityForNextShape', () => {
 		editor.setOpacity(0.5)

commit 79fae186e4816f4b60f336fa80c2d85ef1debc21
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 18:03:31 2023 +0100

    Revert "Editor commands API / effects" (#1783)
    
    Reverts tldraw/tldraw#1778.
    
    Fuzz testing picked up errors related to deleting pages and undo/redo
    which may doom this PR.
    
    ### Change Type
    
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index eb855aca7..59310cfd3 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -1,5 +1,6 @@
 import { BaseBoxShapeUtil, PageRecordType, TLShape, createShapeId } from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
+import { TL } from './test-jsx'
 
 let editor: TestEditor
 
@@ -52,13 +53,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setHintingShapeIds([ids.box1, ids.box2, ids.box3])
+			editor.setHintingIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.hintingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setHintingShapeIds([ids.frame1])
+			editor.setHintingIds([ids.frame1])
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
@@ -67,25 +68,25 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
-			editor.setEditingShapeId(ids.box1)
+			editor.setEditingId(ids.box1)
 			expect(editor.editingShapeId).toBe(ids.box1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of frame]', () => {
-			editor.setEditingShapeId(ids.box2)
+			editor.setEditingId(ids.box2)
 			expect(editor.editingShapeId).toBe(ids.box2)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of group]', () => {
-			editor.setEditingShapeId(ids.box3)
+			editor.setEditingId(ids.box3)
 			expect(editor.editingShapeId).toBe(ids.box3)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
-			editor.setEditingShapeId(ids.frame1)
+			editor.setEditingId(ids.frame1)
 			expect(editor.editingShapeId).toBe(ids.frame1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(ids.frame1)
@@ -94,13 +95,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setErasingShapeIds([ids.box1, ids.box2, ids.box3])
+			editor.setErasingIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setErasingShapeIds([ids.frame1])
+			editor.setErasingIds([ids.frame1])
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
@@ -146,89 +147,89 @@ it('Does not create an undo stack item when first clicking on an empty canvas',
 	expect(editor.canUndo).toBe(false)
 })
 
-// describe('Editor.sharedOpacity', () => {
-// 	it('should return the current opacity', () => {
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
-// 		editor.setOpacity(0.5)
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
-// 	})
-
-// 	it('should return opacity for a single selected shape', () => {
-// 		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
-// 		editor.setSelectedShapeIds([A])
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-// 	})
-
-// 	it('should return opacity for multiple selected shapes', () => {
-// 		const { A, B } = editor.createShapesFromJsx([
-// 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-// 			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
-// 		])
-// 		editor.setSelectedShapeIds([A, B])
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-// 	})
-
-// 	it('should return mixed when multiple selected shapes have different opacity', () => {
-// 		const { A, B } = editor.createShapesFromJsx([
-// 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-// 			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
-// 		])
-// 		editor.setSelectedShapeIds([A, B])
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
-// 	})
-
-// 	it('ignores the opacity of groups and returns the opacity of their children', () => {
-// 		const ids = editor.createShapesFromJsx([
-// 			<TL.group ref="group" x={0} y={0}>
-// 				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
-// 			</TL.group>,
-// 		])
-// 		editor.setSelectedShapeIds([ids.group])
-// 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
-// 	})
-// })
+describe('Editor.sharedOpacity', () => {
+	it('should return the current opacity', () => {
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
+		editor.setOpacity(0.5)
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
+	})
+
+	it('should return opacity for a single selected shape', () => {
+		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
+		editor.setSelectedShapeIds([A])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+
+	it('should return opacity for multiple selected shapes', () => {
+		const { A, B } = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
+		])
+		editor.setSelectedShapeIds([A, B])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+
+	it('should return mixed when multiple selected shapes have different opacity', () => {
+		const { A, B } = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
+		])
+		editor.setSelectedShapeIds([A, B])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
+	})
+
+	it('ignores the opacity of groups and returns the opacity of their children', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.group ref="group" x={0} y={0}>
+				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
+			</TL.group>,
+		])
+		editor.setSelectedShapeIds([ids.group])
+		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+	})
+})
 
 describe('Editor.setOpacity', () => {
-	// it('should set opacity for selected shapes', () => {
-	// 	const ids = editor.createShapesFromJsx([
-	// 		<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
-	// 		<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
-	// 	])
-
-	// 	editor.setSelectedShapeIds([ids.A, ids.B])
-	// 	editor.setOpacity(0.5)
-
-	// 	expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
-	// 	expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
-	// })
-
-	// it('should traverse into groups and set opacity in their children', () => {
-	// 	const ids = editor.createShapesFromJsx([
-	// 		<TL.geo ref="boxA" x={0} y={0} />,
-	// 		<TL.group ref="groupA" x={0} y={0}>
-	// 			<TL.geo ref="boxB" x={0} y={0} />
-	// 			<TL.group ref="groupB" x={0} y={0}>
-	// 				<TL.geo ref="boxC" x={0} y={0} />
-	// 				<TL.geo ref="boxD" x={0} y={0} />
-	// 			</TL.group>
-	// 		</TL.group>,
-	// 	])
-
-	// 	editor.setSelectedShapeIds([ids.groupA])
-	// 	editor.setOpacity(0.5)
-
-	// 	// a wasn't selected...
-	// 	expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
-
-	// 	// b, c, & d were within a selected group...
-	// 	expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
-	// 	expect(editor.getShape(ids.boxC)!.opacity).toBe(0.5)
-	// 	expect(editor.getShape(ids.boxD)!.opacity).toBe(0.5)
-
-	// 	// groups get skipped
-	// 	expect(editor.getShape(ids.groupA)!.opacity).toBe(1)
-	// 	expect(editor.getShape(ids.groupB)!.opacity).toBe(1)
-	// })
+	it('should set opacity for selected shapes', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
+			<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
+		])
+
+		editor.setSelectedShapeIds([ids.A, ids.B])
+		editor.setOpacity(0.5)
+
+		expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
+	})
+
+	it('should traverse into groups and set opacity in their children', () => {
+		const ids = editor.createShapesFromJsx([
+			<TL.geo ref="boxA" x={0} y={0} />,
+			<TL.group ref="groupA" x={0} y={0}>
+				<TL.geo ref="boxB" x={0} y={0} />
+				<TL.group ref="groupB" x={0} y={0}>
+					<TL.geo ref="boxC" x={0} y={0} />
+					<TL.geo ref="boxD" x={0} y={0} />
+				</TL.group>
+			</TL.group>,
+		])
+
+		editor.setSelectedShapeIds([ids.groupA])
+		editor.setOpacity(0.5)
+
+		// a wasn't selected...
+		expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
+
+		// b, c, & d were within a selected group...
+		expect(editor.getShape(ids.boxB)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.boxC)!.opacity).toBe(0.5)
+		expect(editor.getShape(ids.boxD)!.opacity).toBe(0.5)
+
+		// groups get skipped
+		expect(editor.getShape(ids.groupA)!.opacity).toBe(1)
+		expect(editor.getShape(ids.groupB)!.opacity).toBe(1)
+	})
 
 	it('stores opacity on opacityForNextShape', () => {
 		editor.setOpacity(0.5)

commit 2be738e0cc3216138abaad41ba0fe808c31418ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Aug 3 15:10:41 2023 +0100

    Update setter names, `setXXShapeId` rather than `setXXId` (#1789)
    
    This PR is a follower on #1787 that adds some changes to how setters are
    named.
    
    ### Change Type
    
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 59310cfd3..0452ee43f 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -68,25 +68,25 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
-			editor.setEditingId(ids.box1)
+			editor.setEditingShapeId(ids.box1)
 			expect(editor.editingShapeId).toBe(ids.box1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of frame]', () => {
-			editor.setEditingId(ids.box2)
+			editor.setEditingShapeId(ids.box2)
 			expect(editor.editingShapeId).toBe(ids.box2)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of group]', () => {
-			editor.setEditingId(ids.box3)
+			editor.setEditingShapeId(ids.box3)
 			expect(editor.editingShapeId).toBe(ids.box3)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
-			editor.setEditingId(ids.frame1)
+			editor.setEditingShapeId(ids.frame1)
 			expect(editor.editingShapeId).toBe(ids.frame1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(ids.frame1)
@@ -95,13 +95,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setErasingIds([ids.box1, ids.box2, ids.box3])
+			editor.setErasingShapeIds([ids.box1, ids.box2, ids.box3])
 			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setErasingIds([ids.frame1])
+			editor.setErasingShapeIds([ids.frame1])
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])

commit 89914684467c1e18ef06fa702c82ed0f88a2ea09
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Aug 5 12:21:07 2023 +0100

    history options / markId / createPage (#1796)
    
    This PR:
    
    - adds history options to several commands in order to allow them to
    support squashing and ephemeral data (previously, these commands had
    boolean values for squashing / ephemeral)
    
    It also:
    - changes `markId` to return the editor instance rather than the mark id
    passed into the command
    - removes `focus` and `blur` commands
    - changes `createPage` parameters
    - unifies `animateShape` / `animateShapes` options
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 0452ee43f..f4cc0c45e 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -29,7 +29,7 @@ beforeEach(() => {
 	])
 
 	const page1 = editor.currentPageId
-	editor.createPage('page 2', ids.page2)
+	editor.createPage({ name: 'page 2', id: ids.page2 })
 	editor.setCurrentPage(page1)
 })
 
@@ -429,12 +429,12 @@ describe('isFocused', () => {
 		expect(focusMock).not.toHaveBeenCalled()
 		expect(blurMock).not.toHaveBeenCalled()
 
-		editor.focus()
+		editor.getContainer().focus()
 
 		expect(focusMock).toHaveBeenCalled()
 		expect(blurMock).not.toHaveBeenCalled()
 
-		editor.blur()
+		editor.getContainer().blur()
 
 		expect(blurMock).toHaveBeenCalled()
 	})
@@ -471,7 +471,7 @@ describe('getShapeUtil', () => {
 			{ id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 100, h: 100 } },
 		])
 		const page1 = editor.currentPageId
-		editor.createPage('page 2', ids.page2)
+		editor.createPage({ name: 'page 2', id: ids.page2 })
 		editor.setCurrentPage(page1)
 	})
 

commit 13ef8be58d158ae3dbbf3aedd8485bfb21402716
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Aug 6 13:05:35 2023 +0100

    Cleanup page state commands (#1800)
    
    This PR cleans up some APIs around the editor's current page state:
    
    - `setEditingShapeId` -> `setEditingShape`
    - `setHoveredShapeId` -> `setHoveredShape`
    - `setCroppingShapeId` -> `setCroppingShape`
    - `setFocusedGroupId` -> `setFocusedGroup`
    - `setErasingShapeIds` -> `setErasingShapes`
    - `setHintingShapeIds` -> `setHintingShapes`
    
    It also adds some additional computed getters, e.g.
    `Editor.croppingShape`.
    
    It also adds some errors around `setCroppingShape`.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index f4cc0c45e..cfe3f0d12 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -45,7 +45,7 @@ const moveShapesToPage2 = () => {
 
 describe('shapes that are moved to another page', () => {
 	it("should be excluded from the previous page's focusedGroupId", () => {
-		editor.setFocusedGroupId(ids.group1)
+		editor.setFocusedGroup(ids.group1)
 		expect(editor.focusedGroupId).toBe(ids.group1)
 		moveShapesToPage2()
 		expect(editor.focusedGroupId).toBe(editor.currentPageId)
@@ -53,13 +53,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setHintingIds([ids.box1, ids.box2, ids.box3])
+			editor.setHintingShapes([ids.box1, ids.box2, ids.box3])
 			expect(editor.hintingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setHintingIds([ids.frame1])
+			editor.setHintingShapes([ids.frame1])
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.hintingShapeIds).toEqual([ids.frame1])
@@ -68,25 +68,25 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
-			editor.setEditingShapeId(ids.box1)
+			editor.setEditingShape(ids.box1)
 			expect(editor.editingShapeId).toBe(ids.box1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of frame]', () => {
-			editor.setEditingShapeId(ids.box2)
+			editor.setEditingShape(ids.box2)
 			expect(editor.editingShapeId).toBe(ids.box2)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[child of group]', () => {
-			editor.setEditingShapeId(ids.box3)
+			editor.setEditingShape(ids.box3)
 			expect(editor.editingShapeId).toBe(ids.box3)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
-			editor.setEditingShapeId(ids.frame1)
+			editor.setEditingShape(ids.frame1)
 			expect(editor.editingShapeId).toBe(ids.frame1)
 			moveShapesToPage2()
 			expect(editor.editingShapeId).toBe(ids.frame1)
@@ -95,13 +95,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setErasingShapeIds([ids.box1, ids.box2, ids.box3])
+			editor.setErasingShapes([ids.box1, ids.box2, ids.box3])
 			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setErasingShapeIds([ids.frame1])
+			editor.setErasingShapes([ids.frame1])
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.erasingShapeIds).toEqual([ids.frame1])

commit 22329c51fcdb41111c7adf0fa4522cc675150738
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Aug 13 16:55:24 2023 +0100

    [improvement] More selection logic (#1806)
    
    This PR includes further UX improvements to selection.
    
    - clicking inside of a hollow shape will no longer select it on pointer
    up
    - clicking a shape's filled label will select it on pointer down
    - clicking a shape's empty label will select it on pointer up
    - clicking and dragging a selected arrow is now better limited to its
    body, not its bounds
    - arrows will no longer bind to labels
    
    ### Text labels
    
    A big change here relates to text labels. Previously, we had listeners
    set on the text label elements; I've removed these and we now check the
    actual label bounds geometry for a hit. For geo shapes, this geometry is
    now placed correctly based on the alignment / vertical alignment of the
    label.
    
    - Clicking on a label with text in it will select the shape on pointer
    down.
    - Clicking on an empty text label will select the shape on pointer up.
    
    ## Hollow shapes
    
    Previously, shapes with `fill: none` were also being selected on pointer
    up. I've removed that logic because it was producing wrong-feeling
    selections too often. We now select these shapes only when clicking on
    the label (as mentioned above) or when clicking on the edges of the
    shape. This is in line with the original behavior (currently on
    tldraw.com, prior to the earlier PR that updated selection logic).
    
    ## Arrows
    
    Arrows still hit the inside of hollow shapes, using the "smallest
    hovered" logic previously used for pointer-up selection on hollow
    shapes. They also now correctly do so while ignoring text labels.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. try selecting geo shapes, nested geo shapes, arrows and shapes with
    labels or without labels
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index cfe3f0d12..4d8852581 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -110,13 +110,13 @@ describe('shapes that are moved to another page', () => {
 
 	describe("should be excluded from the previous page's selectedShapeIds", () => {
 		test('[boxes]', () => {
-			editor.setSelectedShapeIds([ids.box1, ids.box2, ids.box3])
+			editor.setSelectedShapes([ids.box1, ids.box2, ids.box3])
 			expect(editor.selectedShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
 			expect(editor.selectedShapeIds).toEqual([])
 		})
 		test('[frame that does not move]', () => {
-			editor.setSelectedShapeIds([ids.frame1])
+			editor.setSelectedShapes([ids.frame1])
 			expect(editor.selectedShapeIds).toEqual([ids.frame1])
 			moveShapesToPage2()
 			expect(editor.selectedShapeIds).toEqual([ids.frame1])
@@ -156,7 +156,7 @@ describe('Editor.sharedOpacity', () => {
 
 	it('should return opacity for a single selected shape', () => {
 		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
-		editor.setSelectedShapeIds([A])
+		editor.setSelectedShapes([A])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
@@ -165,7 +165,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
 			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
 		])
-		editor.setSelectedShapeIds([A, B])
+		editor.setSelectedShapes([A, B])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
@@ -174,7 +174,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="A" opacity={0.3} x={0} y={0} />,
 			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
 		])
-		editor.setSelectedShapeIds([A, B])
+		editor.setSelectedShapes([A, B])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
 	})
 
@@ -184,7 +184,7 @@ describe('Editor.sharedOpacity', () => {
 				<TL.geo ref="A" opacity={0.3} x={0} y={0} />
 			</TL.group>,
 		])
-		editor.setSelectedShapeIds([ids.group])
+		editor.setSelectedShapes([ids.group])
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 })
@@ -196,7 +196,7 @@ describe('Editor.setOpacity', () => {
 			<TL.geo ref="B" opacity={0.4} x={0} y={0} />,
 		])
 
-		editor.setSelectedShapeIds([ids.A, ids.B])
+		editor.setSelectedShapes([ids.A, ids.B])
 		editor.setOpacity(0.5)
 
 		expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
@@ -215,7 +215,7 @@ describe('Editor.setOpacity', () => {
 			</TL.group>,
 		])
 
-		editor.setSelectedShapeIds([ids.groupA])
+		editor.setSelectedShapes([ids.groupA])
 		editor.setOpacity(0.5)
 
 		// a wasn't selected...

commit 2c7c97af9c766d0579f969e4eb03a115acd7b418
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 23 12:14:49 2023 +0200

    [fix] style changes (#1814)
    
    This PR updates the way that styles are changed. It splits `setStyle`
    and `setOpacity` into `setStyleForNext Shape` and
    `setOpacityForNextShape` and `setStyleForSelectedShapes` and
    `setOpacityForSelectedShapes`. It fixes the issue with setting one style
    re-setting other styles.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Set styles when shapes are not selected.
    2. Set styles when shapes are selected.
    3. Set styles when shapes are selected and the selected tool is not
    select.
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 4d8852581..8acae1d0f 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -150,7 +150,8 @@ it('Does not create an undo stack item when first clicking on an empty canvas',
 describe('Editor.sharedOpacity', () => {
 	it('should return the current opacity', () => {
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
-		editor.setOpacity(0.5)
+		editor.setOpacityForSelectedShapes(0.5)
+		editor.setOpacityForNextShapes(0.5)
 		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
 	})
 
@@ -197,7 +198,8 @@ describe('Editor.setOpacity', () => {
 		])
 
 		editor.setSelectedShapes([ids.A, ids.B])
-		editor.setOpacity(0.5)
+		editor.setOpacityForSelectedShapes(0.5)
+		editor.setOpacityForNextShapes(0.5)
 
 		expect(editor.getShape(ids.A)!.opacity).toBe(0.5)
 		expect(editor.getShape(ids.B)!.opacity).toBe(0.5)
@@ -216,7 +218,8 @@ describe('Editor.setOpacity', () => {
 		])
 
 		editor.setSelectedShapes([ids.groupA])
-		editor.setOpacity(0.5)
+		editor.setOpacityForSelectedShapes(0.5)
+		editor.setOpacityForNextShapes(0.5)
 
 		// a wasn't selected...
 		expect(editor.getShape(ids.boxA)!.opacity).toBe(1)
@@ -232,9 +235,11 @@ describe('Editor.setOpacity', () => {
 	})
 
 	it('stores opacity on opacityForNextShape', () => {
-		editor.setOpacity(0.5)
+		editor.setOpacityForSelectedShapes(0.5)
+		editor.setOpacityForNextShapes(0.5)
 		expect(editor.instanceState.opacityForNextShape).toBe(0.5)
-		editor.setOpacity(0.6)
+		editor.setOpacityForSelectedShapes(0.6)
+		editor.setOpacityForNextShapes(0.6)
 		expect(editor.instanceState.opacityForNextShape).toBe(0.6)
 	})
 })

commit 48a1bb4d88b16f3b1cf42246e7690a1754e3befc
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Sep 8 18:04:53 2023 +0100

    Migrate snapshot (#1843)
    
    Add `Store.migrateSnapshot`, another surface API alongside getSnapshot
    and loadSnapshot.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Release Notes
    
    - [editor] add `Store.migrateSnapshot`

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 8acae1d0f..66429bce9 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -1,4 +1,10 @@
-import { BaseBoxShapeUtil, PageRecordType, TLShape, createShapeId } from '@tldraw/editor'
+import {
+	AssetRecordType,
+	BaseBoxShapeUtil,
+	PageRecordType,
+	TLShape,
+	createShapeId,
+} from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
 import { TL } from './test-jsx'
 
@@ -504,3 +510,73 @@ describe('getShapeUtil', () => {
 		)
 	})
 })
+
+describe('snapshots', () => {
+	it('creates and loads a snapshot', () => {
+		const ids = {
+			imageA: createShapeId('imageA'),
+			boxA: createShapeId('boxA'),
+			imageAssetA: AssetRecordType.createId('imageAssetA'),
+		}
+
+		editor.createAssets([
+			{
+				type: 'image',
+				id: ids.imageAssetA,
+				typeName: 'asset',
+				props: {
+					w: 1200,
+					h: 800,
+					name: '',
+					isAnimated: false,
+					mimeType: 'png',
+					src: '',
+				},
+				meta: {},
+			},
+		])
+
+		editor.createShapes([
+			{ type: 'geo', x: 0, y: 0 },
+			{ type: 'geo', x: 100, y: 0 },
+			{
+				id: ids.imageA,
+				type: 'image',
+				props: {
+					playing: false,
+					url: '',
+					w: 1200,
+					h: 800,
+					assetId: ids.imageAssetA,
+				},
+				x: 0,
+				y: 1200,
+			},
+		])
+
+		const page2Id = PageRecordType.createId('page2')
+
+		editor.createPage({
+			id: page2Id,
+		})
+
+		editor.setCurrentPage(page2Id)
+
+		editor.createShapes([
+			{ type: 'geo', x: 0, y: 0 },
+			{ type: 'geo', x: 100, y: 0 },
+		])
+
+		editor.selectAll()
+
+		// now serialize
+
+		const snapshot = editor.store.getSnapshot()
+
+		const newEditor = new TestEditor()
+
+		newEditor.store.loadSnapshot(snapshot)
+
+		expect(editor.store.serialize()).toEqual(newEditor.store.serialize())
+	})
+})

commit 20704ea41768f0746480bd840b008ecda9778627
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Sep 9 10:41:06 2023 +0100

    [fix] iframe losing focus on pointer down (#1848)
    
    This PR fixes a bug that would cause an interactive iframe (e.g. a
    youtube video) to lose its editing state once clicked.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create an interactive iframe.
    2. Begin editing.
    3. Click inside of the iframe

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 66429bce9..fe998aed5 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -4,6 +4,7 @@ import {
 	PageRecordType,
 	TLShape,
 	createShapeId,
+	debounce,
 } from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
 import { TL } from './test-jsx'
@@ -356,6 +357,33 @@ describe('currentToolId', () => {
 })
 
 describe('isFocused', () => {
+	beforeEach(() => {
+		// lame but duplicated here since this was moved into a hook
+		const container = editor.getContainer()
+
+		const updateFocus = debounce(() => {
+			const { activeElement } = document
+			const { isFocused: wasFocused } = editor.instanceState
+			const isFocused =
+				document.hasFocus() && (container === activeElement || container.contains(activeElement))
+
+			if (wasFocused !== isFocused) {
+				editor.updateInstanceState({ isFocused })
+				editor.updateViewportScreenBounds()
+
+				if (!isFocused) {
+					// When losing focus, run complete() to ensure that any interacts end
+					editor.complete()
+				}
+			}
+		}, 32)
+
+		container.addEventListener('focusin', updateFocus)
+		container.addEventListener('focus', updateFocus)
+		container.addEventListener('focusout', updateFocus)
+		container.addEventListener('blur', updateFocus)
+	})
+
 	it('is false by default', () => {
 		expect(editor.instanceState.isFocused).toBe(false)
 	})

commit 3d30f77ac1035cf6c9ba1d4c47b134a49530a7a9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Sep 29 16:20:39 2023 +0100

    Make user preferences optional (#1963)
    
    This PR makes it so that user preferences can be in a 'null' state,
    where we use the default values and/or infer from the system
    preferences.
    
    Before this PR it was impossible to allow a user to change their locale
    via their system config rather than selecting an explicit value in the
    tldraw editor menu. Similarly, it was impossible to adapt to changes in
    the user's system preferences for dark/light mode.
    
    That's because we saved the full user preference values the first time
    the user loaded tldraw, and the only way for them to change after that
    is by saving new values.
    
    After this PR, if a value is `null` we will use the 'default' version of
    it, which can be inferred based on the user's system preferences in the
    case of dark mode, locale, and animation speed. Then if the user changes
    their system config and refreshes the page their changes should be
    picked up by tldraw where they previously wouldn't have been.
    
    Dark mode inference is opt-in by setting a prop `inferDarkMode: true` on
    the `Editor` instance (and the `<Tldraw />` components), because we
    don't want it to be a surprise for existing library users.
    
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [x] `major` — Breaking change
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index fe998aed5..410636abf 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -608,3 +608,57 @@ describe('snapshots', () => {
 		expect(editor.store.serialize()).toEqual(newEditor.store.serialize())
 	})
 })
+
+describe('when the user prefers dark UI', () => {
+	beforeEach(() => {
+		window.matchMedia = jest.fn().mockImplementation((query) => {
+			return {
+				matches: query === '(prefers-color-scheme: dark)',
+				media: query,
+				onchange: null,
+				addEventListener: jest.fn(),
+				removeEventListener: jest.fn(),
+				dispatchEvent: jest.fn(),
+			}
+		})
+	})
+	it('isDarkMode should be false by default', () => {
+		editor = new TestEditor({})
+		expect(editor.user.isDarkMode).toBe(false)
+	})
+	it('isDarkMode should be false when inferDarkMode is false', () => {
+		editor = new TestEditor({ inferDarkMode: false })
+		expect(editor.user.isDarkMode).toBe(false)
+	})
+	it('should be true if the editor was instantiated with inferDarkMode', () => {
+		editor = new TestEditor({ inferDarkMode: true })
+		expect(editor.user.isDarkMode).toBe(true)
+	})
+})
+
+describe('when the user prefers light UI', () => {
+	beforeEach(() => {
+		window.matchMedia = jest.fn().mockImplementation((query) => {
+			return {
+				matches: false,
+				media: query,
+				onchange: null,
+				addEventListener: jest.fn(),
+				removeEventListener: jest.fn(),
+				dispatchEvent: jest.fn(),
+			}
+		})
+	})
+	it('isDarkMode should be false by default', () => {
+		editor = new TestEditor({})
+		expect(editor.user.isDarkMode).toBe(false)
+	})
+	it('isDarkMode should be false when inferDarkMode is false', () => {
+		editor = new TestEditor({ inferDarkMode: false })
+		expect(editor.user.isDarkMode).toBe(false)
+	})
+	it('should be false if the editor was instantiated with inferDarkMode', () => {
+		editor = new TestEditor({ inferDarkMode: true })
+		expect(editor.user.isDarkMode).toBe(false)
+	})
+})

commit da33179a313f92f8b4f335cca7f45762f9f38075
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Oct 2 12:29:54 2023 +0100

    Remove focus management (#1953)
    
    This PR removes the automatic focus events from the editor.
    
    The `autoFocus` prop is now true by default. When true, the editor will
    begin in a focused state (`editor.instanceState.isFocused` will be
    `true`) and the component will respond to keyboard shortcuts and other
    interactions. When false, the editor will begin in an unfocused state
    and not respond to keyboard interactions.
    
    **It's now up to the developer** using the component to update
    `isFocused` themselves. There's no predictable way to do that on our
    side, so we leave it to the developer to decide when to turn on or off
    focus for a container (for example, using an intersection observer to
    "unfocus" components that are off screen).
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Open the multiple editors example.
    2. Click to focus each editor.
    3. Use the keyboard shortcuts to check that the correct editor is
    focused.
    4. Start editing a shape, then select the other editor. The first
    editing shape should complete.
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [editor] Make autofocus default, remove automatic blur / focus events.
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 410636abf..6b7bd71ed 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -460,23 +460,6 @@ describe('isFocused', () => {
 		jest.advanceTimersByTime(100)
 		expect(editor.instanceState.isFocused).toBe(false)
 	})
-
-	it('calls .focus() and .blur() on the container div when you call .focus() and .blur() on the editor', () => {
-		const focusMock = jest.spyOn(editor.elm, 'focus').mockImplementation()
-		const blurMock = jest.spyOn(editor.elm, 'blur').mockImplementation()
-
-		expect(focusMock).not.toHaveBeenCalled()
-		expect(blurMock).not.toHaveBeenCalled()
-
-		editor.getContainer().focus()
-
-		expect(focusMock).toHaveBeenCalled()
-		expect(blurMock).not.toHaveBeenCalled()
-
-		editor.getContainer().blur()
-
-		expect(blurMock).toHaveBeenCalled()
-	})
 })
 
 describe('getShapeUtil', () => {

commit 5db3c1553e14edd14aa5f7c0fc85fc5efc352335
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Nov 13 11:51:22 2023 +0000

    Replace Atom.value with Atom.get() (#2189)
    
    This PR replaces the `.value` getter for the atom with `.get()`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 6b7bd71ed..e455d7b14 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -151,7 +151,7 @@ it('Does not create an undo stack item when first clicking on an empty canvas',
 	editor = new TestEditor()
 	editor.pointerMove(50, 50)
 	editor.click(0, 0)
-	expect(editor.canUndo).toBe(false)
+	expect(editor.getCanUndo()).toBe(false)
 })
 
 describe('Editor.sharedOpacity', () => {
@@ -244,10 +244,10 @@ describe('Editor.setOpacity', () => {
 	it('stores opacity on opacityForNextShape', () => {
 		editor.setOpacityForSelectedShapes(0.5)
 		editor.setOpacityForNextShapes(0.5)
-		expect(editor.instanceState.opacityForNextShape).toBe(0.5)
+		expect(editor.getInstanceState().opacityForNextShape).toBe(0.5)
 		editor.setOpacityForSelectedShapes(0.6)
 		editor.setOpacityForNextShapes(0.6)
-		expect(editor.instanceState.opacityForNextShape).toBe(0.6)
+		expect(editor.getInstanceState().opacityForNextShape).toBe(0.6)
 	})
 })
 
@@ -293,66 +293,66 @@ describe('Editor.TickManager', () => {
 describe("App's default tool", () => {
 	it('Is select for regular app', () => {
 		editor = new TestEditor()
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 	})
 	it('Is hand for readonly mode', () => {
 		editor = new TestEditor()
 		editor.updateInstanceState({ isReadonly: true })
 		editor.setCurrentTool('hand')
-		expect(editor.currentToolId).toBe('hand')
+		expect(editor.getCurrentToolId()).toBe('hand')
 	})
 })
 
 describe('currentToolId', () => {
 	it('is select by default', () => {
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 	})
 	it('is set to the last used tool', () => {
 		editor.setCurrentTool('draw')
-		expect(editor.currentToolId).toBe('draw')
+		expect(editor.getCurrentToolId()).toBe('draw')
 
 		editor.setCurrentTool('geo')
-		expect(editor.currentToolId).toBe('geo')
+		expect(editor.getCurrentToolId()).toBe('geo')
 	})
 	it('stays the selected tool during shape creation interactions that technically use the select tool', () => {
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 
 		editor.setCurrentTool('geo')
 		editor.pointerDown(0, 0)
 		editor.pointerMove(100, 100)
 
-		expect(editor.currentToolId).toBe('geo')
-		expect(editor.root.path.value).toBe('root.select.resizing')
+		expect(editor.getCurrentToolId()).toBe('geo')
+		expect(editor.root.path.get()).toBe('root.select.resizing')
 	})
 
 	it('reverts back to select if we finish the interaction', () => {
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 
 		editor.setCurrentTool('geo')
 		editor.pointerDown(0, 0)
 		editor.pointerMove(100, 100)
 
-		expect(editor.currentToolId).toBe('geo')
-		expect(editor.root.path.value).toBe('root.select.resizing')
+		expect(editor.getCurrentToolId()).toBe('geo')
+		expect(editor.root.path.get()).toBe('root.select.resizing')
 
 		editor.pointerUp(100, 100)
 
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 	})
 
 	it('stays on the selected tool if we cancel the interaction', () => {
-		expect(editor.currentToolId).toBe('select')
+		expect(editor.getCurrentToolId()).toBe('select')
 
 		editor.setCurrentTool('geo')
 		editor.pointerDown(0, 0)
 		editor.pointerMove(100, 100)
 
-		expect(editor.currentToolId).toBe('geo')
-		expect(editor.root.path.value).toBe('root.select.resizing')
+		expect(editor.getCurrentToolId()).toBe('geo')
+		expect(editor.root.path.get()).toBe('root.select.resizing')
 
 		editor.cancel()
 
-		expect(editor.currentToolId).toBe('geo')
+		expect(editor.getCurrentToolId()).toBe('geo')
 	})
 })
 
@@ -363,7 +363,7 @@ describe('isFocused', () => {
 
 		const updateFocus = debounce(() => {
 			const { activeElement } = document
-			const { isFocused: wasFocused } = editor.instanceState
+			const { isFocused: wasFocused } = editor.getInstanceState()
 			const isFocused =
 				document.hasFocus() && (container === activeElement || container.contains(activeElement))
 
@@ -385,48 +385,48 @@ describe('isFocused', () => {
 	})
 
 	it('is false by default', () => {
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
 	it('becomes true when you call .focus()', () => {
 		editor.updateInstanceState({ isFocused: true })
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 	})
 
 	it('becomes false when you call .blur()', () => {
 		editor.updateInstanceState({ isFocused: true })
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 
 		editor.updateInstanceState({ isFocused: false })
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
 	it('remains false when you call .blur()', () => {
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 		editor.updateInstanceState({ isFocused: false })
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
 	it('becomes true when the container div receives a focus event', () => {
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 
 		editor.elm.focus()
 
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 	})
 
 	it('becomes false when the container div receives a blur event', () => {
 		editor.elm.focus()
 
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 
 		editor.elm.blur()
 
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
 	it.skip('becomes true when a child of the app container div receives a focusin event', () => {
@@ -438,13 +438,13 @@ describe('isFocused', () => {
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 		child.dispatchEvent(new FocusEvent('focusin', { bubbles: true }))
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
 	it('becomes false when a child of the app container div receives a focusout event', () => {
@@ -453,12 +453,12 @@ describe('isFocused', () => {
 
 		editor.updateInstanceState({ isFocused: true })
 
-		expect(editor.instanceState.isFocused).toBe(true)
+		expect(editor.getInstanceState().isFocused).toBe(true)
 
 		child.dispatchEvent(new FocusEvent('focusout', { bubbles: true }))
 
 		jest.advanceTimersByTime(100)
-		expect(editor.instanceState.isFocused).toBe(false)
+		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 })
 

commit 2ca2f81f2aac16790c73bd334eda53a35a9d9f45
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 12:42:07 2023 +0000

    No impure getters pt2 (#2202)
    
    follow up to #2189

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index e455d7b14..f2f5aaca3 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -118,15 +118,15 @@ describe('shapes that are moved to another page', () => {
 	describe("should be excluded from the previous page's selectedShapeIds", () => {
 		test('[boxes]', () => {
 			editor.setSelectedShapes([ids.box1, ids.box2, ids.box3])
-			expect(editor.selectedShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
+			expect(editor.getSelectedShapeIds()).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.selectedShapeIds).toEqual([])
+			expect(editor.getSelectedShapeIds()).toEqual([])
 		})
 		test('[frame that does not move]', () => {
 			editor.setSelectedShapes([ids.frame1])
-			expect(editor.selectedShapeIds).toEqual([ids.frame1])
+			expect(editor.getSelectedShapeIds()).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.selectedShapeIds).toEqual([ids.frame1])
+			expect(editor.getSelectedShapeIds()).toEqual([ids.frame1])
 		})
 	})
 })

commit daf729d45c879d4e234d9417570149ad854f635b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 16:02:50 2023 +0000

    No impure getters pt4 (#2206)
    
    follow up to #2189 and #2203
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index f2f5aaca3..58f4f2432 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -53,9 +53,9 @@ const moveShapesToPage2 = () => {
 describe('shapes that are moved to another page', () => {
 	it("should be excluded from the previous page's focusedGroupId", () => {
 		editor.setFocusedGroup(ids.group1)
-		expect(editor.focusedGroupId).toBe(ids.group1)
+		expect(editor.getFocusedGroupId()).toBe(ids.group1)
 		moveShapesToPage2()
-		expect(editor.focusedGroupId).toBe(editor.currentPageId)
+		expect(editor.getFocusedGroupId()).toBe(editor.currentPageId)
 	})
 
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
@@ -76,27 +76,27 @@ describe('shapes that are moved to another page', () => {
 	describe("should be excluded from the previous page's editingShapeId", () => {
 		test('[root shape]', () => {
 			editor.setEditingShape(ids.box1)
-			expect(editor.editingShapeId).toBe(ids.box1)
+			expect(editor.getEditingShapeId()).toBe(ids.box1)
 			moveShapesToPage2()
-			expect(editor.editingShapeId).toBe(null)
+			expect(editor.getEditingShapeId()).toBe(null)
 		})
 		test('[child of frame]', () => {
 			editor.setEditingShape(ids.box2)
-			expect(editor.editingShapeId).toBe(ids.box2)
+			expect(editor.getEditingShapeId()).toBe(ids.box2)
 			moveShapesToPage2()
-			expect(editor.editingShapeId).toBe(null)
+			expect(editor.getEditingShapeId()).toBe(null)
 		})
 		test('[child of group]', () => {
 			editor.setEditingShape(ids.box3)
-			expect(editor.editingShapeId).toBe(ids.box3)
+			expect(editor.getEditingShapeId()).toBe(ids.box3)
 			moveShapesToPage2()
-			expect(editor.editingShapeId).toBe(null)
+			expect(editor.getEditingShapeId()).toBe(null)
 		})
 		test('[frame that doesnt move]', () => {
 			editor.setEditingShape(ids.frame1)
-			expect(editor.editingShapeId).toBe(ids.frame1)
+			expect(editor.getEditingShapeId()).toBe(ids.frame1)
 			moveShapesToPage2()
-			expect(editor.editingShapeId).toBe(ids.frame1)
+			expect(editor.getEditingShapeId()).toBe(ids.frame1)
 		})
 	})
 

commit 9d783f65cb522f1fc8009e8f3923124d8db131d3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 10:23:03 2023 +0000

    No impure getters pt5 (#2208)
    
    Follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 58f4f2432..05f168fd8 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -61,15 +61,15 @@ describe('shapes that are moved to another page', () => {
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
 		test('[boxes]', () => {
 			editor.setHintingShapes([ids.box1, ids.box2, ids.box3])
-			expect(editor.hintingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
+			expect(editor.getHintingShapeIds()).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.hintingShapeIds).toEqual([])
+			expect(editor.getHintingShapeIds()).toEqual([])
 		})
 		test('[frame that does not move]', () => {
 			editor.setHintingShapes([ids.frame1])
-			expect(editor.hintingShapeIds).toEqual([ids.frame1])
+			expect(editor.getHintingShapeIds()).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.hintingShapeIds).toEqual([ids.frame1])
+			expect(editor.getHintingShapeIds()).toEqual([ids.frame1])
 		})
 	})
 
@@ -103,15 +103,15 @@ describe('shapes that are moved to another page', () => {
 	describe("should be excluded from the previous page's erasingShapeIds", () => {
 		test('[boxes]', () => {
 			editor.setErasingShapes([ids.box1, ids.box2, ids.box3])
-			expect(editor.erasingShapeIds).toEqual([ids.box1, ids.box2, ids.box3])
+			expect(editor.getErasingShapeIds()).toEqual([ids.box1, ids.box2, ids.box3])
 			moveShapesToPage2()
-			expect(editor.erasingShapeIds).toEqual([])
+			expect(editor.getErasingShapeIds()).toEqual([])
 		})
 		test('[frame that does not move]', () => {
 			editor.setErasingShapes([ids.frame1])
-			expect(editor.erasingShapeIds).toEqual([ids.frame1])
+			expect(editor.getErasingShapeIds()).toEqual([ids.frame1])
 			moveShapesToPage2()
-			expect(editor.erasingShapeIds).toEqual([ids.frame1])
+			expect(editor.getErasingShapeIds()).toEqual([ids.frame1])
 		})
 	})
 

commit 7186368f0d4cb7fbe59a59ffa4265908e8f48eae
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Nov 14 13:02:50 2023 +0000

    StateNode atoms (#2213)
    
    This PR extracts some improvements from #2198 into a separate PR.
    
    ### Release Notes
    - adds computed `StateNode.getPath`
    - adds computed StateNode.getCurrent`
    - adds computed StateNode.getIsActive`
    - adds computed `Editor.getPath()`
    - makes transition's second property optional
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 05f168fd8..3ff815d67 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -322,7 +322,7 @@ describe('currentToolId', () => {
 		editor.pointerMove(100, 100)
 
 		expect(editor.getCurrentToolId()).toBe('geo')
-		expect(editor.root.path.get()).toBe('root.select.resizing')
+		editor.expectToBeIn('select.resizing')
 	})
 
 	it('reverts back to select if we finish the interaction', () => {
@@ -333,7 +333,7 @@ describe('currentToolId', () => {
 		editor.pointerMove(100, 100)
 
 		expect(editor.getCurrentToolId()).toBe('geo')
-		expect(editor.root.path.get()).toBe('root.select.resizing')
+		editor.expectToBeIn('select.resizing')
 
 		editor.pointerUp(100, 100)
 
@@ -348,7 +348,7 @@ describe('currentToolId', () => {
 		editor.pointerMove(100, 100)
 
 		expect(editor.getCurrentToolId()).toBe('geo')
-		expect(editor.root.path.get()).toBe('root.select.resizing')
+		editor.expectToBeIn('select.resizing')
 
 		editor.cancel()
 

commit dc0f6ae0f25518342de828498998c5c7241da7b0
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 16:32:27 2023 +0000

    No impure getters pt8 (#2221)
    
    follow up to #2189
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 3ff815d67..2ec1e1d7a 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -156,16 +156,16 @@ it('Does not create an undo stack item when first clicking on an empty canvas',
 
 describe('Editor.sharedOpacity', () => {
 	it('should return the current opacity', () => {
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 1 })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 1 })
 		editor.setOpacityForSelectedShapes(0.5)
 		editor.setOpacityForNextShapes(0.5)
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.5 })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.5 })
 	})
 
 	it('should return opacity for a single selected shape', () => {
 		const { A } = editor.createShapesFromJsx(<TL.geo ref="A" opacity={0.3} x={0} y={0} />)
 		editor.setSelectedShapes([A])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
 	it('should return opacity for multiple selected shapes', () => {
@@ -174,7 +174,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="B" opacity={0.3} x={0} y={0} />,
 		])
 		editor.setSelectedShapes([A, B])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 
 	it('should return mixed when multiple selected shapes have different opacity', () => {
@@ -183,7 +183,7 @@ describe('Editor.sharedOpacity', () => {
 			<TL.geo ref="B" opacity={0.5} x={0} y={0} />,
 		])
 		editor.setSelectedShapes([A, B])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'mixed' })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'mixed' })
 	})
 
 	it('ignores the opacity of groups and returns the opacity of their children', () => {
@@ -193,7 +193,7 @@ describe('Editor.sharedOpacity', () => {
 			</TL.group>,
 		])
 		editor.setSelectedShapes([ids.group])
-		expect(editor.sharedOpacity).toStrictEqual({ type: 'shared', value: 0.3 })
+		expect(editor.getSharedOpacity()).toStrictEqual({ type: 'shared', value: 0.3 })
 	})
 })
 

commit d683cc09432197e89bddacf2b706b5eaad40e399
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 17:07:35 2023 +0000

    No impure getters pt9 (#2222)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 2ec1e1d7a..5ce46e48d 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -607,15 +607,15 @@ describe('when the user prefers dark UI', () => {
 	})
 	it('isDarkMode should be false by default', () => {
 		editor = new TestEditor({})
-		expect(editor.user.isDarkMode).toBe(false)
+		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 	it('isDarkMode should be false when inferDarkMode is false', () => {
 		editor = new TestEditor({ inferDarkMode: false })
-		expect(editor.user.isDarkMode).toBe(false)
+		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 	it('should be true if the editor was instantiated with inferDarkMode', () => {
 		editor = new TestEditor({ inferDarkMode: true })
-		expect(editor.user.isDarkMode).toBe(true)
+		expect(editor.user.getIsDarkMode()).toBe(true)
 	})
 })
 
@@ -634,14 +634,14 @@ describe('when the user prefers light UI', () => {
 	})
 	it('isDarkMode should be false by default', () => {
 		editor = new TestEditor({})
-		expect(editor.user.isDarkMode).toBe(false)
+		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 	it('isDarkMode should be false when inferDarkMode is false', () => {
 		editor = new TestEditor({ inferDarkMode: false })
-		expect(editor.user.isDarkMode).toBe(false)
+		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 	it('should be false if the editor was instantiated with inferDarkMode', () => {
 		editor = new TestEditor({ inferDarkMode: true })
-		expect(editor.user.isDarkMode).toBe(false)
+		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 })

commit 34cfb85169e02178a20dd9e7b7c0c4e48b1428c4
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Nov 16 15:34:56 2023 +0000

    no impure getters pt 11 (#2236)
    
    follow up to #2189
    
    adds runtime warnings for deprecated fields. cleans up remaining fields
    and usages. Adds a lint rule to prevent access to deprecated fields.
    Adds a lint rule to prevent using getters.
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 5ce46e48d..c138e0b3e 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -35,7 +35,7 @@ beforeEach(() => {
 		{ id: ids.box3, type: 'geo', x: 500, y: 500, props: { w: 100, h: 100 }, parentId: ids.group1 },
 	])
 
-	const page1 = editor.currentPageId
+	const page1 = editor.getCurrentPageId()
 	editor.createPage({ name: 'page 2', id: ids.page2 })
 	editor.setCurrentPage(page1)
 })
@@ -55,7 +55,7 @@ describe('shapes that are moved to another page', () => {
 		editor.setFocusedGroup(ids.group1)
 		expect(editor.getFocusedGroupId()).toBe(ids.group1)
 		moveShapesToPage2()
-		expect(editor.getFocusedGroupId()).toBe(editor.currentPageId)
+		expect(editor.getFocusedGroupId()).toBe(editor.getCurrentPageId())
 	})
 
 	describe("should be excluded from the previous page's hintingShapeIds", () => {
@@ -492,7 +492,7 @@ describe('getShapeUtil', () => {
 		editor.createShapes([
 			{ id: ids.box1, type: 'blorg', x: 100, y: 100, props: { w: 100, h: 100 } },
 		])
-		const page1 = editor.currentPageId
+		const page1 = editor.getCurrentPageId()
 		editor.createPage({ name: 'page 2', id: ids.page2 })
 		editor.setCurrentPage(page1)
 	})

commit f7ae99dd1fc906089834c96055b83ad5871eba21
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Dec 8 10:35:35 2023 +0000

    zoom to affected shapes after undo/redo (#2293)
    
    This PR makes it so that any shapes affected by an undo/redo action,
    along with any shapes that are selected after an undo/redo action, are
    visible in the viewport.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    
    ### Release Notes
    
    - Make sure affected shapes are visible after undo/redo

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index c138e0b3e..46d92ab27 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -1,6 +1,7 @@
 import {
 	AssetRecordType,
 	BaseBoxShapeUtil,
+	Box2d,
 	PageRecordType,
 	TLShape,
 	createShapeId,
@@ -645,3 +646,89 @@ describe('when the user prefers light UI', () => {
 		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 })
+
+describe('undo and redo', () => {
+	test('cause the camera to move if the affected shapes are offscreen', () => {
+		editor = new TestEditor({})
+		editor.setScreenBounds(new Box2d(0, 0, 1000, 1000))
+		editor.user.updateUserPreferences({ animationSpeed: 0 })
+
+		const boxId = createShapeId('box')
+		editor.createShapes([{ id: boxId, type: 'geo', x: 100, y: 100, props: { w: 100, h: 100 } }])
+		editor.panZoomIntoView([boxId])
+		editor.mark()
+		const cameraBefore = editor.getCamera()
+
+		editor.updateShapes([
+			{
+				id: boxId,
+				type: 'geo',
+				x: 100,
+				y: 100,
+				props: {
+					geo: 'cloud',
+					w: 100,
+					h: 100,
+				},
+			},
+		])
+
+		expect(editor.getCamera()).toMatchInlineSnapshot(`
+		Object {
+		  "id": "camera:page:page",
+		  "meta": Object {},
+		  "typeName": "camera",
+		  "x": 0,
+		  "y": 0,
+		  "z": 1,
+		}
+	`)
+
+		editor.undo()
+		expect(editor.getCamera()).toEqual(cameraBefore)
+
+		editor.updateShapes([
+			{
+				id: boxId,
+				type: 'geo',
+				x: -500,
+				y: -500,
+			},
+		])
+		editor.mark()
+		editor.updateShapes([
+			{
+				id: boxId,
+				type: 'geo',
+				x: 500,
+				y: 500,
+			},
+		])
+		editor.undo()
+
+		expect(editor.getCamera()).not.toEqual(cameraBefore)
+		expect(editor.getCamera()).toMatchInlineSnapshot(`
+		Object {
+		  "id": "camera:page:page",
+		  "meta": Object {},
+		  "typeName": "camera",
+		  "x": 950,
+		  "y": 950,
+		  "z": 1,
+		}
+	`)
+
+		editor.redo()
+
+		expect(editor.getCamera()).toMatchInlineSnapshot(`
+		Object {
+		  "id": "camera:page:page",
+		  "meta": Object {},
+		  "typeName": "camera",
+		  "x": -50,
+		  "y": -50,
+		  "z": 1,
+		}
+	`)
+	})
+})

commit be93cc0eb6d8554d04273d67dbb2a08dfb8e469c
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Dec 12 11:36:52 2023 +0000

    Revert "zoom to affected shapes after undo/redo" (#2310)
    
    Reverts tldraw/tldraw#2293

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 46d92ab27..c138e0b3e 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -1,7 +1,6 @@
 import {
 	AssetRecordType,
 	BaseBoxShapeUtil,
-	Box2d,
 	PageRecordType,
 	TLShape,
 	createShapeId,
@@ -646,89 +645,3 @@ describe('when the user prefers light UI', () => {
 		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 })
-
-describe('undo and redo', () => {
-	test('cause the camera to move if the affected shapes are offscreen', () => {
-		editor = new TestEditor({})
-		editor.setScreenBounds(new Box2d(0, 0, 1000, 1000))
-		editor.user.updateUserPreferences({ animationSpeed: 0 })
-
-		const boxId = createShapeId('box')
-		editor.createShapes([{ id: boxId, type: 'geo', x: 100, y: 100, props: { w: 100, h: 100 } }])
-		editor.panZoomIntoView([boxId])
-		editor.mark()
-		const cameraBefore = editor.getCamera()
-
-		editor.updateShapes([
-			{
-				id: boxId,
-				type: 'geo',
-				x: 100,
-				y: 100,
-				props: {
-					geo: 'cloud',
-					w: 100,
-					h: 100,
-				},
-			},
-		])
-
-		expect(editor.getCamera()).toMatchInlineSnapshot(`
-		Object {
-		  "id": "camera:page:page",
-		  "meta": Object {},
-		  "typeName": "camera",
-		  "x": 0,
-		  "y": 0,
-		  "z": 1,
-		}
-	`)
-
-		editor.undo()
-		expect(editor.getCamera()).toEqual(cameraBefore)
-
-		editor.updateShapes([
-			{
-				id: boxId,
-				type: 'geo',
-				x: -500,
-				y: -500,
-			},
-		])
-		editor.mark()
-		editor.updateShapes([
-			{
-				id: boxId,
-				type: 'geo',
-				x: 500,
-				y: 500,
-			},
-		])
-		editor.undo()
-
-		expect(editor.getCamera()).not.toEqual(cameraBefore)
-		expect(editor.getCamera()).toMatchInlineSnapshot(`
-		Object {
-		  "id": "camera:page:page",
-		  "meta": Object {},
-		  "typeName": "camera",
-		  "x": 950,
-		  "y": 950,
-		  "z": 1,
-		}
-	`)
-
-		editor.redo()
-
-		expect(editor.getCamera()).toMatchInlineSnapshot(`
-		Object {
-		  "id": "camera:page:page",
-		  "meta": Object {},
-		  "typeName": "camera",
-		  "x": -50,
-		  "y": -50,
-		  "z": 1,
-		}
-	`)
-	})
-})

commit d0f6ef80fcf93311efee6b1c0861d0eadf9f81bd
Author: Dan Groshev <git@dgroshev.com>
Date:   Wed Jan 31 16:53:40 2024 +0000

    Update the project to Node 20 (#2691)
    
    ### Change Type
    - [x] `internal` — Any other changes that don't affect the published
    package

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index c138e0b3e..ca4e3f6db 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -511,13 +511,13 @@ describe('getShapeUtil', () => {
 	it('throws if that shape type isnt registered', () => {
 		const myMissingShape = { type: 'missing' } as TLShape
 		expect(() => editor.getShapeUtil(myMissingShape)).toThrowErrorMatchingInlineSnapshot(
-			`"No shape util found for type \\"missing\\""`
+			`"No shape util found for type "missing""`
 		)
 	})
 
 	it('throws if that type isnt registered', () => {
 		expect(() => editor.getShapeUtil('missing')).toThrowErrorMatchingInlineSnapshot(
-			`"No shape util found for type \\"missing\\""`
+			`"No shape util found for type "missing""`
 		)
 	})
 })

commit 79460cbf3a1084ac5b49e41d1e2570e4eee98e82
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Feb 12 15:03:25 2024 +0000

    Use canvas bounds for viewport bounds (#2798)
    
    This PR changes the way that viewport bounds are calculated by using the
    canvas element as the source of truth, rather than the container. This
    allows for cases where the canvas is not the same dimensions as the
    component. (Given the way our UI and context works, there are cases
    where this is desired, i.e. toolbars and other items overlaid on top of
    the canvas area).
    
    The editor's `getContainer` is now only used for the text measurement.
    It would be good to get that out somehow.
    
    # Pros
    
    We can inset the canvas
    
    # Cons
    
    We can no longer imperatively call `updateScreenBounds`, as we need to
    provide those bounds externally.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Use the examples, including the new inset canvas example.
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Changes the source of truth for the viewport page bounds to be the
    canvas instead.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index ca4e3f6db..c512565a6 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -369,7 +369,6 @@ describe('isFocused', () => {
 
 			if (wasFocused !== isFocused) {
 				editor.updateInstanceState({ isFocused })
-				editor.updateViewportScreenBounds()
 
 				if (!isFocused) {
 					// When losing focus, run complete() to ensure that any interacts end

commit b4c1f606e18e338b16e2386b3cddfb1d2fc2bcff
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Fri May 17 09:53:57 2024 +0100

    focus: rework and untangle existing focus management logic in the sdk (#3718)
    
    Focus management is really scattered across the codebase. There's sort
    of a battle between different code paths to make the focus the correct
    desired state. It seemed to grow like a knot and once I started pulling
    on one thread to see if it was still needed you could see underneath
    that it was accounting for another thing underneath that perhaps wasn't
    needed.
    
    The impetus for this PR came but especially during the text label
    rework, now that it's much more easy to jump around from textfield to
    textfield. It became apparent that we were playing whack-a-mole trying
    to preserve the right focus conditions (especially on iOS, ugh).
    
    This tries to remove as many hacks as possible, and bring together in
    place the focus logic (and in the darkness, bind them).
    
    ## Places affected
    - [x] `useEditableText`: was able to remove a bunch of the focus logic
    here. In addition, it doesn't look like we need to save the selection
    range anymore.
    - lingering footgun that needed to be fixed anyway: if there are two
    labels in the same shape, because we were just checking `editingShapeId
    === id`, the two text labels would have just fought each other for
    control
    - [x] `useFocusEvents`: nixed and refactored — we listen to the store in
    `FocusManager` and then take care of autoFocus there
    - [x] `useSafariFocusOutFix`: nixed. not necessary anymore because we're
    not trying to refocus when blurring in `useEditableText`. original PR
    for reference: https://github.com/tldraw/brivate/pull/79
    - [x] `defaultSideEffects`: moved logic to `FocusManager`
    - [x] `PointingShape` focus for `startTranslating`, decided to leave
    this alone actually.
    - [x] `TldrawUIButton`: it doesn't look like this focus bug fix is
    needed anymore, original PR for reference:
    https://github.com/tldraw/tldraw/pull/2630
    - [x] `useDocumentEvents`: left alone its manual focus after the Escape
    key is hit
    - [x] `FrameHeading`: double focus/select doesn't seem necessary anymore
    - [x] `useCanvasEvents`: `onPointerDown` focus logic never happened b/c
    in `Editor.ts` we `clearedMenus` on pointer down
    - [x] `onTouchStart`: looks like `document.body.click()` is not
    necessary anymore
    
    ## Future Changes
    - [ ] a11y: work on having an accessebility focus ring
    - [ ] Page visibility API:
    (https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API)
    events when tab is back in focus vs. background, different kind of focus
    - [ ] Reexamine places we manually dispatch `pointer_down` events to see
    if they're necessary.
    - [ ] Minor: get rid of `useContainer` maybe? Is it really necessary to
    have this hook? you can just do `useEditor` → `editor.getContainer()`,
    feels superfluous.
    
    ## Methodology
    Looked for places where we do:
    - `body.click()`
    - places we do `container.focus()`
    - places we do `container.blur()`
    - places we do `editor.updateInstanceState({ isFocused })`
    - places we do `autofocus`
    - searched for `document.activeElement`
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    - [x] run test-focus.spec.ts
    - [x] check MultipleExample
    - [x] check EditorFocusExample
    - [x] check autoFocus
    - [x] check style panel usage and focus events in general
    - [x] check text editing focus, lots of different devices,
    mobile/desktop
    
    ### Release Notes
    
    - Focus: rework and untangle existing focus management logic in the SDK

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index c512565a6..96665bc32 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -446,7 +446,9 @@ describe('isFocused', () => {
 		expect(editor.getInstanceState().isFocused).toBe(false)
 	})
 
-	it('becomes false when a child of the app container div receives a focusout event', () => {
+	it.skip('becomes false when a child of the app container div receives a focusout event', () => {
+		// This used to be true, but the focusout event doesn't actually bubble up anymore
+		// after we reworked to have the focus manager handle things.
 		const child = document.createElement('div')
 		editor.elm.appendChild(child)
 

commit 1452978246a68a5e31c6acc2379fcce8e194f99a
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue May 21 09:45:22 2024 +0100

    [bugfix] Cleanup input state after middle-click-to-pan  (#3792)
    
    closes #3013
    closes #3733
    
    This fixes a bug wherein the `inputs.isPanning` state was not being
    unset correctly after a middle-click-to-pan gesture with a mouse.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 96665bc32..d0a3b83cc 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -646,3 +646,33 @@ describe('when the user prefers light UI', () => {
 		expect(editor.user.getIsDarkMode()).toBe(false)
 	})
 })
+
+describe('middle-click panning', () => {
+	it('clears the isPanning state on mouse up', () => {
+		editor.pointerDown(0, 0, {
+			// middle mouse button
+			button: 1,
+		})
+		editor.pointerMove(100, 100)
+		expect(editor.inputs.isPanning).toBe(true)
+		editor.pointerUp(100, 100)
+		expect(editor.inputs.isPanning).toBe(false)
+	})
+
+	it('does not clear thee isPanning state if the space bar is down', () => {
+		editor.pointerDown(0, 0, {
+			// middle mouse button
+			button: 1,
+		})
+		editor.pointerMove(100, 100)
+		expect(editor.inputs.isPanning).toBe(true)
+		editor.keyDown(' ')
+		editor.pointerUp(100, 100, {
+			button: 1,
+		})
+		expect(editor.inputs.isPanning).toBe(true)
+
+		editor.keyUp(' ')
+		expect(editor.inputs.isPanning).toBe(false)
+	})
+})

commit 19d051c188381e54d7f8a1fd90a2ccd247419909
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Jun 3 16:58:00 2024 +0100

    Snapshots pit of success (#3811)
    
    Lots of people are having a bad time with loading/restoring snapshots
    and there's a few reasons for that:
    
    - It's not clear how to preserve UI state independently of document
    state.
    - Loading a snapshot wipes the instance state, which means we almost
    always need to
      - update the viewport page bounds
      - refocus the editor
      - preserver some other sneaky properties of the `instance` record
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index d0a3b83cc..13b16bc63 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -5,6 +5,8 @@ import {
 	TLShape,
 	createShapeId,
 	debounce,
+	getSnapshot,
+	loadSnapshot,
 } from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
 import { TL } from './test-jsx'
@@ -583,11 +585,11 @@ describe('snapshots', () => {
 
 		// now serialize
 
-		const snapshot = editor.store.getSnapshot()
+		const snapshot = getSnapshot(editor.store)
 
 		const newEditor = new TestEditor()
 
-		newEditor.store.loadSnapshot(snapshot)
+		loadSnapshot(newEditor.store, snapshot)
 
 		expect(editor.store.serialize()).toEqual(newEditor.store.serialize())
 	})

commit 930ea64d35d6889fae6094cd7bb0dfa32a4b7c67
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jun 4 14:16:23 2024 +0200

    Fix drag distance (#3873)
    
    This PR fixes a bug where the drag distance for an interaction was being
    measured in page space rather than screen space. It should be measured
    in screen space. The actual check for `isDragging` is a little ugly but
    this is correct.
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `bugfix` — Bug fix
    
    ### Test Plan
    
    1. Zoom in
    2. Drag the center handle of an arrow shape
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Fixed a bug where the minimum distance for a drag was wrong when
    zoomed in or out.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 13b16bc63..c1d063c4d 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -678,3 +678,39 @@ describe('middle-click panning', () => {
 		expect(editor.inputs.isPanning).toBe(false)
 	})
 })
+
+describe('dragging', () => {
+	it('drags correctly at 100% zoom', () => {
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 0).pointerDown()
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 1)
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 5)
+		expect(editor.inputs.isDragging).toBe(true)
+	})
+
+	it('drags correctly at 150% zoom', () => {
+		editor.setCamera({ x: 0, y: 0, z: 8 }).forceTick()
+
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 0).pointerDown()
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 2)
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 5)
+		expect(editor.inputs.isDragging).toBe(true)
+	})
+
+	it('drags correctly at 50% zoom', () => {
+		editor.setCamera({ x: 0, y: 0, z: 0.1 }).forceTick()
+
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 0).pointerDown()
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 2)
+		expect(editor.inputs.isDragging).toBe(false)
+		editor.pointerMove(0, 5)
+		expect(editor.inputs.isDragging).toBe(true)
+	})
+})

commit 6c846716c343e1ad40839f0f2bab758f58b4284d
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Jun 11 15:17:09 2024 +0100

    assets: make option to transform urls dynamically / LOD (#3827)
    
    this is take #2 of this PR https://github.com/tldraw/tldraw/pull/3764
    
    This continues the idea kicked off in
    https://github.com/tldraw/tldraw/pull/3684 to explore LOD and takes it
    in a different direction.
    
    Several things here to call out:
    - our dotcom version would start to use Cloudflare's image transforms
    - we don't rewrite non-image assets
    - we debounce zooming so that we're not swapping out images while
    zooming (it creates jank)
    - we load different images based on steps of .25 (maybe we want to make
    this more, like 0.33). Feels like 0.5 might be a bit too much but we can
    play around with it.
    - we take into account network connection speed. if you're on 3g, for
    example, we have the size of the image.
    - dpr is taken into account - in our case, Cloudflare handles it. But if
    it wasn't Cloudflare, we could add it to our width equation.
    - we use Cloudflare's `fit=scale-down` setting to never scale _up_ an
    image.
    - we don't swap the image in until we've finished loading it
    programatically (to avoid a blank image while it loads)
    
    TODO
    - [x] We need to enable Cloudflare's pricing on image transforms btw
    @steveruizok 😉 - this won't work quite yet until we do that.
    
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [x] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Test images on staging, small, medium, large, mega
    2. Test videos on staging
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Assets: make option to transform urls dynamically to provide different
    sized images on demand.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index c1d063c4d..3d7843b82 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -541,6 +541,7 @@ describe('snapshots', () => {
 				props: {
 					w: 1200,
 					h: 800,
+					fileSize: -1,
 					name: '',
 					isAnimated: false,
 					mimeType: 'png',

commit eaf921f401744ae788d5443e1fba1eb9db8aa016
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 18 09:33:06 2024 +0100

    Make asset.fileSize optional (#4206)
    
    This PR makes the `fileSize` property of `TLImageAsset` and
    `TLVideoAsset` optional. I first noticed this when I was updating the
    Draw Fast repo, but there are a bunch of cases where we don't know the
    file size when we're creating an asset. Instead of setting it to -1
    (which is sort of magic), we can leave it off if we didn't know it
    already.
    
    ### Change type
    
    - [x] `api`
    
    ### Test plan
    
    - [x] Unit tests
    
    ### Release notes
    
    - Made the `fileSize` property of `TLImageAsset` and `TLVideoAsset`
    optional

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 3d7843b82..c1d063c4d 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -541,7 +541,6 @@ describe('snapshots', () => {
 				props: {
 					w: 1200,
 					h: 800,
-					fileSize: -1,
 					name: '',
 					isAnimated: false,
 					mimeType: 'png',

commit b33cc2e6b0f2630ec328018f592e3d301b90efaf
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Sep 23 18:07:34 2024 +0100

    [feature] isShapeHidden option (#4446)
    
    This PR adds an option to the Editor that allows people to control the
    visibility of shapes. This has been requested a couple of times for
    different use-cases:
    
    - A layer panel with a visibility toggle per shape
    - A kind-of 'private' drawing mode in a multiplayer app.
    
    So to test this feature out I've implemented both of those in minimal
    ways as examples.
    
    ### Change type
    
    - [x] `feature`
    
    
    ### Test plan
    
    - [x] Unit tests
    
    
    ### Release notes
    
    - Adds an `isShapeHidden` option, which allows you to provide custom
    logic to decide whether or not a shape should be shown on the canvas.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index c1d063c4d..9554fa919 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -2,11 +2,14 @@ import {
 	AssetRecordType,
 	BaseBoxShapeUtil,
 	PageRecordType,
+	TLGeoShapeProps,
 	TLShape,
+	atom,
 	createShapeId,
 	debounce,
 	getSnapshot,
 	loadSnapshot,
+	react,
 } from '@tldraw/editor'
 import { TestEditor } from './TestEditor'
 import { TL } from './test-jsx'
@@ -24,7 +27,7 @@ const ids = {
 }
 
 beforeEach(() => {
-	editor = new TestEditor()
+	editor = new TestEditor({})
 
 	editor.createShapes([
 		// on it's own
@@ -714,3 +717,110 @@ describe('dragging', () => {
 		expect(editor.inputs.isDragging).toBe(true)
 	})
 })
+
+describe('isShapeHidden', () => {
+	const isShapeHidden = jest.fn((shape: TLShape) => {
+		return !!shape.meta.hidden
+	})
+
+	beforeEach(() => {
+		editor = new TestEditor({ isShapeHidden })
+
+		editor.createShapes([
+			{
+				id: ids.box1,
+				type: 'geo',
+				x: 100,
+				y: 100,
+				props: { w: 100, h: 100, fill: 'solid' } satisfies Partial<TLGeoShapeProps>,
+			},
+			{
+				id: ids.box2,
+				type: 'geo',
+				x: 200,
+				y: 200,
+				props: { w: 100, h: 100, fill: 'solid' } satisfies Partial<TLGeoShapeProps>,
+			},
+			{
+				id: ids.box3,
+				type: 'geo',
+				x: 300,
+				y: 300,
+				props: { w: 100, h: 100, fill: 'solid' } satisfies Partial<TLGeoShapeProps>,
+			},
+		])
+	})
+
+	it('can be directly used via editor.isShapeHidden', () => {
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
+	})
+
+	it('excludes hidden shapes from the rendering shapes array', () => {
+		expect(editor.getRenderingShapes().length).toBe(3)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(editor.getRenderingShapes().length).toBe(2)
+		editor.updateShape({ id: ids.box2, type: 'geo', meta: { hidden: true } })
+		expect(editor.getRenderingShapes().length).toBe(1)
+	})
+
+	it('excludes hidden shapes from hit testing', () => {
+		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).toBeDefined()
+		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(1)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).not.toBeDefined()
+		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(0)
+	})
+
+	it('uses the callback reactively', () => {
+		const isFilteringEnabled = atom('', true)
+		isShapeHidden.mockImplementation((shape: TLShape) => {
+			if (!isFilteringEnabled.get()) return false
+			return !!shape.meta.hidden
+		})
+		let renderingShapes = editor.getRenderingShapes()
+		react('setRenderingShapes', () => {
+			renderingShapes = editor.getRenderingShapes()
+		})
+		expect(renderingShapes.length).toBe(3)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(renderingShapes.length).toBe(2)
+		isFilteringEnabled.set(false)
+		expect(renderingShapes.length).toBe(3)
+		isFilteringEnabled.set(true)
+		expect(renderingShapes.length).toBe(2)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: false } })
+		expect(renderingShapes.length).toBe(3)
+	})
+
+	it('applies recursively to children', () => {
+		const groupId = createShapeId('group')
+		editor.groupShapes([ids.box1, ids.box2], { groupId })
+
+		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(false)
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
+		editor.updateShape({ id: groupId, type: 'group', meta: { hidden: true } })
+		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
+	})
+
+	it('still allows hidden shapes to be selected', () => {
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.select(ids.box1)
+		expect(editor.getSelectedShapeIds()).toEqual([ids.box1])
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
+	})
+
+	it('applies to getCurrentPageRenderingShapesSorted', () => {
+		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(3)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(2)
+	})
+
+	it('does not apply to getCurrentPageShapesSorted', () => {
+		expect(editor.getCurrentPageShapesSorted().length).toBe(3)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		expect(editor.getCurrentPageShapesSorted().length).toBe(3)
+	})
+})

commit 9c14e0f1f9db3c37ac58d6df33b5404658132a9f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Oct 7 09:35:01 2024 +0100

    [sync] Set instance.isReadonly automatically  (#4673)
    
    Follow up to #4648 , extracted from #4660
    
    This PR adds a TLStore prop that contains a signal for setting the
    readonly mode. This allows the readonlyness to change on the fly, which
    is necessary for botcom. it's also just nice for tlsync users to be able
    to decide on the server whether something is readonly.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    - Puts the editor into readonly mode automatically when the tlsync
    server responds in readonly mode.
    - Adds the `editor.getIsReadonly()` method.
    - Fixes a bug where arrow labels could be edited in readonly mode.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 9554fa919..32fdd0c3d 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -824,3 +824,25 @@ describe('isShapeHidden', () => {
 		expect(editor.getCurrentPageShapesSorted().length).toBe(3)
 	})
 })
+
+describe('instance.isReadonly', () => {
+	it('updates in accordance with collaboration.mode', () => {
+		const mode = atom<'readonly' | 'readwrite'>('', 'readonly')
+		const editor = new TestEditor(
+			{},
+			{
+				collaboration: {
+					mode,
+					status: atom('', 'online'),
+				},
+			}
+		)
+
+		expect(editor.getIsReadonly()).toBe(true)
+
+		mode.set('readwrite')
+		expect(editor.getIsReadonly()).toBe(false)
+		mode.set('readonly')
+		expect(editor.getIsReadonly()).toBe(true)
+	})
+})

commit 71368dc000db19924eec6c4d6d5e23ec3e49d89f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Apr 3 10:24:59 2025 +0100

    isShapeHidden => getShapeVisibility, to allow children of hidden shapes to be visible (#5762)
    
    This PR was motivated by a very reasonable [discord request
    
    ](https://discord.com/channels/859816885297741824/1353628236487327857/1353628236487327857)
    
    > We are working on a feature where we need to hide all of the shapes
    except for the "focused shape" (we are using isShapeHidden prop) - this
    is largely working as expected, except for one challenge - when the
    "focused shape" is child of a frame/ group shape, then hiding the parent
    shape also hides the "focused shape", which makes sense in general
    context, but we need the ability to hide the parent shape without hiding
    the "focused shape".
    
    Ended up being a fairly small diff.
    
    ![Kapture 2025-03-27 at 12 00
    09](https://github.com/user-attachments/assets/e2423d49-9908-4a7b-bdb0-fed96c3b25f5)
    
    I'm not crazy about this 'force_show' API and would appreciate
    alternative suggestions if you have any.
    
    ### Change type
    
    - [x] `other`
    
    ### Release notes
    
    - Allow the children of a hidden shape to show themselves by returning a
    'force_show' override from the `isShapeHidden` predicate.

diff --git a/packages/tldraw/src/test/Editor.test.tsx b/packages/tldraw/src/test/Editor.test.tsx
index 32fdd0c3d..9cc311666 100644
--- a/packages/tldraw/src/test/Editor.test.tsx
+++ b/packages/tldraw/src/test/Editor.test.tsx
@@ -4,6 +4,7 @@ import {
 	PageRecordType,
 	TLGeoShapeProps,
 	TLShape,
+	TldrawEditorProps,
 	atom,
 	createShapeId,
 	debounce,
@@ -718,13 +719,14 @@ describe('dragging', () => {
 	})
 })
 
-describe('isShapeHidden', () => {
-	const isShapeHidden = jest.fn((shape: TLShape) => {
-		return !!shape.meta.hidden
-	})
+describe('getShapeVisibility', () => {
+	const getShapeVisibility = jest.fn(((shape: TLShape) => {
+		return shape.meta.visibility as any
+	}) satisfies TldrawEditorProps['getShapeVisibility'])
 
 	beforeEach(() => {
-		editor = new TestEditor({ isShapeHidden })
+		getShapeVisibility.mockClear()
+		editor = new TestEditor({ getShapeVisibility })
 
 		editor.createShapes([
 			{
@@ -753,44 +755,44 @@ describe('isShapeHidden', () => {
 
 	it('can be directly used via editor.isShapeHidden', () => {
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
 	})
 
 	it('excludes hidden shapes from the rendering shapes array', () => {
 		expect(editor.getRenderingShapes().length).toBe(3)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getRenderingShapes().length).toBe(2)
-		editor.updateShape({ id: ids.box2, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box2, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getRenderingShapes().length).toBe(1)
 	})
 
 	it('excludes hidden shapes from hit testing', () => {
 		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).toBeDefined()
 		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(1)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getShapeAtPoint({ x: 150, y: 150 })).not.toBeDefined()
 		expect(editor.getShapesAtPoint({ x: 150, y: 150 }).length).toBe(0)
 	})
 
 	it('uses the callback reactively', () => {
 		const isFilteringEnabled = atom('', true)
-		isShapeHidden.mockImplementation((shape: TLShape) => {
-			if (!isFilteringEnabled.get()) return false
-			return !!shape.meta.hidden
+		getShapeVisibility.mockImplementation((shape: TLShape) => {
+			if (!isFilteringEnabled.get()) return 'inherit'
+			return shape.meta.visibility
 		})
 		let renderingShapes = editor.getRenderingShapes()
 		react('setRenderingShapes', () => {
 			renderingShapes = editor.getRenderingShapes()
 		})
 		expect(renderingShapes.length).toBe(3)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(renderingShapes.length).toBe(2)
 		isFilteringEnabled.set(false)
 		expect(renderingShapes.length).toBe(3)
 		isFilteringEnabled.set(true)
 		expect(renderingShapes.length).toBe(2)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: false } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'inherit' } })
 		expect(renderingShapes.length).toBe(3)
 	})
 
@@ -800,13 +802,13 @@ describe('isShapeHidden', () => {
 
 		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(false)
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
-		editor.updateShape({ id: groupId, type: 'group', meta: { hidden: true } })
+		editor.updateShape({ id: groupId, type: 'group', meta: { visibility: 'hidden' } })
 		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
 	})
 
 	it('still allows hidden shapes to be selected', () => {
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		editor.select(ids.box1)
 		expect(editor.getSelectedShapeIds()).toEqual([ids.box1])
 		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
@@ -814,15 +816,29 @@ describe('isShapeHidden', () => {
 
 	it('applies to getCurrentPageRenderingShapesSorted', () => {
 		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(3)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getCurrentPageRenderingShapesSorted().length).toBe(2)
 	})
 
 	it('does not apply to getCurrentPageShapesSorted', () => {
 		expect(editor.getCurrentPageShapesSorted().length).toBe(3)
-		editor.updateShape({ id: ids.box1, type: 'geo', meta: { hidden: true } })
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'hidden' } })
 		expect(editor.getCurrentPageShapesSorted().length).toBe(3)
 	})
+
+	it('allows overriding hidden parents with "visible" value', () => {
+		const groupId = createShapeId('group')
+		editor.groupShapes([ids.box1, ids.box2], { groupId })
+
+		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(false)
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
+		editor.updateShape({ id: groupId, type: 'group', meta: { visibility: 'hidden' } })
+		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(true)
+		editor.updateShape({ id: ids.box1, type: 'geo', meta: { visibility: 'visible' } })
+		expect(editor.isShapeHidden(editor.getShape(groupId)!)).toBe(true)
+		expect(editor.isShapeHidden(editor.getShape(ids.box1)!)).toBe(false)
+	})
 })
 
 describe('instance.isReadonly', () => {

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    