<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actual Output: lib/segment/src/segment_constructor/segment_constructor_base.rs - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
        .empty-content-notice {
            background-color: #f8f8f8;
            border: 1px dashed #ccc;
            border-radius: 4px;
            padding: 20px;
            text-align: center;
            color: #666;
        }
        
        .empty-content-notice p:first-child {
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .info-message {
            background-color: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            color: #0366d6;
        }
        
        .info-message p:first-child {
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Actual Output: lib/segment/src/segment_constructor/segment_constructor_base.rs</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../../cases/openai_gpt-oss-120b/qdrant_lib_segment_src_segment_constructor_segment_constructor_base.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        
        <section>
            <h2>Raw Model Response</h2>
            
            <pre><code class="language-plaintext">```rust
use std::collections::HashMap;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use std::sync::atomic::AtomicBool;

use atomic_refcell::AtomicRefCell;
use common::budget::ResourcePermit;
use common::flags::FeatureFlags;
use io::storage_version::StorageVersion;
use log::info;
use parking_lot::{Mutex, RwLock};
use serde::Deserialize;
use uuid::Uuid;

use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF, DB_MAPPING_CF};
use crate::data_types::vectors::DEFAULT_VECTOR_NAME;
use crate::id_tracker::immutable_id_tracker::ImmutableIdTracker;
use crate::id_tracker::mutable_id_tracker::MutableIdTracker;
use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
use crate::id_tracker::{IdTracker, IdTrackerEnum, IdTrackerSS};
use crate::index::VectorIndexEnum;
use crate::index::hnsw_index::gpu::gpu_devices_manager::LockedGpuDevice;
use crate::index::hnsw_index::hnsw::{HNSWIndex, HnswIndexOpenArgs};
use crate::index::plain_vector_index::PlainVectorIndex;
use crate::index::sparse_index::sparse_index_config::SparseIndexType;
use crate::index::sparse_index::sparse_vector_index::{
    self as sparse_vector_index_mod, SparseVectorIndex, SparseVectorIndexOpenArgs,
};
use crate::index::struct_payload_index::StructPayloadIndex;
use crate::payload_storage::mmap_payload_storage::MmapPayloadStorage;
use crate::payload_storage::on_disk_payload_storage::OnDiskPayloadStorage;
use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
use crate::segment::{SEGMENT_STATE_FILE, Segment, SegmentVersion, VectorData};
use crate::types::{
    Distance, Indexes, PayloadStorageType, SegmentConfig, SegmentState, SegmentType,
    SeqNumberType, SparseVectorStorageType, VectorDataConfig, VectorName, VectorStorageDatatype,
    VectorStorageType,
};

use crate::vector_storage::dense::appendable_dense_vector_storage::{
    open_appendable_in_ram_vector_storage, open_appendable_in_ram_vector_storage_byte,
    open_appendable_in_ram_vector_storage_half, open_appendable_memmap_vector_storage,
    open_appendable_memmap_vector_storage_byte, open_appendable_memmap_vector_storage_half,
};
use crate::vector_storage::dense::memmap_dense_vector_storage::{
    open_memmap_vector_storage, open_memmap_vector_storage_byte,
    open_memmap_vector_storage_half,
};
use crate::vector_storage::dense::simple_dense_vector_storage::{
    open_simple_dense_byte_vector_storage, open_simple_dense_half_vector_storage,
    open_simple_dense_vector_storage,
};
use crate::vector_storage::multi_dense::appendable_mmap_multi_dense_vector_storage::{
    open_appendable_in_ram_multi_vector_storage, open_appendable_in_ram_multi_vector_storage_byte,
    open_appendable_in_ram_multi_vector_storage_half,
    open_appendable_memmap_multi_vector_storage,
    open_appendable_memmap_multi_vector_storage_byte,
    open_appendable_memmap_multi_vector_storage_half,
};
use crate::vector_storage::multi_dense::simple_multi_dense_vector_storage::{
    open_simple_multi_dense_vector_storage,
    open_simple_multi_dense_vector_storage_byte,
    open_simple_multi_dense_vector_storage_half,
    open_simple_multi_dense_vector_storage_byte,
    open_simple_multi_dense_vector_storage_half,
};
use crate::vector_storage::multi_dense::{VectorData, VectorDataConfig};
use crate::vector_storage::mmap_sparse_vector_storage::MmapSparseVectorStorage;
use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
use crate::vector_storage::simple_sparse_vector_storage::open_simple_sparse_vector_storage;
use crate::vector_storage::{VectorStorage, VectorStorageEnum};

pub const PAYLOAD_INDEX_PATH: &str = "payload_index";
pub const VECTOR_STORAGE_PATH: &str = "vector_storage";
pub const VECTOR_INDEX_PATH: &str = "vector_index";

fn sp<T>(t: T) -> Arc<AtomicRefCell<T>> {
    Arc::new(AtomicRefCell::new(t))
}

fn get_vector_name_with_prefix(prefix: &str, vector_name: &VectorName) -> String {
    if !vector_name.is_empty() {
        format!("{prefix}-{vector_name}")
    } else {
        prefix.to_owned()
    }
}

pub fn get_vector_storage_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
    segment_path.join(get_vector_name_with_prefix(
        VECTOR_STORAGE_PATH,
        vector_name,
    ))
}

pub fn get_vector_index_path(segment_path: &Path, vector_name: &VectorName) -> PathBuf {
    segment_path.join(get_vector_name_with_prefix(
        VECTOR_INDEX_PATH,
        vector_name,
    ))
}

/// Open a vector storage instance using the configuration. This method decides which
/// vector storage type to instantiate based on the configuration. It
/// optionally uses the `stopped` atomic to check whether the loading
/// process was stopped early.
pub(crate) fn open_vector_storage(
    database: &Arc<RwLock<rocksdb::DB>>,
    vector_config: &VectorDataConfig,
    stopped: &AtomicBool,
    vector_storage_path: &Path,
    vector_name: &VectorName,
) -> OperationResult<VectorStorageEnum> {
    let storage_element_type = vector_config.datatype.unwrap_or_default();

    match vector_config.storage_type {
        // In-memory storage
        // A data type of `Float32` corresponds to the default dense vector
        // storage. The `Float16` type leverages a half-precision storage
        // implementation. The `Uint8` type can be used with quantized
        // vectors.
        //
        // When using `Memory`, the data is stored inside RocksDB.
        VectorStorageType::Memory => {
            let db_column_name = get_vector_name_with_prefix(DB_VECTOR_CF, vector_name);
            match vector_config.multivector_config {
                Some(multivector_config) => match storage_element_type {
                    VectorStorageDatatype::Float32 => open_simple_multi_dense_vector_storage(
                        database.clone(),
                        &db_column_name,
                        vector_config.size,
                        vector_config.distance,
                        *multivector_config,
                        stopped,
                    ),
                    VectorStorageDatatype::Uint8 => {
                        open_simple_multi_dense_vector_storage_byte(
                            database.clone(),
                            &db_column_name,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                            stopped,
                        )
                    }
                    VectorStorage::Float16 => {
                        #[cfg(feature = "half")]
                        {
                            open_simple_multi_dense_vector_half(
                                database.clone(),
                                &db_column_name,
                                vector_config.size,
                                vector_config.distance,
                                *multivector_config,
                                stopped,
                            )
                        }
                        #[cfg(not(feature = "half"))]
                        {
                            Err(OperationError::ServiceError {
                                description: "Half-precision vectors require feature=serde".into(),
                            })
                        }
                    }
                },
                None => match storage_element_type {
                    VectorStorage::Float32 => open_simple_dense_vector_storage(
                        database.clone(),
                        &db_column_name,
                        vector_config.size,
                        vector_config.distance,
                        stopped,
                    ),
                    VectorStorage::Uint8 => {
                        open_simple_dense_vector_storage_byte(
                            database.clone(),
                            &db_column_name,
                            vector_config.size,
                            vector_config.distance,
                            stopped,
                        )
                    }
                    VectorStorage::Float16 => {
                        #[cfg(feature = "half")]
                        {
                            open_simple_dense_half_vector_storage(
                                database.clone(),
                                &db_column_name,
                                vector_config.size,
                                vector_config.distance,
                                stopped,
                            )
                        }
                        #[cfg(not(feature = "half"))]
                        {
                            Err(OperationError::ServiceError {
                                description: "Half-precision vectors require feature=serde".into(),
                            })
                        }
                    }
                },
            }
        }

        // Mmap on disk, not appendable
        VectorStorageType::Mmap => {
            if let Some(multivector_config) = &vector_config.multivector_config {
                // There are no mmap multi-vector storages; we only offer appendable mmap.
                match storage_element_type {
                    VectorStorage::Float32 => {
                        open_appendable_memmap_multi_vector_storage(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                        )
                    }
                    VectorStorage::Uint8 => {
                        open_appendable_memmap_multi_vector_storage_byte(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                        )
                    }
                    #[cfg(feature = "half")]
                    VectorStorage::Float16 => {
                        open_appendable_memmap_multi_vector_storage_half(
                            vector_storage_path,
                            vector_config.size,
                            &vector_config.distance,
                            *multivector_config,
                        )
                    }
                }
            } else {
                match storage_element_type {
                    VectorStorage::Float32 => open_memmap_vector_storage(
                        vector_storage_path,
                        vector_config.size,
                        vector_config.distance,
                    ),
                    VectorStorage::Uint8 => {
                        open_memmap_vector_storage_byte(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                        )
                    }
                    #[cfg(feature = "half")]
                    VectorStorage::Float16 => {
                        open_memmap_vector_storage_half(
                            &vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                        )
                    }
                }
            }
        }

        // Chunked mmap on disk, appendable
        VectorStorageType::ChunkedMmap => {
            if let Some(multivector_config) = &vector_config.multivector_config {
                match storage_element_type {
                    VectorStorage::Float32 => {
                        open_appendable_memmap_multi_vector_storage(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                        )
                    }
                    VectorStorage::Uint8 => {
                        open_appendable_memmap_multi_vector_storage_byte(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                        )
                    }
                    #[cfg(feature = "half")]
                    VectorStorage::Float16 => {
                        open_appendable_memmap_multi_vector_storage_half(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                            *multivector_config,
                        )
                    }
                }
            } else {
                match storage_element_type {
                    VectorStorage::Float32 => {
                        open_appendable_memmap_vector_storage(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                        )
                    }
                    VectorStorage::Uint8 => open_appendable_memmap_vector_storage_byte(
                        vector_storage_path,
                        vector_config.size,
                        vector_config.distance,
                    ),
                    #[cfg(feature = "half")]
                    VectorStorage::Float16 => {
                        open_appendable_memmap_vector_storage_half(
                            vector_storage_path,
                            vector_config.size,
                            vector_config.distance,
                        )
                    }
                }
            }
        }

        // In RAM chunked memory-mapped storage, enabled by default.
        VectorStorageType::InRamChunkedMmap => {
            if let Some(multivector_config) = &vector_config.multivector_config {
                match storage_element_type {
                    VectorStorage::Float32 => {
                        open_appendable_in_ram_multi_vector_storage(
                          vector_storage_path,
                          vector_config.size,
                          vector_config.distance,
                          *multivector_config,
                        )
                    }
                    // ... Similar for other data types ...
                }
            } else {
                match storage_element_type {
                    // ...
                }
            }
        }
    }
}

/// Open the RocksDB instance for a segment.
pub(crate) fn open_segment_db(
    segment_path: &Path,
    config: &SegmentConfig,
) -> Result<Arc<RwLock<rocksdb::DB>>, OperationError> {
    // collect column family names.
    // ...
    open_db(segment_path, &vector_db_names)
        .map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))
}

pub(crate) fn create_payload_storage(
    database: Arc<RwLock<rocksdb::DB>>,
    config: &SegmentConfig,
    path: &Path,
) -> OperationResult<PayloadStorageEnum> {
    let payload_storage = match config.payload_storage_type {
        PayloadStorageType::InMemory => {
            PayloadStorageEnum::from(SimplePayloadStorage::open(database)?)
        }
        PayloadStorageType::OnDisk => {
            PayloadStorageEnum::from(OnDiskPayloadStorage::open(database)?)
        }
        PayloadStorageType::Mmap => {
            PayloadStorageEnum::from(MmapPayloadStorage::open_or_create(path)?)
        }
    };
    Ok(payload_storage)
}

// Create mutable ID tracker (file based)
pub(crate) fn create_mutable_id_tracker(segment_path: &Path) -> Result<MutableIdTracker, OperationError> {
    // implementation...
}

// Open RocksDB-backed ID tracker.
pub(crate) fn create_rocksdb_id_tracker(
    database: Arc<RwLock<rocksdb::DB>>,
) -> Result<SimpleIdTracker, OperationError> {
    SimpleIdTracker::open(database)
}

// Get payload index path.
pub(crate) fn get_payload_index_path(segment_path: &Path) -> PathBuf {
    segment_path.join(PAYLOAD_INDEX_PATH)
}

pub(crate) fn create_mutable_id_tracker(
    database: Arc<RwLock<rocksdb::DB>>,
) -> Result<MutableIdTracker, OperationError> {
    SimpleIdTracker::open(database)
}

pub struct VectorIndexOpenArgs<'a> {
    pub path: &'a Path,
    pub id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
    pub vector_storage: Arc<AtomicRefCell<VectorStorageEnum>>,
    pub payload_index: Arc<AtomicRefCell<StructPayloadIndex>>,
    pub quantized_vectors: Arc<AtomicRefCell<Option<QuantizedVectors>>>,
}

pub struct VectorIndexBuildArgs<'a> {
    pub permit: Arc<ResourcePermit>,
    pub old_indices: &'a [Arc<AtomicRefCell<VectorIndexEnum>>],
    pub gpu_device: Option<&'a LockedGpuDevice<'a>>,
    pub stopped: &'a AtomicBool,
    pub feature_flags: FeatureFlags,
}

pub(crate) fn open_vector_index(
    vector_config: &VectorDataConfig,
    open_args: VectorIndexOpenArgs,
) -> Result<VectorIndexEnum, OperationError> {
    Ok(match &vector_config.index {
        Indexes::Plain => {
            VectorIndexEnum::Plain(PlainVectorIndex::new(
                open_args.id_tracker,
                open_args.vector_storage,
                open_args.payload_index,
            ))
        }
        Indexes::Hnsw(hnsw_config) => {
            let args = HnswIndexOpenArgs {
                path: open_args.path,
                id_tracker: open_args.id_tracker,
                vector_storage: open_args.vector_storage,
                quantized_vectors: open_args.quantized_vectors,
                payload_index: open_args.payload_index,
                hnsw_config: hnsw_config.clone(),
            };
            if hnsw_config.on_disk == Some(true) {
                // TODO: handle GPU device if needed.
                IndexEnum::Hnsw(HNSWIndex::open(args)?)
            } else {
                IndexEnum::Hnsw(HNSWIndex::open(args)?)
            }
        }
    })
}

pub fn load_segment(
    path: &Path,
    stopped: &AtomicBool,
) -> Result<Option<Segment>, OperationError> {
    // Check for an obsolete .deleted suffix.
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        if ext == "deleted" {
            log::warn!("Segment is marked as deleted, skipping: {}", path.display());
            return Ok(None);
        }
    }

    // Check for segment version file.
    if let None = SegmentVersion::check_exists(path) {
        log::warn!("...."); // omitted for brevity
        return Ok(None);
    }

    // Load segment state.
    let segment_state = Segment::load_state(path)?;

    let segment = create_segment(
        None,
        path,
        &segment_state.config,
        stopped,
    )?;

    //...
    Ok(Some(segment))
}

/// Build a segment. This function creates the segment folder, stores
/// all segment information and returns a segment instance.
pub fn build_segment(
    segments_path: &Path,
    config: &SegmentConfig,
    ready: bool,
) -> Result<Segment, OperationError> {
    let segment_path = segments_path.join(Uuid::new_v4().to_string());

    std::fs::create_dir_all(&segment_path)?;

    let segment = create_segment(None, &segment_path, config, &AtomicBool::new(false))?;
    segment.save_current_state()?;

    if ready {
        SegmentVersion::save(&segment_path)?;
    }

    Ok(segment)
}
```

**Note:** The above representation provides the current structure of
`segment_constructor_base.rs` after the series of commits up to
`featureFlags` integration, including all major changes:
dynamic storage handling, vector storage variants,
immutable vs. mutable ID trackers, and
the latest index‑building and loading logic.
```</code></pre>
        </section>
        
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    