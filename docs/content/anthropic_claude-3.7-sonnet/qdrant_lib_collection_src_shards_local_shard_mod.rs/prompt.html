<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/collection/src/shards/local_shard/mod.rs - Sonnet 3.7</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: Sonnet 3.7</h2>
        <p><a href="../../../cases/anthropic_claude-3.7-sonnet/qdrant_lib_collection_src_shards_local_shard_mod.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/collection/src/shards/local_shard/mod.rs

commit 1df94c53b149a96d433f9185982c9e51e85f0109
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Feb 8 16:00:13 2024 +0100

    Add `ClockMap` type to track versions of update operations in the local shard WAL (#3506)
    
    * Add `ClockMap` type to track versions of update operation in local shard WAL
    
    * `ClockMap::advance_clock_and_correct_tag`: only correct `clock_tag.clock_tick` if it's `0`
    
    * Add `ClockMap::load` and `ClockMap::store`
    
    * WIP: Load/restore `ClockMap` from disk/WAL when loading `LocalShard`
    
    * WIP: Save `ClockMap` to disk when truncating WAL
    
    * Do not apply operation with `clock_tick` that is older than clock value in `ClockMap`
    
    * Handle `ClockMap` properly during shard snapshot operations
    
    * Use "atomic disk write" when saving `ClockMap` to disk
    
    * Use `into` instead of explicit `Atomic*::new`
    
    * Return *local* shard result (instead of *remote* shard result) when updating `ForwardProxyShard`
    
    * Refactor `ClockMap::advance_clock*`
    
    * Refactor `ClockMap::advance_clock*` once again
    
    * Add documentation and `must_use` attributes
    
    * Use `atomicwrites` crate for `ClockMap::store`
    
    * WIP: Add `force` flag to the operations forwarded by forward/queue proxy shards...
    
    ...and add `force` flag handling to the `ClockMap`
    
    * Disable force on forward proxy, always accept old clock values
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
new file mode 100644
index 000000000..ac347a340
--- /dev/null
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -0,0 +1,930 @@
+pub mod clock_map;
+mod shard_ops;
+
+use std::collections::{BTreeSet, HashMap};
+use std::mem::size_of;
+use std::ops::Deref;
+use std::path::{Path, PathBuf};
+use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
+use std::thread;
+use std::time::{Duration, Instant};
+
+use arc_swap::ArcSwap;
+use common::cpu::CpuBudget;
+use common::panic;
+use indicatif::{ProgressBar, ProgressStyle};
+use itertools::Itertools;
+use parking_lot::{Mutex as ParkingMutex, RwLock};
+use segment::data_types::vectors::VectorElementType;
+use segment::entry::entry_point::SegmentEntry as _;
+use segment::index::field_index::CardinalityEstimation;
+use segment::segment::Segment;
+use segment::segment_constructor::{build_segment, load_segment};
+use segment::types::{
+    CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PayloadStorageType, PointIdType,
+    QuantizationConfig, SegmentConfig, SegmentType,
+};
+use segment::utils::mem::Mem;
+use tokio::fs::{copy, create_dir_all, remove_dir_all, remove_file};
+use tokio::runtime::Handle;
+use tokio::sync::mpsc::Sender;
+use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
+use wal::{Wal, WalOptions};
+
+use self::clock_map::ClockMap;
+use super::update_tracker::UpdateTracker;
+use crate::collection_manager::collection_updater::CollectionUpdater;
+use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
+use crate::collection_manager::optimizers::TrackerLog;
+use crate::common::file_utils::{move_dir, move_file};
+use crate::config::CollectionConfig;
+use crate::operations::shared_storage_config::SharedStorageConfig;
+use crate::operations::types::{
+    check_sparse_compatible_with_segment_config, CollectionError, CollectionInfoInternal,
+    CollectionResult, CollectionStatus, OptimizersStatus,
+};
+use crate::operations::OperationWithClockTag;
+use crate::optimizers_builder::{build_optimizers, clear_temp_segments};
+use crate::shards::shard::ShardId;
+use crate::shards::shard_config::{ShardConfig, SHARD_CONFIG_FILE};
+use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
+use crate::shards::CollectionId;
+use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
+use crate::wal::SerdeWal;
+
+pub type LockedWal = Arc<ParkingMutex<SerdeWal<OperationWithClockTag>>>;
+
+/// If rendering WAL load progression in basic text form, report progression every 60 seconds.
+const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);
+
+/// LocalShard
+///
+/// LocalShard is an entity that can be moved between peers and contains some part of one collections data.
+///
+/// Holds all object, required for collection functioning
+pub struct LocalShard {
+    pub(super) segments: Arc<RwLock<SegmentHolder>>,
+    pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
+    pub(super) shared_storage_config: Arc<SharedStorageConfig>,
+    pub(super) wal: LockedWal,
+    pub(super) update_handler: Arc<Mutex<UpdateHandler>>,
+    pub(super) update_sender: ArcSwap<Sender<UpdateSignal>>,
+    pub(super) update_tracker: UpdateTracker,
+    pub(super) path: PathBuf,
+    pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
+    pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
+    clock_map: Arc<Mutex<ClockMap>>,
+    update_runtime: Handle,
+}
+
+/// Shard holds information about segments and WAL.
+impl LocalShard {
+    pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {
+        let wal_from = Self::wal_path(from);
+        let wal_to = Self::wal_path(to);
+        let segments_from = Self::segments_path(from);
+        let segments_to = Self::segments_path(to);
+
+        move_dir(wal_from, wal_to).await?;
+        move_dir(segments_from, segments_to).await?;
+
+        let clock_map_from = Self::clock_map_path(from);
+        if clock_map_from.exists() {
+            let clock_map_to = Self::clock_map_path(to);
+            move_file(clock_map_from, clock_map_to).await?;
+        }
+
+        Ok(())
+    }
+
+    /// Checks if path have local shard data present
+    pub fn check_data(shard_path: &Path) -> bool {
+        let wal_path = Self::wal_path(shard_path);
+        let segments_path = Self::segments_path(shard_path);
+        wal_path.exists() && segments_path.exists()
+    }
+
+    /// Clear local shard related data.
+    ///
+    /// Do NOT remove config file.
+    pub async fn clear(shard_path: &Path) -> CollectionResult<()> {
+        // Delete WAL
+        let wal_path = Self::wal_path(shard_path);
+        if wal_path.exists() {
+            remove_dir_all(wal_path).await?;
+        }
+
+        // Delete segments
+        let segments_path = Self::segments_path(shard_path);
+        if segments_path.exists() {
+            remove_dir_all(segments_path).await?;
+        }
+
+        // Delete clock map
+        let clock_map_path = Self::clock_map_path(shard_path);
+        if clock_map_path.exists() {
+            remove_file(clock_map_path).await?;
+        }
+
+        Ok(())
+    }
+
+    #[allow(clippy::too_many_arguments)]
+    pub async fn new(
+        segment_holder: SegmentHolder,
+        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        shared_storage_config: Arc<SharedStorageConfig>,
+        wal: SerdeWal<OperationWithClockTag>,
+        optimizers: Arc<Vec<Arc<Optimizer>>>,
+        optimizer_cpu_budget: CpuBudget,
+        shard_path: &Path,
+        clock_map: ClockMap,
+        update_runtime: Handle,
+    ) -> Self {
+        let segment_holder = Arc::new(RwLock::new(segment_holder));
+        let config = collection_config.read().await;
+        let locked_wal = Arc::new(ParkingMutex::new(wal));
+        let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
+        let clock_map = Arc::new(Mutex::new(clock_map));
+        let clock_map_path = Self::clock_map_path(shard_path);
+
+        let mut update_handler = UpdateHandler::new(
+            shared_storage_config.clone(),
+            optimizers.clone(),
+            optimizers_log.clone(),
+            optimizer_cpu_budget.clone(),
+            update_runtime.clone(),
+            segment_holder.clone(),
+            locked_wal.clone(),
+            config.optimizer_config.flush_interval_sec,
+            config.optimizer_config.max_optimization_threads,
+            clock_map.clone(),
+            clock_map_path,
+        );
+
+        let (update_sender, update_receiver) =
+            mpsc::channel(shared_storage_config.update_queue_size);
+        update_handler.run_workers(update_receiver);
+
+        let update_tracker = segment_holder.read().update_tracker();
+
+        drop(config); // release `shared_config` from borrow checker
+
+        Self {
+            segments: segment_holder,
+            collection_config,
+            shared_storage_config,
+            wal: locked_wal,
+            update_handler: Arc::new(Mutex::new(update_handler)),
+            update_sender: ArcSwap::from_pointee(update_sender),
+            update_tracker,
+            path: shard_path.to_owned(),
+            clock_map,
+            update_runtime,
+            optimizers,
+            optimizers_log,
+        }
+    }
+
+    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {
+        self.segments.deref()
+    }
+
+    /// Recovers shard from disk.
+    pub async fn load(
+        id: ShardId,
+        collection_id: CollectionId,
+        shard_path: &Path,
+        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        shared_storage_config: Arc<SharedStorageConfig>,
+        update_runtime: Handle,
+        optimizer_cpu_budget: CpuBudget,
+    ) -> CollectionResult<LocalShard> {
+        let collection_config_read = collection_config.read().await;
+
+        let wal_path = Self::wal_path(shard_path);
+        let segments_path = Self::segments_path(shard_path);
+        let clock_map_path = Self::clock_map_path(shard_path);
+
+        let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(
+            wal_path.to_str().unwrap(),
+            (&collection_config_read.wal_config).into(),
+        )
+        .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;
+
+        let segment_dirs = std::fs::read_dir(&segments_path).map_err(|err| {
+            CollectionError::service_error(format!(
+                "Can't read segments directory due to {}\nat {}",
+                err,
+                segments_path.to_str().unwrap()
+            ))
+        })?;
+
+        let mut load_handlers = vec![];
+
+        for entry in segment_dirs {
+            let segments_path = entry.unwrap().path();
+            load_handlers.push(
+                thread::Builder::new()
+                    .name(format!("shard-load-{collection_id}-{id}"))
+                    .spawn(move || {
+                        let mut res = load_segment(&segments_path, &AtomicBool::new(false))?;
+                        if let Some(segment) = &mut res {
+                            segment.check_consistency_and_repair()?;
+                        } else {
+                            std::fs::remove_dir_all(&segments_path).map_err(|err| {
+                                CollectionError::service_error(format!(
+                                    "Can't remove leftover segment {}, due to {}",
+                                    segments_path.to_str().unwrap(),
+                                    err
+                                ))
+                            })?;
+                        }
+                        Ok::<_, CollectionError>(res)
+                    })?,
+            );
+        }
+
+        let mut segment_holder = SegmentHolder::default();
+
+        for handler in load_handlers {
+            let segment = handler.join().map_err(|err| {
+                CollectionError::service_error(format!(
+                    "Can't join segment load thread: {:?}",
+                    err.type_id()
+                ))
+            })??;
+
+            let Some(segment) = segment else {
+                continue;
+            };
+
+            collection_config_read
+                .params
+                .vectors
+                .check_compatible_with_segment_config(&segment.config().vector_data, true)?;
+            collection_config_read
+                .params
+                .sparse_vectors
+                .as_ref()
+                .map(|sparse_vectors| {
+                    check_sparse_compatible_with_segment_config(
+                        sparse_vectors,
+                        &segment.config().sparse_vector_data,
+                        true,
+                    )
+                })
+                .unwrap_or(Ok(()))?;
+
+            segment_holder.add(segment);
+        }
+
+        let res = segment_holder.deduplicate_points()?;
+        if res > 0 {
+            log::debug!("Deduplicated {} points", res);
+        }
+
+        clear_temp_segments(shard_path);
+        let optimizers = build_optimizers(
+            shard_path,
+            &collection_config_read.params,
+            &collection_config_read.optimizer_config,
+            &collection_config_read.hnsw_config,
+            &collection_config_read.quantization_config,
+        );
+
+        drop(collection_config_read); // release `shared_config` from borrow checker
+
+        let clock_map = ClockMap::load_or_default(&clock_map_path)?;
+
+        let collection = LocalShard::new(
+            segment_holder,
+            collection_config,
+            shared_storage_config,
+            wal,
+            optimizers,
+            optimizer_cpu_budget,
+            shard_path,
+            clock_map,
+            update_runtime,
+        )
+        .await;
+
+        collection.load_from_wal(collection_id).await?;
+
+        let available_memory_bytes = Mem::new().available_memory_bytes() as usize;
+        let vectors_size_bytes = collection.estimate_vector_data_size().await;
+
+        // Simple heuristic to exclude mmap prefaulting for collections that won't benefit from it.
+        //
+        // We assume that mmap prefaulting is beneficial if we can put significant part of data
+        // into RAM in advance. However, if we can see that the data is too big to fit into RAM,
+        // it is better to avoid prefaulting, because it will only cause extra disk IO.
+        //
+        // This heuristic is not perfect, but it exclude cases when we don't have enough RAM
+        // even to store half of the vector data.
+        let do_mmap_prefault = available_memory_bytes * 2 > vectors_size_bytes;
+
+        if do_mmap_prefault {
+            for (_, segment) in collection.segments.read().iter() {
+                if let LockedSegment::Original(segment) = segment {
+                    segment.read().prefault_mmap_pages();
+                }
+            }
+        }
+
+        Ok(collection)
+    }
+
+    pub fn shard_path(&self) -> PathBuf {
+        self.path.clone()
+    }
+
+    pub fn wal_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("wal")
+    }
+
+    pub fn segments_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("segments")
+    }
+
+    pub fn clock_map_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("clock_map.json")
+    }
+
+    pub async fn build_local(
+        id: ShardId,
+        collection_id: CollectionId,
+        shard_path: &Path,
+        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        shared_storage_config: Arc<SharedStorageConfig>,
+        update_runtime: Handle,
+        optimizer_cpu_budget: CpuBudget,
+    ) -> CollectionResult<LocalShard> {
+        // initialize local shard config file
+        let local_shard_config = ShardConfig::new_replica_set();
+        let shard = Self::build(
+            id,
+            collection_id,
+            shard_path,
+            collection_config,
+            shared_storage_config,
+            update_runtime,
+            optimizer_cpu_budget,
+        )
+        .await?;
+        local_shard_config.save(shard_path)?;
+        Ok(shard)
+    }
+
+    /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.
+    pub async fn build(
+        id: ShardId,
+        collection_id: CollectionId,
+        shard_path: &Path,
+        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        shared_storage_config: Arc<SharedStorageConfig>,
+        update_runtime: Handle,
+        optimizer_cpu_budget: CpuBudget,
+    ) -> CollectionResult<LocalShard> {
+        let config = collection_config.read().await;
+
+        let wal_path = shard_path.join("wal");
+
+        create_dir_all(&wal_path).await.map_err(|err| {
+            CollectionError::service_error(format!(
+                "Can't create shard wal directory. Error: {err}"
+            ))
+        })?;
+
+        let segments_path = shard_path.join("segments");
+
+        create_dir_all(&segments_path).await.map_err(|err| {
+            CollectionError::service_error(format!(
+                "Can't create shard segments directory. Error: {err}"
+            ))
+        })?;
+
+        let mut segment_holder = SegmentHolder::default();
+        let mut build_handlers = vec![];
+
+        let vector_params = config.params.into_base_vector_data()?;
+        let sparse_vector_params = config.params.into_sparse_vector_data()?;
+        let segment_number = config.optimizer_config.get_number_segments();
+
+        for _sid in 0..segment_number {
+            let path_clone = segments_path.clone();
+            let segment_config = SegmentConfig {
+                vector_data: vector_params.clone(),
+                sparse_vector_data: sparse_vector_params.clone(),
+                payload_storage_type: if config.params.on_disk_payload {
+                    PayloadStorageType::OnDisk
+                } else {
+                    PayloadStorageType::InMemory
+                },
+            };
+            let segment = thread::Builder::new()
+                .name(format!("shard-build-{collection_id}-{id}"))
+                .spawn(move || build_segment(&path_clone, &segment_config, true))
+                .unwrap();
+            build_handlers.push(segment);
+        }
+
+        let join_results = build_handlers
+            .into_iter()
+            .map(|handler| handler.join())
+            .collect_vec();
+
+        for join_result in join_results {
+            let segment = join_result.map_err(|err| {
+                let message = panic::downcast_str(&err).unwrap_or("");
+                let separator = if !message.is_empty() { "with:\n" } else { "" };
+
+                CollectionError::service_error(format!(
+                    "Segment DB create panicked{separator}{message}",
+                ))
+            })??;
+
+            segment_holder.add(segment);
+        }
+
+        let wal: SerdeWal<OperationWithClockTag> =
+            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;
+
+        let optimizers = build_optimizers(
+            shard_path,
+            &config.params,
+            &config.optimizer_config,
+            &config.hnsw_config,
+            &config.quantization_config,
+        );
+
+        drop(config); // release `shared_config` from borrow checker
+
+        let collection = LocalShard::new(
+            segment_holder,
+            collection_config,
+            shared_storage_config,
+            wal,
+            optimizers,
+            optimizer_cpu_budget,
+            shard_path,
+            ClockMap::default(),
+            update_runtime,
+        )
+        .await;
+
+        Ok(collection)
+    }
+
+    pub async fn stop_flush_worker(&self) {
+        let mut update_handler = self.update_handler.lock().await;
+        update_handler.stop_flush_worker()
+    }
+
+    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {
+        let mut update_handler = self.update_handler.lock().await;
+        update_handler.wait_workers_stops().await
+    }
+
+    /// Loads latest collection operations from WAL
+    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
+        let mut clock_map = self.clock_map.lock().await;
+        let wal = self.wal.lock();
+        let bar = ProgressBar::new(wal.len());
+
+        let progress_style = ProgressStyle::default_bar()
+            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")
+            .expect("Failed to create progress style");
+        bar.set_style(progress_style);
+
+        bar.set_message(format!("Recovering collection {collection_id}"));
+        let segments = self.segments();
+
+        // Fall back to basic text output if the progress bar is hidden (e.g. not a tty)
+        let show_progress_bar = !bar.is_hidden();
+        let mut last_progress_report = Instant::now();
+        if !show_progress_bar {
+            log::info!(
+                "Recovering collection {collection_id}: 0/{} (0%)",
+                wal.len(),
+            );
+        }
+
+        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation
+        // that has been applied and flushed.
+        //
+        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling
+        // in the `wal` crate itself).
+        //
+        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,
+        // so no additional handling required to "skip" any potentially applied entries.
+        //
+        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.
+        // (`SerdeWal::read_all` may even start reading WAL from some already truncated
+        // index *occasionally*), but the storage can handle it.
+
+        for (op_num, update) in wal.read_all() {
+            if let Some(clock_tag) = &update.clock_tag {
+                clock_map.advance_clock(clock_tag);
+            }
+
+            // Propagate `CollectionError::ServiceError`, but skip other error types.
+            match &CollectionUpdater::update(segments, op_num, update.operation) {
+                Err(err @ CollectionError::ServiceError { error, backtrace }) => {
+                    let path = self.path.display();
+
+                    log::error!(
+                        "Can't apply WAL operation: {error}, \
+                         collection: {collection_id}, \
+                         shard: {path}, \
+                         op_num: {op_num}"
+                    );
+
+                    if let Some(backtrace) = &backtrace {
+                        log::error!("Backtrace: {}", backtrace);
+                    }
+
+                    return Err(err.clone());
+                }
+                Err(err @ CollectionError::OutOfMemory { .. }) => {
+                    log::error!("{err}");
+                    return Err(err.clone());
+                }
+                Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),
+                Err(err) => log::error!("{err}"),
+                Ok(_) => (),
+            }
+
+            // Update progress bar or show text progress every WAL_LOAD_REPORT_EVERY
+            bar.inc(1);
+            if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {
+                let progress = bar.position();
+                log::info!(
+                    "{progress}/{} ({}%)",
+                    wal.len(),
+                    (progress as f32 / wal.len() as f32 * 100.0) as usize,
+                );
+                last_progress_report = Instant::now();
+            }
+        }
+
+        self.segments.read().flush_all(true)?;
+
+        bar.finish();
+        if !show_progress_bar {
+            log::info!(
+                "Recovered collection {collection_id}: {0}/{0} (100%)",
+                wal.len(),
+            );
+        }
+
+        Ok(())
+    }
+
+    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {
+        let config = self.collection_config.read().await;
+        let mut update_handler = self.update_handler.lock().await;
+
+        let (update_sender, update_receiver) =
+            mpsc::channel(self.shared_storage_config.update_queue_size);
+        // makes sure that the Stop signal is the last one in this channel
+        let old_sender = self.update_sender.swap(Arc::new(update_sender));
+        old_sender.send(UpdateSignal::Stop).await?;
+        update_handler.stop_flush_worker();
+
+        update_handler.wait_workers_stops().await?;
+        let new_optimizers = build_optimizers(
+            &self.path,
+            &config.params,
+            &config.optimizer_config,
+            &config.hnsw_config,
+            &config.quantization_config,
+        );
+        update_handler.optimizers = new_optimizers;
+        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;
+        update_handler.run_workers(update_receiver);
+        self.update_sender.load().send(UpdateSignal::Nop).await?;
+
+        Ok(())
+    }
+
+    /// Finishes ongoing update tasks
+    pub async fn stop_gracefully(&self) {
+        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {
+            log::warn!("Error sending stop signal to update handler: {}", err);
+        }
+
+        self.stop_flush_worker().await;
+
+        if let Err(err) = self.wait_update_workers_stop().await {
+            log::warn!("Update workers failed with: {}", err);
+        }
+    }
+
+    pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {
+        // recover segments
+        let segments_path = LocalShard::segments_path(snapshot_path);
+        // iterate over segments directory and recover each segment
+        for entry in std::fs::read_dir(segments_path)? {
+            let entry_path = entry?.path();
+            if entry_path.extension().map(|s| s == "tar").unwrap_or(false) {
+                let segment_id_opt = entry_path
+                    .file_stem()
+                    .map(|s| s.to_str().unwrap().to_owned());
+                if segment_id_opt.is_none() {
+                    return Err(CollectionError::service_error(
+                        "Segment ID is empty".to_string(),
+                    ));
+                }
+                let segment_id = segment_id_opt.unwrap();
+                Segment::restore_snapshot(&entry_path, &segment_id)?;
+                std::fs::remove_file(&entry_path)?;
+            }
+        }
+        Ok(())
+    }
+
+    /// Create snapshot for local shard into `target_path`
+    pub async fn create_snapshot(
+        &self,
+        temp_path: &Path,
+        target_path: &Path,
+        save_wal: bool,
+    ) -> CollectionResult<()> {
+        let snapshot_shard_path = target_path;
+
+        // snapshot all shard's segment
+        let snapshot_segments_shard_path = snapshot_shard_path.join("segments");
+        create_dir_all(&snapshot_segments_shard_path).await?;
+
+        let segments = self.segments.clone();
+        let wal = self.wal.clone();
+        let snapshot_shard_path_owned = snapshot_shard_path.to_owned();
+
+        if !save_wal {
+            // If we are not saving WAL, we still need to make sure that all submitted by this point
+            // updates have made it to the segments. So we use the Plunger to achieve that.
+            // It will notify us when all submitted updates so far have been processed.
+            let (tx, rx) = oneshot::channel();
+            let plunger = UpdateSignal::Plunger(tx);
+            self.update_sender.load().send(plunger).await?;
+            rx.await?;
+        }
+
+        let temp_path = temp_path.to_owned();
+
+        tokio::task::spawn_blocking(move || {
+            let segments_read = segments.read();
+
+            // Do not change segments while snapshotting
+            segments_read.snapshot_all_segments(&temp_path, &snapshot_segments_shard_path)?;
+
+            if save_wal {
+                // snapshot all shard's WAL
+                Self::snapshot_wal(wal, &snapshot_shard_path_owned)
+            } else {
+                Self::snapshot_empty_wal(wal, &snapshot_shard_path_owned)
+            }
+        })
+        .await??;
+
+        // copy clock map
+        let clock_map_path = Self::clock_map_path(&self.path);
+
+        if clock_map_path.exists() {
+            let target_clock_map_path = Self::clock_map_path(snapshot_shard_path);
+            copy(clock_map_path, target_clock_map_path).await?;
+        }
+
+        // copy shard's config
+        let shard_config_path = ShardConfig::get_config_path(&self.path);
+        let target_shard_config_path = snapshot_shard_path.join(SHARD_CONFIG_FILE);
+        copy(&shard_config_path, &target_shard_config_path).await?;
+
+        Ok(())
+    }
+
+    /// Create empty WAL which is compatible with currently stored data
+    pub fn snapshot_empty_wal(wal: LockedWal, snapshot_shard_path: &Path) -> CollectionResult<()> {
+        let (segment_capacity, latest_op_num) = {
+            let wal_guard = wal.lock();
+            (wal_guard.segment_capacity(), wal_guard.last_index())
+        };
+
+        let target_path = Self::wal_path(snapshot_shard_path);
+
+        // Create directory if it does not exist
+        std::fs::create_dir_all(&target_path).map_err(|err| {
+            CollectionError::service_error(format!(
+                "Can not crate directory {}: {}",
+                target_path.display(),
+                err
+            ))
+        })?;
+
+        Wal::generate_empty_wal_starting_at_index(
+            target_path,
+            &WalOptions {
+                segment_capacity,
+                segment_queue_len: 0,
+            },
+            latest_op_num,
+        )
+        .map_err(|err| {
+            CollectionError::service_error(format!("Error while create empty WAL: {err}"))
+        })
+    }
+
+    /// snapshot WAL
+    ///
+    /// copies all WAL files into `snapshot_shard_path/wal`
+    pub fn snapshot_wal(wal: LockedWal, snapshot_shard_path: &Path) -> CollectionResult<()> {
+        // lock wal during snapshot
+        let mut wal_guard = wal.lock();
+        wal_guard.flush()?;
+        let source_wal_path = wal_guard.path();
+        let options = fs_extra::dir::CopyOptions::new();
+        fs_extra::dir::copy(source_wal_path, snapshot_shard_path, &options).map_err(|err| {
+            CollectionError::service_error(format!(
+                "Error while copy WAL {snapshot_shard_path:?} {err}"
+            ))
+        })?;
+        Ok(())
+    }
+
+    pub fn estimate_cardinality<'a>(
+        &'a self,
+        filter: Option<&'a Filter>,
+    ) -> CollectionResult<CardinalityEstimation> {
+        let segments = self.segments().read();
+        let some_segment = segments.iter().next();
+
+        if some_segment.is_none() {
+            return Ok(CardinalityEstimation::exact(0));
+        }
+        let cardinality = segments
+            .iter()
+            .map(|(_id, segment)| segment.get().read().estimate_point_count(filter))
+            .fold(CardinalityEstimation::exact(0), |acc, x| {
+                CardinalityEstimation {
+                    primary_clauses: vec![],
+                    min: acc.min + x.min,
+                    exp: acc.exp + x.exp,
+                    max: acc.max + x.max,
+                }
+            });
+        Ok(cardinality)
+    }
+
+    pub fn read_filtered<'a>(
+        &'a self,
+        filter: Option<&'a Filter>,
+    ) -> CollectionResult<BTreeSet<PointIdType>> {
+        let segments = self.segments().read();
+        let some_segment = segments.iter().next();
+
+        if some_segment.is_none() {
+            return Ok(Default::default());
+        }
+        let all_points: BTreeSet<_> = segments
+            .iter()
+            .flat_map(|(_id, segment)| segment.get().read().read_filtered(None, None, filter))
+            .collect();
+        Ok(all_points)
+    }
+
+    pub fn get_telemetry_data(&self) -> LocalShardTelemetry {
+        let segments_read_guard = self.segments.read();
+        let segments: Vec<_> = segments_read_guard
+            .iter()
+            .map(|(_id, segment)| segment.get().read().get_telemetry_data())
+            .collect();
+
+        let optimizer_status = match &segments_read_guard.optimizer_errors {
+            None => OptimizersStatus::Ok,
+            Some(error) => OptimizersStatus::Error(error.to_string()),
+        };
+        drop(segments_read_guard);
+        let optimizations = self
+            .optimizers
+            .iter()
+            .map(|optimizer| optimizer.get_telemetry_data())
+            .fold(Default::default(), |acc, x| acc + x);
+
+        LocalShardTelemetry {
+            variant_name: None,
+            segments,
+            optimizations: OptimizerTelemetry {
+                status: optimizer_status,
+                optimizations,
+                log: self.optimizers_log.lock().to_telemetry(),
+            },
+        }
+    }
+
+    /// Returns estimated size of vector data in bytes
+    async fn estimate_vector_data_size(&self) -> usize {
+        let info = self.local_shard_info().await;
+
+        let vector_size: usize = info
+            .config
+            .params
+            .vectors
+            .params_iter()
+            .map(|(_, value)| {
+                let vector_size = value.size.get() as usize;
+
+                let quantization_config = value
+                    .quantization_config
+                    .as_ref()
+                    .or(info.config.quantization_config.as_ref());
+
+                let quantized_size_bytes = match quantization_config {
+                    None => 0,
+                    Some(QuantizationConfig::Scalar(_)) => vector_size,
+                    Some(QuantizationConfig::Product(pq)) => match pq.product.compression {
+                        CompressionRatio::X4 => vector_size,
+                        CompressionRatio::X8 => vector_size / 2,
+                        CompressionRatio::X16 => vector_size / 4,
+                        CompressionRatio::X32 => vector_size / 8,
+                        CompressionRatio::X64 => vector_size / 16,
+                    },
+                    Some(QuantizationConfig::Binary(_)) => vector_size / 8,
+                };
+
+                vector_size * size_of::<VectorElementType>() + quantized_size_bytes
+            })
+            .sum();
+
+        vector_size * info.points_count
+    }
+
+    pub async fn local_shard_info(&self) -> CollectionInfoInternal {
+        let collection_config = self.collection_config.read().await.clone();
+        let segments = self.segments().read();
+        let mut vectors_count = 0;
+        let mut indexed_vectors_count = 0;
+        let mut points_count = 0;
+        let mut segments_count = 0;
+        let mut status = CollectionStatus::Green;
+        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();
+        for (_idx, segment) in segments.iter() {
+            segments_count += 1;
+
+            let segment_info = segment.get().read().info();
+
+            if segment_info.segment_type == SegmentType::Special {
+                status = CollectionStatus::Yellow;
+            }
+            vectors_count += segment_info.num_vectors;
+            indexed_vectors_count += segment_info.num_indexed_vectors;
+            points_count += segment_info.num_points;
+            for (key, val) in segment_info.index_schema {
+                schema
+                    .entry(key)
+                    .and_modify(|entry| entry.points += val.points)
+                    .or_insert(val);
+            }
+        }
+        if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
+            status = CollectionStatus::Red;
+        }
+
+        let optimizer_status = match &segments.optimizer_errors {
+            None => OptimizersStatus::Ok,
+            Some(error) => OptimizersStatus::Error(error.to_string()),
+        };
+
+        CollectionInfoInternal {
+            status,
+            optimizer_status,
+            vectors_count,
+            indexed_vectors_count,
+            points_count,
+            segments_count,
+            config: collection_config,
+            payload_schema: schema,
+        }
+    }
+
+    pub fn update_tracker(&self) -> &UpdateTracker {
+        &self.update_tracker
+    }
+}
+
+impl Drop for LocalShard {
+    fn drop(&mut self) {
+        thread::scope(|s| {
+            let handle = thread::Builder::new()
+                .name("drop-shard".to_string())
+                .spawn_scoped(s, || {
+                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.
+                    self.update_runtime
+                        .block_on(async { self.stop_gracefully().await })
+                });
+            handle.expect("Failed to create thread for shard drop");
+        })
+    }
+}

commit f08df0b22e28c22c0f1eddeba0343c516c4939a7
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Feb 9 16:57:12 2024 +0100

    Add endpoint to request recovery point for remote shard (#3510)
    
    * Add initial gRPC call for requesting WAL recovery point for remote shard
    
    * Add remote shard method to request WAL recovery point
    
    * Add recovery point type in gRPC, use it in recovery point functions
    
    * Add function to extend recovery point with missing clocks from clock map
    
    * Add new gRPC type for recovery point clocks
    
    * Remove atomic loading, because we use regular integers now

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index ac347a340..a3bc6a72c 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -32,7 +32,7 @@ use tokio::sync::mpsc::Sender;
 use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
 use wal::{Wal, WalOptions};
 
-use self::clock_map::ClockMap;
+use self::clock_map::{ClockMap, RecoveryPoint};
 use super::update_tracker::UpdateTracker;
 use crate::collection_manager::collection_updater::CollectionUpdater;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
@@ -912,6 +912,13 @@ impl LocalShard {
     pub fn update_tracker(&self) -> &UpdateTracker {
         &self.update_tracker
     }
+
+    /// Get the recovery point for the current shard
+    ///
+    /// This is sourced from the last seen clocks from other nodes that we know about.
+    pub async fn shard_recovery_point(&self) -> RecoveryPoint {
+        self.clock_map.lock().await.to_recovery_point()
+    }
 }
 
 impl Drop for LocalShard {

commit 5b406a0257f3e95a0e34a9d87047c9b388dacdd1
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Feb 12 15:29:55 2024 +0100

    Resolve WAL delta for shard diff transfer (#3571)
    
    * Take clock tag as value, because it implements Copy
    
    * Implement Display for recovery point
    
    * Add WAL function to read from newest to oldest, including physical
    
    * Add local shard method to resolve WAL delta based on recovery point
    
    * Add error reporting to WAL delta resolve method
    
    * Use lowercase error message
    
    * Use real first physical WAL index
    
    * Do not skip forced entries when resolving WAL delta
    
    * Use single error branch for unsupported shard types
    
    * Propagate WAL delta resolve method up to shard replica set
    
    * Change physical WAL naming
    
    * Decouple WAL delta resolve method into standalone function

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index a3bc6a72c..5b4f91f4d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,5 +1,6 @@
 pub mod clock_map;
 mod shard_ops;
+pub mod wal_delta;
 
 use std::collections::{BTreeSet, HashMap};
 use std::mem::size_of;
@@ -526,7 +527,7 @@ impl LocalShard {
         // index *occasionally*), but the storage can handle it.
 
         for (op_num, update) in wal.read_all() {
-            if let Some(clock_tag) = &update.clock_tag {
+            if let Some(clock_tag) = update.clock_tag {
                 clock_map.advance_clock(clock_tag);
             }
 

commit 42b80f454346b39c2fba09e38c8c6c8e578080c6
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Feb 14 17:25:49 2024 +0100

    Add WAL type with integrated clock map (#3620)
    
    * Add WAL type with integrated clock map
    
    * Rename clock map field to last clocks
    
    * Move WAL delta logic into separate module

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 5b4f91f4d..1058e5db5 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,6 +1,5 @@
 pub mod clock_map;
 mod shard_ops;
-pub mod wal_delta;
 
 use std::collections::{BTreeSet, HashMap};
 use std::mem::size_of;
@@ -53,8 +52,7 @@ use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
 use crate::shards::CollectionId;
 use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
 use crate::wal::SerdeWal;
-
-pub type LockedWal = Arc<ParkingMutex<SerdeWal<OperationWithClockTag>>>;
+use crate::wal_delta::{LockedWal, RecoverableWal};
 
 /// If rendering WAL load progression in basic text form, report progression every 60 seconds.
 const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);
@@ -68,14 +66,13 @@ pub struct LocalShard {
     pub(super) segments: Arc<RwLock<SegmentHolder>>,
     pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
     pub(super) shared_storage_config: Arc<SharedStorageConfig>,
-    pub(super) wal: LockedWal,
+    pub(super) wal: RecoverableWal,
     pub(super) update_handler: Arc<Mutex<UpdateHandler>>,
     pub(super) update_sender: ArcSwap<Sender<UpdateSignal>>,
     pub(super) update_tracker: UpdateTracker,
     pub(super) path: PathBuf,
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
-    clock_map: Arc<Mutex<ClockMap>>,
     update_runtime: Handle,
 }
 
@@ -176,12 +173,11 @@ impl LocalShard {
             segments: segment_holder,
             collection_config,
             shared_storage_config,
-            wal: locked_wal,
+            wal: RecoverableWal::from(locked_wal, clock_map),
             update_handler: Arc::new(Mutex::new(update_handler)),
             update_sender: ArcSwap::from_pointee(update_sender),
             update_tracker,
             path: shard_path.to_owned(),
-            clock_map,
             update_runtime,
             optimizers,
             optimizers_log,
@@ -491,8 +487,8 @@ impl LocalShard {
 
     /// Loads latest collection operations from WAL
     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
-        let mut clock_map = self.clock_map.lock().await;
-        let wal = self.wal.lock();
+        let mut last_clocks = self.wal.last_clocks.lock().await;
+        let wal = self.wal.wal.lock();
         let bar = ProgressBar::new(wal.len());
 
         let progress_style = ProgressStyle::default_bar()
@@ -528,7 +524,7 @@ impl LocalShard {
 
         for (op_num, update) in wal.read_all() {
             if let Some(clock_tag) = update.clock_tag {
-                clock_map.advance_clock(clock_tag);
+                last_clocks.advance_clock(clock_tag);
             }
 
             // Propagate `CollectionError::ServiceError`, but skip other error types.
@@ -661,7 +657,7 @@ impl LocalShard {
         create_dir_all(&snapshot_segments_shard_path).await?;
 
         let segments = self.segments.clone();
-        let wal = self.wal.clone();
+        let wal = self.wal.wal.clone();
         let snapshot_shard_path_owned = snapshot_shard_path.to_owned();
 
         if !save_wal {
@@ -917,8 +913,8 @@ impl LocalShard {
     /// Get the recovery point for the current shard
     ///
     /// This is sourced from the last seen clocks from other nodes that we know about.
-    pub async fn shard_recovery_point(&self) -> RecoveryPoint {
-        self.clock_map.lock().await.to_recovery_point()
+    pub async fn recovery_point(&self) -> RecoveryPoint {
+        self.wal.recovery_point().await
     }
 }
 

commit cac93508e6dc649f8db3376bb3ad0d31cd1c28bf
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Feb 16 13:21:10 2024 +0100

    Add WAL cutoff clock map (#3631)
    
    * Add cutoff clock map to recoverable WAL
    
    * Rename last seen clock map to highest clock map
    
    * Add method to update cutoff clock map in recoverable WAL
    
    * Check cutoff point when resolving WAL delta
    
    * Rename last clocks to highest clocks

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 1058e5db5..2a91e236e 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -87,10 +87,15 @@ impl LocalShard {
         move_dir(wal_from, wal_to).await?;
         move_dir(segments_from, segments_to).await?;
 
-        let clock_map_from = Self::clock_map_path(from);
-        if clock_map_from.exists() {
-            let clock_map_to = Self::clock_map_path(to);
-            move_file(clock_map_from, clock_map_to).await?;
+        let highest_clock_map_path = Self::highest_clock_map_path(from);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(from);
+        if highest_clock_map_path.exists() {
+            let clock_map_to = Self::highest_clock_map_path(to);
+            move_file(highest_clock_map_path, clock_map_to).await?;
+        }
+        if cutoff_clock_map_path.exists() {
+            let clock_map_to = Self::cutoff_clock_map_path(to);
+            move_file(cutoff_clock_map_path, clock_map_to).await?;
         }
 
         Ok(())
@@ -119,10 +124,14 @@ impl LocalShard {
             remove_dir_all(segments_path).await?;
         }
 
-        // Delete clock map
-        let clock_map_path = Self::clock_map_path(shard_path);
-        if clock_map_path.exists() {
-            remove_file(clock_map_path).await?;
+        // Delete clock maps
+        let highest_clock_map = Self::highest_clock_map_path(shard_path);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
+        if highest_clock_map.exists() {
+            remove_file(highest_clock_map).await?;
+        }
+        if cutoff_clock_map_path.exists() {
+            remove_file(cutoff_clock_map_path).await?;
         }
 
         Ok(())
@@ -137,15 +146,18 @@ impl LocalShard {
         optimizers: Arc<Vec<Arc<Optimizer>>>,
         optimizer_cpu_budget: CpuBudget,
         shard_path: &Path,
-        clock_map: ClockMap,
+        highest_clock_map: ClockMap,
+        cutoff_clock_map: ClockMap,
         update_runtime: Handle,
     ) -> Self {
         let segment_holder = Arc::new(RwLock::new(segment_holder));
         let config = collection_config.read().await;
         let locked_wal = Arc::new(ParkingMutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
-        let clock_map = Arc::new(Mutex::new(clock_map));
-        let clock_map_path = Self::clock_map_path(shard_path);
+        let highest_clock_map = Arc::new(Mutex::new(highest_clock_map));
+        let cutoff_clock_map = Arc::new(Mutex::new(cutoff_clock_map));
+        let highest_clock_map_path = Self::highest_clock_map_path(shard_path);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
 
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
@@ -157,8 +169,10 @@ impl LocalShard {
             locked_wal.clone(),
             config.optimizer_config.flush_interval_sec,
             config.optimizer_config.max_optimization_threads,
-            clock_map.clone(),
-            clock_map_path,
+            highest_clock_map.clone(),
+            cutoff_clock_map.clone(),
+            highest_clock_map_path,
+            cutoff_clock_map_path,
         );
 
         let (update_sender, update_receiver) =
@@ -173,7 +187,7 @@ impl LocalShard {
             segments: segment_holder,
             collection_config,
             shared_storage_config,
-            wal: RecoverableWal::from(locked_wal, clock_map),
+            wal: RecoverableWal::from(locked_wal, highest_clock_map, cutoff_clock_map),
             update_handler: Arc::new(Mutex::new(update_handler)),
             update_sender: ArcSwap::from_pointee(update_sender),
             update_tracker,
@@ -202,7 +216,8 @@ impl LocalShard {
 
         let wal_path = Self::wal_path(shard_path);
         let segments_path = Self::segments_path(shard_path);
-        let clock_map_path = Self::clock_map_path(shard_path);
+        let highest_clock_map_path = Self::highest_clock_map_path(shard_path);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
 
         let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(
             wal_path.to_str().unwrap(),
@@ -293,7 +308,8 @@ impl LocalShard {
 
         drop(collection_config_read); // release `shared_config` from borrow checker
 
-        let clock_map = ClockMap::load_or_default(&clock_map_path)?;
+        let highest_clock_map = ClockMap::load_or_default(&highest_clock_map_path)?;
+        let cutoff_clock_map = ClockMap::load_or_default(&cutoff_clock_map_path)?;
 
         let collection = LocalShard::new(
             segment_holder,
@@ -303,7 +319,8 @@ impl LocalShard {
             optimizers,
             optimizer_cpu_budget,
             shard_path,
-            clock_map,
+            highest_clock_map,
+            cutoff_clock_map,
             update_runtime,
         )
         .await;
@@ -346,8 +363,12 @@ impl LocalShard {
         shard_path.join("segments")
     }
 
-    pub fn clock_map_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("clock_map.json")
+    pub fn highest_clock_map_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("clock_map_highest.json")
+    }
+
+    pub fn cutoff_clock_map_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("clock_map_cutoff.json")
     }
 
     pub async fn build_local(
@@ -468,6 +489,7 @@ impl LocalShard {
             optimizer_cpu_budget,
             shard_path,
             ClockMap::default(),
+            ClockMap::default(),
             update_runtime,
         )
         .await;
@@ -487,7 +509,7 @@ impl LocalShard {
 
     /// Loads latest collection operations from WAL
     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
-        let mut last_clocks = self.wal.last_clocks.lock().await;
+        let mut highest_clocks = self.wal.highest_clocks.lock().await;
         let wal = self.wal.wal.lock();
         let bar = ProgressBar::new(wal.len());
 
@@ -524,7 +546,7 @@ impl LocalShard {
 
         for (op_num, update) in wal.read_all() {
             if let Some(clock_tag) = update.clock_tag {
-                last_clocks.advance_clock(clock_tag);
+                highest_clocks.advance_clock(clock_tag);
             }
 
             // Propagate `CollectionError::ServiceError`, but skip other error types.
@@ -687,12 +709,17 @@ impl LocalShard {
         })
         .await??;
 
-        // copy clock map
-        let clock_map_path = Self::clock_map_path(&self.path);
+        // Copy clock maps
+        let highest_clock_map_path = Self::highest_clock_map_path(&self.path);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(&self.path);
 
-        if clock_map_path.exists() {
-            let target_clock_map_path = Self::clock_map_path(snapshot_shard_path);
-            copy(clock_map_path, target_clock_map_path).await?;
+        if highest_clock_map_path.exists() {
+            let target_clock_map_path = Self::highest_clock_map_path(snapshot_shard_path);
+            copy(highest_clock_map_path, target_clock_map_path).await?;
+        }
+        if cutoff_clock_map_path.exists() {
+            let target_clock_map_path = Self::cutoff_clock_map_path(snapshot_shard_path);
+            copy(cutoff_clock_map_path, target_clock_map_path).await?;
         }
 
         // copy shard's config

commit df18dbbe755a14e717d6656504fef27307eb589d
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Feb 16 16:33:33 2024 +0100

    WAL delta resolution and recovery tests (#3610)
    
    * Fix error when reading WAL backwards with zero items
    
    * WAL delta resolve function should take arc value, not reference
    
    * Reject WAL delta resolution if recovery point defines unknown clocks
    
    * Check if recovery point is empty after adding missed clocks
    
    * Test resolving one operation from WAL
    
    * Test empty recovery point error
    
    * Test recovery point with unknown clocks error
    
    * Test recovery point with higher clocks than current WAL error
    
    * Test recovery point is not in WAL error
    
    * Test recovery point is cut off
    
    * In test, recover WAL with delta
    
    * Move empty WAL construction in test into fixture
    
    * In tests, resolve WAL on both node A and B to check consistency
    
    * WAL resolve function can take local recovery point by reference
    
    * Test WAL delta with many operations, not just one
    
    * Reformat
    
    * Test WAL delta with operations from multiple entrypoints intermixed
    
    * Test WAL delta with operations in a different order on different nodes
    
    * Source clock IDs from clock guard
    
    * In tests, when recovering WAL, update clock map of the recovering node
    
    * Rename WAL delta test functions
    
    * suggestion for tests
    
    * Utilize RecoverableWal in WAL delta tests, advance for clock responses
    
    * an advanced test scenario
    
    * remove mut
    
    * Mock all test operations, test error explicitly
    
    * Fix WAL cutoff test, allow clocks not in cutoff point
    
    * Allow WAL delta resolution for equal states to return None
    
    * Advance highest seen clocks along with updating cutoff point
    
    * Update full transfer delta test with cutoff point, still failing
    
    * Strict WAL delta error checks
    
    * Fix typo
    
    * update tests
    
    * fmt
    
    * Use correct clock set for node D operation in failing test
    
    * Apply suggestions from code review
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * Mark recovery point insert function as testing only
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 2a91e236e..00871a566 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -511,7 +511,7 @@ impl LocalShard {
     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
         let mut highest_clocks = self.wal.highest_clocks.lock().await;
         let wal = self.wal.wal.lock();
-        let bar = ProgressBar::new(wal.len());
+        let bar = ProgressBar::new(wal.len(false));
 
         let progress_style = ProgressStyle::default_bar()
             .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")
@@ -527,7 +527,7 @@ impl LocalShard {
         if !show_progress_bar {
             log::info!(
                 "Recovering collection {collection_id}: 0/{} (0%)",
-                wal.len(),
+                wal.len(false),
             );
         }
 
@@ -582,8 +582,8 @@ impl LocalShard {
                 let progress = bar.position();
                 log::info!(
                     "{progress}/{} ({}%)",
-                    wal.len(),
-                    (progress as f32 / wal.len() as f32 * 100.0) as usize,
+                    wal.len(false),
+                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,
                 );
                 last_progress_report = Instant::now();
             }
@@ -595,7 +595,7 @@ impl LocalShard {
         if !show_progress_bar {
             log::info!(
                 "Recovered collection {collection_id}: {0}/{0} (100%)",
-                wal.len(),
+                wal.len(false),
             );
         }
 

commit d39a483017d14971051e30be5023dd4e969163b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Feb 20 14:55:57 2024 +0000

    Refactor: introduce details level enum (#3612)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 00871a566..c7ba0429e 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -13,6 +13,7 @@ use std::time::{Duration, Instant};
 use arc_swap::ArcSwap;
 use common::cpu::CpuBudget;
 use common::panic;
+use common::types::TelemetryDetail;
 use indicatif::{ProgressBar, ProgressStyle};
 use itertools::Itertools;
 use parking_lot::{Mutex as ParkingMutex, RwLock};
@@ -819,11 +820,11 @@ impl LocalShard {
         Ok(all_points)
     }
 
-    pub fn get_telemetry_data(&self) -> LocalShardTelemetry {
+    pub fn get_telemetry_data(&self, detail: TelemetryDetail) -> LocalShardTelemetry {
         let segments_read_guard = self.segments.read();
         let segments: Vec<_> = segments_read_guard
             .iter()
-            .map(|(_id, segment)| segment.get().read().get_telemetry_data())
+            .map(|(_id, segment)| segment.get().read().get_telemetry_data(detail))
             .collect();
 
         let optimizer_status = match &segments_read_guard.optimizer_errors {
@@ -834,7 +835,7 @@ impl LocalShard {
         let optimizations = self
             .optimizers
             .iter()
-            .map(|optimizer| optimizer.get_telemetry_data())
+            .map(|optimizer| optimizer.get_telemetry_data(detail))
             .fold(Default::default(), |acc, x| acc + x);
 
         LocalShardTelemetry {

commit 530d24a3452b0f01ed3948acf5a3e4891327a99a
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Feb 22 11:20:45 2024 +0100

    Add struct combining local shard clock maps (#3662)
    
    * Create structure holding shared highest and cutoff clock maps and paths
    
    * Use local visibility
    
    * Rename ShardClocks to LocalShardClocks
    
    * Move shard clock map file IO into dedicated functions
    
    * Fix typo

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index c7ba0429e..6a0da9166 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -88,16 +88,7 @@ impl LocalShard {
         move_dir(wal_from, wal_to).await?;
         move_dir(segments_from, segments_to).await?;
 
-        let highest_clock_map_path = Self::highest_clock_map_path(from);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(from);
-        if highest_clock_map_path.exists() {
-            let clock_map_to = Self::highest_clock_map_path(to);
-            move_file(highest_clock_map_path, clock_map_to).await?;
-        }
-        if cutoff_clock_map_path.exists() {
-            let clock_map_to = Self::cutoff_clock_map_path(to);
-            move_file(cutoff_clock_map_path, clock_map_to).await?;
-        }
+        LocalShardClocks::move_data(from, to).await?;
 
         Ok(())
     }
@@ -125,15 +116,7 @@ impl LocalShard {
             remove_dir_all(segments_path).await?;
         }
 
-        // Delete clock maps
-        let highest_clock_map = Self::highest_clock_map_path(shard_path);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
-        if highest_clock_map.exists() {
-            remove_file(highest_clock_map).await?;
-        }
-        if cutoff_clock_map_path.exists() {
-            remove_file(cutoff_clock_map_path).await?;
-        }
+        LocalShardClocks::delete_data(shard_path).await?;
 
         Ok(())
     }
@@ -155,10 +138,7 @@ impl LocalShard {
         let config = collection_config.read().await;
         let locked_wal = Arc::new(ParkingMutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
-        let highest_clock_map = Arc::new(Mutex::new(highest_clock_map));
-        let cutoff_clock_map = Arc::new(Mutex::new(cutoff_clock_map));
-        let highest_clock_map_path = Self::highest_clock_map_path(shard_path);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
+        let clocks = LocalShardClocks::new_at(highest_clock_map, cutoff_clock_map, shard_path);
 
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
@@ -170,10 +150,7 @@ impl LocalShard {
             locked_wal.clone(),
             config.optimizer_config.flush_interval_sec,
             config.optimizer_config.max_optimization_threads,
-            highest_clock_map.clone(),
-            cutoff_clock_map.clone(),
-            highest_clock_map_path,
-            cutoff_clock_map_path,
+            clocks.clone(),
         );
 
         let (update_sender, update_receiver) =
@@ -188,7 +165,7 @@ impl LocalShard {
             segments: segment_holder,
             collection_config,
             shared_storage_config,
-            wal: RecoverableWal::from(locked_wal, highest_clock_map, cutoff_clock_map),
+            wal: RecoverableWal::from(locked_wal, clocks.highest_clocks, clocks.cutoff_clocks),
             update_handler: Arc::new(Mutex::new(update_handler)),
             update_sender: ArcSwap::from_pointee(update_sender),
             update_tracker,
@@ -217,8 +194,8 @@ impl LocalShard {
 
         let wal_path = Self::wal_path(shard_path);
         let segments_path = Self::segments_path(shard_path);
-        let highest_clock_map_path = Self::highest_clock_map_path(shard_path);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(shard_path);
+        let highest_clock_map_path = LocalShardClocks::highest_clock_map_path(shard_path);
+        let cutoff_clock_map_path = LocalShardClocks::cutoff_clock_map_path(shard_path);
 
         let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(
             wal_path.to_str().unwrap(),
@@ -364,14 +341,6 @@ impl LocalShard {
         shard_path.join("segments")
     }
 
-    pub fn highest_clock_map_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("clock_map_highest.json")
-    }
-
-    pub fn cutoff_clock_map_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("clock_map_cutoff.json")
-    }
-
     pub async fn build_local(
         id: ShardId,
         collection_id: CollectionId,
@@ -710,18 +679,7 @@ impl LocalShard {
         })
         .await??;
 
-        // Copy clock maps
-        let highest_clock_map_path = Self::highest_clock_map_path(&self.path);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(&self.path);
-
-        if highest_clock_map_path.exists() {
-            let target_clock_map_path = Self::highest_clock_map_path(snapshot_shard_path);
-            copy(highest_clock_map_path, target_clock_map_path).await?;
-        }
-        if cutoff_clock_map_path.exists() {
-            let target_clock_map_path = Self::cutoff_clock_map_path(snapshot_shard_path);
-            copy(cutoff_clock_map_path, target_clock_map_path).await?;
-        }
+        LocalShardClocks::copy_data(&self.path, snapshot_shard_path).await?;
 
         // copy shard's config
         let shard_config_path = ShardConfig::get_config_path(&self.path);
@@ -960,3 +918,89 @@ impl Drop for LocalShard {
         })
     }
 }
+
+/// Convenience struct for combining clock maps belonging to a shard
+///
+/// Holds a clock map for tracking the highest clocks and the cutoff clocks.
+#[derive(Clone)]
+pub struct LocalShardClocks {
+    highest_clocks: Arc<Mutex<ClockMap>>,
+    cutoff_clocks: Arc<Mutex<ClockMap>>,
+    highest_clocks_path: PathBuf,
+    cutoff_clocks_path: PathBuf,
+}
+
+impl LocalShardClocks {
+    pub fn new_at(highest_clocks: ClockMap, cutoff_clocks: ClockMap, shard_path: &Path) -> Self {
+        Self {
+            highest_clocks: Arc::new(Mutex::new(highest_clocks)),
+            cutoff_clocks: Arc::new(Mutex::new(cutoff_clocks)),
+            highest_clocks_path: Self::highest_clock_map_path(shard_path),
+            cutoff_clocks_path: Self::cutoff_clock_map_path(shard_path),
+        }
+    }
+
+    /// Persist clock maps to disk
+    pub async fn store(&self) -> CollectionResult<()> {
+        self.cutoff_clocks
+            .lock()
+            .await
+            .store(&self.cutoff_clocks_path)?;
+        self.highest_clocks
+            .lock()
+            .await
+            .store(&self.highest_clocks_path)?;
+        Ok(())
+    }
+
+    pub fn highest_clock_map_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("clock_map_highest.json")
+    }
+
+    pub fn cutoff_clock_map_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("clock_map_cutoff.json")
+    }
+
+    /// Copy clock data on disk from one shard path to another.
+    pub async fn copy_data(from: &Path, to: &Path) -> CollectionResult<()> {
+        let highest_path_from = Self::highest_clock_map_path(from);
+        let cutoff_clock_map_path = Self::cutoff_clock_map_path(from);
+        if highest_path_from.exists() {
+            let highest_path_to = Self::highest_clock_map_path(to);
+            copy(highest_path_from, highest_path_to).await?;
+        }
+        if cutoff_clock_map_path.exists() {
+            let cutoff_path_to = Self::cutoff_clock_map_path(to);
+            copy(cutoff_clock_map_path, cutoff_path_to).await?;
+        }
+        Ok(())
+    }
+
+    /// Move clock data on disk from one shard path to another.
+    pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {
+        let highest_path_from = Self::highest_clock_map_path(from);
+        let cutoff_path_from = Self::cutoff_clock_map_path(from);
+        if highest_path_from.exists() {
+            let highest_path_to = Self::highest_clock_map_path(to);
+            move_file(highest_path_from, highest_path_to).await?;
+        }
+        if cutoff_path_from.exists() {
+            let cutoff_path_to = Self::cutoff_clock_map_path(to);
+            move_file(cutoff_path_from, cutoff_path_to).await?;
+        }
+        Ok(())
+    }
+
+    /// Delete clock data from disk at the given shard path.
+    pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {
+        let highest_path = Self::highest_clock_map_path(shard_path);
+        let cutoff_path = Self::cutoff_clock_map_path(shard_path);
+        if highest_path.exists() {
+            remove_file(highest_path).await?;
+        }
+        if cutoff_path.exists() {
+            remove_file(cutoff_path).await?;
+        }
+        Ok(())
+    }
+}

commit 19f43f5b30a81509fd8221f059824caa30fb2a84
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Feb 22 10:39:33 2024 +0000

    Prometheus histogram support (#3552)
    
    * Get rid of Arc in SegmentOptimizer::get_telemetry_counter()
    
    * Get rid of SegmentOptimizer::get_telemetry_data
    
    * Prometheus histogram support
    
    * Fixes, and sparse buckets
    
    * Preallocate in convert_histogram, merge_histograms
    
    * debug_assert to check boundaries are sorted
    
    * Generate histograms when details_level >= 3 or in /metrics

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 6a0da9166..0a77dd7c0 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -793,7 +793,12 @@ impl LocalShard {
         let optimizations = self
             .optimizers
             .iter()
-            .map(|optimizer| optimizer.get_telemetry_data(detail))
+            .map(|optimizer| {
+                optimizer
+                    .get_telemetry_counter()
+                    .lock()
+                    .get_statistics(detail)
+            })
             .fold(Default::default(), |acc, x| acc + x);
 
         LocalShardTelemetry {

commit bb8dcb15c8ef694d86a68df718b850f8a65ec8aa
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Feb 22 13:29:09 2024 +0100

    Add gRPC API to set shard cutoff point (#3661)
    
    * Add functions to propagate updating cutoff point from collection level
    
    * Add gRPC endpoint to set cutoff point
    
    * Lock highest and cutoff clock maps separately

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0a77dd7c0..9abb13d15 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -907,6 +907,13 @@ impl LocalShard {
     pub async fn recovery_point(&self) -> RecoveryPoint {
         self.wal.recovery_point().await
     }
+
+    /// Update the cutoff point on the current shard
+    ///
+    /// This also updates the highest seen clocks.
+    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {
+        self.wal.update_cutoff(cutoff).await
+    }
 }
 
 impl Drop for LocalShard {

commit 1539087a6dfa968fce556f8b386ea60049fe8025
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Feb 29 12:41:07 2024 +0100

    Diff transfer improvements (#3645)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 9abb13d15..bfcac678d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -130,15 +130,13 @@ impl LocalShard {
         optimizers: Arc<Vec<Arc<Optimizer>>>,
         optimizer_cpu_budget: CpuBudget,
         shard_path: &Path,
-        highest_clock_map: ClockMap,
-        cutoff_clock_map: ClockMap,
+        clocks: LocalShardClocks,
         update_runtime: Handle,
     ) -> Self {
         let segment_holder = Arc::new(RwLock::new(segment_holder));
         let config = collection_config.read().await;
         let locked_wal = Arc::new(ParkingMutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
-        let clocks = LocalShardClocks::new_at(highest_clock_map, cutoff_clock_map, shard_path);
 
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
@@ -151,6 +149,7 @@ impl LocalShard {
             config.optimizer_config.flush_interval_sec,
             config.optimizer_config.max_optimization_threads,
             clocks.clone(),
+            shard_path.into(),
         );
 
         let (update_sender, update_receiver) =
@@ -165,7 +164,7 @@ impl LocalShard {
             segments: segment_holder,
             collection_config,
             shared_storage_config,
-            wal: RecoverableWal::from(locked_wal, clocks.highest_clocks, clocks.cutoff_clocks),
+            wal: RecoverableWal::new(locked_wal, clocks.newest_clocks, clocks.oldest_clocks),
             update_handler: Arc::new(Mutex::new(update_handler)),
             update_sender: ArcSwap::from_pointee(update_sender),
             update_tracker,
@@ -194,8 +193,6 @@ impl LocalShard {
 
         let wal_path = Self::wal_path(shard_path);
         let segments_path = Self::segments_path(shard_path);
-        let highest_clock_map_path = LocalShardClocks::highest_clock_map_path(shard_path);
-        let cutoff_clock_map_path = LocalShardClocks::cutoff_clock_map_path(shard_path);
 
         let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(
             wal_path.to_str().unwrap(),
@@ -286,8 +283,7 @@ impl LocalShard {
 
         drop(collection_config_read); // release `shared_config` from borrow checker
 
-        let highest_clock_map = ClockMap::load_or_default(&highest_clock_map_path)?;
-        let cutoff_clock_map = ClockMap::load_or_default(&cutoff_clock_map_path)?;
+        let clocks = LocalShardClocks::load(shard_path)?;
 
         let collection = LocalShard::new(
             segment_holder,
@@ -297,8 +293,7 @@ impl LocalShard {
             optimizers,
             optimizer_cpu_budget,
             shard_path,
-            highest_clock_map,
-            cutoff_clock_map,
+            clocks,
             update_runtime,
         )
         .await;
@@ -458,8 +453,7 @@ impl LocalShard {
             optimizers,
             optimizer_cpu_budget,
             shard_path,
-            ClockMap::default(),
-            ClockMap::default(),
+            LocalShardClocks::default(),
             update_runtime,
         )
         .await;
@@ -479,7 +473,7 @@ impl LocalShard {
 
     /// Loads latest collection operations from WAL
     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
-        let mut highest_clocks = self.wal.highest_clocks.lock().await;
+        let mut newest_clocks = self.wal.newest_clocks.lock().await;
         let wal = self.wal.wal.lock();
         let bar = ProgressBar::new(wal.len(false));
 
@@ -514,9 +508,9 @@ impl LocalShard {
         // (`SerdeWal::read_all` may even start reading WAL from some already truncated
         // index *occasionally*), but the storage can handle it.
 
-        for (op_num, update) in wal.read_all() {
+        for (op_num, update) in wal.read_all(false) {
             if let Some(clock_tag) = update.clock_tag {
-                highest_clocks.advance_clock(clock_tag);
+                newest_clocks.advance_clock(clock_tag);
             }
 
             // Propagate `CollectionError::ServiceError`, but skip other error types.
@@ -934,85 +928,101 @@ impl Drop for LocalShard {
 /// Convenience struct for combining clock maps belonging to a shard
 ///
 /// Holds a clock map for tracking the highest clocks and the cutoff clocks.
-#[derive(Clone)]
+#[derive(Clone, Debug, Default)]
 pub struct LocalShardClocks {
-    highest_clocks: Arc<Mutex<ClockMap>>,
-    cutoff_clocks: Arc<Mutex<ClockMap>>,
-    highest_clocks_path: PathBuf,
-    cutoff_clocks_path: PathBuf,
+    newest_clocks: Arc<Mutex<ClockMap>>,
+    oldest_clocks: Arc<Mutex<ClockMap>>,
 }
 
 impl LocalShardClocks {
-    pub fn new_at(highest_clocks: ClockMap, cutoff_clocks: ClockMap, shard_path: &Path) -> Self {
+    fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {
         Self {
-            highest_clocks: Arc::new(Mutex::new(highest_clocks)),
-            cutoff_clocks: Arc::new(Mutex::new(cutoff_clocks)),
-            highest_clocks_path: Self::highest_clock_map_path(shard_path),
-            cutoff_clocks_path: Self::cutoff_clock_map_path(shard_path),
+            newest_clocks: Arc::new(Mutex::new(newest_clocks)),
+            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),
         }
     }
 
+    // Load clock maps from disk
+    pub fn load(shard_path: &Path) -> CollectionResult<Self> {
+        let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;
+
+        let oldest_clocks = ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;
+
+        Ok(Self::new(newest_clocks, oldest_clocks))
+    }
+
     /// Persist clock maps to disk
-    pub async fn store(&self) -> CollectionResult<()> {
-        self.cutoff_clocks
+    pub async fn store(&self, shard_path: &Path) -> CollectionResult<()> {
+        self.oldest_clocks
             .lock()
             .await
-            .store(&self.cutoff_clocks_path)?;
-        self.highest_clocks
+            .store(&Self::oldest_clocks_path(shard_path))?;
+
+        self.newest_clocks
             .lock()
             .await
-            .store(&self.highest_clocks_path)?;
-        Ok(())
-    }
-
-    pub fn highest_clock_map_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("clock_map_highest.json")
-    }
+            .store(&Self::newest_clocks_path(shard_path))?;
 
-    pub fn cutoff_clock_map_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("clock_map_cutoff.json")
+        Ok(())
     }
 
     /// Copy clock data on disk from one shard path to another.
     pub async fn copy_data(from: &Path, to: &Path) -> CollectionResult<()> {
-        let highest_path_from = Self::highest_clock_map_path(from);
-        let cutoff_clock_map_path = Self::cutoff_clock_map_path(from);
-        if highest_path_from.exists() {
-            let highest_path_to = Self::highest_clock_map_path(to);
-            copy(highest_path_from, highest_path_to).await?;
+        let newest_clocks_from = Self::newest_clocks_path(from);
+        let oldest_clocks_from = Self::oldest_clocks_path(from);
+
+        if newest_clocks_from.exists() {
+            let newest_clocks_to = Self::newest_clocks_path(to);
+            copy(newest_clocks_from, newest_clocks_to).await?;
         }
-        if cutoff_clock_map_path.exists() {
-            let cutoff_path_to = Self::cutoff_clock_map_path(to);
-            copy(cutoff_clock_map_path, cutoff_path_to).await?;
+
+        if oldest_clocks_from.exists() {
+            let oldest_clocks_to = Self::oldest_clocks_path(to);
+            copy(oldest_clocks_from, oldest_clocks_to).await?;
         }
+
         Ok(())
     }
 
     /// Move clock data on disk from one shard path to another.
     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {
-        let highest_path_from = Self::highest_clock_map_path(from);
-        let cutoff_path_from = Self::cutoff_clock_map_path(from);
-        if highest_path_from.exists() {
-            let highest_path_to = Self::highest_clock_map_path(to);
-            move_file(highest_path_from, highest_path_to).await?;
+        let newest_clocks_from = Self::newest_clocks_path(from);
+        let oldest_clocks_from = Self::oldest_clocks_path(from);
+
+        if newest_clocks_from.exists() {
+            let newest_clocks_to = Self::newest_clocks_path(to);
+            move_file(newest_clocks_from, newest_clocks_to).await?;
         }
-        if cutoff_path_from.exists() {
-            let cutoff_path_to = Self::cutoff_clock_map_path(to);
-            move_file(cutoff_path_from, cutoff_path_to).await?;
+
+        if oldest_clocks_from.exists() {
+            let oldest_clocks_to = Self::oldest_clocks_path(to);
+            move_file(oldest_clocks_from, oldest_clocks_to).await?;
         }
+
         Ok(())
     }
 
     /// Delete clock data from disk at the given shard path.
     pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {
-        let highest_path = Self::highest_clock_map_path(shard_path);
-        let cutoff_path = Self::cutoff_clock_map_path(shard_path);
-        if highest_path.exists() {
-            remove_file(highest_path).await?;
+        let newest_clocks_path = Self::newest_clocks_path(shard_path);
+        let oldest_clocks_path = Self::oldest_clocks_path(shard_path);
+
+        if newest_clocks_path.exists() {
+            remove_file(newest_clocks_path).await?;
         }
-        if cutoff_path.exists() {
-            remove_file(cutoff_path).await?;
+
+        if oldest_clocks_path.exists() {
+            remove_file(oldest_clocks_path).await?;
         }
+
         Ok(())
     }
+
+    fn newest_clocks_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("newest_clocks.json")
+    }
+
+    fn oldest_clocks_path(shard_path: &Path) -> PathBuf {
+        shard_path.join("oldest_clocks.json")
+    }
 }

commit a6817c54671d824943515ebfc79a40248d94d5b0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Mar 15 13:59:03 2024 +0100

    Fix optimizations config (#3832)
    
    * fix updating of the max_optimization_threads param
    
    * fix logic of the indexig optimizer
    
    * fmt
    
    * Update lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs [no-ci]
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * add test
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index bfcac678d..d065f9f00 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -587,6 +587,7 @@ impl LocalShard {
         );
         update_handler.optimizers = new_optimizers;
         update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;
+        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;
         update_handler.run_workers(update_receiver);
         self.update_sender.load().send(UpdateSignal::Nop).await?;
 

commit ec1e91aebb23d41b94fe11e9b5b01430c471494b
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Mar 15 17:38:49 2024 +0100

    Only flush clock maps to disk if they have changed (#3835)
    
    * Only flush clock maps to disk if they have changed
    
    * When loading from disk, we don't have new changes
    
    * With the serde helper, we don't care about the changed field
    
    * Rename store_changed to store_if_changed
    
    * Fix changed state in unit test
    
    * Only set clock map changed state if advancing a clock tag is accepted

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index d065f9f00..0bdf5326f 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -953,16 +953,16 @@ impl LocalShardClocks {
     }
 
     /// Persist clock maps to disk
-    pub async fn store(&self, shard_path: &Path) -> CollectionResult<()> {
+    pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {
         self.oldest_clocks
             .lock()
             .await
-            .store(&Self::oldest_clocks_path(shard_path))?;
+            .store_if_changed(&Self::oldest_clocks_path(shard_path))?;
 
         self.newest_clocks
             .lock()
             .await
-            .store(&Self::newest_clocks_path(shard_path))?;
+            .store_if_changed(&Self::newest_clocks_path(shard_path))?;
 
         Ok(())
     }

commit 647d7e9dec2fc2a9e6a82014a38663f3836a25fb
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 4 10:04:02 2024 +0200

    Add grey collection status (#3962)
    
    * Add grey color for collection info status
    
    * Restructure locks in local shard info method
    
    * Set collection status to grey if we have pending optimizations
    
    * Update OpenAPI specification and gRPC documentation
    
    * Set optimizer status instead of color for compatibility reasons
    
    * Only set and check for grey status if there are no other statuses

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0bdf5326f..0a7819f53 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -846,39 +846,55 @@ impl LocalShard {
 
     pub async fn local_shard_info(&self) -> CollectionInfoInternal {
         let collection_config = self.collection_config.read().await.clone();
-        let segments = self.segments().read();
         let mut vectors_count = 0;
         let mut indexed_vectors_count = 0;
         let mut points_count = 0;
         let mut segments_count = 0;
         let mut status = CollectionStatus::Green;
         let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();
-        for (_idx, segment) in segments.iter() {
-            segments_count += 1;
+        let mut optimizer_status = OptimizersStatus::Ok;
+
+        {
+            let segments = self.segments().read();
+            for (_idx, segment) in segments.iter() {
+                segments_count += 1;
 
-            let segment_info = segment.get().read().info();
+                let segment_info = segment.get().read().info();
 
-            if segment_info.segment_type == SegmentType::Special {
-                status = CollectionStatus::Yellow;
+                if segment_info.segment_type == SegmentType::Special {
+                    status = CollectionStatus::Yellow;
+                }
+                vectors_count += segment_info.num_vectors;
+                indexed_vectors_count += segment_info.num_indexed_vectors;
+                points_count += segment_info.num_points;
+                for (key, val) in segment_info.index_schema {
+                    schema
+                        .entry(key)
+                        .and_modify(|entry| entry.points += val.points)
+                        .or_insert(val);
+                }
             }
-            vectors_count += segment_info.num_vectors;
-            indexed_vectors_count += segment_info.num_indexed_vectors;
-            points_count += segment_info.num_points;
-            for (key, val) in segment_info.index_schema {
-                schema
-                    .entry(key)
-                    .and_modify(|entry| entry.points += val.points)
-                    .or_insert(val);
+            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
+                status = CollectionStatus::Red;
+            }
+
+            if let Some(error) = &segments.optimizer_errors {
+                optimizer_status = OptimizersStatus::Error(error.to_string());
             }
-        }
-        if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
-            status = CollectionStatus::Red;
         }
 
-        let optimizer_status = match &segments.optimizer_errors {
-            None => OptimizersStatus::Ok,
-            Some(error) => OptimizersStatus::Error(error.to_string()),
-        };
+        // If still green while optimization conditions are triggered, mark as grey
+        if status == CollectionStatus::Green
+            && self.update_handler.lock().await.has_pending_optimizations()
+        {
+            // TODO(1.10): enable grey status in Qdrant 1.10+
+            // status = CollectionStatus::Grey;
+            if optimizer_status == OptimizersStatus::Ok {
+                optimizer_status = OptimizersStatus::Error(
+                    "optimizations pending, awaiting update operation".into(),
+                );
+            }
+        }
 
         CollectionInfoInternal {
             status,

commit 41c817c2a16f270dcab376e94b2ec0c5e7d8f149
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 4 10:52:59 2024 +0200

    Non-blocking snapshots (#3420)
    
    * Initial non-blocking snapshot implementation
    
    * Minor refactoring
    
    * Add some comments, improve log messages
    
    * Propagate proxy segment changes into wrapped segment when unproxying
    
    * Use upgradable read lock for propagating proxy segment changes
    
    * Extract proxy/unproxy functions for segments, better error handling
    
    * Don't stop early on error, always clean up proxied segments
    
    * Propagate proxy changes in two batches to minimize write locking
    
    * Use upgradable read lock when propagating proxy changes in two batches
    
    * Do not fall back to non-appendable segment configurations
    
    * Resolve remaining TODOs
    
    * Use LockedSegmentHolder type alias everywhere
    
    * Better state handling in method to proxy all segments
    
    * When proxying all segments, lock only after creating temporary segment
    
    * Pass actual proxied segments around to minimize segment holder locking
    
    * Propagate proxy segment changes to wrapped on drop, not to writable
    
    * Minor improvements
    
    * Fix proxy logic returning non-proxied segments
    
    * Share single segment holder lock and upgrade/downgrade it
    
    * Minor improvements
    
    * Make appendable segment check more efficient
    
    * Do not explicitly drop segments lock, it's not necessary
    
    * Add consensus test to assert data consistency while snapshotting
    
    * Fix incorrect documentation
    
    * Extract payload storage type decision logic to collection params function
    
    * Resolve TODO, we always expect to get a shard here
    
    * Only upgrade propagate to wrapped readers if lists are not empty
    
    * Set correct operation versions
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0a7819f53..8d32909c3 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -36,7 +36,9 @@ use wal::{Wal, WalOptions};
 use self::clock_map::{ClockMap, RecoveryPoint};
 use super::update_tracker::UpdateTracker;
 use crate::collection_manager::collection_updater::CollectionUpdater;
-use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
+use crate::collection_manager::holders::segment_holder::{
+    LockedSegment, LockedSegmentHolder, SegmentHolder,
+};
 use crate::collection_manager::optimizers::TrackerLog;
 use crate::common::file_utils::{move_dir, move_file};
 use crate::config::CollectionConfig;
@@ -64,7 +66,7 @@ const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);
 ///
 /// Holds all object, required for collection functioning
 pub struct LocalShard {
-    pub(super) segments: Arc<RwLock<SegmentHolder>>,
+    pub(super) segments: LockedSegmentHolder,
     pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
     pub(super) shared_storage_config: Arc<SharedStorageConfig>,
     pub(super) wal: RecoverableWal,
@@ -657,13 +659,21 @@ impl LocalShard {
             rx.await?;
         }
 
+        let collection_path = self.path.parent().map(Path::to_path_buf).ok_or_else(|| {
+            CollectionError::service_error("Failed to determine collection path for shard")
+        })?;
+        let collection_params = self.collection_config.read().await.params.clone();
         let temp_path = temp_path.to_owned();
 
         tokio::task::spawn_blocking(move || {
-            let segments_read = segments.read();
-
             // Do not change segments while snapshotting
-            segments_read.snapshot_all_segments(&temp_path, &snapshot_segments_shard_path)?;
+            SegmentHolder::snapshot_all_segments(
+                segments.clone(),
+                &collection_path,
+                Some(&collection_params),
+                &temp_path,
+                &snapshot_segments_shard_path,
+            )?;
 
             if save_wal {
                 // snapshot all shard's WAL

commit 42e8db910e296fafca3d026cfe95703b6d5b8a69
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Apr 10 16:09:21 2024 +0200

    Use idiomatic Rust naming (#4007)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 8d32909c3..87344f661 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -394,8 +394,8 @@ impl LocalShard {
         let mut segment_holder = SegmentHolder::default();
         let mut build_handlers = vec![];
 
-        let vector_params = config.params.into_base_vector_data()?;
-        let sparse_vector_params = config.params.into_sparse_vector_data()?;
+        let vector_params = config.params.to_base_vector_data()?;
+        let sparse_vector_params = config.params.to_sparse_vector_data()?;
         let segment_number = config.optimizer_config.get_number_segments();
 
         for _sid in 0..segment_number {

commit a40b8ed94b283b5af9c462999b6afeaa879cfa4a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 15 11:37:48 2024 +0200

    Missing points and flush (#4034)
    
    * propose fix for missing points problem
    
    * fmt

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 87344f661..e0535fa57 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -212,12 +212,18 @@ impl LocalShard {
 
         let mut load_handlers = vec![];
 
+        // This semaphore is used to limit the number of threads that load segments concurrently.
+        // Uncomment it if you need to debug segment loading.
+        // let semaphore = Arc::new(parking_lot::Mutex::new(()));
+
         for entry in segment_dirs {
             let segments_path = entry.unwrap().path();
+            // let semaphore_clone = semaphore.clone();
             load_handlers.push(
                 thread::Builder::new()
                     .name(format!("shard-load-{collection_id}-{id}"))
                     .spawn(move || {
+                        // let _guard = semaphore_clone.lock();
                         let mut res = load_segment(&segments_path, &AtomicBool::new(false))?;
                         if let Some(segment) = &mut res {
                             segment.check_consistency_and_repair()?;
@@ -287,7 +293,7 @@ impl LocalShard {
 
         let clocks = LocalShardClocks::load(shard_path)?;
 
-        let collection = LocalShard::new(
+        let local_shard = LocalShard::new(
             segment_holder,
             collection_config,
             shared_storage_config,
@@ -300,10 +306,10 @@ impl LocalShard {
         )
         .await;
 
-        collection.load_from_wal(collection_id).await?;
+        local_shard.load_from_wal(collection_id).await?;
 
         let available_memory_bytes = Mem::new().available_memory_bytes() as usize;
-        let vectors_size_bytes = collection.estimate_vector_data_size().await;
+        let vectors_size_bytes = local_shard.estimate_vector_data_size().await;
 
         // Simple heuristic to exclude mmap prefaulting for collections that won't benefit from it.
         //
@@ -316,14 +322,14 @@ impl LocalShard {
         let do_mmap_prefault = available_memory_bytes * 2 > vectors_size_bytes;
 
         if do_mmap_prefault {
-            for (_, segment) in collection.segments.read().iter() {
+            for (_, segment) in local_shard.segments.read().iter() {
                 if let LockedSegment::Original(segment) = segment {
                     segment.read().prefault_mmap_pages();
                 }
             }
         }
 
-        Ok(collection)
+        Ok(local_shard)
     }
 
     pub fn shard_path(&self) -> PathBuf {

commit 9edc17dffd3ac533a0b0377153eecdc2614fbd49
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Apr 22 13:42:30 2024 +0200

    When reading with a filter, go over non-appendable segments first (#4084)
    
    * When reading with a filter, go over non-appendable segments first
    
    * Use existing iterator, shortcutting on empty is not necessary

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index e0535fa57..7b1ddfb3d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -777,14 +777,9 @@ impl LocalShard {
         filter: Option<&'a Filter>,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
         let segments = self.segments().read();
-        let some_segment = segments.iter().next();
-
-        if some_segment.is_none() {
-            return Ok(Default::default());
-        }
         let all_points: BTreeSet<_> = segments
-            .iter()
-            .flat_map(|(_id, segment)| segment.get().read().read_filtered(None, None, filter))
+            .non_appendable_then_appendable_segments()
+            .flat_map(|segment| segment.get().read().read_filtered(None, None, filter))
             .collect();
         Ok(all_points)
     }

commit f43d9813b6de9a1f6d9833e8627b54ec4861742b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu May 2 16:54:39 2024 +0200

    Clean-up unversioned points (#4156)
    
    * allow unversioned points in optimized (with warning) + remove unversioned points after WAL recovery
    
    * Change unwrap with debug statement to match
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 7b1ddfb3d..3e9886894 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -561,7 +561,24 @@ impl LocalShard {
             }
         }
 
-        self.segments.read().flush_all(true)?;
+        {
+            let segments = self.segments.read();
+
+            // It is possible, that after recovery, if WAL flush was not enforced.
+            // We could be left with some un-versioned points.
+            // To maintain consistency, we can either remove them or try to recover.
+            for (_idx, segment) in segments.iter() {
+                match segment {
+                    LockedSegment::Original(raw_segment) => {
+                        raw_segment.write().cleanup_versions()?;
+                    }
+                    LockedSegment::Proxy(_) => {
+                        debug_assert!(false, "Proxy segment found in load_from_wal");
+                    }
+                }
+            }
+            segments.flush_all(true)?;
+        }
 
         bar.finish();
         if !show_progress_bar {

commit 96ca9039aafdb93158111ca7e5f0f696187ce1aa
Author: Kenshin Tanaka <70839560+kemkemG0@users.noreply.github.com>
Date:   Mon May 13 18:36:56 2024 +0900

    Handle Out-Of-Disk gracefully  (#4165)
    
    * tests: Add test on low disk
    
    * Remove redundant assertion
    
    * keep container after failure and print latest logs in console
    
    * Add fs2 crate as a dependency and ensure sufficient disk space in LocalShard operations
    
    * small fix
    
    * Update test
    
    * small fix
    
    * use available_space
    
    * Use `fs2` -> `fs4` and offload sync IO with `tokio::task::spawn_blocking`
    
    * create DiskUsageWathcer
    
    * chore: Remove unnecessary println statement in update_handler.rs
    
    * chore: Fix typo in DiskUsageWatcher struct name
    
    * chore: Refactor DiskUsageWatcher to improve disk usage tracking and update logic
    
    ---------
    
    Co-authored-by: tellet-q <elena.dubrovina@qdrant.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 3e9886894..2cb56c622 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,4 +1,5 @@
 pub mod clock_map;
+pub mod disk_usage_watcher;
 mod shard_ops;
 
 use std::collections::{BTreeSet, HashMap};
@@ -34,6 +35,7 @@ use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
 use wal::{Wal, WalOptions};
 
 use self::clock_map::{ClockMap, RecoveryPoint};
+use self::disk_usage_watcher::DiskUsageWatcher;
 use super::update_tracker::UpdateTracker;
 use crate::collection_manager::collection_updater::CollectionUpdater;
 use crate::collection_manager::holders::segment_holder::{
@@ -77,6 +79,7 @@ pub struct LocalShard {
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
     update_runtime: Handle,
+    pub(super) disk_usage_watcher: Arc<TokioRwLock<DiskUsageWatcher>>,
 }
 
 /// Shard holds information about segments and WAL.
@@ -140,6 +143,17 @@ impl LocalShard {
         let locked_wal = Arc::new(ParkingMutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
 
+        // default to 2x the WAL capacity
+        let disk_buffer_threshold_mb =
+            2 * (collection_config.read().await.wal_config.wal_capacity_mb);
+        let disk_usage_watcher = Arc::new(TokioRwLock::new(
+            disk_usage_watcher::DiskUsageWatcher::new(
+                shard_path.to_owned(),
+                disk_buffer_threshold_mb as u64,
+            )
+            .await,
+        ));
+
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
             optimizers.clone(),
@@ -152,6 +166,7 @@ impl LocalShard {
             config.optimizer_config.max_optimization_threads,
             clocks.clone(),
             shard_path.into(),
+            disk_usage_watcher.clone(),
         );
 
         let (update_sender, update_receiver) =
@@ -174,6 +189,7 @@ impl LocalShard {
             update_runtime,
             optimizers,
             optimizers_log,
+            disk_usage_watcher,
         }
     }
 

commit 8d59fb783abfff0c8578dd12521b34c799ef9ad5
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon May 13 12:04:36 2024 -0400

    universal-query: Sketch request types pipeline (#4198)
    
    * sketch types pipeline
    
    * separate query, scroll, and search implementations into own files

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 2cb56c622..f9d82ce11 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,6 +1,9 @@
 pub mod clock_map;
 pub mod disk_usage_watcher;
-mod shard_ops;
+pub(super) mod query;
+pub(super) mod scroll;
+pub(super) mod search;
+pub(super) mod shard_ops;
 
 use std::collections::{BTreeSet, HashMap};
 use std::mem::size_of;

commit 9a70b90cb6adcf5e1c3e9ed8b64eaf71a17785aa
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 13 21:21:47 2024 +0200

    refactor disk usage checks (#4222)
    
    * refactor disk usage checks
    
    * review fix
    
    * fix logic here and there

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index f9d82ce11..20594e563 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -82,7 +82,7 @@ pub struct LocalShard {
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
     update_runtime: Handle,
-    pub(super) disk_usage_watcher: Arc<TokioRwLock<DiskUsageWatcher>>,
+    disk_usage_watcher: DiskUsageWatcher,
 }
 
 /// Shard holds information about segments and WAL.
@@ -149,13 +149,12 @@ impl LocalShard {
         // default to 2x the WAL capacity
         let disk_buffer_threshold_mb =
             2 * (collection_config.read().await.wal_config.wal_capacity_mb);
-        let disk_usage_watcher = Arc::new(TokioRwLock::new(
-            disk_usage_watcher::DiskUsageWatcher::new(
-                shard_path.to_owned(),
-                disk_buffer_threshold_mb as u64,
-            )
-            .await,
-        ));
+
+        let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(
+            shard_path.to_owned(),
+            disk_buffer_threshold_mb,
+        )
+        .await;
 
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
@@ -169,7 +168,6 @@ impl LocalShard {
             config.optimizer_config.max_optimization_threads,
             clocks.clone(),
             shard_path.into(),
-            disk_usage_watcher.clone(),
         );
 
         let (update_sender, update_receiver) =

commit aad9db1fe9c5d22dce24e1de27a92a28f7453c8d
Author: Tim Visée <tim+github@visee.me>
Date:   Mon May 27 19:03:02 2024 +0200

    Fix missing segments, use correct path for new segment created during snapshot (#4332)
    
    * Put temporary segment in correct path
    
    * Use shard directory rather than collection directory in test
    
    * Fix collection path getter, it actually returns segments path
    
    * Use segments path for temporary segment
    
    * The build segment function actually wants the segments path
    
    * Refactor parameter name

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 20594e563..362ccc445 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -699,9 +699,7 @@ impl LocalShard {
             rx.await?;
         }
 
-        let collection_path = self.path.parent().map(Path::to_path_buf).ok_or_else(|| {
-            CollectionError::service_error("Failed to determine collection path for shard")
-        })?;
+        let segments_path = Self::segments_path(&self.path);
         let collection_params = self.collection_config.read().await.params.clone();
         let temp_path = temp_path.to_owned();
 
@@ -709,7 +707,7 @@ impl LocalShard {
             // Do not change segments while snapshotting
             SegmentHolder::snapshot_all_segments(
                 segments.clone(),
-                &collection_path,
+                &segments_path,
                 Some(&collection_params),
                 &temp_path,
                 &snapshot_segments_shard_path,

commit 8e6f8d4575a4613f7d863f76088b3096c9d7be77
Author: Tim Visée <tim+github@visee.me>
Date:   Tue May 28 13:31:54 2024 +0200

    On shard load, ensure we have any appendable segments (#4342)
    
    * Extract logic for creating temporary segment during segment proxying
    
    * Simplify check for having an appendable segment
    
    * Fix incorrect documentation
    
    * When loading shard, ensure we have any appendable segments or create one
    
    * Use correct parameter name
    
    * In debug builds, crash when there's no appendable segment on start

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 362ccc445..c5e24ce54 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -310,6 +310,18 @@ impl LocalShard {
 
         let clocks = LocalShardClocks::load(shard_path)?;
 
+        // Always make sure we have any appendable segments, needed for update operations
+        if !segment_holder.has_appendable_segment() {
+            debug_assert!(
+                false,
+                "Shard has no appendable segments, this should never happen",
+            );
+            log::warn!("Shard has no appendable segments, this should never happen. Creating new appendable segment now");
+            let segments_path = LocalShard::segments_path(shard_path);
+            let collection_params = collection_config.read().await.params.clone();
+            segment_holder.create_appendable_segment(&segments_path, &collection_params)?;
+        }
+
         let local_shard = LocalShard::new(
             segment_holder,
             collection_config,

commit afdfe1aa8034b63ab7a337c5d1911ccf299e5000
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu May 30 21:28:30 2024 +0200

    Add optional post WAL data consistency check (#4359)
    
    * Add optional post WAL data consistency check
    
    * fix multi features build

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index c5e24ce54..0f7a5896d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -335,6 +335,7 @@ impl LocalShard {
         )
         .await;
 
+        // Apply outstanding operations from WAL
         local_shard.load_from_wal(collection_id).await?;
 
         let available_memory_bytes = Mem::new().available_memory_bytes() as usize;
@@ -617,6 +618,39 @@ impl LocalShard {
             );
         }
 
+        // The storage is expected to be consistent after WAL recovery
+        #[cfg(feature = "data-consistency-check")]
+        self.check_data_consistency()?;
+
+        Ok(())
+    }
+
+    /// Check data consistency for all segments
+    ///
+    /// Returns an error at the first inconsistent segment
+    pub fn check_data_consistency(&self) -> CollectionResult<()> {
+        log::info!("Checking data consistency for shard {:?}", self.path);
+        let segments = self.segments.read();
+        for (_idx, segment) in segments.iter() {
+            match segment {
+                LockedSegment::Original(raw_segment) => {
+                    let segment_guard = raw_segment.read();
+                    if let Err(err) = segment_guard.check_data_consistency() {
+                        log::error!(
+                            "Segment {:?} is inconsistent: {}",
+                            segment_guard.current_path,
+                            err
+                        );
+                        return Err(err.into());
+                    }
+                }
+                LockedSegment::Proxy(_) => {
+                    return Err(CollectionError::service_error(
+                        "Proxy segment found in check_data_consistency",
+                    ));
+                }
+            }
+        }
         Ok(())
     }
 

commit f7a7e6ff128b7134e0cdf9804494981a7880ccee
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri May 31 09:02:44 2024 +0200

    Add optimizer_overwrite config option (#4317)
    
    * add config option
    
    * add optimizers_config to optimizer calls
    
    * also add for tests
    
    * add to build_optimizers
    
    * rename function parameter

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0f7a5896d..c5f9698dd 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -53,7 +53,7 @@ use crate::operations::types::{
     CollectionResult, CollectionStatus, OptimizersStatus,
 };
 use crate::operations::OperationWithClockTag;
-use crate::optimizers_builder::{build_optimizers, clear_temp_segments};
+use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
 use crate::shards::shard::ShardId;
 use crate::shards::shard_config::{ShardConfig, SHARD_CONFIG_FILE};
 use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
@@ -199,11 +199,13 @@ impl LocalShard {
     }
 
     /// Recovers shard from disk.
+    #[allow(clippy::too_many_arguments)]
     pub async fn load(
         id: ShardId,
         collection_id: CollectionId,
         shard_path: &Path,
         collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        effective_optimizers_config: OptimizersConfig,
         shared_storage_config: Arc<SharedStorageConfig>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
@@ -301,7 +303,7 @@ impl LocalShard {
         let optimizers = build_optimizers(
             shard_path,
             &collection_config_read.params,
-            &collection_config_read.optimizer_config,
+            &effective_optimizers_config,
             &collection_config_read.hnsw_config,
             &collection_config_read.quantization_config,
         );
@@ -374,6 +376,7 @@ impl LocalShard {
         shard_path.join("segments")
     }
 
+    #[allow(clippy::too_many_arguments)]
     pub async fn build_local(
         id: ShardId,
         collection_id: CollectionId,
@@ -382,6 +385,7 @@ impl LocalShard {
         shared_storage_config: Arc<SharedStorageConfig>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
+        effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
         // initialize local shard config file
         let local_shard_config = ShardConfig::new_replica_set();
@@ -393,6 +397,7 @@ impl LocalShard {
             shared_storage_config,
             update_runtime,
             optimizer_cpu_budget,
+            effective_optimizers_config,
         )
         .await?;
         local_shard_config.save(shard_path)?;
@@ -400,6 +405,7 @@ impl LocalShard {
     }
 
     /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.
+    #[allow(clippy::too_many_arguments)]
     pub async fn build(
         id: ShardId,
         collection_id: CollectionId,
@@ -408,6 +414,7 @@ impl LocalShard {
         shared_storage_config: Arc<SharedStorageConfig>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
+        effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
         let config = collection_config.read().await;
 
@@ -476,7 +483,7 @@ impl LocalShard {
         let optimizers = build_optimizers(
             shard_path,
             &config.params,
-            &config.optimizer_config,
+            &effective_optimizers_config,
             &config.hnsw_config,
             &config.quantization_config,
         );

commit a7f2e7a3c9861c90630917b96e5f59db70cedbe5
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Jun 6 20:11:00 2024 +0200

    Fix deadlock caused by concurrent snapshot and optimization (#4402)
    
    * Rename segment addition functions, clarify this generates a new ID
    
    * Don't randomize segment IDs, auto increment to prevent duplicates
    
    * Rename swap to swap_new
    
    * On snapshot unproxy, put segments back with their original segment ID
    
    * Add sanity check to optimizer unproxy, must swap same number of segments
    
    * Clean up
    
    * Extend snapshot test, assert we end up with the same segment IDs

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index c5f9698dd..5b112fa9b 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -291,7 +291,7 @@ impl LocalShard {
                 })
                 .unwrap_or(Ok(()))?;
 
-            segment_holder.add(segment);
+            segment_holder.add_new(segment);
         }
 
         let res = segment_holder.deduplicate_points()?;
@@ -474,7 +474,7 @@ impl LocalShard {
                 ))
             })??;
 
-            segment_holder.add(segment);
+            segment_holder.add_new(segment);
         }
 
         let wal: SerdeWal<OperationWithClockTag> =

commit 63b2801e4fe25fea190e5a4069d6a1d3702a4661
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Jun 21 20:01:05 2024 +0200

    Fix new appendable segments not having payload indices (#4523)
    
    * Propagate payload index schema down to shard replica set + update handler
    
    * Configure payload indices when creating new appendable segment
    
    * When loading segments, make sure applied payload indices match config
    
    * Add test to assert creating new segments with payload index
    
    * Fix unit test because the collection payload schema wasn't updated
    
    * Add test for updating payload index configuration on segment load
    
    * Update test documentation
    
    * Also create payload indices in temporary snapshot segment
    
    * do not delete extra payload index from segments
    
    * do not delete extra payload index from segments
    
    * fix test
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 5b112fa9b..249ec0210 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -40,6 +40,7 @@ use wal::{Wal, WalOptions};
 use self::clock_map::{ClockMap, RecoveryPoint};
 use self::disk_usage_watcher::DiskUsageWatcher;
 use super::update_tracker::UpdateTracker;
+use crate::collection::payload_index_schema::PayloadIndexSchema;
 use crate::collection_manager::collection_updater::CollectionUpdater;
 use crate::collection_manager::holders::segment_holder::{
     LockedSegment, LockedSegmentHolder, SegmentHolder,
@@ -54,6 +55,7 @@ use crate::operations::types::{
 };
 use crate::operations::OperationWithClockTag;
 use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
+use crate::save_on_disk::SaveOnDisk;
 use crate::shards::shard::ShardId;
 use crate::shards::shard_config::{ShardConfig, SHARD_CONFIG_FILE};
 use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
@@ -74,6 +76,7 @@ pub struct LocalShard {
     pub(super) segments: LockedSegmentHolder,
     pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
     pub(super) shared_storage_config: Arc<SharedStorageConfig>,
+    payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
     pub(super) wal: RecoverableWal,
     pub(super) update_handler: Arc<Mutex<UpdateHandler>>,
     pub(super) update_sender: ArcSwap<Sender<UpdateSignal>>,
@@ -134,6 +137,7 @@ impl LocalShard {
         segment_holder: SegmentHolder,
         collection_config: Arc<TokioRwLock<CollectionConfig>>,
         shared_storage_config: Arc<SharedStorageConfig>,
+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         wal: SerdeWal<OperationWithClockTag>,
         optimizers: Arc<Vec<Arc<Optimizer>>>,
         optimizer_cpu_budget: CpuBudget,
@@ -158,6 +162,7 @@ impl LocalShard {
 
         let mut update_handler = UpdateHandler::new(
             shared_storage_config.clone(),
+            payload_index_schema.clone(),
             optimizers.clone(),
             optimizers_log.clone(),
             optimizer_cpu_budget.clone(),
@@ -182,6 +187,7 @@ impl LocalShard {
             segments: segment_holder,
             collection_config,
             shared_storage_config,
+            payload_index_schema,
             wal: RecoverableWal::new(locked_wal, clocks.newest_clocks, clocks.oldest_clocks),
             update_handler: Arc::new(Mutex::new(update_handler)),
             update_sender: ArcSwap::from_pointee(update_sender),
@@ -207,6 +213,7 @@ impl LocalShard {
         collection_config: Arc<TokioRwLock<CollectionConfig>>,
         effective_optimizers_config: OptimizersConfig,
         shared_storage_config: Arc<SharedStorageConfig>,
+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
     ) -> CollectionResult<LocalShard> {
@@ -237,6 +244,7 @@ impl LocalShard {
 
         for entry in segment_dirs {
             let segments_path = entry.unwrap().path();
+            let payload_index_schema = payload_index_schema.clone();
             // let semaphore_clone = semaphore.clone();
             load_handlers.push(
                 thread::Builder::new()
@@ -246,12 +254,14 @@ impl LocalShard {
                         let mut res = load_segment(&segments_path, &AtomicBool::new(false))?;
                         if let Some(segment) = &mut res {
                             segment.check_consistency_and_repair()?;
+                            segment.update_all_field_indices(
+                                &payload_index_schema.read().schema.clone(),
+                            )?;
                         } else {
                             std::fs::remove_dir_all(&segments_path).map_err(|err| {
                                 CollectionError::service_error(format!(
-                                    "Can't remove leftover segment {}, due to {}",
+                                    "Can't remove leftover segment {}, due to {err}",
                                     segments_path.to_str().unwrap(),
-                                    err
                                 ))
                             })?;
                         }
@@ -321,13 +331,19 @@ impl LocalShard {
             log::warn!("Shard has no appendable segments, this should never happen. Creating new appendable segment now");
             let segments_path = LocalShard::segments_path(shard_path);
             let collection_params = collection_config.read().await.params.clone();
-            segment_holder.create_appendable_segment(&segments_path, &collection_params)?;
+            let payload_index_schema = payload_index_schema.read();
+            segment_holder.create_appendable_segment(
+                &segments_path,
+                &collection_params,
+                &payload_index_schema,
+            )?;
         }
 
         let local_shard = LocalShard::new(
             segment_holder,
             collection_config,
             shared_storage_config,
+            payload_index_schema,
             wal,
             optimizers,
             optimizer_cpu_budget,
@@ -383,6 +399,7 @@ impl LocalShard {
         shard_path: &Path,
         collection_config: Arc<TokioRwLock<CollectionConfig>>,
         shared_storage_config: Arc<SharedStorageConfig>,
+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
         effective_optimizers_config: OptimizersConfig,
@@ -395,6 +412,7 @@ impl LocalShard {
             shard_path,
             collection_config,
             shared_storage_config,
+            payload_index_schema,
             update_runtime,
             optimizer_cpu_budget,
             effective_optimizers_config,
@@ -412,6 +430,7 @@ impl LocalShard {
         shard_path: &Path,
         collection_config: Arc<TokioRwLock<CollectionConfig>>,
         shared_storage_config: Arc<SharedStorageConfig>,
+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
         effective_optimizers_config: OptimizersConfig,
@@ -494,6 +513,7 @@ impl LocalShard {
             segment_holder,
             collection_config,
             shared_storage_config,
+            payload_index_schema,
             wal,
             optimizers,
             optimizer_cpu_budget,
@@ -755,6 +775,7 @@ impl LocalShard {
         let segments_path = Self::segments_path(&self.path);
         let collection_params = self.collection_config.read().await.params.clone();
         let temp_path = temp_path.to_owned();
+        let payload_index_schema = self.payload_index_schema.clone();
 
         tokio::task::spawn_blocking(move || {
             // Do not change segments while snapshotting
@@ -762,6 +783,7 @@ impl LocalShard {
                 segments.clone(),
                 &segments_path,
                 Some(&collection_params),
+                &payload_index_schema.read().clone(),
                 &temp_path,
                 &snapshot_segments_shard_path,
             )?;

commit 40830a1729f176a8691022e47119ad5dce2d1a54
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Jul 8 15:58:19 2024 +0200

    Merge pull request #4620
    
    * Add `force` flag to `SegmentEntry::flush` and `ShardHolder::flush_all…

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 249ec0210..85a1b354d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -634,7 +634,11 @@ impl LocalShard {
                     }
                 }
             }
-            segments.flush_all(true)?;
+
+            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data
+            // consistency, if we happened to only apply *past* operations to a segment with newer
+            // version.
+            segments.flush_all(true, true)?;
         }
 
         bar.finish();

commit cf3a18afa2576759b634e65b983e53ac1384ec5a
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Aug 1 13:09:37 2024 -0400

    Facets in local shard (#4785)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 85a1b354d..3a1f3787d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,5 +1,6 @@
 pub mod clock_map;
 pub mod disk_usage_watcher;
+pub(super) mod facet;
 pub(super) mod query;
 pub(super) mod scroll;
 pub(super) mod search;

commit 10b05c3ed84024f4aeaad5e97e24bd0b0ec421d2
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Aug 5 19:05:45 2024 +0200

    Make scroll cancellable (#4827)
    
    * Make scroll cancellable
    
    * comments and fix
    
    * better comment

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 3a1f3787d..379040a53 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -889,9 +889,15 @@ impl LocalShard {
         filter: Option<&'a Filter>,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
         let segments = self.segments().read();
+        let is_stopped = AtomicBool::new(false);
         let all_points: BTreeSet<_> = segments
             .non_appendable_then_appendable_segments()
-            .flat_map(|segment| segment.get().read().read_filtered(None, None, filter))
+            .flat_map(|segment| {
+                segment
+                    .get()
+                    .read()
+                    .read_filtered(None, None, filter, &is_stopped)
+            })
             .collect();
         Ok(all_points)
     }

commit c7da6ae36c455a67859dbc2a9f1e3ce274645121
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Aug 8 12:41:33 2024 +0200

    Non blocking retrieve with timeout and cancellation support (#4844)
    
    * Non blocking retrieve with timeout and cancellation support
    
    * apply timeout for extra retrieve in rescoring

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 379040a53..0e4b79cae 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -86,6 +86,7 @@ pub struct LocalShard {
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
     update_runtime: Handle,
+    search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
 }
 
@@ -145,6 +146,7 @@ impl LocalShard {
         shard_path: &Path,
         clocks: LocalShardClocks,
         update_runtime: Handle,
+        search_runtime: Handle,
     ) -> Self {
         let segment_holder = Arc::new(RwLock::new(segment_holder));
         let config = collection_config.read().await;
@@ -195,6 +197,7 @@ impl LocalShard {
             update_tracker,
             path: shard_path.to_owned(),
             update_runtime,
+            search_runtime,
             optimizers,
             optimizers_log,
             disk_usage_watcher,
@@ -216,6 +219,7 @@ impl LocalShard {
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
+        search_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
     ) -> CollectionResult<LocalShard> {
         let collection_config_read = collection_config.read().await;
@@ -351,6 +355,7 @@ impl LocalShard {
             shard_path,
             clocks,
             update_runtime,
+            search_runtime,
         )
         .await;
 
@@ -402,6 +407,7 @@ impl LocalShard {
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
+        search_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
         effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
@@ -415,6 +421,7 @@ impl LocalShard {
             shared_storage_config,
             payload_index_schema,
             update_runtime,
+            search_runtime,
             optimizer_cpu_budget,
             effective_optimizers_config,
         )
@@ -433,6 +440,7 @@ impl LocalShard {
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
+        search_runtime: Handle,
         optimizer_cpu_budget: CpuBudget,
         effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
@@ -521,6 +529,7 @@ impl LocalShard {
             shard_path,
             LocalShardClocks::default(),
             update_runtime,
+            search_runtime,
         )
         .await;
 

commit 8030504514e0a3cbc89e8f7e85c99ed9fc0936d9
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Aug 8 14:47:51 2024 +0200

    Non blocking exact count with timeout and cancellation support (#4849)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0e4b79cae..143388b17 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -47,6 +47,7 @@ use crate::collection_manager::holders::segment_holder::{
     LockedSegment, LockedSegmentHolder, SegmentHolder,
 };
 use crate::collection_manager::optimizers::TrackerLog;
+use crate::collection_manager::segments_searcher::SegmentsSearcher;
 use crate::common::file_utils::{move_dir, move_file};
 use crate::config::CollectionConfig;
 use crate::operations::shared_storage_config::SharedStorageConfig;
@@ -86,7 +87,7 @@ pub struct LocalShard {
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
     update_runtime: Handle,
-    search_runtime: Handle,
+    pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
 }
 
@@ -874,11 +875,6 @@ impl LocalShard {
         filter: Option<&'a Filter>,
     ) -> CollectionResult<CardinalityEstimation> {
         let segments = self.segments().read();
-        let some_segment = segments.iter().next();
-
-        if some_segment.is_none() {
-            return Ok(CardinalityEstimation::exact(0));
-        }
         let cardinality = segments
             .iter()
             .map(|(_id, segment)| segment.get().read().estimate_point_count(filter))
@@ -893,22 +889,13 @@ impl LocalShard {
         Ok(cardinality)
     }
 
-    pub fn read_filtered<'a>(
+    pub async fn read_filtered<'a>(
         &'a self,
         filter: Option<&'a Filter>,
+        runtime_handle: &Handle,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
-        let segments = self.segments().read();
-        let is_stopped = AtomicBool::new(false);
-        let all_points: BTreeSet<_> = segments
-            .non_appendable_then_appendable_segments()
-            .flat_map(|segment| {
-                segment
-                    .get()
-                    .read()
-                    .read_filtered(None, None, filter, &is_stopped)
-            })
-            .collect();
-        Ok(all_points)
+        let segments = self.segments.clone();
+        SegmentsSearcher::read_filtered(segments, filter, runtime_handle).await
     }
 
     pub fn get_telemetry_data(&self, detail: TelemetryDetail) -> LocalShardTelemetry {

commit 3377530c6263ec3c723b16c0fefec712406ddfdd
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Aug 29 10:49:23 2024 +0200

    [Strict-Mode] Basic implementation (#4887)
    
    * add CollectionRequestVerification
    
    * add to api
    
    * rebase
    
    * improve implementation
    
    * implement strict mode for SearchRequest+Batch
    
    * improve code + fix Clippy
    
    * improve error handling
    
    * restructure StrictModeVerification trait
    
    * generate docs
    
    * check `enabled` option
    
    * review remarks
    
    * rename StrictModeConfigDiff in grpc
    
    * use missing payload detection from issue api
    
    * performance improvement
    
    * decouple extractor from issues (#4945)
    
    * some review remarks
    
    * don't default to empty functions in StrictModeVerification trait
    
    * update openapi
    
    * filter_limit => query_limit
    
    * replace discovery_max_context_size and recommend_max_examples with max_input_examples
    
    * review remarks
    
    * review fix: include possible index types into error message
    
    * review remarks
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 143388b17..6fb9a1003 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -78,7 +78,7 @@ pub struct LocalShard {
     pub(super) segments: LockedSegmentHolder,
     pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
     pub(super) shared_storage_config: Arc<SharedStorageConfig>,
-    payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
+    pub(crate) payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
     pub(super) wal: RecoverableWal,
     pub(super) update_handler: Arc<Mutex<UpdateHandler>>,
     pub(super) update_sender: ArcSwap<Sender<UpdateSignal>>,

commit d5174d8d60829c9cf99f92e15c0276b552a7d62f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Sep 2 12:34:26 2024 +0000

    Don't save shard config in `LocalShard::create_snapshot` (#4997)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 6fb9a1003..17a6854ba 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -59,7 +59,7 @@ use crate::operations::OperationWithClockTag;
 use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
 use crate::save_on_disk::SaveOnDisk;
 use crate::shards::shard::ShardId;
-use crate::shards::shard_config::{ShardConfig, SHARD_CONFIG_FILE};
+use crate::shards::shard_config::ShardConfig;
 use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
 use crate::shards::CollectionId;
 use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
@@ -814,11 +814,6 @@ impl LocalShard {
 
         LocalShardClocks::copy_data(&self.path, snapshot_shard_path).await?;
 
-        // copy shard's config
-        let shard_config_path = ShardConfig::get_config_path(&self.path);
-        let target_shard_config_path = snapshot_shard_path.join(SHARD_CONFIG_FILE);
-        copy(&shard_config_path, &target_shard_config_path).await?;
-
         Ok(())
     }
 

commit 35682861325ad345058ef3e33e74cba7afba33d3
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Thu Sep 5 13:08:39 2024 +0530

    Introduce grey collection status and expose shard status in telemetry (#4940)
    
    * Expose shard status in telemetry API
    
    * fmt
    
    * Drop segment lock before using async fetching shard status
    
    * Use Self in From implementation for ShardStatus to CollectionStatus mapping
    
    * Improve comments
    
    * Remove redundant clone
    
    * Update openapi specs
    
    * Isolate function for shard status
    
    * Fix compiler error
    
    * Avoid adding dedicated function for shard status
    
    * review fixes
    
    * define missing var
    
    * lint err
    
    * comment
    
    * comment
    
    * refactor
    
    * improve comments
    
    * Improve comments
    
    * fix lint and update openapi specs
    
    * improve comment

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 17a6854ba..9e5ae7fa1 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -52,8 +52,8 @@ use crate::common::file_utils::{move_dir, move_file};
 use crate::config::CollectionConfig;
 use crate::operations::shared_storage_config::SharedStorageConfig;
 use crate::operations::types::{
-    check_sparse_compatible_with_segment_config, CollectionError, CollectionInfoInternal,
-    CollectionResult, CollectionStatus, OptimizersStatus,
+    check_sparse_compatible_with_segment_config, CollectionError, CollectionResult,
+    OptimizersStatus, ShardInfoInternal, ShardStatus,
 };
 use crate::operations::OperationWithClockTag;
 use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
@@ -918,6 +918,7 @@ impl LocalShard {
 
         LocalShardTelemetry {
             variant_name: None,
+            status: None,
             segments,
             optimizations: OptimizerTelemetry {
                 status: optimizer_status,
@@ -964,15 +965,53 @@ impl LocalShard {
         vector_size * info.points_count
     }
 
-    pub async fn local_shard_info(&self) -> CollectionInfoInternal {
+    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {
+        let mut status = ShardStatus::Green;
+        let mut optimizer_status = OptimizersStatus::Ok;
+
+        {
+            let segments = self.segments().read();
+
+            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
+                status = ShardStatus::Red;
+
+                if let Some(error) = &segments.optimizer_errors {
+                    optimizer_status = OptimizersStatus::Error(error.to_string());
+                }
+            } else {
+                let has_special_segments = segments
+                    .iter()
+                    .map(|(_, segment)| segment.get().read().info().segment_type)
+                    .any(|segment_type| segment_type == SegmentType::Special);
+
+                // Special segment means it's a proxy segment and is being optimized, mark as yellow
+                // ToDo: snapshotting also creates temp proxy segments. should differentiate.
+                if has_special_segments {
+                    status = ShardStatus::Yellow;
+                }
+            }
+        }
+
+        // If status looks green/ok but optimizations can be triggered, mark as grey
+        if status == ShardStatus::Green
+            && optimizer_status == OptimizersStatus::Ok
+            && self.update_handler.lock().await.has_non_optimal_segments()
+        {
+            // This can happen when a node is restarted (crashed), because we don't
+            // automatically trigger optimizations on restart to avoid a crash loop
+            status = ShardStatus::Grey;
+        }
+
+        (status, optimizer_status)
+    }
+
+    pub async fn local_shard_info(&self) -> ShardInfoInternal {
         let collection_config = self.collection_config.read().await.clone();
         let mut vectors_count = 0;
         let mut indexed_vectors_count = 0;
         let mut points_count = 0;
         let mut segments_count = 0;
-        let mut status = CollectionStatus::Green;
         let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();
-        let mut optimizer_status = OptimizersStatus::Ok;
 
         {
             let segments = self.segments().read();
@@ -981,9 +1020,6 @@ impl LocalShard {
 
                 let segment_info = segment.get().read().info();
 
-                if segment_info.segment_type == SegmentType::Special {
-                    status = CollectionStatus::Yellow;
-                }
                 vectors_count += segment_info.num_vectors;
                 indexed_vectors_count += segment_info.num_indexed_vectors;
                 points_count += segment_info.num_points;
@@ -994,29 +1030,11 @@ impl LocalShard {
                         .or_insert(val);
                 }
             }
-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
-                status = CollectionStatus::Red;
-            }
-
-            if let Some(error) = &segments.optimizer_errors {
-                optimizer_status = OptimizersStatus::Error(error.to_string());
-            }
         }
 
-        // If still green while optimization conditions are triggered, mark as grey
-        if status == CollectionStatus::Green
-            && self.update_handler.lock().await.has_pending_optimizations()
-        {
-            // TODO(1.10): enable grey status in Qdrant 1.10+
-            // status = CollectionStatus::Grey;
-            if optimizer_status == OptimizersStatus::Ok {
-                optimizer_status = OptimizersStatus::Error(
-                    "optimizations pending, awaiting update operation".into(),
-                );
-            }
-        }
+        let (status, optimizer_status) = self.local_shard_status().await;
 
-        CollectionInfoInternal {
+        ShardInfoInternal {
             status,
             optimizer_status,
             vectors_count,

commit 8c365f27efca127c9dc95cc731b3ca6fec936611
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Mon Sep 9 14:37:51 2024 +0530

    Fix shard/collection status blinking (#5043)
    
    * Fix shard/collection status blinking
    
    * Improve var names
    
    * improve var names
    
    * Improve function docs

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 9e5ae7fa1..ebc24a4cc 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -992,14 +992,24 @@ impl LocalShard {
             }
         }
 
-        // If status looks green/ok but optimizations can be triggered, mark as grey
-        if status == ShardStatus::Green
-            && optimizer_status == OptimizersStatus::Ok
-            && self.update_handler.lock().await.has_non_optimal_segments()
-        {
-            // This can happen when a node is restarted (crashed), because we don't
-            // automatically trigger optimizations on restart to avoid a crash loop
-            status = ShardStatus::Grey;
+        // If status looks green/ok but some optimizations are suboptimal
+        if status == ShardStatus::Green && optimizer_status == OptimizersStatus::Ok {
+            let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self
+                .update_handler
+                .lock()
+                .await
+                .check_optimizer_conditions();
+
+            if has_suboptimal_optimizers {
+                // Check if any optimizations were triggered after starting the node
+                if has_triggered_any_optimizers {
+                    status = ShardStatus::Yellow;
+                } else {
+                    // This can happen when a node is restarted (crashed), because we don't
+                    // automatically trigger optimizations on restart to avoid a crash loop
+                    status = ShardStatus::Grey;
+                }
+            }
         }
 
         (status, optimizer_status)

commit 70c46bbb6f49739acac3ee7ce55074029a40b5a1
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Tue Sep 10 16:52:38 2024 +0530

    Track number of points optimized and expose in telemetry (#5000)
    
    * Track number of points optimized and expose in telemetry
    
    * refactor
    
    * openapi specs
    
    * remove dbg
    
    * Return num points optimized from optimize() func
    
    * fmt
    
    * fix
    
    * fix type in tests
    
    * Store total points indexed on shard level instead of optimization level
    
    * fmt
    
    * fix test
    
    * trigger ci
    
    * fix openapi schema
    
    * review fixes
    
    * fmt
    
    * improvements and fix test
    
    * review fixes
    
    * use const for indexing optimizer name
    
    * fmt
    
    * return segment id from optimize() func
    
    * review fixes
    
    * fix
    
    * fix
    
    * fik
    
    * minor var name improvement
    
    * Use Option<usize> to return segment id
    
    * Use segment ID type rather than ambiguous usize
    
    * fix test
    
    * avoid intermediate check
    
    * review fixes
    
    * Rename total_indexed_points to total_optimized_points
    
    * Update openapi schema
    
    * optimize() should return number of points in new segment instead of segment id
    
    * add else condition
    
    * take read lock
    
    * fmt
    
    * remove flaky assert
    
    * Count points on new segment without locking
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index ebc24a4cc..3ab5a1e4e 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -10,7 +10,7 @@ use std::collections::{BTreeSet, HashMap};
 use std::mem::size_of;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
-use std::sync::atomic::AtomicBool;
+use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
 use std::sync::Arc;
 use std::thread;
 use std::time::{Duration, Instant};
@@ -86,6 +86,7 @@ pub struct LocalShard {
     pub(super) path: PathBuf,
     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,
     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,
+    pub(super) total_optimized_points: Arc<AtomicUsize>,
     update_runtime: Handle,
     pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
@@ -153,6 +154,7 @@ impl LocalShard {
         let config = collection_config.read().await;
         let locked_wal = Arc::new(ParkingMutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
+        let total_optimized_points = Arc::new(AtomicUsize::new(0));
 
         // default to 2x the WAL capacity
         let disk_buffer_threshold_mb =
@@ -169,6 +171,7 @@ impl LocalShard {
             payload_index_schema.clone(),
             optimizers.clone(),
             optimizers_log.clone(),
+            total_optimized_points.clone(),
             optimizer_cpu_budget.clone(),
             update_runtime.clone(),
             segment_holder.clone(),
@@ -201,6 +204,7 @@ impl LocalShard {
             search_runtime,
             optimizers,
             optimizers_log,
+            total_optimized_points,
             disk_usage_watcher,
         }
     }
@@ -916,9 +920,12 @@ impl LocalShard {
             })
             .fold(Default::default(), |acc, x| acc + x);
 
+        let total_optimized_points = self.total_optimized_points.load(Ordering::Relaxed);
+
         LocalShardTelemetry {
             variant_name: None,
             status: None,
+            total_optimized_points,
             segments,
             optimizations: OptimizerTelemetry {
                 status: optimizer_status,

commit 2a6ab9d4fb6d17f35d58a5ff6a4f1e92b2defd83
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Sep 12 19:39:15 2024 +0000

    Direct snapshot creation (#5061)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 3ab5a1e4e..64e1cda58 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -17,8 +17,8 @@ use std::time::{Duration, Instant};
 
 use arc_swap::ArcSwap;
 use common::cpu::CpuBudget;
-use common::panic;
 use common::types::TelemetryDetail;
+use common::{panic, tar_ext};
 use indicatif::{ProgressBar, ProgressStyle};
 use itertools::Itertools;
 use parking_lot::{Mutex as ParkingMutex, RwLock};
@@ -32,7 +32,7 @@ use segment::types::{
     QuantizationConfig, SegmentConfig, SegmentType,
 };
 use segment::utils::mem::Mem;
-use tokio::fs::{copy, create_dir_all, remove_dir_all, remove_file};
+use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
 use tokio::sync::mpsc::Sender;
 use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
@@ -69,6 +69,10 @@ use crate::wal_delta::{LockedWal, RecoverableWal};
 /// If rendering WAL load progression in basic text form, report progression every 60 seconds.
 const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);
 
+const WAL_PATH: &str = "wal";
+
+const SEGMENTS_PATH: &str = "segments";
+
 /// LocalShard
 ///
 /// LocalShard is an entity that can be moved between peers and contains some part of one collections data.
@@ -396,11 +400,11 @@ impl LocalShard {
     }
 
     pub fn wal_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("wal")
+        shard_path.join(WAL_PATH)
     }
 
     pub fn segments_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("segments")
+        shard_path.join(SEGMENTS_PATH)
     }
 
     #[allow(clippy::too_many_arguments)]
@@ -451,7 +455,7 @@ impl LocalShard {
     ) -> CollectionResult<LocalShard> {
         let config = collection_config.read().await;
 
-        let wal_path = shard_path.join("wal");
+        let wal_path = Self::wal_path(shard_path);
 
         create_dir_all(&wal_path).await.map_err(|err| {
             CollectionError::service_error(format!(
@@ -459,7 +463,7 @@ impl LocalShard {
             ))
         })?;
 
-        let segments_path = shard_path.join("segments");
+        let segments_path = Self::segments_path(shard_path);
 
         create_dir_all(&segments_path).await.map_err(|err| {
             CollectionError::service_error(format!(
@@ -768,18 +772,11 @@ impl LocalShard {
     pub async fn create_snapshot(
         &self,
         temp_path: &Path,
-        target_path: &Path,
+        tar: &tar_ext::BuilderExt,
         save_wal: bool,
     ) -> CollectionResult<()> {
-        let snapshot_shard_path = target_path;
-
-        // snapshot all shard's segment
-        let snapshot_segments_shard_path = snapshot_shard_path.join("segments");
-        create_dir_all(&snapshot_segments_shard_path).await?;
-
         let segments = self.segments.clone();
         let wal = self.wal.wal.clone();
-        let snapshot_shard_path_owned = snapshot_shard_path.to_owned();
 
         if !save_wal {
             // If we are not saving WAL, we still need to make sure that all submitted by this point
@@ -796,6 +793,7 @@ impl LocalShard {
         let temp_path = temp_path.to_owned();
         let payload_index_schema = self.payload_index_schema.clone();
 
+        let tar_c = tar.clone();
         tokio::task::spawn_blocking(move || {
             // Do not change segments while snapshotting
             SegmentHolder::snapshot_all_segments(
@@ -804,43 +802,42 @@ impl LocalShard {
                 Some(&collection_params),
                 &payload_index_schema.read().clone(),
                 &temp_path,
-                &snapshot_segments_shard_path,
+                &tar_c.descend(Path::new(SEGMENTS_PATH))?,
             )?;
 
             if save_wal {
                 // snapshot all shard's WAL
-                Self::snapshot_wal(wal, &snapshot_shard_path_owned)
+                Self::snapshot_wal(wal, &tar_c)
             } else {
-                Self::snapshot_empty_wal(wal, &snapshot_shard_path_owned)
+                Self::snapshot_empty_wal(wal, &temp_path, &tar_c)
             }
         })
         .await??;
 
-        LocalShardClocks::copy_data(&self.path, snapshot_shard_path).await?;
+        LocalShardClocks::archive_data(&self.path, tar).await?;
 
         Ok(())
     }
 
     /// Create empty WAL which is compatible with currently stored data
-    pub fn snapshot_empty_wal(wal: LockedWal, snapshot_shard_path: &Path) -> CollectionResult<()> {
+    pub fn snapshot_empty_wal(
+        wal: LockedWal,
+        temp_path: &Path,
+        tar: &tar_ext::BuilderExt,
+    ) -> CollectionResult<()> {
         let (segment_capacity, latest_op_num) = {
             let wal_guard = wal.lock();
             (wal_guard.segment_capacity(), wal_guard.last_index())
         };
 
-        let target_path = Self::wal_path(snapshot_shard_path);
-
-        // Create directory if it does not exist
-        std::fs::create_dir_all(&target_path).map_err(|err| {
+        let temp_dir = tempfile::tempdir_in(temp_path).map_err(|err| {
             CollectionError::service_error(format!(
-                "Can not crate directory {}: {}",
-                target_path.display(),
-                err
+                "Can not create temporary directory for WAL: {err}",
             ))
         })?;
 
         Wal::generate_empty_wal_starting_at_index(
-            target_path,
+            temp_dir.path(),
             &WalOptions {
                 segment_capacity,
                 segment_queue_len: 0,
@@ -849,23 +846,43 @@ impl LocalShard {
         )
         .map_err(|err| {
             CollectionError::service_error(format!("Error while create empty WAL: {err}"))
-        })
+        })?;
+
+        tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))
+            .map_err(|err| {
+                CollectionError::service_error(format!("Error while archiving WAL: {err}"))
+            })
     }
 
     /// snapshot WAL
-    ///
-    /// copies all WAL files into `snapshot_shard_path/wal`
-    pub fn snapshot_wal(wal: LockedWal, snapshot_shard_path: &Path) -> CollectionResult<()> {
+    pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {
         // lock wal during snapshot
         let mut wal_guard = wal.lock();
         wal_guard.flush()?;
         let source_wal_path = wal_guard.path();
-        let options = fs_extra::dir::CopyOptions::new();
-        fs_extra::dir::copy(source_wal_path, snapshot_shard_path, &options).map_err(|err| {
-            CollectionError::service_error(format!(
-                "Error while copy WAL {snapshot_shard_path:?} {err}"
-            ))
-        })?;
+
+        let tar = tar.descend(Path::new(WAL_PATH))?;
+        for entry in std::fs::read_dir(source_wal_path).map_err(|err| {
+            CollectionError::service_error(format!("Can't read WAL directory: {err}",))
+        })? {
+            let entry = entry.map_err(|err| {
+                CollectionError::service_error(format!("Can't read WAL directory: {err}",))
+            })?;
+
+            if entry.file_name() == ".wal" {
+                // This sentinel file is used for WAL locking. Trying to archive
+                // or open it will cause the following error on Windows:
+                // > The process cannot access the file because another process
+                // > has locked a portion of the file. (os error 33)
+                // https://github.com/qdrant/wal/blob/7c9202d0874/src/lib.rs#L125-L145
+                continue;
+            }
+
+            tar.blocking_append_file(&entry.path(), Path::new(&entry.file_name()))
+                .map_err(|err| {
+                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))
+                })?;
+        }
         Ok(())
     }
 
@@ -1097,6 +1114,10 @@ impl Drop for LocalShard {
     }
 }
 
+const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";
+
+const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";
+
 /// Convenience struct for combining clock maps belonging to a shard
 ///
 /// Holds a clock map for tracking the highest clocks and the cutoff clocks.
@@ -1138,19 +1159,19 @@ impl LocalShardClocks {
         Ok(())
     }
 
-    /// Copy clock data on disk from one shard path to another.
-    pub async fn copy_data(from: &Path, to: &Path) -> CollectionResult<()> {
+    /// Put clock data from the disk into an archive.
+    pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {
         let newest_clocks_from = Self::newest_clocks_path(from);
         let oldest_clocks_from = Self::oldest_clocks_path(from);
 
         if newest_clocks_from.exists() {
-            let newest_clocks_to = Self::newest_clocks_path(to);
-            copy(newest_clocks_from, newest_clocks_to).await?;
+            tar.append_file(&newest_clocks_from, Path::new(NEWEST_CLOCKS_PATH))
+                .await?;
         }
 
         if oldest_clocks_from.exists() {
-            let oldest_clocks_to = Self::oldest_clocks_path(to);
-            copy(oldest_clocks_from, oldest_clocks_to).await?;
+            tar.append_file(&oldest_clocks_from, Path::new(OLDEST_CLOCKS_PATH))
+                .await?;
         }
 
         Ok(())
@@ -1191,10 +1212,10 @@ impl LocalShardClocks {
     }
 
     fn newest_clocks_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("newest_clocks.json")
+        shard_path.join(NEWEST_CLOCKS_PATH)
     }
 
     fn oldest_clocks_path(shard_path: &Path) -> PathBuf {
-        shard_path.join("oldest_clocks.json")
+        shard_path.join(OLDEST_CLOCKS_PATH)
     }
 }

commit 0334ff4488eefccb473551f967138bed778fcf6c
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Sep 13 23:29:36 2024 +0200

    Parallelize duplicate point deletions across segments (#5073)
    
    * Parallelize duplicate point deletions across segments
    
    * Fix typo

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 64e1cda58..ab68520e1 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -318,7 +318,7 @@ impl LocalShard {
             segment_holder.add_new(segment);
         }
 
-        let res = segment_holder.deduplicate_points()?;
+        let res = segment_holder.deduplicate_points().await?;
         if res > 0 {
             log::debug!("Deduplicated {} points", res);
         }

commit 92675cd1c16582999eaefe8f357f43a1472a1c81
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Sep 18 11:16:13 2024 +0200

    Refactor local shard status function (#5102)
    
    * Refactor local shard status
    
    * Update lib/collection/src/shards/local_shard/mod.rs
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index ab68520e1..c73bbd62a 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -990,53 +990,50 @@ impl LocalShard {
     }
 
     pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {
-        let mut status = ShardStatus::Green;
-        let mut optimizer_status = OptimizersStatus::Ok;
-
         {
             let segments = self.segments().read();
 
+            // Red status on failed operation or optimizer error
             if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {
-                status = ShardStatus::Red;
+                let optimizer_status = segments
+                    .optimizer_errors
+                    .as_ref()
+                    .map_or(OptimizersStatus::Ok, |err| {
+                        OptimizersStatus::Error(err.to_string())
+                    });
+                return (ShardStatus::Red, optimizer_status);
+            }
 
-                if let Some(error) = &segments.optimizer_errors {
-                    optimizer_status = OptimizersStatus::Error(error.to_string());
-                }
-            } else {
-                let has_special_segments = segments
-                    .iter()
-                    .map(|(_, segment)| segment.get().read().info().segment_type)
-                    .any(|segment_type| segment_type == SegmentType::Special);
-
-                // Special segment means it's a proxy segment and is being optimized, mark as yellow
-                // ToDo: snapshotting also creates temp proxy segments. should differentiate.
-                if has_special_segments {
-                    status = ShardStatus::Yellow;
-                }
+            // Yellow status if we have a special segment, indicates a proxy segment used during optimization
+            // TODO: snapshotting also creates temp proxy segments. should differentiate.
+            let has_special_segment = segments
+                .iter()
+                .map(|(_, segment)| segment.get().read().info().segment_type)
+                .any(|segment_type| segment_type == SegmentType::Special);
+            if has_special_segment {
+                return (ShardStatus::Yellow, OptimizersStatus::Ok);
             }
         }
 
-        // If status looks green/ok but some optimizations are suboptimal
-        if status == ShardStatus::Green && optimizer_status == OptimizersStatus::Ok {
-            let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self
-                .update_handler
-                .lock()
-                .await
-                .check_optimizer_conditions();
-
-            if has_suboptimal_optimizers {
-                // Check if any optimizations were triggered after starting the node
-                if has_triggered_any_optimizers {
-                    status = ShardStatus::Yellow;
-                } else {
-                    // This can happen when a node is restarted (crashed), because we don't
-                    // automatically trigger optimizations on restart to avoid a crash loop
-                    status = ShardStatus::Grey;
-                }
-            }
+        // Yellow or grey status if there are pending optimizations
+        // Grey if optimizers were not triggered yet after restart,
+        // we don't automatically trigger them to prevent a crash loop
+        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self
+            .update_handler
+            .lock()
+            .await
+            .check_optimizer_conditions();
+        if has_suboptimal_optimizers {
+            let status = if has_triggered_any_optimizers {
+                ShardStatus::Yellow
+            } else {
+                ShardStatus::Grey
+            };
+            return (status, OptimizersStatus::Ok);
         }
 
-        (status, optimizer_status)
+        // Green status because everything is fine
+        (ShardStatus::Green, OptimizersStatus::Ok)
     }
 
     pub async fn local_shard_info(&self) -> ShardInfoInternal {

commit 428e09d49b8fcd943427c5d397686ed08cd08337
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Sep 24 17:52:03 2024 +0200

    Trigger optimizers when uploading snapshots (#5140)
    
    * Trigger optimizers when uploading snapshots
    
    * Trigger optimizers through new method when optimizer config is updated
    
    * review remarks
    
    * Add comment on why ignoring channel send errors is fine
    
    * Remove obsolete return value omitting
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index c73bbd62a..00d9919de 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -727,11 +727,19 @@ impl LocalShard {
         update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;
         update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;
         update_handler.run_workers(update_receiver);
+
         self.update_sender.load().send(UpdateSignal::Nop).await?;
 
         Ok(())
     }
 
+    pub fn trigger_optimizers(&self) {
+        // Send a trigger signal and ignore errors because all error cases are acceptable:
+        // - If receiver is already dead - we do not care
+        // - If channel is full - optimization will be triggered by some other signal
+        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);
+    }
+
     /// Finishes ongoing update tasks
     pub async fn stop_gracefully(&self) {
         if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {

commit a50a248fd07ebeb2978ad28813bb90ca23be2bb3
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Oct 4 16:09:30 2024 +0000

    Introduce SnapshotFormat (#5175)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 00d9919de..bcb2fd744 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -29,7 +29,7 @@ use segment::segment::Segment;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::{
     CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PayloadStorageType, PointIdType,
-    QuantizationConfig, SegmentConfig, SegmentType,
+    QuantizationConfig, SegmentConfig, SegmentType, SnapshotFormat,
 };
 use segment::utils::mem::Mem;
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
@@ -781,6 +781,7 @@ impl LocalShard {
         &self,
         temp_path: &Path,
         tar: &tar_ext::BuilderExt,
+        format: SnapshotFormat,
         save_wal: bool,
     ) -> CollectionResult<()> {
         let segments = self.segments.clone();
@@ -811,6 +812,7 @@ impl LocalShard {
                 &payload_index_schema.read().clone(),
                 &temp_path,
                 &tar_c.descend(Path::new(SEGMENTS_PATH))?,
+                format,
             )?;
 
             if save_wal {

commit 3fb19cabc97209d9674db4f60ad932aed66716c4
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Oct 4 16:39:56 2024 +0000

    Restore SnapshotFormat::Streamable snapshots (#5179)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index bcb2fd744..2d606a57d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -754,25 +754,14 @@ impl LocalShard {
     }
 
     pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {
-        // recover segments
-        let segments_path = LocalShard::segments_path(snapshot_path);
-        // iterate over segments directory and recover each segment
-        for entry in std::fs::read_dir(segments_path)? {
-            let entry_path = entry?.path();
-            if entry_path.extension().map(|s| s == "tar").unwrap_or(false) {
-                let segment_id_opt = entry_path
-                    .file_stem()
-                    .map(|s| s.to_str().unwrap().to_owned());
-                if segment_id_opt.is_none() {
-                    return Err(CollectionError::service_error(
-                        "Segment ID is empty".to_string(),
-                    ));
-                }
-                let segment_id = segment_id_opt.unwrap();
-                Segment::restore_snapshot(&entry_path, &segment_id)?;
-                std::fs::remove_file(&entry_path)?;
-            }
+        // Read dir first as the directory contents would change during restore.
+        let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?
+            .collect::<Result<Vec<_>, _>>()?;
+
+        for entry in entries {
+            Segment::restore_snapshot_in_place(&entry.path())?;
         }
+
         Ok(())
     }
 

commit 758dca6f5a68282732d0de771915963fb19fd240
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Nov 1 20:42:30 2024 +0100

    Experiment: ignore clock tags when replica is in partial state (#5349)
    
    * Add internal interface to enable/disable clock tags on recoverable WAL
    
    * Disable WAL clocks when switching replica into partial state
    
    * Synchronize consensus at the end of stream records transfer
    
    * Minor refactoring
    
    * Do not send updates to replicas in recovery state
    
    * Fix test compilation

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 2d606a57d..ca1cc89bf 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1093,6 +1093,10 @@ impl LocalShard {
     pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {
         self.wal.update_cutoff(cutoff).await
     }
+
+    pub fn set_clocks_enabled(&self, enabled: bool) {
+        self.wal.set_clocks_enabled(enabled);
+    }
 }
 
 impl Drop for LocalShard {

commit 2656b7be1bb6247a10a90dea9735993a96c2e0e1
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Nov 5 17:46:02 2024 +0100

    Experiment: disable clocks in initializing state, propagate ignore flag (#5372)
    
    * Propagate flag for ignoring clocks on local shard from replica set
    
    * Also ignore local clocks in initializing state, is similar to partial
    
    * Remove previous logic for disabling clocks
    
    * We can make static replica set state functions inlined const
    
    * Fix typo

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index ca1cc89bf..2d606a57d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1093,10 +1093,6 @@ impl LocalShard {
     pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {
         self.wal.update_cutoff(cutoff).await
     }
-
-    pub fn set_clocks_enabled(&self, enabled: bool) {
-        self.wal.set_clocks_enabled(enabled);
-    }
 }
 
 impl Drop for LocalShard {

commit 17bce6e4587900f52cfbac79e4575fb696c75985
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 12 12:31:03 2024 +0100

    Async fixes (#5426)
    
    * expose async in telemetry
    
    * move async scorer config to proper section (as it was documented)
    
    * temporary disable mmap prefault
    
    * rollback prefault_mmap_pages
    
    * upd openapi

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 2d606a57d..1e15cf534 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -32,6 +32,7 @@ use segment::types::{
     QuantizationConfig, SegmentConfig, SegmentType, SnapshotFormat,
 };
 use segment::utils::mem::Mem;
+use segment::vector_storage::common::get_async_scorer;
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
 use tokio::sync::mpsc::Sender;
@@ -948,6 +949,7 @@ impl LocalShard {
                 optimizations,
                 log: self.optimizers_log.lock().to_telemetry(),
             },
+            async_scorer: Some(get_async_scorer()),
         }
     }
 

commit 6c162656f3a23a6e6601a58cf69f44bdcea0ab00
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 13 08:49:42 2024 -0600

    Backward compatibility for mmap payload storage (#5398)
    
    * support mmap storage backward compat
    
    * fix clippy
    
    * review fixes + bump + restore Cargo.lock
    
    * fix clippy
    
    * map_err instead of match
    
    * add sanity tests for payload storage trait
    
    * fix clippy
    
    * error conversion
    
    * test persistance too
    
    * add config to enable mmap storage (#5434)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 1e15cf534..4cb7339e9 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -28,8 +28,8 @@ use segment::index::field_index::CardinalityEstimation;
 use segment::segment::Segment;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::{
-    CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PayloadStorageType, PointIdType,
-    QuantizationConfig, SegmentConfig, SegmentType, SnapshotFormat,
+    CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, QuantizationConfig,
+    SegmentConfig, SegmentType, SnapshotFormat,
 };
 use segment::utils::mem::Mem;
 use segment::vector_storage::common::get_async_scorer;
@@ -484,11 +484,7 @@ impl LocalShard {
             let segment_config = SegmentConfig {
                 vector_data: vector_params.clone(),
                 sparse_vector_data: sparse_vector_params.clone(),
-                payload_storage_type: if config.params.on_disk_payload {
-                    PayloadStorageType::OnDisk
-                } else {
-                    PayloadStorageType::InMemory
-                },
+                payload_storage_type: config.params.payload_storage_type(),
             };
             let segment = thread::Builder::new()
                 .name(format!("shard-build-{collection_id}-{id}"))

commit 9e06d68661402bb2df271134bab5d9aeda995048
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Sat Nov 16 01:03:50 2024 +0700

    Add UUID to collection config (#5378)
    
    * Add UUID to collection...
    
    ...and recreate collection, when applying Raft snapshot, if UUID of collection is different
    
    * fixup! Add UUID to collection...
    
    Remove UUID field from gRPC and exclude it from OpenAPI spec 🤡
    
    * fixup! fixup! Add UUID to collection...
    
    Always generate collection UUID 🤦‍♀️
    
    * Raft snapshot recreate collection no expose UUID (#5452)
    
    * separate colleciton config structure from API
    
    * fmt
    
    * Update lib/collection/src/operations/types.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 4cb7339e9..5f3b46b51 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -50,7 +50,7 @@ use crate::collection_manager::holders::segment_holder::{
 use crate::collection_manager::optimizers::TrackerLog;
 use crate::collection_manager::segments_searcher::SegmentsSearcher;
 use crate::common::file_utils::{move_dir, move_file};
-use crate::config::CollectionConfig;
+use crate::config::CollectionConfigInternal;
 use crate::operations::shared_storage_config::SharedStorageConfig;
 use crate::operations::types::{
     check_sparse_compatible_with_segment_config, CollectionError, CollectionResult,
@@ -81,7 +81,7 @@ const SEGMENTS_PATH: &str = "segments";
 /// Holds all object, required for collection functioning
 pub struct LocalShard {
     pub(super) segments: LockedSegmentHolder,
-    pub(super) collection_config: Arc<TokioRwLock<CollectionConfig>>,
+    pub(super) collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,
     pub(super) shared_storage_config: Arc<SharedStorageConfig>,
     pub(crate) payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
     pub(super) wal: RecoverableWal,
@@ -144,7 +144,7 @@ impl LocalShard {
     #[allow(clippy::too_many_arguments)]
     pub async fn new(
         segment_holder: SegmentHolder,
-        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         wal: SerdeWal<OperationWithClockTag>,
@@ -224,7 +224,7 @@ impl LocalShard {
         id: ShardId,
         collection_id: CollectionId,
         shard_path: &Path,
-        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,
         effective_optimizers_config: OptimizersConfig,
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
@@ -413,7 +413,7 @@ impl LocalShard {
         id: ShardId,
         collection_id: CollectionId,
         shard_path: &Path,
-        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
@@ -446,7 +446,7 @@ impl LocalShard {
         id: ShardId,
         collection_id: CollectionId,
         shard_path: &Path,
-        collection_config: Arc<TokioRwLock<CollectionConfig>>,
+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,
         shared_storage_config: Arc<SharedStorageConfig>,
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,

commit 82db112e4d4be42af1dc52a72ddb1f4ee4797139
Author: generall <andrey@vasnetsov.com>
Date:   Fri Nov 29 20:48:21 2024 +0100

    add debug log about version on WAL reading

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 5f3b46b51..aaf92cb7f 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -563,6 +563,12 @@ impl LocalShard {
             .expect("Failed to create progress style");
         bar.set_style(progress_style);
 
+        log::debug!(
+            "Recovering shard {} starting reading WAL from {}",
+            &self.path,
+            wal.first_index()
+        );
+
         bar.set_message(format!("Recovering collection {collection_id}"));
         let segments = self.segments();
 

commit 3ce2b4a50a102b0dfa4ae9ceec1c169a71c3860a
Author: generall <andrey@vasnetsov.com>
Date:   Sat Nov 30 19:24:48 2024 +0100

    fix debug log

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index aaf92cb7f..fa7e3c958 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -564,7 +564,7 @@ impl LocalShard {
         bar.set_style(progress_style);
 
         log::debug!(
-            "Recovering shard {} starting reading WAL from {}",
+            "Recovering shard {:?} starting reading WAL from {}",
             &self.path,
             wal.first_index()
         );

commit 6842791e036b44606bc432de540d1626be850525
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Dec 2 13:37:00 2024 +0100

    Rate limit local shard operations (#5539)
    
    * Rate limit local shard operations
    
    * one more test
    
    * remove time sensitive test

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index fa7e3c958..ca8771357 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -17,6 +17,7 @@ use std::time::{Duration, Instant};
 
 use arc_swap::ArcSwap;
 use common::cpu::CpuBudget;
+use common::rate_limiting::RateLimiter;
 use common::types::TelemetryDetail;
 use common::{panic, tar_ext};
 use indicatif::{ProgressBar, ProgressStyle};
@@ -95,6 +96,8 @@ pub struct LocalShard {
     update_runtime: Handle,
     pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
+    read_rate_limiter: Option<ParkingMutex<RateLimiter>>,
+    write_rate_limiter: Option<ParkingMutex<RateLimiter>>,
 }
 
 /// Shard holds information about segments and WAL.
@@ -211,6 +214,8 @@ impl LocalShard {
             optimizers_log,
             total_optimized_points,
             disk_usage_watcher,
+            read_rate_limiter: None, // TODO initialize rate limiter from config
+            write_rate_limiter: None, // TODO initialize rate limiter from config
         }
     }
 
@@ -1097,6 +1102,34 @@ impl LocalShard {
     pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {
         self.wal.update_cutoff(cutoff).await
     }
+
+    /// Check if the write rate limiter allows the operation to proceed
+    ///
+    /// Returns an error if the rate limit is exceeded.
+    fn check_write_rate_limiter(&self) -> CollectionResult<()> {
+        if let Some(rate_limiter) = &self.write_rate_limiter {
+            if !rate_limiter.lock().check() {
+                return Err(CollectionError::RateLimitExceeded {
+                    description: "Write rate limit exceeded, retry later".to_string(),
+                });
+            }
+        }
+        Ok(())
+    }
+
+    /// Check if the read rate limiter allows the operation to proceed
+    ///
+    /// Returns an error if the rate limit is exceeded.
+    fn check_read_rate_limiter(&self) -> CollectionResult<()> {
+        if let Some(rate_limiter) = &self.read_rate_limiter {
+            if !rate_limiter.lock().check() {
+                return Err(CollectionError::RateLimitExceeded {
+                    description: "Read rate limit exceeded, retry later".to_string(),
+                });
+            }
+        }
+        Ok(())
+    }
 }
 
 impl Drop for LocalShard {

commit 3c19eea9ca435304c6ea5b42c1000eb52e9ee7ca
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 6 11:02:18 2024 +0100

    Rate limiting for shard operations (#5582)
    
    * Rate limiting for shard operations
    
    * address all review comments in one go

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index ca8771357..f95a5fa7b 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -96,8 +96,8 @@ pub struct LocalShard {
     update_runtime: Handle,
     pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
-    read_rate_limiter: Option<ParkingMutex<RateLimiter>>,
-    write_rate_limiter: Option<ParkingMutex<RateLimiter>>,
+    read_rate_limiter: ParkingMutex<Option<RateLimiter>>,
+    write_rate_limiter: ParkingMutex<Option<RateLimiter>>,
 }
 
 /// Shard holds information about segments and WAL.
@@ -196,6 +196,20 @@ impl LocalShard {
 
         let update_tracker = segment_holder.read().update_tracker();
 
+        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
+            strict_mode
+                .read_rate_limit_per_sec
+                .map(RateLimiter::with_rate_per_sec)
+        });
+        let read_rate_limiter = ParkingMutex::new(read_rate_limiter);
+
+        let write_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
+            strict_mode
+                .write_rate_limit_per_sec
+                .map(RateLimiter::with_rate_per_sec)
+        });
+        let write_rate_limiter = ParkingMutex::new(write_rate_limiter);
+
         drop(config); // release `shared_config` from borrow checker
 
         Self {
@@ -214,8 +228,8 @@ impl LocalShard {
             optimizers_log,
             total_optimized_points,
             disk_usage_watcher,
-            read_rate_limiter: None, // TODO initialize rate limiter from config
-            write_rate_limiter: None, // TODO initialize rate limiter from config
+            read_rate_limiter,
+            write_rate_limiter,
         }
     }
 
@@ -741,6 +755,28 @@ impl LocalShard {
         Ok(())
     }
 
+    /// Apply shard's strict mode configuration update
+    /// - Update read and write rate limiters
+    pub async fn on_strict_mode_config_update(&self) {
+        let config = self.collection_config.read().await;
+
+        if let Some(strict_mode_config) = &config.strict_mode_config {
+            // Update read rate limiter
+            if let Some(read_rate_limit_per_sec) = strict_mode_config.read_rate_limit_per_sec {
+                let mut read_rate_limiter_guard = self.read_rate_limiter.lock();
+                read_rate_limiter_guard
+                    .replace(RateLimiter::with_rate_per_sec(read_rate_limit_per_sec));
+            }
+
+            // update write rate limiter
+            if let Some(write_rate_limit_per_sec) = strict_mode_config.write_rate_limit_per_sec {
+                let mut write_rate_limiter_guard = self.write_rate_limiter.lock();
+                write_rate_limiter_guard
+                    .replace(RateLimiter::with_rate_per_sec(write_rate_limit_per_sec));
+            }
+        }
+    }
+
     pub fn trigger_optimizers(&self) {
         // Send a trigger signal and ignore errors because all error cases are acceptable:
         // - If receiver is already dead - we do not care
@@ -1107,8 +1143,8 @@ impl LocalShard {
     ///
     /// Returns an error if the rate limit is exceeded.
     fn check_write_rate_limiter(&self) -> CollectionResult<()> {
-        if let Some(rate_limiter) = &self.write_rate_limiter {
-            if !rate_limiter.lock().check() {
+        if let Some(rate_limiter) = self.write_rate_limiter.lock().as_mut() {
+            if !rate_limiter.check() {
                 return Err(CollectionError::RateLimitExceeded {
                     description: "Write rate limit exceeded, retry later".to_string(),
                 });
@@ -1121,8 +1157,8 @@ impl LocalShard {
     ///
     /// Returns an error if the rate limit is exceeded.
     fn check_read_rate_limiter(&self) -> CollectionResult<()> {
-        if let Some(rate_limiter) = &self.read_rate_limiter {
-            if !rate_limiter.lock().check() {
+        if let Some(rate_limiter) = self.read_rate_limiter.lock().as_mut() {
+            if !rate_limiter.check() {
                 return Err(CollectionError::RateLimitExceeded {
                     description: "Read rate limit exceeded, retry later".to_string(),
                 });

commit f5bec253b6e1d9931dec902b0ccaa68475cad05f
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Dec 9 15:33:26 2024 +0100

    Minor refactoring during testing (#5610)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index f95a5fa7b..e7f7aea18 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -75,6 +75,10 @@ const WAL_PATH: &str = "wal";
 
 const SEGMENTS_PATH: &str = "segments";
 
+const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";
+
+const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";
+
 /// LocalShard
 ///
 /// LocalShard is an entity that can be moved between peers and contains some part of one collections data.
@@ -1183,10 +1187,6 @@ impl Drop for LocalShard {
     }
 }
 
-const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";
-
-const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";
-
 /// Convenience struct for combining clock maps belonging to a shard
 ///
 /// Holds a clock map for tracking the highest clocks and the cutoff clocks.

commit 993121b3eadecb1010d1db9a62bd29e5fef99941
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Dec 10 00:26:37 2024 +0100

    Rate limit requests per minute (#5597)
    
    * Rate limit requests per minute
    
    * rename to remove time unit for API

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index e7f7aea18..72bc9334e 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -200,17 +200,16 @@ impl LocalShard {
 
         let update_tracker = segment_holder.read().update_tracker();
 
-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
-            strict_mode
-                .read_rate_limit_per_sec
-                .map(RateLimiter::with_rate_per_sec)
-        });
+        let read_rate_limiter = config
+            .strict_mode_config
+            .as_ref()
+            .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute));
         let read_rate_limiter = ParkingMutex::new(read_rate_limiter);
 
         let write_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
             strict_mode
-                .write_rate_limit_per_sec
-                .map(RateLimiter::with_rate_per_sec)
+                .write_rate_limit
+                .map(RateLimiter::new_per_minute)
         });
         let write_rate_limiter = ParkingMutex::new(write_rate_limiter);
 
@@ -766,17 +765,17 @@ impl LocalShard {
 
         if let Some(strict_mode_config) = &config.strict_mode_config {
             // Update read rate limiter
-            if let Some(read_rate_limit_per_sec) = strict_mode_config.read_rate_limit_per_sec {
+            if let Some(read_rate_limit_per_sec) = strict_mode_config.read_rate_limit {
                 let mut read_rate_limiter_guard = self.read_rate_limiter.lock();
                 read_rate_limiter_guard
-                    .replace(RateLimiter::with_rate_per_sec(read_rate_limit_per_sec));
+                    .replace(RateLimiter::new_per_minute(read_rate_limit_per_sec));
             }
 
             // update write rate limiter
-            if let Some(write_rate_limit_per_sec) = strict_mode_config.write_rate_limit_per_sec {
+            if let Some(write_rate_limit_per_sec) = strict_mode_config.write_rate_limit {
                 let mut write_rate_limiter_guard = self.write_rate_limiter.lock();
                 write_rate_limiter_guard
-                    .replace(RateLimiter::with_rate_per_sec(write_rate_limit_per_sec));
+                    .replace(RateLimiter::new_per_minute(write_rate_limit_per_sec));
             }
         }
     }

commit d3f2b8e79c362b5eb4351d0266382598c3600f08
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 20 12:59:07 2024 +0100

    Fix rate limiting of internal update operations (#5653)
    
    * Fix rate limiting of internal update operations
    
    * code review
    
    * write_rate_limiter turned Option<Mutex> and fix disabling mode
    
    * Update TODO tag
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 72bc9334e..0c883d225 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -101,7 +101,6 @@ pub struct LocalShard {
     pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
     read_rate_limiter: ParkingMutex<Option<RateLimiter>>,
-    write_rate_limiter: ParkingMutex<Option<RateLimiter>>,
 }
 
 /// Shard holds information about segments and WAL.
@@ -206,13 +205,6 @@ impl LocalShard {
             .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute));
         let read_rate_limiter = ParkingMutex::new(read_rate_limiter);
 
-        let write_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
-            strict_mode
-                .write_rate_limit
-                .map(RateLimiter::new_per_minute)
-        });
-        let write_rate_limiter = ParkingMutex::new(write_rate_limiter);
-
         drop(config); // release `shared_config` from borrow checker
 
         Self {
@@ -232,7 +224,6 @@ impl LocalShard {
             total_optimized_points,
             disk_usage_watcher,
             read_rate_limiter,
-            write_rate_limiter,
         }
     }
 
@@ -770,13 +761,6 @@ impl LocalShard {
                 read_rate_limiter_guard
                     .replace(RateLimiter::new_per_minute(read_rate_limit_per_sec));
             }
-
-            // update write rate limiter
-            if let Some(write_rate_limit_per_sec) = strict_mode_config.write_rate_limit {
-                let mut write_rate_limiter_guard = self.write_rate_limiter.lock();
-                write_rate_limiter_guard
-                    .replace(RateLimiter::new_per_minute(write_rate_limit_per_sec));
-            }
         }
     }
 
@@ -1142,26 +1126,12 @@ impl LocalShard {
         self.wal.update_cutoff(cutoff).await
     }
 
-    /// Check if the write rate limiter allows the operation to proceed
-    ///
-    /// Returns an error if the rate limit is exceeded.
-    fn check_write_rate_limiter(&self) -> CollectionResult<()> {
-        if let Some(rate_limiter) = self.write_rate_limiter.lock().as_mut() {
-            if !rate_limiter.check() {
-                return Err(CollectionError::RateLimitExceeded {
-                    description: "Write rate limit exceeded, retry later".to_string(),
-                });
-            }
-        }
-        Ok(())
-    }
-
     /// Check if the read rate limiter allows the operation to proceed
     ///
     /// Returns an error if the rate limit is exceeded.
     fn check_read_rate_limiter(&self) -> CollectionResult<()> {
         if let Some(rate_limiter) = self.read_rate_limiter.lock().as_mut() {
-            if !rate_limiter.check() {
+            if !rate_limiter.check_and_update() {
                 return Err(CollectionError::RateLimitExceeded {
                     description: "Read rate limit exceeded, retry later".to_string(),
                 });

commit 3d3f8c104e35f0f4e393ed09d61cc063a759fabe
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 20 16:56:17 2024 +0100

    Reshape read rate limiter and fix disabled mode (#5683)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 0c883d225..92b84899a 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -100,7 +100,7 @@ pub struct LocalShard {
     update_runtime: Handle,
     pub(super) search_runtime: Handle,
     disk_usage_watcher: DiskUsageWatcher,
-    read_rate_limiter: ParkingMutex<Option<RateLimiter>>,
+    read_rate_limiter: Option<ParkingMutex<RateLimiter>>,
 }
 
 /// Shard holds information about segments and WAL.
@@ -199,11 +199,12 @@ impl LocalShard {
 
         let update_tracker = segment_holder.read().update_tracker();
 
-        let read_rate_limiter = config
-            .strict_mode_config
-            .as_ref()
-            .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute));
-        let read_rate_limiter = ParkingMutex::new(read_rate_limiter);
+        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {
+            strict_mode
+                .read_rate_limit
+                .map(RateLimiter::new_per_minute)
+                .map(ParkingMutex::new)
+        });
 
         drop(config); // release `shared_config` from borrow checker
 
@@ -750,18 +751,24 @@ impl LocalShard {
     }
 
     /// Apply shard's strict mode configuration update
-    /// - Update read and write rate limiters
-    pub async fn on_strict_mode_config_update(&self) {
+    /// - Update read rate limiter
+    pub async fn on_strict_mode_config_update(&mut self) {
         let config = self.collection_config.read().await;
 
         if let Some(strict_mode_config) = &config.strict_mode_config {
-            // Update read rate limiter
-            if let Some(read_rate_limit_per_sec) = strict_mode_config.read_rate_limit {
-                let mut read_rate_limiter_guard = self.read_rate_limiter.lock();
-                read_rate_limiter_guard
-                    .replace(RateLimiter::new_per_minute(read_rate_limit_per_sec));
+            if strict_mode_config.enabled == Some(true) {
+                // update read rate limiter
+                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {
+                    let new_read_rate_limiter =
+                        RateLimiter::new_per_minute(read_rate_limit_per_min);
+                    self.read_rate_limiter
+                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));
+                    return;
+                }
             }
         }
+        // remove read rate limiter for all other situations
+        self.read_rate_limiter.take();
     }
 
     pub fn trigger_optimizers(&self) {
@@ -1130,8 +1137,8 @@ impl LocalShard {
     ///
     /// Returns an error if the rate limit is exceeded.
     fn check_read_rate_limiter(&self) -> CollectionResult<()> {
-        if let Some(rate_limiter) = self.read_rate_limiter.lock().as_mut() {
-            if !rate_limiter.check_and_update() {
+        if let Some(rate_limiter) = &self.read_rate_limiter {
+            if !rate_limiter.lock().check_and_update() {
                 return Err(CollectionError::RateLimitExceeded {
                     description: "Read rate limit exceeded, retry later".to_string(),
                 });

commit 237ff8ca13d4e6a0f477533eb742b7f8b878e689
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Dec 23 11:22:13 2024 +0100

    Read rate limiter handles batched search requests (#5685)
    
    * Read rate limiter handles batched search requests
    
    * Show different rate limiter if big request can never pass
    
    * Improve rate limiter error reporting
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 92b84899a..99885942b 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1134,14 +1134,23 @@ impl LocalShard {
     }
 
     /// Check if the read rate limiter allows the operation to proceed
+    /// - cost: the cost of the operation
     ///
     /// Returns an error if the rate limit is exceeded.
-    fn check_read_rate_limiter(&self) -> CollectionResult<()> {
+    fn check_read_rate_limiter(&self, cost: usize) -> CollectionResult<()> {
         if let Some(rate_limiter) = &self.read_rate_limiter {
-            if !rate_limiter.lock().check_and_update() {
-                return Err(CollectionError::RateLimitExceeded {
-                    description: "Read rate limit exceeded, retry later".to_string(),
-                });
+            match rate_limiter.lock().try_consume(cost as f64) {
+                Ok(true) => {}
+                Ok(false) => {
+                    return Err(CollectionError::rate_limit_exceeded(
+                        "Read rate limit exceeded, retry later",
+                    ));
+                }
+                Err(msg) => {
+                    return Err(CollectionError::rate_limit_exceeded(format!(
+                        "Read rate limit exceeded, {msg}",
+                    )));
+                }
             }
         }
         Ok(())

commit cb8667a7ae571cc42d29a381375824bbf60461b2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Jan 8 18:12:10 2025 +0100

    Merge pull request #5729
    
    * Consider filter-cardinality as cost in update ratelimiter
    
    * Use OperationEffectArea and improve rate limit error message
    
    * Clippy
    
    * Fix test

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 99885942b..f065e0770 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1139,19 +1139,10 @@ impl LocalShard {
     /// Returns an error if the rate limit is exceeded.
     fn check_read_rate_limiter(&self, cost: usize) -> CollectionResult<()> {
         if let Some(rate_limiter) = &self.read_rate_limiter {
-            match rate_limiter.lock().try_consume(cost as f64) {
-                Ok(true) => {}
-                Ok(false) => {
-                    return Err(CollectionError::rate_limit_exceeded(
-                        "Read rate limit exceeded, retry later",
-                    ));
-                }
-                Err(msg) => {
-                    return Err(CollectionError::rate_limit_exceeded(format!(
-                        "Read rate limit exceeded, {msg}",
-                    )));
-                }
-            }
+            rate_limiter
+                .lock()
+                .try_consume(cost as f64)
+                .map_err(|err| CollectionError::rate_limit_error(err, Some(cost), false))?;
         }
         Ok(())
     }

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index f065e0770..1eff298ca 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -16,6 +16,7 @@ use std::thread;
 use std::time::{Duration, Instant};
 
 use arc_swap::ArcSwap;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::cpu::CpuBudget;
 use common::rate_limiting::RateLimiter;
 use common::types::TelemetryDetail;
@@ -615,7 +616,12 @@ impl LocalShard {
             }
 
             // Propagate `CollectionError::ServiceError`, but skip other error types.
-            match &CollectionUpdater::update(segments, op_num, update.operation) {
+            match &CollectionUpdater::update(
+                segments,
+                op_num,
+                update.operation,
+                &HardwareCounterCell::disposable(), // Internal operation, no measurement needed.
+            ) {
                 Err(err @ CollectionError::ServiceError { error, backtrace }) => {
                     let path = self.path.display();
 

commit 97743b1b625d42f73955ecb32d54ca34ea3a5cb7
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jan 24 16:33:44 2025 +0100

    Propagate hardware counter for more functions (#5844)
    
    * Propagate hardware counter for more functions
    
    * Minor improvements
    
    * use vector_query_contexts hardware_counter

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 1eff298ca..98b8082a7 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -16,6 +16,7 @@ use std::thread;
 use std::time::{Duration, Instant};
 
 use arc_swap::ArcSwap;
+use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::cpu::CpuBudget;
 use common::rate_limiting::RateLimiter;
@@ -952,9 +953,10 @@ impl LocalShard {
         &'a self,
         filter: Option<&'a Filter>,
         runtime_handle: &Handle,
+        hw_counter: HwMeasurementAcc,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
         let segments = self.segments.clone();
-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle).await
+        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await
     }
 
     pub fn get_telemetry_data(&self, detail: TelemetryDetail) -> LocalShardTelemetry {

commit 27d5b39aee992d26a95a3c6ff4e6fceba1bf89ad
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Feb 10 11:27:18 2025 +0100

    Retry-After on rate limiter hit for REST API (#5917)
    
    * Retry-After on rate limiter hit for REST API
    
    * fix tests
    
    * Ceil retry after seconds number so clients don't retry too early
    
    * Relax retry after time requirement a bit in case CI machines are slow
    
    * Add rate limit test, test retry after if we replanish within a second
    
    * Report time to wait in rate limit error
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 98b8082a7..9c2a62bc0 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1150,7 +1150,7 @@ impl LocalShard {
             rate_limiter
                 .lock()
                 .try_consume(cost as f64)
-                .map_err(|err| CollectionError::rate_limit_error(err, Some(cost), false))?;
+                .map_err(|err| CollectionError::rate_limit_error(err, cost, false))?;
         }
         Ok(())
     }

commit 2cab5192f7c546986f609057d40010418686c1bd
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Feb 19 13:16:02 2025 -0300

    [score boosting] handle rescoring up to local shard (#6019)
    
    * handle rescoring up to local shard
    
    * use heap to keep only best points
    
    * add stopping flag
    
    * handle wrapped segment deletions
    
    * drop ordering, assume always LargeBetter
    
    * use ahash for u32 keys
    
    * micro optimization on update_point_versions
    
    * use Option instead of Vec for error
    
    * clarify comment

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 9c2a62bc0..d99b06d93 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1,6 +1,7 @@
 pub mod clock_map;
 pub mod disk_usage_watcher;
 pub(super) mod facet;
+pub(super) mod formula_rescore;
 pub(super) mod query;
 pub(super) mod scroll;
 pub(super) mod search;

commit caed5729e5b7ff3db9dcb4531a4af0929b186682
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Feb 20 09:05:00 2025 +0100

    IO resource usage permit (#6015)
    
    * rename cpu_budget -> resource_budget
    
    * clippy
    
    * add io budget to resources
    
    * fmt
    
    * move budget structures into a separate file
    
    * add extend permit function
    
    * dont extend existing permit
    
    * switch from IO to CPU permit
    
    * do not release resource before aquiring an extension
    
    * fmt
    
    * Review remarks
    
    * Improve resource permit number assertion
    
    * Make resource permit replace_with only acquire extra needed permits
    
    * Remove obsolete drop implementation
    
    * allocate IO budget same as CPU
    
    * review fixes
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index d99b06d93..9c56d120c 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -17,9 +17,9 @@ use std::thread;
 use std::time::{Duration, Instant};
 
 use arc_swap::ArcSwap;
+use common::budget::ResourceBudget;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
-use common::cpu::CpuBudget;
 use common::rate_limiting::RateLimiter;
 use common::types::TelemetryDetail;
 use common::{panic, tar_ext};
@@ -158,7 +158,7 @@ impl LocalShard {
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         wal: SerdeWal<OperationWithClockTag>,
         optimizers: Arc<Vec<Arc<Optimizer>>>,
-        optimizer_cpu_budget: CpuBudget,
+        optimizer_resource_budget: ResourceBudget,
         shard_path: &Path,
         clocks: LocalShardClocks,
         update_runtime: Handle,
@@ -186,7 +186,7 @@ impl LocalShard {
             optimizers.clone(),
             optimizers_log.clone(),
             total_optimized_points.clone(),
-            optimizer_cpu_budget.clone(),
+            optimizer_resource_budget.clone(),
             update_runtime.clone(),
             segment_holder.clone(),
             locked_wal.clone(),
@@ -247,7 +247,7 @@ impl LocalShard {
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         search_runtime: Handle,
-        optimizer_cpu_budget: CpuBudget,
+        optimizer_resource_budget: ResourceBudget,
     ) -> CollectionResult<LocalShard> {
         let collection_config_read = collection_config.read().await;
 
@@ -378,7 +378,7 @@ impl LocalShard {
             payload_index_schema,
             wal,
             optimizers,
-            optimizer_cpu_budget,
+            optimizer_resource_budget,
             shard_path,
             clocks,
             update_runtime,
@@ -435,7 +435,7 @@ impl LocalShard {
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         search_runtime: Handle,
-        optimizer_cpu_budget: CpuBudget,
+        optimizer_resource_budget: ResourceBudget,
         effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
         // initialize local shard config file
@@ -449,7 +449,7 @@ impl LocalShard {
             payload_index_schema,
             update_runtime,
             search_runtime,
-            optimizer_cpu_budget,
+            optimizer_resource_budget,
             effective_optimizers_config,
         )
         .await?;
@@ -468,7 +468,7 @@ impl LocalShard {
         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,
         update_runtime: Handle,
         search_runtime: Handle,
-        optimizer_cpu_budget: CpuBudget,
+        optimizer_resource_budget: ResourceBudget,
         effective_optimizers_config: OptimizersConfig,
     ) -> CollectionResult<LocalShard> {
         let config = collection_config.read().await;
@@ -548,7 +548,7 @@ impl LocalShard {
             payload_index_schema,
             wal,
             optimizers,
-            optimizer_cpu_budget,
+            optimizer_resource_budget,
             shard_path,
             LocalShardClocks::default(),
             update_runtime,

commit 3216983c5f3cbcd65ee02c6cda1f907cfa312f9a
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Feb 21 10:52:13 2025 +0100

    Improve segment loading, don't load invalid segments (#6032)
    
    * Fix segment loading, don't try to load unknown files
    
    Don't load a segment from a path that is not a directory. Ignore segment
    file names prefixed with a period as well.
    
    * Rework segment directory walker, error before spawning threads

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 9c56d120c..956af07fb 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -260,13 +260,49 @@ impl LocalShard {
         )
         .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;
 
-        let segment_dirs = std::fs::read_dir(&segments_path).map_err(|err| {
-            CollectionError::service_error(format!(
-                "Can't read segments directory due to {}\nat {}",
-                err,
-                segments_path.to_str().unwrap()
-            ))
-        })?;
+        // Walk over segments directory and collect all directory entries now
+        // Collect now and error early to prevent errors while we've already spawned load threads
+        let segment_paths = std::fs::read_dir(&segments_path)
+            .map_err(|err| {
+                CollectionError::service_error(format!(
+                    "Can't read segments directory due to {err}\nat {}",
+                    segments_path.display(),
+                ))
+            })?
+            .collect::<Result<Vec<_>, _>>()
+            .map_err(|err| {
+                CollectionError::service_error(format!(
+                    "Failed to read segment path in segment directory: {err}",
+                ))
+            })?;
+
+        // Grab segment paths, filter out hidden entries and non-directories
+        let segment_paths = segment_paths
+            .into_iter()
+            .filter(|entry| {
+                let is_hidden = entry
+                    .file_name()
+                    .to_str()
+                    .is_some_and(|s| s.starts_with('.'));
+                if is_hidden {
+                    log::debug!(
+                        "Segments path entry prefixed with a period, ignoring: {}",
+                        entry.path().display(),
+                    );
+                }
+                !is_hidden
+            })
+            .filter(|entry| {
+                let is_dir = entry.path().is_dir();
+                if !is_dir {
+                    log::warn!(
+                        "Segments path entry is not a directory, skipping: {}",
+                        entry.path().display(),
+                    );
+                }
+                is_dir
+            })
+            .map(|entry| entry.path());
 
         let mut load_handlers = vec![];
 
@@ -274,8 +310,7 @@ impl LocalShard {
         // Uncomment it if you need to debug segment loading.
         // let semaphore = Arc::new(parking_lot::Mutex::new(()));
 
-        for entry in segment_dirs {
-            let segments_path = entry.unwrap().path();
+        for segment_path in segment_paths {
             let payload_index_schema = payload_index_schema.clone();
             // let semaphore_clone = semaphore.clone();
             load_handlers.push(
@@ -283,17 +318,17 @@ impl LocalShard {
                     .name(format!("shard-load-{collection_id}-{id}"))
                     .spawn(move || {
                         // let _guard = semaphore_clone.lock();
-                        let mut res = load_segment(&segments_path, &AtomicBool::new(false))?;
+                        let mut res = load_segment(&segment_path, &AtomicBool::new(false))?;
                         if let Some(segment) = &mut res {
                             segment.check_consistency_and_repair()?;
                             segment.update_all_field_indices(
                                 &payload_index_schema.read().schema.clone(),
                             )?;
                         } else {
-                            std::fs::remove_dir_all(&segments_path).map_err(|err| {
+                            std::fs::remove_dir_all(&segment_path).map_err(|err| {
                                 CollectionError::service_error(format!(
                                     "Can't remove leftover segment {}, due to {err}",
-                                    segments_path.to_str().unwrap(),
+                                    segment_path.to_str().unwrap(),
                                 ))
                             })?;
                         }

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 956af07fb..5dcdd1c6d 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -11,8 +11,8 @@ use std::collections::{BTreeSet, HashMap};
 use std::mem::size_of;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
-use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
 use std::sync::Arc;
+use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
 use std::thread;
 use std::time::{Duration, Instant};
 
@@ -40,7 +40,7 @@ use segment::vector_storage::common::get_async_scorer;
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
 use tokio::sync::mpsc::Sender;
-use tokio::sync::{mpsc, oneshot, Mutex, RwLock as TokioRwLock};
+use tokio::sync::{Mutex, RwLock as TokioRwLock, mpsc, oneshot};
 use wal::{Wal, WalOptions};
 
 use self::clock_map::{ClockMap, RecoveryPoint};
@@ -55,18 +55,18 @@ use crate::collection_manager::optimizers::TrackerLog;
 use crate::collection_manager::segments_searcher::SegmentsSearcher;
 use crate::common::file_utils::{move_dir, move_file};
 use crate::config::CollectionConfigInternal;
+use crate::operations::OperationWithClockTag;
 use crate::operations::shared_storage_config::SharedStorageConfig;
 use crate::operations::types::{
-    check_sparse_compatible_with_segment_config, CollectionError, CollectionResult,
-    OptimizersStatus, ShardInfoInternal, ShardStatus,
+    CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,
+    check_sparse_compatible_with_segment_config,
 };
-use crate::operations::OperationWithClockTag;
-use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};
+use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};
 use crate::save_on_disk::SaveOnDisk;
+use crate::shards::CollectionId;
 use crate::shards::shard::ShardId;
 use crate::shards::shard_config::ShardConfig;
 use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
-use crate::shards::CollectionId;
 use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
 use crate::wal::SerdeWal;
 use crate::wal_delta::{LockedWal, RecoverableWal};
@@ -395,7 +395,9 @@ impl LocalShard {
                 false,
                 "Shard has no appendable segments, this should never happen",
             );
-            log::warn!("Shard has no appendable segments, this should never happen. Creating new appendable segment now");
+            log::warn!(
+                "Shard has no appendable segments, this should never happen. Creating new appendable segment now",
+            );
             let segments_path = LocalShard::segments_path(shard_path);
             let collection_params = collection_config.read().await.params.clone();
             let payload_index_schema = payload_index_schema.read();

commit 2791bb19b7935f5c714078052e23cecb2bc1db5c
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Feb 25 13:26:06 2025 +0100

    Keep initial shard configuration on failed restore (#6038)
    
    * Keep initial shard configuration on failed restore
    
    * Set initialization flag for crash safety

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 5dcdd1c6d..aaa2ae033 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -108,6 +108,7 @@ pub struct LocalShard {
 
 /// Shard holds information about segments and WAL.
 impl LocalShard {
+    /// Moves `wal`, `segments` and `clocks` data from one path to another.
     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {
         let wal_from = Self::wal_path(from);
         let wal_to = Self::wal_path(to);

commit 68aa671643c57c9ff66aee9cc1f91e29c4c6b06b
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Feb 27 11:00:41 2025 +0100

    Ignore hidden files while restoring shard segments from snapshot (#6069)
    
    * Ignore hidden files while restoring shard segments from snapshot
    
    * Remove obsolete into_iter

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index aaa2ae033..6d8d90319 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -838,10 +838,25 @@ impl LocalShard {
     }
 
     pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {
-        // Read dir first as the directory contents would change during restore.
+        // Read dir first as the directory contents would change during restore
         let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?
             .collect::<Result<Vec<_>, _>>()?;
 
+        // Filter out hidden entries
+        let entries = entries.into_iter().filter(|entry| {
+            let is_hidden = entry
+                .file_name()
+                .to_str()
+                .is_some_and(|s| s.starts_with('.'));
+            if is_hidden {
+                log::debug!(
+                    "Ignoring hidden segment in local shard during snapshot recovery: {}",
+                    entry.path().display(),
+                );
+            }
+            !is_hidden
+        });
+
         for entry in entries {
             Segment::restore_snapshot_in_place(&entry.path())?;
         }

commit 1f4809f2a36d5ed177b542f1f994df68e32d3898
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Mar 7 12:45:18 2025 +0100

    Do not rate limit scroll operations for shard transfers (#6118)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 6d8d90319..3cca8729e 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1199,12 +1199,24 @@ impl LocalShard {
     /// - cost: the cost of the operation
     ///
     /// Returns an error if the rate limit is exceeded.
-    fn check_read_rate_limiter(&self, cost: usize) -> CollectionResult<()> {
+    fn check_read_rate_limiter(
+        &self,
+        cost: usize,
+        hw_measurement_acc: &HwMeasurementAcc,
+        context: &str,
+    ) -> CollectionResult<()> {
+        // Do not rate limit internal operation tagged with disposable measurement
+        if hw_measurement_acc.is_disposable() {
+            return Ok(());
+        }
         if let Some(rate_limiter) = &self.read_rate_limiter {
             rate_limiter
                 .lock()
                 .try_consume(cost as f64)
-                .map_err(|err| CollectionError::rate_limit_error(err, cost, false))?;
+                .map_err(|err| {
+                    log::debug!("Read rate limit error on {context} with {err:?}");
+                    CollectionError::rate_limit_error(err, cost, false)
+                })?;
         }
         Ok(())
     }

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 3cca8729e..7323de663 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -987,11 +987,17 @@ impl LocalShard {
     pub fn estimate_cardinality<'a>(
         &'a self,
         filter: Option<&'a Filter>,
+        hw_counter: &HardwareCounterCell,
     ) -> CollectionResult<CardinalityEstimation> {
         let segments = self.segments().read();
         let cardinality = segments
             .iter()
-            .map(|(_id, segment)| segment.get().read().estimate_point_count(filter))
+            .map(|(_id, segment)| {
+                segment
+                    .get()
+                    .read()
+                    .estimate_point_count(filter, hw_counter)
+            })
             .fold(CardinalityEstimation::exact(0), |acc, x| {
                 CardinalityEstimation {
                     primary_clauses: vec![],

commit c9b48bccd153f9742e1a42c1d76561c58e2a0b9a
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Fri Mar 21 13:51:36 2025 +0530

    Snapshot logging improve (#6192)
    
    * Add details to snapshot logging for more details
    
    * Format code and improve log msg
    
    * Remove unused import and improve logs
    
    * Improve terminology for logging
    
    * Minimize noise using logging levels
    
    * Log when moving local shard
    
    * Apply suggestions from code review
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    * fmt fix
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 7323de663..c630bbc4f 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -110,6 +110,12 @@ pub struct LocalShard {
 impl LocalShard {
     /// Moves `wal`, `segments` and `clocks` data from one path to another.
     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {
+        log::debug!(
+            "Moving local shard from {} to {}",
+            from.display(),
+            to.display()
+        );
+
         let wal_from = Self::wal_path(from);
         let wal_to = Self::wal_path(to);
         let segments_from = Self::segments_path(from);
@@ -632,7 +638,8 @@ impl LocalShard {
         let mut last_progress_report = Instant::now();
         if !show_progress_bar {
             log::info!(
-                "Recovering collection {collection_id}: 0/{} (0%)",
+                "Recovering shard {}: 0/{} (0%)",
+                self.path.display(),
                 wal.len(false),
             );
         }
@@ -838,6 +845,7 @@ impl LocalShard {
     }
 
     pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {
+        log::info!("Restoring shard snapshot {}", snapshot_path.display());
         // Read dir first as the directory contents would change during restore
         let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?
             .collect::<Result<Vec<_>, _>>()?;

commit f230629fa0e62e069e683cce60e24319ab3cc84b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 25 10:08:21 2025 +0100

    build(deps): bump log from 0.4.26 to 0.4.27 (#6247)
    
    * build(deps): bump log from 0.4.26 to 0.4.27
    
    Bumps [log](https://github.com/rust-lang/log) from 0.4.26 to 0.4.27.
    - [Release notes](https://github.com/rust-lang/log/releases)
    - [Changelog](https://github.com/rust-lang/log/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/rust-lang/log/compare/0.4.26...0.4.27)
    
    ---
    updated-dependencies:
    - dependency-name: log
      dependency-type: direct:production
      update-type: version-update:semver-patch
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * put variables inside the strings for log macros
    
    * also for pyroscope
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index c630bbc4f..8008fe4d5 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -380,7 +380,7 @@ impl LocalShard {
 
         let res = segment_holder.deduplicate_points().await?;
         if res > 0 {
-            log::debug!("Deduplicated {} points", res);
+            log::debug!("Deduplicated {res} points");
         }
 
         clear_temp_segments(shard_path);
@@ -680,7 +680,7 @@ impl LocalShard {
                     );
 
                     if let Some(backtrace) = &backtrace {
-                        log::error!("Backtrace: {}", backtrace);
+                        log::error!("Backtrace: {backtrace}");
                     }
 
                     return Err(err.clone());
@@ -834,13 +834,13 @@ impl LocalShard {
     /// Finishes ongoing update tasks
     pub async fn stop_gracefully(&self) {
         if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {
-            log::warn!("Error sending stop signal to update handler: {}", err);
+            log::warn!("Error sending stop signal to update handler: {err}");
         }
 
         self.stop_flush_worker().await;
 
         if let Err(err) = self.wait_update_workers_stop().await {
-            log::warn!("Update workers failed with: {}", err);
+            log::warn!("Update workers failed with: {err}");
         }
     }
 

commit 90340a098c9667e36c499633bf3d17015ee4ddc1
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Apr 2 15:11:13 2025 +0200

    Implement partial snapshot recovery (#6206)
    
    - Fix creating partial snapshot without RocksDB backup
    - Fix `segment_manifest.json` file placement
    - Implement partial snapshot recovery
    - Allow restoring partial snapshot for all shard types
    - Validate segment manifests when recovering partial snapshot
    - Log error, if streaming shard/partial snapshot failed
    - Contextualize errors in `snapshot_files` function
    - Tweak log messages in `Segment::take_snapshot` method
    - Remove unnecessary lifetimes from `SegmentHolder` iter methods

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 8008fe4d5..91abb1938 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -26,6 +26,7 @@ use common::{panic, tar_ext};
 use indicatif::{ProgressBar, ProgressStyle};
 use itertools::Itertools;
 use parking_lot::{Mutex as ParkingMutex, RwLock};
+use segment::data_types::segment_manifest::SegmentManifests;
 use segment::data_types::vectors::VectorElementType;
 use segment::entry::entry_point::SegmentEntry as _;
 use segment::index::field_index::CardinalityEstimation;
@@ -992,6 +993,13 @@ impl LocalShard {
         Ok(())
     }
 
+    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {
+        self.segments()
+            .read()
+            .segment_manifests()
+            .map_err(CollectionError::from)
+    }
+
     pub fn estimate_cardinality<'a>(
         &'a self,
         filter: Option<&'a Filter>,

commit 9c008f4013469072d95c61a716f46745b27eb039
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Apr 4 11:25:11 2025 +0200

    Make read rate limiter cost lazy (#6321)

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 91abb1938..537863cc1 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -1218,20 +1218,26 @@ impl LocalShard {
     }
 
     /// Check if the read rate limiter allows the operation to proceed
-    /// - cost: the cost of the operation
+    /// - hw_measurement_acc: the current hardware measurement accumulator
+    /// - context: the context of the operation to add on the error message
+    /// - cost_fn: the cost of the operation called lazily
     ///
     /// Returns an error if the rate limit is exceeded.
-    fn check_read_rate_limiter(
+    fn check_read_rate_limiter<F>(
         &self,
-        cost: usize,
         hw_measurement_acc: &HwMeasurementAcc,
         context: &str,
-    ) -> CollectionResult<()> {
+        cost_fn: F,
+    ) -> CollectionResult<()>
+    where
+        F: FnOnce() -> usize,
+    {
         // Do not rate limit internal operation tagged with disposable measurement
         if hw_measurement_acc.is_disposable() {
             return Ok(());
         }
         if let Some(rate_limiter) = &self.read_rate_limiter {
+            let cost = cost_fn();
             rate_limiter
                 .lock()
                 .try_consume(cost as f64)

commit d854b41ac1a346ed1addd42f26e66c97634dc0c7
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Apr 4 12:18:53 2025 +0200

    Migrate WAL mutex from parking lot to tokio (#6307)
    
    * Migrate WAL from sync parking lot to async tokio mutex
    
    * Improve logging
    
    * Migrate tests

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 537863cc1..4908badb7 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -174,7 +174,7 @@ impl LocalShard {
     ) -> Self {
         let segment_holder = Arc::new(RwLock::new(segment_holder));
         let config = collection_config.read().await;
-        let locked_wal = Arc::new(ParkingMutex::new(wal));
+        let locked_wal = Arc::new(Mutex::new(wal));
         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));
         let total_optimized_points = Arc::new(AtomicUsize::new(0));
 
@@ -617,7 +617,7 @@ impl LocalShard {
     /// Loads latest collection operations from WAL
     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {
         let mut newest_clocks = self.wal.newest_clocks.lock().await;
-        let wal = self.wal.wal.lock();
+        let wal = self.wal.wal.lock().await;
         let bar = ProgressBar::new(wal.len(false));
 
         let progress_style = ProgressStyle::default_bar()
@@ -626,9 +626,9 @@ impl LocalShard {
         bar.set_style(progress_style);
 
         log::debug!(
-            "Recovering shard {:?} starting reading WAL from {}",
-            &self.path,
-            wal.first_index()
+            "Recovering shard {} starting reading WAL from {}",
+            self.path.display(),
+            wal.first_index(),
         );
 
         bar.set_message(format!("Recovering collection {collection_id}"));
@@ -927,13 +927,17 @@ impl LocalShard {
     }
 
     /// Create empty WAL which is compatible with currently stored data
+    ///
+    /// # Panics
+    ///
+    /// This function panics if called within an asynchronous execution context.
     pub fn snapshot_empty_wal(
         wal: LockedWal,
         temp_path: &Path,
         tar: &tar_ext::BuilderExt,
     ) -> CollectionResult<()> {
         let (segment_capacity, latest_op_num) = {
-            let wal_guard = wal.lock();
+            let wal_guard = wal.blocking_lock();
             (wal_guard.segment_capacity(), wal_guard.last_index())
         };
 
@@ -962,9 +966,13 @@ impl LocalShard {
     }
 
     /// snapshot WAL
+    ///
+    /// # Panics
+    ///
+    /// This function panics if called within an asynchronous execution context.
     pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {
         // lock wal during snapshot
-        let mut wal_guard = wal.lock();
+        let mut wal_guard = wal.blocking_lock();
         wal_guard.flush()?;
         let source_wal_path = wal_guard.path();
 

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index 4908badb7..af7973235 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -8,7 +8,6 @@ pub(super) mod search;
 pub(super) mod shard_ops;
 
 use std::collections::{BTreeSet, HashMap};
-use std::mem::size_of;
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
@@ -27,16 +26,14 @@ use indicatif::{ProgressBar, ProgressStyle};
 use itertools::Itertools;
 use parking_lot::{Mutex as ParkingMutex, RwLock};
 use segment::data_types::segment_manifest::SegmentManifests;
-use segment::data_types::vectors::VectorElementType;
 use segment::entry::entry_point::SegmentEntry as _;
 use segment::index::field_index::CardinalityEstimation;
 use segment::segment::Segment;
 use segment::segment_constructor::{build_segment, load_segment};
 use segment::types::{
-    CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, QuantizationConfig,
-    SegmentConfig, SegmentType, SnapshotFormat,
+    Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,
+    SnapshotFormat,
 };
-use segment::utils::mem::Mem;
 use segment::vector_storage::common::get_async_scorer;
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
@@ -434,27 +431,6 @@ impl LocalShard {
         // Apply outstanding operations from WAL
         local_shard.load_from_wal(collection_id).await?;
 
-        let available_memory_bytes = Mem::new().available_memory_bytes() as usize;
-        let vectors_size_bytes = local_shard.estimate_vector_data_size().await;
-
-        // Simple heuristic to exclude mmap prefaulting for collections that won't benefit from it.
-        //
-        // We assume that mmap prefaulting is beneficial if we can put significant part of data
-        // into RAM in advance. However, if we can see that the data is too big to fit into RAM,
-        // it is better to avoid prefaulting, because it will only cause extra disk IO.
-        //
-        // This heuristic is not perfect, but it exclude cases when we don't have enough RAM
-        // even to store half of the vector data.
-        let do_mmap_prefault = available_memory_bytes * 2 > vectors_size_bytes;
-
-        if do_mmap_prefault {
-            for (_, segment) in local_shard.segments.read().iter() {
-                if let LockedSegment::Original(segment) = segment {
-                    segment.read().prefault_mmap_pages();
-                }
-            }
-        }
-
         Ok(local_shard)
     }
 
@@ -1082,43 +1058,6 @@ impl LocalShard {
         }
     }
 
-    /// Returns estimated size of vector data in bytes
-    async fn estimate_vector_data_size(&self) -> usize {
-        let info = self.local_shard_info().await;
-
-        let vector_size: usize = info
-            .config
-            .params
-            .vectors
-            .params_iter()
-            .map(|(_, value)| {
-                let vector_size = value.size.get() as usize;
-
-                let quantization_config = value
-                    .quantization_config
-                    .as_ref()
-                    .or(info.config.quantization_config.as_ref());
-
-                let quantized_size_bytes = match quantization_config {
-                    None => 0,
-                    Some(QuantizationConfig::Scalar(_)) => vector_size,
-                    Some(QuantizationConfig::Product(pq)) => match pq.product.compression {
-                        CompressionRatio::X4 => vector_size,
-                        CompressionRatio::X8 => vector_size / 2,
-                        CompressionRatio::X16 => vector_size / 4,
-                        CompressionRatio::X32 => vector_size / 8,
-                        CompressionRatio::X64 => vector_size / 16,
-                    },
-                    Some(QuantizationConfig::Binary(_)) => vector_size / 8,
-                };
-
-                vector_size * size_of::<VectorElementType>() + quantized_size_bytes
-            })
-            .sum();
-
-        vector_size * info.points_count
-    }
-
     pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {
         {
             let segments = self.segments().read();

commit bbea80e7d4f675d455053c10e751cc0f45df45e6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 17 23:32:10 2025 +0200

    Telemetry improvements (#6390)
    
    * allow shard states in anonymize telemetry (with hashed peer ids)
    
    * introduce level3 and level4 for telemetry, where level4 = everything, incl. segments info
    
    * upd openapi
    
    * fix tests
    
    * expose vector count & size stats on shard level to avoid reading of segments
    
    * fix spelling
    
    * upd schema
    
    * fix tests
    
    * Use unwrap_or_default
    
    * [#6390] skip serializing shard details in Level2 (#6398)
    
    * skip serializing shard details in Level2
    
    * upd openapi
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    Co-authored-by: Luis Cossío <luis.cossio@qdrant.com>

diff --git a/lib/collection/src/shards/local_shard/mod.rs b/lib/collection/src/shards/local_shard/mod.rs
index af7973235..636570c44 100644
--- a/lib/collection/src/shards/local_shard/mod.rs
+++ b/lib/collection/src/shards/local_shard/mod.rs
@@ -6,12 +6,13 @@ pub(super) mod query;
 pub(super) mod scroll;
 pub(super) mod search;
 pub(super) mod shard_ops;
+mod telemetry;
 
 use std::collections::{BTreeSet, HashMap};
 use std::ops::Deref;
 use std::path::{Path, PathBuf};
 use std::sync::Arc;
-use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
+use std::sync::atomic::{AtomicBool, AtomicUsize};
 use std::thread;
 use std::time::{Duration, Instant};
 
@@ -20,7 +21,6 @@ use common::budget::ResourceBudget;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::rate_limiting::RateLimiter;
-use common::types::TelemetryDetail;
 use common::{panic, tar_ext};
 use indicatif::{ProgressBar, ProgressStyle};
 use itertools::Itertools;
@@ -34,7 +34,6 @@ use segment::types::{
     Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,
     SnapshotFormat,
 };
-use segment::vector_storage::common::get_async_scorer;
 use tokio::fs::{create_dir_all, remove_dir_all, remove_file};
 use tokio::runtime::Handle;
 use tokio::sync::mpsc::Sender;
@@ -64,7 +63,6 @@ use crate::save_on_disk::SaveOnDisk;
 use crate::shards::CollectionId;
 use crate::shards::shard::ShardId;
 use crate::shards::shard_config::ShardConfig;
-use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};
 use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};
 use crate::wal::SerdeWal;
 use crate::wal_delta::{LockedWal, RecoverableWal};
@@ -1019,45 +1017,6 @@ impl LocalShard {
         SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await
     }
 
-    pub fn get_telemetry_data(&self, detail: TelemetryDetail) -> LocalShardTelemetry {
-        let segments_read_guard = self.segments.read();
-        let segments: Vec<_> = segments_read_guard
-            .iter()
-            .map(|(_id, segment)| segment.get().read().get_telemetry_data(detail))
-            .collect();
-
-        let optimizer_status = match &segments_read_guard.optimizer_errors {
-            None => OptimizersStatus::Ok,
-            Some(error) => OptimizersStatus::Error(error.to_string()),
-        };
-        drop(segments_read_guard);
-        let optimizations = self
-            .optimizers
-            .iter()
-            .map(|optimizer| {
-                optimizer
-                    .get_telemetry_counter()
-                    .lock()
-                    .get_statistics(detail)
-            })
-            .fold(Default::default(), |acc, x| acc + x);
-
-        let total_optimized_points = self.total_optimized_points.load(Ordering::Relaxed);
-
-        LocalShardTelemetry {
-            variant_name: None,
-            status: None,
-            total_optimized_points,
-            segments,
-            optimizations: OptimizerTelemetry {
-                status: optimizer_status,
-                optimizations,
-                log: self.optimizers_log.lock().to_telemetry(),
-            },
-            async_scorer: Some(get_async_scorer()),
-        }
-    }
-
     pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {
         {
             let segments = self.segments().read();

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    