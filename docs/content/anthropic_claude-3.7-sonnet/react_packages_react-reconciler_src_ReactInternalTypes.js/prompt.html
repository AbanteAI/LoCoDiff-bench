<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/ReactInternalTypes.js - Sonnet 3.7</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/ReactInternalTypes.js</h1>
        <h2>Model: Sonnet 3.7</h2>
        <p><a href="../../../cases/anthropic_claude-3.7-sonnet/react_packages_react-reconciler_src_ReactInternalTypes.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/ReactInternalTypes.js

commit 376d5c1b5aa17724c5fea9412f8fcde14a7b23f1
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 23:48:24 2020 -0700

    Split cross-package types from implementation
    
    Some of our internal reconciler types have leaked into other packages.
    Usually, these types are treated as opaque; we don't read and write
    to its fields. This is good.
    
    However, the type is often passed back to a reconciler method. For
    example, React DOM creates a FiberRoot with `createContainer`, then
    passes that root to `updateContainer`. It doesn't do anything with the
    root except pass it through, but because `updateContainer` expects a
    full FiberRoot, React DOM is still coupled to all its fields.
    
    I don't know if there's an idiomatic way to handle this in Flow. Opaque
    types are simlar, but those only work within a single file. AFAIK,
    there's no way to use a package as the boundary for opaqueness.
    
    The immediate problem this presents is that the reconciler refactor will
    involve changes to our internal data structures. I don't want to have to
    fork every single package that happens to pass through a Fiber or
    FiberRoot, or access any one of its fields. So my current plan is to
    share the same Flow type across both forks. The shared type will be a
    superset of each implementation's type, e.g. Fiber will have both an
    `expirationTime` field and a `lanes` field. The implementations will
    diverge, but not the types.
    
    To do this, I lifted the type definitions into a separate module.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
new file mode 100644
index 0000000000..2dbc9e5160
--- /dev/null
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -0,0 +1,330 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {Source} from 'shared/ReactElementType';
+import type {
+  RefObject,
+  ReactEventResponder,
+  ReactEventResponderListener,
+  ReactEventResponderInstance,
+  ReactContext,
+  MutableSourceSubscribeFn,
+  MutableSourceGetSnapshotFn,
+  MutableSource,
+} from 'shared/ReactTypes';
+import type {
+  SuspenseInstance,
+  ReactListenerEvent,
+} from './ReactFiberHostConfig';
+import type {WorkTag} from './ReactWorkTags';
+import type {TypeOfMode} from './ReactTypeOfMode';
+import type {SideEffectTag} from './ReactSideEffectTags';
+import type {ExpirationTime} from './ReactFiberExpirationTime';
+// import type {UpdateQueue} from './ReactUpdateQueue.old';
+import type {HookType} from './ReactFiberHooks.old';
+import type {RootTag} from './ReactRootTags';
+import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
+import type {Wakeable} from 'shared/ReactTypes';
+import type {Interaction} from 'scheduler/src/Tracing';
+import type {
+  OpaqueIDType,
+  ReactListenerMap,
+} from 'react-reconciler/src/ReactFiberHostConfig';
+import type {SuspenseConfig, TimeoutConfig} from './ReactFiberSuspenseConfig';
+
+export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
+
+export type ContextDependency<T> = {
+  context: ReactContext<T>,
+  observedBits: number,
+  next: ContextDependency<mixed> | null,
+  ...
+};
+
+export type Dependencies = {
+  expirationTime: ExpirationTime,
+  firstContext: ContextDependency<mixed> | null,
+  responders: Map<
+    ReactEventResponder<any, any>,
+    ReactEventResponderInstance<any, any>,
+  > | null,
+  ...
+};
+
+// A Fiber is work on a Component that needs to be done or was done. There can
+// be more than one per component.
+export type Fiber = {|
+  // These first fields are conceptually members of an Instance. This used to
+  // be split into a separate type and intersected with the other Fiber fields,
+  // but until Flow fixes its intersection bugs, we've merged them into a
+  // single type.
+
+  // An Instance is shared between all versions of a component. We can easily
+  // break this out into a separate object to avoid copying so much to the
+  // alternate versions of the tree. We put this on a single object for now to
+  // minimize the number of objects created during the initial render.
+
+  // Tag identifying the type of fiber.
+  tag: WorkTag,
+
+  // Unique identifier of this child.
+  key: null | string,
+
+  // The value of element.type which is used to preserve the identity during
+  // reconciliation of this child.
+  elementType: any,
+
+  // The resolved function/class/ associated with this fiber.
+  type: any,
+
+  // The local state associated with this fiber.
+  stateNode: any,
+
+  // Conceptual aliases
+  // parent : Instance -> return The parent happens to be the same as the
+  // return fiber since we've merged the fiber and instance.
+
+  // Remaining fields belong to Fiber
+
+  // The Fiber to return to after finishing processing this one.
+  // This is effectively the parent, but there can be multiple parents (two)
+  // so this is only the parent of the thing we're currently processing.
+  // It is conceptually the same as the return address of a stack frame.
+  return: Fiber | null,
+
+  // Singly Linked List Tree Structure.
+  child: Fiber | null,
+  sibling: Fiber | null,
+  index: number,
+
+  // The ref last used to attach this node.
+  // I'll avoid adding an owner field for prod and model that as functions.
+  ref:
+    | null
+    | (((handle: mixed) => void) & {_stringRef: ?string, ...})
+    | RefObject,
+
+  // Input is the data coming into process this fiber. Arguments. Props.
+  pendingProps: any, // This type will be more specific once we overload the tag.
+  memoizedProps: any, // The props used to create the output.
+
+  // A queue of state updates and callbacks.
+  updateQueue: mixed,
+
+  // The state used to create the output
+  memoizedState: any,
+
+  // Dependencies (contexts, events) for this fiber, if it has any
+  dependencies: Dependencies | null,
+
+  // Bitfield that describes properties about the fiber and its subtree. E.g.
+  // the ConcurrentMode flag indicates whether the subtree should be async-by-
+  // default. When a fiber is created, it inherits the mode of its
+  // parent. Additional flags can be set at creation time, but after that the
+  // value should remain unchanged throughout the fiber's lifetime, particularly
+  // before its child fibers are created.
+  mode: TypeOfMode,
+
+  // Effect
+  effectTag: SideEffectTag,
+
+  // Singly linked list fast path to the next fiber with side-effects.
+  nextEffect: Fiber | null,
+
+  // The first and last fiber with side-effect within this subtree. This allows
+  // us to reuse a slice of the linked list when we reuse the work done within
+  // this fiber.
+  firstEffect: Fiber | null,
+  lastEffect: Fiber | null,
+
+  // Represents a time in the future by which this work should be completed.
+  // Does not include work found in its subtree.
+  expirationTime: ExpirationTime,
+
+  // This is used to quickly determine if a subtree has no pending changes.
+  childExpirationTime: ExpirationTime,
+
+  // This is a pooled version of a Fiber. Every fiber that gets updated will
+  // eventually have a pair. There are cases when we can clean up pairs to save
+  // memory if we need to.
+  alternate: Fiber | null,
+
+  // Time spent rendering this Fiber and its descendants for the current update.
+  // This tells us how well the tree makes use of sCU for memoization.
+  // It is reset to 0 each time we render and only updated when we don't bailout.
+  // This field is only set when the enableProfilerTimer flag is enabled.
+  actualDuration?: number,
+
+  // If the Fiber is currently active in the "render" phase,
+  // This marks the time at which the work began.
+  // This field is only set when the enableProfilerTimer flag is enabled.
+  actualStartTime?: number,
+
+  // Duration of the most recent render time for this Fiber.
+  // This value is not updated when we bailout for memoization purposes.
+  // This field is only set when the enableProfilerTimer flag is enabled.
+  selfBaseDuration?: number,
+
+  // Sum of base times for all descendants of this Fiber.
+  // This value bubbles up during the "complete" phase.
+  // This field is only set when the enableProfilerTimer flag is enabled.
+  treeBaseDuration?: number,
+
+  // Conceptual aliases
+  // workInProgress : Fiber ->  alternate The alternate used for reuse happens
+  // to be the same as work in progress.
+  // __DEV__ only
+  _debugID?: number,
+  _debugSource?: Source | null,
+  _debugOwner?: Fiber | null,
+  _debugIsCurrentlyTiming?: boolean,
+  _debugNeedsRemount?: boolean,
+
+  // Used to verify that the order of hooks does not change between renders.
+  _debugHookTypes?: Array<HookType> | null,
+|};
+
+export type PendingInteractionMap = Map<ExpirationTime, Set<Interaction>>;
+
+type BaseFiberRootProperties = {|
+  // The type of root (legacy, batched, concurrent, etc.)
+  tag: RootTag,
+
+  // Any additional information from the host associated with this root.
+  containerInfo: any,
+  // Used only by persistent updates.
+  pendingChildren: any,
+  // The currently active root fiber. This is the mutable root of the tree.
+  current: Fiber,
+
+  pingCache:
+    | WeakMap<Wakeable, Set<ExpirationTime>>
+    | Map<Wakeable, Set<ExpirationTime>>
+    | null,
+
+  finishedExpirationTime: ExpirationTime,
+  // A finished work-in-progress HostRoot that's ready to be committed.
+  finishedWork: Fiber | null,
+  // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
+  // it's superseded by a new one.
+  timeoutHandle: TimeoutHandle | NoTimeout,
+  // Top context object, used by renderSubtreeIntoContainer
+  context: Object | null,
+  pendingContext: Object | null,
+  // Determines if we should attempt to hydrate on the initial mount
+  +hydrate: boolean,
+  // Node returned by Scheduler.scheduleCallback
+  callbackNode: *,
+  // Expiration of the callback associated with this root
+  callbackExpirationTime: ExpirationTime,
+  // Priority of the callback associated with this root
+  callbackPriority: ReactPriorityLevel,
+  // The earliest pending expiration time that exists in the tree
+  firstPendingTime: ExpirationTime,
+  // The latest pending expiration time that exists in the tree
+  lastPendingTime: ExpirationTime,
+  // The earliest suspended expiration time that exists in the tree
+  firstSuspendedTime: ExpirationTime,
+  // The latest suspended expiration time that exists in the tree
+  lastSuspendedTime: ExpirationTime,
+  // The next known expiration time after the suspended range
+  nextKnownPendingLevel: ExpirationTime,
+  // The latest time at which a suspended component pinged the root to
+  // render again
+  lastPingedTime: ExpirationTime,
+  lastExpiredTime: ExpirationTime,
+  // Used by useMutableSource hook to avoid tearing within this root
+  // when external, mutable sources are read from during render.
+  mutableSourceLastPendingUpdateTime: ExpirationTime,
+|};
+
+// The following attributes are only used by interaction tracing builds.
+// They enable interactions to be associated with their async work,
+// And expose interaction metadata to the React DevTools Profiler plugin.
+// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
+type ProfilingOnlyFiberRootProperties = {|
+  interactionThreadID: number,
+  memoizedInteractions: Set<Interaction>,
+  pendingInteractionMap: PendingInteractionMap,
+|};
+
+export type SuspenseHydrationCallbacks = {
+  onHydrated?: (suspenseInstance: SuspenseInstance) => void,
+  onDeleted?: (suspenseInstance: SuspenseInstance) => void,
+  ...
+};
+
+// The follow fields are only used by enableSuspenseCallback for hydration.
+type SuspenseCallbackOnlyFiberRootProperties = {|
+  hydrationCallbacks: null | SuspenseHydrationCallbacks,
+|};
+
+// Exported FiberRoot type includes all properties,
+// To avoid requiring potentially error-prone :any casts throughout the project.
+// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
+// The types are defined separately within this file to ensure they stay in sync.
+// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
+export type FiberRoot = {
+  ...BaseFiberRootProperties,
+  ...ProfilingOnlyFiberRootProperties,
+  ...SuspenseCallbackOnlyFiberRootProperties,
+  ...
+};
+
+type BasicStateAction<S> = (S => S) | S;
+type Dispatch<A> = A => void;
+
+export type Dispatcher = {|
+  readContext<T>(
+    context: ReactContext<T>,
+    observedBits: void | number | boolean,
+  ): T,
+  useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],
+  useReducer<S, I, A>(
+    reducer: (S, A) => S,
+    initialArg: I,
+    init?: (I) => S,
+  ): [S, Dispatch<A>],
+  useContext<T>(
+    context: ReactContext<T>,
+    observedBits: void | number | boolean,
+  ): T,
+  useRef<T>(initialValue: T): {|current: T|},
+  useEffect(
+    create: () => (() => void) | void,
+    deps: Array<mixed> | void | null,
+  ): void,
+  useLayoutEffect(
+    create: () => (() => void) | void,
+    deps: Array<mixed> | void | null,
+  ): void,
+  useCallback<T>(callback: T, deps: Array<mixed> | void | null): T,
+  useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T,
+  useImperativeHandle<T>(
+    ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
+    create: () => T,
+    deps: Array<mixed> | void | null,
+  ): void,
+  useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
+  useResponder<E, C>(
+    responder: ReactEventResponder<E, C>,
+    props: Object,
+  ): ReactEventResponderListener<E, C>,
+  useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T,
+  useTransition(
+    config: SuspenseConfig | void | null,
+  ): [(() => void) => void, boolean],
+  useMutableSource<Source, Snapshot>(
+    source: MutableSource<Source>,
+    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
+    subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+  ): Snapshot,
+  useEvent(event: ReactListenerEvent): ReactListenerMap,
+  useOpaqueIdentifier(): OpaqueIDType | void,
+|};

commit dc630d3374e8b3d01cdf9e12a81eab9322ac6832
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Apr 9 12:51:02 2020 -0700

    Fork ReactFiberExpirationTime
    
    I had thought I wouldn't fork this one because the new "lanes" module
    will be pretty different, but I need it to make some
    incremental changes.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 2dbc9e5160..1c37422388 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -25,7 +25,7 @@ import type {
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
-import type {ExpirationTime} from './ReactFiberExpirationTime';
+import type {ExpirationTime} from './ReactFiberExpirationTime.old';
 // import type {UpdateQueue} from './ReactUpdateQueue.old';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';

commit ff431b7fc43ee9022db094a673afbac7088bcfa2
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Apr 21 16:40:44 2020 +0100

    Remove ReactDOM.useEvent and associated types+tests (#18689)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1c37422388..b394f5f449 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -18,10 +18,7 @@ import type {
   MutableSourceGetSnapshotFn,
   MutableSource,
 } from 'shared/ReactTypes';
-import type {
-  SuspenseInstance,
-  ReactListenerEvent,
-} from './ReactFiberHostConfig';
+import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
@@ -32,10 +29,7 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
-import type {
-  OpaqueIDType,
-  ReactListenerMap,
-} from 'react-reconciler/src/ReactFiberHostConfig';
+import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 import type {SuspenseConfig, TimeoutConfig} from './ReactFiberSuspenseConfig';
 
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
@@ -325,6 +319,5 @@ export type Dispatcher = {|
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
     subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
   ): Snapshot,
-  useEvent(event: ReactListenerEvent): ReactListenerMap,
   useOpaqueIdentifier(): OpaqueIDType | void,
 |};

commit db6513914f99c260090f26f0a547ee1432c934e6
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 24 23:26:04 2020 -0700

    Make ExpirationTime an opaque type (#18732)
    
    * Add LanePriority type
    
    React's internal scheduler has more priority levels than the external
    Scheduler package. Let's use React as the source of truth for tracking
    the priority of updates so we have more control. We'll still fall back
    to Scheduler in the default case. In the future, we should consider
    removing `runWithPriority` from Scheduler and replacing the valid use
    cases with React-specific APIs.
    
    This commit adds a new type, called a LanePriority to disambiguate from
    the Scheduler one.
    
    ("Lane" refers to another type that I'm planning. It roughly translates
    to "thread." Each lane will have a priority associated with it.)
    
    I'm not actually using the lane anywhere, yet. Only setting stuff up.
    
    * Remove expiration times train model
    
    In the old reconciler, expiration times are computed by applying an
    offset to the current system time. This has the effect of increasing
    the priority of updates as time progresses. Because we also use
    expiration times as a kind of "thread" identifier, it turns out this
    is quite limiting because we can only flush work sequentially along
    the timeline.
    
    The new model will use a bitmask to represent parallel threads that
    can be worked on in any combination and in any order.
    
    In this commit, expiration times and the linear timeline are still in
    place, but they are no longer based on a timestamp. Effectively, they
    are constants based on their priority level.
    
    * Stop using ExpirationTime to represent timestamps
    
    Follow up to the previous commit. This converts the remaining places
    where we were using the ExpirationTime type to represent a timestamp,
    like Suspense timeouts.
    
    * Fork Dependencies and PendingInteractionMap types
    
    These contain expiration times
    
    * Make ExpirationTime an opaque type
    
    ExpirationTime is currently just an alias for the `number` type, for a
    few reasons. One is that it predates Flow's opaque type feature. Another
    is that making it opaque means we have to move all our comparisons and
    number math to the ExpirationTime module, and use utility functions
    everywhere else.
    
    However, this is actually what we want in the new system, because the
    Lanes type that will replace ExpirationTime is a bitmask with a
    particular layout, and performing operations on it will involve more
    than just number comparisions and artihmetic. I don't want this logic to
    spread ad hoc around the whole codebase.
    
    The utility functions get inlined by Closure so it doesn't matter
    performance-wise.
    
    I automated most of the changes with JSCodeshift, with only a few manual
    tweaks to stuff like imports. My goal was to port the logic exactly to
    prevent subtle mistakes, without trying to simplify anything in the
    process. I'll likely need to audit many of these sites again when I
    replace them with the new type, though, especially the ones
    in ReactFiberRoot.
    
    I added the codemods I used to the `scripts` directory. I won't merge
    these to master. I'll remove them in a subsequent commit. I'm only
    committing them here so they show up in the PR for future reference.
    
    I had a lot of trouble getting Flow to pass. Somehow it was not
    inferring the correct type of the constants exported from the
    ExpirationTime module, despite being annotated correctly.
    
    I tried converting them them to constructor functions — `NoWork`
    becomes `NoWork()` — and that made it work. I used that to unblock me,
    and fixed all the other type errors. Once there were no more type
    errors, I tried converting the constructors back to constants. Started
    getting errors again.
    
    Then I added a type constraint everywhere a constant was referenced.
    That fixed it. I also figured out that you only have to add a constraint
    when the constant is passed to another function, even if the function is
    annotated. So this indicates to me that it's probably a Flow bug. I'll
    file an issue with Flow.
    
    * Delete temporary codemods used in previous commit
    
    I only added these to the previous commit so that I can easily run it
    again when rebasing. When the stack is squashed, it will be as if they
    never existed.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index b394f5f449..edca384093 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -23,7 +23,7 @@ import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
 import type {ExpirationTime} from './ReactFiberExpirationTime.old';
-// import type {UpdateQueue} from './ReactUpdateQueue.old';
+import type {ExpirationTimeOpaque} from './ReactFiberExpirationTime.new';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
@@ -41,7 +41,7 @@ export type ContextDependency<T> = {
   ...
 };
 
-export type Dependencies = {
+export type Dependencies_old = {
   expirationTime: ExpirationTime,
   firstContext: ContextDependency<mixed> | null,
   responders: Map<
@@ -51,6 +51,16 @@ export type Dependencies = {
   ...
 };
 
+export type Dependencies_new = {
+  expirationTime: ExpirationTimeOpaque,
+  firstContext: ContextDependency<mixed> | null,
+  responders: Map<
+    ReactEventResponder<any, any>,
+    ReactEventResponderInstance<any, any>,
+  > | null,
+  ...
+};
+
 // A Fiber is work on a Component that needs to be done or was done. There can
 // be more than one per component.
 export type Fiber = {|
@@ -115,7 +125,8 @@ export type Fiber = {|
   memoizedState: any,
 
   // Dependencies (contexts, events) for this fiber, if it has any
-  dependencies: Dependencies | null,
+  dependencies_new: Dependencies_new | null,
+  dependencies_old: Dependencies_old | null,
 
   // Bitfield that describes properties about the fiber and its subtree. E.g.
   // the ConcurrentMode flag indicates whether the subtree should be async-by-
@@ -144,6 +155,10 @@ export type Fiber = {|
   // This is used to quickly determine if a subtree has no pending changes.
   childExpirationTime: ExpirationTime,
 
+  // Only used by new reconciler
+  expirationTime_opaque: ExpirationTimeOpaque,
+  childExpirationTime_opaque: ExpirationTimeOpaque,
+
   // This is a pooled version of a Fiber. Every fiber that gets updated will
   // eventually have a pair. There are cases when we can clean up pairs to save
   // memory if we need to.
@@ -184,8 +199,6 @@ export type Fiber = {|
   _debugHookTypes?: Array<HookType> | null,
 |};
 
-export type PendingInteractionMap = Map<ExpirationTime, Set<Interaction>>;
-
 type BaseFiberRootProperties = {|
   // The type of root (legacy, batched, concurrent, etc.)
   tag: RootTag,
@@ -197,12 +210,8 @@ type BaseFiberRootProperties = {|
   // The currently active root fiber. This is the mutable root of the tree.
   current: Fiber,
 
-  pingCache:
-    | WeakMap<Wakeable, Set<ExpirationTime>>
-    | Map<Wakeable, Set<ExpirationTime>>
-    | null,
+  pingCache: WeakMap<Wakeable, Set<mixed>> | Map<Wakeable, Set<mixed>> | null,
 
-  finishedExpirationTime: ExpirationTime,
   // A finished work-in-progress HostRoot that's ready to be committed.
   finishedWork: Fiber | null,
   // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
@@ -215,10 +224,15 @@ type BaseFiberRootProperties = {|
   +hydrate: boolean,
   // Node returned by Scheduler.scheduleCallback
   callbackNode: *,
+
+  // Only used by old reconciler
+
   // Expiration of the callback associated with this root
   callbackExpirationTime: ExpirationTime,
   // Priority of the callback associated with this root
   callbackPriority: ReactPriorityLevel,
+
+  finishedExpirationTime: ExpirationTime,
   // The earliest pending expiration time that exists in the tree
   firstPendingTime: ExpirationTime,
   // The latest pending expiration time that exists in the tree
@@ -236,6 +250,36 @@ type BaseFiberRootProperties = {|
   // Used by useMutableSource hook to avoid tearing within this root
   // when external, mutable sources are read from during render.
   mutableSourceLastPendingUpdateTime: ExpirationTime,
+
+  // Only used by new reconciler
+
+  // Represents the next task that the root should work on, or the current one
+  // if it's already working.
+  // TODO: In the new system, this will be a Lanes bitmask.
+  callbackId: ExpirationTimeOpaque,
+  // Whether the currently scheduled task for this root is synchronous or
+  // batched/concurrent. We have to track this because Scheduler does not
+  // support synchronous tasks, so we put those on a separate queue. So you
+  // could also think of this as "which queue is the callback scheduled with?"
+  callbackIsSync: boolean,
+  // Timestamp at which we will synchronously finish the current task to
+  // prevent starvation.
+  // TODO: There should be a separate expiration per lane.
+  // NOTE: This is not an "ExpirationTime" as used by the old reconciler. It's a
+  // timestamp, in milliseconds.
+  expiresAt: number,
+
+  // Same as corresponding fields in the old reconciler, but opaque. These will
+  // become bitmasks.
+  finishedExpirationTime_opaque: ExpirationTimeOpaque,
+  firstPendingTime_opaque: ExpirationTimeOpaque,
+  lastPendingTime_opaque: ExpirationTimeOpaque,
+  firstSuspendedTime_opaque: ExpirationTimeOpaque,
+  lastSuspendedTime_opaque: ExpirationTimeOpaque,
+  nextKnownPendingLevel_opaque: ExpirationTimeOpaque,
+  lastPingedTime_opaque: ExpirationTimeOpaque,
+  lastExpiredTime_opaque: ExpirationTimeOpaque,
+  mutableSourceLastPendingUpdateTime_opaque: ExpirationTimeOpaque,
 |};
 
 // The following attributes are only used by interaction tracing builds.
@@ -245,7 +289,8 @@ type BaseFiberRootProperties = {|
 type ProfilingOnlyFiberRootProperties = {|
   interactionThreadID: number,
   memoizedInteractions: Set<Interaction>,
-  pendingInteractionMap: PendingInteractionMap,
+  pendingInteractionMap_new: Map<ExpirationTimeOpaque, Set<Interaction>>,
+  pendingInteractionMap_old: Map<ExpirationTime, Set<Interaction>>,
 |};
 
 export type SuspenseHydrationCallbacks = {

commit 93e078ddf274636b0a40bd5501ce3549aec700fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat May 2 17:09:31 2020 -0700

    Initial Lanes implementation (#18796)
    
    See PR #18796 for more information.
    
    All of the changes I've made in this commit are behind the
    `enableNewReconciler` flag. Merging this to master will not affect the
    open source builds or the build that we ship to Facebook.
    
    The only build that is affected is the `ReactDOMForked` build, which is
    deployed to Facebook **behind an experimental flag (currently disabled
    for all users)**. We will use this flag to gradually roll out the new
    reconciler, and quickly roll it back if we find any problems.
    
    Because we have those protections in place, what I'm aiming for with
    this initial PR is the **smallest possible atomic change that lands
    cleanly and doesn't rely on too many hacks**. The goal has not been to
    get every single test or feature passing, and it definitely is not to
    implement all the features that we intend to build on top of the new
    model. When possible, I have chosen to preserve existing semantics and
    defer changes to follow-up steps. (Listed in the section below.)
    
    (I did not end up having to disable any tests, although if I had, that
    should not have necessarily been a merge blocker.)
    
    For example, even though one of the primary goals of this project is to
    improve our model for parallel Suspense transitions, in this initial
    implementation, I have chosen to keep the same core heuristics for
    sequencing and flushing that existed in the ExpirationTimes model: low
    priority updates cannot finish without also finishing high priority
    ones.
    
    Despite all these precautions, **because the scope of this refactor is
    inherently large, I do expect we will find regressions.** The flip side
    is that I also expect the new model to improve the stability of the
    codebase and make it easier to fix bugs when they arise.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index edca384093..2b12735c8c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -23,7 +23,7 @@ import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
 import type {ExpirationTime} from './ReactFiberExpirationTime.old';
-import type {ExpirationTimeOpaque} from './ReactFiberExpirationTime.new';
+import type {Lane, Lanes} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
@@ -52,7 +52,7 @@ export type Dependencies_old = {
 };
 
 export type Dependencies_new = {
-  expirationTime: ExpirationTimeOpaque,
+  lanes: Lanes,
   firstContext: ContextDependency<mixed> | null,
   responders: Map<
     ReactEventResponder<any, any>,
@@ -148,16 +148,13 @@ export type Fiber = {|
   firstEffect: Fiber | null,
   lastEffect: Fiber | null,
 
-  // Represents a time in the future by which this work should be completed.
-  // Does not include work found in its subtree.
+  // Only used by old reconciler
   expirationTime: ExpirationTime,
-
-  // This is used to quickly determine if a subtree has no pending changes.
   childExpirationTime: ExpirationTime,
 
   // Only used by new reconciler
-  expirationTime_opaque: ExpirationTimeOpaque,
-  childExpirationTime_opaque: ExpirationTimeOpaque,
+  lanes: Lanes,
+  childLanes: Lanes,
 
   // This is a pooled version of a Fiber. Every fiber that gets updated will
   // eventually have a pair. There are cases when we can clean up pairs to save
@@ -255,8 +252,7 @@ type BaseFiberRootProperties = {|
 
   // Represents the next task that the root should work on, or the current one
   // if it's already working.
-  // TODO: In the new system, this will be a Lanes bitmask.
-  callbackId: ExpirationTimeOpaque,
+  callbackId: Lanes,
   // Whether the currently scheduled task for this root is synchronous or
   // batched/concurrent. We have to track this because Scheduler does not
   // support synchronous tasks, so we put those on a separate queue. So you
@@ -269,17 +265,13 @@ type BaseFiberRootProperties = {|
   // timestamp, in milliseconds.
   expiresAt: number,
 
-  // Same as corresponding fields in the old reconciler, but opaque. These will
-  // become bitmasks.
-  finishedExpirationTime_opaque: ExpirationTimeOpaque,
-  firstPendingTime_opaque: ExpirationTimeOpaque,
-  lastPendingTime_opaque: ExpirationTimeOpaque,
-  firstSuspendedTime_opaque: ExpirationTimeOpaque,
-  lastSuspendedTime_opaque: ExpirationTimeOpaque,
-  nextKnownPendingLevel_opaque: ExpirationTimeOpaque,
-  lastPingedTime_opaque: ExpirationTimeOpaque,
-  lastExpiredTime_opaque: ExpirationTimeOpaque,
-  mutableSourceLastPendingUpdateTime_opaque: ExpirationTimeOpaque,
+  pendingLanes: Lanes,
+  suspendedLanes: Lanes,
+  pingedLanes: Lanes,
+  expiredLanes: Lanes,
+  mutableReadLanes: Lanes,
+
+  finishedLanes: Lanes,
 |};
 
 // The following attributes are only used by interaction tracing builds.
@@ -289,7 +281,7 @@ type BaseFiberRootProperties = {|
 type ProfilingOnlyFiberRootProperties = {|
   interactionThreadID: number,
   memoizedInteractions: Set<Interaction>,
-  pendingInteractionMap_new: Map<ExpirationTimeOpaque, Set<Interaction>>,
+  pendingInteractionMap_new: Map<Lane | Lanes, Set<Interaction>>,
   pendingInteractionMap_old: Map<ExpirationTime, Set<Interaction>>,
 |};
 

commit df14b5bcc163516fc0f1ad35e9b93732c66c1085
Author: Luna Ruan <luna@fb.com>
Date:   Thu May 7 20:46:27 2020 -0700

    add new IDs for each each server renderer instance and prefixes to distinguish between each server render (#18576)
    
    There is a worry that `useOpaqueIdentifier` might run out of unique IDs if running for long enough. This PR moves the unique ID counter so it's generated per server renderer object instead. For people who render different subtrees, this PR adds a prefix option to `renderToString`, `renderToStaticMarkup`, `renderToNodeStream`, and `renderToStaticNodeStream` so identifiers can be differentiated for each individual subtree.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 2b12735c8c..0f6daf6e05 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -29,7 +29,6 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
-import type {OpaqueIDType} from 'react-reconciler/src/ReactFiberHostConfig';
 import type {SuspenseConfig, TimeoutConfig} from './ReactFiberSuspenseConfig';
 
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
@@ -356,5 +355,5 @@ export type Dispatcher = {|
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
     subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
   ): Snapshot,
-  useOpaqueIdentifier(): OpaqueIDType | void,
+  useOpaqueIdentifier(): any,
 |};

commit 6edaf6f764f23043f0cd1c2da355b42f641afd8b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri May 8 12:47:51 2020 -0700

    Detect and prevent render starvation, per lane (#18864)
    
    * Detect and prevent render starvation, per lane
    
    If an update is CPU-bound for longer than expected according to its
    priority, we assume it's being starved by other work on the main thread.
    
    To detect this, we keep track of the elapsed time using a fixed-size
    array where each slot corresponds to a lane. What we actually store is
    the event time when the lane first became CPU-bound.
    
    Then, when receiving a new update or yielding to the main thread, we
    check how long each lane has been pending. If the time exceeds a
    threshold constant corresponding to its priority, we mark it as expired
    to force it to synchronously finish.
    
    We don't want to mistake time elapsed while an update is IO-bound
    (waiting for data to resolve) for time when it is CPU-bound. So when a
    lane suspends, we clear its associated event time from the array. When
    it receives a signal to try again, either a ping or an update, we assign
    a new event time to restart the clock.
    
    * Store as expiration time, not start time
    
    I originally stored the start time because I thought I could use this
    in the future to also measure Suspense timeouts. (Event times are
    currently stored on each update object for this purpose.) But that
    won't work because in the case of expiration times, we reset the clock
    whenever the update becomes IO-bound. So to replace the per-update
    field, I'm going to have to track those on the room separately from
    expiration times.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0f6daf6e05..246d68fac3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -23,7 +23,7 @@ import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
 import type {ExpirationTime} from './ReactFiberExpirationTime.old';
-import type {Lane, Lanes} from './ReactFiberLane';
+import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
@@ -226,7 +226,7 @@ type BaseFiberRootProperties = {|
   // Expiration of the callback associated with this root
   callbackExpirationTime: ExpirationTime,
   // Priority of the callback associated with this root
-  callbackPriority: ReactPriorityLevel,
+  callbackPriority_old: ReactPriorityLevel,
 
   finishedExpirationTime: ExpirationTime,
   // The earliest pending expiration time that exists in the tree
@@ -252,17 +252,8 @@ type BaseFiberRootProperties = {|
   // Represents the next task that the root should work on, or the current one
   // if it's already working.
   callbackId: Lanes,
-  // Whether the currently scheduled task for this root is synchronous or
-  // batched/concurrent. We have to track this because Scheduler does not
-  // support synchronous tasks, so we put those on a separate queue. So you
-  // could also think of this as "which queue is the callback scheduled with?"
-  callbackIsSync: boolean,
-  // Timestamp at which we will synchronously finish the current task to
-  // prevent starvation.
-  // TODO: There should be a separate expiration per lane.
-  // NOTE: This is not an "ExpirationTime" as used by the old reconciler. It's a
-  // timestamp, in milliseconds.
-  expiresAt: number,
+  callbackPriority_new: LanePriority,
+  expirationTimes: LaneMap<number>,
 
   pendingLanes: Lanes,
   suspendedLanes: Lanes,

commit 33589f7423fa498c97001898af730c461a1fdc7d
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 13 11:33:32 2020 -0700

    useMutableSource: "Entangle" instead of expiring (#18889)
    
    * useMutableSource: "Entangle" instead of expiring
    
    A lane is said to be entangled with another when it's not allowed to
    render in a batch that does not also include the other lane.
    
    This commit implements entanglement for `useMutableSource`. If a source
    is mutated in between when it's read in the render phase, but before
    it's subscribed to in the commit phase, we must account for whether the
    same source has pending mutations elsewhere. The old subscriptions must
    not be allowed to re-render without also including the new subscription
    (and vice versa), to prevent tearing.
    
    In the old reconciler, we did this by synchronously flushing all the
    pending subscription updates. This works, but isn't ideal. The new
    reconciler can entangle the updates without de-opting to sync.
    
    In the future, we plan to use this same mechanism for other features,
    like skipping over intermediate useTransition states.
    
    * Use clz instead of ctrz to pick an arbitrary lane
    
    Should be slightly faster since most engines have built-in support.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 246d68fac3..54b3825fa3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -262,6 +262,9 @@ type BaseFiberRootProperties = {|
   mutableReadLanes: Lanes,
 
   finishedLanes: Lanes,
+
+  entangledLanes: Lanes,
+  entanglements: LaneMap<Lanes>,
 |};
 
 // The following attributes are only used by interaction tracing builds.

commit 74394aa8cbb7a1c18c34018b099a9b5ab10ef11c
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu May 21 11:56:00 2020 -0700

    Add unstable_isNewReconciler to dispatcher (#18975)
    
    This is a bit gross but I need to be able to access it without importing
    the renderer.
    
    There might be a better way but I need this to unblock internal bugfix.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 54b3825fa3..16f4d95981 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -350,4 +350,6 @@ export type Dispatcher = {|
     subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
   ): Snapshot,
   useOpaqueIdentifier(): any,
+
+  unstable_isNewReconciler?: boolean,
 |};

commit 142d4f1c00c66f3d728177082dbc027fd6335115
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu May 21 16:00:46 2020 -0700

    useMutableSource hydration support (#18771)
    
    * useMutableSource hydration support
    
    * Remove unnecessary ReactMutableSource fork
    
    * Replaced root.registerMutableSourceForHydration() with mutableSources option
    
    * Response to PR feedback:
    
    1. Moved mutableSources root option to hydrationOptions object
    2. Only initialize root mutableSourceEagerHydrationData if supportsHydration config is true
    3. Lazily initialize mutableSourceEagerHydrationData on root object

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 16f4d95981..d97c543205 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -16,6 +16,7 @@ import type {
   ReactContext,
   MutableSourceSubscribeFn,
   MutableSourceGetSnapshotFn,
+  MutableSourceVersion,
   MutableSource,
 } from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
@@ -247,6 +248,11 @@ type BaseFiberRootProperties = {|
   // when external, mutable sources are read from during render.
   mutableSourceLastPendingUpdateTime: ExpirationTime,
 
+  // Used by useMutableSource hook to avoid tearing during hydrtaion.
+  mutableSourceEagerHydrationData?: Array<
+    MutableSource<any> | MutableSourceVersion,
+  > | null,
+
   // Only used by new reconciler
 
   // Represents the next task that the root should work on, or the current one

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index d97c543205..656437c64e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -23,7 +23,6 @@ import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
-import type {ExpirationTime} from './ReactFiberExpirationTime.old';
 import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
@@ -41,17 +40,7 @@ export type ContextDependency<T> = {
   ...
 };
 
-export type Dependencies_old = {
-  expirationTime: ExpirationTime,
-  firstContext: ContextDependency<mixed> | null,
-  responders: Map<
-    ReactEventResponder<any, any>,
-    ReactEventResponderInstance<any, any>,
-  > | null,
-  ...
-};
-
-export type Dependencies_new = {
+export type Dependencies = {
   lanes: Lanes,
   firstContext: ContextDependency<mixed> | null,
   responders: Map<
@@ -125,8 +114,7 @@ export type Fiber = {|
   memoizedState: any,
 
   // Dependencies (contexts, events) for this fiber, if it has any
-  dependencies_new: Dependencies_new | null,
-  dependencies_old: Dependencies_old | null,
+  dependencies: Dependencies | null,
 
   // Bitfield that describes properties about the fiber and its subtree. E.g.
   // the ConcurrentMode flag indicates whether the subtree should be async-by-
@@ -148,11 +136,6 @@ export type Fiber = {|
   firstEffect: Fiber | null,
   lastEffect: Fiber | null,
 
-  // Only used by old reconciler
-  expirationTime: ExpirationTime,
-  childExpirationTime: ExpirationTime,
-
-  // Only used by new reconciler
   lanes: Lanes,
   childLanes: Lanes,
 
@@ -222,43 +205,15 @@ type BaseFiberRootProperties = {|
   // Node returned by Scheduler.scheduleCallback
   callbackNode: *,
 
-  // Only used by old reconciler
-
-  // Expiration of the callback associated with this root
-  callbackExpirationTime: ExpirationTime,
-  // Priority of the callback associated with this root
-  callbackPriority_old: ReactPriorityLevel,
-
-  finishedExpirationTime: ExpirationTime,
-  // The earliest pending expiration time that exists in the tree
-  firstPendingTime: ExpirationTime,
-  // The latest pending expiration time that exists in the tree
-  lastPendingTime: ExpirationTime,
-  // The earliest suspended expiration time that exists in the tree
-  firstSuspendedTime: ExpirationTime,
-  // The latest suspended expiration time that exists in the tree
-  lastSuspendedTime: ExpirationTime,
-  // The next known expiration time after the suspended range
-  nextKnownPendingLevel: ExpirationTime,
-  // The latest time at which a suspended component pinged the root to
-  // render again
-  lastPingedTime: ExpirationTime,
-  lastExpiredTime: ExpirationTime,
-  // Used by useMutableSource hook to avoid tearing within this root
-  // when external, mutable sources are read from during render.
-  mutableSourceLastPendingUpdateTime: ExpirationTime,
-
   // Used by useMutableSource hook to avoid tearing during hydrtaion.
   mutableSourceEagerHydrationData?: Array<
     MutableSource<any> | MutableSourceVersion,
   > | null,
 
-  // Only used by new reconciler
-
   // Represents the next task that the root should work on, or the current one
   // if it's already working.
   callbackId: Lanes,
-  callbackPriority_new: LanePriority,
+  callbackPriority: LanePriority,
   expirationTimes: LaneMap<number>,
 
   pendingLanes: Lanes,
@@ -280,8 +235,7 @@ type BaseFiberRootProperties = {|
 type ProfilingOnlyFiberRootProperties = {|
   interactionThreadID: number,
   memoizedInteractions: Set<Interaction>,
-  pendingInteractionMap_new: Map<Lane | Lanes, Set<Interaction>>,
-  pendingInteractionMap_old: Map<ExpirationTime, Set<Interaction>>,
+  pendingInteractionMap: Map<Lane | Lanes, Set<Interaction>>,
 |};
 
 export type SuspenseHydrationCallbacks = {

commit 30b47103d4354d9187dc0f1fb804855a5208ca9f
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jun 15 19:59:44 2020 -0400

    Fix spelling errors and typos (#19138)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 656437c64e..648b3d537a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -205,7 +205,7 @@ type BaseFiberRootProperties = {|
   // Node returned by Scheduler.scheduleCallback
   callbackNode: *,
 
-  // Used by useMutableSource hook to avoid tearing during hydrtaion.
+  // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<
     MutableSource<any> | MutableSourceVersion,
   > | null,

commit a226b9b44591e2af85388fa88ddf76b3f3a9de6c
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Thu Jul 16 09:10:00 2020 -0400

    Effects list refactor continued: did-bailout flag (#19322)
    
    * Effects list rewrite
    
    * Improved deletions approach
    
    Process deletions as we traverse the tree during commit, before we process other effects. This has the result of better mimicking the previous sequencing.
    
    * Made deletions field nullable
    
    * Revert (no longer necessary) change to ReactNative test
    
    * Eagerly set Deletions effect on Fiber when adding child to deletions array
    
    * Initialize deletions array to null
    
    * Null out deletions array instead of splicing 🤡
    
    * Removed TODO comment
    
    * Initial exploration on a did-bailout flag
    
    * fixed the rest of the bugs
    
    * Rolled temporary didBailout attribute into subtreeTag
    
    * addressed comments
    
    * Removed DidBailout subtree tag
    
    * Removed stale comment
    
    * use while loop instead of recursion for siblings
    
    * move bailout flag from while loop
    
    * Removed some unnecessary Deletion effectTags from children
    
    * Move Deletion effect assignment to deletions array initialization
    
    Co-authored-by: Luna <lunaris.ruan@gmail.com>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 648b3d537a..1a638d42d5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -23,6 +23,7 @@ import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {SideEffectTag} from './ReactSideEffectTags';
+import type {SubtreeTag} from './ReactSubtreeTags';
 import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
@@ -126,6 +127,8 @@ export type Fiber = {|
 
   // Effect
   effectTag: SideEffectTag,
+  subtreeTag: SubtreeTag,
+  deletions: Array<Fiber> | null,
 
   // Singly linked list fast path to the next fiber with side-effects.
   nextEffect: Fiber | null,

commit b23ea02be507cc08747d49c1994f283514c5aeea
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Jul 17 12:47:39 2020 -0500

    Track event times per lane on the root (#19387)
    
    * Pass event time to markRootUpdated
    
    Some minor rearranging so that eventTime gets threaded through. No
    change in behavior.
    
    * Track event times per lane on the root
    
    Previous strategy was to store the event time on the update object
    and accumulate the most recent one during the render phase.
    
    Among other advantages, by tracking them on the root, we can read the
    event time before the render phase has finished.
    
    I haven't removed the `eventTime` field from the update object yet,
    because it's still used to compute the timeout. Tracking the timeout
    on the root is my next step.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1a638d42d5..51b8f9ec18 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -217,6 +217,7 @@ type BaseFiberRootProperties = {|
   // if it's already working.
   callbackId: Lanes,
   callbackPriority: LanePriority,
+  eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,
 
   pendingLanes: Lanes,

commit 96ac799eace5d989de3b4f80e6414e94a08ff77a
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Jul 27 12:39:07 2020 -0500

    Remove `callbackId` field from FiberRoot (#19458)
    
    The old expiration times implementation used this field to infer when
    the priority of a task had changed at a more granular level than a
    Scheduler priority level.
    
    Now that we have the LanePriority type, which is React-specific, we no
    longer need the `callbackId` field.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 51b8f9ec18..c6c83472e6 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -205,17 +205,15 @@ type BaseFiberRootProperties = {|
   pendingContext: Object | null,
   // Determines if we should attempt to hydrate on the initial mount
   +hydrate: boolean,
-  // Node returned by Scheduler.scheduleCallback
-  callbackNode: *,
 
   // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<
     MutableSource<any> | MutableSourceVersion,
   > | null,
 
-  // Represents the next task that the root should work on, or the current one
-  // if it's already working.
-  callbackId: Lanes,
+  // Node returned by Scheduler.scheduleCallback. Represents the next rendering
+  // task that the root will work on.
+  callbackNode: *,
   callbackPriority: LanePriority,
   eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,

commit b61174fb7b09580c1ec2a8f55e73204b706d2935
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed Aug 5 15:13:29 2020 +0100

    Remove the deprecated React Flare event system (#19520)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c6c83472e6..51cce04255 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -10,9 +10,6 @@
 import type {Source} from 'shared/ReactElementType';
 import type {
   RefObject,
-  ReactEventResponder,
-  ReactEventResponderListener,
-  ReactEventResponderInstance,
   ReactContext,
   MutableSourceSubscribeFn,
   MutableSourceGetSnapshotFn,
@@ -44,10 +41,6 @@ export type ContextDependency<T> = {
 export type Dependencies = {
   lanes: Lanes,
   firstContext: ContextDependency<mixed> | null,
-  responders: Map<
-    ReactEventResponder<any, any>,
-    ReactEventResponderInstance<any, any>,
-  > | null,
   ...
 };
 
@@ -298,10 +291,6 @@ export type Dispatcher = {|
     deps: Array<mixed> | void | null,
   ): void,
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
-  useResponder<E, C>(
-    responder: ReactEventResponder<E, C>,
-    props: Object,
-  ): ReactEventResponderListener<E, C>,
   useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T,
   useTransition(
     config: SuspenseConfig | void | null,

commit 92fcd46cc79bbf45df4ce86b0678dcef3b91078d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 28 12:52:56 2020 -0500

    Replace SuspenseConfig object with an integer (#19706)
    
    Now that the options in SuspenseConfig are no longer supported, the
    only thing we use it for is to track whether an update is part of
    a transition.
    
    I've renamed `ReactCurrentBatchConfig.suspense` to
    `ReactCurrentBatchConfig.transition`, and changed the type to a number.
    The number is always either 0 or 1. I could have made it a boolean;
    however, most likely this will eventually be either a Lane or an
    incrementing identifier.
    
    The `withSuspenseConfig` export still exists until we've removed
    all the callers from www.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 51cce04255..e58a8e1a80 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -27,7 +27,7 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
-import type {SuspenseConfig, TimeoutConfig} from './ReactFiberSuspenseConfig';
+import type {SuspenseConfig, TimeoutConfig} from './ReactFiberTransition';
 
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
 

commit ddd1faa1972b614dfbfae205f2aa4a6c0b39a759
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 28 13:49:01 2020 -0500

    Remove config argument from useTransition (#19719)
    
    And `useDeferredValue`.
    
    The options were already disabled in previous commits, so this doesn't
    change any behavior. I upated type signatures and cleaned up the hook
    implementation a bit — no longer have to wrap the `start` method with
    `useCallback`, because its only remaining dependency is a `setState`
    method, which never changes. Instead, we can store the `start` method
    on a ref.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e58a8e1a80..ef7d1ea763 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -27,7 +27,6 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
-import type {SuspenseConfig, TimeoutConfig} from './ReactFiberTransition';
 
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
 
@@ -291,10 +290,8 @@ export type Dispatcher = {|
     deps: Array<mixed> | void | null,
   ): void,
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
-  useDeferredValue<T>(value: T, config: TimeoutConfig | void | null): T,
-  useTransition(
-    config: SuspenseConfig | void | null,
-  ): [(() => void) => void, boolean],
+  useDeferredValue<T>(value: T): T,
+  useTransition(): [(() => void) => void, boolean],
   useMutableSource<Source, Snapshot>(
     source: MutableSource<Source>,
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,

commit 16654436039dd8f16a63928e71081c7745872e8f
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Sep 4 16:34:07 2020 -0500

    Rename effect fields (#19755)
    
    - `effectTag` -> `flags`
    - `subtreeTag` -> `subtreeFlags`

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index ef7d1ea763..728aadf3f8 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -19,8 +19,8 @@ import type {
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
-import type {SideEffectTag} from './ReactSideEffectTags';
-import type {SubtreeTag} from './ReactSubtreeTags';
+import type {Flags} from './ReactFiberFlags';
+import type {SubtreeFlags} from './ReactSubtreeFlags';
 import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
@@ -118,8 +118,8 @@ export type Fiber = {|
   mode: TypeOfMode,
 
   // Effect
-  effectTag: SideEffectTag,
-  subtreeTag: SubtreeTag,
+  flags: Flags,
+  subtreeFlags: SubtreeFlags,
   deletions: Array<Fiber> | null,
 
   // Singly linked list fast path to the next fiber with side-effects.

commit 7baf9d4128d41903de125527b50285ea9862cf9a
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Sep 4 16:48:30 2020 -0500

    Combine Flags and SubtreeFlags types (#19775)
    
    Because the `subtreeFlags` is the union of all the flags present in
    a subtree, we can use the same type as `flags`.
    
    One practical benefit is that we can bubble up the flags from the
    children with a single `|=` operator.
    
    Structurally, everything else about the effect algorithm is unchanged.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 728aadf3f8..cebc8725cc 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -20,7 +20,6 @@ import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
-import type {SubtreeFlags} from './ReactSubtreeFlags';
 import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
 import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
@@ -119,7 +118,7 @@ export type Fiber = {|
 
   // Effect
   flags: Flags,
-  subtreeFlags: SubtreeFlags,
+  subtreeFlags: Flags,
   deletions: Array<Fiber> | null,
 
   // Singly linked list fast path to the next fiber with side-effects.

commit 2fbcc98066667848a0eb103e7f0afa540cbb475b
Author: Paul Doyle <37384169+ZoteTheMighty@users.noreply.github.com>
Date:   Fri Nov 13 06:18:24 2020 -0800

    Remove cycle between ReactFiberHooks and ReactInternalTypes (#20242)
    
    Co-authored-by: Paul Doyle <pauldoyle22@gmail.com>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index cebc8725cc..f63495cdce 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -21,12 +21,28 @@ import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
 import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
-import type {HookType} from './ReactFiberHooks.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
 
+// Unwind Circular: moved from ReactFiberHooks.old
+export type HookType =
+  | 'useState'
+  | 'useReducer'
+  | 'useContext'
+  | 'useRef'
+  | 'useEffect'
+  | 'useLayoutEffect'
+  | 'useCallback'
+  | 'useMemo'
+  | 'useImperativeHandle'
+  | 'useDebugValue'
+  | 'useDeferredValue'
+  | 'useTransition'
+  | 'useMutableSource'
+  | 'useOpaqueIdentifier';
+
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
 
 export type ContextDependency<T> = {

commit e23673b511a2eab6ddcb848a4150105c954f289a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Dec 3 03:44:56 2020 +0000

    [Flight] Add getCacheForType() to the dispatcher (#20315)
    
    * Remove react/unstable_cache
    
    We're probably going to make it available via the dispatcher. Let's remove this for now.
    
    * Add readContext() to the dispatcher
    
    On the server, it will be per-request.
    
    On the client, there will be some way to shadow it.
    
    For now, I provide it on the server, and throw on the client.
    
    * Use readContext() from react-fetch
    
    This makes it work on the server (but not on the client until we implement it there.)
    
    Updated the test to use Server Components. Now it passes.
    
    * Fixture: Add fetch from a Server Component
    
    * readCache -> getCacheForType<T>
    
    * Add React.unstable_getCacheForType
    
    * Add a feature flag
    
    * Fix Flow
    
    * Add react-suspense-test-utils and port tests
    
    * Remove extra Map lookup
    
    * Unroll async/await because build system
    
    * Add some error coverage and retry
    
    * Add unstable_getCacheForType to Flight entry

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f63495cdce..ce3f786a51 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -274,6 +274,7 @@ type BasicStateAction<S> = (S => S) | S;
 type Dispatch<A> = A => void;
 
 export type Dispatcher = {|
+  getCacheForType?: <T>(resourceType: () => T) => T,
   readContext<T>(
     context: ReactContext<T>,
     observedBits: void | number | boolean,

commit 88ef95712d315705b2d6654f3c0d5c5ace4a6456
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Dec 4 10:54:09 2020 -0600

    Fork ReactFiberLane (#20371)
    
    This wasn't forked previously because Lane and associated types are
    opaque, and they leak into non-reconciler packages. So forking the type
    would also require forking all those other packages.
    
    But I really want to use the reconciler fork infra for lanes changes.
    So I made them no longer opaque.
    
    Another possible solution would be to add separate `new` and `old`
    fields to the Fiber type, like I did when migrating from expiration
    times. But that seems so excessive. This seems fine.
    
    But we should still treat them like they're opaque and only do lanes
    manipulation in the ReactFiberLane module. At least until the model
    stabilizes more. We'll just need to enforce this with discipline
    instead of with the type system.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index ce3f786a51..c48d53fbb9 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -20,7 +20,7 @@ import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
-import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane';
+import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';

commit efc57e5cbbd618f3c98d941c48eec859026c2dcb
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Dec 18 12:57:24 2020 -0600

    Add built-in Suspense cache with support for invalidation (refreshing) (#20456)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c48d53fbb9..cb34ac7494 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -25,6 +25,7 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Interaction} from 'scheduler/src/Tracing';
+import type {Cache} from './ReactFiberCacheComponent.old';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -41,7 +42,8 @@ export type HookType =
   | 'useDeferredValue'
   | 'useTransition'
   | 'useMutableSource'
-  | 'useOpaqueIdentifier';
+  | 'useOpaqueIdentifier'
+  | 'useCacheRefresh';
 
 export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
 
@@ -235,6 +237,9 @@ type BaseFiberRootProperties = {|
 
   entangledLanes: Lanes,
   entanglements: LaneMap<Lanes>,
+
+  pooledCache: Cache | null,
+  pooledCacheLanes: Lanes,
 |};
 
 // The following attributes are only used by interaction tracing builds.
@@ -314,6 +319,7 @@ export type Dispatcher = {|
     subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
   ): Snapshot,
   useOpaqueIdentifier(): any,
+  useCacheRefresh?: () => <T>(?() => T, ?T) => void,
 
   unstable_isNewReconciler?: boolean,
 |};

commit 258b375a419098a5b6c3568e8d35046d142ea912
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 25 16:42:11 2021 -0600

    Move context comparison to consumer
    
    In the lazy context implementation, not all context changes are
    propagated from the provider, so we can't rely on the propagation alone
    to mark the consumer as dirty. The consumer needs to compare to the
    previous value, like we do for state and context.
    
    I added a `memoizedValue` field to the context dependency type. Then in
    the consumer, we iterate over the current dependencies to see if
    something changed. We only do this iteration after props and state has
    already bailed out, so it's a relatively uncommon path, except at the
    root of a changed subtree. Alternatively, we could move these
    comparisons into `readContext`, but that's a much hotter path, so I
    think this is an appropriate trade off.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index cb34ac7494..b1764bed5a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -51,6 +51,7 @@ export type ContextDependency<T> = {
   context: ReactContext<T>,
   observedBits: number,
   next: ContextDependency<mixed> | null,
+  memoizedValue: T,
   ...
 };
 

commit 6d3ecb70dceb225af0cd990b46d6c44b852c1d82
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 19 17:36:51 2021 -0500

    Remove unstable_changedBits (#20953)
    
    We added this unstable feature a few years ago, as a way to opt out of
    context updates, but it didn't prove useful in practice.
    
    We have other proposals for how to address the same problem, like
    context selectors.
    
    Since it was prefixed with `unstable_`, we should be able to remove it
    without consequence. The hook API already warned if you used it.
    
    Even if someone is using it somewhere, it's meant to be an optimization
    only, so if they are using the API properly, it should not have any
    semantic impact.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index b1764bed5a..e5fd43e6f4 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -49,7 +49,6 @@ export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
-  observedBits: number,
   next: ContextDependency<mixed> | null,
   memoizedValue: T,
   ...
@@ -281,20 +280,14 @@ type Dispatch<A> = A => void;
 
 export type Dispatcher = {|
   getCacheForType?: <T>(resourceType: () => T) => T,
-  readContext<T>(
-    context: ReactContext<T>,
-    observedBits: void | number | boolean,
-  ): T,
+  readContext<T>(context: ReactContext<T>): T,
   useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],
   useReducer<S, I, A>(
     reducer: (S, A) => S,
     initialArg: I,
     init?: (I) => S,
   ): [S, Dispatch<A>],
-  useContext<T>(
-    context: ReactContext<T>,
-    observedBits: void | number | boolean,
-  ): T,
+  useContext<T>(context: ReactContext<T>): T,
   useRef<T>(initialValue: T): {|current: T|},
   useEffect(
     create: () => (() => void) | void,

commit 05ec0d7646b463dcbd64f3a2575f4bb992f7e423
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 25 11:24:49 2021 -0500

    Entangled expired lanes with SyncLane (#21083)
    
    Makes the implementation simpler. Expiration is now a special case of
    entanglement.
    
    Also fixes an issue where expired lanes weren't batched with normal
    sync updates. (See deleted TODO comment in test.)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e5fd43e6f4..4e5a415f16 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -230,7 +230,6 @@ type BaseFiberRootProperties = {|
   pendingLanes: Lanes,
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
-  expiredLanes: Lanes,
   mutableReadLanes: Lanes,
 
   finishedLanes: Lanes,

commit dcd13045ef5d4e42bbda6ec2a493ac2ea507c018
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Mar 28 15:58:46 2021 -0500

    Use Lane to track root callback priority (#21089)
    
    Instead of LanePriority.
    
    I'm removing all uses of LanePriority so I can delete it.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 4e5a415f16..95aa2483ee 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -20,7 +20,7 @@ import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
-import type {Lane, LanePriority, Lanes, LaneMap} from './ReactFiberLane.old';
+import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
@@ -223,7 +223,7 @@ type BaseFiberRootProperties = {|
   // Node returned by Scheduler.scheduleCallback. Represents the next rendering
   // task that the root will work on.
   callbackNode: *,
-  callbackPriority: LanePriority,
+  callbackPriority: Lane,
   eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,
 

commit 3ba5c87377710e154351aebc818df3d33ee6a718
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Mar 28 16:13:38 2021 -0500

    Remove Scheduler indirection (#21107)
    
    * Bump version number
    
    * Remove Scheduler indirection
    
    I originally kept the React PriorityLevel and Scheduler PriorityLevel
    types separate in case there was a versioning mismatch between the two
    modules. However, it looks like we're going to keep the Scheduler module
    private in the short to medium term, and longer term the public
    interface will match postTask. So, I've removed the extra indirection
    (the switch statements that convert between the two types).

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 95aa2483ee..4ad4cb122b 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -45,8 +45,6 @@ export type HookType =
   | 'useOpaqueIdentifier'
   | 'useCacheRefresh';
 
-export type ReactPriorityLevel = 99 | 98 | 97 | 96 | 95 | 90;
-
 export type ContextDependency<T> = {
   context: ReactContext<T>,
   next: ContextDependency<mixed> | null,

commit dc108b0f55387c811899aeb92e583294b0707b1c
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Fri Apr 9 10:34:33 2021 -0400

    Track which fibers scheduled the current render work (#15658)
    
    Tracked Fibers are called "updaters" and are exposed to DevTools via a 'memoizedUpdaters' property on the ReactFiberRoot. The implementation of this feature follows a vaguely similar approach as interaction tracing, but does not require reference counting since there is no subscriptions API.
    
    This change is in support of a new DevTools Profiler feature that shows which Fiber(s) scheduled the selected commit in the Profiler.
    
    All changes have been gated behind a new feature flag, 'enableUpdaterTracking', which is enabled for Profiling builds by default. We also only track updaters when DevTools has been detected, to avoid doing unnecessary work.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 4ad4cb122b..0c34eeda8e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -249,6 +249,13 @@ type ProfilingOnlyFiberRootProperties = {|
   pendingInteractionMap: Map<Lane | Lanes, Set<Interaction>>,
 |};
 
+// The following attributes are only used by DevTools and are only present in DEV builds.
+// They enable DevTools Profiler UI to show which Fiber(s) scheduled a given commit.
+type UpdaterTrackingOnlyFiberRootProperties = {|
+  memoizedUpdaters: Set<Fiber>,
+  pendingUpdatersLaneMap: LaneMap<Set<Fiber>>,
+|};
+
 export type SuspenseHydrationCallbacks = {
   onHydrated?: (suspenseInstance: SuspenseInstance) => void,
   onDeleted?: (suspenseInstance: SuspenseInstance) => void,
@@ -269,6 +276,7 @@ export type FiberRoot = {
   ...BaseFiberRootProperties,
   ...ProfilingOnlyFiberRootProperties,
   ...SuspenseCallbackOnlyFiberRootProperties,
+  ...UpdaterTrackingOnlyFiberRootProperties,
   ...
 };
 

commit a632f7de3bd35eaf6d5082054af4da92dd37cf20
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Apr 20 12:21:44 2021 -0400

    Flip tuple order of useTransition (#20976)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0c34eeda8e..08f5cbc2d0 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -311,7 +311,7 @@ export type Dispatcher = {|
   ): void,
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
   useDeferredValue<T>(value: T): T,
-  useTransition(): [(() => void) => void, boolean],
+  useTransition(): [boolean, (() => void) => void],
   useMutableSource<Source, Snapshot>(
     source: MutableSource<Source>,
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,

commit 48740429b4a74e984193e4e2d364d461e4fdc3be
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Apr 24 18:32:48 2021 -0500

    Expiration: Do nothing except disable time slicing (#21345)
    
    We have a feature called "expiration" whose purpose is to prevent
    a concurrent update from being starved by higher priority events.
    If a lane is CPU-bound for too long, we finish the rest of the work
    synchronously without allowing further interruptions.
    
    In the current implementation, we do this in sort of a roundabout way:
    once a lane is determined to have expired, we entangle it with SyncLane
    and switch to the synchronous work loop.
    
    There are a few flaws with the approach. One is that SyncLane has a
    particular semantic meaning besides its non-yieldiness. For example,
    `flushSync` will force remaining Sync work to finish; currently, that
    also includes expired work, which isn't an intended behavior, but rather
    an artifact of the implementation.
    
    An event worse example is that passive effects triggered by a Sync
    update are flushed synchronously, before paint, so that its result
    is guaranteed to be observed by the next discrete event. But expired
    work has no such requirement: we're flushing expired effects before
    paint unnecessarily.
    
    Aside from the behaviorial implications, the current implementation has
    proven to be fragile: more than once, we've accidentally regressed
    performance due to a subtle change in how expiration is handled.
    
    This PR aims to radically simplify how we model starvation protection by
    scaling back the implementation as much as possible. In this new model,
    if a lane is expired, we disable time slicing. That's it. We don't
    entangle it with SyncLane. The only thing we do is skip the call to
    `shouldYield` in between each time slice. This is identical to how we
    model synchronous-by-default updates in React 18.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 08f5cbc2d0..6d7d38232e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -228,6 +228,7 @@ type BaseFiberRootProperties = {|
   pendingLanes: Lanes,
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
+  expiredLanes: Lanes,
   mutableReadLanes: Lanes,
 
   finishedLanes: Lanes,

commit fc33f12bdee1d0ffbcc83d25199cdf4d47252736
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Mon Apr 26 19:16:18 2021 -0400

    Remove unstable scheduler/tracing API (#20037)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 6d7d38232e..104a9ef728 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -24,7 +24,6 @@ import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
-import type {Interaction} from 'scheduler/src/Tracing';
 import type {Cache} from './ReactFiberCacheComponent.old';
 
 // Unwind Circular: moved from ReactFiberHooks.old
@@ -240,16 +239,6 @@ type BaseFiberRootProperties = {|
   pooledCacheLanes: Lanes,
 |};
 
-// The following attributes are only used by interaction tracing builds.
-// They enable interactions to be associated with their async work,
-// And expose interaction metadata to the React DevTools Profiler plugin.
-// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
-type ProfilingOnlyFiberRootProperties = {|
-  interactionThreadID: number,
-  memoizedInteractions: Set<Interaction>,
-  pendingInteractionMap: Map<Lane | Lanes, Set<Interaction>>,
-|};
-
 // The following attributes are only used by DevTools and are only present in DEV builds.
 // They enable DevTools Profiler UI to show which Fiber(s) scheduled a given commit.
 type UpdaterTrackingOnlyFiberRootProperties = {|
@@ -270,12 +259,9 @@ type SuspenseCallbackOnlyFiberRootProperties = {|
 
 // Exported FiberRoot type includes all properties,
 // To avoid requiring potentially error-prone :any casts throughout the project.
-// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
 // The types are defined separately within this file to ensure they stay in sync.
-// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
 export type FiberRoot = {
   ...BaseFiberRootProperties,
-  ...ProfilingOnlyFiberRootProperties,
   ...SuspenseCallbackOnlyFiberRootProperties,
   ...UpdaterTrackingOnlyFiberRootProperties,
   ...

commit 0d493dcda96fc86242cf9a05a44130978a56fbdd
Author: Pulkit Sharma <75886411+Pulkit3234@users.noreply.github.com>
Date:   Thu May 27 02:23:18 2021 +0530

    Removed _debugID field from Fiber - Issue #21558 (#21570)
    
    * Removed _debugID field from Fiber
    * Update ReactFunctionComponent-test.js
    
    Co-authored-by: Brian Vaughn <brian.david.vaughn@gmail.com>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 104a9ef728..5a4bc62374 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -178,7 +178,7 @@ export type Fiber = {|
   // workInProgress : Fiber ->  alternate The alternate used for reuse happens
   // to be the same as work in progress.
   // __DEV__ only
-  _debugID?: number,
+
   _debugSource?: Source | null,
   _debugOwner?: Fiber | null,
   _debugIsCurrentlyTiming?: boolean,

commit 77912d9a05d7a90287fabdec76486f25869b2981
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 7 13:20:24 2021 -0400

    Wire up the native API for useSyncExternalStore (#22237)
    
    Adds useSyncExternalStore to the internal dispatcher, and exports
    the native API from the React package without yet implementing it.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 5a4bc62374..33bdb24af0 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -41,6 +41,7 @@ export type HookType =
   | 'useDeferredValue'
   | 'useTransition'
   | 'useMutableSource'
+  | 'useSyncExternalStore'
   | 'useOpaqueIdentifier'
   | 'useCacheRefresh';
 
@@ -304,6 +305,10 @@ export type Dispatcher = {|
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
     subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
   ): Snapshot,
+  useSyncExternalStore<T>(
+    subscribe: (() => void) => () => void,
+    getSnapshot: () => T,
+  ): T,
   useOpaqueIdentifier(): any,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
 

commit 263cfa6ecb9879ecb629d4e04a8c26422b4c4ff9
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Sep 14 10:27:09 2021 -0400

    [Experimental] Add useInsertionEffect (#21913)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 33bdb24af0..f07fd4634b 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -33,6 +33,7 @@ export type HookType =
   | 'useContext'
   | 'useRef'
   | 'useEffect'
+  | 'useInsertionEffect'
   | 'useLayoutEffect'
   | 'useCallback'
   | 'useMemo'
@@ -286,6 +287,10 @@ export type Dispatcher = {|
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
+  useInsertionEffect(
+    create: () => (() => void) | void,
+    deps: Array<mixed> | void | null,
+  ): void,
   useLayoutEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 8209de269531767b33d8db26eda41db38bfb6a27
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 20 00:11:50 2021 -0400

    Delete useMutableSource implementation (#22292)
    
    This API was replaced by useSyncExternalStore

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f07fd4634b..692ec27bd7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -8,14 +8,7 @@
  */
 
 import type {Source} from 'shared/ReactElementType';
-import type {
-  RefObject,
-  ReactContext,
-  MutableSourceSubscribeFn,
-  MutableSourceGetSnapshotFn,
-  MutableSourceVersion,
-  MutableSource,
-} from 'shared/ReactTypes';
+import type {RefObject, ReactContext} from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -41,7 +34,6 @@ export type HookType =
   | 'useDebugValue'
   | 'useDeferredValue'
   | 'useTransition'
-  | 'useMutableSource'
   | 'useSyncExternalStore'
   | 'useOpaqueIdentifier'
   | 'useCacheRefresh';
@@ -214,11 +206,6 @@ type BaseFiberRootProperties = {|
   // Determines if we should attempt to hydrate on the initial mount
   +hydrate: boolean,
 
-  // Used by useMutableSource hook to avoid tearing during hydration.
-  mutableSourceEagerHydrationData?: Array<
-    MutableSource<any> | MutableSourceVersion,
-  > | null,
-
   // Node returned by Scheduler.scheduleCallback. Represents the next rendering
   // task that the root will work on.
   callbackNode: *,
@@ -230,7 +217,6 @@ type BaseFiberRootProperties = {|
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
   expiredLanes: Lanes,
-  mutableReadLanes: Lanes,
 
   finishedLanes: Lanes,
 
@@ -305,11 +291,6 @@ export type Dispatcher = {|
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
   useDeferredValue<T>(value: T): T,
   useTransition(): [boolean, (() => void) => void],
-  useMutableSource<Source, Snapshot>(
-    source: MutableSource<Source>,
-    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
-    subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
-  ): Snapshot,
   useSyncExternalStore<T>(
     subscribe: (() => void) => () => void,
     getSnapshot: () => T,

commit 86b3e2461da28d9c074b04f42e4ca69773902fec
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Sep 20 11:31:02 2021 -0400

    Implement useSyncExternalStore on server (#22347)
    
    Adds a third argument called `getServerSnapshot`.
    
    On the server, React calls this one instead of the normal `getSnapshot`.
    We also call it during hydration.
    
    So it represents the snapshot that is used to generate the initial,
    server-rendered HTML. The purpose is to avoid server-client mismatches.
    What we render during hydration needs to match up exactly with what we
    render on the server.
    
    The pattern is for the server to send down a serialized copy of the
    store that was used to generate the initial HTML. On the client, React
    will call either `getSnapshot` or `getServerSnapshot` on the client as
    appropriate, depending on whether it's currently hydrating.
    
    The argument is optional for fully client rendered use cases. If the
    user does attempt to omit `getServerSnapshot`, and the hook is called
    on the server, React will abort that subtree on the server and
    revert to client rendering, up to the nearest Suspense boundary.
    
    For the userspace shim, we will need to use a heuristic (canUseDOM)
    to determine whether we are in a server environment. I'll do that in
    a follow up.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 692ec27bd7..bf7ffb2b33 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -294,6 +294,7 @@ export type Dispatcher = {|
   useSyncExternalStore<T>(
     subscribe: (() => void) => () => void,
     getSnapshot: () => T,
+    getServerSnapshot?: () => T,
   ): T,
   useOpaqueIdentifier(): any,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,

commit 82c8fa90be86fc0afcbff2dc39486579cff1ac9a
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 21 23:38:24 2021 -0400

    Add back useMutableSource temporarily (#22396)
    
    Recoil uses useMutableSource behind a flag. I thought this was fine
    because Recoil isn't used in any concurrent roots, so the behavior
    would be the same, but it turns out that it is used by concurrent
    roots in a few places.
    
    I'm not expecting it to be hard to migrate to useSyncExternalStore, but
    to de-risk the change I'm going to roll it out gradually with a flag. In
    the meantime, I've added back the useMutableSource API.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index bf7ffb2b33..673298b8da 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -8,7 +8,14 @@
  */
 
 import type {Source} from 'shared/ReactElementType';
-import type {RefObject, ReactContext} from 'shared/ReactTypes';
+import type {
+  RefObject,
+  ReactContext,
+  MutableSourceSubscribeFn,
+  MutableSourceGetSnapshotFn,
+  MutableSourceVersion,
+  MutableSource,
+} from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -34,6 +41,7 @@ export type HookType =
   | 'useDebugValue'
   | 'useDeferredValue'
   | 'useTransition'
+  | 'useMutableSource'
   | 'useSyncExternalStore'
   | 'useOpaqueIdentifier'
   | 'useCacheRefresh';
@@ -206,6 +214,11 @@ type BaseFiberRootProperties = {|
   // Determines if we should attempt to hydrate on the initial mount
   +hydrate: boolean,
 
+  // Used by useMutableSource hook to avoid tearing during hydration.
+  mutableSourceEagerHydrationData?: Array<
+    MutableSource<any> | MutableSourceVersion,
+  > | null,
+
   // Node returned by Scheduler.scheduleCallback. Represents the next rendering
   // task that the root will work on.
   callbackNode: *,
@@ -217,6 +230,7 @@ type BaseFiberRootProperties = {|
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
   expiredLanes: Lanes,
+  mutableReadLanes: Lanes,
 
   finishedLanes: Lanes,
 
@@ -291,6 +305,11 @@ export type Dispatcher = {|
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
   useDeferredValue<T>(value: T): T,
   useTransition(): [boolean, (() => void) => void],
+  useMutableSource<Source, Snapshot>(
+    source: MutableSource<Source>,
+    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
+    subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+  ): Snapshot,
   useSyncExternalStore<T>(
     subscribe: (() => void) => () => void,
     getSnapshot: () => T,

commit 029fdcebbfec51a28af27cd390dff8668bf136cf
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Sep 24 13:45:46 2021 -0400

    root.hydrate -> root.isDehydrated (#22420)
    
    I think this naming is a bit clearer. It means the root is currently
    showing server rendered content that needs to be hydrated.
    
    A dehydrated root is conceptually the same as what we call dehydrated
    Suspense boundary, so this makes the naming of the root align with the
    naming of subtrees.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 673298b8da..f079b3e8f2 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -212,7 +212,7 @@ type BaseFiberRootProperties = {|
   context: Object | null,
   pendingContext: Object | null,
   // Determines if we should attempt to hydrate on the initial mount
-  +hydrate: boolean,
+  +isDehydrated: boolean,
 
   // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<

commit fa9bea0c41ccfef5b528ef9b5517607f9f94c52a
Author: Joseph Savona <joesavona@fb.com>
Date:   Thu Oct 21 14:11:42 2021 -0700

    Initial implementation of cache cleanup (#22510)
    
    This is an initial, partial implementation of a cleanup mechanism for the experimental Cache API. The idea is that consumers of the Cache API can register to be informed when a given Cache instance is no longer needed so that they can perform associated cleanup tasks to free resources stored in the cache. A canonical example would be cancelling pending network requests.
    
    An overview of the high-level changes:
    
    * Changes the `Cache` type from a Map of cache instances to be an object with the original Map of instances, a reference count (to count roughly "active references" to the cache instances - more below), and an AbortController.
    * Adds a new public API, `unstable_getCacheSignal(): AbortSignal`, which is callable during render. It returns an AbortSignal tied to the lifetime of the cache - developers can listen for the 'abort' event on the signal, which React now triggers when a given cache instance is no longer referenced.
      * Note that `AbortSignal` is a web standard that is supported by other platform APIs; for example a signal can be passed to `fetch()` to trigger cancellation of an HTTP request.
    * Implements the above - triggering the 'abort' event - by handling passive mount/unmount for HostRoot and CacheComponent fiber nodes.
    
    Cases handled:
    * Aborted transitions: we clean up a new cache created for an aborted transition
    * Suspense: we retain a fresh cache instance until a suspended tree resolves
    
    For follow-ups:
    * When a subsequent cache refresh is issued before a previous refresh completes, the refreshes are queued. Fresh cache instances for previous refreshes in the queue should be cleared, retaining only the most recent cache. I plan to address this in a follow-up PR.
    * If a refresh is cancelled, the fresh cache should be cleaned up.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f079b3e8f2..e971828233 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -273,6 +273,7 @@ type BasicStateAction<S> = (S => S) | S;
 type Dispatch<A> = A => void;
 
 export type Dispatcher = {|
+  getCacheSignal?: () => AbortSignal,
   getCacheForType?: <T>(resourceType: () => T) => T,
   readContext<T>(context: ReactContext<T>): T,
   useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],

commit ebf9ae8579230e7b1ed0b1d243e1cf802f56938b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 1 16:30:44 2021 -0400

    useId (#22644)
    
    * Add useId to dispatcher
    
    * Initial useId implementation
    
    Ids are base 32 strings whose binary representation corresponds to the
    position of a node in a tree.
    
    Every time the tree forks into multiple children, we add additional bits
    to the left of the sequence that represent the position of the child
    within the current level of children.
    
        00101       00010001011010101
        ╰─┬─╯       ╰───────┬───────╯
      Fork 5 of 20       Parent id
    
    The leading 0s are important. In the above example, you only need 3 bits
    to represent slot 5. However, you need 5 bits to represent all the forks
    at the current level, so we must account for the empty bits at the end.
    
    For this same reason, slots are 1-indexed instead of 0-indexed.
    Otherwise, the zeroth id at a level would be indistinguishable from
    its parent.
    
    If a node has only one child, and does not materialize an id (i.e. does
    not contain a useId hook), then we don't need to allocate any space in
    the sequence. It's treated as a transparent indirection. For example,
    these two trees produce the same ids:
    
    <>                          <>
      <Indirection>               <A />
        <A />                     <B />
      </Indirection>            </>
      <B />
    </>
    
    However, we cannot skip any materializes an id. Otherwise, a parent id
    that does not fork would be indistinguishable from its child id. For
    example, this tree does not fork, but the parent and child must have
    different ids.
    
    <Parent>
      <Child />
    </Parent>
    
    To handle this scenario, every time we materialize an id, we allocate a
    new level with a single slot. You can think of this as a fork with only
    one prong, or an array of children with length 1.
    
    It's possible for the the size of the sequence to exceed 32 bits, the
    max size for bitwise operations. When this happens, we make more room by
    converting the right part of the id to a string and storing it in an
    overflow variable. We use a base 32 string representation, because 32 is
    the largest power of 2 that is supported by toString(). We want the base
    to be large so that the resulting ids are compact, and we want the base
    to be a power of 2 because every log2(base) bits corresponds to a single
    character, i.e. every log2(32) = 5 bits. That means we can lop bits off
    the end 5 at a time without affecting the final result.
    
    * Incremental hydration
    
    Stores the tree context on the dehydrated Suspense boundary's state
    object so it resume where it left off.
    
    * Add useId to react-debug-tools
    
    * Add selective hydration test
    
    Demonstrates that selective hydration works and ids are preserved even
    after subsequent client updates.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e971828233..9dac4f40aa 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -44,6 +44,7 @@ export type HookType =
   | 'useMutableSource'
   | 'useSyncExternalStore'
   | 'useOpaqueIdentifier'
+  | 'useId'
   | 'useCacheRefresh';
 
 export type ContextDependency<T> = {
@@ -317,6 +318,7 @@ export type Dispatcher = {|
     getServerSnapshot?: () => T,
   ): T,
   useOpaqueIdentifier(): any,
+  useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
 
   unstable_isNewReconciler?: boolean,

commit 75f3ddebfa0d9885ce8df42571cf0c09ad6c0a3b
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 1 18:02:39 2021 -0400

    Remove experimental useOpaqueIdentifier API (#22672)
    
    useId is the updated version of this API.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 9dac4f40aa..db96410383 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -43,7 +43,6 @@ export type HookType =
   | 'useTransition'
   | 'useMutableSource'
   | 'useSyncExternalStore'
-  | 'useOpaqueIdentifier'
   | 'useId'
   | 'useCacheRefresh';
 
@@ -317,7 +316,6 @@ export type Dispatcher = {|
     getSnapshot: () => T,
     getServerSnapshot?: () => T,
   ): T,
-  useOpaqueIdentifier(): any,
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
 

commit 4729ff6d1f191902897927ff4ecd3d1f390177fa
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Dec 2 20:49:43 2021 -0500

    Implement identifierPrefix option for useId (#22855)
    
    When an `identifierPrefix` option is given, React will add it to the
    beginning of ids generated by `useId`.
    
    The main use case is to avoid conflicts when there are multiple React
    roots on a single page.
    
    The server API already supported an `identifierPrefix` option. It's not
    only used by `useId`, but also for React-generated ids that are used to
    stitch together chunks of HTML, among other things. I added a
    corresponding option to the client.
    
    You must pass the same prefix option to both the server and client.
    Eventually we may make this automatic by sending the prefix from the
    server as part of the HTML stream.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index db96410383..13965720b7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -239,6 +239,13 @@ type BaseFiberRootProperties = {|
 
   pooledCache: Cache | null,
   pooledCacheLanes: Lanes,
+
+  // TODO: In Fizz, id generation is specific to each server config. Maybe we
+  // should do this in Fiber, too? Deferring this decision for now because
+  // there's no other place to store the prefix except for an internal field on
+  // the public createRoot object, which the fiber tree does not currently have
+  // a reference to.
+  identifierPrefix: string,
 |};
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit 848e802d203e531daf2b9b0edb281a1eb6c5415d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Feb 4 07:57:33 2022 -0800

    Add onRecoverableError option to hydrateRoot, createRoot (#23207)
    
    * [RFC] Add onHydrationError option to hydrateRoot
    
    This is not the final API but I'm pushing it for discussion purposes.
    
    When an error is thrown during hydration, we fallback to client
    rendering, without triggering an error boundary. This is good because,
    in many cases, the UI will recover and the user won't even notice that
    something has gone wrong behind the scenes.
    
    However, we shouldn't recover from these errors silently, because the
    underlying cause might be pretty serious. Server-client mismatches are
    not supposed to happen, even if UI doesn't break from the users
    perspective. Ignoring them could lead to worse problems later. De-opting
    from server to client rendering could also be a significant performance
    regression, depending on the scope of the UI it affects.
    
    So we need a way to log when hydration errors occur.
    
    This adds a new option for `hydrateRoot` called `onHydrationError`. It's
    symmetrical to the server renderer's `onError` option, and serves the
    same purpose.
    
    When no option is provided, the default behavior is to schedule a
    browser task and rethrow the error. This will trigger the normal browser
    behavior for errors, including dispatching an error event. If the app
    already has error monitoring, this likely will just work as expected
    without additional configuration.
    
    However, we can also expose additional metadata about these errors, like
    which Suspense boundaries were affected by the de-opt to client
    rendering. (I have not exposed any metadata in this commit; API needs
    more design work.)
    
    There are other situations besides hydration where we recover from an
    error without surfacing it to the user, or notifying an error boundary.
    For example, if an error occurs during a concurrent render, it could be
    due to a data race, so we try again synchronously in case that fixes it.
    We should probably expose a way to log these types of errors, too. (Also
    not implemented in this commit.)
    
    * Log all recoverable errors
    
    This expands the scope of onHydrationError to include all errors that
    are not surfaced to the UI (an error boundary). In addition to errors
    that occur during hydration, this also includes errors that recoverable
    by de-opting to synchronous rendering. Typically (or really, by
    definition) these errors are the result of a concurrent data race;
    blocking the main thread fixes them by prevents subsequent races.
    
    The logic for de-opting to synchronous rendering already existed. The
    only thing that has changed is that we now log the errors instead of
    silently proceeding.
    
    The logging API has been renamed from onHydrationError
    to onRecoverableError.
    
    * Don't log recoverable errors until commit phase
    
    If the render is interrupted and restarts, we don't want to log the
    errors multiple times.
    
    This change only affects errors that are recovered by de-opting to
    synchronous rendering; we'll have to do something else for errors
    during hydration, since they use a different recovery path.
    
    * Only log hydration error if client render succeeds
    
    Similar to previous step.
    
    When an error occurs during hydration, we only want to log it if falling
    back to client rendering _succeeds_. If client rendering fails,
    the error will get reported to the nearest error boundary, so there's
    no need for a duplicate log.
    
    To implement this, I added a list of errors to the hydration context.
    If the Suspense boundary successfully completes, they are added to
    the main recoverable errors queue (the one I added in the
    previous step.)
    
    * Log error with queueMicrotask instead of Scheduler
    
    If onRecoverableError is not provided, we default to rethrowing the
    error in a separate task. Originally, I scheduled the task with
    idle priority, but @sebmarkbage made the good point that if there are
    multiple errors logs, we want to preserve the original order. So I've
    switched it to a microtask. The priority can be lowered in userspace
    by scheduling an additional task inside onRecoverableError.
    
    * Only use host config method for default behavior
    
    Redefines the contract of the host config's logRecoverableError method
    to be a default implementation for onRecoverableError if a user-provided
    one is not provided when the root is created.
    
    * Log with reportError instead of rethrowing
    
    In modern browsers, reportError will dispatch an error event, emulating
    an uncaught JavaScript error. We can do this instead of rethrowing
    recoverable errors in a microtask, which is nice because it avoids any
    subtle ordering issues.
    
    In older browsers and test environments, we'll fall back
    to console.error.
    
    * Naming nits
    
    queueRecoverableHydrationErrors -> upgradeHydrationErrorsToRecoverable

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 13965720b7..bbfe70c26c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -246,6 +246,8 @@ type BaseFiberRootProperties = {|
   // the public createRoot object, which the fiber tree does not currently have
   // a reference to.
   identifierPrefix: string,
+
+  onRecoverableError: null | ((error: mixed) => void),
 |};
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit efd8f6442d1aa7c4566fe812cba03e7e83aaccc3
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 10 07:59:10 2022 -0800

    Resolve default onRecoverableError at root init (#23264)
    
    Minor follow up to initial onRecoverableError PR.
    
    When onRecoverableError is not provided to `createRoot`, the
    renderer falls back to a default implementation. Originally I
    implemented this with a host config method, but what we can do instead
    is pass the default implementation the root constructor as if it were
    a user provided one.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index bbfe70c26c..352498be61 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -247,7 +247,7 @@ type BaseFiberRootProperties = {|
   // a reference to.
   identifierPrefix: string,
 
-  onRecoverableError: null | ((error: mixed) => void),
+  onRecoverableError: (error: mixed) => void,
 |};
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit 1fb0d06878416d321182ddb4601231982e7433c9
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Fri Feb 11 13:15:10 2022 -0500

    [Devtools][Transition Tracing] Add Transition callbacks to createRoot (#23276)
    
    - Add the type of transition tracing callbacks
    - Add transition tracing callbacks as an option to `createRoot`
    - Add transition tracing callbacks on the root
    - Add option to pass transition tracing callbacks to createReactNoop

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 352498be61..ed668d9126 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -268,6 +268,60 @@ type SuspenseCallbackOnlyFiberRootProperties = {|
   hydrationCallbacks: null | SuspenseHydrationCallbacks,
 |};
 
+export type TransitionTracingCallbacks = {
+  onTransitionStart?: (transitionName: string, startTime: number) => void,
+  onTransitionProgress?: (
+    transitionName: string,
+    startTime: number,
+    currentTime: number,
+    pending: Array<{name: null | string}>,
+  ) => void,
+  onTransitionIncomplete?: (
+    transitionName: string,
+    startTime: number,
+    deletions: Array<{
+      type: string,
+      name?: string,
+      newName?: string,
+      endTime: number,
+    }>,
+  ) => void,
+  onTransitionComplete?: (
+    transitionName: string,
+    startTime: number,
+    endTime: number,
+  ) => void,
+  onMarkerProgress?: (
+    transitionName: string,
+    marker: string,
+    startTime: number,
+    currentTime: number,
+    pending: Array<{name: null | string}>,
+  ) => void,
+  onMarkerIncomplete?: (
+    transitionName: string,
+    marker: string,
+    startTime: number,
+    deletions: Array<{
+      type: string,
+      name?: string,
+      newName?: string,
+      endTime: number,
+    }>,
+  ) => void,
+  onMarkerComplete?: (
+    transitionName: string,
+    marker: string,
+    startTime: number,
+    endTime: number,
+  ) => void,
+};
+
+// The following fields are only used in transition tracing in Profile builds
+type TransitionTracingOnlyFiberRootProperties = {|
+  transitionCallbacks: null | TransitionTracingCallbacks,
+|};
+
 // Exported FiberRoot type includes all properties,
 // To avoid requiring potentially error-prone :any casts throughout the project.
 // The types are defined separately within this file to ensure they stay in sync.
@@ -275,6 +329,7 @@ export type FiberRoot = {
   ...BaseFiberRootProperties,
   ...SuspenseCallbackOnlyFiberRootProperties,
   ...UpdaterTrackingOnlyFiberRootProperties,
+  ...TransitionTracingOnlyFiberRootProperties,
   ...
 };
 

commit 42f15b324f50d0fd98322c21646ac3013e30344a
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Feb 24 17:28:18 2022 -0500

    [DevTools][Transition Tracing] onTransitionComplete and onTransitionStart implmentation (#23313)
    
    * add transition name to startTransition
    
    Add a transitionName to start transition, store the transition start time and name in the batch config, and pass it to the root on render
    
    * Transition Tracing Types and Consts
    
    * Root begin work
    
    The root operates as a tracing marker that has all transitions on it. This PR only tested the root with one transition so far
    
    - Store transitions in memoizedState. Do this in updateHostRoot AND attemptEarlyBailoutIfNoScheduledUpdate. We need to do this in the latter part because even if the root itself doesn't have an update, it could still have new transitions in its transitionLanes map that we need to process.
    
    * Transition Tracing commit phase
    
    - adds a module scoped pending transition callbacks object that contains all transition callbacks that have not yet been processed. This  contains all callbacks before the next paint occurs.
    - Add code in the mutation phase to:
            * For the root, if there are transitions that were initialized during this commit in the root transition lanes map, add a transition start call to the pending transition callbacks object. Then, remove the transitions from the root transition lanes map.
            * For roots, in the commit phase, add a transition complete call
    
    We add this code in the mutation phase because we can't add it to the passive phase because then the paint might have occurred before we even know which callbacks to call
    
    * Process Callbacks after paint
    
    At the end of the commit phase, call scheduleTransitionCallbacks to schedule all pending transition callbacks to be called after paint. Then clear the callbacks

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index ed668d9126..162ba457d5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -15,6 +15,7 @@ import type {
   MutableSourceGetSnapshotFn,
   MutableSourceVersion,
   MutableSource,
+  StartTransitionOptions,
 } from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
@@ -25,6 +26,7 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Wakeable} from 'shared/ReactTypes';
 import type {Cache} from './ReactFiberCacheComponent.old';
+import type {Transitions} from './ReactFiberTracingMarkerComponent.new';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -320,6 +322,7 @@ export type TransitionTracingCallbacks = {
 // The following fields are only used in transition tracing in Profile builds
 type TransitionTracingOnlyFiberRootProperties = {|
   transitionCallbacks: null | TransitionTracingCallbacks,
+  transitionLanes: Array<Transitions>,
 |};
 
 // Exported FiberRoot type includes all properties,
@@ -369,7 +372,10 @@ export type Dispatcher = {|
   ): void,
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
   useDeferredValue<T>(value: T): T,
-  useTransition(): [boolean, (() => void) => void],
+  useTransition(): [
+    boolean,
+    (callback: () => void, options?: StartTransitionOptions) => void,
+  ],
   useMutableSource<Source, Snapshot>(
     source: MutableSource<Source>,
     getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,

commit d5f1b067c8bbb826b823d0354a28ba31078b70c0
Author: salazarm <salazarm@users.noreply.github.com>
Date:   Tue Mar 8 07:55:32 2022 -0500

    [ServerContext] Flight support for ServerContext (#23244)
    
    * Flight side of server context
    
    * 1 more test
    
    * rm unused function
    
    * flow+prettier
    
    * flow again =)
    
    * duplicate ReactServerContext across packages
    
    * store default value when lazily initializing server context
    
    * .
    
    * better comment
    
    * derp... missing import
    
    * rm optional chaining
    
    * missed feature flag
    
    * React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED ??
    
    * add warning if non ServerContext passed into useServerContext
    
    * pass context in as array of arrays
    
    * make importServerContext nott pollute the global context state
    
    * merge main
    
    * remove useServerContext
    
    * dont rely on object getters in ReactServerContext and disallow JSX
    
    * add symbols to devtools + rename globalServerContextRegistry to just ContextRegistry
    
    * gate test case as experimental
    
    * feedback
    
    * remove unions
    
    * Lint
    
    * fix oopsies (tests/lint/mismatching arguments/signatures
    
    * lint again
    
    * replace-fork
    
    * remove extraneous change
    
    * rebase
    
    * 1 more test
    
    * rm unused function
    
    * flow+prettier
    
    * flow again =)
    
    * duplicate ReactServerContext across packages
    
    * store default value when lazily initializing server context
    
    * .
    
    * better comment
    
    * derp... missing import
    
    * rm optional chaining
    
    * missed feature flag
    
    * React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED ??
    
    * add warning if non ServerContext passed into useServerContext
    
    * pass context in as array of arrays
    
    * make importServerContext nott pollute the global context state
    
    * merge main
    
    * remove useServerContext
    
    * dont rely on object getters in ReactServerContext and disallow JSX
    
    * add symbols to devtools + rename globalServerContextRegistry to just ContextRegistry
    
    * gate test case as experimental
    
    * feedback
    
    * remove unions
    
    * Lint
    
    * fix oopsies (tests/lint/mismatching arguments/signatures
    
    * lint again
    
    * replace-fork
    
    * remove extraneous change
    
    * rebase
    
    * reinline
    
    * rebase
    
    * add back changes lost due to rebase being hard
    
    * emit chunk for provider
    
    * remove case for React provider type
    
    * update type for SomeChunk
    
    * enable flag with experimental
    
    * add missing types
    
    * fix flow type
    
    * missing type
    
    * t: any
    
    * revert extraneous type change
    
    * better type
    
    * better type
    
    * feedback
    
    * change import to type import
    
    * test?
    
    * test?
    
    * remove react-dom
    
    * remove react-native-renderer from react-server-native-relay/package.json
    
    * gate change in FiberNewContext, getComponentNameFromType, use switch statement in FlightServer
    
    * getComponentNameFromTpe: server context type gated and use displayName if available
    
    * fallthrough
    
    * lint....
    
    * POP
    
    * lint

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 162ba457d5..dd2e09c03b 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -16,6 +16,7 @@ import type {
   MutableSourceVersion,
   MutableSource,
   StartTransitionOptions,
+  Wakeable,
 } from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
@@ -24,7 +25,6 @@ import type {Flags} from './ReactFiberFlags';
 import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
-import type {Wakeable} from 'shared/ReactTypes';
 import type {Cache} from './ReactFiberCacheComponent.old';
 import type {Transitions} from './ReactFiberTracingMarkerComponent.new';
 

commit 02b65fd8c5dbc6bfe2c976841f2f70a593ac9129
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 11 19:48:36 2022 -0500

    Allow updates at lower pri without forcing client render
    
    Currently, if a root is updated before the shell has finished hydrating
    (for example, due to a top-level navigation), we immediately revert to
    client rendering. This is rare because the root is expected is finish
    quickly, but not exceedingly rare because the root may be suspended.
    
    This adds support for updating the root without forcing a client render
    as long as the update has lower priority than the initial hydration,
    i.e. if the update is wrapped in startTransition.
    
    To implement this, I had to do some refactoring. The main idea here is
    to make it closer to how we implement hydration in Suspense boundaries:
    
    - I moved isDehydrated from the shared FiberRoot object to the
    HostRoot's state object.
    - In the begin phase, I check if the root has received an by comparing
    the new children to the initial children. If they are different, we
    revert to client rendering, and set isDehydrated to false using a
    derived state update (a la getDerivedStateFromProps).
    - There are a few places where we used to set root.isDehydrated to false
    as a way to force a client render. Instead, I set the ForceClientRender
    flag on the root work-in-progress fiber.
    - Whenever we fall back to client rendering, I log a recoverable error.
    
    The overall code structure is almost identical to the corresponding
    logic for Suspense components.
    
    The reason this works is because if the update has lower priority than
    the initial hydration, it won't be processed during the hydration
    render, so the children will be the same.
    
    We can go even further and allow updates at _higher_ priority (though
    not sync) by implementing selective hydration at the root, like we do
    for Suspense boundaries: interrupt the current render, attempt hydration
    at slightly higher priority than the update, then continue rendering the
    update. I haven't implemented this yet, but I've structured the code in
    anticipation of adding this later.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index dd2e09c03b..1fa3d4b668 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -213,8 +213,6 @@ type BaseFiberRootProperties = {|
   // Top context object, used by renderSubtreeIntoContainer
   context: Object | null,
   pendingContext: Object | null,
-  // Determines if we should attempt to hydrate on the initial mount
-  +isDehydrated: boolean,
 
   // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<

commit 832e2987e01aa357c3b2e551acae0682ca36fb14
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 11 21:31:23 2022 -0500

    Revert accdientally merged PR (#24081)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1fa3d4b668..dd2e09c03b 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -213,6 +213,8 @@ type BaseFiberRootProperties = {|
   // Top context object, used by renderSubtreeIntoContainer
   context: Object | null,
   pendingContext: Object | null,
+  // Determines if we should attempt to hydrate on the initial mount
+  +isDehydrated: boolean,
 
   // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<

commit 2e0d86d22192ff0b13b71b4ad68fea46bf523ef6
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Mar 20 16:18:51 2022 -0400

    Allow updating dehydrated root at lower priority without forcing client render (#24082)
    
    * Pass children to hydration root constructor
    
    I already made this change for the concurrent root API in #23309. This
    does the same thing for the legacy API.
    
    Doesn't change any behavior, but I will use this in the next steps.
    
    * Add isRootDehydrated function
    
    Currently this does nothing except read a boolean field, but I'm about
    to change this logic.
    
    Since this is accessed by React DOM, too, I put the function in a
    separate module that can be deep imported. Previously, it was accessing
    the FiberRoot directly. The reason it's a separate module is to break a
    circular dependency between React DOM and the reconciler.
    
    * Allow updates at lower pri without forcing client render
    
    Currently, if a root is updated before the shell has finished hydrating
    (for example, due to a top-level navigation), we immediately revert to
    client rendering. This is rare because the root is expected is finish
    quickly, but not exceedingly rare because the root may be suspended.
    
    This adds support for updating the root without forcing a client render
    as long as the update has lower priority than the initial hydration,
    i.e. if the update is wrapped in startTransition.
    
    To implement this, I had to do some refactoring. The main idea here is
    to make it closer to how we implement hydration in Suspense boundaries:
    
    - I moved isDehydrated from the shared FiberRoot object to the
    HostRoot's state object.
    - In the begin phase, I check if the root has received an by comparing
    the new children to the initial children. If they are different, we
    revert to client rendering, and set isDehydrated to false using a
    derived state update (a la getDerivedStateFromProps).
    - There are a few places where we used to set root.isDehydrated to false
    as a way to force a client render. Instead, I set the ForceClientRender
    flag on the root work-in-progress fiber.
    - Whenever we fall back to client rendering, I log a recoverable error.
    
    The overall code structure is almost identical to the corresponding
    logic for Suspense components.
    
    The reason this works is because if the update has lower priority than
    the initial hydration, it won't be processed during the hydration
    render, so the children will be the same.
    
    We can go even further and allow updates at _higher_ priority (though
    not sync) by implementing selective hydration at the root, like we do
    for Suspense boundaries: interrupt the current render, attempt hydration
    at slightly higher priority than the update, then continue rendering the
    update. I haven't implemented this yet, but I've structured the code in
    anticipation of adding this later.
    
    * Wrap useMutableSource logic in feature flag

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index dd2e09c03b..1fa3d4b668 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -213,8 +213,6 @@ type BaseFiberRootProperties = {|
   // Top context object, used by renderSubtreeIntoContainer
   context: Object | null,
   pendingContext: Object | null,
-  // Determines if we should attempt to hydrate on the initial mount
-  +isDehydrated: boolean,
 
   // Used by useMutableSource hook to avoid tearing during hydration.
   mutableSourceEagerHydrationData?: Array<

commit b8cfda15e1232554487c7285fb464f22705a23ce
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Fri Apr 1 17:02:28 2022 -0400

    changed Transitions type to Array<Transition> (#24249)
    
    Changed the Transitions type to Array<Transition> because Transitions was confusing

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1fa3d4b668..319bbc1c33 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -26,7 +26,7 @@ import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
-import type {Transitions} from './ReactFiberTracingMarkerComponent.new';
+import type {Transition} from './ReactFiberTracingMarkerComponent.new';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -320,7 +320,7 @@ export type TransitionTracingCallbacks = {
 // The following fields are only used in transition tracing in Profile builds
 type TransitionTracingOnlyFiberRootProperties = {|
   transitionCallbacks: null | TransitionTracingCallbacks,
-  transitionLanes: Array<Transitions>,
+  transitionLanes: Array<Array<Transition> | null>,
 |};
 
 // Exported FiberRoot type includes all properties,

commit 4f29ba1cc52061e439cede3813e100557b23a15c
Author: Josh Story <story@hey.com>
Date:   Mon Jun 6 17:23:32 2022 -0400

    support errorInfo in onRecoverableError (#24591)
    
    * extend onRecoverableError API to support errorInfo
    
    errorInfo has been used in Error Boundaries wiht componentDidCatch for a while now. To date this metadata only contained a componentStack. onRecoverableError only receives an error (type mixed) argument and thus providing additional error metadata was not possible without mutating user created mixed objects.
    
    This change modifies rootConcurrentErrors rootRecoverableErrors, and hydrationErrors so all expect CapturedValue types. additionally a new factory function allows the creation of CapturedValues from a value plus a hash and stack.
    
    In general, client derived CapturedValues will be created using the original function which derives a componentStack from a fiber and server originated CapturedValues will be created using with a passed in hash and optional componentStack.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 319bbc1c33..618260b47c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -247,7 +247,10 @@ type BaseFiberRootProperties = {|
   // a reference to.
   identifierPrefix: string,
 
-  onRecoverableError: (error: mixed) => void,
+  onRecoverableError: (
+    error: mixed,
+    errorInfo: {digest?: ?string, componentStack?: ?string},
+  ) => void,
 |};
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit 79f54c16dc3d5298e6037df75db2beb3552896e9
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 7 20:04:02 2022 -0400

    Bugfix: Revealing a hidden update (#24685)
    
    * Add `isHidden` to OffscreenInstance
    
    We need to be able to read whether an offscreen tree is hidden from
    an imperative event. We can store this on its OffscreenInstance.
    
    We were already scheduling a commit effect whenever the visibility
    changes, in order to toggle the inner effects. So we can reuse that.
    
    * [FORKED] Bugfix: Revealing a hidden update
    
    This fixes a bug I discovered related to revealing a hidden Offscreen
    tree. When this happens, we include in that render all the updates that
    had previously been deferred — that is, all the updates that would have
    already committed if the tree weren't hidden. This is necessary to avoid
    tearing with the surrounding contents. (This was the "flickering"
    Suspense bug we found a few years ago: #18411.)
    
    The way we do this is by tracking the lanes of the updates that were
    deferred by a hidden tree. These are the "base" lanes. Then, in order
    to reveal the hidden tree, we process any update that matches one of
    those base lanes.
    
    The bug I discovered is that some of these base lanes may include
    updates that were not present at the time the tree was hidden. We cannot
    flush those updates earlier that the surrounding contents — that, too,
    could cause tearing.
    
    The crux of the problem is that we sometimes reuse the same lane for
    base updates and for non-base updates. So the lane alone isn't
    sufficient to distinguish between these cases. We must track this in
    some other way.
    
    The solution I landed upon was to add an extra OffscreenLane bit to any
    update that is made to a hidden tree. Then later when we reveal the
    tree, we'll know not to treat them as base updates.
    
    The extra OffscreenLane bit is removed as soon as that lane is committed
    by the root (markRootFinished) — at that point, it gets
    "upgraded" to a base update.
    
    The trickiest part of this algorithm is reliably detecting when an
    update is made to a hidden tree. What makes this challenging is when the
    update is received during a concurrent event, while a render is already
    in progress — it's possible the work-in-progress render is about to
    flip the visibility of the tree that's being updated, leading to a race
    condition.
    
    To avoid a race condition, we will wait to read the visibility of the
    tree until the current render has finished. In other words, this makes
    it an atomic operation. Most of this logic was already implemented
    in #24663.
    
    Because this bugfix depends on a moderately risky refactor to the update
    queue (#24663), it only works in the "new" reconciler fork. We will roll
    it out gradually to www before landing in the main fork.
    
    * Add previous commit to list of forked revisions

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 618260b47c..c6a7ed58b0 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -27,6 +27,7 @@ import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
 import type {Transition} from './ReactFiberTracingMarkerComponent.new';
+import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.new';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -225,6 +226,7 @@ type BaseFiberRootProperties = {|
   callbackPriority: Lane,
   eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,
+  hiddenUpdates: LaneMap<Array<ConcurrentUpdate> | null>,
 
   pendingLanes: Lanes,
   suspendedLanes: Lanes,

commit cf665c4b73a28b034c8173f4d929205fb12d2d2e
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Mon Jun 20 20:08:54 2022 -0400

    [DevTools] Refactor incompleteTransitions field from Root Fiber memoized state to FiberRoot (#24765)
    
    `incompleteTransitions` persists across renders, so it should be part of the `fiber.stateNode` (ie FiberRoot) rather than `fiber.memoizedState`

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c6a7ed58b0..abf8a98e99 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -26,6 +26,9 @@ import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
 import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
+// Doing this because there's a merge conflict because of the way sync-reconciler-fork
+// is implemented
+import type {PendingSuspenseBoundaries} from './ReactFiberTracingMarkerComponent.new';
 import type {Transition} from './ReactFiberTracingMarkerComponent.new';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.new';
 
@@ -326,6 +329,13 @@ export type TransitionTracingCallbacks = {
 type TransitionTracingOnlyFiberRootProperties = {|
   transitionCallbacks: null | TransitionTracingCallbacks,
   transitionLanes: Array<Array<Transition> | null>,
+  // Transitions on the root can be represented as a bunch of tracing markers.
+  // Each entangled group of transitions can be treated as a tracing marker.
+  // It will have a set of pending suspense boundaries. These transitions
+  // are considered complete when the pending suspense boundaries set is
+  // empty. We can represent this as a Map of transitions to suspense
+  // boundary sets
+  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries> | null,
 |};
 
 // Exported FiberRoot type includes all properties,

commit d1432ba93e971b249d7055dbb3b91e34eb0d2100
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Tue Jun 28 21:17:14 2022 -0400

    [Transition Tracing] Fix excess calls to the transition start callback (#24806)
    
    This PR fixes a bug where we would add a transition to the lanes map every time an update occurs. However, we didn't factor in that there might be multiple updates in a transition, which would cause the transition to be added multiple times to the transitionLanes map.
    
    This changes the transitionLanes object from an Array of Arrays to an Array of Sets so that we only add a transition if it hasn't been added before, avoiding duplicates

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index abf8a98e99..0f6e9bcaf7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -328,7 +328,7 @@ export type TransitionTracingCallbacks = {
 // The following fields are only used in transition tracing in Profile builds
 type TransitionTracingOnlyFiberRootProperties = {|
   transitionCallbacks: null | TransitionTracingCallbacks,
-  transitionLanes: Array<Array<Transition> | null>,
+  transitionLanes: Array<Set<Transition> | null>,
   // Transitions on the root can be represented as a bunch of tracing markers.
   // Each entangled group of transitions can be treated as a tracing marker.
   // It will have a set of pending suspense boundaries. These transitions

commit 401296310fbc6a9e769936eda6a6d0269e9c84d0
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Jun 30 11:16:32 2022 -0400

    [Transition Tracing] Refactor Transition Tracing Root Code (#24766)
    
    This PR refactors the transition tracing root code by reusing the tracing marker code. Namely it:
    * Refactors the tracing marker code so that it takes a tracing marker instance instead of a tracing marker fiber and rename the stack to `markerInstance` instead of `tracingMarker`
    * Pushes the root code onto the stack
    * Moves the instantiation of `root.incompleteTransitions` to the begin phase when we are pushing the root to the stack rather than in the commit phase

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0f6e9bcaf7..8aad50f4bf 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -335,7 +335,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // are considered complete when the pending suspense boundaries set is
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
-  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries> | null,
+  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries>,
 |};
 
 // Exported FiberRoot type includes all properties,

commit e61fd91f5c523adb63a3b97375ac95ac657dc07f
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 30 11:48:25 2022 -0400

    Revert "[Transition Tracing] Refactor Transition Tracing Root Code (#24766)" (#24829)
    
    This reverts commit 401296310fbc6a9e769936eda6a6d0269e9c84d0 because it's
    failing on main, likely due to conflict with something that landed before the
    PR was merged. Need to rebase and fix.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 8aad50f4bf..0f6e9bcaf7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -335,7 +335,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // are considered complete when the pending suspense boundaries set is
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
-  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries>,
+  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries> | null,
 |};
 
 // Exported FiberRoot type includes all properties,

commit 4cd788aef03d8f32c03e4dac4d0cf28b220cedfb
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Jun 30 13:16:08 2022 -0400

    Revert "Revert [Transition Tracing] Refactor Transition Tracing Root Code" (#24830)
    
    * refactor root
    
    * old
    
    * Add comments and push actual marker instance in pushMarkerInstance
    
    * old
    
    * refactor pushRootMarkerInstance
    
    * old
    
    * fix test

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0f6e9bcaf7..8aad50f4bf 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -335,7 +335,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // are considered complete when the pending suspense boundaries set is
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
-  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries> | null,
+  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries>,
 |};
 
 // Exported FiberRoot type includes all properties,

commit fa20b319fcfad50d7b981ec57f111b4e24d6f559
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Tue Jul 12 15:48:04 2022 -0400

    [Transition Tracing] Code Cleanup (#24880)
    
    This PR cleans up some of the transition tracing code by:
    * Looping through marker transitions only when we process the markerComplete callback (rather than in the commit phase) so we block for less time during commit.
    * Renaming `PendingSuspenseBoundaries` to `pendingBoundaries`
    * Cleaning up the callback functions

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 8aad50f4bf..e017674dda 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -28,8 +28,10 @@ import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
 // Doing this because there's a merge conflict because of the way sync-reconciler-fork
 // is implemented
-import type {PendingSuspenseBoundaries} from './ReactFiberTracingMarkerComponent.new';
-import type {Transition} from './ReactFiberTracingMarkerComponent.new';
+import type {
+  TracingMarkerInstance,
+  Transition,
+} from './ReactFiberTracingMarkerComponent.new';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.new';
 
 // Unwind Circular: moved from ReactFiberHooks.old
@@ -335,7 +337,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // are considered complete when the pending suspense boundaries set is
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
-  incompleteTransitions: Map<Transition, PendingSuspenseBoundaries>,
+  incompleteTransitions: Map<Array<Transition>, TracingMarkerInstance>,
 |};
 
 // Exported FiberRoot type includes all properties,

commit 9e67e7a31582079263665fac0391220b99d8bb86
Author: Joseph Savona <joesavona@fb.com>
Date:   Tue Aug 23 01:36:02 2022 -0700

    Scaffolding for useMemoCache hook (#25123)
    
    * Scaffolding for useMemoCache hook
    * cleanup leftovers from copy/paste of use() diff
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e017674dda..e9a4b61039 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -403,6 +403,7 @@ export type Dispatcher = {|
   ): T,
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
+  useMemoCache?: (size: number) => Array<any>,
 
   unstable_isNewReconciler?: boolean,
 |};

commit 11ed7010c6d34c40342e8b829a48fec138215ae0
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Aug 25 19:03:03 2022 +0100

    [Transition Tracing] onMarkerIncomplete - Tracing Marker/Suspense Boundary Deletions (#24885)
    
    This PR adds the `onMarkerIncomplete` callback for tracing marker name changes. Specifically, this PR:
    * Adds the `onMarkerIncomplete` callback
    * When a tracing marker is deleted, call `onMarkerIncomplete` with the `name` of the tracing marker for the tracing marker.
    * When a tracing marker/suspense boundary is deleted, call `onMarkerIncomplete` for every parent tracing marker with the `name` of the tracing marker that caused the transition to be incomplete.
    * Don't call `onTransitionComplete` or `onMarkerComplete` when `onMarkerIncomplete` is called for all tracing markers with the same transitions, but continue to call `onTransitionProgress`

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e9a4b61039..b03a715701 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -291,8 +291,7 @@ export type TransitionTracingCallbacks = {
     startTime: number,
     deletions: Array<{
       type: string,
-      name?: string,
-      newName?: string,
+      name?: string | null,
       endTime: number,
     }>,
   ) => void,
@@ -314,8 +313,7 @@ export type TransitionTracingCallbacks = {
     startTime: number,
     deletions: Array<{
       type: string,
-      name?: string,
-      newName?: string,
+      name?: string | null,
       endTime: number,
     }>,
   ) => void,
@@ -337,7 +335,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // are considered complete when the pending suspense boundaries set is
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
-  incompleteTransitions: Map<Array<Transition>, TracingMarkerInstance>,
+  incompleteTransitions: Map<Transition, TracingMarkerInstance>,
 |};
 
 // Exported FiberRoot type includes all properties,

commit b6978bc38f6788c7e73982b9fd2771aabdf36f15
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Aug 25 14:12:07 2022 -0400

    experimental_use(promise) (#25084)
    
    * Internal `act`: Unwrapping resolved promises
    
    This update our internal implementation of `act` to support React's new
    behavior for unwrapping promises. Like we did with Scheduler, when
    something suspends, it will yield to the main thread so the microtasks
    can run, then continue in a new task.
    
    I need to implement the same behavior in the public version of `act`,
    but there are some additional considerations so I'll do that in a
    separate commit.
    
    * Move throwException to after work loop resumes
    
    throwException is the function that finds the nearest boundary and
    schedules it for a second render pass. We should only call it right
    before we unwind the stack — not if we receive an immediate ping and
    render the fiber again.
    
    This was an oversight in 8ef3a7c that I didn't notice because it happens
    to mostly work, anyway. What made me notice the mistake is that
    throwException also marks the entire render phase as suspended
    (RootDidSuspend or RootDidSuspendWithDelay), which is only supposed to
    be happen if we show a fallback. One consequence was that, in the
    RootDidSuspendWithDelay case, the entire commit phase was blocked,
    because that's the exit status we use to block a bad fallback
    from appearing.
    
    * Use expando to check whether promise has resolved
    
    Add a `status` expando to a thrown thenable to track when its value has
    resolved.
    
    In a later step, we'll also use `value` and `reason` expandos to track
    the resolved value.
    
    This is not part of the official JavaScript spec — think of
    it as an extension of the Promise API, or a custom interface that is a
    superset of Thenable. However, it's inspired by the terminology used
    by `Promise.allSettled`.
    
    The intent is that this will be a public API — Suspense implementations
    can set these expandos to allow React to unwrap the value synchronously
    without waiting a microtask.
    
    * Scaffolding for `experimental_use` hook
    
    Sets up a new experimental hook behind a feature flag, but does not
    implement it yet.
    
    * use(promise)
    
    Adds experimental support to Fiber for unwrapping the value of a promise
    inside a component. It is not yet implemented for Server Components,
    but that is planned.
    
    If promise has already resolved, the value can be unwrapped
    "immediately" without showing a fallback. The trick we use to implement
    this is to yield to the main thread (literally suspending the work
    loop), wait for the microtask queue to drain, then check if the promise
    resolved in the meantime. If so, we can resume the last attempted fiber
    without unwinding the stack. This functionality was implemented in
    previous commits.
    
    Another feature is that the promises do not need to be cached between
    attempts. Because we assume idempotent execution of components, React
    will track the promises that were used during the previous attempt and
    reuse the result. You shouldn't rely on this property, but during
    initial render it mostly just works. Updates are trickier, though,
    because if you used an uncached promise, we have no way of knowing
    whether the underlying data has changed, so we have to unwrap the
    promise every time. It will still work, but it's inefficient and can
    lead to unnecessary fallbacks if it happens during a discrete update.
    
    When we implement this for Server Components, this will be less of an
    issue because there are no updates in that environment. However, it's
    still better for performance to cache data requests, so the same
    principles largely apply.
    
    The intention is that this will eventually be the only supported way to
    suspend on arbitrary promises. Throwing a promise directly will
    be deprecated.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index b03a715701..c8239dc248 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -17,6 +17,7 @@ import type {
   MutableSource,
   StartTransitionOptions,
   Wakeable,
+  Usable,
 } from 'shared/ReactTypes';
 import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
@@ -238,6 +239,7 @@ type BaseFiberRootProperties = {|
   pingedLanes: Lanes,
   expiredLanes: Lanes,
   mutableReadLanes: Lanes,
+  errorRecoveryDisabledLanes: Lanes,
 
   finishedLanes: Lanes,
 
@@ -353,6 +355,7 @@ type BasicStateAction<S> = (S => S) | S;
 type Dispatch<A> = A => void;
 
 export type Dispatcher = {|
+  use?: <T>(Usable<T>) => T,
   getCacheSignal?: () => AbortSignal,
   getCacheForType?: <T>(resourceType: () => T) => T,
   readContext<T>(context: ReactContext<T>): T,

commit 8a9e7b6cefb5e7e94333c7d5fe2cca6541776d5b
Author: Jan Kassens <jan@kassens.net>
Date:   Fri Sep 9 10:13:58 2022 -0400

    Flow: implicit-inexact-object=error (#25210)
    
    * implicit-inexact-object=error
    * default everything ambiguous to exact object
    * inexact where exact causes errors

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c8239dc248..5770adb76b 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -258,7 +258,7 @@ type BaseFiberRootProperties = {|
 
   onRecoverableError: (
     error: mixed,
-    errorInfo: {digest?: ?string, componentStack?: ?string},
+    errorInfo: {|digest?: ?string, componentStack?: ?string|},
   ) => void,
 |};
 
@@ -280,22 +280,22 @@ type SuspenseCallbackOnlyFiberRootProperties = {|
   hydrationCallbacks: null | SuspenseHydrationCallbacks,
 |};
 
-export type TransitionTracingCallbacks = {
+export type TransitionTracingCallbacks = {|
   onTransitionStart?: (transitionName: string, startTime: number) => void,
   onTransitionProgress?: (
     transitionName: string,
     startTime: number,
     currentTime: number,
-    pending: Array<{name: null | string}>,
+    pending: Array<{|name: null | string|}>,
   ) => void,
   onTransitionIncomplete?: (
     transitionName: string,
     startTime: number,
-    deletions: Array<{
+    deletions: Array<{|
       type: string,
       name?: string | null,
       endTime: number,
-    }>,
+    |}>,
   ) => void,
   onTransitionComplete?: (
     transitionName: string,
@@ -307,17 +307,17 @@ export type TransitionTracingCallbacks = {
     marker: string,
     startTime: number,
     currentTime: number,
-    pending: Array<{name: null | string}>,
+    pending: Array<{|name: null | string|}>,
   ) => void,
   onMarkerIncomplete?: (
     transitionName: string,
     marker: string,
     startTime: number,
-    deletions: Array<{
+    deletions: Array<{|
       type: string,
       name?: string | null,
       endTime: number,
-    }>,
+    |}>,
   ) => void,
   onMarkerComplete?: (
     transitionName: string,
@@ -325,7 +325,7 @@ export type TransitionTracingCallbacks = {
     startTime: number,
     endTime: number,
   ) => void,
-};
+|};
 
 // The following fields are only used in transition tracing in Profile builds
 type TransitionTracingOnlyFiberRootProperties = {|

commit 8003ab9cf5c711eb00f741bbd89def56b066b999
Author: Jan Kassens <jan@kassens.net>
Date:   Fri Sep 9 16:03:48 2022 -0400

    Flow: remove explicit object syntax (#25223)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 5770adb76b..df7398c796 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -70,7 +70,7 @@ export type Dependencies = {
 
 // A Fiber is work on a Component that needs to be done or was done. There can
 // be more than one per component.
-export type Fiber = {|
+export type Fiber = {
   // These first fields are conceptually members of an Instance. This used to
   // be split into a separate type and intersected with the other Fiber fields,
   // but until Flow fixes its intersection bugs, we've merged them into a
@@ -197,9 +197,9 @@ export type Fiber = {|
 
   // Used to verify that the order of hooks does not change between renders.
   _debugHookTypes?: Array<HookType> | null,
-|};
+};
 
-type BaseFiberRootProperties = {|
+type BaseFiberRootProperties = {
   // The type of root (legacy, batched, concurrent, etc.)
   tag: RootTag,
 
@@ -258,16 +258,16 @@ type BaseFiberRootProperties = {|
 
   onRecoverableError: (
     error: mixed,
-    errorInfo: {|digest?: ?string, componentStack?: ?string|},
+    errorInfo: {digest?: ?string, componentStack?: ?string},
   ) => void,
-|};
+};
 
 // The following attributes are only used by DevTools and are only present in DEV builds.
 // They enable DevTools Profiler UI to show which Fiber(s) scheduled a given commit.
-type UpdaterTrackingOnlyFiberRootProperties = {|
+type UpdaterTrackingOnlyFiberRootProperties = {
   memoizedUpdaters: Set<Fiber>,
   pendingUpdatersLaneMap: LaneMap<Set<Fiber>>,
-|};
+};
 
 export type SuspenseHydrationCallbacks = {
   onHydrated?: (suspenseInstance: SuspenseInstance) => void,
@@ -276,26 +276,26 @@ export type SuspenseHydrationCallbacks = {
 };
 
 // The follow fields are only used by enableSuspenseCallback for hydration.
-type SuspenseCallbackOnlyFiberRootProperties = {|
+type SuspenseCallbackOnlyFiberRootProperties = {
   hydrationCallbacks: null | SuspenseHydrationCallbacks,
-|};
+};
 
-export type TransitionTracingCallbacks = {|
+export type TransitionTracingCallbacks = {
   onTransitionStart?: (transitionName: string, startTime: number) => void,
   onTransitionProgress?: (
     transitionName: string,
     startTime: number,
     currentTime: number,
-    pending: Array<{|name: null | string|}>,
+    pending: Array<{name: null | string}>,
   ) => void,
   onTransitionIncomplete?: (
     transitionName: string,
     startTime: number,
-    deletions: Array<{|
+    deletions: Array<{
       type: string,
       name?: string | null,
       endTime: number,
-    |}>,
+    }>,
   ) => void,
   onTransitionComplete?: (
     transitionName: string,
@@ -307,17 +307,17 @@ export type TransitionTracingCallbacks = {|
     marker: string,
     startTime: number,
     currentTime: number,
-    pending: Array<{|name: null | string|}>,
+    pending: Array<{name: null | string}>,
   ) => void,
   onMarkerIncomplete?: (
     transitionName: string,
     marker: string,
     startTime: number,
-    deletions: Array<{|
+    deletions: Array<{
       type: string,
       name?: string | null,
       endTime: number,
-    |}>,
+    }>,
   ) => void,
   onMarkerComplete?: (
     transitionName: string,
@@ -325,10 +325,10 @@ export type TransitionTracingCallbacks = {|
     startTime: number,
     endTime: number,
   ) => void,
-|};
+};
 
 // The following fields are only used in transition tracing in Profile builds
-type TransitionTracingOnlyFiberRootProperties = {|
+type TransitionTracingOnlyFiberRootProperties = {
   transitionCallbacks: null | TransitionTracingCallbacks,
   transitionLanes: Array<Set<Transition> | null>,
   // Transitions on the root can be represented as a bunch of tracing markers.
@@ -338,7 +338,7 @@ type TransitionTracingOnlyFiberRootProperties = {|
   // empty. We can represent this as a Map of transitions to suspense
   // boundary sets
   incompleteTransitions: Map<Transition, TracingMarkerInstance>,
-|};
+};
 
 // Exported FiberRoot type includes all properties,
 // To avoid requiring potentially error-prone :any casts throughout the project.
@@ -354,7 +354,7 @@ export type FiberRoot = {
 type BasicStateAction<S> = (S => S) | S;
 type Dispatch<A> = A => void;
 
-export type Dispatcher = {|
+export type Dispatcher = {
   use?: <T>(Usable<T>) => T,
   getCacheSignal?: () => AbortSignal,
   getCacheForType?: <T>(resourceType: () => T) => T,
@@ -366,7 +366,7 @@ export type Dispatcher = {|
     init?: (I) => S,
   ): [S, Dispatch<A>],
   useContext<T>(context: ReactContext<T>): T,
-  useRef<T>(initialValue: T): {|current: T|},
+  useRef<T>(initialValue: T): {current: T},
   useEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
@@ -382,7 +382,7 @@ export type Dispatcher = {|
   useCallback<T>(callback: T, deps: Array<mixed> | void | null): T,
   useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T,
   useImperativeHandle<T>(
-    ref: {|current: T | null|} | ((inst: T | null) => mixed) | null | void,
+    ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,
     create: () => T,
     deps: Array<mixed> | void | null,
   ): void,
@@ -407,4 +407,4 @@ export type Dispatcher = {|
   useMemoCache?: (size: number) => Array<any>,
 
   unstable_isNewReconciler?: boolean,
-|};
+};

commit 3401e9200efbdb27815f739a90f6e18d1073de13
Author: Joseph Savona <joesavona@fb.com>
Date:   Tue Sep 13 14:44:32 2022 -0700

    useMemoCache implementation (#25143)
    
    * useMemoCache impl
    * test for multiple calls in a component (from custom hook)
    * Use array of arrays for multiple calls; use alternate/local as the backup
    * code cleanup
    * fix internal test
    * oops we do not support nullable property access
    * Simplify implementation, still have questions on some of the PR feedback though
    * Gate all code based on the feature flag
    * refactor to use updateQueue
    * address feedback
    * Try to eliminate size increase in prod bundle
    * update to retrigger ci

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index df7398c796..004aa17e56 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -68,6 +68,11 @@ export type Dependencies = {
   ...
 };
 
+export type MemoCache = {
+  data: Array<Array<any>>,
+  index: number,
+};
+
 // A Fiber is work on a Component that needs to be done or was done. There can
 // be more than one per component.
 export type Fiber = {

commit c91a1e03be54733a7dbfcb5663d7a9e8606ab1c1
Author: Lauren Tan <poteto@users.noreply.github.com>
Date:   Wed Sep 14 14:39:06 2022 -0400

    experimental_useEvent (#25229)
    
    This commit adds a new hook `useEvent` per the RFC [here](https://github.com/reactjs/rfcs/pull/220), gated as experimental.
    
    Co-authored-by: Rick Hanlon <rickhanlonii@gmail.com>
    Co-authored-by: Rick Hanlon <rickhanlonii@fb.com>
    Co-authored-by: Lauren Tan <poteto@users.noreply.github.com>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 004aa17e56..c7ee97c69c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -42,6 +42,7 @@ export type HookType =
   | 'useContext'
   | 'useRef'
   | 'useEffect'
+  | 'useEvent'
   | 'useInsertionEffect'
   | 'useLayoutEffect'
   | 'useCallback'
@@ -376,6 +377,7 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
+  useEvent?: <T>(callback: () => T) => () => T,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 3517bd9f77dc63189f3bafedf83ba1bf8ae359df
Author: Lauren Tan <poteto@users.noreply.github.com>
Date:   Thu Sep 29 13:45:27 2022 -0700

    Refactor useEvent (#25336)
    
    * Refactor useEvent
    
    Previously, the useEvent implementation made use of effect infra under
    the hood. This was a lot of extra overhead for functionality we didn't
    use (events have no deps, and no clean up functions). This PR refactors
    the implementation to instead use a queue to ensure that the callback is
    stable across renders.
    
    Additionally, the function signature was updated to infer the callback's argument types and return value. While this doesn't affect anything internal it more accurately describes what's being passed.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c7ee97c69c..9d23bc4376 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -286,6 +286,17 @@ type SuspenseCallbackOnlyFiberRootProperties = {
   hydrationCallbacks: null | SuspenseHydrationCallbacks,
 };
 
+// A wrapper callable object around a useEvent callback that throws if the callback is called during
+// rendering. The _impl property points to the actual implementation.
+export type EventFunctionWrapper<
+  Args,
+  Return,
+  F: (...Array<Args>) => Return,
+> = {
+  (): F,
+  _impl: F,
+};
+
 export type TransitionTracingCallbacks = {
   onTransitionStart?: (transitionName: string, startTime: number) => void,
   onTransitionProgress?: (
@@ -377,7 +388,9 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
-  useEvent?: <T>(callback: () => T) => () => T,
+  useEvent?: <Args, Return, F: (...Array<Args>) => Return>(
+    callback: F,
+  ) => EventFunctionWrapper<Args, Return, F>,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 31400ce293c6a99a770df435961df413e49ccf0f
Author: jerry-lllman <45385120+jerry-lllman@users.noreply.github.com>
Date:   Fri Sep 30 21:57:50 2022 +0800

    Refactor: merge duplicate imports (#25364)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 9d23bc4376..bee847ce29 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -19,13 +19,17 @@ import type {
   Wakeable,
   Usable,
 } from 'shared/ReactTypes';
-import type {SuspenseInstance} from './ReactFiberHostConfig';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
 import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
 import type {RootTag} from './ReactRootTags';
-import type {TimeoutHandle, NoTimeout} from './ReactFiberHostConfig';
+import type {
+  Container,
+  TimeoutHandle,
+  NoTimeout,
+  SuspenseInstance,
+} from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
 // Doing this because there's a merge conflict because of the way sync-reconciler-fork
 // is implemented
@@ -210,7 +214,7 @@ type BaseFiberRootProperties = {
   tag: RootTag,
 
   // Any additional information from the host associated with this root.
-  containerInfo: any,
+  containerInfo: Container,
   // Used only by persistent updates.
   pendingChildren: any,
   // The currently active root fiber. This is the mutable root of the tree.

commit 1089faf0d88411921980b7d1dfe3f539b5fda1d3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Oct 4 13:25:16 2022 -0400

    Flow: run codemod to remove existential type
    
    The existential type `*` was deprecated and a codemod provided to replace it. Ran that and did some manual fixups:
    
    ```sh
    node_modules/.bin/flow codemod replace-existentials --write .
    ```
    
    ghstack-source-id: 4c98b8db6a80159aa6ba3f2fc3659c11939da134
    Pull Request resolved: https://github.com/facebook/react/pull/25416

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index bee847ce29..2ee501d2a4 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -238,7 +238,7 @@ type BaseFiberRootProperties = {
 
   // Node returned by Scheduler.scheduleCallback. Represents the next rendering
   // task that the root will work on.
-  callbackNode: *,
+  callbackNode: any,
   callbackPriority: Lane,
   eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,

commit a8c16a00406a204f0153c21023a04ca9a68411da
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Oct 12 23:13:39 2022 -0400

    Split Cache into its own Dispatcher (#25474)
    
    * Missing Hooks
    
    * Remove www forks. These can use __SECRET... instead.
    
    * Move cache to separate dispatcher
    
    These will be available in more contexts than just render.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 2ee501d2a4..e7b274c3ff 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -377,8 +377,6 @@ type Dispatch<A> = A => void;
 
 export type Dispatcher = {
   use?: <T>(Usable<T>) => T,
-  getCacheSignal?: () => AbortSignal,
-  getCacheForType?: <T>(resourceType: () => T) => T,
   readContext<T>(context: ReactContext<T>): T,
   useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],
   useReducer<S, I, A>(
@@ -432,3 +430,8 @@ export type Dispatcher = {
 
   unstable_isNewReconciler?: boolean,
 };
+
+export type CacheDispatcher = {
+  getCacheSignal: () => AbortSignal,
+  getCacheForType: <T>(resourceType: () => T) => T,
+};

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e7b274c3ff..10c4c9853a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 3cc792bfb53c63de34bbb1e8ca131c11faca6cba
Author: lauren <poteto@users.noreply.github.com>
Date:   Wed Oct 19 11:59:27 2022 -0700

    [useEvent] Non-stable function identity (#25473)
    
    * [useEvent] Non-stable function identity
    
    Since useEvent shouldn't go in the dependency list of whatever is
    consuming it (which is enforced by the fact that useEvent functions are
    always locally created and never passed by reference), its identity
    doesn't matter. Effectively, this PR is a runtime assertion
    that you can't rely on the return value of useEvent to be stable.
    
    * Test: Events should see latest bindings
    
    The key feature of useEvent that makes it different from useCallback
    is that events always see the latest committed values. There's no such
    thing as a "stale" event handler.
    
    * Don't queue a commit effect on mount
    
    * Inline event function wrapping
    
    - Inlines wrapping of the callback
    - Use a mutable ref-style object instead of a callable object
    - Fix types
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 10c4c9853a..a5f28fd5d2 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -290,17 +290,6 @@ type SuspenseCallbackOnlyFiberRootProperties = {
   hydrationCallbacks: null | SuspenseHydrationCallbacks,
 };
 
-// A wrapper callable object around a useEvent callback that throws if the callback is called during
-// rendering. The _impl property points to the actual implementation.
-export type EventFunctionWrapper<
-  Args,
-  Return,
-  F: (...Array<Args>) => Return,
-> = {
-  (): F,
-  _impl: F,
-};
-
 export type TransitionTracingCallbacks = {
   onTransitionStart?: (transitionName: string, startTime: number) => void,
   onTransitionProgress?: (
@@ -390,9 +379,7 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
-  useEvent?: <Args, Return, F: (...Array<Args>) => Return>(
-    callback: F,
-  ) => EventFunctionWrapper<Args, Return, F>,
+  useEvent?: <Args, Return, F: (...Array<Args>) => Return>(callback: F) => F,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit e98225485a124e35abc4cea82e6da944472ce7c7
Author: Samuel Susla <samuel.susla@gmail.com>
Date:   Tue Nov 29 16:41:02 2022 +0000

    Add ref cleanup function (#25686)
    
    Add option for ref function to return a clean up function.
    
    ```jsx
    <div ref={(_ref) => {
      // Use `_ref`
      return () => {
        // Clean up _ref
      };
    }} />
    ```
    
    If clean up function is not provided. Ref function is called with null
    like it has been before.
    
    ```jsx
    <div ref={(_ref) => {
      if (_ref) {
        // Use _ref
      } else {
        // Clean up _ref
      }
    }} />
    ```

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index a5f28fd5d2..0b7a0c4f9e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -131,6 +131,8 @@ export type Fiber = {
     | (((handle: mixed) => void) & {_stringRef: ?string, ...})
     | RefObject,
 
+  refCleanup: null | (() => void),
+
   // Input is the data coming into process this fiber. Arguments. Props.
   pendingProps: any, // This type will be more specific once we overload the tag.
   memoizedProps: any, // The props used to create the output.

commit 420f0b7fa1fcc609fc7b438c4599d0f76fab4bc0
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:06:25 2022 -0500

    Remove Reconciler fork (1/2) (#25774)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **This PR**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **#25775**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0b7a0c4f9e..478a77d6f1 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -31,13 +31,11 @@ import type {
   SuspenseInstance,
 } from './ReactFiberHostConfig';
 import type {Cache} from './ReactFiberCacheComponent.old';
-// Doing this because there's a merge conflict because of the way sync-reconciler-fork
-// is implemented
 import type {
   TracingMarkerInstance,
   Transition,
-} from './ReactFiberTracingMarkerComponent.new';
-import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.new';
+} from './ReactFiberTracingMarkerComponent.old';
+import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.old';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -416,8 +414,6 @@ export type Dispatcher = {
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
-
-  unstable_isNewReconciler?: boolean,
 };
 
 export type CacheDispatcher = {

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 478a77d6f1..4974f64d9a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -22,7 +22,7 @@ import type {
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
-import type {Lane, Lanes, LaneMap} from './ReactFiberLane.old';
+import type {Lane, Lanes, LaneMap} from './ReactFiberLane';
 import type {RootTag} from './ReactRootTags';
 import type {
   Container,
@@ -30,12 +30,12 @@ import type {
   NoTimeout,
   SuspenseInstance,
 } from './ReactFiberHostConfig';
-import type {Cache} from './ReactFiberCacheComponent.old';
+import type {Cache} from './ReactFiberCacheComponent';
 import type {
   TracingMarkerInstance,
   Transition,
-} from './ReactFiberTracingMarkerComponent.old';
-import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates.old';
+} from './ReactFiberTracingMarkerComponent';
+import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =

commit 84a0a171ea0ecd25e287bd3d3dd30e932beb4677
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Dec 14 15:08:29 2022 -0500

    Rename experimental useEvent to useEffectEvent (#25881)
    
    We originally had grand plans for using this Event concept for more but
    now it's only meant to be used in combination with effects.
    
    It's an Event in the FRP terms, that is triggered from an Effect.
    Technically it can also be from another function that itself is
    triggered from an existing side-effect but that's kind of an advanced
    case.
    
    The canonical case is an effect that triggers an event:
    
    ```js
    const onHappened = useEffectEvent(() => ...);
    useEffect(() => {
      onHappened();
    }, []);
    ```

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 4974f64d9a..f2a1eed378 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -44,7 +44,7 @@ export type HookType =
   | 'useContext'
   | 'useRef'
   | 'useEffect'
-  | 'useEvent'
+  | 'useEffectEvent'
   | 'useInsertionEffect'
   | 'useLayoutEffect'
   | 'useCallback'
@@ -379,7 +379,9 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
-  useEvent?: <Args, Return, F: (...Array<Args>) => Return>(callback: F) => F,
+  useEffectEvent?: <Args, Return, F: (...Array<Args>) => Return>(
+    callback: F,
+  ) => F,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 2b1fb91a55deb9b7b60452cb57184c2f182a42fd
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Dec 20 14:27:01 2022 -0500

    ESLint upgrade to use hermes-eslint (#25915)
    
    Hermes parser is the preferred parser for Flow code going forward. We
    need to upgrade to this parser to support new Flow syntax like function
    `this` context type annotations or `ObjectType['prop']` syntax.
    
    Unfortunately, there's quite a few upgrades here to make it work somehow
    (dependencies between the changes)
    
    - ~Upgrade `eslint` to `8.*`~ reverted this as the React eslint plugin
    tests depend on the older version and there's a [yarn
    bug](https://github.com/yarnpkg/yarn/issues/6285) that prevents
    `devDependencies` and `peerDependencies` to different versions.
    - Remove `eslint-config-fbjs` preset dependency and inline the rules,
    imho this makes it a lot clearer what the rules are.
    - Remove the turned off `jsx-a11y/*` rules and it's dependency instead
    of inlining those from the `fbjs` config.
    - Update parser and dependency from `babel-eslint` to `hermes-eslint`.
    - `ft-flow/no-unused-expressions` rule replaces `no-unused-expressions`
    which now allows standalone type asserts, e.g. `(foo: number);`
    - Bunch of globals added to the eslint config
    - Disabled `no-redeclare`, seems like the eslint upgrade started making
    this more precise and warn against re-defined globals like
    `__EXPERIMENTAL__` (in rollup scripts) or `fetch` (when importing fetch
    from node-fetch).
    - Minor lint fixes like duplicate keys in objects.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f2a1eed378..edc120182e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -403,10 +403,10 @@ export type Dispatcher = {
     boolean,
     (callback: () => void, options?: StartTransitionOptions) => void,
   ],
-  useMutableSource<Source, Snapshot>(
-    source: MutableSource<Source>,
-    getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
-    subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
+  useMutableSource<TSource, Snapshot>(
+    source: MutableSource<TSource>,
+    getSnapshot: MutableSourceGetSnapshotFn<TSource, Snapshot>,
+    subscribe: MutableSourceSubscribeFn<TSource, Snapshot>,
   ): Snapshot,
   useSyncExternalStore<T>(
     subscribe: (() => void) => () => void,

commit db281b3d9cd033cdc3d63e00fc9f3153c03aa70c
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 17 18:05:11 2023 -0400

    Feature: Suspend commit without blocking render (#26398)
    
    This adds a new capability for renderers (React DOM, React Native):
    prevent a tree from being displayed until it is ready, showing a
    fallback if necessary, but without blocking the React components from
    being evaluated in the meantime.
    
    A concrete example is CSS loading: React DOM can block a commit from
    being applied until the stylesheet has loaded. This allows us to load
    the CSS asynchronously, while also preventing a flash of unstyled
    content. Images and fonts are some of the other use cases.
    
    You can think of this as "Suspense for the commit phase". Traditional
    Suspense, i.e. with `use`, blocking during the render phase: React
    cannot proceed with rendering until the data is available. But in the
    case of things like stylesheets, you don't need the CSS in order to
    evaluate the component. It just needs to be loaded before the tree is
    committed. Because React buffers its side effects and mutations, it can
    do work in parallel while the stylesheets load in the background.
    
    Like regular Suspense, a "suspensey" stylesheet or image will trigger
    the nearest Suspense fallback if it hasn't loaded yet. For now, though,
    we only do this for non-urgent updates, like with startTransition. If
    you render a suspensey resource during an urgent update, it will revert
    to today's behavior. (We may or may not add a way to suspend the commit
    during an urgent update in the future.)
    
    In this PR, I have implemented this capability in the reconciler via new
    methods added to the host config. I've used our internal React "no-op"
    renderer to write tests that demonstrate the feature. I have not yet
    implemented Suspensey CSS, images, etc in React DOM. @gnoff and I will
    work on that in subsequent PRs.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index edc120182e..7f01daa524 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -227,6 +227,10 @@ type BaseFiberRootProperties = {
   // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
   // it's superseded by a new one.
   timeoutHandle: TimeoutHandle | NoTimeout,
+  // When a root has a pending commit scheduled, calling this function will
+  // cancel it.
+  // TODO: Can this be consolidated with timeoutHandle?
+  cancelPendingCommit: null | (() => void),
   // Top context object, used by renderSubtreeIntoContainer
   context: Object | null,
   pendingContext: Object | null,

commit d12bdcda69afd219f4d91cbd60d6fae2a375d35b
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Sat Mar 25 20:24:00 2023 +0100

    Fix Flow types of useEffectEvent (#26468)
    
    ## Summary
    
    Just copied the types over from the internal types. Type error was
    hidden by overly broad FlowFixMe. With `$FlowFixMe[not-a-function]` we
    would've seen the actual issue:
    ```
    Cannot return `dispatcher.useEffectEvent(...)` because  `T` [1] is incompatible with  undefined [2].Flow(incompatible-return)
    ```
    
    ## How did you test this change?
    
    - [x] yarn flow dom-node
    - [x] CI

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 7f01daa524..a672b9669a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -383,9 +383,7 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
-  useEffectEvent?: <Args, Return, F: (...Array<Args>) => Return>(
-    callback: F,
-  ) => F,
+  useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 09c8d2563300621dc91258a4c2839210e2fbdf0e
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 31 13:04:08 2023 -0400

    Move update scheduling to microtask (#26512)
    
    When React receives new input (via `setState`, a Suspense promise
    resolution, and so on), it needs to ensure there's a rendering task
    associated with the update. Most of this happens
    `ensureRootIsScheduled`.
    
    If a single event contains multiple updates, we end up running the
    scheduling code once per update. But this is wasteful because we really
    only need to run it once, at the end of the event (or in the case of
    flushSync, at the end of the scope function's execution).
    
    So this PR moves the scheduling logic to happen in a microtask instead.
    In some cases, we will force it run earlier than that, like for
    `flushSync`, but since updates are batched by default, it will almost
    always happen in the microtask. Even for discrete updates.
    
    In production, this should have no observable behavior difference. In a
    testing environment that uses `act`, this should also not have a
    behavior difference because React will push these tasks to an internal
    `act` queue.
    
    However, tests that do not use `act` and do not simulate an actual
    production environment (like an e2e test) may be affected. For example,
    before this change, if a test were to call `setState` outside of `act`
    and then immediately call `jest.runAllTimers()`, the update would be
    synchronously applied. After this change, that will no longer work
    because the rendering task (a timer, in this case) isn't scheduled until
    after the microtask queue has run.
    
    I don't expect this to be an issue in practice because most people do
    not write their tests this way. They either use `act`, or they write
    e2e-style tests.
    
    The biggest exception has been... our own internal test suite. Until
    recently, many of our tests were written in a way that accidentally
    relied on the updates being scheduled synchronously. Over the past few
    weeks, @tyao1 and I have gradually converted the test suite to use a new
    set of testing helpers that are resilient to this implementation detail.
    
    (There are also some old Relay tests that were written in the style of
    React's internal test suite. Those will need to be fixed, too.)
    
    The larger motivation behind this change, aside from a minor performance
    improvement, is we intend to use this new microtask to perform
    additional logic that doesn't yet exist. Like inferring the priority of
    a custom event.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index a672b9669a..ae1e75bfe9 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -240,6 +240,10 @@ type BaseFiberRootProperties = {
     MutableSource<any> | MutableSourceVersion,
   > | null,
 
+  // Used to create a linked list that represent all the roots that have
+  // pending work scheduled on them.
+  next: FiberRoot | null,
+
   // Node returned by Scheduler.scheduleCallback. Represents the next rendering
   // task that the root will work on.
   callbackNode: any,

commit b55d31955982851284bb437a5187a6c56e366539
Author: Josh Story <story@hey.com>
Date:   Mon Apr 10 14:58:44 2023 -0700

    Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)
    
    part of https://github.com/facebook/react/pull/26571
    
    merging separately to improve tracking of files renames in git
    
    Rename HostConfig files to FiberConfig to clarify they are configs for
    Fiber and not Fizz/Flight. This better conforms to the naming used in
    Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index ae1e75bfe9..c726408317 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -29,7 +29,7 @@ import type {
   TimeoutHandle,
   NoTimeout,
   SuspenseInstance,
-} from './ReactFiberHostConfig';
+} from './ReactFiberConfig';
 import type {Cache} from './ReactFiberCacheComponent';
 import type {
   TracingMarkerInstance,

commit 58742c21b8c3237e8b66c7df4e200504846a01ae
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 11 08:23:04 2023 -0400

    Delete unused `eventTimes` Fiber field (#26599)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c726408317..281186c53d 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -248,7 +248,6 @@ type BaseFiberRootProperties = {
   // task that the root will work on.
   callbackNode: any,
   callbackPriority: Lane,
-  eventTimes: LaneMap<number>,
   expirationTimes: LaneMap<number>,
   hiddenUpdates: LaneMap<Array<ConcurrentUpdate> | null>,
 

commit 7ce765ec321a6f213019b56b36f9dccb2a8a7d5c
Author: Andrew Clark <git@andrewclark.io>
Date:   Sun Apr 23 14:50:17 2023 -0400

    Clean up enableUseHook flag (#26707)
    
    This has been statically enabled everywhere for months.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 281186c53d..1421181cb8 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -372,7 +372,7 @@ type BasicStateAction<S> = (S => S) | S;
 type Dispatch<A> = A => void;
 
 export type Dispatcher = {
-  use?: <T>(Usable<T>) => T,
+  use: <T>(Usable<T>) => T,
   readContext<T>(context: ReactContext<T>): T,
   useState<S>(initialState: (() => S) | S): [S, Dispatch<BasicStateAction<S>>],
   useReducer<S, I, A>(

commit 540bab085d571789f4562565eebfd0db9f36345c
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 26 18:19:58 2023 -0400

    Implement experimental_useFormStatus (#26722)
    
    This hook reads the status of its ancestor form component, if it exists.
    
    ```js
    const {pending, data, action, method} = useFormStatus();
    ```
    
    It can be used to implement a loading indicator, for example. You can
    think of it as a shortcut for implementing a loading state with the
    useTransition hook.
    
    For now, it's only available in the experimental channel. We'll share
    docs once its closer to being stable. There are additional APIs that
    will ship alongside it.
    
    Internally it's implemented using startTransition + a context object.
    That's a good way to think about its behavior, but the actual
    implementation details may change in the future.
    
    Because form elements cannot be nested, the implementation in the
    reconciler does not bother to keep track of multiple nested "transition
    providers". So although it's implemented using generic Fiber config
    methods, it does currently make some assumptions based on React DOM's
    requirements.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1421181cb8..bc9cfd1fb3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -29,6 +29,7 @@ import type {
   TimeoutHandle,
   NoTimeout,
   SuspenseInstance,
+  TransitionStatus,
 } from './ReactFiberConfig';
 import type {Cache} from './ReactFiberCacheComponent';
 import type {
@@ -421,6 +422,9 @@ export type Dispatcher = {
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
+  useHostTransitionStatus?: (
+    initialStatus: TransitionStatus,
+  ) => TransitionStatus,
 };
 
 export type CacheDispatcher = {

commit efbd68511db472120afa0f3eba78a7462f25ed30
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Fri Apr 28 23:18:10 2023 +0200

    Remove unused `initialStatus` parameter from `useHostTransitionStatus` (#26743)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index bc9cfd1fb3..b177db722d 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -422,9 +422,7 @@ export type Dispatcher = {
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
-  useHostTransitionStatus?: (
-    initialStatus: TransitionStatus,
-  ) => TransitionStatus,
+  useHostTransitionStatus?: () => TransitionStatus,
 };
 
 export type CacheDispatcher = {

commit 491aec5d6113ce5bae7c10966bc38a4a8fc091a8
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 1 13:19:20 2023 -0400

    Implement experimental_useOptimisticState (#26740)
    
    This adds an experimental hook tentatively called useOptimisticState.
    (The actual name needs some bikeshedding.)
    
    The headline feature is that you can use it to implement optimistic
    updates. If you set some optimistic state during a transition/action,
    the state will be automatically reverted once the transition completes.
    
    Another feature is that the optimistic updates will be continually
    rebased on top of the latest state.
    
    It's easiest to explain with examples; we'll publish documentation as
    the API gets closer to stabilizing. See tests for now.
    
    Technically the use cases for this hook are broader than just optimistic
    updates; you could use it implement any sort of "pending" state, such as
    the ones exposed by useTransition and useFormStatus. But we expect
    people will most often reach for this hook to implement the optimistic
    update pattern; simpler cases are covered by those other hooks.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index b177db722d..c70ea5a1a5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -57,7 +57,8 @@ export type HookType =
   | 'useMutableSource'
   | 'useSyncExternalStore'
   | 'useId'
-  | 'useCacheRefresh';
+  | 'useCacheRefresh'
+  | 'useOptimisticState';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -423,6 +424,10 @@ export type Dispatcher = {
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
   useHostTransitionStatus?: () => TransitionStatus,
+  useOptimisticState?: <S, A>(
+    passthrough: S,
+    reducer: ?(S, A) => S,
+  ) => [S, (A) => void],
 };
 
 export type CacheDispatcher = {

commit b7972822b5887d05ae772ef757a453265b4b7aec
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed May 3 14:26:00 2023 -0400

    useOptimisticState -> useOptimistic (#26772)
    
    Drop the "state". Just "useOptimistic". It's cleaner.
    
    This is still an experimental API. May not be the final name.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index c70ea5a1a5..fd08c6f85c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -58,7 +58,7 @@ export type HookType =
   | 'useSyncExternalStore'
   | 'useId'
   | 'useCacheRefresh'
-  | 'useOptimisticState';
+  | 'useOptimistic';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -424,7 +424,7 @@ export type Dispatcher = {
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
   useHostTransitionStatus?: () => TransitionStatus,
-  useOptimisticState?: <S, A>(
+  useOptimistic?: <S, A>(
     passthrough: S,
     reducer: ?(S, A) => S,
   ) => [S, (A) => void],

commit 80d9a40114bb43c07d021e8254790852f450bd2b
Author: Noah Lemen <noah.lemen@gmail.com>
Date:   Tue Jun 27 12:45:46 2023 -0400

    Remove useMutableSource (#27011)
    
    ## Summary
    
    This PR cleans up `useMutableSource`. This has been blocked by a
    remaining dependency internally at Meta, but that has now been deleted.
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    ## How did you test this change?
    
    ```
    yarn flow
    yarn lint
    yarn test --prod
    ```
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index fd08c6f85c..eae140ac4e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -11,10 +11,6 @@ import type {Source} from 'shared/ReactElementType';
 import type {
   RefObject,
   ReactContext,
-  MutableSourceSubscribeFn,
-  MutableSourceGetSnapshotFn,
-  MutableSourceVersion,
-  MutableSource,
   StartTransitionOptions,
   Wakeable,
   Usable,
@@ -54,7 +50,6 @@ export type HookType =
   | 'useDebugValue'
   | 'useDeferredValue'
   | 'useTransition'
-  | 'useMutableSource'
   | 'useSyncExternalStore'
   | 'useId'
   | 'useCacheRefresh'
@@ -237,11 +232,6 @@ type BaseFiberRootProperties = {
   context: Object | null,
   pendingContext: Object | null,
 
-  // Used by useMutableSource hook to avoid tearing during hydration.
-  mutableSourceEagerHydrationData?: Array<
-    MutableSource<any> | MutableSourceVersion,
-  > | null,
-
   // Used to create a linked list that represent all the roots that have
   // pending work scheduled on them.
   next: FiberRoot | null,
@@ -257,7 +247,6 @@ type BaseFiberRootProperties = {
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
   expiredLanes: Lanes,
-  mutableReadLanes: Lanes,
   errorRecoveryDisabledLanes: Lanes,
 
   finishedLanes: Lanes,
@@ -410,11 +399,6 @@ export type Dispatcher = {
     boolean,
     (callback: () => void, options?: StartTransitionOptions) => void,
   ],
-  useMutableSource<TSource, Snapshot>(
-    source: MutableSource<TSource>,
-    getSnapshot: MutableSourceGetSnapshotFn<TSource, Snapshot>,
-    subscribe: MutableSourceSubscribeFn<TSource, Snapshot>,
-  ): Snapshot,
   useSyncExternalStore<T>(
     subscribe: (() => void) => () => void,
     getSnapshot: () => T,

commit fc801116c80b68f7ebdaf66ac77d5f2dcd9e50eb
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 29 16:05:00 2023 -0400

    Detect crashes caused by Async Client Components (#27019)
    
    Suspending with an uncached promise is not yet supported. We only
    support suspending on promises that are cached between render attempts.
    (We do plan to partially support this in the future, at least in certain
    constrained cases, like during a route transition.)
    
    This includes the case where a component returns an uncached promise,
    which is effectively what happens if a Client Component is authored
    using async/await syntax.
    
    This is an easy mistake to make in a Server Components app, because
    async/await _is_ available in Server Components.
    
    In the current behavior, this can sometimes cause the app to crash with
    an infinite loop, because React will repeatedly keep trying to render
    the component, which will result in a fresh promise, which will result
    in a new render attempt, and so on. We have some strategies we can use
    to prevent this — during a concurrent render, we can suspend the work
    loop until the promise resolves. If it's not a concurrent render, we can
    show a Suspense fallback and try again at concurrent priority.
    
    There's one case where neither of these strategies work, though: during
    a sync render when there's no parent Suspense boundary. (We refer to
    this as the "shell" of the app because it exists outside of any loading
    UI.)
    
    Since we don't have any great options for this scenario, we should at
    least error gracefully instead of crashing the app.
    
    So this commit adds a detection mechanism for render loops caused by
    async client components. The way it works is, if an app suspends
    repeatedly in the shell during a synchronous render, without committing
    anything in between, we will count the number of attempts and eventually
    trigger an error once the count exceeds a threshold.
    
    In the future, we will consider ways to make this case a warning instead
    of a hard error.
    
    See https://github.com/facebook/react/issues/26801 for more details.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index eae140ac4e..50a0ec85f9 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -248,6 +248,7 @@ type BaseFiberRootProperties = {
   pingedLanes: Lanes,
   expiredLanes: Lanes,
   errorRecoveryDisabledLanes: Lanes,
+  shellSuspendCounter: number,
 
   finishedLanes: Lanes,
 

commit b4cdd3e8922713f8c9817b004a0dc51be47bc5df
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Aug 23 10:58:09 2023 -0400

    Scaffolding for useFormState (#27270)
    
    This exposes, but does not yet implement, a new experimental API called
    useFormState. It's gated behind the enableAsyncActions flag.
    
    useFormState has a similar signature to useReducer, except instead of a
    reducer it accepts an (async) action function. React will wait until the
    promise resolves before updating the state:
    
    ```js
    async function action(prevState, payload) {
      // ..
    }
    const [state, dispatch] = useFormState(action, initialState)
    ```
    
    When used in combination with Server Actions, it will also support
    progressive enhancement — a form that is submitted before it has
    hydrated will have its state transferred to the next page. However, like
    the other action-related hooks, it works with fully client-driven
    actions, too.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 50a0ec85f9..2372fc1305 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -53,7 +53,8 @@ export type HookType =
   | 'useSyncExternalStore'
   | 'useId'
   | 'useCacheRefresh'
-  | 'useOptimistic';
+  | 'useOptimistic'
+  | 'useFormState';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -413,6 +414,11 @@ export type Dispatcher = {
     passthrough: S,
     reducer: ?(S, A) => S,
   ) => [S, (A) => void],
+  useFormState?: <S, P>(
+    action: (S, P) => S,
+    initialState: S,
+    url?: string,
+  ) => [S, (P) => void],
 };
 
 export type CacheDispatcher = {

commit 456d153bb582798effa76c09bec2405ab2e392cf
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Aug 28 11:05:40 2023 -0400

    Client implementation of useFormState (#27278)
    
    This implements useFormState in Fiber. (It does not include any
    progressive enhancement features; those will be added later.)
    
    useFormState is a hook for tracking state produced by async actions. It
    has a signature similar to useReducer, but instead of a reducer, it
    accepts an async action function.
    
    ```js
    async function action(prevState, payload) {
      // ..
    }
    const [state, dispatch] = useFormState(action, initialState)
    ```
    
    Calling dispatch runs the async action and updates the state to the
    returned value.
    
    Async actions run before React's render cycle, so unlike reducers, they
    can contain arbitrary side effects.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 2372fc1305..e852057f20 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -415,7 +415,7 @@ export type Dispatcher = {
     reducer: ?(S, A) => S,
   ) => [S, (A) => void],
   useFormState?: <S, P>(
-    action: (S, P) => S,
+    action: (S, P) => Promise<S>,
     initialState: S,
     url?: string,
   ) => [S, (P) => void],

commit ddff504695f33c19e8c0792bff82bd8f8b8f7c05
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Aug 29 11:58:44 2023 -0400

    useFormState's permalink option changes form target (#27302)
    
    When the `permalink` option is passed to `useFormState`, and the form is
    submitted before it has hydrated, the permalink will be used as the
    target of the form action, enabling MPA-style form submissions.
    
    (Note that submitting a form without hydration is a feature of Server
    Actions; it doesn't work with regular client actions.)
    
    It does not have any effect after the form has hydrated.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e852057f20..8dae4fa10e 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -417,7 +417,7 @@ export type Dispatcher = {
   useFormState?: <S, P>(
     action: (S, P) => Promise<S>,
     initialState: S,
-    url?: string,
+    permalink?: string,
   ) => [S, (P) => void],
 };
 

commit 612b2b6601abb844248c384d1e288bb824b180b7
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 13 18:30:40 2023 -0400

    useFormState: Reuse state from previous form submission (#27321)
    
    If a Server Action is passed to useFormState, the action may be
    submitted before it has hydrated. This will trigger a full page
    (MPA-style) navigation. We can transfer the form state to the next page
    by comparing the key path of the hook instance.
    
    `ReactServerDOMServer.decodeFormState` is used by the server to extract
    the form state from the submitted action. This value can then be passed
    as an option when rendering the new page. It must be passed during both
    SSR and hydration.
    
    ```js
    const boundAction = await decodeAction(formData, serverManifest);
    const result = await boundAction();
    const formState = decodeFormState(result, formData, serverManifest);
    
    // SSR
    const response = createFromReadableStream(<App />);
    const ssrStream = await renderToReadableStream(response, { formState })
    
    // Hydration
    hydrateRoot(container, <App />, { formState });
    ```
    
    If the `formState` option is omitted, then the state won't be
    transferred to the next page. However, it must be passed in both places,
    or in neither; misconfiguring will result in a hydration mismatch.
    
    (The `formState` option is currently prefixed with `experimental_`)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 8dae4fa10e..e6b002d0e3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -14,6 +14,7 @@ import type {
   StartTransitionOptions,
   Wakeable,
   Usable,
+  ReactFormState,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -270,6 +271,8 @@ type BaseFiberRootProperties = {
     error: mixed,
     errorInfo: {digest?: ?string, componentStack?: ?string},
   ) => void,
+
+  formState: ReactFormState<any> | null,
 };
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit 95c9554bc72813b0ee2b028774bb7cf0482887ba
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 13 20:46:22 2023 -0400

    useFormState: Compare action signatures when reusing form state (#27370)
    
    During an MPA form submission, useFormState should only reuse the form
    state if same action is passed both times. (We also compare the key
    paths.)
    
    We compare the identity of the inner closure function, disregarding the
    value of the bound arguments. That way you can pass an inline Server
    Action closure:
    
    ```js
    function FormContainer({maxLength}) {
      function submitAction(prevState, formData) {
        'use server'
        if (formData.get('field').length > maxLength) {
          return { errorMsg: 'Too many characters' };
        }
        // ...
      }
      return <Form submitAction={submitAction} />
    }
    ```

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e6b002d0e3..b603a9fec3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -272,7 +272,7 @@ type BaseFiberRootProperties = {
     errorInfo: {digest?: ?string, componentStack?: ?string},
   ) => void,
 
-  formState: ReactFormState<any> | null,
+  formState: ReactFormState<any, any> | null,
 };
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit be67db46b60d94f9fbefccf2523429af25873e5b
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 10 16:39:02 2023 -0400

    Add optional initialValue argument to useDeferredValue (#27500)
    
    Adds a second argument to useDeferredValue called initialValue:
    
    ```js
    const value = useDeferredValue(finalValue, initialValue);
    ```
    
    During the initial render of a component, useDeferredValue will return
    initialValue. Once that render finishes, it will spawn an additional
    render to switch to finalValue.
    
    This same sequence should occur whenever the hook is hidden and revealed
    again, i.e. by a Suspense or Activity, though this part is not yet
    implemented.
    
    When initialValue is not provided, useDeferredValue has no effect during
    initial render, but during an update, it will remain on the previous
    value, then spawn an additional render to switch to the new value. (This
    is the same behavior that exists today.)
    
    During SSR, initialValue is always used, if provided.
    
    This feature is currently behind an experimental flag. We plan to ship
    it in a non-breaking release.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index b603a9fec3..9378a41477 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -399,7 +399,7 @@ export type Dispatcher = {
     deps: Array<mixed> | void | null,
   ): void,
   useDebugValue<T>(value: T, formatterFn: ?(value: T) => mixed): void,
-  useDeferredValue<T>(value: T): T,
+  useDeferredValue<T>(value: T, initialValue?: T): T,
   useTransition(): [
     boolean,
     (callback: () => void, options?: StartTransitionOptions) => void,

commit 77c4ac2ce88736bbdfe0b29008b5df931c2beb1e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 31 23:32:31 2023 -0400

    [useFormState] Allow sync actions (#27571)
    
    Updates useFormState to allow a sync function to be passed as an action.
    
    A form action is almost always async, because it needs to talk to the
    server. But since we support client-side actions, too, there's no reason
    we can't allow sync actions, too.
    
    I originally chose not to allow them to keep the implementation simpler
    but it's not really that much more complicated because we already
    support this for actions passed to startTransition. So now it's
    consistent: anywhere an action is accepted, a sync client function is a
    valid input.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 9378a41477..e03ac26a01 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -15,6 +15,7 @@ import type {
   Wakeable,
   Usable,
   ReactFormState,
+  Awaited,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -418,10 +419,10 @@ export type Dispatcher = {
     reducer: ?(S, A) => S,
   ) => [S, (A) => void],
   useFormState?: <S, P>(
-    action: (S, P) => Promise<S>,
-    initialState: S,
+    action: (Awaited<S>, P) => S,
+    initialState: Awaited<S>,
     permalink?: string,
-  ) => [S, (P) => void],
+  ) => [Awaited<S>, (P) => void],
 };
 
 export type CacheDispatcher = {

commit 37d901e2b81e12d40df7012c6f8681b8272d2555
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Feb 7 13:38:00 2024 -0800

    Remove __self and __source location from elements (#28265)
    
    Along with all the places using it like the `_debugSource` on Fiber.
    This still lets them be passed into `createElement` (and JSX dev
    runtime) since those can still be used in existing already compiled code
    and we don't want that to start spreading to DOM attributes.
    
    We used to have a DEV mode that compiles the source location of JSX into
    the compiled output. This was nice because we could get the actual call
    site of the JSX (instead of just somewhere in the component). It had a
    bunch of issues though:
    
    - It only works with JSX.
    - The way this source location is compiled is different in all the
    pipelines along the way. It relies on this transform being first and the
    source location we want to extract but it doesn't get preserved along
    source maps and don't have a way to be connected to the source hosted by
    the source maps. Ideally it should just use the mechanism other source
    maps use.
    - Since it's expensive it only works in DEV so if it's used for
    component stacks it would vary between dev and prod.
    - It only captures the callsite of the JSX and not the stack between the
    component and that callsite. In the happy case it's in the component but
    not always.
    
    Instead, we have another zero-cost trick to extract the call site of
    each component lazily only if it's needed. This ensures that component
    stacks are the same in DEV and PROD. At the cost of worse line number
    information.
    
    The better way to get the JSX call site would be to get it from `new
    Error()` or `console.createTask()` inside the JSX runtime which can
    capture the whole stack in a consistent way with other source mappings.
    We might explore that in the future.
    
    This removes source location info from React DevTools and React Native
    Inspector. The "jump to source code" feature or inspection can be made
    lazy instead by invoking the lazy component stack frame generation. That
    way it can be made to work in prod too. The filtering based on file path
    is a bit trickier.
    
    When redesigned this UI should ideally also account for more than one
    stack frame.
    
    With this change the DEV only Babel transforms are effectively
    deprecated since they're not necessary for anything.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e03ac26a01..f4ec8ab186 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -7,7 +7,6 @@
  * @flow
  */
 
-import type {Source} from 'shared/ReactElementType';
 import type {
   RefObject,
   ReactContext,
@@ -200,7 +199,6 @@ export type Fiber = {
   // to be the same as work in progress.
   // __DEV__ only
 
-  _debugSource?: Source | null,
   _debugOwner?: Fiber | null,
   _debugIsCurrentlyTiming?: boolean,
   _debugNeedsRemount?: boolean,

commit 3f93ca1c8dec1fd85df4dbb748a2df9438fc699f
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Feb 12 14:56:59 2024 -0500

    [Fiber] Transfer `_debugInfo` from Arrays, Lazy, Thenables and Elements to the inner Fibers. (#28286)
    
    That way we can use it for debug information like component stacks and
    DevTools. I used an extra stack argument in Child Fiber to track this as
    it's flowing down since it's not just elements where we have this info
    readily available but parent arrays and lazy can merge this into the
    Fiber too. It's not great that this is a dev-only argument and I could
    track it globally but seems more likely to make mistakes.
    
    It is possible for the same debug info to appear for multiple child
    fibers like when it's attached to a fragment or a lazy that resolves to
    a fragment at the root. The object identity could be used in these
    scenarios to infer if that's really one server component that's a parent
    of all children or if each child has a server component with the same
    name.
    
    This is effectively a public API because you can use it to stash
    information on Promises from a third-party service - not just Server
    Components. I started outline the types for this for some things I was
    planning to add but it's not final.
    
    I was also planning on storing it from `use(thenable)` for when you
    suspend on a Promise. However, I realized that there's no Hook instance
    for those to stash it on. So it might need a separate data structure to
    stash the previous pass over of `use()` that resets each render.
    
    No tests yet since I didn't want to test internals but it'll be covered
    once we have debugging features like component stacks.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f4ec8ab186..126bb02cfd 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -15,6 +15,7 @@ import type {
   Usable,
   ReactFormState,
   Awaited,
+  ReactDebugInfo,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -199,6 +200,7 @@ export type Fiber = {
   // to be the same as work in progress.
   // __DEV__ only
 
+  _debugInfo?: ReactDebugInfo | null,
   _debugOwner?: Fiber | null,
   _debugIsCurrentlyTiming?: boolean,
   _debugNeedsRemount?: boolean,

commit 49441e342f0c5252eb24bb352cf76ac59aef353c
Author: bubucuo <bubucuo@users.noreply.github.com>
Date:   Wed Feb 21 03:31:15 2024 +0800

    refactor: remove dead code of fiber (#28389)
    
    The `nextEffect` property of the `fiber` is currently not being used and
    has become dead code. It can be safely removed.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 126bb02cfd..d643b1f9c2 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -157,9 +157,6 @@ export type Fiber = {
   subtreeFlags: Flags,
   deletions: Array<Fiber> | null,
 
-  // Singly linked list fast path to the next fiber with side-effects.
-  nextEffect: Fiber | null,
-
   // The first and last fiber with side-effect within this subtree. This allows
   // us to reuse a slice of the linked list when we reuse the work done within
   // this fiber.

commit ddd736d2589c972e1ac75402f2e2e833e97ad61a
Author: bubucuo <bubucuo@users.noreply.github.com>
Date:   Wed Feb 21 19:17:21 2024 +0800

    refactor: remove dead types of fiber (#28405)
    
    The properties `firstEffect` and `lastEffect` of the Fiber are currently
    not being used and are considered to be dead code, and can be removed.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index d643b1f9c2..0227970a77 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -157,12 +157,6 @@ export type Fiber = {
   subtreeFlags: Flags,
   deletions: Array<Fiber> | null,
 
-  // The first and last fiber with side-effect within this subtree. This allows
-  // us to reuse a slice of the linked list when we reuse the work done within
-  // this fiber.
-  firstEffect: Fiber | null,
-  lastEffect: Fiber | null,
-
   lanes: Lanes,
   childLanes: Lanes,
 

commit 17eaacaac167addf0c4358b4983f054073a0626d
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 12 15:50:11 2024 -0400

    Add pending state to useFormState (#28514)
    
    ## Overview
    
    Adds a `pending` state to useFormState, which will be replaced by
    `useActionState` in the next diff. We will keep `useFormState` around
    for backwards compatibility, but functionally it will work the same as
    `useActionState`, which has an `isPending` state returned.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0227970a77..8d3e99b986 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -413,7 +413,7 @@ export type Dispatcher = {
     action: (Awaited<S>, P) => S,
     initialState: Awaited<S>,
     permalink?: string,
-  ) => [Awaited<S>, (P) => void],
+  ) => [Awaited<S>, (P) => void, boolean],
 };
 
 export type CacheDispatcher = {

commit 5c65b27587c0507d66a84e055de948fc62d471d4
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Mar 22 13:03:44 2024 -0400

    Add `React.useActionState` (#28491)
    
    ## Overview
    
    _Depends on https://github.com/facebook/react/pull/28514_
    
    This PR adds a new React hook called `useActionState` to replace and
    improve the ReactDOM `useFormState` hook.
    
    ## Motivation
    
    This hook intends to fix some of the confusion and limitations of the
    `useFormState` hook.
    
    The `useFormState` hook is only exported from the `ReactDOM` package and
    implies that it is used only for the state of `<form>` actions, similar
    to `useFormStatus` (which is only for `<form>` element status). This
    leads to understandable confusion about why `useFormState` does not
    provide a `pending` state value like `useFormStatus` does.
    
    The key insight is that the `useFormState` hook does not actually return
    the state of any particular form at all. Instead, it returns the state
    of the _action_ passed to the hook, wrapping it and returning a
    trackable action to add to a form, and returning the last returned value
    of the action given. In fact, `useFormState` doesn't need to be used in
    a `<form>` at all.
    
    Thus, adding a `pending` value to `useFormState` as-is would thus be
    confusing because it would only return the pending state of the _action_
    given, not the `<form>` the action is passed to. Even if we wanted to
    tie them together, the returned `action` can be passed to multiple
    forms, creating confusing and conflicting pending states during multiple
    form submissions.
    
    Additionally, since the action is not related to any particular
    `<form>`, the hook can be used in any renderer - not only `react-dom`.
    For example, React Native could use the hook to wrap an action, pass it
    to a component that will unwrap it, and return the form result state and
    pending state. It's renderer agnostic.
    
    To fix these issues, this PR:
    - Renames `useFormState` to `useActionState`
    - Adds a `pending` state to the returned tuple
    - Moves the hook to the `'react'` package
    
    ## Reference
    
    The `useFormState` hook allows you to track the pending state and return
    value of a function (called an "action"). The function passed can be a
    plain JavaScript client function, or a bound server action to a
    reference on the server. It accepts an optional `initialState` value
    used for the initial render, and an optional `permalink` argument for
    renderer specific pre-hydration handling (such as a URL to support
    progressive hydration in `react-dom`).
    
    Type:
    
    ```ts
    function useActionState<State>(
            action: (state: Awaited<State>) => State | Promise<State>,
            initialState: Awaited<State>,
            permalink?: string,
        ): [state: Awaited<State>, dispatch: () => void, boolean];
    ```
    
    The hook returns a tuple with:
    - `state`: the last state the action returned
    - `dispatch`: the method to call to dispatch the wrapped action
    - `pending`: the pending state of the action and any state updates
    contained
    
    Notably, state updates inside of the action dispatched are wrapped in a
    transition to keep the page responsive while the action is completing
    and the UI is updated based on the result.
    
    ## Usage
    
    The `useActionState` hook can be used similar to `useFormState`:
    
    ```js
    import { useActionState } from "react"; // not react-dom
    
    function Form({ formAction }) {
      const [state, action, isPending] = useActionState(formAction);
    
      return (
        <form action={action}>
          <input type="email" name="email" disabled={isPending} />
          <button type="submit" disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </form>
      );
    }
    ```
    
    But it doesn't need to be used with a `<form/>` (neither did
    `useFormState`, hence the confusion):
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(someAction);
    
      async function handleSubmit() {
        // See caveats below
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    ## Benefits
    
    One of the benefits of using this hook is the automatic tracking of the
    return value and pending states of the wrapped function. For example,
    the above example could be accomplished via:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction }) {
      const ref = useRef(null);
      const [state, setState] = useState(null);
      const [isPending, setIsPending] = useTransition();
    
      function handleSubmit() {
        startTransition(async () => {
          const response = await someAction({ email: ref.current.value });
          setState(response);
        });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    However, this hook adds more benefits when used with render specific
    elements like react-dom `<form>` elements and Server Action. With
    `<form>` elements, React will automatically support replay actions on
    the form if it is submitted before hydration has completed, providing a
    form of partial progressive enhancement: enhancement for when javascript
    is enabled but not ready.
    
    Additionally, with the `permalink` argument and Server Actions,
    frameworks can provide full progressive enhancement support, submitting
    the form to the URL provided along with the FormData from the form. On
    submission, the Server Action will be called during the MPA navigation,
    similar to any raw HTML app, server rendered, and the result returned to
    the client without any JavaScript on the client.
    
    ## Caveats
    There are a few Caveats to this new hook:
    **Additional state update**: Since we cannot know whether you use the
    pending state value returned by the hook, the hook will always set the
    `isPending` state at the beginning of the first chained action,
    resulting in an additional state update similar to `useTransition`. In
    the future a type-aware compiler could optimize this for when the
    pending state is not accessed.
    
    **Pending state is for the action, not the handler**: The difference is
    subtle but important, the pending state begins when the return action is
    dispatched and will revert back after all actions and transitions have
    settled. The mechanism for this under the hook is the same as
    useOptimisitic.
    
    Concretely, what this means is that the pending state of
    `useActionState` will not represent any actions or sync work performed
    before dispatching the action returned by `useActionState`. Hopefully
    this is obvious based on the name and shape of the API, but there may be
    some temporary confusion.
    
    As an example, let's take the above example and await another action
    inside of it:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(someAction);
    
      async function handleSubmit() {
        await someOtherAction();
    
        // The pending state does not start until this call.
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    
    ```
    
    Since the pending state is related to the action, and not the handler or
    form it's attached to, the pending state only changes when the action is
    dispatched. To solve, there are two options.
    
    First (recommended): place the other function call inside of the action
    passed to `useActionState`:
    
    ```js
    import { useActionState, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
      const [state, action, isPending] = useActionState(async (data) => {
        // Pending state is true already.
        await someOtherAction();
        return someAction(data);
      });
    
      async function handleSubmit() {
        // The pending state starts at this call.
        await action({ email: ref.current.value });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    For greater control, you can also wrap both in a transition and use the
    `isPending` state of the transition:
    
    ```js
    import { useActionState, useTransition, useRef } from "react";
    
    function Form({ someAction, someOtherAction }) {
      const ref = useRef(null);
    
      // isPending is used from the transition wrapping both action calls.
      const [isPending, startTransition] = useTransition();
    
      // isPending not used from the individual action.
      const [state, action] = useActionState(someAction);
    
      async function handleSubmit() {
        startTransition(async () => {
          // The transition pending state has begun.
          await someOtherAction();
          await action({ email: ref.current.value });
        });
      }
    
      return (
        <div>
          <input ref={ref} type="email" name="email" disabled={isPending} />
          <button onClick={handleSubmit} disabled={isPending}>
            Submit
          </button>
          {state.errorMessage && <p>{state.errorMessage}</p>}
        </div>
      );
    }
    ```
    
    A similar technique using `useOptimistic` is preferred over using
    `useTransition` directly, and is left as an exercise to the reader.
    
    ## Thanks
    
    Thanks to @ryanflorence @mjackson @wesbos
    (https://github.com/facebook/react/issues/27980#issuecomment-1960685940)
    and [Allan
    Lasser](https://allanlasser.com/posts/2024-01-26-avoid-using-reacts-useformstatus)
    for their feedback and suggestions on `useFormStatus` hook.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 8d3e99b986..398a5720ab 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -56,7 +56,8 @@ export type HookType =
   | 'useId'
   | 'useCacheRefresh'
   | 'useOptimistic'
-  | 'useFormState';
+  | 'useFormState'
+  | 'useActionState';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -414,6 +415,11 @@ export type Dispatcher = {
     initialState: Awaited<S>,
     permalink?: string,
   ) => [Awaited<S>, (P) => void, boolean],
+  useActionState?: <S, P>(
+    action: (Awaited<S>, P) => S,
+    initialState: Awaited<S>,
+    permalink?: string,
+  ) => [Awaited<S>, (P) => void, boolean],
 };
 
 export type CacheDispatcher = {

commit a0537160771bafae90c6fd3154eeead2f2c903e7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 21:51:37 2024 -0700

    Make onUncaughtError and onCaughtError Configurable (#28641)
    
    Stacked on #28627.
    
    This makes error logging configurable using these
    `createRoot`/`hydrateRoot` options:
    
    ```
    onUncaughtError(error: mixed, errorInfo: {componentStack?: ?string}) => void
    onCaughtError(error: mixed, errorInfo: {componentStack?: ?string, errorBoundary?: ?React.Component<any, any>}) => void
    onRecoverableError(error: mixed, errorInfo: {digest?: ?string, componentStack?: ?string}) => void
    ```
    
    We already have the `onRecoverableError` option since before.
    
    Overriding these can be used to implement custom error dialogs (with
    access to the `componentStack`).
    
    It can also be used to silence caught errors when testing an error
    boundary or if you prefer not getting logs for caught errors that you've
    already handled in an error boundary.
    
    I currently expose the error boundary instance but I think we should
    probably remove that since it doesn't make sense for non-class error
    boundaries and isn't very useful anyway. It's also unclear what it
    should do when an error is rethrown from one boundary to another.
    
    Since these are public APIs now we can implement the
    ReactFiberErrorDialog forks using these options at the roots of the
    builds. So I unforked those files and instead passed a custom option for
    the native and www builds.
    
    To do this I had to fork the ReactDOMLegacy file into ReactDOMRootFB
    which is a duplication but that will go away as soon as the FB fork is
    the only legacy root.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 398a5720ab..10b65fb392 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -260,9 +260,20 @@ type BaseFiberRootProperties = {
   // a reference to.
   identifierPrefix: string,
 
+  onUncaughtError: (
+    error: mixed,
+    errorInfo: {+componentStack?: ?string},
+  ) => void,
+  onCaughtError: (
+    error: mixed,
+    errorInfo: {
+      +componentStack?: ?string,
+      +errorBoundary?: ?React$Component<any, any>,
+    },
+  ) => void,
   onRecoverableError: (
     error: mixed,
-    errorInfo: {digest?: ?string, componentStack?: ?string},
+    errorInfo: {+digest?: ?string, +componentStack?: ?string},
   ) => void,
 
   formState: ReactFormState<any, any> | null,

commit df95577db0d1d7ca383f281bc1d9e6ba5579bef2
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 30 18:32:20 2024 -0400

    Finish cleaning up digest from onRecoverableError (#28686)
    
    Don't need to track it separately on the captured value anymore.
    
    Shouldn't be in the types.
    
    I used a getter for the warning instead because Proxies are kind of
    heavy weight options for this kind of warning. We typically use getters.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 10b65fb392..dac96a66dc 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -273,7 +273,7 @@ type BaseFiberRootProperties = {
   ) => void,
   onRecoverableError: (
     error: mixed,
-    errorInfo: {+digest?: ?string, +componentStack?: ?string},
+    errorInfo: {+componentStack?: ?string},
   ) => void,
 
   formState: ReactFormState<any, any> | null,

commit 8cb6a1c0347a69ad4c580c5cf5f28d8be544d6d4
Author: Joseph Savona <joesavona@fb.com>
Date:   Tue Apr 2 10:54:31 2024 -0700

    [be] Remove unused, experimental getCacheSignal API (#28706)
    
    Similar to #28698, this removes the `unstable_getCacheSignal()` API
    since we don't intend to ship this to stable.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index dac96a66dc..3b82dc40c8 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -434,6 +434,5 @@ export type Dispatcher = {
 };
 
 export type CacheDispatcher = {
-  getCacheSignal: () => AbortSignal,
   getCacheForType: <T>(resourceType: () => T) => T,
 };

commit f33a6b69c6cb406ea0cc51d07bc4d3fd2d8d8744
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Apr 5 12:48:52 2024 -0400

    Track Owner for Server Components in DEV (#28753)
    
    This implements the concept of a DEV-only "owner" for Server Components.
    The owner concept isn't really super useful. We barely use it anymore,
    but we do have it as a concept in DevTools in a couple of cases so this
    adds it for parity. However, this is mainly interesting because it could
    be used to wire up future owner-based stacks.
    
    I do this by outlining the DebugInfo for a Server Component
    (ReactComponentInfo). Then I just rely on Flight deduping to refer to
    that. I refer to the same thing by referential equality so that we can
    associate a Server Component parent in DebugInfo with an owner.
    
    If you suspend and replay a Server Component, we have to restore the
    same owner. To do that, I did a little ugly hack and stashed it on the
    thenable state object. Felt unnecessarily complicated to add a stateful
    wrapper for this one dev-only case.
    
    The owner could really be anything since it could be coming from a
    different implementation. Because this is the first time we have an
    owner other than Fiber, I have to fix up a bunch of places that assumes
    Fiber. I mainly did the `typeof owner.tag === 'number'` to assume it's a
    Fiber for now.
    
    This also doesn't actually add it to DevTools / RN Inspector yet. I just
    ignore them there for now.
    
    Because Server Components can be async the owner isn't tracked after an
    await. We need per-component AsyncLocalStorage for that. This can be
    done in a follow up.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 3b82dc40c8..f12b9a16c5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -15,6 +15,7 @@ import type {
   Usable,
   ReactFormState,
   Awaited,
+  ReactComponentInfo,
   ReactDebugInfo,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
@@ -193,7 +194,7 @@ export type Fiber = {
   // __DEV__ only
 
   _debugInfo?: ReactDebugInfo | null,
-  _debugOwner?: Fiber | null,
+  _debugOwner?: ReactComponentInfo | Fiber | null,
   _debugIsCurrentlyTiming?: boolean,
   _debugNeedsRemount?: boolean,
 

commit 94eed63c49d989861ae7cd62e111de6d717f0a10
Author: Josh Story <story@hey.com>
Date:   Thu Apr 25 10:40:40 2024 -0700

    (Land #28798) Move Current Owner (and Cache) to an Async Dispatcher (#28912)
    
    Rebasing and landing https://github.com/facebook/react/pull/28798
    
    This PR was approved already but held back to give time for the sync.
    Rebased and landing here without pushing to seb's remote to avoid
    possibility of lost updates
    
    ---------
    
    Co-authored-by: Sebastian Markbage <sebastian@calyptus.eu>

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f12b9a16c5..6fa9142e2d 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -434,6 +434,8 @@ export type Dispatcher = {
   ) => [Awaited<S>, (P) => void, boolean],
 };
 
-export type CacheDispatcher = {
+export type AsyncDispatcher = {
   getCacheForType: <T>(resourceType: () => T) => T,
+  // DEV-only (or !disableStringRefs)
+  getOwner: () => null | Fiber | ReactComponentInfo,
 };

commit d6cfa0f295f4c8b366af15fd20c84e27cdd1fab7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat May 25 11:58:17 2024 -0400

    [Fiber] Use Owner/JSX Stack When Appending Stacks to Console (#29206)
    
    This one should be fully behind the `enableOwnerStacks` flag.
    
    Instead of printing the parent Component stack all the way to the root,
    this now prints the owner stack of every JSX callsite. It also includes
    intermediate callsites between the Component and the JSX call so it has
    potentially more frames. Mainly it provides the line number of the JSX
    callsite. In terms of the number of components is a subset of the parent
    component stack so it's less information in that regard. This is usually
    better since it's more focused on components that might affect the
    output but if it's contextual based on rendering it's still good to have
    parent stack. Therefore, I still use the parent stack when printing DOM
    nesting warnings but I plan on switching that format to a diff view
    format instead (Next.js already reformats the parent stack like this).
    
    __Follow ups__
    
    - Server Components show up in the owner stack for client logs but logs
    done by Server Components don't yet get their owner stack printed as
    they're replayed. They're also not yet printed in the server logs of the
    RSC server.
    
    - Server Component stack frames are formatted as the server and added to
    the end but this might be a different format than the browser. E.g. if
    server is running V8 and browser is running JSC or vice versa. Ideally
    we can reformat them in terms of the client formatting.
    
    - This doesn't yet update Fizz or DevTools. Those will be follow ups.
    Fizz still prints parent stacks in the server side logs. The stacks
    added to user space `console.error` calls by DevTools still get the
    parent stacks instead.
    
    - It also doesn't yet expose these to user space so there's no way to
    get them inside `onCaughtError` for example or inside a custom
    `console.error` override.
    
    - In another follow up I'll use `console.createTask` instead and
    completely remove these stacks if it's available.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 6fa9142e2d..8e58b5c44a 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -195,6 +195,8 @@ export type Fiber = {
 
   _debugInfo?: ReactDebugInfo | null,
   _debugOwner?: ReactComponentInfo | Fiber | null,
+  _debugStack?: string | Error | null,
+  _debugTask?: ConsoleTask | null,
   _debugIsCurrentlyTiming?: boolean,
   _debugNeedsRemount?: boolean,
 

commit 315109b02b0c9460b7466ca88f3f4d6ed1215a21
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Jul 1 10:27:52 2024 -0400

    [Fizz] Enable owner stacks for SSR (#30152)
    
    Stacked on #30142.
    
    This tracks owners and their stacks in DEV in Fizz. We use the
    ComponentStackNode as the data structure to track this information -
    effectively like ReactComponentInfo (Server) or Fiber (Client). They're
    the instance.
    
    I then port them same logic from ReactFiberComponentStack,
    ReactFiberOwnerStack and ReactFiberCallUserSpace to Fizz equivalents.
    
    This gets us both owner stacks from `captureOwnerStack()`, as well as
    appended to console.errors logged by Fizz, while rendering and in
    onError.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 8e58b5c44a..beee88de25 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -36,6 +36,7 @@ import type {
   Transition,
 } from './ReactFiberTracingMarkerComponent';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
+import type {ComponentStackNode} from 'react-server/src/ReactFizzComponentStack';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -439,5 +440,5 @@ export type Dispatcher = {
 export type AsyncDispatcher = {
   getCacheForType: <T>(resourceType: () => T) => T,
   // DEV-only (or !disableStringRefs)
-  getOwner: () => null | Fiber | ReactComponentInfo,
+  getOwner: () => null | Fiber | ReactComponentInfo | ComponentStackNode,
 };

commit 1350a85980d1bf5e63c16a4a889861246f4cc107
Author: Jack Pope <jackpope1@gmail.com>
Date:   Fri Jul 26 14:38:24 2024 -0400

    Add unstable context bailout for profiling (#30407)
    
    **This API is not intended to ship. This is a temporary unstable hook
    for internal performance profiling.**
    
    This PR exposes `unstable_useContextWithBailout`, which takes a compare
    function in addition to Context. The comparison function is run to
    determine if Context propagation and render should bail out earlier.
    `unstable_useContextWithBailout` returns the full Context value, same as
    `useContext`.
    
    We can profile this API against `useContext` to better measure the cost
    of Context value updates and gather more data around propagation and
    render performance.
    
    The bailout logic and test cases are based on
    https://github.com/facebook/react/pull/20646
    
    Additionally, this implementation allows multiple values to be compared
    in one hook by returning a tuple to avoid requiring additional Context
    consumer hooks.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index beee88de25..4549253ba7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -61,16 +61,26 @@ export type HookType =
   | 'useFormState'
   | 'useActionState';
 
-export type ContextDependency<T> = {
-  context: ReactContext<T>,
-  next: ContextDependency<mixed> | null,
-  memoizedValue: T,
-  ...
+export type ContextDependency<C> = {
+  context: ReactContext<C>,
+  next: ContextDependency<mixed> | ContextDependencyWithSelect<mixed> | null,
+  memoizedValue: C,
+};
+
+export type ContextDependencyWithSelect<C> = {
+  context: ReactContext<C>,
+  next: ContextDependency<mixed> | ContextDependencyWithSelect<mixed> | null,
+  memoizedValue: C,
+  select: C => Array<mixed>,
+  lastSelectedValue: ?Array<mixed>,
 };
 
 export type Dependencies = {
   lanes: Lanes,
-  firstContext: ContextDependency<mixed> | null,
+  firstContext:
+    | ContextDependency<mixed>
+    | ContextDependencyWithSelect<mixed>
+    | null,
   ...
 };
 
@@ -384,6 +394,10 @@ export type Dispatcher = {
     initialArg: I,
     init?: (I) => S,
   ): [S, Dispatch<A>],
+  unstable_useContextWithBailout?: <T>(
+    context: ReactContext<T>,
+    select: (T => Array<mixed>) | null,
+  ) => T,
   useContext<T>(context: ReactContext<T>): T,
   useRef<T>(initialValue: T): {current: T},
   useEffect(

commit 8d68da3f7396064614f34b84881fe8833b6039ac
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Sep 3 16:04:24 2024 -0400

    [Fiber] Stash ThenableState on the Dependencies Object for Use By DevTools (#30866)
    
    This lets us track what a Component might suspend on from DevTools. We
    could already collect this by replaying a component's Hooks but that
    would be expensive to collect from a whole tree.
    
    The thenables themselves might contain useful information but mainly
    we'd want access to the `_debugInfo` on the thenables which might
    contain additional information from the server.
    
    
    https://github.com/facebook/react/blob/19bd26beb689e554fceb0b929dc5199be8cba594/packages/shared/ReactTypes.js#L114
    
    In a follow up we should really do something similar in Flight to
    transfer `use()` on the debugInfo of that Server Component.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 4549253ba7..871325f379 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -37,6 +37,7 @@ import type {
 } from './ReactFiberTracingMarkerComponent';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 import type {ComponentStackNode} from 'react-server/src/ReactFizzComponentStack';
+import type {ThenableState} from './ReactFiberThenable';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -81,7 +82,7 @@ export type Dependencies = {
     | ContextDependency<mixed>
     | ContextDependencyWithSelect<mixed>
     | null,
-  ...
+  _debugThenableState?: null | ThenableState, // DEV-only
 };
 
 export type MemoCache = {

commit e10e8681824e56c10fdb14e0359d878bcd748937
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 4 13:55:29 2024 -0400

    Schedule prerender after something suspends (#30800)
    
    Adds the concept of a "prerender". These special renders are spawned
    whenever something suspends (and we're not already prerendering).
    
    The purpose is to move speculative rendering work into a separate phase
    that does not block the UI from updating. For example, during a
    transition, if something suspends, we should not speculatively prerender
    siblings that will be replaced by a fallback in the UI until *after* the
    fallback has been shown to the user.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 871325f379..d160aa0d22 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -256,6 +256,7 @@ type BaseFiberRootProperties = {
   pendingLanes: Lanes,
   suspendedLanes: Lanes,
   pingedLanes: Lanes,
+  warmLanes: Lanes,
   expiredLanes: Lanes,
   errorRecoveryDisabledLanes: Lanes,
   shellSuspendCounter: number,

commit 4549be0f846e7df5a4eaabf06369d93bd120271e
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Sep 17 15:12:16 2024 -0400

    [Fiber] Optimize enableProfilerCommitHooks by Collecting Elapsed Effect Duration in Module Scope (#30981)
    
    Stacked on #30979.
    
    The problem with the previous approach is that it recursively walked the
    tree up to propagate the resulting time from recording a layout effect.
    
    Instead, we keep a running count of the effect duration on the module
    scope. Then we reset it when entering a nested Profiler and then we add
    its elapsed count when we exit the Profiler.
    
    This also fixes a bug where we weren't previously including unmount
    times for some detached trees since they couldn't bubble up to find the
    profiler.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index d160aa0d22..1c98a9e9c7 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -373,6 +373,11 @@ type TransitionTracingOnlyFiberRootProperties = {
   incompleteTransitions: Map<Transition, TracingMarkerInstance>,
 };
 
+type ProfilerCommitHooksOnlyFiberRootProperties = {
+  effectDuration: number,
+  passiveEffectDuration: number,
+};
+
 // Exported FiberRoot type includes all properties,
 // To avoid requiring potentially error-prone :any casts throughout the project.
 // The types are defined separately within this file to ensure they stay in sync.
@@ -381,7 +386,7 @@ export type FiberRoot = {
   ...SuspenseCallbackOnlyFiberRootProperties,
   ...UpdaterTrackingOnlyFiberRootProperties,
   ...TransitionTracingOnlyFiberRootProperties,
-  ...
+  ...ProfilerCommitHooksOnlyFiberRootProperties,
 };
 
 type BasicStateAction<S> = (S => S) | S;

commit e1378902bbb322aa1fe1953780f4b2b5f80d26b1
Author: Jan Kassens <jkassens@meta.com>
Date:   Wed Nov 6 14:00:10 2024 -0500

    [string-refs] cleanup string ref code (#31443)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1c98a9e9c7..d91727525c 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -460,6 +460,6 @@ export type Dispatcher = {
 
 export type AsyncDispatcher = {
   getCacheForType: <T>(resourceType: () => T) => T,
-  // DEV-only (or !disableStringRefs)
+  // DEV-only
   getOwner: () => null | Fiber | ReactComponentInfo | ComponentStackNode,
 };

commit d8afd1c82e671662c6d1e998bad7fe524071bd56
Author: lauren <poteto@users.noreply.github.com>
Date:   Fri Nov 15 17:49:31 2024 -0500

    [crud] Scaffold initial types (#31555)
    
    Scaffolds the initial `useResourceEffect` dispatcher type. This will
    eventually be folded into `useEffect` et al as an overload.
    
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/31555).
    * #31523
    * #31557
    * #31556
    * __->__ #31555

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index d91727525c..bd40c74785 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -47,6 +47,7 @@ export type HookType =
   | 'useRef'
   | 'useEffect'
   | 'useEffectEvent'
+  | 'useResourceEffect'
   | 'useInsertionEffect'
   | 'useLayoutEffect'
   | 'useCallback'
@@ -412,6 +413,13 @@ export type Dispatcher = {
     deps: Array<mixed> | void | null,
   ): void,
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
+  useResourceEffect?: (
+    create: () => mixed,
+    createDeps: Array<mixed> | void | null,
+    update: ((resource: mixed) => void) | void,
+    updateDeps: Array<mixed> | void | null,
+    destroy: ((resource: mixed) => void) | void,
+  ) => void,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit 56ae4b8d22f773c961c6f57946e648de0879c7f1
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Dec 12 23:53:37 2024 -0500

    Remove unused field _debugIsCurrentlyTiming (#31753)
    
    This field is unused. It's not there at runtime. It's just legacy from
    the type.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index bd40c74785..dc6ab646b5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -210,7 +210,6 @@ export type Fiber = {
   _debugOwner?: ReactComponentInfo | Fiber | null,
   _debugStack?: string | Error | null,
   _debugTask?: ConsoleTask | null,
-  _debugIsCurrentlyTiming?: boolean,
   _debugNeedsRemount?: boolean,
 
   // Used to verify that the order of hooks does not change between renders.

commit ef63718a27407b6d6b262d6be92e6bf0a87ff1a3
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Dec 13 13:58:18 2024 -0500

    Remove enableAsyncActions (#31757)
    
    Based on https://github.com/facebook/react/pull/31756
    
    This is landed everywhere

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index dc6ab646b5..2ef3a2da4f 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -448,17 +448,17 @@ export type Dispatcher = {
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
   useMemoCache?: (size: number) => Array<any>,
-  useHostTransitionStatus?: () => TransitionStatus,
-  useOptimistic?: <S, A>(
+  useHostTransitionStatus: () => TransitionStatus,
+  useOptimistic: <S, A>(
     passthrough: S,
     reducer: ?(S, A) => S,
   ) => [S, (A) => void],
-  useFormState?: <S, P>(
+  useFormState: <S, P>(
     action: (Awaited<S>, P) => S,
     initialState: Awaited<S>,
     permalink?: string,
   ) => [Awaited<S>, (P) => void, boolean],
-  useActionState?: <S, P>(
+  useActionState: <S, P>(
     action: (Awaited<S>, P) => S,
     initialState: Awaited<S>,
     permalink?: string,

commit 909ed63e0adc162a95a4704d3ed07a956dcf9cd1
Author: Jack Pope <jackpope1@gmail.com>
Date:   Mon Dec 16 12:32:07 2024 -0500

    Clean up context access profiling experiment (#31806)
    
    We introduced the `unstable_useContextWithBailout` API to run compiler
    based experiments. This API was designed to be an experiment proxy for
    alternative approaches which would be heavier to implement. The
    experiment turned out to be inconclusive. Since most of our performance
    critical usage is already optimized, we weren't able to find a clear win
    with this approach.
    
    Since we don't have further plans for this API, let's clean it up.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 2ef3a2da4f..afe853202f 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -63,27 +63,18 @@ export type HookType =
   | 'useFormState'
   | 'useActionState';
 
-export type ContextDependency<C> = {
-  context: ReactContext<C>,
-  next: ContextDependency<mixed> | ContextDependencyWithSelect<mixed> | null,
-  memoizedValue: C,
-};
-
-export type ContextDependencyWithSelect<C> = {
-  context: ReactContext<C>,
-  next: ContextDependency<mixed> | ContextDependencyWithSelect<mixed> | null,
-  memoizedValue: C,
-  select: C => Array<mixed>,
-  lastSelectedValue: ?Array<mixed>,
+export type ContextDependency<T> = {
+  context: ReactContext<T>,
+  next: ContextDependency<mixed> | null,
+  memoizedValue: T,
+  ...
 };
 
 export type Dependencies = {
   lanes: Lanes,
-  firstContext:
-    | ContextDependency<mixed>
-    | ContextDependencyWithSelect<mixed>
-    | null,
+  firstContext: ContextDependency<mixed> | null,
   _debugThenableState?: null | ThenableState, // DEV-only
+  ...
 };
 
 export type MemoCache = {
@@ -401,10 +392,6 @@ export type Dispatcher = {
     initialArg: I,
     init?: (I) => S,
   ): [S, Dispatch<A>],
-  unstable_useContextWithBailout?: <T>(
-    context: ReactContext<T>,
-    select: (T => Array<mixed>) | null,
-  ) => T,
   useContext<T>(context: ReactContext<T>): T,
   useRef<T>(initialValue: T): {current: T},
   useEffect(

commit c81312e3a78dcbf71ed98c8893abe6dbfeaef3f2
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Jan 2 14:55:34 2025 -0500

    [Fiber] Refactor Commit Phase into Separate Functions for Before Mutation/Mutation/Layout (#31930)
    
    This is doing some general clean up to be able to split the commit root three phases into three separate async steps.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index afe853202f..859da37cad 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -220,8 +220,6 @@ type BaseFiberRootProperties = {
 
   pingCache: WeakMap<Wakeable, Set<mixed>> | Map<Wakeable, Set<mixed>> | null,
 
-  // A finished work-in-progress HostRoot that's ready to be committed.
-  finishedWork: Fiber | null,
   // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
   // it's superseded by a new one.
   timeoutHandle: TimeoutHandle | NoTimeout,
@@ -252,8 +250,6 @@ type BaseFiberRootProperties = {
   errorRecoveryDisabledLanes: Lanes,
   shellSuspendCounter: number,
 
-  finishedLanes: Lanes,
-
   entangledLanes: Lanes,
   entanglements: LaneMap<Lanes>,
 

commit f9f17f6c8d1e747a3e242b36aa35feae31c55f75
Author: Sebastian "Sebbie" Silbermann <sebastian.silbermann@vercel.com>
Date:   Tue Jan 14 22:59:52 2025 +0100

    [Fizz] Restore `useMemoCache` in renderers with support for Client APIs (#32067)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 859da37cad..7a6766f5c9 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -430,7 +430,7 @@ export type Dispatcher = {
   ): T,
   useId(): string,
   useCacheRefresh?: () => <T>(?() => T, ?T) => void,
-  useMemoCache?: (size: number) => Array<any>,
+  useMemoCache: (size: number) => Array<any>,
   useHostTransitionStatus: () => TransitionStatus,
   useOptimistic: <S, A>(
     passthrough: S,

commit 886c5ad936428f168e50e077bd37fe9472ff8d3e
Author: Sebastian "Sebbie" Silbermann <sebastian.silbermann@vercel.com>
Date:   Wed Jan 15 00:40:54 2025 +0100

    Reduce risk of leaving shipped Hooks as nullable on Dispatcher (#32068)

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 7a6766f5c9..0c5504cab4 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -394,7 +394,9 @@ export type Dispatcher = {
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,
   ): void,
+  // TODO: Non-nullable once `enableUseEffectEventHook` is on everywhere.
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
+  // TODO: Non-nullable once `enableUseResourceEffectHook` is on everywhere.
   useResourceEffect?: (
     create: () => mixed,
     createDeps: Array<mixed> | void | null,
@@ -429,7 +431,7 @@ export type Dispatcher = {
     getServerSnapshot?: () => T,
   ): T,
   useId(): string,
-  useCacheRefresh?: () => <T>(?() => T, ?T) => void,
+  useCacheRefresh: () => <T>(?() => T, ?T) => void,
   useMemoCache: (size: number) => Array<any>,
   useHostTransitionStatus: () => TransitionStatus,
   useOptimistic: <S, A>(

commit 899e3d1297ec15a5aa8d73e2f1bd478918090a12
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 13:52:25 2025 -0500

    [crud] Narrow resource type (#32203)
    
    Small refactor to the `resource` type to narrow it to an arbitrary
    object or void/null instead of the top type. This makes the overload on
    useEffect simpler since the return type of create is no longer widened
    to the top type when we merge their definitions.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32203).
    * #32206
    * #32205
    * #32204
    * __->__ #32203

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 0c5504cab4..e31b7cefd1 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -398,11 +398,11 @@ export type Dispatcher = {
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
   // TODO: Non-nullable once `enableUseResourceEffectHook` is on everywhere.
   useResourceEffect?: (
-    create: () => mixed,
+    create: () => {...} | void | null,
     createDeps: Array<mixed> | void | null,
-    update: ((resource: mixed) => void) | void,
+    update: ((resource: {...} | void | null) => void) | void,
     updateDeps: Array<mixed> | void | null,
-    destroy: ((resource: mixed) => void) | void,
+    destroy: ((resource: {...} | void | null) => void) | void,
   ) => void,
   useInsertionEffect(
     create: () => (() => void) | void,

commit 0461c0d8a49730d1c8ebca2071d9bb7adfc8ac92
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:05:50 2025 -0500

    [crud] Rename useResourceEffect flag (#32204)
    
    Rename the flag in preparation for the overload.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32204).
    * #32206
    * #32205
    * __->__ #32204

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index e31b7cefd1..9ac0680fb6 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -396,7 +396,7 @@ export type Dispatcher = {
   ): void,
   // TODO: Non-nullable once `enableUseEffectEventHook` is on everywhere.
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
-  // TODO: Non-nullable once `enableUseResourceEffectHook` is on everywhere.
+  // TODO: Non-nullable once `enableUseEffectCRUDOverload` is on everywhere.
   useResourceEffect?: (
     create: () => {...} | void | null,
     createDeps: Array<mixed> | void | null,

commit 2c5fd26c07c0fb94ff21a6c10c5a757ef3c5d6a4
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:18:50 2025 -0500

    [crud] Merge useResourceEffect into useEffect (#32205)
    
    Merges the useResourceEffect API into useEffect while keeping the
    underlying implementation the same. useResourceEffect will be removed in
    the next diff.
    
    To fork between behavior we rely on a `typeof` check for the updater or
    destroy function in addition to the CRUD feature flag. This does now
    have to be checked every time (instead of inlined statically like before
    due to them being different hooks) which will incur some non-zero amount
    (possibly negligble) of overhead for every effect.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32205).
    * #32206
    * __->__ #32205

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 9ac0680fb6..756d88c4a5 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -391,8 +391,11 @@ export type Dispatcher = {
   useContext<T>(context: ReactContext<T>): T,
   useRef<T>(initialValue: T): {current: T},
   useEffect(
-    create: () => (() => void) | void,
-    deps: Array<mixed> | void | null,
+    create: (() => (() => void) | void) | (() => {...} | void | null),
+    createDeps: Array<mixed> | void | null,
+    update?: ((resource: {...} | void | null) => void) | void,
+    updateDeps?: Array<mixed> | void | null,
+    destroy?: ((resource: {...} | void | null) => void) | void,
   ): void,
   // TODO: Non-nullable once `enableUseEffectEventHook` is on everywhere.
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,

commit a69b80d07e5d1bf363ed15d6209a55b35e0765c2
Author: lauren <poteto@users.noreply.github.com>
Date:   Tue Feb 11 14:19:34 2025 -0500

    [crud] Remove useResourceEffect (#32206)
    
    Removes useResourceEffect.
    ---
    [//]: # (BEGIN SAPLING FOOTER)
    Stack created with [Sapling](https://sapling-scm.com). Best reviewed
    with [ReviewStack](https://reviewstack.dev/facebook/react/pull/32206).
    * __->__ #32206
    * #32205

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 756d88c4a5..98e7d4deef 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -47,7 +47,6 @@ export type HookType =
   | 'useRef'
   | 'useEffect'
   | 'useEffectEvent'
-  | 'useResourceEffect'
   | 'useInsertionEffect'
   | 'useLayoutEffect'
   | 'useCallback'
@@ -399,14 +398,6 @@ export type Dispatcher = {
   ): void,
   // TODO: Non-nullable once `enableUseEffectEventHook` is on everywhere.
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,
-  // TODO: Non-nullable once `enableUseEffectCRUDOverload` is on everywhere.
-  useResourceEffect?: (
-    create: () => {...} | void | null,
-    createDeps: Array<mixed> | void | null,
-    update: ((resource: {...} | void | null) => void) | void,
-    updateDeps: Array<mixed> | void | null,
-    destroy: ((resource: {...} | void | null) => void) | void,
-  ) => void,
   useInsertionEffect(
     create: () => (() => void) | void,
     deps: Array<mixed> | void | null,

commit a53da6abe1593483098df2baf927fe07d80153a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 13 16:06:01 2025 -0500

    Add useSwipeTransition Hook Behind Experimental Flag (#32373)
    
    This Hook will be used to drive a View Transition based on a gesture.
    
    ```js
    const [value, startGesture] = useSwipeTransition(prev, current, next);
    ```
    
    The `enableSwipeTransition` flag will depend on `enableViewTransition`
    flag but we may decide to ship them independently. This PR doesn't do
    anything interesting yet. There will be a lot more PRs to build out the
    actual functionality. This is just wiring up the plumbing for the new
    Hook.
    
    This first PR is mainly concerned with how the whole starts (and stops).
    The core API is the `startGesture` function (although there will be
    other conveniences added in the future). You can call this to start a
    gesture with a source provider. You can call this multiple times in one
    event to batch multiple Hooks listening to the same provider. However,
    each render can only handle one source provider at a time and so it does
    one render per scheduled gesture provider.
    
    This uses a separate `GestureLane` to drive gesture renders by marking
    the Hook as having an update on that lane. Then schedule a render. These
    renders should be blocking and in the same microtask as the
    `startGesture` to ensure it can block the paint. So it's similar to
    sync.
    
    It may not be possible to finish it synchronously e.g. if something
    suspends. If so, it just tries again later when it can like any other
    render. This can also happen because it also may not be possible to
    drive more than one gesture at a time like if we're limited to one View
    Transition per document. So right now you can only run one gesture at a
    time in practice.
    
    These renders never commit. This means that we can't clear the
    `GestureLane` the normal way. Instead, we have to clear only the root's
    `pendingLanes` if we don't have any new renders scheduled. Then wait
    until something else updates the Fiber after all gestures on it have
    stopped before it really clears.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 98e7d4deef..3479eba1b9 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -17,6 +17,7 @@ import type {
   Awaited,
   ReactComponentInfo,
   ReactDebugInfo,
+  StartGesture,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -38,6 +39,7 @@ import type {
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 import type {ComponentStackNode} from 'react-server/src/ReactFizzComponentStack';
 import type {ThenableState} from './ReactFiberThenable';
+import type {ScheduledGesture} from './ReactFiberGestureScheduler';
 
 // Unwind Circular: moved from ReactFiberHooks.old
 export type HookType =
@@ -60,7 +62,8 @@ export type HookType =
   | 'useCacheRefresh'
   | 'useOptimistic'
   | 'useFormState'
-  | 'useActionState';
+  | 'useActionState'
+  | 'useSwipeTransition';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -279,6 +282,9 @@ type BaseFiberRootProperties = {
   ) => void,
 
   formState: ReactFormState<any, any> | null,
+
+  // enableSwipeTransition only
+  gestures: null | ScheduledGesture,
 };
 
 // The following attributes are only used by DevTools and are only present in DEV builds.
@@ -442,6 +448,12 @@ export type Dispatcher = {
     initialState: Awaited<S>,
     permalink?: string,
   ) => [Awaited<S>, (P) => void, boolean],
+  // TODO: Non-nullable once `enableSwipeTransition` is on everywhere.
+  useSwipeTransition?: <T>(
+    previous: T,
+    current: T,
+    next: T,
+  ) => [T, StartGesture],
 };
 
 export type AsyncDispatcher = {

commit 3607f4838a8f4a87160da36aa26bb1432d7a5f11
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 27 16:45:18 2025 -0500

    Add Commit Scaffolding for Gestures (#32451)
    
    This adds a `ReactFiberApplyGesture` which is basically intended to be a
    fork of the phases in `ReactFiberCommitWork` except for the fake commit
    that `useSwipeTransition` does. So far none of the phases are actually
    implemented yet. This is just the scaffolding around them so I can fill
    them in later.
    
    The important bit is that we call `startViewTransition` (via the
    `startGestureTransition` Config) when a gesture starts. We add a paused
    animation to prevent the transition from committing (even if the
    ScrollTimeline goes to 100%). This also locks the documents so that we
    can't commit any other Transitions until it completes.
    
    When the gesture completes (scroll end) then we stop the gesture View
    Transition. If there's no new work scheduled we do that immediately but
    if there was any new work already scheduled, then we assume that this
    will potentially commit the new state. So we wait for that to finish.
    This lets us lock the animation in its state instead of snapping back
    and then applying the real update.
    
    Using this technique we can't actually run a View Transition from the
    current state to the actual committed state because it would snap back
    to the beginning and then run the View Transition from there. Therefore
    any new commit needs to skip View Transitions even if it should've
    technically animated to that state. We assume that the new state is the
    same as the optimistic state you already swiped to. An alternative to
    this technique could be to commit the optimistic state when we cancel
    and then apply any new updates o top of that. I might explore that in
    the future.
    
    Regardless it's important that the `action` associated with the swipe
    schedules some work before we cancel. Otherwise it risks reverting
    first. So I had to update this in the fixture.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 3479eba1b9..be5e9a5c0d 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -284,7 +284,8 @@ type BaseFiberRootProperties = {
   formState: ReactFormState<any, any> | null,
 
   // enableSwipeTransition only
-  gestures: null | ScheduledGesture,
+  pendingGestures: null | ScheduledGesture,
+  stoppingGestures: null | ScheduledGesture,
 };
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit e9252bcdccf7f8f691081e4d48ca47657bc723f9
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 4 20:10:08 2025 -0500

    During a Swipe Gesture Render a Clone Offscreen and Animate it Onscreen (#32500)
    
    This is really the essence mechanism of the `useSwipeTransition`
    feature.
    
    We don't want to immediately switch to the destination state when
    starting a gesture. The effects remain mounted on the current state. We
    want the current state to be "live". This is important to for example
    allow a video to keeping playing while starting a swipe (think
    TikTok/Reels) and not stop until you've committed the action. The only
    thing that can be live is the "new" state. Therefore we treat the
    destination as the "old" state and perform a reverse animation from
    there.
    
    Ideally we could apply the old state to the DOM tree, take a snapshot
    and then revert it back in the mutation of `startViewTransition`.
    Unfortunately, the way `startViewTransition` was designed it always
    paints one frame of the "old" state which would lead this to cause a
    flicker.
    
    To work around this, we need to create a clone of any View Transition
    boundary that might be mutated and then render that offscreen. That way
    we can render the "current" state on screen and the "destination" state
    offscreen for the screenshots. Being mutated can be either due to React
    doing a DOM mutation or if a child boundary resizes that causes the
    parent to relayout. We don't have to do this for insertions or deletions
    since they only appear on one side.
    
    The worst case scenario is that we have to clone the whole root. That's
    what this first PR implements. We clone the container and if it's not
    absolutely positioned, we position it on top of the current one. If the
    container is `document` or `<html>` we instead clone the `<body>` tag
    since it's the only one we can insert a duplicate of. If the container
    is deep in the tree we clone just that even though technically we should
    probably clone the whole document in that case. We just keep the impact
    smaller. Ideally though we'd never hit this case. In fact, if we clone
    the document we issue a warning (always for now) since you probably
    should optimize this. In the future I intend to add optimizations when
    affected View Transition boundaries are absolutely positioned since they
    cannot possibly relayout the parent. This would be the ideal way to use
    this feature most efficiently but it still works without it.
    
    Since we render the "old" state outside the viewport, we need to then
    adjust the animation to put it back into the viewport. This is the
    trickiest part to get right while still preserving any customization of
    the View Transitions done using CSS. This current approach reapplies all
    the animations with adjusted keyframes.
    
    In the case of an "exit" the pseudo-element itself is positioned outside
    the viewport but since we can't programmatically update the style of the
    pseudo-element itself we instead adjust all the keyframes to put it back
    into the viewport. If there is no animation on the group we add one.
    
    In the case of an "update" the pseudo-element is positioned on the new
    state which is already inside the viewport. However, the auto-generated
    animation of the group has a starting keyframe that starts outside the
    viewport. In this case we need to adjust that keyframe.
    
    In the future I might explore a technique that inserts stylesheets
    instead of mutating the animations. It might be simpler. But whatever
    hacks work to maximize the compatibility is best.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index be5e9a5c0d..1452746089 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -26,6 +26,7 @@ import type {Lane, Lanes, LaneMap} from './ReactFiberLane';
 import type {RootTag} from './ReactRootTags';
 import type {
   Container,
+  Instance,
   TimeoutHandle,
   NoTimeout,
   SuspenseInstance,
@@ -286,6 +287,7 @@ type BaseFiberRootProperties = {
   // enableSwipeTransition only
   pendingGestures: null | ScheduledGesture,
   stoppingGestures: null | ScheduledGesture,
+  gestureClone: null | Instance,
 };
 
 // The following attributes are only used by DevTools and are only present in DEV builds.

commit 313332d111a2fba2db94c584334d8895e8d73c61
Author: lauren <poteto@users.noreply.github.com>
Date:   Wed Mar 26 12:04:57 2025 -0400

    [crud] Revert CRUD overload (#32741)
    
    Cleans up this experiment. After some internal experimentation we are
    deprioritizing this project for now and may revisit it at a later point.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 1452746089..4de46988db 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -399,11 +399,8 @@ export type Dispatcher = {
   useContext<T>(context: ReactContext<T>): T,
   useRef<T>(initialValue: T): {current: T},
   useEffect(
-    create: (() => (() => void) | void) | (() => {...} | void | null),
-    createDeps: Array<mixed> | void | null,
-    update?: ((resource: {...} | void | null) => void) | void,
-    updateDeps?: Array<mixed> | void | null,
-    destroy?: ((resource: {...} | void | null) => void) | void,
+    create: () => (() => void) | void,
+    deps: Array<mixed> | void | null,
   ): void,
   // TODO: Non-nullable once `enableUseEffectEventHook` is on everywhere.
   useEffectEvent?: <Args, F: (...Array<Args>) => mixed>(callback: F) => F,

commit d3b8ff6e589bcacfd1c9b0aa48c42fd1c93001c1
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Mar 31 19:59:07 2025 -0400

    Unify BatchConfigTransition and Transition types  (#32783)
    
    This is some overdue refactoring. The two types never made sense. It
    also should be defined by isomorphic since it defines how it should be
    used by renderers rather than isomorphic depending on Fiber.
    
    Clean up hidden classes to be consistent.
    
    Fix missing name due to wrong types. I choose not to invoke the
    transition tracing callbacks if there's no name since the name is
    required there.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 4de46988db..a683401283 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -33,10 +33,8 @@ import type {
   TransitionStatus,
 } from './ReactFiberConfig';
 import type {Cache} from './ReactFiberCacheComponent';
-import type {
-  TracingMarkerInstance,
-  Transition,
-} from './ReactFiberTracingMarkerComponent';
+import type {Transition} from 'react/src/ReactStartTransition';
+import type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';
 import type {ConcurrentUpdate} from './ReactFiberConcurrentUpdates';
 import type {ComponentStackNode} from 'react-server/src/ReactFizzComponentStack';
 import type {ThenableState} from './ReactFiberThenable';

commit 0a7cf20b220a9f719e06fd8a12dfde3ab029c651
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 1 11:43:33 2025 -0400

    Remove useSwipeTransition (#32786)
    
    Stacked on #32785.
    
    This is now replaced by `startGestureTransition` added in #32785.
    
    I also renamed the flag from `enableSwipeTransition` to
    `enableGestureTransition` to correspond to the new name.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index a683401283..9e56893835 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -17,7 +17,6 @@ import type {
   Awaited,
   ReactComponentInfo,
   ReactDebugInfo,
-  StartGesture,
 } from 'shared/ReactTypes';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
@@ -61,8 +60,7 @@ export type HookType =
   | 'useCacheRefresh'
   | 'useOptimistic'
   | 'useFormState'
-  | 'useActionState'
-  | 'useSwipeTransition';
+  | 'useActionState';
 
 export type ContextDependency<T> = {
   context: ReactContext<T>,
@@ -282,7 +280,7 @@ type BaseFiberRootProperties = {
 
   formState: ReactFormState<any, any> | null,
 
-  // enableSwipeTransition only
+  // enableGestureTransition only
   pendingGestures: null | ScheduledGesture,
   stoppingGestures: null | ScheduledGesture,
   gestureClone: null | Instance,
@@ -446,12 +444,6 @@ export type Dispatcher = {
     initialState: Awaited<S>,
     permalink?: string,
   ) => [Awaited<S>, (P) => void, boolean],
-  // TODO: Non-nullable once `enableSwipeTransition` is on everywhere.
-  useSwipeTransition?: <T>(
-    previous: T,
-    current: T,
-    next: T,
-  ) => [T, StartGesture],
 };
 
 export type AsyncDispatcher = {

commit 731ae3e0ade1ac2a79e5f9f52b3244f3d02d5ac8
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 1 12:11:19 2025 -0400

    Solidify addTransitionType Semantics (#32797)
    
    Stacked on #32793.
    
    This is meant to model the intended semantics of `addTransitionType`
    better. The previous hack just consumed all transition types when any
    root committed so it could steal them from other roots. Really each root
    should get its own set. Really each transition lane should get its own
    set.
    
    We can't implement the full ideal semantics yet because 1) we currently
    entangle transition lanes 2) we lack `AsyncContext` on the client so for
    async actions we can't associate a `addTransitionType` call to a
    specific `startTransition`.
    
    This starts by modeling Transition Types to be stored on the Transition
    instance. Conceptually they belong to the Transition instance of that
    `startTransition` they belong to. That instance is otherwise mostly just
    used for Transition Tracing but it makes sense that those would be able
    to be passed the Transition Types for that specific instance.
    
    Nested `startTransition` need to get entangled. So that this
    `addTransitionType` can be associated with the `setState`:
    
    ```js
    startTransition(() => {
      startTransition(() => {
        addTransitionType(...)
      });
      setState(...);
    });
    ```
    
    Ideally we'd probably just use the same Transition instance itself since
    these are conceptually all part of one entangled one. But transition
    tracing uses multiple names and start times. Unclear what we want to do
    with that. So I kept separate instances but shared `types` set.
    
    Next I collect the types added during a `startTransition` to any root
    scheduled with a Transition. This should really be collected one set per
    Transition lane in a `LaneMap`. In fact, the information would already
    be there if Transition Tracing was always enabled because it tracks all
    Transition instances per lane. For now I just keep track of one set for
    all Transition lanes. Maybe we should only add it if a `setState` was
    done on this root in this particular `startTransition` call rather
    having already scheduled any Transition earlier.
    
    While async transitions are entangled, we don't know if there will be a
    startTransition+setState on a new root in the future. Therefore, we
    collect all transition types while this is happening and if a new root
    gets startTransition+setState they get added to that root.
    
    ```js
    startTransition(async () => {
      addTransitionType(...)
      await ...;
      setState(...);
    });
    ```

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 9e56893835..40ab04ffa3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -18,6 +18,7 @@ import type {
   ReactComponentInfo,
   ReactDebugInfo,
 } from 'shared/ReactTypes';
+import type {TransitionTypes} from 'react/src/ReactTransitionType';
 import type {WorkTag} from './ReactWorkTags';
 import type {TypeOfMode} from './ReactTypeOfMode';
 import type {Flags} from './ReactFiberFlags';
@@ -280,6 +281,8 @@ type BaseFiberRootProperties = {
 
   formState: ReactFormState<any, any> | null,
 
+  // enableViewTransition only
+  transitionTypes: null | TransitionTypes, // TODO: Make this a LaneMap.
   // enableGestureTransition only
   pendingGestures: null | ScheduledGesture,
   stoppingGestures: null | ScheduledGesture,

commit 450f8df8865303f14be7ddd7c951f020115aa27c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 1 18:18:33 2025 -0400

    Clarify that the transitionLanes used by Transition Tracing is a LaneMap (#32800)
    
    We have a high level concept for this used elsewhere.
    
    We should use this for `transitionTypes` too:
    
    
    https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactInternalTypes.js#L285
    
    As mentioned in #32797 we could also just use the `transitionLanes`
    since the `types` are also on the `Transition` objects. If we always
    stored this set.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index 40ab04ffa3..f8e06456ee 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -357,7 +357,7 @@ export type TransitionTracingCallbacks = {
 // The following fields are only used in transition tracing in Profile builds
 type TransitionTracingOnlyFiberRootProperties = {
   transitionCallbacks: null | TransitionTracingCallbacks,
-  transitionLanes: Array<Set<Transition> | null>,
+  transitionLanes: LaneMap<Set<Transition> | null>,
   // Transitions on the root can be represented as a bunch of tracing markers.
   // Each entangled group of transitions can be treated as a tracing marker.
   // It will have a set of pending suspense boundaries. These transitions

commit 17f88c80ed20b4e5f21255d9e1268542a2fbc1bd
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 22 19:44:14 2025 -0400

    Implement ActivityInstance in FiberConfigDOM (#32842)
    
    Stacked on #32851 and #32900.
    
    This implements the equivalent Configs for ActivityInstance as we have
    for SuspenseInstance. These can be implemented as comments but they
    don't have to be and can be implemented differently in the renderer.
    
    This seems like a lot duplication but it's actually ends mostly just
    calling the same methods underneath and the wrappers compiles out.
    
    This doesn't leave the Activity dehydrated yet. It just hydrates into it
    immediately.

diff --git a/packages/react-reconciler/src/ReactInternalTypes.js b/packages/react-reconciler/src/ReactInternalTypes.js
index f8e06456ee..d083d189b3 100644
--- a/packages/react-reconciler/src/ReactInternalTypes.js
+++ b/packages/react-reconciler/src/ReactInternalTypes.js
@@ -29,6 +29,7 @@ import type {
   Instance,
   TimeoutHandle,
   NoTimeout,
+  ActivityInstance,
   SuspenseInstance,
   TransitionStatus,
 } from './ReactFiberConfig';
@@ -297,8 +298,10 @@ type UpdaterTrackingOnlyFiberRootProperties = {
 };
 
 export type SuspenseHydrationCallbacks = {
-  onHydrated?: (suspenseInstance: SuspenseInstance) => void,
-  onDeleted?: (suspenseInstance: SuspenseInstance) => void,
+  +onHydrated?: (
+    hydrationBoundary: SuspenseInstance | ActivityInstance,
+  ) => void,
+  +onDeleted?: (hydrationBoundary: SuspenseInstance | ActivityInstance) => void,
   ...
 };
 

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    