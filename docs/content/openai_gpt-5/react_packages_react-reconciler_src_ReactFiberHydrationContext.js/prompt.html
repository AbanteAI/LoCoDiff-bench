<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/ReactFiberHydrationContext.js - GPT-5</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/ReactFiberHydrationContext.js</h1>
        <h2>Model: GPT-5</h2>
        <p><a href="../../../cases/openai_gpt-5/react_packages_react-reconciler_src_ReactFiberHydrationContext.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/ReactFiberHydrationContext.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
new file mode 100644
index 0000000000..f6024e39c6
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -0,0 +1,381 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @providesModule ReactFiberHydrationContext
+ * @flow
+ */
+
+'use strict';
+
+import type {Fiber} from 'ReactFiber';
+import type {HostConfig} from 'ReactFiberReconciler';
+
+var invariant = require('fbjs/lib/invariant');
+
+const {HostComponent, HostText, HostRoot} = require('ReactTypeOfWork');
+const {Deletion, Placement} = require('ReactTypeOfSideEffect');
+
+const {createFiberFromHostInstanceForDeletion} = require('ReactFiber');
+
+export type HydrationContext<C, CX> = {
+  enterHydrationState(fiber: Fiber): boolean,
+  resetHydrationState(): void,
+  tryToClaimNextHydratableInstance(fiber: Fiber): void,
+  prepareToHydrateHostInstance(
+    fiber: Fiber,
+    rootContainerInstance: C,
+    hostContext: CX,
+  ): boolean,
+  prepareToHydrateHostTextInstance(fiber: Fiber): boolean,
+  popHydrationState(fiber: Fiber): boolean,
+};
+
+module.exports = function<T, P, I, TI, PI, C, CX, PL>(
+  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,
+): HydrationContext<C, CX> {
+  const {shouldSetTextContent, hydration} = config;
+
+  // If this doesn't have hydration mode.
+  if (!hydration) {
+    return {
+      enterHydrationState() {
+        return false;
+      },
+      resetHydrationState() {},
+      tryToClaimNextHydratableInstance() {},
+      prepareToHydrateHostInstance() {
+        invariant(
+          false,
+          'Expected prepareToHydrateHostInstance() to never be called. ' +
+            'This error is likely caused by a bug in React. Please file an issue.',
+        );
+      },
+      prepareToHydrateHostTextInstance() {
+        invariant(
+          false,
+          'Expected prepareToHydrateHostTextInstance() to never be called. ' +
+            'This error is likely caused by a bug in React. Please file an issue.',
+        );
+      },
+      popHydrationState(fiber: Fiber) {
+        return false;
+      },
+    };
+  }
+
+  const {
+    canHydrateInstance,
+    canHydrateTextInstance,
+    getNextHydratableSibling,
+    getFirstHydratableChild,
+    hydrateInstance,
+    hydrateTextInstance,
+    didNotMatchHydratedContainerTextInstance,
+    didNotMatchHydratedTextInstance,
+    didNotHydrateContainerInstance,
+    didNotHydrateInstance,
+    didNotFindHydratableContainerInstance,
+    didNotFindHydratableContainerTextInstance,
+    didNotFindHydratableInstance,
+    didNotFindHydratableTextInstance,
+  } = hydration;
+
+  // The deepest Fiber on the stack involved in a hydration context.
+  // This may have been an insertion or a hydration.
+  let hydrationParentFiber: null | Fiber = null;
+  let nextHydratableInstance: null | I | TI = null;
+  let isHydrating: boolean = false;
+
+  function enterHydrationState(fiber: Fiber) {
+    const parentInstance = fiber.stateNode.containerInfo;
+    nextHydratableInstance = getFirstHydratableChild(parentInstance);
+    hydrationParentFiber = fiber;
+    isHydrating = true;
+    return true;
+  }
+
+  function deleteHydratableInstance(returnFiber: Fiber, instance: I | TI) {
+    if (__DEV__) {
+      switch (returnFiber.tag) {
+        case HostRoot:
+          didNotHydrateContainerInstance(
+            returnFiber.stateNode.containerInfo,
+            instance,
+          );
+          break;
+        case HostComponent:
+          didNotHydrateInstance(
+            returnFiber.type,
+            returnFiber.memoizedProps,
+            returnFiber.stateNode,
+            instance,
+          );
+          break;
+      }
+    }
+
+    const childToDelete = createFiberFromHostInstanceForDeletion();
+    childToDelete.stateNode = instance;
+    childToDelete.return = returnFiber;
+    childToDelete.effectTag = Deletion;
+
+    // This might seem like it belongs on progressedFirstDeletion. However,
+    // these children are not part of the reconciliation list of children.
+    // Even if we abort and rereconcile the children, that will try to hydrate
+    // again and the nodes are still in the host tree so these will be
+    // recreated.
+    if (returnFiber.lastEffect !== null) {
+      returnFiber.lastEffect.nextEffect = childToDelete;
+      returnFiber.lastEffect = childToDelete;
+    } else {
+      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
+    }
+  }
+
+  function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+    fiber.effectTag |= Placement;
+    if (__DEV__) {
+      switch (returnFiber.tag) {
+        case HostRoot: {
+          const parentContainer = returnFiber.stateNode.containerInfo;
+          switch (fiber.tag) {
+            case HostComponent:
+              const type = fiber.type;
+              const props = fiber.pendingProps;
+              didNotFindHydratableContainerInstance(
+                parentContainer,
+                type,
+                props,
+              );
+              break;
+            case HostText:
+              const text = fiber.pendingProps;
+              didNotFindHydratableContainerTextInstance(parentContainer, text);
+              break;
+          }
+          break;
+        }
+        case HostComponent: {
+          const parentType = returnFiber.type;
+          const parentProps = returnFiber.memoizedProps;
+          const parentInstance = returnFiber.stateNode;
+          switch (fiber.tag) {
+            case HostComponent:
+              const type = fiber.type;
+              const props = fiber.pendingProps;
+              didNotFindHydratableInstance(
+                parentType,
+                parentProps,
+                parentInstance,
+                type,
+                props,
+              );
+              break;
+            case HostText:
+              const text = fiber.pendingProps;
+              didNotFindHydratableTextInstance(
+                parentType,
+                parentProps,
+                parentInstance,
+                text,
+              );
+              break;
+          }
+          break;
+        }
+        default:
+          return;
+      }
+    }
+  }
+
+  function canHydrate(fiber, nextInstance) {
+    switch (fiber.tag) {
+      case HostComponent: {
+        const type = fiber.type;
+        const props = fiber.pendingProps;
+        return canHydrateInstance(nextInstance, type, props);
+      }
+      case HostText: {
+        const text = fiber.pendingProps;
+        return canHydrateTextInstance(nextInstance, text);
+      }
+      default:
+        return false;
+    }
+  }
+
+  function tryToClaimNextHydratableInstance(fiber: Fiber) {
+    if (!isHydrating) {
+      return;
+    }
+    let nextInstance = nextHydratableInstance;
+    if (!nextInstance) {
+      // Nothing to hydrate. Make it an insertion.
+      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      isHydrating = false;
+      hydrationParentFiber = fiber;
+      return;
+    }
+    if (!canHydrate(fiber, nextInstance)) {
+      // If we can't hydrate this instance let's try the next one.
+      // We use this as a heuristic. It's based on intuition and not data so it
+      // might be flawed or unnecessary.
+      nextInstance = getNextHydratableSibling(nextInstance);
+      if (!nextInstance || !canHydrate(fiber, nextInstance)) {
+        // Nothing to hydrate. Make it an insertion.
+        insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+        isHydrating = false;
+        hydrationParentFiber = fiber;
+        return;
+      }
+      // We matched the next one, we'll now assume that the first one was
+      // superfluous and we'll delete it. Since we can't eagerly delete it
+      // we'll have to schedule a deletion. To do that, this node needs a dummy
+      // fiber associated with it.
+      deleteHydratableInstance(
+        (hydrationParentFiber: any),
+        nextHydratableInstance,
+      );
+    }
+    fiber.stateNode = nextInstance;
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = getFirstHydratableChild(nextInstance);
+  }
+
+  function prepareToHydrateHostInstance(
+    fiber: Fiber,
+    rootContainerInstance: C,
+    hostContext: CX,
+  ): boolean {
+    const instance: I = fiber.stateNode;
+    const updatePayload = hydrateInstance(
+      instance,
+      fiber.type,
+      fiber.memoizedProps,
+      rootContainerInstance,
+      hostContext,
+      fiber,
+    );
+    // TODO: Type this specific to this type of component.
+    fiber.updateQueue = (updatePayload: any);
+    // If the update payload indicates that there is a change or if there
+    // is a new ref we mark this as an update.
+    if (updatePayload !== null) {
+      return true;
+    }
+    return false;
+  }
+
+  function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
+    const textInstance: TI = fiber.stateNode;
+    const textContent: string = fiber.memoizedProps;
+    const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
+    if (__DEV__) {
+      if (shouldUpdate) {
+        // We assume that prepareToHydrateHostTextInstance is called in a context where the
+        // hydration parent is the parent host component of this host text.
+        const returnFiber = hydrationParentFiber;
+        if (returnFiber !== null) {
+          switch (returnFiber.tag) {
+            case HostRoot: {
+              const parentContainer = returnFiber.stateNode.containerInfo;
+              didNotMatchHydratedContainerTextInstance(
+                parentContainer,
+                textInstance,
+                textContent,
+              );
+              break;
+            }
+            case HostComponent: {
+              const parentType = returnFiber.type;
+              const parentProps = returnFiber.memoizedProps;
+              const parentInstance = returnFiber.stateNode;
+              didNotMatchHydratedTextInstance(
+                parentType,
+                parentProps,
+                parentInstance,
+                textInstance,
+                textContent,
+              );
+              break;
+            }
+          }
+        }
+      }
+    }
+    return shouldUpdate;
+  }
+
+  function popToNextHostParent(fiber: Fiber): void {
+    let parent = fiber.return;
+    while (
+      parent !== null &&
+      parent.tag !== HostComponent &&
+      parent.tag !== HostRoot
+    ) {
+      parent = parent.return;
+    }
+    hydrationParentFiber = parent;
+  }
+
+  function popHydrationState(fiber: Fiber): boolean {
+    if (fiber !== hydrationParentFiber) {
+      // We're deeper than the current hydration context, inside an inserted
+      // tree.
+      return false;
+    }
+    if (!isHydrating) {
+      // If we're not currently hydrating but we're in a hydration context, then
+      // we were an insertion and now need to pop up reenter hydration of our
+      // siblings.
+      popToNextHostParent(fiber);
+      isHydrating = true;
+      return false;
+    }
+
+    const type = fiber.type;
+
+    // If we have any remaining hydratable nodes, we need to delete them now.
+    // We only do this deeper than head and body since they tend to have random
+    // other nodes in them. We also ignore components with pure text content in
+    // side of them.
+    // TODO: Better heuristic.
+    if (
+      fiber.tag !== HostComponent ||
+      (type !== 'head' &&
+        type !== 'body' &&
+        !shouldSetTextContent(type, fiber.memoizedProps))
+    ) {
+      let nextInstance = nextHydratableInstance;
+      while (nextInstance) {
+        deleteHydratableInstance(fiber, nextInstance);
+        nextInstance = getNextHydratableSibling(nextInstance);
+      }
+    }
+
+    popToNextHostParent(fiber);
+    nextHydratableInstance = hydrationParentFiber
+      ? getNextHydratableSibling(fiber.stateNode)
+      : null;
+    return true;
+  }
+
+  function resetHydrationState() {
+    hydrationParentFiber = null;
+    nextHydratableInstance = null;
+    isHydrating = false;
+  }
+
+  return {
+    enterHydrationState,
+    resetHydrationState,
+    tryToClaimNextHydratableInstance,
+    prepareToHydrateHostInstance,
+    prepareToHydrateHostTextInstance,
+    popHydrationState,
+  };
+};

commit b52a5624e95f77166ffa520476d68231640692f9
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Oct 18 18:28:23 2017 -0700

    [CS] Persistent Updates (#11260)
    
    * Update build size
    
    * [CS] Clone container instead of new root concept
    
    The extra "root" concept is kind of unnecessary. Instead of having a
    mutable container even in the persistent mode, I'll instead make the
    container be immutable too and be cloned. Then the "commit" just becomes
    swapping the previous container for the new one.
    
    * Change the signature or persistence again
    
    We may need to clone without any updates, e.g. when the children are changed.
    
    Passing in the previous node is not enough to recycle since it won't have the
    up-to-date props and children. It's really only useful to for allocation pooling.
    
    * Implement persistent updates
    
    This forks the update path for host fibers. For mutation mode we mark
    them as having an effect. For persistence mode, we clone the stateNode with
    new props/children.
    
    Next I'll do HostRoot and HostPortal.
    
    * Refine protocol into a complete and commit phase
    
    finalizeContainerChildren will get called at the complete phase.
    replaceContainer will get called at commit.
    
    Also, drop the keepChildren flag. We'll never keep children as we'll never
    update a container if none of the children has changed.
    
    * Implement persistent updates of roots and portals
    
    These are both "containers". Normally we rely on placement/deletion effects
    to deal with insertions into the containers. In the persistent mode we need
    to clone the container and append all the changed children to it.
    
    I needed somewhere to store these new containers before they're committed
    so I added another field.
    
    * Commit persistent work at the end by swapping out the container
    
    * Unify cloneOrRecycle
    
    Originally I tried to make the recyclable instance nullable but Flow didn't
    like that and it's kind of sketchy since the instance type might not be
    nullable.
    
    However, the real difference which one we call is depending on whether they
    are equal. We can just offload that to the renderer. Most of them won't
    need to know about this at all since they'll always clone or just create
    new.
    
    The ones that do know now have to be careful to compare them so they don't
    reuse an existing instance but that's probably fine to simplify the
    implementation and API.
    
    * Add persistent noop renderer for testing
    
    * Add basic persistent tree test
    
    * Test bail out
    
    This adds a test for bailouts. This revealed a subtle bug. We don't set the
    return pointer when stepping into newly created fibers because there
    can only be one. However, since I'm reusing this mechanism for persistent
    updates, I'll need to set the return pointer because a bailed out tree
    won't have the right return pointer.
    
    * Test persistent text nodes
    
    Found another bug.
    
    * Add persistent portal test
    
    This creates a bit of an unfortunate feature testing in the unmount
    branch.
    
    That's because we want to trigger nested host deletions in portals in the
    mutation mode.
    
    * Don't consider container when determining portal identity
    
    Basically, we can't use the container to determine if we should keep
    identity and update an existing portal instead of recreate it. Because
    for persistent containers, there is no permanent identity.
    
    This makes it kind of strange to even use portals in this mode. It's
    probably more ideal to have another concept that has permanent identity
    rather than trying to swap out containers.
    
    * Clear portals when the portal is deleted
    
    When a portal gets deleted we need to create a new empty container and
    replace the current one with the empty one.
    
    * Add renderer mode flags for dead code elimination
    
    * Simplify ReactNoop fix
    
    * Add new type to the host config for persistent configs
    
    We need container to stay as the persistent identity of the root atom.
    So that we can refer to portals over time.
    
    Instead, I'll introduce a new type just to temporarily hold the children
    of a container until they're ready to be committed into the permanent
    container. Essentially, this is just a fancy array that is not an array
    so that the host can choose data structure/allocation for it.
    
    * Implement new hooks
    
    Now containers are singletons and instead their children swap. That way
    portals can use the container as part of their identity again.
    
    * Update build size and error codes
    
    * Address comment
    
    * Move new files to new location

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index f6024e39c6..d710db0671 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -33,8 +33,8 @@ export type HydrationContext<C, CX> = {
   popHydrationState(fiber: Fiber): boolean,
 };
 
-module.exports = function<T, P, I, TI, PI, C, CX, PL>(
-  config: HostConfig<T, P, I, TI, PI, C, CX, PL>,
+module.exports = function<T, P, I, TI, PI, C, CC, CX, PL>(
+  config: HostConfig<T, P, I, TI, PI, C, CC, CX, PL>,
 ): HydrationContext<C, CX> {
   const {shouldSetTextContent, hydration} = config;
 

commit 313611572b6567d229367ed20ff63d1bca8610bb
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 19:50:24 2017 +0100

    Reorganize code structure (#11288)
    
    * Move files and tests to more meaningful places
    
    * Fix the build
    
    Now that we import reconciler via react-reconciler, I needed to make a few tweaks.
    
    * Update sizes
    
    * Move @preventMunge directive to FB header
    
    * Revert unintentional change
    
    * Fix Flow coverage
    
    I forgot to @flow-ify those files. This uncovered some issues.
    
    * Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    
    Like a rat in a cage
    Pulling minimum wage
    Prettier, I love you but you're bringing me down
    
    Prettier, you're safer and you're wasting my time
    Our records all show you were filthy but fine
    But they shuttered your stores
    When you opened the doors
    To the cops who were bored once they'd run out of crime
    
    Prettier, you're perfect, oh, please don't change a thing
    Your mild billionaire mayor's now convinced he's a king
    So the boring collect
    I mean all disrespect
    In the neighborhood bars I'd once dreamt I would drink
    
    Prettier, I love you but you're freaking me out
    There's a ton of the twist but we're fresh out of shout
    Like a death in the hall
    That you hear through your wall
    Prettier, I love you but you're freaking me out
    
    Prettier, I love you but you're bringing me down
    Prettier, I love you but you're bringing me down
    Like a death of the heart
    Jesus, where do I start?
    But you're still the one pool where I'd happily drown
    
    And oh! Take me off your mailing list
    For kids who think it still exists
    Yes, for those who think it still exists
    Maybe I'm wrong and maybe you're right
    Maybe I'm wrong and maybe you're right
    Maybe you're right, maybe I'm wrong
    And just maybe you're right
    
    And oh! Maybe mother told you true
    And there'll always be somebody there for you
    And you'll never be alone
    But maybe she's wrong and maybe I'm right
    And just maybe she's wrong
    Maybe she's wrong and maybe I'm right
    And if so, here's this song!

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index d710db0671..367f0ad717 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -10,8 +10,8 @@
 
 'use strict';
 
+import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from 'ReactFiber';
-import type {HostConfig} from 'ReactFiberReconciler';
 
 var invariant = require('fbjs/lib/invariant');
 

commit 1eed302d346bfb8f5db8d88b0e7096d8999d3548
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Oct 25 02:55:00 2017 +0300

    Drop Haste (#11303)
    
    * Use relative paths in packages/react
    
    * Use relative paths in packages/react-art
    
    * Use relative paths in packages/react-cs
    
    * Use relative paths in other packages
    
    * Fix as many issues as I can
    
    This uncovered an interesting problem where ./b from package/src/a would resolve to a different instantiation of package/src/b in Jest.
    
    Either this is a showstopper or we can solve it by completely fobbidding remaining /src/.
    
    * Fix all tests
    
    It seems we can't use relative requires in tests anymore. Otherwise Jest becomes confused between real file and symlink.
    https://github.com/facebook/jest/issues/3830
    
    This seems bad... Except that we already *don't* want people to create tests that import individual source files.
    All existing cases of us doing so are actually TODOs waiting to be fixed.
    
    So perhaps this requirement isn't too bad because it makes bad code looks bad.
    
    Of course, if we go with this, we'll have to lint against relative requires in tests.
    It also makes moving things more painful.
    
    * Prettier
    
    * Remove @providesModule
    
    * Fix remaining Haste imports I missed earlier
    
    * Fix up paths to reflect new flat structure
    
    * Fix Flow
    
    * Fix CJS and UMD builds
    
    * Fix FB bundles
    
    * Fix RN bundles
    
    * Prettier
    
    * Fix lint
    
    * Fix warning printing and error codes
    
    * Fix buggy return
    
    * Fix lint and Flow
    
    * Use Yarn on CI
    
    * Unbreak Jest
    
    * Fix lint
    
    * Fix aliased originals getting included in DEV
    
    Shouldn't affect correctness (they were ignored) but fixes DEV size regression.
    
    * Record sizes
    
    * Fix weird version in package.json
    
    * Tweak bundle labels
    
    * Get rid of output option by introducing react-dom/server.node
    
    * Reconciler should depend on prop-types
    
    * Update sizes last time

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 367f0ad717..f37fe514ee 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -4,21 +4,20 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
- * @providesModule ReactFiberHydrationContext
  * @flow
  */
 
 'use strict';
 
 import type {HostConfig} from 'react-reconciler';
-import type {Fiber} from 'ReactFiber';
+import type {Fiber} from './ReactFiber';
 
 var invariant = require('fbjs/lib/invariant');
 
-const {HostComponent, HostText, HostRoot} = require('ReactTypeOfWork');
-const {Deletion, Placement} = require('ReactTypeOfSideEffect');
+const {HostComponent, HostText, HostRoot} = require('shared/ReactTypeOfWork');
+const {Deletion, Placement} = require('shared/ReactTypeOfSideEffect');
 
-const {createFiberFromHostInstanceForDeletion} = require('ReactFiber');
+const {createFiberFromHostInstanceForDeletion} = require('./ReactFiber');
 
 export type HydrationContext<C, CX> = {
   enterHydrationState(fiber: Fiber): boolean,

commit 087c48bb36b88ef0b5bbca2b9b70a52d8d413102
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Oct 25 21:07:54 2017 +0300

    Reorder imports (#11359)
    
    * Reorder imports
    
    * Record sizes

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index f37fe514ee..6b575b2e84 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -12,10 +12,9 @@
 import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
 
-var invariant = require('fbjs/lib/invariant');
-
 const {HostComponent, HostText, HostRoot} = require('shared/ReactTypeOfWork');
 const {Deletion, Placement} = require('shared/ReactTypeOfSideEffect');
+var invariant = require('fbjs/lib/invariant');
 
 const {createFiberFromHostInstanceForDeletion} = require('./ReactFiber');
 

commit 21d0c115238b4f38837020cf83e0c657d8c01c9f
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 2 19:50:03 2017 +0000

    Convert the Source to ES Modules (#11389)
    
    * Update transforms to handle ES modules
    
    * Update Jest to handle ES modules
    
    * Convert react package to ES modules
    
    * Convert react-art package to ES Modules
    
    * Convert react-call-return package to ES Modules
    
    * Convert react-test-renderer package to ES Modules
    
    * Convert react-cs-renderer package to ES Modules
    
    * Convert react-rt-renderer package to ES Modules
    
    * Convert react-noop-renderer package to ES Modules
    
    * Convert react-dom/server to ES modules
    
    * Convert react-dom/{client,events,test-utils} to ES modules
    
    * Convert react-dom/shared to ES modules
    
    * Convert react-native-renderer to ES modules
    
    * Convert react-reconciler to ES modules
    
    * Convert events to ES modules
    
    * Convert shared to ES modules
    
    * Remove CommonJS support from transforms
    
    * Move ReactDOMFB entry point code into react-dom/src
    
    This is clearer because we can use ES imports in it.
    
    * Fix Rollup shim configuration to work with ESM
    
    * Fix incorrect comment
    
    * Exclude external imports without side effects
    
    * Fix ReactDOM FB build
    
    * Remove TODOs I don’t intend to fix yet

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 6b575b2e84..e800dca28a 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -12,11 +12,11 @@
 import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
 
-const {HostComponent, HostText, HostRoot} = require('shared/ReactTypeOfWork');
-const {Deletion, Placement} = require('shared/ReactTypeOfSideEffect');
-var invariant = require('fbjs/lib/invariant');
+import {HostComponent, HostText, HostRoot} from 'shared/ReactTypeOfWork';
+import {Deletion, Placement} from 'shared/ReactTypeOfSideEffect';
+import invariant from 'fbjs/lib/invariant';
 
-const {createFiberFromHostInstanceForDeletion} = require('./ReactFiber');
+import {createFiberFromHostInstanceForDeletion} from './ReactFiber';
 
 export type HydrationContext<C, CX> = {
   enterHydrationState(fiber: Fiber): boolean,
@@ -31,7 +31,7 @@ export type HydrationContext<C, CX> = {
   popHydrationState(fiber: Fiber): boolean,
 };
 
-module.exports = function<T, P, I, TI, PI, C, CC, CX, PL>(
+export default function<T, P, I, TI, PI, C, CC, CX, PL>(
   config: HostConfig<T, P, I, TI, PI, C, CC, CX, PL>,
 ): HydrationContext<C, CX> {
   const {shouldSetTextContent, hydration} = config;
@@ -376,4 +376,4 @@ module.exports = function<T, P, I, TI, PI, C, CC, CX, PL>(
     prepareToHydrateHostTextInstance,
     popHydrationState,
   };
-};
+}

commit 45c1ff348e1c7d03567f5bba6cb32cffa9222972
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 2 20:32:48 2017 +0000

    Remove unnecessary 'use strict' in the source (#11433)
    
    * Remove use strict from ES modules
    
    * Delete unused file
    
    This was unused since Stack.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index e800dca28a..a0d659ef78 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -7,8 +7,6 @@
  * @flow
  */
 
-'use strict';
-
 import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
 

commit acabf112454e5545205da013266d8529599a2a82
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Nov 11 17:00:33 2017 -0800

    Update Flow and Fix Hydration Types (#11493)
    
    * Update Flow
    
    * Fix createElement() issue
    
    The * type was too ambiguous. It's always a string so what's the point?
    
    Suppression for missing Flow support for {is: ''} web component argument to createElement() didn't work for some reason.
    I don't understand what the regex is testing for anyway (a task number?) so I just removed that, and suppression got fixed.
    
    * Remove deleted $Abstract<> feature
    
    * Expand the unsound isAsync check
    
    Flow now errors earlier because it can't find .type on a portal.
    
    * Add an unsafe cast for the null State in UpdateQueue
    
    * Introduce "hydratable instance" type
    
    The Flow error here highlighted a quirk in our typing of hydration.
    React only really knows about a subset of all possible nodes that can
    exist in a hydrated tree. Currently we assume that the host renderer
    filters them out to be either Instance or TextInstance. We also assume
    that those are different things which they might not be. E.g. it could
    be fine for a renderer to render "text" as the same type as one of the
    instances, with some default props.
    
    We don't really know what it will be narrowed down to until we call
    canHydrateInstance or canHydrateTextInstance. That's when the type is
    truly refined.
    
    So to solve this I use a different type for hydratable instance that is
    used in that temporary stage between us reading it from the DOM and until
    it gets refined by canHydrate(Text)Instance.
    
    * Have the renderer refine Hydratable Instance to Instance or Text Instance
    
    Currently we assume that if canHydrateInstance or canHydrateTextInstance
    returns true, then the types also match up. But we don't tell that to Flow.
    
    It just happens to work because `fiber.stateNode` is still `any`.
    
    We could potentially use some kind of predicate typing but instead
    of that I can just return null or instance from the "can" tests.
    
    This ensures that the renderer has to do the refinement properly.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a0d659ef78..bd3889580a 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -29,8 +29,8 @@ export type HydrationContext<C, CX> = {
   popHydrationState(fiber: Fiber): boolean,
 };
 
-export default function<T, P, I, TI, PI, C, CC, CX, PL>(
-  config: HostConfig<T, P, I, TI, PI, C, CC, CX, PL>,
+export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
+  config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,
 ): HydrationContext<C, CX> {
   const {shouldSetTextContent, hydration} = config;
 
@@ -82,7 +82,7 @@ export default function<T, P, I, TI, PI, C, CC, CX, PL>(
   // The deepest Fiber on the stack involved in a hydration context.
   // This may have been an insertion or a hydration.
   let hydrationParentFiber: null | Fiber = null;
-  let nextHydratableInstance: null | I | TI = null;
+  let nextHydratableInstance: null | HI = null;
   let isHydrating: boolean = false;
 
   function enterHydrationState(fiber: Fiber) {
@@ -188,16 +188,26 @@ export default function<T, P, I, TI, PI, C, CC, CX, PL>(
     }
   }
 
-  function canHydrate(fiber, nextInstance) {
+  function tryHydrate(fiber, nextInstance) {
     switch (fiber.tag) {
       case HostComponent: {
         const type = fiber.type;
         const props = fiber.pendingProps;
-        return canHydrateInstance(nextInstance, type, props);
+        const instance = canHydrateInstance(nextInstance, type, props);
+        if (instance !== null) {
+          fiber.stateNode = (instance: I);
+          return true;
+        }
+        return false;
       }
       case HostText: {
         const text = fiber.pendingProps;
-        return canHydrateTextInstance(nextInstance, text);
+        const textInstance = canHydrateTextInstance(nextInstance, text);
+        if (textInstance !== null) {
+          fiber.stateNode = (textInstance: TI);
+          return true;
+        }
+        return false;
       }
       default:
         return false;
@@ -216,12 +226,12 @@ export default function<T, P, I, TI, PI, C, CC, CX, PL>(
       hydrationParentFiber = fiber;
       return;
     }
-    if (!canHydrate(fiber, nextInstance)) {
+    if (!tryHydrate(fiber, nextInstance)) {
       // If we can't hydrate this instance let's try the next one.
       // We use this as a heuristic. It's based on intuition and not data so it
       // might be flawed or unnecessary.
       nextInstance = getNextHydratableSibling(nextInstance);
-      if (!nextInstance || !canHydrate(fiber, nextInstance)) {
+      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
         // Nothing to hydrate. Make it an insertion.
         insertNonHydratedInstance((hydrationParentFiber: any), fiber);
         isHydrating = false;
@@ -237,7 +247,6 @@ export default function<T, P, I, TI, PI, C, CC, CX, PL>(
         nextHydratableInstance,
       );
     }
-    fiber.stateNode = nextInstance;
     hydrationParentFiber = fiber;
     nextHydratableInstance = getFirstHydratableChild(nextInstance);
   }

commit 47b003a828fe98e12947ba98e819ec4e617deef1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat May 19 11:29:11 2018 +0100

    Resolve host configs at build time (#12792)
    
    * Extract base Jest config
    
    This makes it easier to change the source config without affecting the build test config.
    
    * Statically import the host config
    
    This changes react-reconciler to import HostConfig instead of getting it through a function argument.
    
    Rather than start with packages like ReactDOM that want to inline it, I started with React Noop and ensured that *custom* renderers using react-reconciler package still work. To do this, I'm making HostConfig module in the reconciler look at a global variable by default (which, in case of the react-reconciler npm package, ends up being the host config argument in the top-level scope).
    
    This is still very broken.
    
    * Add scaffolding for importing an inlined renderer
    
    * Fix the build
    
    * ES exports for renderer methods
    
    * ES modules for host configs
    
    * Remove closures from the reconciler
    
    * Check each renderer's config with Flow
    
    * Fix uncovered Flow issue
    
    We know nextHydratableInstance doesn't get mutated inside this function, but Flow doesn't so it thinks it may be null.
    Help Flow.
    
    * Prettier
    
    * Get rid of enable*Reconciler flags
    
    They are not as useful anymore because for almost all cases (except third party renderers) we *know* whether it supports mutation or persistence.
    
    This refactoring means react-reconciler and react-reconciler/persistent third-party packages now ship the same thing.
    Not ideal, but this seems worth how simpler the code becomes. We can later look into addressing it by having a single toggle instead.
    
    * Prettier again
    
    * Fix Flow config creation issue
    
    * Fix imprecise Flow typing
    
    * Revert accidental changes

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index bd3889580a..bc4b9eae80 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -7,380 +7,367 @@
  * @flow
  */
 
-import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
+import type {
+  Instance,
+  TextInstance,
+  HydratableInstance,
+  Container,
+  HostContext,
+} from './ReactFiberHostConfig';
 
 import {HostComponent, HostText, HostRoot} from 'shared/ReactTypeOfWork';
 import {Deletion, Placement} from 'shared/ReactTypeOfSideEffect';
 import invariant from 'fbjs/lib/invariant';
 
 import {createFiberFromHostInstanceForDeletion} from './ReactFiber';
+import {
+  shouldSetTextContent,
+  supportsHydration,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  getNextHydratableSibling,
+  getFirstHydratableChild,
+  hydrateInstance,
+  hydrateTextInstance,
+  didNotMatchHydratedContainerTextInstance,
+  didNotMatchHydratedTextInstance,
+  didNotHydrateContainerInstance,
+  didNotHydrateInstance,
+  didNotFindHydratableContainerInstance,
+  didNotFindHydratableContainerTextInstance,
+  didNotFindHydratableInstance,
+  didNotFindHydratableTextInstance,
+} from './ReactFiberHostConfig';
 
-export type HydrationContext<C, CX> = {
-  enterHydrationState(fiber: Fiber): boolean,
-  resetHydrationState(): void,
-  tryToClaimNextHydratableInstance(fiber: Fiber): void,
-  prepareToHydrateHostInstance(
-    fiber: Fiber,
-    rootContainerInstance: C,
-    hostContext: CX,
-  ): boolean,
-  prepareToHydrateHostTextInstance(fiber: Fiber): boolean,
-  popHydrationState(fiber: Fiber): boolean,
-};
-
-export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
-  config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,
-): HydrationContext<C, CX> {
-  const {shouldSetTextContent, hydration} = config;
+// The deepest Fiber on the stack involved in a hydration context.
+// This may have been an insertion or a hydration.
+let hydrationParentFiber: null | Fiber = null;
+let nextHydratableInstance: null | HydratableInstance = null;
+let isHydrating: boolean = false;
 
-  // If this doesn't have hydration mode.
-  if (!hydration) {
-    return {
-      enterHydrationState() {
-        return false;
-      },
-      resetHydrationState() {},
-      tryToClaimNextHydratableInstance() {},
-      prepareToHydrateHostInstance() {
-        invariant(
-          false,
-          'Expected prepareToHydrateHostInstance() to never be called. ' +
-            'This error is likely caused by a bug in React. Please file an issue.',
-        );
-      },
-      prepareToHydrateHostTextInstance() {
-        invariant(
-          false,
-          'Expected prepareToHydrateHostTextInstance() to never be called. ' +
-            'This error is likely caused by a bug in React. Please file an issue.',
-        );
-      },
-      popHydrationState(fiber: Fiber) {
-        return false;
-      },
-    };
+function enterHydrationState(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    return false;
   }
 
-  const {
-    canHydrateInstance,
-    canHydrateTextInstance,
-    getNextHydratableSibling,
-    getFirstHydratableChild,
-    hydrateInstance,
-    hydrateTextInstance,
-    didNotMatchHydratedContainerTextInstance,
-    didNotMatchHydratedTextInstance,
-    didNotHydrateContainerInstance,
-    didNotHydrateInstance,
-    didNotFindHydratableContainerInstance,
-    didNotFindHydratableContainerTextInstance,
-    didNotFindHydratableInstance,
-    didNotFindHydratableTextInstance,
-  } = hydration;
-
-  // The deepest Fiber on the stack involved in a hydration context.
-  // This may have been an insertion or a hydration.
-  let hydrationParentFiber: null | Fiber = null;
-  let nextHydratableInstance: null | HI = null;
-  let isHydrating: boolean = false;
-
-  function enterHydrationState(fiber: Fiber) {
-    const parentInstance = fiber.stateNode.containerInfo;
-    nextHydratableInstance = getFirstHydratableChild(parentInstance);
-    hydrationParentFiber = fiber;
-    isHydrating = true;
-    return true;
-  }
+  const parentInstance = fiber.stateNode.containerInfo;
+  nextHydratableInstance = getFirstHydratableChild(parentInstance);
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  return true;
+}
 
-  function deleteHydratableInstance(returnFiber: Fiber, instance: I | TI) {
-    if (__DEV__) {
-      switch (returnFiber.tag) {
-        case HostRoot:
-          didNotHydrateContainerInstance(
-            returnFiber.stateNode.containerInfo,
-            instance,
-          );
-          break;
-        case HostComponent:
-          didNotHydrateInstance(
-            returnFiber.type,
-            returnFiber.memoizedProps,
-            returnFiber.stateNode,
-            instance,
-          );
-          break;
-      }
+function deleteHydratableInstance(
+  returnFiber: Fiber,
+  instance: HydratableInstance,
+) {
+  if (__DEV__) {
+    switch (returnFiber.tag) {
+      case HostRoot:
+        didNotHydrateContainerInstance(
+          returnFiber.stateNode.containerInfo,
+          instance,
+        );
+        break;
+      case HostComponent:
+        didNotHydrateInstance(
+          returnFiber.type,
+          returnFiber.memoizedProps,
+          returnFiber.stateNode,
+          instance,
+        );
+        break;
     }
+  }
 
-    const childToDelete = createFiberFromHostInstanceForDeletion();
-    childToDelete.stateNode = instance;
-    childToDelete.return = returnFiber;
-    childToDelete.effectTag = Deletion;
+  const childToDelete = createFiberFromHostInstanceForDeletion();
+  childToDelete.stateNode = instance;
+  childToDelete.return = returnFiber;
+  childToDelete.effectTag = Deletion;
 
-    // This might seem like it belongs on progressedFirstDeletion. However,
-    // these children are not part of the reconciliation list of children.
-    // Even if we abort and rereconcile the children, that will try to hydrate
-    // again and the nodes are still in the host tree so these will be
-    // recreated.
-    if (returnFiber.lastEffect !== null) {
-      returnFiber.lastEffect.nextEffect = childToDelete;
-      returnFiber.lastEffect = childToDelete;
-    } else {
-      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
-    }
+  // This might seem like it belongs on progressedFirstDeletion. However,
+  // these children are not part of the reconciliation list of children.
+  // Even if we abort and rereconcile the children, that will try to hydrate
+  // again and the nodes are still in the host tree so these will be
+  // recreated.
+  if (returnFiber.lastEffect !== null) {
+    returnFiber.lastEffect.nextEffect = childToDelete;
+    returnFiber.lastEffect = childToDelete;
+  } else {
+    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
   }
+}
 
-  function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
-    fiber.effectTag |= Placement;
-    if (__DEV__) {
-      switch (returnFiber.tag) {
-        case HostRoot: {
-          const parentContainer = returnFiber.stateNode.containerInfo;
-          switch (fiber.tag) {
-            case HostComponent:
-              const type = fiber.type;
-              const props = fiber.pendingProps;
-              didNotFindHydratableContainerInstance(
-                parentContainer,
-                type,
-                props,
-              );
-              break;
-            case HostText:
-              const text = fiber.pendingProps;
-              didNotFindHydratableContainerTextInstance(parentContainer, text);
-              break;
-          }
-          break;
+function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+  fiber.effectTag |= Placement;
+  if (__DEV__) {
+    switch (returnFiber.tag) {
+      case HostRoot: {
+        const parentContainer = returnFiber.stateNode.containerInfo;
+        switch (fiber.tag) {
+          case HostComponent:
+            const type = fiber.type;
+            const props = fiber.pendingProps;
+            didNotFindHydratableContainerInstance(parentContainer, type, props);
+            break;
+          case HostText:
+            const text = fiber.pendingProps;
+            didNotFindHydratableContainerTextInstance(parentContainer, text);
+            break;
         }
-        case HostComponent: {
-          const parentType = returnFiber.type;
-          const parentProps = returnFiber.memoizedProps;
-          const parentInstance = returnFiber.stateNode;
-          switch (fiber.tag) {
-            case HostComponent:
-              const type = fiber.type;
-              const props = fiber.pendingProps;
-              didNotFindHydratableInstance(
-                parentType,
-                parentProps,
-                parentInstance,
-                type,
-                props,
-              );
-              break;
-            case HostText:
-              const text = fiber.pendingProps;
-              didNotFindHydratableTextInstance(
-                parentType,
-                parentProps,
-                parentInstance,
-                text,
-              );
-              break;
-          }
-          break;
+        break;
+      }
+      case HostComponent: {
+        const parentType = returnFiber.type;
+        const parentProps = returnFiber.memoizedProps;
+        const parentInstance = returnFiber.stateNode;
+        switch (fiber.tag) {
+          case HostComponent:
+            const type = fiber.type;
+            const props = fiber.pendingProps;
+            didNotFindHydratableInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+              type,
+              props,
+            );
+            break;
+          case HostText:
+            const text = fiber.pendingProps;
+            didNotFindHydratableTextInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+              text,
+            );
+            break;
         }
-        default:
-          return;
+        break;
       }
+      default:
+        return;
     }
   }
+}
 
-  function tryHydrate(fiber, nextInstance) {
-    switch (fiber.tag) {
-      case HostComponent: {
-        const type = fiber.type;
-        const props = fiber.pendingProps;
-        const instance = canHydrateInstance(nextInstance, type, props);
-        if (instance !== null) {
-          fiber.stateNode = (instance: I);
-          return true;
-        }
-        return false;
+function tryHydrate(fiber, nextInstance) {
+  switch (fiber.tag) {
+    case HostComponent: {
+      const type = fiber.type;
+      const props = fiber.pendingProps;
+      const instance = canHydrateInstance(nextInstance, type, props);
+      if (instance !== null) {
+        fiber.stateNode = (instance: Instance);
+        return true;
       }
-      case HostText: {
-        const text = fiber.pendingProps;
-        const textInstance = canHydrateTextInstance(nextInstance, text);
-        if (textInstance !== null) {
-          fiber.stateNode = (textInstance: TI);
-          return true;
-        }
-        return false;
+      return false;
+    }
+    case HostText: {
+      const text = fiber.pendingProps;
+      const textInstance = canHydrateTextInstance(nextInstance, text);
+      if (textInstance !== null) {
+        fiber.stateNode = (textInstance: TextInstance);
+        return true;
       }
-      default:
-        return false;
+      return false;
     }
+    default:
+      return false;
   }
+}
 
-  function tryToClaimNextHydratableInstance(fiber: Fiber) {
-    if (!isHydrating) {
-      return;
-    }
-    let nextInstance = nextHydratableInstance;
-    if (!nextInstance) {
+function tryToClaimNextHydratableInstance(fiber: Fiber): void {
+  if (!isHydrating) {
+    return;
+  }
+  let nextInstance = nextHydratableInstance;
+  if (!nextInstance) {
+    // Nothing to hydrate. Make it an insertion.
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  const firstAttemptedInstance = nextInstance;
+  if (!tryHydrate(fiber, nextInstance)) {
+    // If we can't hydrate this instance let's try the next one.
+    // We use this as a heuristic. It's based on intuition and not data so it
+    // might be flawed or unnecessary.
+    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
+    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
       // Nothing to hydrate. Make it an insertion.
       insertNonHydratedInstance((hydrationParentFiber: any), fiber);
       isHydrating = false;
       hydrationParentFiber = fiber;
       return;
     }
-    if (!tryHydrate(fiber, nextInstance)) {
-      // If we can't hydrate this instance let's try the next one.
-      // We use this as a heuristic. It's based on intuition and not data so it
-      // might be flawed or unnecessary.
-      nextInstance = getNextHydratableSibling(nextInstance);
-      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
-        // Nothing to hydrate. Make it an insertion.
-        insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-        isHydrating = false;
-        hydrationParentFiber = fiber;
-        return;
-      }
-      // We matched the next one, we'll now assume that the first one was
-      // superfluous and we'll delete it. Since we can't eagerly delete it
-      // we'll have to schedule a deletion. To do that, this node needs a dummy
-      // fiber associated with it.
-      deleteHydratableInstance(
-        (hydrationParentFiber: any),
-        nextHydratableInstance,
-      );
-    }
-    hydrationParentFiber = fiber;
-    nextHydratableInstance = getFirstHydratableChild(nextInstance);
+    // We matched the next one, we'll now assume that the first one was
+    // superfluous and we'll delete it. Since we can't eagerly delete it
+    // we'll have to schedule a deletion. To do that, this node needs a dummy
+    // fiber associated with it.
+    deleteHydratableInstance(
+      (hydrationParentFiber: any),
+      firstAttemptedInstance,
+    );
   }
+  hydrationParentFiber = fiber;
+  nextHydratableInstance = getFirstHydratableChild((nextInstance: any));
+}
 
-  function prepareToHydrateHostInstance(
-    fiber: Fiber,
-    rootContainerInstance: C,
-    hostContext: CX,
-  ): boolean {
-    const instance: I = fiber.stateNode;
-    const updatePayload = hydrateInstance(
-      instance,
-      fiber.type,
-      fiber.memoizedProps,
-      rootContainerInstance,
-      hostContext,
-      fiber,
+function prepareToHydrateHostInstance(
+  fiber: Fiber,
+  rootContainerInstance: Container,
+  hostContext: HostContext,
+): boolean {
+  if (!supportsHydration) {
+    invariant(
+      false,
+      'Expected prepareToHydrateHostInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
     );
-    // TODO: Type this specific to this type of component.
-    fiber.updateQueue = (updatePayload: any);
-    // If the update payload indicates that there is a change or if there
-    // is a new ref we mark this as an update.
-    if (updatePayload !== null) {
-      return true;
-    }
-    return false;
   }
 
-  function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
-    const textInstance: TI = fiber.stateNode;
-    const textContent: string = fiber.memoizedProps;
-    const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
-    if (__DEV__) {
-      if (shouldUpdate) {
-        // We assume that prepareToHydrateHostTextInstance is called in a context where the
-        // hydration parent is the parent host component of this host text.
-        const returnFiber = hydrationParentFiber;
-        if (returnFiber !== null) {
-          switch (returnFiber.tag) {
-            case HostRoot: {
-              const parentContainer = returnFiber.stateNode.containerInfo;
-              didNotMatchHydratedContainerTextInstance(
-                parentContainer,
-                textInstance,
-                textContent,
-              );
-              break;
-            }
-            case HostComponent: {
-              const parentType = returnFiber.type;
-              const parentProps = returnFiber.memoizedProps;
-              const parentInstance = returnFiber.stateNode;
-              didNotMatchHydratedTextInstance(
-                parentType,
-                parentProps,
-                parentInstance,
-                textInstance,
-                textContent,
-              );
-              break;
-            }
+  const instance: Instance = fiber.stateNode;
+  const updatePayload = hydrateInstance(
+    instance,
+    fiber.type,
+    fiber.memoizedProps,
+    rootContainerInstance,
+    hostContext,
+    fiber,
+  );
+  // TODO: Type this specific to this type of component.
+  fiber.updateQueue = (updatePayload: any);
+  // If the update payload indicates that there is a change or if there
+  // is a new ref we mark this as an update.
+  if (updatePayload !== null) {
+    return true;
+  }
+  return false;
+}
+
+function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    invariant(
+      false,
+      'Expected prepareToHydrateHostTextInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  const textInstance: TextInstance = fiber.stateNode;
+  const textContent: string = fiber.memoizedProps;
+  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
+  if (__DEV__) {
+    if (shouldUpdate) {
+      // We assume that prepareToHydrateHostTextInstance is called in a context where the
+      // hydration parent is the parent host component of this host text.
+      const returnFiber = hydrationParentFiber;
+      if (returnFiber !== null) {
+        switch (returnFiber.tag) {
+          case HostRoot: {
+            const parentContainer = returnFiber.stateNode.containerInfo;
+            didNotMatchHydratedContainerTextInstance(
+              parentContainer,
+              textInstance,
+              textContent,
+            );
+            break;
+          }
+          case HostComponent: {
+            const parentType = returnFiber.type;
+            const parentProps = returnFiber.memoizedProps;
+            const parentInstance = returnFiber.stateNode;
+            didNotMatchHydratedTextInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+              textInstance,
+              textContent,
+            );
+            break;
           }
         }
       }
     }
-    return shouldUpdate;
   }
+  return shouldUpdate;
+}
 
-  function popToNextHostParent(fiber: Fiber): void {
-    let parent = fiber.return;
-    while (
-      parent !== null &&
-      parent.tag !== HostComponent &&
-      parent.tag !== HostRoot
-    ) {
-      parent = parent.return;
-    }
-    hydrationParentFiber = parent;
+function popToNextHostParent(fiber: Fiber): void {
+  let parent = fiber.return;
+  while (
+    parent !== null &&
+    parent.tag !== HostComponent &&
+    parent.tag !== HostRoot
+  ) {
+    parent = parent.return;
   }
+  hydrationParentFiber = parent;
+}
 
-  function popHydrationState(fiber: Fiber): boolean {
-    if (fiber !== hydrationParentFiber) {
-      // We're deeper than the current hydration context, inside an inserted
-      // tree.
-      return false;
-    }
-    if (!isHydrating) {
-      // If we're not currently hydrating but we're in a hydration context, then
-      // we were an insertion and now need to pop up reenter hydration of our
-      // siblings.
-      popToNextHostParent(fiber);
-      isHydrating = true;
-      return false;
-    }
+function popHydrationState(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  if (fiber !== hydrationParentFiber) {
+    // We're deeper than the current hydration context, inside an inserted
+    // tree.
+    return false;
+  }
+  if (!isHydrating) {
+    // If we're not currently hydrating but we're in a hydration context, then
+    // we were an insertion and now need to pop up reenter hydration of our
+    // siblings.
+    popToNextHostParent(fiber);
+    isHydrating = true;
+    return false;
+  }
 
-    const type = fiber.type;
+  const type = fiber.type;
 
-    // If we have any remaining hydratable nodes, we need to delete them now.
-    // We only do this deeper than head and body since they tend to have random
-    // other nodes in them. We also ignore components with pure text content in
-    // side of them.
-    // TODO: Better heuristic.
-    if (
-      fiber.tag !== HostComponent ||
-      (type !== 'head' &&
-        type !== 'body' &&
-        !shouldSetTextContent(type, fiber.memoizedProps))
-    ) {
-      let nextInstance = nextHydratableInstance;
-      while (nextInstance) {
-        deleteHydratableInstance(fiber, nextInstance);
-        nextInstance = getNextHydratableSibling(nextInstance);
-      }
+  // If we have any remaining hydratable nodes, we need to delete them now.
+  // We only do this deeper than head and body since they tend to have random
+  // other nodes in them. We also ignore components with pure text content in
+  // side of them.
+  // TODO: Better heuristic.
+  if (
+    fiber.tag !== HostComponent ||
+    (type !== 'head' &&
+      type !== 'body' &&
+      !shouldSetTextContent(type, fiber.memoizedProps))
+  ) {
+    let nextInstance = nextHydratableInstance;
+    while (nextInstance) {
+      deleteHydratableInstance(fiber, nextInstance);
+      nextInstance = getNextHydratableSibling(nextInstance);
     }
-
-    popToNextHostParent(fiber);
-    nextHydratableInstance = hydrationParentFiber
-      ? getNextHydratableSibling(fiber.stateNode)
-      : null;
-    return true;
   }
 
-  function resetHydrationState() {
-    hydrationParentFiber = null;
-    nextHydratableInstance = null;
-    isHydrating = false;
+  popToNextHostParent(fiber);
+  nextHydratableInstance = hydrationParentFiber
+    ? getNextHydratableSibling(fiber.stateNode)
+    : null;
+  return true;
+}
+
+function resetHydrationState(): void {
+  if (!supportsHydration) {
+    return;
   }
 
-  return {
-    enterHydrationState,
-    resetHydrationState,
-    tryToClaimNextHydratableInstance,
-    prepareToHydrateHostInstance,
-    prepareToHydrateHostTextInstance,
-    popHydrationState,
-  };
+  hydrationParentFiber = null;
+  nextHydratableInstance = null;
+  isHydrating = false;
 }
+
+export {
+  enterHydrationState,
+  resetHydrationState,
+  tryToClaimNextHydratableInstance,
+  prepareToHydrateHostInstance,
+  prepareToHydrateHostTextInstance,
+  popHydrationState,
+};

commit aeda7b745d9c080150704feb20ea576238a1b9a1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jun 19 16:03:45 2018 +0100

    Remove fbjs dependency (#13069)
    
    * Inline fbjs/lib/invariant
    
    * Inline fbjs/lib/warning
    
    * Remove remaining usage of fbjs in packages/*.js
    
    * Fix lint
    
    * Remove fbjs from dependencies
    
    * Protect against accidental fbjs imports
    
    * Fix broken test mocks
    
    * Allow transitive deps on fbjs/ for UMD bundles
    
    * Remove fbjs from release script

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index bc4b9eae80..8983333a30 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -18,7 +18,7 @@ import type {
 
 import {HostComponent, HostText, HostRoot} from 'shared/ReactTypeOfWork';
 import {Deletion, Placement} from 'shared/ReactTypeOfSideEffect';
-import invariant from 'fbjs/lib/invariant';
+import invariant from 'shared/invariant';
 
 import {createFiberFromHostInstanceForDeletion} from './ReactFiber';
 import {

commit 340bfd9393e8173adca5380e6587e1ea1a23cefa
Author: Sophie Alpert <git@sophiebits.com>
Date:   Sun Aug 26 13:40:27 2018 -0700

    Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)
    
    * Rename ReactTypeOfWork to ReactWorkTags
    
    And `type TypeOfWork` to `type WorkTag`.
    
    * Rename ReactTypeOfSideEffect too

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 8983333a30..a268b08a80 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -16,8 +16,8 @@ import type {
   HostContext,
 } from './ReactFiberHostConfig';
 
-import {HostComponent, HostText, HostRoot} from 'shared/ReactTypeOfWork';
-import {Deletion, Placement} from 'shared/ReactTypeOfSideEffect';
+import {HostComponent, HostText, HostRoot} from 'shared/ReactWorkTags';
+import {Deletion, Placement} from 'shared/ReactSideEffectTags';
 import invariant from 'shared/invariant';
 
 import {createFiberFromHostInstanceForDeletion} from './ReactFiber';

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Héctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a268b08a80..573a95f517 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit f3a14951ab9bccfd59ca977493b72321b24e50a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Feb 11 21:25:44 2019 -0800

    Partial Hydration (#14717)
    
    * Basic partial hydration test
    
    * Render comments around Suspense components
    
    We need this to be able to identify how far to skip ahead if we're not
    going to hydrate this subtree yet.
    
    * Add DehydratedSuspenseComponent type of work
    
    Will be used for Suspense boundaries that are left with their server
    rendered content intact.
    
    * Add comment node as hydratable instance type as placeholder for suspense
    
    * Skip past nodes within the Suspense boundary
    
    This lets us continue hydrating sibling nodes.
    
    * A dehydrated suspense boundary comment should be considered a sibling
    
    * Retry hydrating at offscreen pri or after ping if suspended
    
    * Enter hydration state when retrying dehydrated suspense boundary
    
    * Delete all children within a dehydrated suspense boundary when it's deleted
    
    * Delete server rendered content when props change before hydration completes
    
    * Make test internal
    
    * Wrap in act
    
    * Change SSR Fixture to use Partial Hydration
    
    This requires the enableSuspenseServerRenderer flag to be manually enabled
    for the build to work.
    
    * Changes to any parent Context forces clearing dehydrated content
    
    We mark dehydrated boundaries as having child work, since they might have
    components that read from the changed context.
    
    We check this in beginWork and if it does we treat it as if the input
    has changed (same as if props changes).
    
    * Wrap in feature flag
    
    * Treat Suspense boundaries without fallbacks as if not-boundaries
    
    These don't come into play for purposes of hydration.
    
    * Fix clearing of nested suspense boundaries
    
    * ping -> retry
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Typo
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Use didReceiveUpdate instead of manually comparing props
    
    * Leave comment for why it's ok to ignore the timeout

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 573a95f517..07647d523c 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -12,11 +12,18 @@ import type {
   Instance,
   TextInstance,
   HydratableInstance,
+  SuspenseInstance,
   Container,
   HostContext,
 } from './ReactFiberHostConfig';
 
-import {HostComponent, HostText, HostRoot} from 'shared/ReactWorkTags';
+import {
+  HostComponent,
+  HostText,
+  HostRoot,
+  SuspenseComponent,
+  DehydratedSuspenseComponent,
+} from 'shared/ReactWorkTags';
 import {Deletion, Placement} from 'shared/ReactSideEffectTags';
 import invariant from 'shared/invariant';
 
@@ -26,19 +33,24 @@ import {
   supportsHydration,
   canHydrateInstance,
   canHydrateTextInstance,
+  canHydrateSuspenseInstance,
   getNextHydratableSibling,
   getFirstHydratableChild,
   hydrateInstance,
   hydrateTextInstance,
+  getNextHydratableInstanceAfterSuspenseInstance,
   didNotMatchHydratedContainerTextInstance,
   didNotMatchHydratedTextInstance,
   didNotHydrateContainerInstance,
   didNotHydrateInstance,
   didNotFindHydratableContainerInstance,
   didNotFindHydratableContainerTextInstance,
+  didNotFindHydratableContainerSuspenseInstance,
   didNotFindHydratableInstance,
   didNotFindHydratableTextInstance,
+  didNotFindHydratableSuspenseInstance,
 } from './ReactFiberHostConfig';
+import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -58,6 +70,20 @@ function enterHydrationState(fiber: Fiber): boolean {
   return true;
 }
 
+function reenterHydrationStateFromDehydratedSuspenseInstance(
+  fiber: Fiber,
+): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+
+  const suspenseInstance = fiber.stateNode;
+  nextHydratableInstance = getNextHydratableSibling(suspenseInstance);
+  popToNextHostParent(fiber);
+  isHydrating = true;
+  return true;
+}
+
 function deleteHydratableInstance(
   returnFiber: Fiber,
   instance: HydratableInstance,
@@ -115,6 +141,9 @@ function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
             const text = fiber.pendingProps;
             didNotFindHydratableContainerTextInstance(parentContainer, text);
             break;
+          case SuspenseComponent:
+            didNotFindHydratableContainerSuspenseInstance(parentContainer);
+            break;
         }
         break;
       }
@@ -143,6 +172,13 @@ function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
               text,
             );
             break;
+          case SuspenseComponent:
+            didNotFindHydratableSuspenseInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+            );
+            break;
         }
         break;
       }
@@ -173,6 +209,18 @@ function tryHydrate(fiber, nextInstance) {
       }
       return false;
     }
+    case SuspenseComponent: {
+      if (enableSuspenseServerRenderer) {
+        const suspenseInstance = canHydrateSuspenseInstance(nextInstance);
+        if (suspenseInstance !== null) {
+          // Downgrade the tag to a dehydrated component until we've hydrated it.
+          fiber.tag = DehydratedSuspenseComponent;
+          fiber.stateNode = (suspenseInstance: SuspenseInstance);
+          return true;
+        }
+      }
+      return false;
+    }
     default:
       return false;
   }
@@ -296,12 +344,32 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
   return shouldUpdate;
 }
 
+function skipPastDehydratedSuspenseInstance(fiber: Fiber): void {
+  if (!supportsHydration) {
+    invariant(
+      false,
+      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+  let suspenseInstance = fiber.stateNode;
+  invariant(
+    suspenseInstance,
+    'Expected to have a hydrated suspense instance. ' +
+      'This error is likely caused by a bug in React. Please file an issue.',
+  );
+  nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(
+    suspenseInstance,
+  );
+}
+
 function popToNextHostParent(fiber: Fiber): void {
   let parent = fiber.return;
   while (
     parent !== null &&
     parent.tag !== HostComponent &&
-    parent.tag !== HostRoot
+    parent.tag !== HostRoot &&
+    parent.tag !== DehydratedSuspenseComponent
   ) {
     parent = parent.return;
   }
@@ -365,9 +433,11 @@ function resetHydrationState(): void {
 
 export {
   enterHydrationState,
+  reenterHydrationStateFromDehydratedSuspenseInstance,
   resetHydrationState,
   tryToClaimNextHydratableInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
+  skipPastDehydratedSuspenseInstance,
   popHydrationState,
 };

commit 6f3c8332d8b2f92784a731e6cc6a707a92495a23
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Aug 7 14:56:12 2019 -0700

    Reset hydration state after reentering (#16306)
    
    We might reenter a hydration state, when attempting to hydrate a boundary.
    We need to ensure that we reset it to not hydrating once we exit it.
    Otherwise the next sibling will still be in hydration mode.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 07647d523c..153503f044 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -51,6 +51,7 @@ import {
   didNotFindHydratableSuspenseInstance,
 } from './ReactFiberHostConfig';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
+import warning from 'shared/warning';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -58,6 +59,15 @@ let hydrationParentFiber: null | Fiber = null;
 let nextHydratableInstance: null | HydratableInstance = null;
 let isHydrating: boolean = false;
 
+function warnIfHydrating() {
+  if (__DEV__) {
+    warning(
+      !isHydrating,
+      'We should not be hydrating here. This is a bug in React. Please file a bug.',
+    );
+  }
+}
+
 function enterHydrationState(fiber: Fiber): boolean {
   if (!supportsHydration) {
     return false;
@@ -432,6 +442,7 @@ function resetHydrationState(): void {
 }
 
 export {
+  warnIfHydrating,
   enterHydrationState,
   reenterHydrationStateFromDehydratedSuspenseInstance,
   resetHydrationState,

commit 50addf4c0e411e351de7290c8c60ec775c25c8c4
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Aug 12 15:58:38 2019 -0700

    Refactor Partial Hydration (#16346)
    
    * Move dehydrated to be child of regular SuspenseComponent
    
    We now store the comment node on SuspenseState instead and that indicates
    that this SuspenseComponent is still dehydrated.
    
    We also store a child but that is only used to represent the DOM node for
    deletions and getNextHostSibling.
    
    * Move logic from DehydratedSuspenseComponent to SuspenseComponent
    
    Forked based on SuspenseState.dehydrated instead.
    
    * Retry logic for dehydrated boundary
    
    We can now simplify the logic for retrying dehydrated boundaries without
    hydrating. This is becomes simply a reconciliation against the dehydrated
    fragment which gets deleted, and the new children gets inserted.
    
    * Remove dehydrated from throw
    
    Instead we use the regular Suspense path. To save code, we attach retry
    listeners in the commit phase even though technically we don't have to.
    
    * Pop to nearest Suspense
    
    I think this is right...?
    
    * Popping hydration state should skip past the dehydrated instance
    
    * Split mount from update and special case suspended second pass
    
    The DidCapture flag isn't used consistently in the same way. We need
    further refactor for this.
    
    * Reorganize update path
    
    If we remove the dehydration status in the first pass and then do a second
    pass because we suspended, then we need to continue as if it didn't
    previously suspend. Since there is no fragment child etc.
    
    However, we must readd the deletion.
    
    * Schedule context work on the boundary and not the child
    
    * Warn for Suspense hydration in legacy mode
    
    It does a two pass render that client renders the content.
    
    * Rename DehydratedSuspenseComponent -> DehydratedFragment
    
    This now doesn't represent a suspense boundary itself. Its parent does.
    
    This Fiber represents the fragment around the dehydrated content.
    
    * Refactor returns
    
    Avoids the temporary mutable variables. I kept losing track of them.
    
    * Add a comment explaining the type.
    
    Placing it in the type since that's the central point as opposed to spread
    out.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 153503f044..4b9cdf73d5 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -16,18 +16,21 @@ import type {
   Container,
   HostContext,
 } from './ReactFiberHostConfig';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {
   HostComponent,
   HostText,
   HostRoot,
   SuspenseComponent,
-  DehydratedSuspenseComponent,
 } from 'shared/ReactWorkTags';
 import {Deletion, Placement} from 'shared/ReactSideEffectTags';
 import invariant from 'shared/invariant';
 
-import {createFiberFromHostInstanceForDeletion} from './ReactFiber';
+import {
+  createFiberFromHostInstanceForDeletion,
+  createFiberFromDehydratedFragment,
+} from './ReactFiber';
 import {
   shouldSetTextContent,
   supportsHydration,
@@ -82,12 +85,11 @@ function enterHydrationState(fiber: Fiber): boolean {
 
 function reenterHydrationStateFromDehydratedSuspenseInstance(
   fiber: Fiber,
+  suspenseInstance: SuspenseInstance,
 ): boolean {
   if (!supportsHydration) {
     return false;
   }
-
-  const suspenseInstance = fiber.stateNode;
   nextHydratableInstance = getNextHydratableSibling(suspenseInstance);
   popToNextHostParent(fiber);
   isHydrating = true;
@@ -221,11 +223,23 @@ function tryHydrate(fiber, nextInstance) {
     }
     case SuspenseComponent: {
       if (enableSuspenseServerRenderer) {
-        const suspenseInstance = canHydrateSuspenseInstance(nextInstance);
+        const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(
+          nextInstance,
+        );
         if (suspenseInstance !== null) {
-          // Downgrade the tag to a dehydrated component until we've hydrated it.
-          fiber.tag = DehydratedSuspenseComponent;
-          fiber.stateNode = (suspenseInstance: SuspenseInstance);
+          const suspenseState: SuspenseState = {
+            dehydrated: suspenseInstance,
+          };
+          fiber.memoizedState = suspenseState;
+          // Store the dehydrated fragment as a child fiber.
+          // This simplifies the code for getHostSibling and deleting nodes,
+          // since it doesn't have to consider all Suspense boundaries and
+          // check if they're dehydrated ones or not.
+          const dehydratedFragment = createFiberFromDehydratedFragment(
+            suspenseInstance,
+          );
+          dehydratedFragment.return = fiber;
+          fiber.child = dehydratedFragment;
           return true;
         }
       }
@@ -354,7 +368,9 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
   return shouldUpdate;
 }
 
-function skipPastDehydratedSuspenseInstance(fiber: Fiber): void {
+function skipPastDehydratedSuspenseInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
   if (!supportsHydration) {
     invariant(
       false,
@@ -362,15 +378,15 @@ function skipPastDehydratedSuspenseInstance(fiber: Fiber): void {
         'This error is likely caused by a bug in React. Please file an issue.',
     );
   }
-  let suspenseInstance = fiber.stateNode;
+  let suspenseState: null | SuspenseState = fiber.memoizedState;
+  let suspenseInstance: null | SuspenseInstance =
+    suspenseState !== null ? suspenseState.dehydrated : null;
   invariant(
     suspenseInstance,
     'Expected to have a hydrated suspense instance. ' +
       'This error is likely caused by a bug in React. Please file an issue.',
   );
-  nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(
-    suspenseInstance,
-  );
+  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
 }
 
 function popToNextHostParent(fiber: Fiber): void {
@@ -379,7 +395,7 @@ function popToNextHostParent(fiber: Fiber): void {
     parent !== null &&
     parent.tag !== HostComponent &&
     parent.tag !== HostRoot &&
-    parent.tag !== DehydratedSuspenseComponent
+    parent.tag !== SuspenseComponent
   ) {
     parent = parent.return;
   }
@@ -425,9 +441,13 @@ function popHydrationState(fiber: Fiber): boolean {
   }
 
   popToNextHostParent(fiber);
-  nextHydratableInstance = hydrationParentFiber
-    ? getNextHydratableSibling(fiber.stateNode)
-    : null;
+  if (fiber.tag === SuspenseComponent) {
+    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
+  } else {
+    nextHydratableInstance = hydrationParentFiber
+      ? getNextHydratableSibling(fiber.stateNode)
+      : null;
+  }
   return true;
 }
 
@@ -449,6 +469,5 @@ export {
   tryToClaimNextHydratableInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
-  skipPastDehydratedSuspenseInstance,
   popHydrationState,
 };

commit 6fbe630549de1ea7d2c34752880459f854c4440d
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Aug 13 18:26:21 2019 -0700

    [Partial Hydration] Attempt hydration at a higher pri first if props/context changes (#16352)
    
    * Test that we can suspend updates while waiting to hydrate
    
    * Attempt hydration at a higher pri first if props/context changes
    
    * Retrying a dehydrated boundary pings at the earliest forced time
    
    This might quickly become an already expired time.
    
    * Mark the render as delayed if we have to retry
    
    This allows the suspense config to kick in and we can wait for much longer
    before we're forced to give up on hydrating.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 4b9cdf73d5..30a3c20dd6 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -55,6 +55,7 @@ import {
 } from './ReactFiberHostConfig';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 import warning from 'shared/warning';
+import {Never} from './ReactFiberExpirationTime';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -229,6 +230,7 @@ function tryHydrate(fiber, nextInstance) {
         if (suspenseInstance !== null) {
           const suspenseState: SuspenseState = {
             dehydrated: suspenseInstance,
+            retryTime: Never,
           };
           fiber.memoizedState = suspenseState;
           // Store the dehydrated fragment as a child fiber.

commit 8d7c733f1fdad55d0f10947931b378edc5e039ad
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Sep 5 08:51:31 2019 -0700

    [Partial Hydration] Don't invoke listeners on parent of dehydrated event target (#16591)
    
    * Don't invoke listeners on parent of dehydrated event target
    
    * Move Suspense boundary check to getClosestInstanceFromNode
    
    Now getClosestInstanceFromNode can return either a host component,
    host text component or suspense component when the suspense
    component is dehydrated.
    
    We then use that to ignore events on a suspense component.
    
    * Attach the HostRoot fiber to the DOM container
    
    This lets us detect if an event happens on this root's subtree before it
    has rendered something.
    
    * Add todo
    
    The approach of checking isFiberMounted answers if we might be in an
    in-progress hydration but it doesn't answer which root or boundary
    might be in-progress so we don't know what to wait for.
    
    This needs some refactoring.
    
    * Refactor isFiberMountedImpl to getNearestMountedFiber
    
    We'll need the nearest boundary for event replaying so this prepares for
    that.
    
    This surfaced an issue that we attach Hydrating tag on the root but normally
    this (and Placement) is attached on the child. This surfaced an issue
    that this can lead to both Placement and Hydrating effects which is not
    supported so we need to ensure that we only ever use one or the other.
    
    * Add todo for bug I spotted
    
    * Cache tags
    
    * Check the ContainerInstanceKey before the InstanceKey
    
    The container is inside the instance, so we must find it before the
    instance, since otherwise we'll miss it.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 30a3c20dd6..8ae0f7b851 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -24,7 +24,7 @@ import {
   HostRoot,
   SuspenseComponent,
 } from 'shared/ReactWorkTags';
-import {Deletion, Placement} from 'shared/ReactSideEffectTags';
+import {Deletion, Placement, Hydrating} from 'shared/ReactSideEffectTags';
 import invariant from 'shared/invariant';
 
 import {
@@ -41,6 +41,7 @@ import {
   getFirstHydratableChild,
   hydrateInstance,
   hydrateTextInstance,
+  hydrateSuspenseInstance,
   getNextHydratableInstanceAfterSuspenseInstance,
   didNotMatchHydratedContainerTextInstance,
   didNotMatchHydratedTextInstance,
@@ -139,7 +140,7 @@ function deleteHydratableInstance(
 }
 
 function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
-  fiber.effectTag |= Placement;
+  fiber.effectTag = (fiber.effectTag & ~Hydrating) | Placement;
   if (__DEV__) {
     switch (returnFiber.tag) {
       case HostRoot: {
@@ -370,6 +371,26 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
   return shouldUpdate;
 }
 
+function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
+  if (!supportsHydration) {
+    invariant(
+      false,
+      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  let suspenseState: null | SuspenseState = fiber.memoizedState;
+  let suspenseInstance: null | SuspenseInstance =
+    suspenseState !== null ? suspenseState.dehydrated : null;
+  invariant(
+    suspenseInstance,
+    'Expected to have a hydrated suspense instance. ' +
+      'This error is likely caused by a bug in React. Please file an issue.',
+  );
+  hydrateSuspenseInstance(suspenseInstance, fiber);
+}
+
 function skipPastDehydratedSuspenseInstance(
   fiber: Fiber,
 ): null | HydratableInstance {
@@ -471,5 +492,6 @@ export {
   tryToClaimNextHydratableInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
+  prepareToHydrateHostSuspenseInstance,
   popHydrationState,
 };

commit c8dc7a926e9e5ec0dcf779e91a3730d4069a22a1
Author: Luna Ruan <lunaris.ruan@gmail.com>
Date:   Thu Sep 26 14:47:01 2019 -0700

    expose isHydrating (#16909)
    
    expose isHydrating for FB

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 8ae0f7b851..018a80886e 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -484,6 +484,10 @@ function resetHydrationState(): void {
   isHydrating = false;
 }
 
+function getIsHydrating(): boolean {
+  return isHydrating;
+}
+
 export {
   warnIfHydrating,
   enterHydrationState,
@@ -494,4 +498,5 @@ export {
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
+  getIsHydrating,
 };

commit d8a76ad5804197108f18b988f6d13c767ab41387
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Sep 28 10:43:53 2019 -0700

    Allow Suspense Mismatch on the Client to Silently Proceed (#16943)
    
    * Regression test: Suspense + hydration + legacy
    
    * Allow Suspense Mismatch on the Client to Silently Proceed
    
    This fixes but isn't actually the semantics that we want this case to have.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 018a80886e..61f007daca 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -404,11 +404,10 @@ function skipPastDehydratedSuspenseInstance(
   let suspenseState: null | SuspenseState = fiber.memoizedState;
   let suspenseInstance: null | SuspenseInstance =
     suspenseState !== null ? suspenseState.dehydrated : null;
-  invariant(
-    suspenseInstance,
-    'Expected to have a hydrated suspense instance. ' +
-      'This error is likely caused by a bug in React. Please file an issue.',
-  );
+  if (suspenseInstance === null) {
+    // This Suspense boundary was hydrated without a match.
+    return nextHydratableInstance;
+  }
   return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
 }
 

commit ed5f010ae51db1544ce92e1a5105e870b5a5098e
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Oct 16 16:23:12 2019 -0700

    Client render Suspense content if there's no boundary match (#16945)
    
    Without the enableSuspenseServerRenderer flag there will never be a boundary match. Also when it is enabled, there might not be a boundary match if something was conditionally rendered by mistake.
    
    With this PR it will now client render the content of a Suspense boundary in that case and issue a DEV only hydration warning. This is the only sound semantics for this case.
    
    Unfortunately, landing this will once again break #16938. It will be less bad though because at least it'll just work by client rendering the content instead of hydrating and issue a DEV only warning.
    
    However, we must land this before enabling the enableSuspenseServerRenderer flag since it does this anyway.
    
    I did notice that we special case fallback={undefined} due to our unfortunate semantics for that. So technically a workaround that works is actually setting the fallback to undefined on the server and during hydration. Then flip it on only after hydration. That could be a workaround if you want to be able to have a Suspense boundary work only after hydration for some reason.
    
    It's kind of unfortunate but at least those semantics are internally consistent. So I added a test for that.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 61f007daca..018a80886e 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -404,10 +404,11 @@ function skipPastDehydratedSuspenseInstance(
   let suspenseState: null | SuspenseState = fiber.memoizedState;
   let suspenseInstance: null | SuspenseInstance =
     suspenseState !== null ? suspenseState.dehydrated : null;
-  if (suspenseInstance === null) {
-    // This Suspense boundary was hydrated without a match.
-    return nextHydratableInstance;
-  }
+  invariant(
+    suspenseInstance,
+    'Expected to have a hydrated suspense instance. ' +
+      'This error is likely caused by a bug in React. Please file an issue.',
+  );
   return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
 }
 

commit 9ac42dd074c42b66ecc0334b75200b1d2989f892
Author: Laura buns <walaura@fb.com>
Date:   Wed Dec 11 03:28:14 2019 +0000

    Remove the condition argument from warning() (#17568)
    
    * prep for codemod
    
    * prep warnings
    
    * rename lint rules
    
    * codemod for ifs
    
    * shim www functions
    
    * Handle more cases in the transform
    
    * Thanks De Morgan
    
    * Run the codemod
    
    * Delete the transform
    
    * Fix up confusing conditions manually
    
    * Fix up www shims to match expected API
    
    * Also check for low-pri warning in the lint rule

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 018a80886e..d601d50182 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -66,10 +66,11 @@ let isHydrating: boolean = false;
 
 function warnIfHydrating() {
   if (__DEV__) {
-    warning(
-      !isHydrating,
-      'We should not be hydrating here. This is a bug in React. Please file a bug.',
-    );
+    if (isHydrating) {
+      warning(
+        'We should not be hydrating here. This is a bug in React. Please file a bug.',
+      );
+    }
   }
 }
 

commit 0cf22a56a18790ef34c71bef14f64695c0498619
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat Dec 14 18:09:25 2019 +0000

    Use console directly instead of warning() modules (#17599)
    
    * Replace all warning/lowPriWarning with console calls
    
    * Replace console.warn/error with a custom wrapper at build time
    
    * Fail the build for console.error/warn() where we can't read the stack

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index d601d50182..0cc2c41ff6 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -55,7 +55,6 @@ import {
   didNotFindHydratableSuspenseInstance,
 } from './ReactFiberHostConfig';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
-import warning from 'shared/warning';
 import {Never} from './ReactFiberExpirationTime';
 
 // The deepest Fiber on the stack involved in a hydration context.
@@ -67,7 +66,7 @@ let isHydrating: boolean = false;
 function warnIfHydrating() {
   if (__DEV__) {
     if (isHydrating) {
-      warning(
+      console.error(
         'We should not be hydrating here. This is a bug in React. Please file a bug.',
       );
     }

commit a607ea4c424356707302da998bf13e9bf1b55007
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Feb 12 01:01:29 2020 +0000

    Remove getIsHydrating (#18019)

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 0cc2c41ff6..a48391d204 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -484,10 +484,6 @@ function resetHydrationState(): void {
   isHydrating = false;
 }
 
-function getIsHydrating(): boolean {
-  return isHydrating;
-}
-
 export {
   warnIfHydrating,
   enterHydrationState,
@@ -498,5 +494,4 @@ export {
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
-  getIsHydrating,
 };

commit c5d2fc7127654e43de59fff865b74765a103c4a5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Mar 21 15:22:01 2020 -0700

    Move some files out of /shared and rename to upper case (#18363)
    
    * Rename lower case isomorphic default exports modules to upper case named exports
    
    We're somewhat inconsistent here between e.g. ReactLazy and memo.
    
    Let's pick one.
    
    This also moves the responder, fundamental, scope creators from shared
    since they're isomorphic and same as the other creators.
    
    * Move some files that are specific to the react-reconciler from shared
    
    Individual renderers are allowed to deep require into the reconciler.
    
    * Move files specific to react-dom from shared
    
    react-interactions is right now dom specific (it wasn't before) so we can
    type check it together with other dom stuff. Avoids the need for
    a shared ReactDOMTypes to be checked by RN for example.
    
    * Move ReactWorkTags to the reconciler
    
    * Move createPortal to export from reconciler
    
    Otherwise Noop can't access it since it's not allowed deep requires.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a48391d204..76add94ea6 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -23,8 +23,8 @@ import {
   HostText,
   HostRoot,
   SuspenseComponent,
-} from 'shared/ReactWorkTags';
-import {Deletion, Placement, Hydrating} from 'shared/ReactSideEffectTags';
+} from './ReactWorkTags';
+import {Deletion, Placement, Hydrating} from './ReactSideEffectTags';
 import invariant from 'shared/invariant';
 
 import {

commit d7382b6c43b63ce15ce091cf13db8cd1f3c4b7ae
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 30 11:25:04 2020 -0700

    Bugfix: Do not unhide a suspended tree without finishing the suspended update (#18411)
    
    * Bugfix: Suspended update must finish to unhide
    
    When we commit a fallback, we cannot unhide the content without including
    the level that originally suspended. That's because the work at level
    outside the boundary (i.e. everything that wasn't hidden during that
    render) already committed.
    
    * Test unblocking with a high-pri update

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 76add94ea6..fbf852e1bb 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -55,7 +55,7 @@ import {
   didNotFindHydratableSuspenseInstance,
 } from './ReactFiberHostConfig';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
-import {Never} from './ReactFiberExpirationTime';
+import {Never, NoWork} from './ReactFiberExpirationTime';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -231,6 +231,7 @@ function tryHydrate(fiber, nextInstance) {
         if (suspenseInstance !== null) {
           const suspenseState: SuspenseState = {
             dehydrated: suspenseInstance,
+            baseTime: NoWork,
             retryTime: Never,
           };
           fiber.memoizedState = suspenseState;

commit 3e94bce765d355d74f6a60feb4addb6d196e3482
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 1 12:35:52 2020 -0700

    Enable prefer-const lint rules (#18451)
    
    * Enable prefer-const rule
    
    Stylistically I don't like this but Closure Compiler takes advantage of
    this information.
    
    * Auto-fix lints
    
    * Manually fix the remaining callsites

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index fbf852e1bb..365bfb48de 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -381,8 +381,8 @@ function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
     );
   }
 
-  let suspenseState: null | SuspenseState = fiber.memoizedState;
-  let suspenseInstance: null | SuspenseInstance =
+  const suspenseState: null | SuspenseState = fiber.memoizedState;
+  const suspenseInstance: null | SuspenseInstance =
     suspenseState !== null ? suspenseState.dehydrated : null;
   invariant(
     suspenseInstance,
@@ -402,8 +402,8 @@ function skipPastDehydratedSuspenseInstance(
         'This error is likely caused by a bug in React. Please file an issue.',
     );
   }
-  let suspenseState: null | SuspenseState = fiber.memoizedState;
-  let suspenseInstance: null | SuspenseInstance =
+  const suspenseState: null | SuspenseState = fiber.memoizedState;
+  const suspenseInstance: null | SuspenseInstance =
     suspenseState !== null ? suspenseState.dehydrated : null;
   invariant(
     suspenseInstance,

commit 3278d242184a13add3f25f683b77ef9a6a2305f3
Author: Luna Ruan <luna@fb.com>
Date:   Mon Apr 6 17:17:27 2020 -0700

    Add useOpaqueIdentifier Hook (#17322)
    
    * Add useOpaqueIdentifier Hook
    
    We currently use unique IDs in a lot of places. Examples are:
      * `<label for="ID">`
      * `aria-labelledby`
    
    This can cause some issues:
      1. If we server side render and then hydrate, this could cause an
         hydration ID mismatch
      2. If we server side render one part of the page and client side
         render another part of the page, the ID for one part could be
         different than the ID for another part even though they are
         supposed to be the same
      3. If we conditionally render something with an ID ,  this might also
         cause an ID mismatch because the ID will be different on other
         parts of the page
    
    This PR creates a new hook `useUniqueId` that generates a different
    unique ID based on whether the hook was called on the server or client.
    If the hook is called during hydration, it generates an opaque object
    that will rerender the hook so that the IDs match.
    
    Co-authored-by: Andrew Clark <git@andrewclark.io>

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 365bfb48de..7f06c4d0ed 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -485,9 +485,14 @@ function resetHydrationState(): void {
   isHydrating = false;
 }
 
+function getIsHydrating(): boolean {
+  return isHydrating;
+}
+
 export {
   warnIfHydrating,
   enterHydrationState,
+  getIsHydrating,
   reenterHydrationStateFromDehydratedSuspenseInstance,
   resetHydrationState,
   tryToClaimNextHydratableInstance,

commit d686f3f16a796025ce32cfb431b70eef6de1934e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 19:44:52 2020 -0700

    Add `.old` prefix to reconciler modules

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
deleted file mode 100644
index 7f06c4d0ed..0000000000
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ /dev/null
@@ -1,503 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- */
-
-import type {Fiber} from './ReactFiber';
-import type {
-  Instance,
-  TextInstance,
-  HydratableInstance,
-  SuspenseInstance,
-  Container,
-  HostContext,
-} from './ReactFiberHostConfig';
-import type {SuspenseState} from './ReactFiberSuspenseComponent';
-
-import {
-  HostComponent,
-  HostText,
-  HostRoot,
-  SuspenseComponent,
-} from './ReactWorkTags';
-import {Deletion, Placement, Hydrating} from './ReactSideEffectTags';
-import invariant from 'shared/invariant';
-
-import {
-  createFiberFromHostInstanceForDeletion,
-  createFiberFromDehydratedFragment,
-} from './ReactFiber';
-import {
-  shouldSetTextContent,
-  supportsHydration,
-  canHydrateInstance,
-  canHydrateTextInstance,
-  canHydrateSuspenseInstance,
-  getNextHydratableSibling,
-  getFirstHydratableChild,
-  hydrateInstance,
-  hydrateTextInstance,
-  hydrateSuspenseInstance,
-  getNextHydratableInstanceAfterSuspenseInstance,
-  didNotMatchHydratedContainerTextInstance,
-  didNotMatchHydratedTextInstance,
-  didNotHydrateContainerInstance,
-  didNotHydrateInstance,
-  didNotFindHydratableContainerInstance,
-  didNotFindHydratableContainerTextInstance,
-  didNotFindHydratableContainerSuspenseInstance,
-  didNotFindHydratableInstance,
-  didNotFindHydratableTextInstance,
-  didNotFindHydratableSuspenseInstance,
-} from './ReactFiberHostConfig';
-import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
-import {Never, NoWork} from './ReactFiberExpirationTime';
-
-// The deepest Fiber on the stack involved in a hydration context.
-// This may have been an insertion or a hydration.
-let hydrationParentFiber: null | Fiber = null;
-let nextHydratableInstance: null | HydratableInstance = null;
-let isHydrating: boolean = false;
-
-function warnIfHydrating() {
-  if (__DEV__) {
-    if (isHydrating) {
-      console.error(
-        'We should not be hydrating here. This is a bug in React. Please file a bug.',
-      );
-    }
-  }
-}
-
-function enterHydrationState(fiber: Fiber): boolean {
-  if (!supportsHydration) {
-    return false;
-  }
-
-  const parentInstance = fiber.stateNode.containerInfo;
-  nextHydratableInstance = getFirstHydratableChild(parentInstance);
-  hydrationParentFiber = fiber;
-  isHydrating = true;
-  return true;
-}
-
-function reenterHydrationStateFromDehydratedSuspenseInstance(
-  fiber: Fiber,
-  suspenseInstance: SuspenseInstance,
-): boolean {
-  if (!supportsHydration) {
-    return false;
-  }
-  nextHydratableInstance = getNextHydratableSibling(suspenseInstance);
-  popToNextHostParent(fiber);
-  isHydrating = true;
-  return true;
-}
-
-function deleteHydratableInstance(
-  returnFiber: Fiber,
-  instance: HydratableInstance,
-) {
-  if (__DEV__) {
-    switch (returnFiber.tag) {
-      case HostRoot:
-        didNotHydrateContainerInstance(
-          returnFiber.stateNode.containerInfo,
-          instance,
-        );
-        break;
-      case HostComponent:
-        didNotHydrateInstance(
-          returnFiber.type,
-          returnFiber.memoizedProps,
-          returnFiber.stateNode,
-          instance,
-        );
-        break;
-    }
-  }
-
-  const childToDelete = createFiberFromHostInstanceForDeletion();
-  childToDelete.stateNode = instance;
-  childToDelete.return = returnFiber;
-  childToDelete.effectTag = Deletion;
-
-  // This might seem like it belongs on progressedFirstDeletion. However,
-  // these children are not part of the reconciliation list of children.
-  // Even if we abort and rereconcile the children, that will try to hydrate
-  // again and the nodes are still in the host tree so these will be
-  // recreated.
-  if (returnFiber.lastEffect !== null) {
-    returnFiber.lastEffect.nextEffect = childToDelete;
-    returnFiber.lastEffect = childToDelete;
-  } else {
-    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
-  }
-}
-
-function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
-  fiber.effectTag = (fiber.effectTag & ~Hydrating) | Placement;
-  if (__DEV__) {
-    switch (returnFiber.tag) {
-      case HostRoot: {
-        const parentContainer = returnFiber.stateNode.containerInfo;
-        switch (fiber.tag) {
-          case HostComponent:
-            const type = fiber.type;
-            const props = fiber.pendingProps;
-            didNotFindHydratableContainerInstance(parentContainer, type, props);
-            break;
-          case HostText:
-            const text = fiber.pendingProps;
-            didNotFindHydratableContainerTextInstance(parentContainer, text);
-            break;
-          case SuspenseComponent:
-            didNotFindHydratableContainerSuspenseInstance(parentContainer);
-            break;
-        }
-        break;
-      }
-      case HostComponent: {
-        const parentType = returnFiber.type;
-        const parentProps = returnFiber.memoizedProps;
-        const parentInstance = returnFiber.stateNode;
-        switch (fiber.tag) {
-          case HostComponent:
-            const type = fiber.type;
-            const props = fiber.pendingProps;
-            didNotFindHydratableInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-              type,
-              props,
-            );
-            break;
-          case HostText:
-            const text = fiber.pendingProps;
-            didNotFindHydratableTextInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-              text,
-            );
-            break;
-          case SuspenseComponent:
-            didNotFindHydratableSuspenseInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-            );
-            break;
-        }
-        break;
-      }
-      default:
-        return;
-    }
-  }
-}
-
-function tryHydrate(fiber, nextInstance) {
-  switch (fiber.tag) {
-    case HostComponent: {
-      const type = fiber.type;
-      const props = fiber.pendingProps;
-      const instance = canHydrateInstance(nextInstance, type, props);
-      if (instance !== null) {
-        fiber.stateNode = (instance: Instance);
-        return true;
-      }
-      return false;
-    }
-    case HostText: {
-      const text = fiber.pendingProps;
-      const textInstance = canHydrateTextInstance(nextInstance, text);
-      if (textInstance !== null) {
-        fiber.stateNode = (textInstance: TextInstance);
-        return true;
-      }
-      return false;
-    }
-    case SuspenseComponent: {
-      if (enableSuspenseServerRenderer) {
-        const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(
-          nextInstance,
-        );
-        if (suspenseInstance !== null) {
-          const suspenseState: SuspenseState = {
-            dehydrated: suspenseInstance,
-            baseTime: NoWork,
-            retryTime: Never,
-          };
-          fiber.memoizedState = suspenseState;
-          // Store the dehydrated fragment as a child fiber.
-          // This simplifies the code for getHostSibling and deleting nodes,
-          // since it doesn't have to consider all Suspense boundaries and
-          // check if they're dehydrated ones or not.
-          const dehydratedFragment = createFiberFromDehydratedFragment(
-            suspenseInstance,
-          );
-          dehydratedFragment.return = fiber;
-          fiber.child = dehydratedFragment;
-          return true;
-        }
-      }
-      return false;
-    }
-    default:
-      return false;
-  }
-}
-
-function tryToClaimNextHydratableInstance(fiber: Fiber): void {
-  if (!isHydrating) {
-    return;
-  }
-  let nextInstance = nextHydratableInstance;
-  if (!nextInstance) {
-    // Nothing to hydrate. Make it an insertion.
-    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-    isHydrating = false;
-    hydrationParentFiber = fiber;
-    return;
-  }
-  const firstAttemptedInstance = nextInstance;
-  if (!tryHydrate(fiber, nextInstance)) {
-    // If we can't hydrate this instance let's try the next one.
-    // We use this as a heuristic. It's based on intuition and not data so it
-    // might be flawed or unnecessary.
-    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
-    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
-      // Nothing to hydrate. Make it an insertion.
-      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-      isHydrating = false;
-      hydrationParentFiber = fiber;
-      return;
-    }
-    // We matched the next one, we'll now assume that the first one was
-    // superfluous and we'll delete it. Since we can't eagerly delete it
-    // we'll have to schedule a deletion. To do that, this node needs a dummy
-    // fiber associated with it.
-    deleteHydratableInstance(
-      (hydrationParentFiber: any),
-      firstAttemptedInstance,
-    );
-  }
-  hydrationParentFiber = fiber;
-  nextHydratableInstance = getFirstHydratableChild((nextInstance: any));
-}
-
-function prepareToHydrateHostInstance(
-  fiber: Fiber,
-  rootContainerInstance: Container,
-  hostContext: HostContext,
-): boolean {
-  if (!supportsHydration) {
-    invariant(
-      false,
-      'Expected prepareToHydrateHostInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-
-  const instance: Instance = fiber.stateNode;
-  const updatePayload = hydrateInstance(
-    instance,
-    fiber.type,
-    fiber.memoizedProps,
-    rootContainerInstance,
-    hostContext,
-    fiber,
-  );
-  // TODO: Type this specific to this type of component.
-  fiber.updateQueue = (updatePayload: any);
-  // If the update payload indicates that there is a change or if there
-  // is a new ref we mark this as an update.
-  if (updatePayload !== null) {
-    return true;
-  }
-  return false;
-}
-
-function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
-  if (!supportsHydration) {
-    invariant(
-      false,
-      'Expected prepareToHydrateHostTextInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-
-  const textInstance: TextInstance = fiber.stateNode;
-  const textContent: string = fiber.memoizedProps;
-  const shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
-  if (__DEV__) {
-    if (shouldUpdate) {
-      // We assume that prepareToHydrateHostTextInstance is called in a context where the
-      // hydration parent is the parent host component of this host text.
-      const returnFiber = hydrationParentFiber;
-      if (returnFiber !== null) {
-        switch (returnFiber.tag) {
-          case HostRoot: {
-            const parentContainer = returnFiber.stateNode.containerInfo;
-            didNotMatchHydratedContainerTextInstance(
-              parentContainer,
-              textInstance,
-              textContent,
-            );
-            break;
-          }
-          case HostComponent: {
-            const parentType = returnFiber.type;
-            const parentProps = returnFiber.memoizedProps;
-            const parentInstance = returnFiber.stateNode;
-            didNotMatchHydratedTextInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-              textInstance,
-              textContent,
-            );
-            break;
-          }
-        }
-      }
-    }
-  }
-  return shouldUpdate;
-}
-
-function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
-  if (!supportsHydration) {
-    invariant(
-      false,
-      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-
-  const suspenseState: null | SuspenseState = fiber.memoizedState;
-  const suspenseInstance: null | SuspenseInstance =
-    suspenseState !== null ? suspenseState.dehydrated : null;
-  invariant(
-    suspenseInstance,
-    'Expected to have a hydrated suspense instance. ' +
-      'This error is likely caused by a bug in React. Please file an issue.',
-  );
-  hydrateSuspenseInstance(suspenseInstance, fiber);
-}
-
-function skipPastDehydratedSuspenseInstance(
-  fiber: Fiber,
-): null | HydratableInstance {
-  if (!supportsHydration) {
-    invariant(
-      false,
-      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +
-        'This error is likely caused by a bug in React. Please file an issue.',
-    );
-  }
-  const suspenseState: null | SuspenseState = fiber.memoizedState;
-  const suspenseInstance: null | SuspenseInstance =
-    suspenseState !== null ? suspenseState.dehydrated : null;
-  invariant(
-    suspenseInstance,
-    'Expected to have a hydrated suspense instance. ' +
-      'This error is likely caused by a bug in React. Please file an issue.',
-  );
-  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
-}
-
-function popToNextHostParent(fiber: Fiber): void {
-  let parent = fiber.return;
-  while (
-    parent !== null &&
-    parent.tag !== HostComponent &&
-    parent.tag !== HostRoot &&
-    parent.tag !== SuspenseComponent
-  ) {
-    parent = parent.return;
-  }
-  hydrationParentFiber = parent;
-}
-
-function popHydrationState(fiber: Fiber): boolean {
-  if (!supportsHydration) {
-    return false;
-  }
-  if (fiber !== hydrationParentFiber) {
-    // We're deeper than the current hydration context, inside an inserted
-    // tree.
-    return false;
-  }
-  if (!isHydrating) {
-    // If we're not currently hydrating but we're in a hydration context, then
-    // we were an insertion and now need to pop up reenter hydration of our
-    // siblings.
-    popToNextHostParent(fiber);
-    isHydrating = true;
-    return false;
-  }
-
-  const type = fiber.type;
-
-  // If we have any remaining hydratable nodes, we need to delete them now.
-  // We only do this deeper than head and body since they tend to have random
-  // other nodes in them. We also ignore components with pure text content in
-  // side of them.
-  // TODO: Better heuristic.
-  if (
-    fiber.tag !== HostComponent ||
-    (type !== 'head' &&
-      type !== 'body' &&
-      !shouldSetTextContent(type, fiber.memoizedProps))
-  ) {
-    let nextInstance = nextHydratableInstance;
-    while (nextInstance) {
-      deleteHydratableInstance(fiber, nextInstance);
-      nextInstance = getNextHydratableSibling(nextInstance);
-    }
-  }
-
-  popToNextHostParent(fiber);
-  if (fiber.tag === SuspenseComponent) {
-    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
-  } else {
-    nextHydratableInstance = hydrationParentFiber
-      ? getNextHydratableSibling(fiber.stateNode)
-      : null;
-  }
-  return true;
-}
-
-function resetHydrationState(): void {
-  if (!supportsHydration) {
-    return;
-  }
-
-  hydrationParentFiber = null;
-  nextHydratableInstance = null;
-  isHydrating = false;
-}
-
-function getIsHydrating(): boolean {
-  return isHydrating;
-}
-
-export {
-  warnIfHydrating,
-  enterHydrationState,
-  getIsHydrating,
-  reenterHydrationStateFromDehydratedSuspenseInstance,
-  resetHydrationState,
-  tryToClaimNextHydratableInstance,
-  prepareToHydrateHostInstance,
-  prepareToHydrateHostTextInstance,
-  prepareToHydrateHostSuspenseInstance,
-  popHydrationState,
-};

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
new file mode 100644
index 0000000000..4b5bc198a5
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -0,0 +1,768 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {Fiber} from './ReactInternalTypes';
+import {NoMode, ConcurrentMode} from './ReactTypeOfMode';
+import type {
+  Instance,
+  TextInstance,
+  HydratableInstance,
+  SuspenseInstance,
+  Container,
+  HostContext,
+} from './ReactFiberHostConfig';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
+import type {TreeContext} from './ReactFiberTreeContext';
+import type {CapturedValue} from './ReactCapturedValue';
+
+import {
+  HostComponent,
+  HostSingleton,
+  HostText,
+  HostRoot,
+  SuspenseComponent,
+} from './ReactWorkTags';
+import {
+  ChildDeletion,
+  Placement,
+  Hydrating,
+  NoFlags,
+  DidCapture,
+} from './ReactFiberFlags';
+import {enableHostSingletons, enableFloat} from 'shared/ReactFeatureFlags';
+
+import {
+  createFiberFromHostInstanceForDeletion,
+  createFiberFromDehydratedFragment,
+} from './ReactFiber';
+import {
+  shouldSetTextContent,
+  supportsHydration,
+  supportsSingletons,
+  isHydratable,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  canHydrateSuspenseInstance,
+  getNextHydratableSibling,
+  getFirstHydratableChild,
+  getFirstHydratableChildWithinContainer,
+  getFirstHydratableChildWithinSuspenseInstance,
+  hydrateInstance,
+  hydrateTextInstance,
+  hydrateSuspenseInstance,
+  getNextHydratableInstanceAfterSuspenseInstance,
+  shouldDeleteUnhydratedTailInstances,
+  didNotMatchHydratedContainerTextInstance,
+  didNotMatchHydratedTextInstance,
+  didNotHydrateInstanceWithinContainer,
+  didNotHydrateInstanceWithinSuspenseInstance,
+  didNotHydrateInstance,
+  didNotFindHydratableInstanceWithinContainer,
+  didNotFindHydratableTextInstanceWithinContainer,
+  didNotFindHydratableSuspenseInstanceWithinContainer,
+  didNotFindHydratableInstanceWithinSuspenseInstance,
+  didNotFindHydratableTextInstanceWithinSuspenseInstance,
+  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,
+  didNotFindHydratableInstance,
+  didNotFindHydratableTextInstance,
+  didNotFindHydratableSuspenseInstance,
+  resolveSingletonInstance,
+} from './ReactFiberHostConfig';
+import {OffscreenLane} from './ReactFiberLane';
+import {
+  getSuspendedTreeContext,
+  restoreSuspendedTreeContext,
+} from './ReactFiberTreeContext';
+import {queueRecoverableErrors} from './ReactFiberWorkLoop';
+import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
+
+// The deepest Fiber on the stack involved in a hydration context.
+// This may have been an insertion or a hydration.
+let hydrationParentFiber: null | Fiber = null;
+let nextHydratableInstance: null | HydratableInstance = null;
+let isHydrating: boolean = false;
+
+// This flag allows for warning supression when we expect there to be mismatches
+// due to earlier mismatches or a suspended fiber.
+let didSuspendOrErrorDEV: boolean = false;
+
+// Hydration errors that were thrown inside this boundary
+let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
+
+function warnIfHydrating() {
+  if (__DEV__) {
+    if (isHydrating) {
+      console.error(
+        'We should not be hydrating here. This is a bug in React. Please file a bug.',
+      );
+    }
+  }
+}
+
+export function markDidThrowWhileHydratingDEV() {
+  if (__DEV__) {
+    didSuspendOrErrorDEV = true;
+  }
+}
+
+export function didSuspendOrErrorWhileHydratingDEV(): boolean {
+  if (__DEV__) {
+    return didSuspendOrErrorDEV;
+  }
+  return false;
+}
+
+function enterHydrationState(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+
+  const parentInstance: Container = fiber.stateNode.containerInfo;
+  nextHydratableInstance = getFirstHydratableChildWithinContainer(
+    parentInstance,
+  );
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  return true;
+}
+
+function reenterHydrationStateFromDehydratedSuspenseInstance(
+  fiber: Fiber,
+  suspenseInstance: SuspenseInstance,
+  treeContext: TreeContext | null,
+): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(
+    suspenseInstance,
+  );
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  if (treeContext !== null) {
+    restoreSuspendedTreeContext(fiber, treeContext);
+  }
+  return true;
+}
+
+function warnUnhydratedInstance(
+  returnFiber: Fiber,
+  instance: HydratableInstance,
+) {
+  if (__DEV__) {
+    switch (returnFiber.tag) {
+      case HostRoot: {
+        didNotHydrateInstanceWithinContainer(
+          returnFiber.stateNode.containerInfo,
+          instance,
+        );
+        break;
+      }
+      case HostSingleton:
+      case HostComponent: {
+        const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
+        didNotHydrateInstance(
+          returnFiber.type,
+          returnFiber.memoizedProps,
+          returnFiber.stateNode,
+          instance,
+          // TODO: Delete this argument when we remove the legacy root API.
+          isConcurrentMode,
+        );
+        break;
+      }
+      case SuspenseComponent: {
+        const suspenseState: SuspenseState = returnFiber.memoizedState;
+        if (suspenseState.dehydrated !== null)
+          didNotHydrateInstanceWithinSuspenseInstance(
+            suspenseState.dehydrated,
+            instance,
+          );
+        break;
+      }
+    }
+  }
+}
+
+function deleteHydratableInstance(
+  returnFiber: Fiber,
+  instance: HydratableInstance,
+) {
+  warnUnhydratedInstance(returnFiber, instance);
+  const childToDelete = createFiberFromHostInstanceForDeletion();
+  childToDelete.stateNode = instance;
+  childToDelete.return = returnFiber;
+
+  const deletions = returnFiber.deletions;
+  if (deletions === null) {
+    returnFiber.deletions = [childToDelete];
+    returnFiber.flags |= ChildDeletion;
+  } else {
+    deletions.push(childToDelete);
+  }
+}
+
+function warnNonhydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+  if (__DEV__) {
+    if (didSuspendOrErrorDEV) {
+      // Inside a boundary that already suspended. We're currently rendering the
+      // siblings of a suspended node. The mismatch may be due to the missing
+      // data, so it's probably a false positive.
+      return;
+    }
+
+    switch (returnFiber.tag) {
+      case HostRoot: {
+        const parentContainer = returnFiber.stateNode.containerInfo;
+        switch (fiber.tag) {
+          case HostSingleton:
+          case HostComponent:
+            const type = fiber.type;
+            const props = fiber.pendingProps;
+            didNotFindHydratableInstanceWithinContainer(
+              parentContainer,
+              type,
+              props,
+            );
+            break;
+          case HostText:
+            const text = fiber.pendingProps;
+            didNotFindHydratableTextInstanceWithinContainer(
+              parentContainer,
+              text,
+            );
+            break;
+          case SuspenseComponent:
+            didNotFindHydratableSuspenseInstanceWithinContainer(
+              parentContainer,
+            );
+            break;
+        }
+        break;
+      }
+      case HostSingleton:
+      case HostComponent: {
+        const parentType = returnFiber.type;
+        const parentProps = returnFiber.memoizedProps;
+        const parentInstance = returnFiber.stateNode;
+        switch (fiber.tag) {
+          case HostSingleton:
+          case HostComponent: {
+            const type = fiber.type;
+            const props = fiber.pendingProps;
+            const isConcurrentMode =
+              (returnFiber.mode & ConcurrentMode) !== NoMode;
+            didNotFindHydratableInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+              type,
+              props,
+              // TODO: Delete this argument when we remove the legacy root API.
+              isConcurrentMode,
+            );
+            break;
+          }
+          case HostText: {
+            const text = fiber.pendingProps;
+            const isConcurrentMode =
+              (returnFiber.mode & ConcurrentMode) !== NoMode;
+            didNotFindHydratableTextInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+              text,
+              // TODO: Delete this argument when we remove the legacy root API.
+              isConcurrentMode,
+            );
+            break;
+          }
+          case SuspenseComponent: {
+            didNotFindHydratableSuspenseInstance(
+              parentType,
+              parentProps,
+              parentInstance,
+            );
+            break;
+          }
+        }
+        break;
+      }
+      case SuspenseComponent: {
+        const suspenseState: SuspenseState = returnFiber.memoizedState;
+        const parentInstance = suspenseState.dehydrated;
+        if (parentInstance !== null)
+          switch (fiber.tag) {
+            case HostSingleton:
+            case HostComponent:
+              const type = fiber.type;
+              const props = fiber.pendingProps;
+              didNotFindHydratableInstanceWithinSuspenseInstance(
+                parentInstance,
+                type,
+                props,
+              );
+              break;
+            case HostText:
+              const text = fiber.pendingProps;
+              didNotFindHydratableTextInstanceWithinSuspenseInstance(
+                parentInstance,
+                text,
+              );
+              break;
+            case SuspenseComponent:
+              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(
+                parentInstance,
+              );
+              break;
+          }
+        break;
+      }
+      default:
+        return;
+    }
+  }
+}
+function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+  fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+  warnNonhydratedInstance(returnFiber, fiber);
+}
+
+function tryHydrate(fiber, nextInstance) {
+  switch (fiber.tag) {
+    // HostSingleton is intentionally omitted. the hydration pathway for singletons is non-fallible
+    // you can find it inlined in claimHydratableSingleton
+    case HostComponent: {
+      const type = fiber.type;
+      const props = fiber.pendingProps;
+      const instance = canHydrateInstance(nextInstance, type, props);
+      if (instance !== null) {
+        fiber.stateNode = (instance: Instance);
+        hydrationParentFiber = fiber;
+        nextHydratableInstance = getFirstHydratableChild(instance);
+        return true;
+      }
+      return false;
+    }
+    case HostText: {
+      const text = fiber.pendingProps;
+      const textInstance = canHydrateTextInstance(nextInstance, text);
+      if (textInstance !== null) {
+        fiber.stateNode = (textInstance: TextInstance);
+        hydrationParentFiber = fiber;
+        // Text Instances don't have children so there's nothing to hydrate.
+        nextHydratableInstance = null;
+        return true;
+      }
+      return false;
+    }
+    case SuspenseComponent: {
+      const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(
+        nextInstance,
+      );
+      if (suspenseInstance !== null) {
+        const suspenseState: SuspenseState = {
+          dehydrated: suspenseInstance,
+          treeContext: getSuspendedTreeContext(),
+          retryLane: OffscreenLane,
+        };
+        fiber.memoizedState = suspenseState;
+        // Store the dehydrated fragment as a child fiber.
+        // This simplifies the code for getHostSibling and deleting nodes,
+        // since it doesn't have to consider all Suspense boundaries and
+        // check if they're dehydrated ones or not.
+        const dehydratedFragment = createFiberFromDehydratedFragment(
+          suspenseInstance,
+        );
+        dehydratedFragment.return = fiber;
+        fiber.child = dehydratedFragment;
+        hydrationParentFiber = fiber;
+        // While a Suspense Instance does have children, we won't step into
+        // it during the first pass. Instead, we'll reenter it later.
+        nextHydratableInstance = null;
+        return true;
+      }
+      return false;
+    }
+    default:
+      return false;
+  }
+}
+
+function shouldClientRenderOnMismatch(fiber: Fiber) {
+  return (
+    (fiber.mode & ConcurrentMode) !== NoMode &&
+    (fiber.flags & DidCapture) === NoFlags
+  );
+}
+
+function throwOnHydrationMismatch(fiber: Fiber) {
+  throw new Error(
+    'Hydration failed because the initial UI does not match what was ' +
+      'rendered on the server.',
+  );
+}
+
+function claimHydratableSingleton(fiber: Fiber): void {
+  if (enableHostSingletons && supportsSingletons) {
+    if (!isHydrating) {
+      return;
+    }
+    const currentRootContainer = getRootHostContainer();
+    const currentHostContext = getHostContext();
+    const instance = (fiber.stateNode = resolveSingletonInstance(
+      fiber.type,
+      fiber.pendingProps,
+      currentRootContainer,
+      currentHostContext,
+      false,
+    ));
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = getFirstHydratableChild(instance);
+  }
+}
+
+function tryToClaimNextHydratableInstance(fiber: Fiber): void {
+  if (!isHydrating) {
+    return;
+  }
+  if (enableFloat && !isHydratable(fiber.type, fiber.pendingProps)) {
+    // This fiber never hydrates from the DOM and always does an insert
+    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  let nextInstance = nextHydratableInstance;
+  if (!nextInstance) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // Nothing to hydrate. Make it an insertion.
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    return;
+  }
+  const firstAttemptedInstance = nextInstance;
+  if (!tryHydrate(fiber, nextInstance)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // If we can't hydrate this instance let's try the next one.
+    // We use this as a heuristic. It's based on intuition and not data so it
+    // might be flawed or unnecessary.
+    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
+    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
+    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
+      // Nothing to hydrate. Make it an insertion.
+      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      isHydrating = false;
+      hydrationParentFiber = fiber;
+      return;
+    }
+    // We matched the next one, we'll now assume that the first one was
+    // superfluous and we'll delete it. Since we can't eagerly delete it
+    // we'll have to schedule a deletion. To do that, this node needs a dummy
+    // fiber associated with it.
+    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+  }
+}
+
+function prepareToHydrateHostInstance(
+  fiber: Fiber,
+  hostContext: HostContext,
+): boolean {
+  if (!supportsHydration) {
+    throw new Error(
+      'Expected prepareToHydrateHostInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  const instance: Instance = fiber.stateNode;
+  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
+  const updatePayload = hydrateInstance(
+    instance,
+    fiber.type,
+    fiber.memoizedProps,
+    hostContext,
+    fiber,
+    shouldWarnIfMismatchDev,
+  );
+  // TODO: Type this specific to this type of component.
+  fiber.updateQueue = (updatePayload: any);
+  // If the update payload indicates that there is a change or if there
+  // is a new ref we mark this as an update.
+  if (updatePayload !== null) {
+    return true;
+  }
+  return false;
+}
+
+function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    throw new Error(
+      'Expected prepareToHydrateHostTextInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  const textInstance: TextInstance = fiber.stateNode;
+  const textContent: string = fiber.memoizedProps;
+  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
+  const shouldUpdate = hydrateTextInstance(
+    textInstance,
+    textContent,
+    fiber,
+    shouldWarnIfMismatchDev,
+  );
+  if (shouldUpdate) {
+    // We assume that prepareToHydrateHostTextInstance is called in a context where the
+    // hydration parent is the parent host component of this host text.
+    const returnFiber = hydrationParentFiber;
+    if (returnFiber !== null) {
+      switch (returnFiber.tag) {
+        case HostRoot: {
+          const parentContainer = returnFiber.stateNode.containerInfo;
+          const isConcurrentMode =
+            (returnFiber.mode & ConcurrentMode) !== NoMode;
+          didNotMatchHydratedContainerTextInstance(
+            parentContainer,
+            textInstance,
+            textContent,
+            // TODO: Delete this argument when we remove the legacy root API.
+            isConcurrentMode,
+            shouldWarnIfMismatchDev,
+          );
+          break;
+        }
+        case HostSingleton:
+        case HostComponent: {
+          const parentType = returnFiber.type;
+          const parentProps = returnFiber.memoizedProps;
+          const parentInstance = returnFiber.stateNode;
+          const isConcurrentMode =
+            (returnFiber.mode & ConcurrentMode) !== NoMode;
+          didNotMatchHydratedTextInstance(
+            parentType,
+            parentProps,
+            parentInstance,
+            textInstance,
+            textContent,
+            // TODO: Delete this argument when we remove the legacy root API.
+            isConcurrentMode,
+            shouldWarnIfMismatchDev,
+          );
+          break;
+        }
+      }
+    }
+  }
+  return shouldUpdate;
+}
+
+function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
+  if (!supportsHydration) {
+    throw new Error(
+      'Expected prepareToHydrateHostSuspenseInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  const suspenseState: null | SuspenseState = fiber.memoizedState;
+  const suspenseInstance: null | SuspenseInstance =
+    suspenseState !== null ? suspenseState.dehydrated : null;
+
+  if (!suspenseInstance) {
+    throw new Error(
+      'Expected to have a hydrated suspense instance. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  hydrateSuspenseInstance(suspenseInstance, fiber);
+}
+
+function skipPastDehydratedSuspenseInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
+  if (!supportsHydration) {
+    throw new Error(
+      'Expected skipPastDehydratedSuspenseInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+  const suspenseState: null | SuspenseState = fiber.memoizedState;
+  const suspenseInstance: null | SuspenseInstance =
+    suspenseState !== null ? suspenseState.dehydrated : null;
+
+  if (!suspenseInstance) {
+    throw new Error(
+      'Expected to have a hydrated suspense instance. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
+}
+
+function popToNextHostParent(fiber: Fiber): void {
+  let parent = fiber.return;
+  while (
+    parent !== null &&
+    parent.tag !== HostComponent &&
+    parent.tag !== HostRoot &&
+    parent.tag !== SuspenseComponent &&
+    (!(enableHostSingletons && supportsSingletons)
+      ? true
+      : parent.tag !== HostSingleton)
+  ) {
+    parent = parent.return;
+  }
+  hydrationParentFiber = parent;
+}
+
+function popHydrationState(fiber: Fiber): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  if (fiber !== hydrationParentFiber) {
+    // We're deeper than the current hydration context, inside an inserted
+    // tree.
+    return false;
+  }
+  if (!isHydrating) {
+    // If we're not currently hydrating but we're in a hydration context, then
+    // we were an insertion and now need to pop up reenter hydration of our
+    // siblings.
+    popToNextHostParent(fiber);
+    isHydrating = true;
+    return false;
+  }
+
+  let shouldClear = false;
+  if (enableHostSingletons && supportsSingletons) {
+    // With float we never clear the Root, or Singleton instances. We also do not clear Instances
+    // that have singleton text content
+    if (
+      fiber.tag !== HostRoot &&
+      fiber.tag !== HostSingleton &&
+      !(
+        fiber.tag === HostComponent &&
+        shouldSetTextContent(fiber.type, fiber.memoizedProps)
+      )
+    ) {
+      shouldClear = true;
+    }
+  } else {
+    // If we have any remaining hydratable nodes, we need to delete them now.
+    // We only do this deeper than head and body since they tend to have random
+    // other nodes in them. We also ignore components with pure text content in
+    // side of them. We also don't delete anything inside the root container.
+    if (
+      fiber.tag !== HostRoot &&
+      (fiber.tag !== HostComponent ||
+        (shouldDeleteUnhydratedTailInstances(fiber.type) &&
+          !shouldSetTextContent(fiber.type, fiber.memoizedProps)))
+    ) {
+      shouldClear = true;
+    }
+  }
+  if (shouldClear) {
+    let nextInstance = nextHydratableInstance;
+    if (nextInstance) {
+      if (shouldClientRenderOnMismatch(fiber)) {
+        warnIfUnhydratedTailNodes(fiber);
+        throwOnHydrationMismatch(fiber);
+      } else {
+        while (nextInstance) {
+          deleteHydratableInstance(fiber, nextInstance);
+          nextInstance = getNextHydratableSibling(nextInstance);
+        }
+      }
+    }
+  }
+  popToNextHostParent(fiber);
+  if (fiber.tag === SuspenseComponent) {
+    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
+  } else {
+    nextHydratableInstance = hydrationParentFiber
+      ? getNextHydratableSibling(fiber.stateNode)
+      : null;
+  }
+  return true;
+}
+
+function hasUnhydratedTailNodes(): boolean {
+  return isHydrating && nextHydratableInstance !== null;
+}
+
+function warnIfUnhydratedTailNodes(fiber: Fiber) {
+  let nextInstance = nextHydratableInstance;
+  while (nextInstance) {
+    warnUnhydratedInstance(fiber, nextInstance);
+    nextInstance = getNextHydratableSibling(nextInstance);
+  }
+}
+
+function resetHydrationState(): void {
+  if (!supportsHydration) {
+    return;
+  }
+
+  hydrationParentFiber = null;
+  nextHydratableInstance = null;
+  isHydrating = false;
+  didSuspendOrErrorDEV = false;
+}
+
+export function upgradeHydrationErrorsToRecoverable(): void {
+  if (hydrationErrors !== null) {
+    // Successfully completed a forced client render. The errors that occurred
+    // during the hydration attempt are now recovered. We will log them in
+    // commit phase, once the entire tree has finished.
+    queueRecoverableErrors(hydrationErrors);
+    hydrationErrors = null;
+  }
+}
+
+function getIsHydrating(): boolean {
+  return isHydrating;
+}
+
+export function queueHydrationError(error: CapturedValue<mixed>): void {
+  if (hydrationErrors === null) {
+    hydrationErrors = [error];
+  } else {
+    hydrationErrors.push(error);
+  }
+}
+
+export {
+  warnIfHydrating,
+  enterHydrationState,
+  getIsHydrating,
+  reenterHydrationStateFromDehydratedSuspenseInstance,
+  resetHydrationState,
+  claimHydratableSingleton,
+  tryToClaimNextHydratableInstance,
+  prepareToHydrateHostInstance,
+  prepareToHydrateHostTextInstance,
+  prepareToHydrateHostSuspenseInstance,
+  popHydrationState,
+  hasUnhydratedTailNodes,
+  warnIfUnhydratedTailNodes,
+};

commit 0b4f443020af386f2b48c47c074cb504ed672dc8
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Jan 9 15:46:48 2023 -0500

    [flow] enable enforce_local_inference_annotations (#25921)
    
    This setting is an incremental path to the next Flow version enforcing
    type annotations on most functions (except some inline callbacks).
    
    Used
    ```
    node_modules/.bin/flow codemod annotate-functions-and-classes --write .
    ```
    to add a majority of the types with some hand cleanup when for large
    inferred objects that should just be `Fiber` or weird constructs
    including `any`.
    
    Suppressed the remaining issues.
    
    Builds on #25918

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 4b5bc198a5..ac76169205 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -338,7 +338,7 @@ function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
   warnNonhydratedInstance(returnFiber, fiber);
 }
 
-function tryHydrate(fiber, nextInstance) {
+function tryHydrate(fiber: Fiber, nextInstance: any) {
   switch (fiber.tag) {
     // HostSingleton is intentionally omitted. the hydration pathway for singletons is non-fallible
     // you can find it inlined in claimHydratableSingleton

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index ac76169205..fa6bb47298 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -124,9 +124,8 @@ function enterHydrationState(fiber: Fiber): boolean {
   }
 
   const parentInstance: Container = fiber.stateNode.containerInfo;
-  nextHydratableInstance = getFirstHydratableChildWithinContainer(
-    parentInstance,
-  );
+  nextHydratableInstance =
+    getFirstHydratableChildWithinContainer(parentInstance);
   hydrationParentFiber = fiber;
   isHydrating = true;
   hydrationErrors = null;
@@ -142,9 +141,8 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   if (!supportsHydration) {
     return false;
   }
-  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(
-    suspenseInstance,
-  );
+  nextHydratableInstance =
+    getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
   hydrationParentFiber = fiber;
   isHydrating = true;
   hydrationErrors = null;
@@ -367,9 +365,8 @@ function tryHydrate(fiber: Fiber, nextInstance: any) {
       return false;
     }
     case SuspenseComponent: {
-      const suspenseInstance: null | SuspenseInstance = canHydrateSuspenseInstance(
-        nextInstance,
-      );
+      const suspenseInstance: null | SuspenseInstance =
+        canHydrateSuspenseInstance(nextInstance);
       if (suspenseInstance !== null) {
         const suspenseState: SuspenseState = {
           dehydrated: suspenseInstance,
@@ -381,9 +378,8 @@ function tryHydrate(fiber: Fiber, nextInstance: any) {
         // This simplifies the code for getHostSibling and deleting nodes,
         // since it doesn't have to consider all Suspense boundaries and
         // check if they're dehydrated ones or not.
-        const dehydratedFragment = createFiberFromDehydratedFragment(
-          suspenseInstance,
-        );
+        const dehydratedFragment =
+          createFiberFromDehydratedFragment(suspenseInstance);
         dehydratedFragment.return = fiber;
         fiber.child = dehydratedFragment;
         hydrationParentFiber = fiber;

commit 8a9f82ed58c2fa76583a041fa34ad80f5f94a3d1
Author: Josh Story <story@hey.com>
Date:   Mon Mar 6 15:00:54 2023 -0800

    [Float][Fizz][Fiber] - Do not hoist elements with `itemProp` & hydrate more tolerantly in hoist contexts (#26256)
    
    ## Do not hoist elements with `itemProp`
    In HTML `itemprop` signifies a property of an `itemscope` with respect
    to the Microdata spec
    (https://html.spec.whatwg.org/multipage/microdata.html#microdata)
    
    additionally `itemprop` is valid on any tag and can even make some tags
    that are otherwise invalid in the `<body>` valid there (`<meta>` for
    instance).
    
    Originally I tried an approach where if you rendered something otherwise
    hoistable inside an `itemscope` it would not hoist if it had an
    `itemprop`. This meant that some components with `itemprop` could hoist
    (if they were not scoped, which is generally invalid microdata
    implementation). However the problem is things that do hoist, hoist into
    the head and body and these tags can have an `itemscope`. This creates a
    ton of ambiguity when trying to hydrate in these hoist scopes because we
    can't know for certain whether a DOM node we find there was hoisted or
    not even if it has an `itemprop` attribute. There are other scenarios
    too that have abiguous semantics like rendering a hoistable with
    `itemProp` outside of `<html itemScope={true>`. Is it fair to embed that
    hoistable inside that itemScope even though it was defined outside?
    
    To simplify the situation and disambiguate I dropped the `itemscope`
    portion from the implementation and now any host component that could
    normally be hoisted will not hoist if it has an `itemProp` prop.
    
    In addition to the changes made for `itemProp` this PR also modifies
    part of the hydration implementation to be more tolerant of tags
    injected by 3rd parties. This was opportunistically done when we needed
    to have context information like `inItemScope` but with the most recent
    implementation that has been removed. I have however left the hydration
    changes in place as it is a goal to make React handle hydrating the
    entire Document even when we cannot control whether 3rd parties are
    going to inject tags that React will not render but are also not
    hoistables
    
    -------
    
    ##### Original Description when we considered tracking itemScope
    >One recent decision was to make elements using the `itemProp` prop not
    hoistable if they were inside and itemScope. This better fits with
    Microdata spec which allows for meta tags and other tag types usually
    reserved for the `<head>` to be used in the `<body>` when using
    itemScope.
    >
    >To implement this a number of small changes were necessary
    >
    >1. HostContext in prod needed to expand beyond just tracking the
    element namespace for new element creation. It now tracks whether we are
    in an itemScope. To keep this efficient it is modeled as a bitmask.
    >2. To disambiguate what is and is not a potential instance in the DOM
    for hoistables the hydration algo was updated to skip past non-matching
    instances while attempting to claim the instance rather than ahead of
    time (getNextHydratable).
    >3. React will not consider an itemScope on `<html>`, `<head>`, or
    `<body>` as a valid scope for the hoisting opt-out. This is important as
    an invariant so we can make assumptions about certain tags in these
    scopes. This should not be a functional breaking change because if any
    of these tags have an `itemScope` then it can just be moved into the
    first node inside the `<body>`
    >
    >Since we were already updating the logic for hydration to better
    support `itemScope` opt-out I also changed the hydration behavior for
    suspected 3rd party nodes in `<head>` and `<body>`. Now if you are
    hydrating in either of those contexts hydration will skip past any
    non-matching nodes until it finds a match. This allows 3rd party scripts
    and extensions to inject nodes in either context that React does not
    expect and still avoid a hydration mismatch.
    >
    >This new algorithm isn't perfect and it is possible for a mismatch to
    occur. The most glaring case may be if a 3rd party script prepends a
    `<div>` into `<body>` and you render a `<div>` in `<body>` in your app.
    there is nothing to signal to React that this div was 3rd party so it
    will claim is as the hydrated instance and hydration will almost
    certainly fail immediately afterwards.
    >
    >The expectation is that this is rare and that if falling back to client
    rendering is transparent to the user then there is not problem here. We
    will continue to evaluate this and may change the hydration matching
    algorithm further to match user and developer expectations

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index fa6bb47298..fbf74de143 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -45,10 +45,6 @@ import {
   shouldSetTextContent,
   supportsHydration,
   supportsSingletons,
-  isHydratable,
-  canHydrateInstance,
-  canHydrateTextInstance,
-  canHydrateSuspenseInstance,
   getNextHydratableSibling,
   getFirstHydratableChild,
   getFirstHydratableChildWithinContainer,
@@ -73,6 +69,14 @@ import {
   didNotFindHydratableTextInstance,
   didNotFindHydratableSuspenseInstance,
   resolveSingletonInstance,
+  shouldSkipHydratableForInstance,
+  shouldSkipHydratableForTextInstance,
+  shouldSkipHydratableForSuspenseInstance,
+  canHydrateInstance,
+  canHydrateTextInstance,
+  canHydrateSuspenseInstance,
+  isHydratableType,
+  isHydratableText,
 } from './ReactFiberHostConfig';
 import {OffscreenLane} from './ReactFiberLane';
 import {
@@ -95,6 +99,8 @@ let didSuspendOrErrorDEV: boolean = false;
 // Hydration errors that were thrown inside this boundary
 let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
 
+let rootOrSingletonContext = false;
+
 function warnIfHydrating() {
   if (__DEV__) {
     if (isHydrating) {
@@ -130,6 +136,7 @@ function enterHydrationState(fiber: Fiber): boolean {
   isHydrating = true;
   hydrationErrors = null;
   didSuspendOrErrorDEV = false;
+  rootOrSingletonContext = true;
   return true;
 }
 
@@ -147,6 +154,7 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   isHydrating = true;
   hydrationErrors = null;
   didSuspendOrErrorDEV = false;
+  rootOrSingletonContext = false;
   if (treeContext !== null) {
     restoreSuspendedTreeContext(fiber, treeContext);
   }
@@ -336,63 +344,62 @@ function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
   warnNonhydratedInstance(returnFiber, fiber);
 }
 
-function tryHydrate(fiber: Fiber, nextInstance: any) {
-  switch (fiber.tag) {
-    // HostSingleton is intentionally omitted. the hydration pathway for singletons is non-fallible
-    // you can find it inlined in claimHydratableSingleton
-    case HostComponent: {
-      const type = fiber.type;
-      const props = fiber.pendingProps;
-      const instance = canHydrateInstance(nextInstance, type, props);
-      if (instance !== null) {
-        fiber.stateNode = (instance: Instance);
-        hydrationParentFiber = fiber;
-        nextHydratableInstance = getFirstHydratableChild(instance);
-        return true;
-      }
-      return false;
-    }
-    case HostText: {
-      const text = fiber.pendingProps;
-      const textInstance = canHydrateTextInstance(nextInstance, text);
-      if (textInstance !== null) {
-        fiber.stateNode = (textInstance: TextInstance);
-        hydrationParentFiber = fiber;
-        // Text Instances don't have children so there's nothing to hydrate.
-        nextHydratableInstance = null;
-        return true;
-      }
-      return false;
-    }
-    case SuspenseComponent: {
-      const suspenseInstance: null | SuspenseInstance =
-        canHydrateSuspenseInstance(nextInstance);
-      if (suspenseInstance !== null) {
-        const suspenseState: SuspenseState = {
-          dehydrated: suspenseInstance,
-          treeContext: getSuspendedTreeContext(),
-          retryLane: OffscreenLane,
-        };
-        fiber.memoizedState = suspenseState;
-        // Store the dehydrated fragment as a child fiber.
-        // This simplifies the code for getHostSibling and deleting nodes,
-        // since it doesn't have to consider all Suspense boundaries and
-        // check if they're dehydrated ones or not.
-        const dehydratedFragment =
-          createFiberFromDehydratedFragment(suspenseInstance);
-        dehydratedFragment.return = fiber;
-        fiber.child = dehydratedFragment;
-        hydrationParentFiber = fiber;
-        // While a Suspense Instance does have children, we won't step into
-        // it during the first pass. Instead, we'll reenter it later.
-        nextHydratableInstance = null;
-        return true;
-      }
-      return false;
-    }
-    default:
-      return false;
+function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
+  // fiber is a HostComponent Fiber
+  const instance = canHydrateInstance(
+    nextInstance,
+    fiber.type,
+    fiber.pendingProps,
+  );
+  if (instance !== null) {
+    fiber.stateNode = (instance: Instance);
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = getFirstHydratableChild(instance);
+    rootOrSingletonContext = false;
+    return true;
   }
+  return false;
+}
+
+function tryHydrateText(fiber: Fiber, nextInstance: any) {
+  // fiber is a HostText Fiber
+  const text = fiber.pendingProps;
+  const textInstance = canHydrateTextInstance(nextInstance, text);
+  if (textInstance !== null) {
+    fiber.stateNode = (textInstance: TextInstance);
+    hydrationParentFiber = fiber;
+    // Text Instances don't have children so there's nothing to hydrate.
+    nextHydratableInstance = null;
+    return true;
+  }
+  return false;
+}
+
+function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
+  // fiber is a SuspenseComponent Fiber
+  const suspenseInstance = canHydrateSuspenseInstance(nextInstance);
+  if (suspenseInstance !== null) {
+    const suspenseState: SuspenseState = {
+      dehydrated: suspenseInstance,
+      treeContext: getSuspendedTreeContext(),
+      retryLane: OffscreenLane,
+    };
+    fiber.memoizedState = suspenseState;
+    // Store the dehydrated fragment as a child fiber.
+    // This simplifies the code for getHostSibling and deleting nodes,
+    // since it doesn't have to consider all Suspense boundaries and
+    // check if they're dehydrated ones or not.
+    const dehydratedFragment =
+      createFiberFromDehydratedFragment(suspenseInstance);
+    dehydratedFragment.return = fiber;
+    fiber.child = dehydratedFragment;
+    hydrationParentFiber = fiber;
+    // While a Suspense Instance does have children, we won't step into
+    // it during the first pass. Instead, we'll reenter it later.
+    nextHydratableInstance = null;
+    return true;
+  }
+  return false;
 }
 
 function shouldClientRenderOnMismatch(fiber: Fiber) {
@@ -424,22 +431,189 @@ function claimHydratableSingleton(fiber: Fiber): void {
       false,
     ));
     hydrationParentFiber = fiber;
+    rootOrSingletonContext = true;
     nextHydratableInstance = getFirstHydratableChild(instance);
   }
 }
 
+function advanceToFirstAttempableInstance(fiber: Fiber) {
+  // fiber is HostComponent Fiber
+  while (
+    nextHydratableInstance &&
+    shouldSkipHydratableForInstance(
+      nextHydratableInstance,
+      fiber.type,
+      fiber.pendingProps,
+    )
+  ) {
+    // Flow doesn't understand that inside this block nextHydratableInstance is not null
+    const instance: HydratableInstance = (nextHydratableInstance: any);
+    nextHydratableInstance = getNextHydratableSibling(instance);
+  }
+}
+
+function advanceToFirstAttempableTextInstance() {
+  while (
+    nextHydratableInstance &&
+    shouldSkipHydratableForTextInstance(nextHydratableInstance)
+  ) {
+    // Flow doesn't understand that inside this block nextHydratableInstance is not null
+    const instance: HydratableInstance = (nextHydratableInstance: any);
+    nextHydratableInstance = getNextHydratableSibling(instance);
+  }
+}
+
+function advanceToFirstAttempableSuspenseInstance() {
+  while (
+    nextHydratableInstance &&
+    shouldSkipHydratableForSuspenseInstance(nextHydratableInstance)
+  ) {
+    // Flow doesn't understand that inside this block nextHydratableInstance is not null
+    const instance: HydratableInstance = (nextHydratableInstance: any);
+    nextHydratableInstance = getNextHydratableSibling(instance);
+  }
+}
+
 function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-  if (enableFloat && !isHydratable(fiber.type, fiber.pendingProps)) {
-    // This fiber never hydrates from the DOM and always does an insert
-    fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+  if (enableFloat) {
+    if (!isHydratableType(fiber.type, fiber.pendingProps)) {
+      // This fiber never hydrates from the DOM and always does an insert
+      fiber.flags = (fiber.flags & ~Hydrating) | Placement;
+      isHydrating = false;
+      hydrationParentFiber = fiber;
+      return;
+    }
+  }
+  const initialInstance = nextHydratableInstance;
+  if (rootOrSingletonContext) {
+    // We may need to skip past certain nodes in these contexts
+    advanceToFirstAttempableInstance(fiber);
+  }
+  const nextInstance = nextHydratableInstance;
+  if (!nextInstance) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // Nothing to hydrate. Make it an insertion.
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
     isHydrating = false;
     hydrationParentFiber = fiber;
+    nextHydratableInstance = initialInstance;
     return;
   }
-  let nextInstance = nextHydratableInstance;
+  const firstAttemptedInstance = nextInstance;
+  if (!tryHydrateInstance(fiber, nextInstance)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // If we can't hydrate this instance let's try the next one.
+    // We use this as a heuristic. It's based on intuition and not data so it
+    // might be flawed or unnecessary.
+    nextHydratableInstance = getNextHydratableSibling(nextInstance);
+    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
+    if (rootOrSingletonContext) {
+      // We may need to skip past certain nodes in these contexts
+      advanceToFirstAttempableInstance(fiber);
+    }
+    if (
+      !nextHydratableInstance ||
+      !tryHydrateInstance(fiber, nextHydratableInstance)
+    ) {
+      // Nothing to hydrate. Make it an insertion.
+      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      isHydrating = false;
+      hydrationParentFiber = fiber;
+      nextHydratableInstance = initialInstance;
+      return;
+    }
+    // We matched the next one, we'll now assume that the first one was
+    // superfluous and we'll delete it. Since we can't eagerly delete it
+    // we'll have to schedule a deletion. To do that, this node needs a dummy
+    // fiber associated with it.
+    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+  }
+}
+
+function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
+  if (!isHydrating) {
+    return;
+  }
+  const text = fiber.pendingProps;
+  const isHydratable = isHydratableText(text);
+
+  const initialInstance = nextHydratableInstance;
+  if (rootOrSingletonContext && isHydratable) {
+    // We may need to skip past certain nodes in these contexts.
+    // We don't skip if the text is not hydratable because we know no hydratables
+    // exist which could match this Fiber
+    advanceToFirstAttempableTextInstance();
+  }
+  const nextInstance = nextHydratableInstance;
+  if (!nextInstance || !isHydratable) {
+    // We exclude non hydrabable text because we know there are no matching hydratables.
+    // We either throw or insert depending on the render mode.
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // Nothing to hydrate. Make it an insertion.
+    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    isHydrating = false;
+    hydrationParentFiber = fiber;
+    nextHydratableInstance = initialInstance;
+    return;
+  }
+  const firstAttemptedInstance = nextInstance;
+  if (!tryHydrateText(fiber, nextInstance)) {
+    if (shouldClientRenderOnMismatch(fiber)) {
+      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      throwOnHydrationMismatch(fiber);
+    }
+    // If we can't hydrate this instance let's try the next one.
+    // We use this as a heuristic. It's based on intuition and not data so it
+    // might be flawed or unnecessary.
+    nextHydratableInstance = getNextHydratableSibling(nextInstance);
+    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
+
+    if (rootOrSingletonContext && isHydratable) {
+      // We may need to skip past certain nodes in these contexts
+      advanceToFirstAttempableTextInstance();
+    }
+
+    if (
+      !nextHydratableInstance ||
+      !tryHydrateText(fiber, nextHydratableInstance)
+    ) {
+      // Nothing to hydrate. Make it an insertion.
+      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      isHydrating = false;
+      hydrationParentFiber = fiber;
+      nextHydratableInstance = initialInstance;
+      return;
+    }
+    // We matched the next one, we'll now assume that the first one was
+    // superfluous and we'll delete it. Since we can't eagerly delete it
+    // we'll have to schedule a deletion. To do that, this node needs a dummy
+    // fiber associated with it.
+    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+  }
+}
+
+function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
+  if (!isHydrating) {
+    return;
+  }
+  const initialInstance = nextHydratableInstance;
+  if (rootOrSingletonContext) {
+    // We may need to skip past certain nodes in these contexts
+    advanceToFirstAttempableSuspenseInstance();
+  }
+  const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
     if (shouldClientRenderOnMismatch(fiber)) {
       warnNonhydratedInstance((hydrationParentFiber: any), fiber);
@@ -449,10 +623,11 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     insertNonHydratedInstance((hydrationParentFiber: any), fiber);
     isHydrating = false;
     hydrationParentFiber = fiber;
+    nextHydratableInstance = initialInstance;
     return;
   }
   const firstAttemptedInstance = nextInstance;
-  if (!tryHydrate(fiber, nextInstance)) {
+  if (!tryHydrateSuspense(fiber, nextInstance)) {
     if (shouldClientRenderOnMismatch(fiber)) {
       warnNonhydratedInstance((hydrationParentFiber: any), fiber);
       throwOnHydrationMismatch(fiber);
@@ -460,13 +635,23 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     // If we can't hydrate this instance let's try the next one.
     // We use this as a heuristic. It's based on intuition and not data so it
     // might be flawed or unnecessary.
-    nextInstance = getNextHydratableSibling(firstAttemptedInstance);
+    nextHydratableInstance = getNextHydratableSibling(nextInstance);
     const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
-    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
+
+    if (rootOrSingletonContext) {
+      // We may need to skip past certain nodes in these contexts
+      advanceToFirstAttempableSuspenseInstance();
+    }
+
+    if (
+      !nextHydratableInstance ||
+      !tryHydrateSuspense(fiber, nextHydratableInstance)
+    ) {
       // Nothing to hydrate. Make it an insertion.
       insertNonHydratedInstance((hydrationParentFiber: any), fiber);
       isHydrating = false;
       hydrationParentFiber = fiber;
+      nextHydratableInstance = initialInstance;
       return;
     }
     // We matched the next one, we'll now assume that the first one was
@@ -616,19 +801,21 @@ function skipPastDehydratedSuspenseInstance(
 }
 
 function popToNextHostParent(fiber: Fiber): void {
-  let parent = fiber.return;
-  while (
-    parent !== null &&
-    parent.tag !== HostComponent &&
-    parent.tag !== HostRoot &&
-    parent.tag !== SuspenseComponent &&
-    (!(enableHostSingletons && supportsSingletons)
-      ? true
-      : parent.tag !== HostSingleton)
-  ) {
-    parent = parent.return;
+  hydrationParentFiber = fiber.return;
+  while (hydrationParentFiber) {
+    switch (hydrationParentFiber.tag) {
+      case HostRoot:
+      case HostSingleton:
+        rootOrSingletonContext = true;
+        return;
+      case HostComponent:
+      case SuspenseComponent:
+        rootOrSingletonContext = false;
+        return;
+      default:
+        hydrationParentFiber = hydrationParentFiber.return;
+    }
   }
-  hydrationParentFiber = parent;
 }
 
 function popHydrationState(fiber: Fiber): boolean {
@@ -755,6 +942,8 @@ export {
   resetHydrationState,
   claimHydratableSingleton,
   tryToClaimNextHydratableInstance,
+  tryToClaimNextHydratableTextInstance,
+  tryToClaimNextHydratableSuspenseInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostSuspenseInstance,

commit 978fae4b4f6d5aa28887b530b5c9bf28b1e7b74b
Author: Josh Story <story@hey.com>
Date:   Mon Mar 6 19:52:35 2023 -0800

    [Float][Fiber] implement a faster hydration match for hoistable elements (#26154)
    
    This PR is now based on #26256
    
    The original matching function for `hydrateHoistable` some challenging
    time complexity since we built up the list of matchable nodes for each
    link of that type and then had to check to exclusion. This new
    implementation aims to improve the complexity
    
    For hoisted title tags we match the first title if it is valid (not in
    SVG context and does not have `itemprop`, the two ways you opt out of
    hoisting when rendering titles). This path is much faster than others
    and we use it because valid Documents only have 1 title anyway and if we
    did have a mismatch the rendered title still ends up as the
    Document.title so there is no functional degradation for misses.
    
    For hoisted link and meta tags we track all potentially hydratable
    Elements of this type in a cache per Document. The cache is refreshed
    once each commit if and only if there is a title or meta hoistable
    hydrating. The caches are partitioned by a natural key for each type
    (href for link and content for meta). Then secondary attributes are
    checked to see if the potential match is matchable.
    
    For link we check `rel`, `title`, and `crossorigin`. These should
    provide enough entropy that we never have collisions except is contrived
    cases and even then it should not affect functionality of the page. This
    should also be tolerant of links being injected in arbitrary places in
    the Document by 3rd party scripts and browser extensions
    
    For meta we check `name`, `property`, `http-equiv`, and `charset`. These
    should provide enough entropy that we don't have meaningful collisions.
    It is concievable with og tags that there may be true duplciates `<meta
    property="og:image:size:height" content="100" />` but even if we did
    bind to the wrong instance meta tags are typically only read from SSR by
    bots and rarely inserted by 3rd parties so an adverse functional outcome
    is not expected.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index fbf74de143..b6c7869e45 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -436,7 +436,7 @@ function claimHydratableSingleton(fiber: Fiber): void {
   }
 }
 
-function advanceToFirstAttempableInstance(fiber: Fiber) {
+function advanceToFirstAttemptableInstance(fiber: Fiber) {
   // fiber is HostComponent Fiber
   while (
     nextHydratableInstance &&
@@ -452,7 +452,7 @@ function advanceToFirstAttempableInstance(fiber: Fiber) {
   }
 }
 
-function advanceToFirstAttempableTextInstance() {
+function advanceToFirstAttemptableTextInstance() {
   while (
     nextHydratableInstance &&
     shouldSkipHydratableForTextInstance(nextHydratableInstance)
@@ -463,7 +463,7 @@ function advanceToFirstAttempableTextInstance() {
   }
 }
 
-function advanceToFirstAttempableSuspenseInstance() {
+function advanceToFirstAttemptableSuspenseInstance() {
   while (
     nextHydratableInstance &&
     shouldSkipHydratableForSuspenseInstance(nextHydratableInstance)
@@ -490,7 +490,7 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   const initialInstance = nextHydratableInstance;
   if (rootOrSingletonContext) {
     // We may need to skip past certain nodes in these contexts
-    advanceToFirstAttempableInstance(fiber);
+    advanceToFirstAttemptableInstance(fiber);
   }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
@@ -518,7 +518,7 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
     if (rootOrSingletonContext) {
       // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttempableInstance(fiber);
+      advanceToFirstAttemptableInstance(fiber);
     }
     if (
       !nextHydratableInstance ||
@@ -551,7 +551,7 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
     // We may need to skip past certain nodes in these contexts.
     // We don't skip if the text is not hydratable because we know no hydratables
     // exist which could match this Fiber
-    advanceToFirstAttempableTextInstance();
+    advanceToFirstAttemptableTextInstance();
   }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !isHydratable) {
@@ -582,7 +582,7 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
 
     if (rootOrSingletonContext && isHydratable) {
       // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttempableTextInstance();
+      advanceToFirstAttemptableTextInstance();
     }
 
     if (
@@ -611,7 +611,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   const initialInstance = nextHydratableInstance;
   if (rootOrSingletonContext) {
     // We may need to skip past certain nodes in these contexts
-    advanceToFirstAttempableSuspenseInstance();
+    advanceToFirstAttemptableSuspenseInstance();
   }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
@@ -640,7 +640,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
 
     if (rootOrSingletonContext) {
       // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttempableSuspenseInstance();
+      advanceToFirstAttemptableSuspenseInstance();
     }
 
     if (

commit 8fa41ffa275cae4895b650b0c3b5e8acdbb5055d
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Mar 16 22:39:17 2023 -0400

    Don't "fix up" mismatched text content with suppressedHydrationWarning (#26391)
    
    In concurrent mode we error if child nodes mismatches which triggers a
    recreation of the whole hydration boundary. This ensures that we don't
    replay the wrong thing, transform state or other security issues.
    
    For text content, we respect `suppressedHydrationWarning` to allow for
    things like `<div suppressedHydrationWarning>{timestamp}</div>` to
    ignore the timestamp. This mode actually still patches up the text
    content to be the client rendered content.
    
    In principle we shouldn't have to do that because either value should be
    ok, and arguably it's better not to trigger layout thrash after the
    fact.
    
    We do have a lot of code still to deal with patching up the tree because
    that's what legacy mode does which is still in the code base. When we
    delete legacy mode we would still be stuck with a lot of it just to deal
    with this case.
    
    Therefore I propose that we change the semantics to not patch up
    hydration errors for text nodes. We already don't for attributes.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index b6c7869e45..e8ce874e34 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -728,6 +728,11 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
+          if (isConcurrentMode) {
+            // In concurrent mode we never update the mismatched text,
+            // even if the error was ignored.
+            return false;
+          }
           break;
         }
         case HostSingleton:
@@ -747,6 +752,11 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
+          if (isConcurrentMode) {
+            // In concurrent mode we never update the mismatched text,
+            // even if the error was ignored.
+            return false;
+          }
           break;
         }
       }

commit afb3d51dc6310f0dbeffdd303eb3c6895e6f7db0
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Mar 22 13:12:41 2023 -0400

    Fix enableClientRenderFallbackOnTextMismatch flag (#26457)
    
    With this flag off, we don't throw and therefore don't patch up the tree
    when suppression is off.
    
    Haven't tested.
    
    ---------
    
    Co-authored-by: Rick Hanlon <rickhanlonii@fb.com>

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index e8ce874e34..351fa12292 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -35,7 +35,11 @@ import {
   NoFlags,
   DidCapture,
 } from './ReactFiberFlags';
-import {enableHostSingletons, enableFloat} from 'shared/ReactFeatureFlags';
+import {
+  enableHostSingletons,
+  enableFloat,
+  enableClientRenderFallbackOnTextMismatch,
+} from 'shared/ReactFeatureFlags';
 
 import {
   createFiberFromHostInstanceForDeletion,
@@ -728,7 +732,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
-          if (isConcurrentMode) {
+          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
             // In concurrent mode we never update the mismatched text,
             // even if the error was ignored.
             return false;
@@ -752,7 +756,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
-          if (isConcurrentMode) {
+          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
             // In concurrent mode we never update the mismatched text,
             // even if the error was ignored.
             return false;

commit b55d31955982851284bb437a5187a6c56e366539
Author: Josh Story <story@hey.com>
Date:   Mon Apr 10 14:58:44 2023 -0700

    Rename HostConfig files to FiberConfig to clarify they are configs fo… (#26592)
    
    part of https://github.com/facebook/react/pull/26571
    
    merging separately to improve tracking of files renames in git
    
    Rename HostConfig files to FiberConfig to clarify they are configs for
    Fiber and not Fizz/Flight. This better conforms to the naming used in
    Flight and now Fizz of `ReactFlightServerConfig` and `ReactFizzConfig`

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 351fa12292..a7b0cfdbf2 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -16,7 +16,7 @@ import type {
   SuspenseInstance,
   Container,
   HostContext,
-} from './ReactFiberHostConfig';
+} from './ReactFiberConfig';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {TreeContext} from './ReactFiberTreeContext';
 import type {CapturedValue} from './ReactCapturedValue';
@@ -81,7 +81,7 @@ import {
   canHydrateSuspenseInstance,
   isHydratableType,
   isHydratableText,
-} from './ReactFiberHostConfig';
+} from './ReactFiberConfig';
 import {OffscreenLane} from './ReactFiberLane';
 import {
   getSuspendedTreeContext,

commit ca41adb8c1b256705f73d1fb657421a03dfad82c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Apr 10 19:09:28 2023 -0400

    Diff properties in the commit phase instead of generating an update payload (#26583)
    
    This removes the concept of `prepareUpdate()`, behind a flag.
    
    React Native already does everything in the commit phase, but generates
    a temporary update payload before applying it.
    
    React Fabric does it both in the render phase. Now it just moves it to a
    single host config.
    
    For DOM I forked updateProperties into one that does diffing and
    updating in one pass vs just applying a pre-diffed updatePayload.
    
    There are a few downsides of this approach:
    
    - If only "children" has changed, we end up scheduling an update to be
    done in the commit phase. Since we traverse through it anyway, it's
    probably not much extra.
    - It does more work in the commit phase so for a large tree that is
    mostly unchanged, it'll stall longer.
    - It does some extra work for special cases since that work happens if
    anything has changed. We no longer have a deep bailout.
    - The special cases now have to each replicate the "clean up old props"
    loop, leading to extra code.
    
    The benefit is that this doesn't allocate temporary extra objects
    (possibly multiple per element if the array has to resize). It's less
    work overall. It also gives us an option to reuse this function for a
    sync render optimization.
    
    Another benefit is that if we do the loop in the commit phase I can do
    further optimizations by reading all props that I need for special cases
    in that loop instead of polymorphic reads from props. This is what I'd
    like to do in future refactors that would be stacked on top of this
    change.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a7b0cfdbf2..7c48be5671 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -39,6 +39,7 @@ import {
   enableHostSingletons,
   enableFloat,
   enableClientRenderFallbackOnTextMismatch,
+  diffInCommitPhase,
 } from 'shared/ReactFeatureFlags';
 
 import {
@@ -687,12 +688,15 @@ function prepareToHydrateHostInstance(
     fiber,
     shouldWarnIfMismatchDev,
   );
+
   // TODO: Type this specific to this type of component.
-  fiber.updateQueue = (updatePayload: any);
-  // If the update payload indicates that there is a change or if there
-  // is a new ref we mark this as an update.
-  if (updatePayload !== null) {
-    return true;
+  if (!diffInCommitPhase) {
+    fiber.updateQueue = (updatePayload: any);
+    // If the update payload indicates that there is a change or if there
+    // is a new ref we mark this as an update.
+    if (updatePayload !== null) {
+      return true;
+    }
   }
   return false;
 }

commit 67f4fb02130b1fe1856289e3b66bb0b8cca57ff7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon May 1 15:35:57 2023 -0400

    Allow forms to skip hydration of hidden inputs (#26735)
    
    This allows us to emit extra ephemeral data that will only be used on
    server rendered forms.
    
    First I refactored the shouldSkip functions to now just do that work
    inside the canHydrate methods. This makes the Config bindings a little
    less surface area but it also helps us optimize a bit since we now can
    look at the code together and find shared paths.
    
    canHydrate returns the instance if it matches, that used to just be
    there to refine the type but it can also be used to just return a
    different instance later that we find. If we don't find one, we'll bail
    out and error regardless so no need to skip past anything.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 7c48be5671..6fd9226466 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -74,9 +74,6 @@ import {
   didNotFindHydratableTextInstance,
   didNotFindHydratableSuspenseInstance,
   resolveSingletonInstance,
-  shouldSkipHydratableForInstance,
-  shouldSkipHydratableForTextInstance,
-  shouldSkipHydratableForSuspenseInstance,
   canHydrateInstance,
   canHydrateTextInstance,
   canHydrateSuspenseInstance,
@@ -355,6 +352,7 @@ function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
     nextInstance,
     fiber.type,
     fiber.pendingProps,
+    rootOrSingletonContext,
   );
   if (instance !== null) {
     fiber.stateNode = (instance: Instance);
@@ -369,7 +367,11 @@ function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
 function tryHydrateText(fiber: Fiber, nextInstance: any) {
   // fiber is a HostText Fiber
   const text = fiber.pendingProps;
-  const textInstance = canHydrateTextInstance(nextInstance, text);
+  const textInstance = canHydrateTextInstance(
+    nextInstance,
+    text,
+    rootOrSingletonContext,
+  );
   if (textInstance !== null) {
     fiber.stateNode = (textInstance: TextInstance);
     hydrationParentFiber = fiber;
@@ -382,7 +384,10 @@ function tryHydrateText(fiber: Fiber, nextInstance: any) {
 
 function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
   // fiber is a SuspenseComponent Fiber
-  const suspenseInstance = canHydrateSuspenseInstance(nextInstance);
+  const suspenseInstance = canHydrateSuspenseInstance(
+    nextInstance,
+    rootOrSingletonContext,
+  );
   if (suspenseInstance !== null) {
     const suspenseState: SuspenseState = {
       dehydrated: suspenseInstance,
@@ -441,44 +446,6 @@ function claimHydratableSingleton(fiber: Fiber): void {
   }
 }
 
-function advanceToFirstAttemptableInstance(fiber: Fiber) {
-  // fiber is HostComponent Fiber
-  while (
-    nextHydratableInstance &&
-    shouldSkipHydratableForInstance(
-      nextHydratableInstance,
-      fiber.type,
-      fiber.pendingProps,
-    )
-  ) {
-    // Flow doesn't understand that inside this block nextHydratableInstance is not null
-    const instance: HydratableInstance = (nextHydratableInstance: any);
-    nextHydratableInstance = getNextHydratableSibling(instance);
-  }
-}
-
-function advanceToFirstAttemptableTextInstance() {
-  while (
-    nextHydratableInstance &&
-    shouldSkipHydratableForTextInstance(nextHydratableInstance)
-  ) {
-    // Flow doesn't understand that inside this block nextHydratableInstance is not null
-    const instance: HydratableInstance = (nextHydratableInstance: any);
-    nextHydratableInstance = getNextHydratableSibling(instance);
-  }
-}
-
-function advanceToFirstAttemptableSuspenseInstance() {
-  while (
-    nextHydratableInstance &&
-    shouldSkipHydratableForSuspenseInstance(nextHydratableInstance)
-  ) {
-    // Flow doesn't understand that inside this block nextHydratableInstance is not null
-    const instance: HydratableInstance = (nextHydratableInstance: any);
-    nextHydratableInstance = getNextHydratableSibling(instance);
-  }
-}
-
 function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
@@ -493,10 +460,6 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     }
   }
   const initialInstance = nextHydratableInstance;
-  if (rootOrSingletonContext) {
-    // We may need to skip past certain nodes in these contexts
-    advanceToFirstAttemptableInstance(fiber);
-  }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
     if (shouldClientRenderOnMismatch(fiber)) {
@@ -521,10 +484,6 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     // might be flawed or unnecessary.
     nextHydratableInstance = getNextHydratableSibling(nextInstance);
     const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
-    if (rootOrSingletonContext) {
-      // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttemptableInstance(fiber);
-    }
     if (
       !nextHydratableInstance ||
       !tryHydrateInstance(fiber, nextHydratableInstance)
@@ -552,12 +511,6 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const isHydratable = isHydratableText(text);
 
   const initialInstance = nextHydratableInstance;
-  if (rootOrSingletonContext && isHydratable) {
-    // We may need to skip past certain nodes in these contexts.
-    // We don't skip if the text is not hydratable because we know no hydratables
-    // exist which could match this Fiber
-    advanceToFirstAttemptableTextInstance();
-  }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !isHydratable) {
     // We exclude non hydrabable text because we know there are no matching hydratables.
@@ -585,11 +538,6 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
     nextHydratableInstance = getNextHydratableSibling(nextInstance);
     const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
 
-    if (rootOrSingletonContext && isHydratable) {
-      // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttemptableTextInstance();
-    }
-
     if (
       !nextHydratableInstance ||
       !tryHydrateText(fiber, nextHydratableInstance)
@@ -614,10 +562,6 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
     return;
   }
   const initialInstance = nextHydratableInstance;
-  if (rootOrSingletonContext) {
-    // We may need to skip past certain nodes in these contexts
-    advanceToFirstAttemptableSuspenseInstance();
-  }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
     if (shouldClientRenderOnMismatch(fiber)) {
@@ -643,11 +587,6 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
     nextHydratableInstance = getNextHydratableSibling(nextInstance);
     const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
 
-    if (rootOrSingletonContext) {
-      // We may need to skip past certain nodes in these contexts
-      advanceToFirstAttemptableSuspenseInstance();
-    }
-
     if (
       !nextHydratableInstance ||
       !tryHydrateSuspense(fiber, nextHydratableInstance)
@@ -863,7 +802,8 @@ function popHydrationState(fiber: Fiber): boolean {
       fiber.tag !== HostSingleton &&
       !(
         fiber.tag === HostComponent &&
-        shouldSetTextContent(fiber.type, fiber.memoizedProps)
+        (!shouldDeleteUnhydratedTailInstances(fiber.type) ||
+          shouldSetTextContent(fiber.type, fiber.memoizedProps))
       )
     ) {
       shouldClear = true;

commit e1ad4aa3615333009d76f947ff05ddeff01039c6
Author: Josh Story <story@hey.com>
Date:   Thu Jun 1 13:34:36 2023 -0700

    [Fizz][Float] stop automatically preloading scripts that are not script resources (#26877)
    
    Currently we preload all scripts that are not hoisted. One of the
    original reasons for this is we stopped SSR rendering async scripts that
    had an onLoad/onError because we needed to be able to distinguish
    between Float scripts and non-Float scripts during hydration. Hydration
    has been refactored a bit and we can not get around this limitation so
    we can just emit the async script in place. However, sync and defer
    scripts are also preloaded. While this is sometimes desirable it is not
    universally so and there are issues with conveying priority properly
    (see fetchpriority) so with this change we remove the automatic
    preloading of non-Float scripts altogether.
    
    For this change to make sense we also need to emit async scripts with
    loading handlers during SSR. we previously only preloaded them during
    SSR because it was necessary to keep async scripts as unambiguously
    resources when hydrating. One ancillary benefit was that load handlers
    would always fire b/c there was no chance the script would run before
    hydration. With this change we go back to having the ability to have
    load handlers fired before hydration. This is already a problem with
    images and we don't have a generalized solution for it however our
    likely approach to this sort of thing where you need to wait for a
    script to load is to use something akin to `importScripts()` rather than
    rendering a script with onLoad.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 6fd9226466..3453fcb451 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -37,7 +37,6 @@ import {
 } from './ReactFiberFlags';
 import {
   enableHostSingletons,
-  enableFloat,
   enableClientRenderFallbackOnTextMismatch,
   diffInCommitPhase,
 } from 'shared/ReactFeatureFlags';
@@ -77,7 +76,6 @@ import {
   canHydrateInstance,
   canHydrateTextInstance,
   canHydrateSuspenseInstance,
-  isHydratableType,
   isHydratableText,
 } from './ReactFiberConfig';
 import {OffscreenLane} from './ReactFiberLane';
@@ -450,15 +448,6 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-  if (enableFloat) {
-    if (!isHydratableType(fiber.type, fiber.pendingProps)) {
-      // This fiber never hydrates from the DOM and always does an insert
-      fiber.flags = (fiber.flags & ~Hydrating) | Placement;
-      isHydrating = false;
-      hydrationParentFiber = fiber;
-      return;
-    }
-  }
   const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {

commit 8b26f07a883bb341c20283c0099bf5ee6f87bd1f
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Sep 7 16:05:44 2023 -0400

    useFormState: Emit comment to mark whether state matches (#27307)
    
    A planned feature of useFormState is that if the page load is the result
    of an MPA-style form submission — i.e. a form was submitted before it
    was hydrated, using Server Actions — the state of the hook should
    transfer to the next page.
    
    I haven't implemented that part yet, but as a prerequisite, we need some
    way for Fizz to indicate whether a useFormState hook was rendered using
    the "postback" state. That way we can do all state matching logic on the
    server without having to replicate it on the client, too.
    
    The approach here is to emit a comment node for each useFormState hook.
    We use one of two comment types: `<!--F-->` for a normal useFormState
    hook, and `<!--F!-->` for a hook that was rendered using the postback
    state. React will read these markers during hydration. This is similar
    to how we encode Suspense boundaries.
    
    Again, the actual matching algorithm is not yet implemented — for now,
    the "not matching" marker is always emitted.
    
    We can optimize this further by not emitting any markers for a render
    that is not the result of a form postback, which I'll do in subsequent
    PRs.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 3453fcb451..dac3d5f2de 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -76,6 +76,8 @@ import {
   canHydrateInstance,
   canHydrateTextInstance,
   canHydrateSuspenseInstance,
+  canHydrateFormStateMarker,
+  isFormStateMarkerMatching,
   isHydratableText,
 } from './ReactFiberConfig';
 import {OffscreenLane} from './ReactFiberLane';
@@ -595,6 +597,34 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   }
 }
 
+export function tryToClaimNextHydratableFormMarkerInstance(
+  fiber: Fiber,
+): boolean {
+  if (!isHydrating) {
+    return false;
+  }
+  if (nextHydratableInstance) {
+    const markerInstance = canHydrateFormStateMarker(
+      nextHydratableInstance,
+      rootOrSingletonContext,
+    );
+    if (markerInstance) {
+      // Found the marker instance.
+      nextHydratableInstance = getNextHydratableSibling(markerInstance);
+      // Return true if this marker instance should use the state passed
+      // to hydrateRoot.
+      // TODO: As an optimization, Fizz should only emit these markers if form
+      // state is passed at the root.
+      return isFormStateMarkerMatching(markerInstance);
+    }
+  }
+  // Should have found a marker instance. Throw an error to trigger client
+  // rendering. We don't bother to check if we're in a concurrent root because
+  // useFormState is a new API, so backwards compat is not an issue.
+  throwOnHydrationMismatch(fiber);
+  return false;
+}
+
 function prepareToHydrateHostInstance(
   fiber: Fiber,
   hostContext: HostContext,

commit 7f6201889e8e628eeb53e05d8850ddffa3c2e74a
Author: Sophie Alpert <git@sophiebits.com>
Date:   Fri Sep 22 20:24:42 2023 -0700

    Ship diffInCommitPhase (#27409)
    
    Performance tests at Meta showed neutral results.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index dac3d5f2de..c1ee83c2c8 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -38,7 +38,6 @@ import {
 import {
   enableHostSingletons,
   enableClientRenderFallbackOnTextMismatch,
-  diffInCommitPhase,
 } from 'shared/ReactFeatureFlags';
 
 import {
@@ -628,7 +627,7 @@ export function tryToClaimNextHydratableFormMarkerInstance(
 function prepareToHydrateHostInstance(
   fiber: Fiber,
   hostContext: HostContext,
-): boolean {
+): void {
   if (!supportsHydration) {
     throw new Error(
       'Expected prepareToHydrateHostInstance() to never be called. ' +
@@ -638,7 +637,7 @@ function prepareToHydrateHostInstance(
 
   const instance: Instance = fiber.stateNode;
   const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-  const updatePayload = hydrateInstance(
+  hydrateInstance(
     instance,
     fiber.type,
     fiber.memoizedProps,
@@ -646,17 +645,6 @@ function prepareToHydrateHostInstance(
     fiber,
     shouldWarnIfMismatchDev,
   );
-
-  // TODO: Type this specific to this type of component.
-  if (!diffInCommitPhase) {
-    fiber.updateQueue = (updatePayload: any);
-    // If the update payload indicates that there is a change or if there
-    // is a new ref we mark this as an update.
-    if (updatePayload !== null) {
-      return true;
-    }
-  }
-  return false;
 }
 
 function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {

commit 1a65d036ef057b07a6b15f5604e399f91bc5ed73
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Nov 16 17:42:03 2023 -0500

    [cleanup] remove enableHostSingletons feature flag (#27583)
    
    The flag is enabled everywhere, I think we can remove it now.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index c1ee83c2c8..a0838ea331 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -35,10 +35,7 @@ import {
   NoFlags,
   DidCapture,
 } from './ReactFiberFlags';
-import {
-  enableHostSingletons,
-  enableClientRenderFallbackOnTextMismatch,
-} from 'shared/ReactFeatureFlags';
+import {enableClientRenderFallbackOnTextMismatch} from 'shared/ReactFeatureFlags';
 
 import {
   createFiberFromHostInstanceForDeletion,
@@ -426,7 +423,7 @@ function throwOnHydrationMismatch(fiber: Fiber) {
 }
 
 function claimHydratableSingleton(fiber: Fiber): void {
-  if (enableHostSingletons && supportsSingletons) {
+  if (supportsSingletons) {
     if (!isHydrating) {
       return;
     }
@@ -801,7 +798,7 @@ function popHydrationState(fiber: Fiber): boolean {
   }
 
   let shouldClear = false;
-  if (enableHostSingletons && supportsSingletons) {
+  if (supportsSingletons) {
     // With float we never clear the Root, or Singleton instances. We also do not clear Instances
     // that have singleton text content
     if (

commit 118ad2afa75a44fe3715ad7fb0023c408125bef7
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Sat Feb 24 00:45:42 2024 -0500

    Validate DOM nesting for hydration before the hydration warns / errors (#28434)
    
    If there's invalid dom nesting, there will be mismatches following but
    the nesting is the most important cause of the problem.
    
    Previously we would include the DOM nesting when rerendering thanks to
    the new model of throw and recovery. However, the log would come during
    the recovery phase which is after we've already logged that there was a
    hydration mismatch.
    
    People would consistently miss this log. Which is fair because you
    should always look at the first log first as the most probable cause.
    
    This ensures that we log in the hydration phase if there's a dom nesting
    issue. This assumes that the consequence of nesting will appear such
    that the won't have a mismatch before this. That's typically the case
    because the node will move up and to be a later sibling. So as long as
    that happens and we keep hydrating depth first, it should hold true.
    There might be an issue if there's a suspense boundary between the nodes
    we'll find discover the new child in the outer path since suspense
    boundaries as breadth first.
    
    Before:
    
    <img width="996" alt="Screenshot 2024-02-23 at 7 34 01 PM"
    src="https://github.com/facebook/react/assets/63648/af70cf7f-898b-477f-be39-13b01cfe585f">
    
    After:
    
    <img width="853" alt="Screenshot 2024-02-23 at 7 22 24 PM"
    src="https://github.com/facebook/react/assets/63648/896c6348-1620-4f99-881d-b6069263925e">
    
    Cameo: RSC stacks.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a0838ea331..8960419b80 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -75,6 +75,8 @@ import {
   canHydrateFormStateMarker,
   isFormStateMarkerMatching,
   isHydratableText,
+  validateHydratableInstance,
+  validateHydratableTextInstance,
 } from './ReactFiberConfig';
 import {OffscreenLane} from './ReactFiberLane';
 import {
@@ -202,7 +204,6 @@ function deleteHydratableInstance(
   returnFiber: Fiber,
   instance: HydratableInstance,
 ) {
-  warnUnhydratedInstance(returnFiber, instance);
   const childToDelete = createFiberFromHostInstanceForDeletion();
   childToDelete.stateNode = instance;
   childToDelete.return = returnFiber;
@@ -216,7 +217,7 @@ function deleteHydratableInstance(
   }
 }
 
-function warnNonhydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
   if (__DEV__) {
     if (didSuspendOrErrorDEV) {
       // Inside a boundary that already suspended. We're currently rendering the
@@ -339,7 +340,6 @@ function warnNonhydratedInstance(returnFiber: Fiber, fiber: Fiber) {
 }
 function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
   fiber.flags = (fiber.flags & ~Hydrating) | Placement;
-  warnNonhydratedInstance(returnFiber, fiber);
 }
 
 function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
@@ -446,15 +446,29 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
+
+  // Validate that this is ok to render here before any mismatches.
+  const currentHostContext = getHostContext();
+  const shouldKeepWarning = validateHydratableInstance(
+    fiber.type,
+    fiber.pendingProps,
+    currentHostContext,
+  );
+
   const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       throwOnHydrationMismatch(fiber);
     }
     // Nothing to hydrate. Make it an insertion.
     insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    if (shouldKeepWarning) {
+      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+    }
     isHydrating = false;
     hydrationParentFiber = fiber;
     nextHydratableInstance = initialInstance;
@@ -463,7 +477,9 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   const firstAttemptedInstance = nextInstance;
   if (!tryHydrateInstance(fiber, nextInstance)) {
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       throwOnHydrationMismatch(fiber);
     }
     // If we can't hydrate this instance let's try the next one.
@@ -477,6 +493,9 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     ) {
       // Nothing to hydrate. Make it an insertion.
       insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       isHydrating = false;
       hydrationParentFiber = fiber;
       nextHydratableInstance = initialInstance;
@@ -486,6 +505,9 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     // superfluous and we'll delete it. Since we can't eagerly delete it
     // we'll have to schedule a deletion. To do that, this node needs a dummy
     // fiber associated with it.
+    if (shouldKeepWarning) {
+      warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
+    }
     deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
   }
 }
@@ -497,17 +519,32 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const text = fiber.pendingProps;
   const isHydratable = isHydratableText(text);
 
+  let shouldKeepWarning = true;
+  if (isHydratable) {
+    // Validate that this is ok to render here before any mismatches.
+    const currentHostContext = getHostContext();
+    shouldKeepWarning = validateHydratableTextInstance(
+      text,
+      currentHostContext,
+    );
+  }
+
   const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !isHydratable) {
     // We exclude non hydrabable text because we know there are no matching hydratables.
     // We either throw or insert depending on the render mode.
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       throwOnHydrationMismatch(fiber);
     }
     // Nothing to hydrate. Make it an insertion.
     insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    if (shouldKeepWarning) {
+      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+    }
     isHydrating = false;
     hydrationParentFiber = fiber;
     nextHydratableInstance = initialInstance;
@@ -516,7 +553,9 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const firstAttemptedInstance = nextInstance;
   if (!tryHydrateText(fiber, nextInstance)) {
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       throwOnHydrationMismatch(fiber);
     }
     // If we can't hydrate this instance let's try the next one.
@@ -531,6 +570,9 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
     ) {
       // Nothing to hydrate. Make it an insertion.
       insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      if (shouldKeepWarning) {
+        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      }
       isHydrating = false;
       hydrationParentFiber = fiber;
       nextHydratableInstance = initialInstance;
@@ -540,6 +582,9 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
     // superfluous and we'll delete it. Since we can't eagerly delete it
     // we'll have to schedule a deletion. To do that, this node needs a dummy
     // fiber associated with it.
+    if (shouldKeepWarning) {
+      warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
+    }
     deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
   }
 }
@@ -552,11 +597,12 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   const nextInstance = nextHydratableInstance;
   if (!nextInstance) {
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
       throwOnHydrationMismatch(fiber);
     }
     // Nothing to hydrate. Make it an insertion.
     insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+    warnNonHydratedInstance((hydrationParentFiber: any), fiber);
     isHydrating = false;
     hydrationParentFiber = fiber;
     nextHydratableInstance = initialInstance;
@@ -565,7 +611,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   const firstAttemptedInstance = nextInstance;
   if (!tryHydrateSuspense(fiber, nextInstance)) {
     if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonhydratedInstance((hydrationParentFiber: any), fiber);
+      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
       throwOnHydrationMismatch(fiber);
     }
     // If we can't hydrate this instance let's try the next one.
@@ -580,6 +626,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
     ) {
       // Nothing to hydrate. Make it an insertion.
       insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
       isHydrating = false;
       hydrationParentFiber = fiber;
       nextHydratableInstance = initialInstance;
@@ -589,6 +636,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
     // superfluous and we'll delete it. Since we can't eagerly delete it
     // we'll have to schedule a deletion. To do that, this node needs a dummy
     // fiber associated with it.
+    warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
     deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
   }
 }
@@ -834,6 +882,7 @@ function popHydrationState(fiber: Fiber): boolean {
         throwOnHydrationMismatch(fiber);
       } else {
         while (nextInstance) {
+          warnUnhydratedInstance(fiber, nextInstance);
           deleteHydratableInstance(fiber, nextInstance);
           nextInstance = getNextHydratableSibling(nextInstance);
         }

commit bb4b147da9a892529995f55f15f19f46a00cf4f6
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Thu Feb 29 20:27:26 2024 -0500

    Clean up empty string special cases (#28475)
    
    This was fixed in https://github.com/facebook/react/pull/22807 so we
    don't need these special cases anymore.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 8960419b80..61be1aa39b 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -74,7 +74,6 @@ import {
   canHydrateSuspenseInstance,
   canHydrateFormStateMarker,
   isFormStateMarkerMatching,
-  isHydratableText,
   validateHydratableInstance,
   validateHydratableTextInstance,
 } from './ReactFiberConfig';
@@ -517,21 +516,15 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
     return;
   }
   const text = fiber.pendingProps;
-  const isHydratable = isHydratableText(text);
 
   let shouldKeepWarning = true;
-  if (isHydratable) {
-    // Validate that this is ok to render here before any mismatches.
-    const currentHostContext = getHostContext();
-    shouldKeepWarning = validateHydratableTextInstance(
-      text,
-      currentHostContext,
-    );
-  }
+  // Validate that this is ok to render here before any mismatches.
+  const currentHostContext = getHostContext();
+  shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);
 
   const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance || !isHydratable) {
+  if (!nextInstance) {
     // We exclude non hydrabable text because we know there are no matching hydratables.
     // We either throw or insert depending on the render mode.
     if (shouldClientRenderOnMismatch(fiber)) {

commit c11b196ae3e2e3c5d143d9102b35a6b6fa97c849
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 5 20:54:24 2024 -0500

    Move tail hydration mismatch back to hydration context (#28501)
    
    In #23176 we added a special case in completeWork for SuspenseBoundaries
    if they still have trailing children. However, that misses a case
    because it doesn't log a recoverable error for the hydration mismatch.
    So we get an error that we rerendered.
    
    I think this special case was done to avoid contexts getting out of
    sync. I don't know why we didn't just move where the pop happens though
    so that's what I did here and let the regular pass throw instead. Seems
    to be pass the tests.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 61be1aa39b..4d59710c75 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -893,10 +893,6 @@ function popHydrationState(fiber: Fiber): boolean {
   return true;
 }
 
-function hasUnhydratedTailNodes(): boolean {
-  return isHydrating && nextHydratableInstance !== null;
-}
-
 function warnIfUnhydratedTailNodes(fiber: Fiber) {
   let nextInstance = nextHydratableInstance;
   while (nextInstance) {
@@ -952,6 +948,4 @@ export {
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
-  hasUnhydratedTailNodes,
-  warnIfUnhydratedTailNodes,
 };

commit 89021fb4ec9aa82194b0788566e736a4cedfc0e4
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Mon Mar 11 17:17:07 2024 -0700

    Remove invokeGuardedCallback and replay trick (#28515)
    
    We broke the ability to "break on uncaught exceptions" by adding a
    try/catch higher up in the scheduling. We're giving up on fixing that so
    we can remove the replay trick inside an event handler.
    
    The issue with that approach is that we end up double logging a lot of
    errors in DEV since they get reported to the page.
    
    It's also a lot of complexity around this feature.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 4d59710c75..90d87e13d7 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -116,13 +116,6 @@ export function markDidThrowWhileHydratingDEV() {
   }
 }
 
-export function didSuspendOrErrorWhileHydratingDEV(): boolean {
-  if (__DEV__) {
-    return didSuspendOrErrorDEV;
-  }
-  return false;
-}
-
 function enterHydrationState(fiber: Fiber): boolean {
   if (!supportsHydration) {
     return false;

commit 670d61bea23470e980ba13c1c8441e375779b0b8
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 14:41:49 2024 -0700

    Remove legacy hydration mode (#28440)
    
    While Meta is still using legacy mode and we can't remove completely,
    Meta is not using legacy hydration so we should be able to remove that.
    
    This is just the first step. Once removed, we can vastly simplify the
    DOMConfig for hydration.
    
    This will have to be rebased when tests are upgraded.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 90d87e13d7..11cb591ec9 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -8,7 +8,6 @@
  */
 
 import type {Fiber} from './ReactInternalTypes';
-import {NoMode, ConcurrentMode} from './ReactTypeOfMode';
 import type {
   Instance,
   TextInstance,
@@ -28,19 +27,9 @@ import {
   HostRoot,
   SuspenseComponent,
 } from './ReactWorkTags';
-import {
-  ChildDeletion,
-  Placement,
-  Hydrating,
-  NoFlags,
-  DidCapture,
-} from './ReactFiberFlags';
 import {enableClientRenderFallbackOnTextMismatch} from 'shared/ReactFeatureFlags';
 
-import {
-  createFiberFromHostInstanceForDeletion,
-  createFiberFromDehydratedFragment,
-} from './ReactFiber';
+import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
   shouldSetTextContent,
   supportsHydration,
@@ -168,14 +157,11 @@ function warnUnhydratedInstance(
       }
       case HostSingleton:
       case HostComponent: {
-        const isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
         didNotHydrateInstance(
           returnFiber.type,
           returnFiber.memoizedProps,
           returnFiber.stateNode,
           instance,
-          // TODO: Delete this argument when we remove the legacy root API.
-          isConcurrentMode,
         );
         break;
       }
@@ -192,23 +178,6 @@ function warnUnhydratedInstance(
   }
 }
 
-function deleteHydratableInstance(
-  returnFiber: Fiber,
-  instance: HydratableInstance,
-) {
-  const childToDelete = createFiberFromHostInstanceForDeletion();
-  childToDelete.stateNode = instance;
-  childToDelete.return = returnFiber;
-
-  const deletions = returnFiber.deletions;
-  if (deletions === null) {
-    returnFiber.deletions = [childToDelete];
-    returnFiber.flags |= ChildDeletion;
-  } else {
-    deletions.push(childToDelete);
-  }
-}
-
 function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
   if (__DEV__) {
     if (didSuspendOrErrorDEV) {
@@ -257,30 +226,22 @@ function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
           case HostComponent: {
             const type = fiber.type;
             const props = fiber.pendingProps;
-            const isConcurrentMode =
-              (returnFiber.mode & ConcurrentMode) !== NoMode;
             didNotFindHydratableInstance(
               parentType,
               parentProps,
               parentInstance,
               type,
               props,
-              // TODO: Delete this argument when we remove the legacy root API.
-              isConcurrentMode,
             );
             break;
           }
           case HostText: {
             const text = fiber.pendingProps;
-            const isConcurrentMode =
-              (returnFiber.mode & ConcurrentMode) !== NoMode;
             didNotFindHydratableTextInstance(
               parentType,
               parentProps,
               parentInstance,
               text,
-              // TODO: Delete this argument when we remove the legacy root API.
-              isConcurrentMode,
             );
             break;
           }
@@ -330,9 +291,6 @@ function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
     }
   }
 }
-function insertNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
-  fiber.flags = (fiber.flags & ~Hydrating) | Placement;
-}
 
 function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
   // fiber is a HostComponent Fiber
@@ -400,13 +358,6 @@ function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
   return false;
 }
 
-function shouldClientRenderOnMismatch(fiber: Fiber) {
-  return (
-    (fiber.mode & ConcurrentMode) !== NoMode &&
-    (fiber.flags & DidCapture) === NoFlags
-  );
-}
-
 function throwOnHydrationMismatch(fiber: Fiber) {
   throw new Error(
     'Hydration failed because the initial UI does not match what was ' +
@@ -447,60 +398,12 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
     currentHostContext,
   );
 
-  const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance) {
-    if (shouldClientRenderOnMismatch(fiber)) {
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      throwOnHydrationMismatch(fiber);
-    }
-    // Nothing to hydrate. Make it an insertion.
-    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+  if (!nextInstance || !tryHydrateInstance(fiber, nextInstance)) {
     if (shouldKeepWarning) {
       warnNonHydratedInstance((hydrationParentFiber: any), fiber);
     }
-    isHydrating = false;
-    hydrationParentFiber = fiber;
-    nextHydratableInstance = initialInstance;
-    return;
-  }
-  const firstAttemptedInstance = nextInstance;
-  if (!tryHydrateInstance(fiber, nextInstance)) {
-    if (shouldClientRenderOnMismatch(fiber)) {
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      throwOnHydrationMismatch(fiber);
-    }
-    // If we can't hydrate this instance let's try the next one.
-    // We use this as a heuristic. It's based on intuition and not data so it
-    // might be flawed or unnecessary.
-    nextHydratableInstance = getNextHydratableSibling(nextInstance);
-    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
-    if (
-      !nextHydratableInstance ||
-      !tryHydrateInstance(fiber, nextHydratableInstance)
-    ) {
-      // Nothing to hydrate. Make it an insertion.
-      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      isHydrating = false;
-      hydrationParentFiber = fiber;
-      nextHydratableInstance = initialInstance;
-      return;
-    }
-    // We matched the next one, we'll now assume that the first one was
-    // superfluous and we'll delete it. Since we can't eagerly delete it
-    // we'll have to schedule a deletion. To do that, this node needs a dummy
-    // fiber associated with it.
-    if (shouldKeepWarning) {
-      warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
-    }
-    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -515,63 +418,12 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const currentHostContext = getHostContext();
   shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);
 
-  const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance) {
-    // We exclude non hydrabable text because we know there are no matching hydratables.
-    // We either throw or insert depending on the render mode.
-    if (shouldClientRenderOnMismatch(fiber)) {
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      throwOnHydrationMismatch(fiber);
-    }
-    // Nothing to hydrate. Make it an insertion.
-    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+  if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {
     if (shouldKeepWarning) {
       warnNonHydratedInstance((hydrationParentFiber: any), fiber);
     }
-    isHydrating = false;
-    hydrationParentFiber = fiber;
-    nextHydratableInstance = initialInstance;
-    return;
-  }
-  const firstAttemptedInstance = nextInstance;
-  if (!tryHydrateText(fiber, nextInstance)) {
-    if (shouldClientRenderOnMismatch(fiber)) {
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      throwOnHydrationMismatch(fiber);
-    }
-    // If we can't hydrate this instance let's try the next one.
-    // We use this as a heuristic. It's based on intuition and not data so it
-    // might be flawed or unnecessary.
-    nextHydratableInstance = getNextHydratableSibling(nextInstance);
-    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
-
-    if (
-      !nextHydratableInstance ||
-      !tryHydrateText(fiber, nextHydratableInstance)
-    ) {
-      // Nothing to hydrate. Make it an insertion.
-      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-      if (shouldKeepWarning) {
-        warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      }
-      isHydrating = false;
-      hydrationParentFiber = fiber;
-      nextHydratableInstance = initialInstance;
-      return;
-    }
-    // We matched the next one, we'll now assume that the first one was
-    // superfluous and we'll delete it. Since we can't eagerly delete it
-    // we'll have to schedule a deletion. To do that, this node needs a dummy
-    // fiber associated with it.
-    if (shouldKeepWarning) {
-      warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
-    }
-    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -579,51 +431,10 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   if (!isHydrating) {
     return;
   }
-  const initialInstance = nextHydratableInstance;
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance) {
-    if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      throwOnHydrationMismatch(fiber);
-    }
-    // Nothing to hydrate. Make it an insertion.
-    insertNonHydratedInstance((hydrationParentFiber: any), fiber);
+  if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {
     warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-    isHydrating = false;
-    hydrationParentFiber = fiber;
-    nextHydratableInstance = initialInstance;
-    return;
-  }
-  const firstAttemptedInstance = nextInstance;
-  if (!tryHydrateSuspense(fiber, nextInstance)) {
-    if (shouldClientRenderOnMismatch(fiber)) {
-      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      throwOnHydrationMismatch(fiber);
-    }
-    // If we can't hydrate this instance let's try the next one.
-    // We use this as a heuristic. It's based on intuition and not data so it
-    // might be flawed or unnecessary.
-    nextHydratableInstance = getNextHydratableSibling(nextInstance);
-    const prevHydrationParentFiber: Fiber = (hydrationParentFiber: any);
-
-    if (
-      !nextHydratableInstance ||
-      !tryHydrateSuspense(fiber, nextHydratableInstance)
-    ) {
-      // Nothing to hydrate. Make it an insertion.
-      insertNonHydratedInstance((hydrationParentFiber: any), fiber);
-      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
-      isHydrating = false;
-      hydrationParentFiber = fiber;
-      nextHydratableInstance = initialInstance;
-      return;
-    }
-    // We matched the next one, we'll now assume that the first one was
-    // superfluous and we'll delete it. Since we can't eagerly delete it
-    // we'll have to schedule a deletion. To do that, this node needs a dummy
-    // fiber associated with it.
-    warnUnhydratedInstance(prevHydrationParentFiber, firstAttemptedInstance);
-    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -703,17 +514,13 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
       switch (returnFiber.tag) {
         case HostRoot: {
           const parentContainer = returnFiber.stateNode.containerInfo;
-          const isConcurrentMode =
-            (returnFiber.mode & ConcurrentMode) !== NoMode;
           didNotMatchHydratedContainerTextInstance(
             parentContainer,
             textInstance,
             textContent,
-            // TODO: Delete this argument when we remove the legacy root API.
-            isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
-          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
+          if (enableClientRenderFallbackOnTextMismatch) {
             // In concurrent mode we never update the mismatched text,
             // even if the error was ignored.
             return false;
@@ -725,19 +532,15 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
           const parentType = returnFiber.type;
           const parentProps = returnFiber.memoizedProps;
           const parentInstance = returnFiber.stateNode;
-          const isConcurrentMode =
-            (returnFiber.mode & ConcurrentMode) !== NoMode;
           didNotMatchHydratedTextInstance(
             parentType,
             parentProps,
             parentInstance,
             textInstance,
             textContent,
-            // TODO: Delete this argument when we remove the legacy root API.
-            isConcurrentMode,
             shouldWarnIfMismatchDev,
           );
-          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
+          if (enableClientRenderFallbackOnTextMismatch) {
             // In concurrent mode we never update the mismatched text,
             // even if the error was ignored.
             return false;
@@ -861,18 +664,10 @@ function popHydrationState(fiber: Fiber): boolean {
     }
   }
   if (shouldClear) {
-    let nextInstance = nextHydratableInstance;
+    const nextInstance = nextHydratableInstance;
     if (nextInstance) {
-      if (shouldClientRenderOnMismatch(fiber)) {
-        warnIfUnhydratedTailNodes(fiber);
-        throwOnHydrationMismatch(fiber);
-      } else {
-        while (nextInstance) {
-          warnUnhydratedInstance(fiber, nextInstance);
-          deleteHydratableInstance(fiber, nextInstance);
-          nextInstance = getNextHydratableSibling(nextInstance);
-        }
-      }
+      warnIfUnhydratedTailNodes(fiber);
+      throwOnHydrationMismatch(fiber);
     }
   }
   popToNextHostParent(fiber);

commit 84c84d72f11ff1961a103b3cd59919876e48f759
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 14:55:14 2024 -0700

    Remove enableClientRenderFallbackOnTextMismatch flag (#28458)
    
    Build on top of #28440.
    
    This lets us remove the path where updates are tracked on differences in
    text.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 11cb591ec9..dab48e40cd 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -27,7 +27,6 @@ import {
   HostRoot,
   SuspenseComponent,
 } from './ReactWorkTags';
-import {enableClientRenderFallbackOnTextMismatch} from 'shared/ReactFeatureFlags';
 
 import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
@@ -489,7 +488,7 @@ function prepareToHydrateHostInstance(
   );
 }
 
-function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
+function prepareToHydrateHostTextInstance(fiber: Fiber): void {
   if (!supportsHydration) {
     throw new Error(
       'Expected prepareToHydrateHostTextInstance() to never be called. ' +
@@ -500,13 +499,13 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
   const textInstance: TextInstance = fiber.stateNode;
   const textContent: string = fiber.memoizedProps;
   const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-  const shouldUpdate = hydrateTextInstance(
+  const textIsDifferent = hydrateTextInstance(
     textInstance,
     textContent,
     fiber,
     shouldWarnIfMismatchDev,
   );
-  if (shouldUpdate) {
+  if (textIsDifferent) {
     // We assume that prepareToHydrateHostTextInstance is called in a context where the
     // hydration parent is the parent host component of this host text.
     const returnFiber = hydrationParentFiber;
@@ -520,11 +519,6 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             textContent,
             shouldWarnIfMismatchDev,
           );
-          if (enableClientRenderFallbackOnTextMismatch) {
-            // In concurrent mode we never update the mismatched text,
-            // even if the error was ignored.
-            return false;
-          }
           break;
         }
         case HostSingleton:
@@ -540,17 +534,11 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): boolean {
             textContent,
             shouldWarnIfMismatchDev,
           );
-          if (enableClientRenderFallbackOnTextMismatch) {
-            // In concurrent mode we never update the mismatched text,
-            // even if the error was ignored.
-            return false;
-          }
           break;
         }
       }
     }
   }
-  return shouldUpdate;
 }
 
 function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {

commit 4b8dfd6215bf855402ae1a94cb0ae4f467afca9a
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 16:04:18 2024 -0700

    Move Hydration Warnings from the DOM Config into the Fiber reconciliation (#28476)
    
    Stacked on #28458.
    
    This doesn't actually really change the messages yet, it's just a
    refactor.
    
    Hydration warnings can be presented either as HTML or React JSX format.
    If presented as HTML it makes more sense to make that a DOM specific
    concept, however, I think it's actually better to present it in terms of
    React JSX.
    
    Most of the time the errors aren't going to be something messing with
    them at the HTML/HTTP layer. It's because the JS code does something
    different. Most of the time you're working in just React. People don't
    necessarily even know what the HTML form of it looks like. So this takes
    the approach that the warnings are presented in React JSX in their rich
    object form.
    
    Therefore, I'm moving the approach to yield diff data to the reconciler
    but it's the reconciler that's actually printing all the warnings.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index dab48e40cd..49171baf1c 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -38,24 +38,13 @@ import {
   getFirstHydratableChildWithinContainer,
   getFirstHydratableChildWithinSuspenseInstance,
   hydrateInstance,
+  diffHydratedPropsForDevWarnings,
+  describeHydratableInstanceForDevWarnings,
   hydrateTextInstance,
+  diffHydratedTextForDevWarnings,
   hydrateSuspenseInstance,
   getNextHydratableInstanceAfterSuspenseInstance,
   shouldDeleteUnhydratedTailInstances,
-  didNotMatchHydratedContainerTextInstance,
-  didNotMatchHydratedTextInstance,
-  didNotHydrateInstanceWithinContainer,
-  didNotHydrateInstanceWithinSuspenseInstance,
-  didNotHydrateInstance,
-  didNotFindHydratableInstanceWithinContainer,
-  didNotFindHydratableTextInstanceWithinContainer,
-  didNotFindHydratableSuspenseInstanceWithinContainer,
-  didNotFindHydratableInstanceWithinSuspenseInstance,
-  didNotFindHydratableTextInstanceWithinSuspenseInstance,
-  didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,
-  didNotFindHydratableInstance,
-  didNotFindHydratableTextInstance,
-  didNotFindHydratableSuspenseInstance,
   resolveSingletonInstance,
   canHydrateInstance,
   canHydrateTextInstance,
@@ -141,36 +130,103 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   return true;
 }
 
+function warnForDeletedHydratableInstance(
+  parentType: string,
+  child: HydratableInstance,
+) {
+  if (__DEV__) {
+    const description = describeHydratableInstanceForDevWarnings(child);
+    if (typeof description === 'string') {
+      console.error(
+        'Did not expect server HTML to contain the text node "%s" in <%s>.',
+        description,
+        parentType,
+      );
+    } else {
+      console.error(
+        'Did not expect server HTML to contain a <%s> in <%s>.',
+        description.type,
+        parentType,
+      );
+    }
+  }
+}
+
+function warnForInsertedHydratedElement(parentType: string, tag: string) {
+  if (__DEV__) {
+    console.error(
+      'Expected server HTML to contain a matching <%s> in <%s>.',
+      tag,
+      parentType,
+    );
+  }
+}
+
+function warnForInsertedHydratedText(parentType: string, text: string) {
+  if (__DEV__) {
+    console.error(
+      'Expected server HTML to contain a matching text node for "%s" in <%s>.',
+      text,
+      parentType,
+    );
+  }
+}
+
+function warnForInsertedHydratedSuspense(parentType: string) {
+  if (__DEV__) {
+    console.error(
+      'Expected server HTML to contain a matching <%s> in <%s>.',
+      'Suspense',
+      parentType,
+    );
+  }
+}
+
+export function errorHydratingContainer(parentContainer: Container): void {
+  if (__DEV__) {
+    // TODO: This gets logged by onRecoverableError, too, so we should be
+    // able to remove it.
+    console.error(
+      'An error occurred during hydration. The server HTML was replaced with client content.',
+    );
+  }
+}
+
 function warnUnhydratedInstance(
   returnFiber: Fiber,
   instance: HydratableInstance,
 ) {
   if (__DEV__) {
+    if (didWarnInvalidHydration) {
+      return;
+    }
+    didWarnInvalidHydration = true;
+
     switch (returnFiber.tag) {
       case HostRoot: {
-        didNotHydrateInstanceWithinContainer(
-          returnFiber.stateNode.containerInfo,
-          instance,
-        );
+        const description = describeHydratableInstanceForDevWarnings(instance);
+        if (typeof description === 'string') {
+          console.error(
+            'Did not expect server HTML to contain the text node "%s" in the root.',
+            description,
+          );
+        } else {
+          console.error(
+            'Did not expect server HTML to contain a <%s> in the root.',
+            description.type,
+          );
+        }
         break;
       }
       case HostSingleton:
       case HostComponent: {
-        didNotHydrateInstance(
-          returnFiber.type,
-          returnFiber.memoizedProps,
-          returnFiber.stateNode,
-          instance,
-        );
+        warnForDeletedHydratableInstance(returnFiber.type, instance);
         break;
       }
       case SuspenseComponent: {
         const suspenseState: SuspenseState = returnFiber.memoizedState;
         if (suspenseState.dehydrated !== null)
-          didNotHydrateInstanceWithinSuspenseInstance(
-            suspenseState.dehydrated,
-            instance,
-          );
+          warnForDeletedHydratableInstance('Suspense', instance);
         break;
       }
     }
@@ -186,30 +242,33 @@ function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
       return;
     }
 
+    if (didWarnInvalidHydration) {
+      return;
+    }
+    didWarnInvalidHydration = true;
+
     switch (returnFiber.tag) {
       case HostRoot: {
-        const parentContainer = returnFiber.stateNode.containerInfo;
+        // const parentContainer = returnFiber.stateNode.containerInfo;
         switch (fiber.tag) {
           case HostSingleton:
           case HostComponent:
-            const type = fiber.type;
-            const props = fiber.pendingProps;
-            didNotFindHydratableInstanceWithinContainer(
-              parentContainer,
-              type,
-              props,
+            console.error(
+              'Expected server HTML to contain a matching <%s> in the root.',
+              fiber.type,
             );
             break;
           case HostText:
             const text = fiber.pendingProps;
-            didNotFindHydratableTextInstanceWithinContainer(
-              parentContainer,
+            console.error(
+              'Expected server HTML to contain a matching text node for "%s" in the root.',
               text,
             );
             break;
           case SuspenseComponent:
-            didNotFindHydratableSuspenseInstanceWithinContainer(
-              parentContainer,
+            console.error(
+              'Expected server HTML to contain a matching <%s> in the root.',
+              'Suspense',
             );
             break;
         }
@@ -218,71 +277,44 @@ function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
       case HostSingleton:
       case HostComponent: {
         const parentType = returnFiber.type;
-        const parentProps = returnFiber.memoizedProps;
-        const parentInstance = returnFiber.stateNode;
+        // const parentProps = returnFiber.memoizedProps;
+        // const parentInstance = returnFiber.stateNode;
         switch (fiber.tag) {
           case HostSingleton:
           case HostComponent: {
             const type = fiber.type;
-            const props = fiber.pendingProps;
-            didNotFindHydratableInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-              type,
-              props,
-            );
+            warnForInsertedHydratedElement(parentType, type);
             break;
           }
           case HostText: {
             const text = fiber.pendingProps;
-            didNotFindHydratableTextInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-              text,
-            );
+            warnForInsertedHydratedText(parentType, text);
             break;
           }
           case SuspenseComponent: {
-            didNotFindHydratableSuspenseInstance(
-              parentType,
-              parentProps,
-              parentInstance,
-            );
+            warnForInsertedHydratedSuspense(parentType);
             break;
           }
         }
         break;
       }
       case SuspenseComponent: {
-        const suspenseState: SuspenseState = returnFiber.memoizedState;
-        const parentInstance = suspenseState.dehydrated;
-        if (parentInstance !== null)
-          switch (fiber.tag) {
-            case HostSingleton:
-            case HostComponent:
-              const type = fiber.type;
-              const props = fiber.pendingProps;
-              didNotFindHydratableInstanceWithinSuspenseInstance(
-                parentInstance,
-                type,
-                props,
-              );
-              break;
-            case HostText:
-              const text = fiber.pendingProps;
-              didNotFindHydratableTextInstanceWithinSuspenseInstance(
-                parentInstance,
-                text,
-              );
-              break;
-            case SuspenseComponent:
-              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(
-                parentInstance,
-              );
-              break;
-          }
+        // const suspenseState: SuspenseState = returnFiber.memoizedState;
+        // const parentInstance = suspenseState.dehydrated;
+        switch (fiber.tag) {
+          case HostSingleton:
+          case HostComponent:
+            const type = fiber.type;
+            warnForInsertedHydratedElement('Suspense', type);
+            break;
+          case HostText:
+            const text = fiber.pendingProps;
+            warnForInsertedHydratedText('Suspense', text);
+            break;
+          case SuspenseComponent:
+            warnForInsertedHydratedSuspense('Suspense');
+            break;
+        }
         break;
       }
       default:
@@ -465,6 +497,9 @@ export function tryToClaimNextHydratableFormMarkerInstance(
   return false;
 }
 
+// Temp
+let didWarnInvalidHydration = false;
+
 function prepareToHydrateHostInstance(
   fiber: Fiber,
   hostContext: HostContext,
@@ -477,15 +512,63 @@ function prepareToHydrateHostInstance(
   }
 
   const instance: Instance = fiber.stateNode;
-  const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-  hydrateInstance(
+  if (__DEV__) {
+    const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
+    if (shouldWarnIfMismatchDev) {
+      const differences = diffHydratedPropsForDevWarnings(
+        instance,
+        fiber.type,
+        fiber.memoizedProps,
+        hostContext,
+      );
+      if (differences !== null) {
+        if (differences.children != null && !didWarnInvalidHydration) {
+          didWarnInvalidHydration = true;
+          const serverValue = differences.children;
+          const clientValue = fiber.memoizedProps.children;
+          console.error(
+            'Text content did not match. Server: "%s" Client: "%s"',
+            serverValue,
+            clientValue,
+          );
+        }
+        for (const propName in differences) {
+          if (!differences.hasOwnProperty(propName)) {
+            continue;
+          }
+          if (didWarnInvalidHydration) {
+            break;
+          }
+          didWarnInvalidHydration = true;
+          const serverValue = differences[propName];
+          const clientValue = fiber.memoizedProps[propName];
+          if (propName === 'children') {
+            // Already handled above
+          } else if (clientValue != null) {
+            console.error(
+              'Prop `%s` did not match. Server: %s Client: %s',
+              propName,
+              JSON.stringify(serverValue),
+              JSON.stringify(clientValue),
+            );
+          } else {
+            console.error('Extra attribute from the server: %s', propName);
+          }
+        }
+      }
+    }
+  }
+
+  const didHydrate = hydrateInstance(
     instance,
     fiber.type,
     fiber.memoizedProps,
     hostContext,
     fiber,
-    shouldWarnIfMismatchDev,
   );
+  if (!didHydrate) {
+    throw new Error('Text content does not match server-rendered HTML.');
+  }
 }
 
 function prepareToHydrateHostTextInstance(fiber: Fiber): void {
@@ -499,45 +582,66 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
   const textInstance: TextInstance = fiber.stateNode;
   const textContent: string = fiber.memoizedProps;
   const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-  const textIsDifferent = hydrateTextInstance(
-    textInstance,
-    textContent,
-    fiber,
-    shouldWarnIfMismatchDev,
-  );
-  if (textIsDifferent) {
-    // We assume that prepareToHydrateHostTextInstance is called in a context where the
-    // hydration parent is the parent host component of this host text.
-    const returnFiber = hydrationParentFiber;
-    if (returnFiber !== null) {
-      switch (returnFiber.tag) {
-        case HostRoot: {
-          const parentContainer = returnFiber.stateNode.containerInfo;
-          didNotMatchHydratedContainerTextInstance(
-            parentContainer,
-            textInstance,
-            textContent,
-            shouldWarnIfMismatchDev,
-          );
-          break;
+  let parentProps = null;
+  // We assume that prepareToHydrateHostTextInstance is called in a context where the
+  // hydration parent is the parent host component of this host text.
+  const returnFiber = hydrationParentFiber;
+  if (returnFiber !== null) {
+    switch (returnFiber.tag) {
+      case HostRoot: {
+        if (__DEV__) {
+          if (shouldWarnIfMismatchDev) {
+            const difference = diffHydratedTextForDevWarnings(
+              textInstance,
+              textContent,
+              parentProps,
+            );
+            if (difference !== null && !didWarnInvalidHydration) {
+              didWarnInvalidHydration = true;
+              console.error(
+                'Text content did not match. Server: "%s" Client: "%s"',
+                difference,
+                textContent,
+              );
+            }
+          }
         }
-        case HostSingleton:
-        case HostComponent: {
-          const parentType = returnFiber.type;
-          const parentProps = returnFiber.memoizedProps;
-          const parentInstance = returnFiber.stateNode;
-          didNotMatchHydratedTextInstance(
-            parentType,
-            parentProps,
-            parentInstance,
-            textInstance,
-            textContent,
-            shouldWarnIfMismatchDev,
-          );
-          break;
+        break;
+      }
+      case HostSingleton:
+      case HostComponent: {
+        parentProps = returnFiber.memoizedProps;
+        if (__DEV__) {
+          if (shouldWarnIfMismatchDev) {
+            const difference = diffHydratedTextForDevWarnings(
+              textInstance,
+              textContent,
+              parentProps,
+            );
+            if (difference !== null && !didWarnInvalidHydration) {
+              didWarnInvalidHydration = true;
+              console.error(
+                'Text content did not match. Server: "%s" Client: "%s"',
+                difference,
+                textContent,
+              );
+            }
+          }
         }
+        break;
       }
     }
+    // TODO: What if it's a SuspenseInstance?
+  }
+
+  const didHydrate = hydrateTextInstance(
+    textInstance,
+    textContent,
+    fiber,
+    parentProps,
+  );
+  if (!didHydrate) {
+    throw new Error('Text content does not match server-rendered HTML.');
   }
 }
 

commit f7aa5e0aa3e2aa51279af4b6cb5413912cacd7f5
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 17:01:41 2024 -0700

    Move Hydration Mismatch Errors to Throw or Log Once (Kind of) (#28502)
    
    Stacked on #28476.
    
    We used to `console.error` for every mismatch we found, up until the
    error we threw for the hydration mismatch.
    
    This changes it so that we build up a set of diffs up until we either
    throw or complete hydrating the root/suspense boundary. If we throw, we
    append the diff to the error message which gets passed to
    onRecoverableError (which by default is also logged to console). If we
    complete, we append it to a `console.error`.
    
    Since we early abort when something throws, it effectively means that we
    can only collect multiple diffs if there were preceding non-throwing
    mismatches - i.e. only properties mismatched but tag name matched.
    
    There can still be multiple logs if multiple siblings Suspense
    boundaries all error hydrating but then they're separate errors
    entirely.
    
    We still log an extra line about something erroring but I think the goal
    should be that it leads to a single recoverable or console.error.
    
    This doesn't yet actually print the diff as part of this message. That's
    in a follow up PR.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 49171baf1c..a25dee709a 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -19,11 +19,11 @@ import type {
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {TreeContext} from './ReactFiberTreeContext';
 import type {CapturedValue} from './ReactCapturedValue';
+import type {HydrationDiffNode} from './ReactFiberHydrationDiffs';
 
 import {
   HostComponent,
   HostSingleton,
-  HostText,
   HostRoot,
   SuspenseComponent,
 } from './ReactWorkTags';
@@ -61,6 +61,7 @@ import {
 } from './ReactFiberTreeContext';
 import {queueRecoverableErrors} from './ReactFiberWorkLoop';
 import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
+import {describeDiff} from './ReactFiberHydrationDiffs';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -72,11 +73,50 @@ let isHydrating: boolean = false;
 // due to earlier mismatches or a suspended fiber.
 let didSuspendOrErrorDEV: boolean = false;
 
+// Hydration differences found that haven't yet been logged.
+let hydrationDiffRootDEV: null | HydrationDiffNode = null;
+
 // Hydration errors that were thrown inside this boundary
 let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
 
 let rootOrSingletonContext = false;
 
+// Builds a common ancestor tree from the root down for collecting diffs.
+function buildHydrationDiffNode(fiber: Fiber): HydrationDiffNode {
+  if (fiber.return === null) {
+    // We're at the root.
+    if (hydrationDiffRootDEV === null) {
+      hydrationDiffRootDEV = {
+        fiber: fiber,
+        children: [],
+        serverProps: undefined,
+        serverTail: [],
+      };
+    } else if (hydrationDiffRootDEV.fiber !== fiber) {
+      throw new Error(
+        'Saw multiple hydration diff roots in a pass. This is a bug in React.',
+      );
+    }
+    return hydrationDiffRootDEV;
+  }
+  const siblings = buildHydrationDiffNode(fiber.return).children;
+  // The same node may already exist in the parent. Since we currently always render depth first
+  // and rerender if we suspend or terminate early, if a shared ancestor was added we should still
+  // be inside of that shared ancestor which means it was the last one to be added. If this changes
+  // we may have to scan the whole set.
+  if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {
+    return siblings[siblings.length - 1];
+  }
+  const newNode: HydrationDiffNode = {
+    fiber: fiber,
+    children: [],
+    serverProps: undefined,
+    serverTail: [],
+  };
+  siblings.push(newNode);
+  return newNode;
+}
+
 function warnIfHydrating() {
   if (__DEV__) {
     if (isHydrating) {
@@ -105,6 +145,7 @@ function enterHydrationState(fiber: Fiber): boolean {
   isHydrating = true;
   hydrationErrors = null;
   didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
   rootOrSingletonContext = true;
   return true;
 }
@@ -123,6 +164,7 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   isHydrating = true;
   hydrationErrors = null;
   didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
   rootOrSingletonContext = false;
   if (treeContext !== null) {
     restoreSuspendedTreeContext(fiber, treeContext);
@@ -130,58 +172,6 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   return true;
 }
 
-function warnForDeletedHydratableInstance(
-  parentType: string,
-  child: HydratableInstance,
-) {
-  if (__DEV__) {
-    const description = describeHydratableInstanceForDevWarnings(child);
-    if (typeof description === 'string') {
-      console.error(
-        'Did not expect server HTML to contain the text node "%s" in <%s>.',
-        description,
-        parentType,
-      );
-    } else {
-      console.error(
-        'Did not expect server HTML to contain a <%s> in <%s>.',
-        description.type,
-        parentType,
-      );
-    }
-  }
-}
-
-function warnForInsertedHydratedElement(parentType: string, tag: string) {
-  if (__DEV__) {
-    console.error(
-      'Expected server HTML to contain a matching <%s> in <%s>.',
-      tag,
-      parentType,
-    );
-  }
-}
-
-function warnForInsertedHydratedText(parentType: string, text: string) {
-  if (__DEV__) {
-    console.error(
-      'Expected server HTML to contain a matching text node for "%s" in <%s>.',
-      text,
-      parentType,
-    );
-  }
-}
-
-function warnForInsertedHydratedSuspense(parentType: string) {
-  if (__DEV__) {
-    console.error(
-      'Expected server HTML to contain a matching <%s> in <%s>.',
-      'Suspense',
-      parentType,
-    );
-  }
-}
-
 export function errorHydratingContainer(parentContainer: Container): void {
   if (__DEV__) {
     // TODO: This gets logged by onRecoverableError, too, so we should be
@@ -192,48 +182,7 @@ export function errorHydratingContainer(parentContainer: Container): void {
   }
 }
 
-function warnUnhydratedInstance(
-  returnFiber: Fiber,
-  instance: HydratableInstance,
-) {
-  if (__DEV__) {
-    if (didWarnInvalidHydration) {
-      return;
-    }
-    didWarnInvalidHydration = true;
-
-    switch (returnFiber.tag) {
-      case HostRoot: {
-        const description = describeHydratableInstanceForDevWarnings(instance);
-        if (typeof description === 'string') {
-          console.error(
-            'Did not expect server HTML to contain the text node "%s" in the root.',
-            description,
-          );
-        } else {
-          console.error(
-            'Did not expect server HTML to contain a <%s> in the root.',
-            description.type,
-          );
-        }
-        break;
-      }
-      case HostSingleton:
-      case HostComponent: {
-        warnForDeletedHydratableInstance(returnFiber.type, instance);
-        break;
-      }
-      case SuspenseComponent: {
-        const suspenseState: SuspenseState = returnFiber.memoizedState;
-        if (suspenseState.dehydrated !== null)
-          warnForDeletedHydratableInstance('Suspense', instance);
-        break;
-      }
-    }
-  }
-}
-
-function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
+function warnNonHydratedInstance(fiber: Fiber) {
   if (__DEV__) {
     if (didSuspendOrErrorDEV) {
       // Inside a boundary that already suspended. We're currently rendering the
@@ -242,84 +191,10 @@ function warnNonHydratedInstance(returnFiber: Fiber, fiber: Fiber) {
       return;
     }
 
-    if (didWarnInvalidHydration) {
-      return;
-    }
-    didWarnInvalidHydration = true;
-
-    switch (returnFiber.tag) {
-      case HostRoot: {
-        // const parentContainer = returnFiber.stateNode.containerInfo;
-        switch (fiber.tag) {
-          case HostSingleton:
-          case HostComponent:
-            console.error(
-              'Expected server HTML to contain a matching <%s> in the root.',
-              fiber.type,
-            );
-            break;
-          case HostText:
-            const text = fiber.pendingProps;
-            console.error(
-              'Expected server HTML to contain a matching text node for "%s" in the root.',
-              text,
-            );
-            break;
-          case SuspenseComponent:
-            console.error(
-              'Expected server HTML to contain a matching <%s> in the root.',
-              'Suspense',
-            );
-            break;
-        }
-        break;
-      }
-      case HostSingleton:
-      case HostComponent: {
-        const parentType = returnFiber.type;
-        // const parentProps = returnFiber.memoizedProps;
-        // const parentInstance = returnFiber.stateNode;
-        switch (fiber.tag) {
-          case HostSingleton:
-          case HostComponent: {
-            const type = fiber.type;
-            warnForInsertedHydratedElement(parentType, type);
-            break;
-          }
-          case HostText: {
-            const text = fiber.pendingProps;
-            warnForInsertedHydratedText(parentType, text);
-            break;
-          }
-          case SuspenseComponent: {
-            warnForInsertedHydratedSuspense(parentType);
-            break;
-          }
-        }
-        break;
-      }
-      case SuspenseComponent: {
-        // const suspenseState: SuspenseState = returnFiber.memoizedState;
-        // const parentInstance = suspenseState.dehydrated;
-        switch (fiber.tag) {
-          case HostSingleton:
-          case HostComponent:
-            const type = fiber.type;
-            warnForInsertedHydratedElement('Suspense', type);
-            break;
-          case HostText:
-            const text = fiber.pendingProps;
-            warnForInsertedHydratedText('Suspense', text);
-            break;
-          case SuspenseComponent:
-            warnForInsertedHydratedSuspense('Suspense');
-            break;
-        }
-        break;
-      }
-      default:
-        return;
-    }
+    // Add this fiber to the diff tree.
+    const diffNode = buildHydrationDiffNode(fiber);
+    // We use null as a signal that there was no node to match.
+    diffNode.serverProps = null;
   }
 }
 
@@ -390,9 +265,29 @@ function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
 }
 
 function throwOnHydrationMismatch(fiber: Fiber) {
+  let diff = '';
+  if (__DEV__) {
+    // Consume the diff root for this mismatch.
+    // Any other errors will get their own diffs.
+    const diffRoot = hydrationDiffRootDEV;
+    if (diffRoot !== null) {
+      hydrationDiffRootDEV = null;
+      diff = describeDiff(diffRoot);
+    }
+  }
   throw new Error(
-    'Hydration failed because the initial UI does not match what was ' +
-      'rendered on the server.',
+    "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n" +
+      '\n' +
+      "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+      "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+      "- Date formatting in a user's locale which doesn't match the server.\n" +
+      '- External changing data without sending a snapshot of it along with the HTML.\n' +
+      '- Invalid HTML tag nesting.\n' +
+      '\n' +
+      'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+      '\n' +
+      'https://react.dev/link/hydration-mismatch' +
+      diff,
   );
 }
 
@@ -432,7 +327,7 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !tryHydrateInstance(fiber, nextInstance)) {
     if (shouldKeepWarning) {
-      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      warnNonHydratedInstance(fiber);
     }
     throwOnHydrationMismatch(fiber);
   }
@@ -452,7 +347,7 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {
     if (shouldKeepWarning) {
-      warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+      warnNonHydratedInstance(fiber);
     }
     throwOnHydrationMismatch(fiber);
   }
@@ -464,7 +359,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {
-    warnNonHydratedInstance((hydrationParentFiber: any), fiber);
+    warnNonHydratedInstance(fiber);
     throwOnHydrationMismatch(fiber);
   }
 }
@@ -497,9 +392,6 @@ export function tryToClaimNextHydratableFormMarkerInstance(
   return false;
 }
 
-// Temp
-let didWarnInvalidHydration = false;
-
 function prepareToHydrateHostInstance(
   fiber: Fiber,
   hostContext: HostContext,
@@ -522,39 +414,8 @@ function prepareToHydrateHostInstance(
         hostContext,
       );
       if (differences !== null) {
-        if (differences.children != null && !didWarnInvalidHydration) {
-          didWarnInvalidHydration = true;
-          const serverValue = differences.children;
-          const clientValue = fiber.memoizedProps.children;
-          console.error(
-            'Text content did not match. Server: "%s" Client: "%s"',
-            serverValue,
-            clientValue,
-          );
-        }
-        for (const propName in differences) {
-          if (!differences.hasOwnProperty(propName)) {
-            continue;
-          }
-          if (didWarnInvalidHydration) {
-            break;
-          }
-          didWarnInvalidHydration = true;
-          const serverValue = differences[propName];
-          const clientValue = fiber.memoizedProps[propName];
-          if (propName === 'children') {
-            // Already handled above
-          } else if (clientValue != null) {
-            console.error(
-              'Prop `%s` did not match. Server: %s Client: %s',
-              propName,
-              JSON.stringify(serverValue),
-              JSON.stringify(clientValue),
-            );
-          } else {
-            console.error('Extra attribute from the server: %s', propName);
-          }
-        }
+        const diffNode = buildHydrationDiffNode(fiber);
+        diffNode.serverProps = differences;
       }
     }
   }
@@ -567,7 +428,7 @@ function prepareToHydrateHostInstance(
     fiber,
   );
   if (!didHydrate) {
-    throw new Error('Text content does not match server-rendered HTML.');
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -596,13 +457,9 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
               textContent,
               parentProps,
             );
-            if (difference !== null && !didWarnInvalidHydration) {
-              didWarnInvalidHydration = true;
-              console.error(
-                'Text content did not match. Server: "%s" Client: "%s"',
-                difference,
-                textContent,
-              );
+            if (difference !== null) {
+              const diffNode = buildHydrationDiffNode(fiber);
+              diffNode.serverProps = difference;
             }
           }
         }
@@ -618,13 +475,9 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
               textContent,
               parentProps,
             );
-            if (difference !== null && !didWarnInvalidHydration) {
-              didWarnInvalidHydration = true;
-              console.error(
-                'Text content did not match. Server: "%s" Client: "%s"',
-                difference,
-                textContent,
-              );
+            if (difference !== null) {
+              const diffNode = buildHydrationDiffNode(fiber);
+              diffNode.serverProps = difference;
             }
           }
         }
@@ -641,7 +494,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
     parentProps,
   );
   if (!didHydrate) {
-    throw new Error('Text content does not match server-rendered HTML.');
+    throwOnHydrationMismatch(fiber);
   }
 }
 
@@ -774,10 +627,15 @@ function popHydrationState(fiber: Fiber): boolean {
 }
 
 function warnIfUnhydratedTailNodes(fiber: Fiber) {
-  let nextInstance = nextHydratableInstance;
-  while (nextInstance) {
-    warnUnhydratedInstance(fiber, nextInstance);
-    nextInstance = getNextHydratableSibling(nextInstance);
+  if (__DEV__) {
+    let nextInstance = nextHydratableInstance;
+    while (nextInstance) {
+      const diffNode = buildHydrationDiffNode(fiber);
+      const description =
+        describeHydratableInstanceForDevWarnings(nextInstance);
+      diffNode.serverTail.push(description);
+      nextInstance = getNextHydratableSibling(nextInstance);
+    }
   }
 }
 
@@ -814,6 +672,34 @@ export function queueHydrationError(error: CapturedValue<mixed>): void {
   }
 }
 
+export function emitPendingHydrationWarnings() {
+  if (__DEV__) {
+    // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully
+    // hydrated, however, we might still have DEV-only mismatches that we log now.
+    const diffRoot = hydrationDiffRootDEV;
+    if (diffRoot !== null) {
+      hydrationDiffRootDEV = null;
+      const diff = describeDiff(diffRoot);
+      console.error(
+        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
+          'This can happen if a SSR-ed Client Component used:\n' +
+          '\n' +
+          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+          "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+          "- Date formatting in a user's locale which doesn't match the server.\n" +
+          '- External changing data without sending a snapshot of it along with the HTML.\n' +
+          '- Invalid HTML tag nesting.\n' +
+          '\n' +
+          'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+          '\n' +
+          '%s%s',
+        'https://react.dev/link/hydration-mismatch',
+        diff,
+      );
+    }
+  }
+}
+
 export {
   warnIfHydrating,
   enterHydrationState,

commit 2ec2aaea98588178525f83495669e11e96815a00
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 17:02:18 2024 -0700

    Add Diffs to Hydration Warnings (#28512)
    
    Stacked on #28502.
    
    This builds on the mechanism in #28502 by adding a diff of everything
    we've collected so far to the thrown error or logged error.
    
    This isn't actually a longest common subsequence diff. This means that
    there are certain cases that can appear confusing such as a node being
    added/removed when it really would've appeared later in the list. In
    fact once a node mismatches, we abort rendering so we don't have the
    context of what would've been rendered. It's not quite right to use the
    result of the recovery render because it can use client-only code paths
    using useSyncExternalStore which would yield false differences. That's
    why diffing the HTML isn't quite right.
    
    I also present abstract components in the stack, these are presented
    with the client props and no diff since we don't have the props that
    were on the server. The lack of difference might be confusing but it's
    useful for context.
    
    The main thing that's data new here is that we're adding some siblings
    and props for context.
    
    Examples in the [snapshot
    commit](https://github.com/facebook/react/pull/28512/commits/e14532fd8df858a319d3eca687d83227209a498c).

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index a25dee709a..2ddc7d2514 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -82,7 +82,10 @@ let hydrationErrors: Array<CapturedValue<mixed>> | null = null;
 let rootOrSingletonContext = false;
 
 // Builds a common ancestor tree from the root down for collecting diffs.
-function buildHydrationDiffNode(fiber: Fiber): HydrationDiffNode {
+function buildHydrationDiffNode(
+  fiber: Fiber,
+  distanceFromLeaf: number,
+): HydrationDiffNode {
   if (fiber.return === null) {
     // We're at the root.
     if (hydrationDiffRootDEV === null) {
@@ -91,27 +94,38 @@ function buildHydrationDiffNode(fiber: Fiber): HydrationDiffNode {
         children: [],
         serverProps: undefined,
         serverTail: [],
+        distanceFromLeaf: distanceFromLeaf,
       };
     } else if (hydrationDiffRootDEV.fiber !== fiber) {
       throw new Error(
         'Saw multiple hydration diff roots in a pass. This is a bug in React.',
       );
+    } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {
+      hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;
     }
     return hydrationDiffRootDEV;
   }
-  const siblings = buildHydrationDiffNode(fiber.return).children;
+  const siblings = buildHydrationDiffNode(
+    fiber.return,
+    distanceFromLeaf + 1,
+  ).children;
   // The same node may already exist in the parent. Since we currently always render depth first
   // and rerender if we suspend or terminate early, if a shared ancestor was added we should still
   // be inside of that shared ancestor which means it was the last one to be added. If this changes
   // we may have to scan the whole set.
   if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {
-    return siblings[siblings.length - 1];
+    const existing = siblings[siblings.length - 1];
+    if (existing.distanceFromLeaf > distanceFromLeaf) {
+      existing.distanceFromLeaf = distanceFromLeaf;
+    }
+    return existing;
   }
   const newNode: HydrationDiffNode = {
     fiber: fiber,
     children: [],
     serverProps: undefined,
     serverTail: [],
+    distanceFromLeaf: distanceFromLeaf,
   };
   siblings.push(newNode);
   return newNode;
@@ -182,7 +196,10 @@ export function errorHydratingContainer(parentContainer: Container): void {
   }
 }
 
-function warnNonHydratedInstance(fiber: Fiber) {
+function warnNonHydratedInstance(
+  fiber: Fiber,
+  rejectedCandidate: null | HydratableInstance,
+) {
   if (__DEV__) {
     if (didSuspendOrErrorDEV) {
       // Inside a boundary that already suspended. We're currently rendering the
@@ -192,13 +209,22 @@ function warnNonHydratedInstance(fiber: Fiber) {
     }
 
     // Add this fiber to the diff tree.
-    const diffNode = buildHydrationDiffNode(fiber);
+    const diffNode = buildHydrationDiffNode(fiber, 0);
     // We use null as a signal that there was no node to match.
     diffNode.serverProps = null;
+    if (rejectedCandidate !== null) {
+      const description =
+        describeHydratableInstanceForDevWarnings(rejectedCandidate);
+      diffNode.serverTail.push(description);
+    }
   }
 }
 
-function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
+function tryHydrateInstance(
+  fiber: Fiber,
+  nextInstance: any,
+  hostContext: HostContext,
+) {
   // fiber is a HostComponent Fiber
   const instance = canHydrateInstance(
     nextInstance,
@@ -208,6 +234,22 @@ function tryHydrateInstance(fiber: Fiber, nextInstance: any) {
   );
   if (instance !== null) {
     fiber.stateNode = (instance: Instance);
+
+    if (__DEV__) {
+      if (!didSuspendOrErrorDEV) {
+        const differences = diffHydratedPropsForDevWarnings(
+          instance,
+          fiber.type,
+          fiber.pendingProps,
+          hostContext,
+        );
+        if (differences !== null) {
+          const diffNode = buildHydrationDiffNode(fiber, 0);
+          diffNode.serverProps = differences;
+        }
+      }
+    }
+
     hydrationParentFiber = fiber;
     nextHydratableInstance = getFirstHydratableChild(instance);
     rootOrSingletonContext = false;
@@ -305,6 +347,22 @@ function claimHydratableSingleton(fiber: Fiber): void {
       currentHostContext,
       false,
     ));
+
+    if (__DEV__) {
+      if (!didSuspendOrErrorDEV) {
+        const differences = diffHydratedPropsForDevWarnings(
+          instance,
+          fiber.type,
+          fiber.pendingProps,
+          currentHostContext,
+        );
+        if (differences !== null) {
+          const diffNode = buildHydrationDiffNode(fiber, 0);
+          diffNode.serverProps = differences;
+        }
+      }
+    }
+
     hydrationParentFiber = fiber;
     rootOrSingletonContext = true;
     nextHydratableInstance = getFirstHydratableChild(instance);
@@ -325,9 +383,12 @@ function tryToClaimNextHydratableInstance(fiber: Fiber): void {
   );
 
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance || !tryHydrateInstance(fiber, nextInstance)) {
+  if (
+    !nextInstance ||
+    !tryHydrateInstance(fiber, nextInstance, currentHostContext)
+  ) {
     if (shouldKeepWarning) {
-      warnNonHydratedInstance(fiber);
+      warnNonHydratedInstance(fiber, nextInstance);
     }
     throwOnHydrationMismatch(fiber);
   }
@@ -347,7 +408,7 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {
     if (shouldKeepWarning) {
-      warnNonHydratedInstance(fiber);
+      warnNonHydratedInstance(fiber, nextInstance);
     }
     throwOnHydrationMismatch(fiber);
   }
@@ -359,7 +420,7 @@ function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
   }
   const nextInstance = nextHydratableInstance;
   if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {
-    warnNonHydratedInstance(fiber);
+    warnNonHydratedInstance(fiber, nextInstance);
     throwOnHydrationMismatch(fiber);
   }
 }
@@ -404,22 +465,6 @@ function prepareToHydrateHostInstance(
   }
 
   const instance: Instance = fiber.stateNode;
-  if (__DEV__) {
-    const shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
-    if (shouldWarnIfMismatchDev) {
-      const differences = diffHydratedPropsForDevWarnings(
-        instance,
-        fiber.type,
-        fiber.memoizedProps,
-        hostContext,
-      );
-      if (differences !== null) {
-        const diffNode = buildHydrationDiffNode(fiber);
-        diffNode.serverProps = differences;
-      }
-    }
-  }
-
   const didHydrate = hydrateInstance(
     instance,
     fiber.type,
@@ -458,7 +503,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
               parentProps,
             );
             if (difference !== null) {
-              const diffNode = buildHydrationDiffNode(fiber);
+              const diffNode = buildHydrationDiffNode(fiber, 0);
               diffNode.serverProps = difference;
             }
           }
@@ -476,7 +521,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
               parentProps,
             );
             if (difference !== null) {
-              const diffNode = buildHydrationDiffNode(fiber);
+              const diffNode = buildHydrationDiffNode(fiber, 0);
               diffNode.serverProps = difference;
             }
           }
@@ -630,11 +675,17 @@ function warnIfUnhydratedTailNodes(fiber: Fiber) {
   if (__DEV__) {
     let nextInstance = nextHydratableInstance;
     while (nextInstance) {
-      const diffNode = buildHydrationDiffNode(fiber);
+      const diffNode = buildHydrationDiffNode(fiber, 0);
       const description =
         describeHydratableInstanceForDevWarnings(nextInstance);
       diffNode.serverTail.push(description);
-      nextInstance = getNextHydratableSibling(nextInstance);
+      if (description.type === 'Suspense') {
+        const suspenseInstance: SuspenseInstance = (nextInstance: any);
+        nextInstance =
+          getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
+      } else {
+        nextInstance = getNextHydratableSibling(nextInstance);
+      }
     }
   }
 }

commit 5910eb34567a8699d1faa73b546baafd94f26411
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Mar 26 19:52:46 2024 -0700

    Add Flag to Favor Hydration Performance over User Safety (#28655)
    
    If false, this ignores text comparison checks during hydration at the
    risk of privacy safety.
    
    Since React 18 we recreate the DOM starting from the nearest Suspense
    boundary if any of the text content mismatches. This ensures that if we
    have nodes that otherwise line up correctly such as if they're the same
    type of Component but in a different order, then we don't accidentally
    transfer state or attributes to the wrong one.
    
    If we didn't do this e.g. attributes like image src might not line up
    with the text. E.g. you might show the wrong profile picture with the
    wrong name. However, the main reason we do this is because it's a
    security/privacy concern if state from the original node can transfer to
    the other one. For example if you start typing into a text field to
    reply to a story but then it turns out that the hydration was in a
    different order, you might submit that text into a different story than
    you intended. Similarly, if you've already clicked an item and that gets
    replayed using Action replaying or is synchronously force hydrated -
    that click might end up applying to a different item in the list than
    you intended. E.g. liking the wrong photo.
    
    Unfortunately a common case where this happens is when Google Translate
    is applied to a page. It'll always cause mismatches and recreate the
    tree. Most of the time this wouldn't be visible to users because it'd
    just recreate to the same thing and then translate again. It can affect
    metrics that trace when this hydration happened though.
    
    Meta can use this flag to decide if they favor this perf metric over the
    risk to user privacy.
    
    This is similar to the old enableClientRenderFallbackOnTextMismatch flag
    except this flag doesn't patch up the text when there's a mismatch.
    Because we don't have the patching anymore. The assumption is that it is
    safe to ignore the safety concern because we assume it's a match and
    therefore favoring not patching it will lead to better perf.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 2ddc7d2514..ce7f4be96e 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -27,6 +27,7 @@ import {
   HostRoot,
   SuspenseComponent,
 } from './ReactWorkTags';
+import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
 
 import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
@@ -472,7 +473,7 @@ function prepareToHydrateHostInstance(
     hostContext,
     fiber,
   );
-  if (!didHydrate) {
+  if (!didHydrate && favorSafetyOverHydrationPerf) {
     throwOnHydrationMismatch(fiber);
   }
 }
@@ -538,7 +539,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
     fiber,
     parentProps,
   );
-  if (!didHydrate) {
+  if (!didHydrate && favorSafetyOverHydrationPerf) {
     throwOnHydrationMismatch(fiber);
   }
 }

commit 323b6e98a76fe6ee721f10d327a9a682334d1a97
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Mar 27 23:48:18 2024 -0400

    Remove errorHydratingContainer (#28664)
    
    I originally added this in #21021 but I didn't mention why and I don't
    quite remember why. Maybe because there were no other message? However
    at the time the recoverable errors mechanism didn't exist.
    
    Today I believe all cases where this happens will trigger another
    recoverable error. Namely these two:
    
    
    https://github.com/facebook/react/blob/9f33f699e4f832971dc0f2047129f832655a3b6d/packages/react-reconciler/src/ReactFiberBeginWork.js#L1442-L1446
    
    
    https://github.com/facebook/react/blob/9f33f699e4f832971dc0f2047129f832655a3b6d/packages/react-reconciler/src/ReactFiberBeginWork.js#L2962-L2965
    
    Therefore this is just an extra unnecessary log.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index ce7f4be96e..dcfc76db03 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -187,16 +187,6 @@ function reenterHydrationStateFromDehydratedSuspenseInstance(
   return true;
 }
 
-export function errorHydratingContainer(parentContainer: Container): void {
-  if (__DEV__) {
-    // TODO: This gets logged by onRecoverableError, too, so we should be
-    // able to remove it.
-    console.error(
-      'An error occurred during hydration. The server HTML was replaced with client content.',
-    );
-  }
-}
-
 function warnNonHydratedInstance(
   fiber: Fiber,
   rejectedCandidate: null | HydratableInstance,

commit 05797ccebd285999343ab4fb94eb542f84be23b1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Mar 28 11:34:24 2024 -0400

    s/form state/action state (#28631)
    
    Rename internals from "form state" to "action state"

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index dcfc76db03..e3fe81641c 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -439,7 +439,7 @@ export function tryToClaimNextHydratableFormMarkerInstance(
   }
   // Should have found a marker instance. Throw an error to trigger client
   // rendering. We don't bother to check if we're in a concurrent root because
-  // useFormState is a new API, so backwards compat is not an issue.
+  // useActionState is a new API, so backwards compat is not an issue.
   throwOnHydrationMismatch(fiber);
   return false;
 }

commit 6090cab099a8f7f373e04c7eb2937425a8f80f80
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 3 21:53:07 2024 -0400

    Use a Wrapper Error for onRecoverableError with a "cause" Field for the real Error (#28736)
    
    We basically have four kinds of recoverable errors:
    
    - Hydration mismatches.
    - Server errored but client didn't.
    - Hydration render errored but client render didn't (in Root or Suspense
    boundary).
    - Concurrent render errored but synchronous render didn't.
    
    For the first three we log an additional error that the root or Suspense
    boundary didn't error. This provides some context about what happened.
    However, the problem is that for hydration mismatches that's unnecessary
    extra context that is confusing. We also don't log any additional
    context for concurrent render errors that could recover. This used to be
    the only recoverable error so it didn't need extra context but now we
    need to distinguish them. When we log these to `reportError` it's
    confusing to just see the error because you didn't see anything error on
    the page. It's also hard to group them together as one.
    
    In this PR, I remove the unnecessary context for hydration mismatches.
    
    For hydration and concurrent errors, I now wrap them in an error that
    describes that what happened but then use the new `cause` field to link
    the original error so we can keep that as the cause. The error that
    happened was that hydration client rendered or you deopted to sync
    render, the cause of that error is some other error.
    
    For server errors, we control the Error object so I already had added
    some context to that error object's message. Since we hide the message
    in prod, it's nice not to have the raw message in DEV neither. We could
    potentially split these into two errors for parity though.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index e3fe81641c..1d2f69852a 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -29,6 +29,8 @@ import {
 } from './ReactWorkTags';
 import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
 
+import {createCapturedValueAtFiber} from './ReactCapturedValue';
+
 import {createFiberFromDehydratedFragment} from './ReactFiber';
 import {
   shouldSetTextContent,
@@ -297,6 +299,11 @@ function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
   return false;
 }
 
+export const HydrationMismatchException: mixed = new Error(
+  'Hydration Mismatch Exception: This is not a real error, and should not leak into ' +
+    "userspace. If you're seeing this, it's likely a bug in React.",
+);
+
 function throwOnHydrationMismatch(fiber: Fiber) {
   let diff = '';
   if (__DEV__) {
@@ -308,7 +315,7 @@ function throwOnHydrationMismatch(fiber: Fiber) {
       diff = describeDiff(diffRoot);
     }
   }
-  throw new Error(
+  const error = new Error(
     "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n" +
       '\n' +
       "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
@@ -322,6 +329,8 @@ function throwOnHydrationMismatch(fiber: Fiber) {
       'https://react.dev/link/hydration-mismatch' +
       diff,
   );
+  queueHydrationError(createCapturedValueAtFiber(error, fiber));
+  throw HydrationMismatchException;
 }
 
 function claimHydratableSingleton(fiber: Fiber): void {

commit 17520b638190a20e745fe53299813b29b52dfc4c
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Dec 18 23:53:54 2024 -0500

    [Fiber] Mark hydrated components in tertiary color (green) (#31829)
    
    This is a follow up to #31752.
    
    This keeps track in the commit phase whether this subtree was hydrated.
    If it was, then we mark those components in the Components track as
    green. Just like the phase itself is marked as green.
    
    If the boundary client rendered we instead mark it as "errored" and its
    children given the plain primary render color (blue). I also collect the
    hydration error for this case so we can include its message in the
    details view. (Unfortunately this doesn't support newlines atm.)
    
    Most of the time this happens in separate commits for each boundary but
    it is possible to force a client render in the same pass as a hydration.
    Such as if an update flows into a boundary that has been put into
    fallback state after it was initially attempted.
    
    <img width="1487" alt="Screenshot 2024-12-18 at 12 06 54 AM"
    src="https://github.com/user-attachments/assets/74c57291-4d11-414c-9751-3dac3285a89a"
    />

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 1d2f69852a..b4d948e735 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -280,6 +280,7 @@ function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
       dehydrated: suspenseInstance,
       treeContext: getSuspendedTreeContext(),
       retryLane: OffscreenLane,
+      hydrationErrors: null,
     };
     fiber.memoizedState = suspenseState;
     // Store the dehydrated fragment as a child fiber.
@@ -701,14 +702,18 @@ function resetHydrationState(): void {
   didSuspendOrErrorDEV = false;
 }
 
-export function upgradeHydrationErrorsToRecoverable(): void {
-  if (hydrationErrors !== null) {
+export function upgradeHydrationErrorsToRecoverable(): Array<
+  CapturedValue<mixed>,
+> | null {
+  const queuedErrors = hydrationErrors;
+  if (queuedErrors !== null) {
     // Successfully completed a forced client render. The errors that occurred
     // during the hydration attempt are now recovered. We will log them in
     // commit phase, once the entire tree has finished.
-    queueRecoverableErrors(hydrationErrors);
+    queueRecoverableErrors(queuedErrors);
     hydrationErrors = null;
   }
+  return queuedErrors;
 }
 
 function getIsHydrating(): boolean {

commit 8bda71558c8b6f9f19af33271f1bfd0251a1c071
Author: Josh Story <story@hey.com>
Date:   Tue Feb 4 12:30:30 2025 -0800

    [Fiber] support hydration when rendering Suspense anywhere (#32224)
    
    follow up to https://github.com/facebook/react/pull/32163
    
    This continues the work of making Suspense workable anywhere in a
    react-dom tree. See the prior PRs for how we handle server rendering and
    client rendering. In this change we update the hydration implementation
    to be able to locate expected nodes. In particular this means hydration
    understands now that the default hydration context is the document body
    when the container is above the body.
    
    One case that is unique to hydration is clearing Suspense boundaries.
    When hydration fails or when the server instructs the client to recover
    an errored boundary it's possible that the html, head, and body tags in
    the initial document were written from a fallback or a different primary
    content on the server and need to be replaced by the client render.
    However these tags (and in the case of head, their content) won't be
    inside the comment nodes that identify the bounds of the Suspense
    boundary. And when client rendering you may not even render the same
    singletons that were server rendered. So when server rendering a
    boudnary which contributes to the preamble (the html, head, and body tag
    openings plus the head contents) we emit a special marker comment just
    before closing the boundary out. This marker encodes which parts of the
    preamble this boundary owned. If we need to clear the suspense boundary
    on the client we read this marker and use it to reset the appropriate
    singleton state.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index b4d948e735..23f13bbcad 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -37,9 +37,11 @@ import {
   supportsHydration,
   supportsSingletons,
   getNextHydratableSibling,
+  getNextHydratableSiblingAfterSingleton,
   getFirstHydratableChild,
   getFirstHydratableChildWithinContainer,
   getFirstHydratableChildWithinSuspenseInstance,
+  getFirstHydratableChildWithinSingleton,
   hydrateInstance,
   diffHydratedPropsForDevWarnings,
   describeHydratableInstanceForDevWarnings,
@@ -366,7 +368,11 @@ function claimHydratableSingleton(fiber: Fiber): void {
 
     hydrationParentFiber = fiber;
     rootOrSingletonContext = true;
-    nextHydratableInstance = getFirstHydratableChild(instance);
+    nextHydratableInstance = getFirstHydratableChildWithinSingleton(
+      fiber.type,
+      instance,
+      nextHydratableInstance,
+    );
   }
 }
 
@@ -593,14 +599,14 @@ function popToNextHostParent(fiber: Fiber): void {
   hydrationParentFiber = fiber.return;
   while (hydrationParentFiber) {
     switch (hydrationParentFiber.tag) {
-      case HostRoot:
-      case HostSingleton:
-        rootOrSingletonContext = true;
-        return;
       case HostComponent:
       case SuspenseComponent:
         rootOrSingletonContext = false;
         return;
+      case HostSingleton:
+      case HostRoot:
+        rootOrSingletonContext = true;
+        return;
       default:
         hydrationParentFiber = hydrationParentFiber.return;
     }
@@ -625,20 +631,25 @@ function popHydrationState(fiber: Fiber): boolean {
     return false;
   }
 
-  let shouldClear = false;
+  const tag = fiber.tag;
+
   if (supportsSingletons) {
     // With float we never clear the Root, or Singleton instances. We also do not clear Instances
     // that have singleton text content
     if (
-      fiber.tag !== HostRoot &&
-      fiber.tag !== HostSingleton &&
+      tag !== HostRoot &&
+      tag !== HostSingleton &&
       !(
-        fiber.tag === HostComponent &&
+        tag === HostComponent &&
         (!shouldDeleteUnhydratedTailInstances(fiber.type) ||
           shouldSetTextContent(fiber.type, fiber.memoizedProps))
       )
     ) {
-      shouldClear = true;
+      const nextInstance = nextHydratableInstance;
+      if (nextInstance) {
+        warnIfUnhydratedTailNodes(fiber);
+        throwOnHydrationMismatch(fiber);
+      }
     }
   } else {
     // If we have any remaining hydratable nodes, we need to delete them now.
@@ -646,24 +657,26 @@ function popHydrationState(fiber: Fiber): boolean {
     // other nodes in them. We also ignore components with pure text content in
     // side of them. We also don't delete anything inside the root container.
     if (
-      fiber.tag !== HostRoot &&
-      (fiber.tag !== HostComponent ||
+      tag !== HostRoot &&
+      (tag !== HostComponent ||
         (shouldDeleteUnhydratedTailInstances(fiber.type) &&
           !shouldSetTextContent(fiber.type, fiber.memoizedProps)))
     ) {
-      shouldClear = true;
-    }
-  }
-  if (shouldClear) {
-    const nextInstance = nextHydratableInstance;
-    if (nextInstance) {
-      warnIfUnhydratedTailNodes(fiber);
-      throwOnHydrationMismatch(fiber);
+      const nextInstance = nextHydratableInstance;
+      if (nextInstance) {
+        warnIfUnhydratedTailNodes(fiber);
+        throwOnHydrationMismatch(fiber);
+      }
     }
   }
   popToNextHostParent(fiber);
-  if (fiber.tag === SuspenseComponent) {
+  if (tag === SuspenseComponent) {
     nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
+  } else if (supportsSingletons && tag === HostSingleton) {
+    nextHydratableInstance = getNextHydratableSiblingAfterSingleton(
+      fiber.type,
+      nextHydratableInstance,
+    );
   } else {
     nextHydratableInstance = hydrationParentFiber
       ? getNextHydratableSibling(fiber.stateNode)

commit 029e8bd618af23fbdd9efdac565ad81f7d4640d8
Author: Sebastian "Sebbie" Silbermann <sebastian.silbermann@vercel.com>
Date:   Thu Mar 6 17:12:50 2025 +0100

    Add Owner Stack to attribute hydration mismatches (#32538)

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index 23f13bbcad..f6589b7445 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -67,6 +67,7 @@ import {
 import {queueRecoverableErrors} from './ReactFiberWorkLoop';
 import {getRootHostContainer, getHostContext} from './ReactFiberHostContext';
 import {describeDiff} from './ReactFiberHydrationDiffs';
+import {runWithFiberInDEV} from './ReactCurrentFiber';
 
 // The deepest Fiber on the stack involved in a hydration context.
 // This may have been an insertion or a hydration.
@@ -749,22 +750,32 @@ export function emitPendingHydrationWarnings() {
     if (diffRoot !== null) {
       hydrationDiffRootDEV = null;
       const diff = describeDiff(diffRoot);
-      console.error(
-        "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
-          'This can happen if a SSR-ed Client Component used:\n' +
-          '\n' +
-          "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
-          "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
-          "- Date formatting in a user's locale which doesn't match the server.\n" +
-          '- External changing data without sending a snapshot of it along with the HTML.\n' +
-          '- Invalid HTML tag nesting.\n' +
-          '\n' +
-          'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
-          '\n' +
-          '%s%s',
-        'https://react.dev/link/hydration-mismatch',
-        diff,
-      );
+
+      // Just pick the DFS-first leaf as the owner.
+      // Should be good enough since most warnings only have a single error.
+      let diffOwner: HydrationDiffNode = diffRoot;
+      while (diffOwner.children.length > 0) {
+        diffOwner = diffOwner.children[0];
+      }
+
+      runWithFiberInDEV(diffOwner.fiber, () => {
+        console.error(
+          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. " +
+            'This can happen if a SSR-ed Client Component used:\n' +
+            '\n' +
+            "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
+            "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
+            "- Date formatting in a user's locale which doesn't match the server.\n" +
+            '- External changing data without sending a snapshot of it along with the HTML.\n' +
+            '- Invalid HTML tag nesting.\n' +
+            '\n' +
+            'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n' +
+            '\n' +
+            '%s%s',
+          'https://react.dev/link/hydration-mismatch',
+          diff,
+        );
+      });
     }
   }
 }

commit 3e88e97c116c7a1535976f2d4486bbf345476443
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Mar 26 17:39:52 2025 -0400

    s/HTML/text for text hydration mismatches (#32763)

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index f6589b7445..c2507f3201 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -308,7 +308,7 @@ export const HydrationMismatchException: mixed = new Error(
     "userspace. If you're seeing this, it's likely a bug in React.",
 );
 
-function throwOnHydrationMismatch(fiber: Fiber) {
+function throwOnHydrationMismatch(fiber: Fiber, fromText: boolean = false) {
   let diff = '';
   if (__DEV__) {
     // Consume the diff root for this mismatch.
@@ -320,7 +320,8 @@ function throwOnHydrationMismatch(fiber: Fiber) {
     }
   }
   const error = new Error(
-    "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n" +
+    `Hydration failed because the server rendered ${fromText ? 'text' : 'HTML'} didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:
+` +
       '\n' +
       "- A server/client branch `if (typeof window !== 'undefined')`.\n" +
       "- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n" +
@@ -481,7 +482,7 @@ function prepareToHydrateHostInstance(
     fiber,
   );
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber);
+    throwOnHydrationMismatch(fiber, true);
   }
 }
 
@@ -547,7 +548,7 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
     parentProps,
   );
   if (!didHydrate && favorSafetyOverHydrationPerf) {
-    throwOnHydrationMismatch(fiber);
+    throwOnHydrationMismatch(fiber, true);
   }
 }
 

commit 961b625ab5d180180e836e0c7b221789f0ee336b
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Apr 11 10:52:23 2025 -0400

    Try not. Do... or do not. Hydrate Suspense Boundaries. (#32851)
    
    Assertively claim a SuspenseInstance. We already know we're hydrating.
    
    If there's no match, it throws anyway. So there's no other code path.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index c2507f3201..daa9c8ca7a 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -272,7 +272,10 @@ function tryHydrateText(fiber: Fiber, nextInstance: any) {
   return false;
 }
 
-function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
+function tryHydrateSuspense(
+  fiber: Fiber,
+  nextInstance: any,
+): null | SuspenseInstance {
   // fiber is a SuspenseComponent Fiber
   const suspenseInstance = canHydrateSuspenseInstance(
     nextInstance,
@@ -298,9 +301,8 @@ function tryHydrateSuspense(fiber: Fiber, nextInstance: any) {
     // While a Suspense Instance does have children, we won't step into
     // it during the first pass. Instead, we'll reenter it later.
     nextHydratableInstance = null;
-    return true;
   }
-  return false;
+  return suspenseInstance;
 }
 
 export const HydrationMismatchException: mixed = new Error(
@@ -423,15 +425,16 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   }
 }
 
-function tryToClaimNextHydratableSuspenseInstance(fiber: Fiber): void {
-  if (!isHydrating) {
-    return;
-  }
+function claimNextHydratableSuspenseInstance(fiber: Fiber): SuspenseInstance {
   const nextInstance = nextHydratableInstance;
-  if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {
+  const suspenseInstance = nextInstance
+    ? tryHydrateSuspense(fiber, nextInstance)
+    : null;
+  if (suspenseInstance === null) {
     warnNonHydratedInstance(fiber, nextInstance);
-    throwOnHydrationMismatch(fiber);
+    throw throwOnHydrationMismatch(fiber);
   }
+  return suspenseInstance;
 }
 
 export function tryToClaimNextHydratableFormMarkerInstance(
@@ -790,7 +793,7 @@ export {
   claimHydratableSingleton,
   tryToClaimNextHydratableInstance,
   tryToClaimNextHydratableTextInstance,
-  tryToClaimNextHydratableSuspenseInstance,
+  claimNextHydratableSuspenseInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
   prepareToHydrateHostSuspenseInstance,

commit 17f88c80ed20b4e5f21255d9e1268542a2fbc1bd
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 22 19:44:14 2025 -0400

    Implement ActivityInstance in FiberConfigDOM (#32842)
    
    Stacked on #32851 and #32900.
    
    This implements the equivalent Configs for ActivityInstance as we have
    for SuspenseInstance. These can be implemented as comments but they
    don't have to be and can be implemented differently in the renderer.
    
    This seems like a lot duplication but it's actually ends mostly just
    calling the same methods underneath and the wrappers compiles out.
    
    This doesn't leave the Activity dehydrated yet. It just hydrates into it
    immediately.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index daa9c8ca7a..f9e7580e09 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -12,6 +12,7 @@ import type {
   Instance,
   TextInstance,
   HydratableInstance,
+  ActivityInstance,
   SuspenseInstance,
   Container,
   HostContext,
@@ -26,6 +27,7 @@ import {
   HostSingleton,
   HostRoot,
   SuspenseComponent,
+  ActivityComponent,
 } from './ReactWorkTags';
 import {favorSafetyOverHydrationPerf} from 'shared/ReactFeatureFlags';
 
@@ -40,6 +42,7 @@ import {
   getNextHydratableSiblingAfterSingleton,
   getFirstHydratableChild,
   getFirstHydratableChildWithinContainer,
+  getFirstHydratableChildWithinActivityInstance,
   getFirstHydratableChildWithinSuspenseInstance,
   getFirstHydratableChildWithinSingleton,
   hydrateInstance,
@@ -48,11 +51,13 @@ import {
   hydrateTextInstance,
   diffHydratedTextForDevWarnings,
   hydrateSuspenseInstance,
+  getNextHydratableInstanceAfterActivityInstance,
   getNextHydratableInstanceAfterSuspenseInstance,
   shouldDeleteUnhydratedTailInstances,
   resolveSingletonInstance,
   canHydrateInstance,
   canHydrateTextInstance,
+  canHydrateActivityInstance,
   canHydrateSuspenseInstance,
   canHydrateFormStateMarker,
   isFormStateMarkerMatching,
@@ -272,6 +277,26 @@ function tryHydrateText(fiber: Fiber, nextInstance: any) {
   return false;
 }
 
+function tryHydrateActivity(
+  fiber: Fiber,
+  nextInstance: any,
+): null | ActivityInstance {
+  // fiber is a SuspenseComponent Fiber
+  const activityInstance = canHydrateActivityInstance(
+    nextInstance,
+    rootOrSingletonContext,
+  );
+  if (activityInstance !== null) {
+    // TODO: Implement dehydrated Activity state.
+    // TODO: Delete this from stateNode. It's only used to skip past it.
+    fiber.stateNode = activityInstance;
+    hydrationParentFiber = fiber;
+    nextHydratableInstance =
+      getFirstHydratableChildWithinActivityInstance(activityInstance);
+  }
+  return activityInstance;
+}
+
 function tryHydrateSuspense(
   fiber: Fiber,
   nextInstance: any,
@@ -425,6 +450,18 @@ function tryToClaimNextHydratableTextInstance(fiber: Fiber): void {
   }
 }
 
+function claimNextHydratableActivityInstance(fiber: Fiber): ActivityInstance {
+  const nextInstance = nextHydratableInstance;
+  const activityInstance = nextInstance
+    ? tryHydrateActivity(fiber, nextInstance)
+    : null;
+  if (activityInstance === null) {
+    warnNonHydratedInstance(fiber, nextInstance);
+    throw throwOnHydrationMismatch(fiber);
+  }
+  return activityInstance;
+}
+
 function claimNextHydratableSuspenseInstance(fiber: Fiber): SuspenseInstance {
   const nextInstance = nextHydratableInstance;
   const suspenseInstance = nextInstance
@@ -576,6 +613,11 @@ function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
 
   hydrateSuspenseInstance(suspenseInstance, fiber);
 }
+function skipPastDehydratedActivityInstance(
+  fiber: Fiber,
+): null | HydratableInstance {
+  return getNextHydratableInstanceAfterActivityInstance(fiber.stateNode);
+}
 
 function skipPastDehydratedSuspenseInstance(
   fiber: Fiber,
@@ -612,6 +654,8 @@ function popToNextHostParent(fiber: Fiber): void {
       case HostRoot:
         rootOrSingletonContext = true;
         return;
+      case ActivityComponent:
+        return;
       default:
         hydrationParentFiber = hydrationParentFiber.return;
     }
@@ -677,6 +721,8 @@ function popHydrationState(fiber: Fiber): boolean {
   popToNextHostParent(fiber);
   if (tag === SuspenseComponent) {
     nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
+  } else if (tag === ActivityComponent) {
+    nextHydratableInstance = skipPastDehydratedActivityInstance(fiber);
   } else if (supportsSingletons && tag === HostSingleton) {
     nextHydratableInstance = getNextHydratableSiblingAfterSingleton(
       fiber.type,
@@ -793,6 +839,7 @@ export {
   claimHydratableSingleton,
   tryToClaimNextHydratableInstance,
   tryToClaimNextHydratableTextInstance,
+  claimNextHydratableActivityInstance,
   claimNextHydratableSuspenseInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,

commit 3ef31d196a83e45d4c70b300a265a9c657c386b4
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Apr 22 21:00:30 2025 -0400

    Implement Partial Hydration for Activity (#32863)
    
    Stacked on #32862 and #32842.
    
    This means that Activity boundaries now act as boundaries which can have
    their effects mounted independently. Just like Suspense boundaries, we
    hydrate the outer content first and then start hydrating the content in
    an Offscreen lane. Flowing props or interacting with the content
    increases the priority just like Suspense boundaries.
    
    This skips emitting even the comments for `<Activity mode="hidden">` so
    we don't hydrate those. Instead those are deferred to a later client
    render.
    
    The implementation are just forked copies of the SuspenseComponent
    branches and then carefully going through each line and tweaking it.
    
    The main interesting bit is that, unlike Suspense, Activity boundaries
    don't have fallbacks so all those branches where you might commit a
    suspended tree disappears. Instead, if something suspends while
    hydration, we can just leave the dehydrated content in place. However,
    if something does suspend during client rendering then it should bubble
    up to the parent. Therefore, we have to be careful to only
    pushSuspenseHandler when hydrating. That's really the main difference.
    
    This just uses the existing basic Activity tests but I've started work
    on port all of the applicable Suspense tests in SelectiveHydration-test
    and PartialHydration-test to Activity versions.

diff --git a/packages/react-reconciler/src/ReactFiberHydrationContext.js b/packages/react-reconciler/src/ReactFiberHydrationContext.js
index f9e7580e09..8c811f1ef2 100644
--- a/packages/react-reconciler/src/ReactFiberHydrationContext.js
+++ b/packages/react-reconciler/src/ReactFiberHydrationContext.js
@@ -17,6 +17,7 @@ import type {
   Container,
   HostContext,
 } from './ReactFiberConfig';
+import type {ActivityState} from './ReactFiberActivityComponent';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {TreeContext} from './ReactFiberTreeContext';
 import type {CapturedValue} from './ReactCapturedValue';
@@ -50,6 +51,7 @@ import {
   describeHydratableInstanceForDevWarnings,
   hydrateTextInstance,
   diffHydratedTextForDevWarnings,
+  hydrateActivityInstance,
   hydrateSuspenseInstance,
   getNextHydratableInstanceAfterActivityInstance,
   getNextHydratableInstanceAfterSuspenseInstance,
@@ -175,6 +177,28 @@ function enterHydrationState(fiber: Fiber): boolean {
   return true;
 }
 
+function reenterHydrationStateFromDehydratedActivityInstance(
+  fiber: Fiber,
+  activityInstance: ActivityInstance,
+  treeContext: TreeContext | null,
+): boolean {
+  if (!supportsHydration) {
+    return false;
+  }
+  nextHydratableInstance =
+    getFirstHydratableChildWithinActivityInstance(activityInstance);
+  hydrationParentFiber = fiber;
+  isHydrating = true;
+  hydrationErrors = null;
+  didSuspendOrErrorDEV = false;
+  hydrationDiffRootDEV = null;
+  rootOrSingletonContext = false;
+  if (treeContext !== null) {
+    restoreSuspendedTreeContext(fiber, treeContext);
+  }
+  return true;
+}
+
 function reenterHydrationStateFromDehydratedSuspenseInstance(
   fiber: Fiber,
   suspenseInstance: SuspenseInstance,
@@ -281,18 +305,31 @@ function tryHydrateActivity(
   fiber: Fiber,
   nextInstance: any,
 ): null | ActivityInstance {
-  // fiber is a SuspenseComponent Fiber
+  // fiber is a ActivityComponent Fiber
   const activityInstance = canHydrateActivityInstance(
     nextInstance,
     rootOrSingletonContext,
   );
   if (activityInstance !== null) {
-    // TODO: Implement dehydrated Activity state.
-    // TODO: Delete this from stateNode. It's only used to skip past it.
-    fiber.stateNode = activityInstance;
+    const activityState: ActivityState = {
+      dehydrated: activityInstance,
+      treeContext: getSuspendedTreeContext(),
+      retryLane: OffscreenLane,
+      hydrationErrors: null,
+    };
+    fiber.memoizedState = activityState;
+    // Store the dehydrated fragment as a child fiber.
+    // This simplifies the code for getHostSibling and deleting nodes,
+    // since it doesn't have to consider all Suspense boundaries and
+    // check if they're dehydrated ones or not.
+    const dehydratedFragment =
+      createFiberFromDehydratedFragment(activityInstance);
+    dehydratedFragment.return = fiber;
+    fiber.child = dehydratedFragment;
     hydrationParentFiber = fiber;
-    nextHydratableInstance =
-      getFirstHydratableChildWithinActivityInstance(activityInstance);
+    // While an Activity Instance does have children, we won't step into
+    // it during the first pass. Instead, we'll reenter it later.
+    nextHydratableInstance = null;
   }
   return activityInstance;
 }
@@ -592,6 +629,27 @@ function prepareToHydrateHostTextInstance(fiber: Fiber): void {
   }
 }
 
+function prepareToHydrateHostActivityInstance(fiber: Fiber): void {
+  if (!supportsHydration) {
+    throw new Error(
+      'Expected prepareToHydrateHostActivityInstance() to never be called. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+  const activityState: null | ActivityState = fiber.memoizedState;
+  const activityInstance: null | ActivityInstance =
+    activityState !== null ? activityState.dehydrated : null;
+
+  if (!activityInstance) {
+    throw new Error(
+      'Expected to have a hydrated activity instance. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  hydrateActivityInstance(activityInstance, fiber);
+}
+
 function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
   if (!supportsHydration) {
     throw new Error(
@@ -613,10 +671,22 @@ function prepareToHydrateHostSuspenseInstance(fiber: Fiber): void {
 
   hydrateSuspenseInstance(suspenseInstance, fiber);
 }
+
 function skipPastDehydratedActivityInstance(
   fiber: Fiber,
 ): null | HydratableInstance {
-  return getNextHydratableInstanceAfterActivityInstance(fiber.stateNode);
+  const activityState: null | ActivityState = fiber.memoizedState;
+  const activityInstance: null | ActivityInstance =
+    activityState !== null ? activityState.dehydrated : null;
+
+  if (!activityInstance) {
+    throw new Error(
+      'Expected to have a hydrated suspense instance. ' +
+        'This error is likely caused by a bug in React. Please file an issue.',
+    );
+  }
+
+  return getNextHydratableInstanceAfterActivityInstance(activityInstance);
 }
 
 function skipPastDehydratedSuspenseInstance(
@@ -647,6 +717,7 @@ function popToNextHostParent(fiber: Fiber): void {
   while (hydrationParentFiber) {
     switch (hydrationParentFiber.tag) {
       case HostComponent:
+      case ActivityComponent:
       case SuspenseComponent:
         rootOrSingletonContext = false;
         return;
@@ -654,8 +725,6 @@ function popToNextHostParent(fiber: Fiber): void {
       case HostRoot:
         rootOrSingletonContext = true;
         return;
-      case ActivityComponent:
-        return;
       default:
         hydrationParentFiber = hydrationParentFiber.return;
     }
@@ -834,6 +903,7 @@ export {
   warnIfHydrating,
   enterHydrationState,
   getIsHydrating,
+  reenterHydrationStateFromDehydratedActivityInstance,
   reenterHydrationStateFromDehydratedSuspenseInstance,
   resetHydrationState,
   claimHydratableSingleton,
@@ -843,6 +913,7 @@ export {
   claimNextHydratableSuspenseInstance,
   prepareToHydrateHostInstance,
   prepareToHydrateHostTextInstance,
+  prepareToHydrateHostActivityInstance,
   prepareToHydrateHostSuspenseInstance,
   popHydrationState,
 };

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    