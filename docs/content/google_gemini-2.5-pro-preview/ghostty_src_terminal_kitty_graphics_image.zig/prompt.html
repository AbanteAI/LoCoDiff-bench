<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/terminal/kitty/graphics_image.zig - Gemini 2.5 Pro 05-06</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/terminal/kitty/graphics_image.zig</h1>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview/ghostty_src_terminal_kitty_graphics_image.zig.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/terminal/kitty/graphics_image.zig

commit c7658df978068d966edff3739bc69fb2bcaf3cca
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 14:34:33 2023 -0700

    terminal/kitty-gfx: support "query", loading images, tests

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
new file mode 100644
index 00000000..b327d1d6
--- /dev/null
+++ b/src/terminal/kitty/graphics_image.zig
@@ -0,0 +1,73 @@
+const std = @import("std");
+const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
+const ArenaAllocator = std.heap.ArenaAllocator;
+
+const command = @import("graphics_command.zig");
+
+pub const Image = struct {
+    id: u32 = 0,
+    data: []const u8,
+
+    pub const Error = error{
+        InvalidData,
+        DimensionsRequired,
+        UnsupportedFormat,
+    };
+
+    /// Load an image from a transmission. The data will be owned by the
+    /// return value if it is successful.
+    pub fn load(alloc: Allocator, t: command.Transmission, data: []const u8) !Image {
+        _ = alloc;
+        return switch (t.format) {
+            .rgb => try loadPacked(3, t, data),
+            .rgba => try loadPacked(4, t, data),
+            else => error.UnsupportedFormat,
+        };
+    }
+
+    /// Load a package image format, i.e. RGB or RGBA.
+    fn loadPacked(
+        comptime bpp: comptime_int,
+        t: command.Transmission,
+        data: []const u8,
+    ) !Image {
+        if (t.width == 0 or t.height == 0) return error.DimensionsRequired;
+
+        // Data length must be what we expect
+        // NOTE: we use a "<" check here because Kitty itself doesn't validate
+        // this and if we validate exact data length then various Kitty
+        // applications fail because the test that Kitty documents itself
+        // uses an invalid value.
+        const expected_len = t.width * t.height * bpp;
+        if (data.len < expected_len) return error.InvalidData;
+
+        return Image{
+            .id = t.image_id,
+            .data = data,
+        };
+    }
+
+    pub fn deinit(self: *Image, alloc: Allocator) void {
+        alloc.free(self.data);
+    }
+};
+
+// This specifically tests we ALLOW invalid RGB data because Kitty
+// documents that this should work.
+test "image load with invalid RGB data" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var data = try alloc.dupe(u8, "AAAA");
+    errdefer alloc.free(data);
+
+    // <ESC>_Gi=31,s=1,v=1,a=q,t=d,f=24;AAAA<ESC>\
+    var img = try Image.load(alloc, .{
+        .format = .rgb,
+        .width = 1,
+        .height = 1,
+        .image_id = 31,
+    }, data);
+    defer img.deinit(alloc);
+}

commit 1b7fbd00d1fcc45708f8427deb240d5c3cb4dd5c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 15:02:29 2023 -0700

    terminal/kitty-gfx: add some validation from Kitty

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index b327d1d6..de564511 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -5,6 +5,9 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 
 const command = @import("graphics_command.zig");
 
+/// Maximum width or height of an image. Taken directly from Kitty.
+const max_dimension = 10000;
+
 pub const Image = struct {
     id: u32 = 0,
     data: []const u8,
@@ -12,6 +15,7 @@ pub const Image = struct {
     pub const Error = error{
         InvalidData,
         DimensionsRequired,
+        DimensionsTooLarge,
         UnsupportedFormat,
     };
 
@@ -33,6 +37,7 @@ pub const Image = struct {
         data: []const u8,
     ) !Image {
         if (t.width == 0 or t.height == 0) return error.DimensionsRequired;
+        if (t.width > max_dimension or t.height > max_dimension) return error.DimensionsTooLarge;
 
         // Data length must be what we expect
         // NOTE: we use a "<" check here because Kitty itself doesn't validate
@@ -71,3 +76,33 @@ test "image load with invalid RGB data" {
     }, data);
     defer img.deinit(alloc);
 }
+
+test "image load with image too wide" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var data = try alloc.dupe(u8, "AAAA");
+    defer alloc.free(data);
+
+    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, .{
+        .format = .rgb,
+        .width = max_dimension + 1,
+        .height = 1,
+        .image_id = 31,
+    }, data));
+}
+
+test "image load with image too tall" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var data = try alloc.dupe(u8, "AAAA");
+    defer alloc.free(data);
+
+    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, .{
+        .format = .rgb,
+        .height = max_dimension + 1,
+        .width = 1,
+        .image_id = 31,
+    }, data));
+}

commit f82899bd58d26950cfc6e8d7111d1d2595fc85cf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 15:20:02 2023 -0700

    terminal/kitty-gfx: better memory ownership semantics around func calls

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index de564511..006c4962 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -19,15 +19,24 @@ pub const Image = struct {
         UnsupportedFormat,
     };
 
-    /// Load an image from a transmission. The data will be owned by the
-    /// return value if it is successful.
-    pub fn load(alloc: Allocator, t: command.Transmission, data: []const u8) !Image {
+    /// Load an image from a transmission. The data in the command will be
+    /// owned by the image if successful. Note that you still must deinit
+    /// the command, all the state change will be done internally.
+    pub fn load(alloc: Allocator, cmd: *command.Command) !Image {
         _ = alloc;
-        return switch (t.format) {
-            .rgb => try loadPacked(3, t, data),
-            .rgba => try loadPacked(4, t, data),
-            else => error.UnsupportedFormat,
+
+        const t = cmd.transmission().?;
+        const img = switch (t.format) {
+            .rgb => try loadPacked(3, t, cmd.data),
+            .rgba => try loadPacked(4, t, cmd.data),
+            else => return error.UnsupportedFormat,
         };
+
+        // If we loaded an image successfully then we take ownership
+        // of the command data.
+        _ = cmd.toOwnedData();
+
+        return img;
     }
 
     /// Load a package image format, i.e. RGB or RGBA.
@@ -68,12 +77,16 @@ test "image load with invalid RGB data" {
     errdefer alloc.free(data);
 
     // <ESC>_Gi=31,s=1,v=1,a=q,t=d,f=24;AAAA<ESC>\
-    var img = try Image.load(alloc, .{
-        .format = .rgb,
-        .width = 1,
-        .height = 1,
-        .image_id = 31,
-    }, data);
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .width = 1,
+            .height = 1,
+            .image_id = 31,
+        } },
+        .data = data,
+    };
+    var img = try Image.load(alloc, &cmd);
     defer img.deinit(alloc);
 }
 
@@ -84,12 +97,16 @@ test "image load with image too wide" {
     var data = try alloc.dupe(u8, "AAAA");
     defer alloc.free(data);
 
-    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, .{
-        .format = .rgb,
-        .width = max_dimension + 1,
-        .height = 1,
-        .image_id = 31,
-    }, data));
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .width = max_dimension + 1,
+            .height = 1,
+            .image_id = 31,
+        } },
+        .data = data,
+    };
+    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
 }
 
 test "image load with image too tall" {
@@ -99,10 +116,14 @@ test "image load with image too tall" {
     var data = try alloc.dupe(u8, "AAAA");
     defer alloc.free(data);
 
-    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, .{
-        .format = .rgb,
-        .height = max_dimension + 1,
-        .width = 1,
-        .image_id = 31,
-    }, data));
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .height = max_dimension + 1,
+            .width = 1,
+            .image_id = 31,
+        } },
+        .data = data,
+    };
+    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
 }

commit 7bec2820a740e11c45fffccba69753c669b36d16
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 16:19:23 2023 -0700

    terminal/kitty-gfx: start working on placements

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 006c4962..5ac7cf09 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -10,6 +10,7 @@ const max_dimension = 10000;
 
 pub const Image = struct {
     id: u32 = 0,
+    number: u32 = 0,
     data: []const u8,
 
     pub const Error = error{
@@ -58,6 +59,7 @@ pub const Image = struct {
 
         return Image{
             .id = t.image_id,
+            .number = t.image_number,
             .data = data,
         };
     }

commit bbcb2f96c8ad9ac62370c54ed11590e6de876bef
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 19:28:39 2023 -0700

    terminal/kitty-gfx: huge progress on chunked transfers, lots of issues

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 5ac7cf09..dbda94c3 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -8,64 +8,151 @@ const command = @import("graphics_command.zig");
 /// Maximum width or height of an image. Taken directly from Kitty.
 const max_dimension = 10000;
 
+/// A chunked image is an image that is in-progress and being constructed
+/// using chunks (the "m" parameter in the protocol).
+pub const ChunkedImage = struct {
+    /// The in-progress image. The first chunk must have all the metadata
+    /// so this comes from that initially.
+    image: Image,
+
+    /// The data that is being built up.
+    data: std.ArrayListUnmanaged(u8) = .{},
+
+    /// Initialize a chunked image from the first image part.
+    pub fn init(alloc: Allocator, image: Image) !ChunkedImage {
+        // Copy our initial set of data
+        var data = try std.ArrayListUnmanaged(u8).initCapacity(alloc, image.data.len * 2);
+        errdefer data.deinit(alloc);
+        try data.appendSlice(alloc, image.data);
+
+        // Set data to empty so it doesn't get freed.
+        var result: ChunkedImage = .{ .image = image, .data = data };
+        result.image.data = "";
+        return result;
+    }
+
+    pub fn deinit(self: *ChunkedImage, alloc: Allocator) void {
+        self.image.deinit(alloc);
+        self.data.deinit(alloc);
+    }
+
+    pub fn destroy(self: *ChunkedImage, alloc: Allocator) void {
+        self.deinit(alloc);
+        alloc.destroy(self);
+    }
+
+    /// Complete the chunked image, returning a completed image.
+    pub fn complete(self: *ChunkedImage, alloc: Allocator) !Image {
+        var result = self.image;
+        result.data = try self.data.toOwnedSlice(alloc);
+        self.image = .{};
+        return result;
+    }
+};
+
+/// Image represents a single fully loaded image.
 pub const Image = struct {
     id: u32 = 0,
     number: u32 = 0,
-    data: []const u8,
+    width: u32 = 0,
+    height: u32 = 0,
+    format: Format = .rgb,
+    data: []const u8 = "",
+
+    pub const Format = enum { rgb, rgba };
 
     pub const Error = error{
         InvalidData,
         DimensionsRequired,
         DimensionsTooLarge,
         UnsupportedFormat,
+        UnsupportedMedium,
     };
 
+    /// Validate that the image appears valid.
+    pub fn validate(self: *const Image) !void {
+        const bpp: u32 = switch (self.format) {
+            .rgb => 3,
+            .rgba => 4,
+        };
+
+        // Validate our dimensions.
+        if (self.width == 0 or self.height == 0) return error.DimensionsRequired;
+        if (self.width > max_dimension or self.height > max_dimension) return error.DimensionsTooLarge;
+
+        // Data length must be what we expect
+        // NOTE: we use a "<" check here because Kitty itself doesn't validate
+        // this and if we validate exact data length then various Kitty
+        // applications fail because the test that Kitty documents itself
+        // uses an invalid value.
+        const expected_len = self.width * self.height * bpp;
+        std.log.warn(
+            "width={} height={} bpp={} expected_len={} actual_len={}",
+            .{ self.width, self.height, bpp, expected_len, self.data.len },
+        );
+        if (self.data.len < expected_len) return error.InvalidData;
+    }
+
     /// Load an image from a transmission. The data in the command will be
     /// owned by the image if successful. Note that you still must deinit
     /// the command, all the state change will be done internally.
+    ///
+    /// If the command represents a chunked image then this image will
+    /// be incomplete. The caller is expected to inspect the command
+    /// and determine if it is a chunked image.
     pub fn load(alloc: Allocator, cmd: *command.Command) !Image {
-        _ = alloc;
-
         const t = cmd.transmission().?;
-        const img = switch (t.format) {
-            .rgb => try loadPacked(3, t, cmd.data),
-            .rgba => try loadPacked(4, t, cmd.data),
-            else => return error.UnsupportedFormat,
+
+        // Load the data
+        const data = switch (t.medium) {
+            .direct => cmd.data,
+            else => {
+                std.log.warn("unimplemented medium={}", .{t.medium});
+                return error.UnsupportedMedium;
+            },
         };
 
         // If we loaded an image successfully then we take ownership
-        // of the command data.
+        // of the command data and we need to make sure to clean up on error.
         _ = cmd.toOwnedData();
+        errdefer if (data.len > 0) alloc.free(data);
+
+        const img = switch (t.format) {
+            .rgb, .rgba => try loadPacked(t, data),
+            else => return error.UnsupportedFormat,
+        };
 
         return img;
     }
 
     /// Load a package image format, i.e. RGB or RGBA.
     fn loadPacked(
-        comptime bpp: comptime_int,
         t: command.Transmission,
         data: []const u8,
     ) !Image {
-        if (t.width == 0 or t.height == 0) return error.DimensionsRequired;
-        if (t.width > max_dimension or t.height > max_dimension) return error.DimensionsTooLarge;
-
-        // Data length must be what we expect
-        // NOTE: we use a "<" check here because Kitty itself doesn't validate
-        // this and if we validate exact data length then various Kitty
-        // applications fail because the test that Kitty documents itself
-        // uses an invalid value.
-        const expected_len = t.width * t.height * bpp;
-        if (data.len < expected_len) return error.InvalidData;
-
         return Image{
             .id = t.image_id,
             .number = t.image_number,
+            .width = t.width,
+            .height = t.height,
+            .format = switch (t.format) {
+                .rgb => .rgb,
+                .rgba => .rgba,
+                else => unreachable,
+            },
             .data = data,
         };
     }
 
     pub fn deinit(self: *Image, alloc: Allocator) void {
-        alloc.free(self.data);
+        if (self.data.len > 0) alloc.free(self.data);
+    }
+
+    /// Mostly for logging
+    pub fn withoutData(self: *const Image) Image {
+        var copy = self.*;
+        copy.data = "";
+        return copy;
     }
 };
 
@@ -75,9 +162,6 @@ test "image load with invalid RGB data" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var data = try alloc.dupe(u8, "AAAA");
-    errdefer alloc.free(data);
-
     // <ESC>_Gi=31,s=1,v=1,a=q,t=d,f=24;AAAA<ESC>\
     var cmd: command.Command = .{
         .control = .{ .transmit = .{
@@ -86,8 +170,9 @@ test "image load with invalid RGB data" {
             .height = 1,
             .image_id = 31,
         } },
-        .data = data,
+        .data = try alloc.dupe(u8, "AAAA"),
     };
+    defer cmd.deinit(alloc);
     var img = try Image.load(alloc, &cmd);
     defer img.deinit(alloc);
 }
@@ -96,9 +181,6 @@ test "image load with image too wide" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var data = try alloc.dupe(u8, "AAAA");
-    defer alloc.free(data);
-
     var cmd: command.Command = .{
         .control = .{ .transmit = .{
             .format = .rgb,
@@ -106,8 +188,9 @@ test "image load with image too wide" {
             .height = 1,
             .image_id = 31,
         } },
-        .data = data,
+        .data = try alloc.dupe(u8, "AAAA"),
     };
+    defer cmd.deinit(alloc);
     try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
 }
 
@@ -115,9 +198,6 @@ test "image load with image too tall" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var data = try alloc.dupe(u8, "AAAA");
-    defer alloc.free(data);
-
     var cmd: command.Command = .{
         .control = .{ .transmit = .{
             .format = .rgb,
@@ -125,7 +205,8 @@ test "image load with image too tall" {
             .width = 1,
             .image_id = 31,
         } },
-        .data = data,
+        .data = try alloc.dupe(u8, "AAAA"),
     };
+    defer cmd.deinit(alloc);
     try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
 }

commit 03e0ba90817e4cacb4dd564e373bb2d8caf6e924
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 19:56:11 2023 -0700

    terminal/kitty-gfx: zlib decompression for data validation

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index dbda94c3..2eef8943 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -5,6 +5,8 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 
 const command = @import("graphics_command.zig");
 
+const log = std.log.scoped(.kitty_gfx);
+
 /// Maximum width or height of an image. Taken directly from Kitty.
 const max_dimension = 10000;
 
@@ -57,20 +59,53 @@ pub const Image = struct {
     width: u32 = 0,
     height: u32 = 0,
     format: Format = .rgb,
+    compression: command.Transmission.Compression = .none,
     data: []const u8 = "",
 
     pub const Format = enum { rgb, rgba };
 
     pub const Error = error{
         InvalidData,
+        DecompressionFailed,
         DimensionsRequired,
         DimensionsTooLarge,
         UnsupportedFormat,
         UnsupportedMedium,
     };
 
+    /// The length of the data in bytes, uncompressed. While this will
+    /// decompress compressed data to count the bytes it doesn't actually
+    /// store the decompressed data so this doesn't allocate much.
+    pub fn dataLen(self: *const Image, alloc: Allocator) !usize {
+        return switch (self.compression) {
+            .none => self.data.len,
+            .zlib_deflate => zlib: {
+                var fbs = std.io.fixedBufferStream(self.data);
+
+                var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
+                    log.warn("zlib decompression failed: {}", .{err});
+                    return error.DecompressionFailed;
+                };
+                defer stream.deinit();
+
+                var counting_stream = std.io.countingReader(stream.reader());
+                const counting_reader = counting_stream.reader();
+
+                var buf: [4096]u8 = undefined;
+                while (counting_reader.readAll(&buf)) |_| {} else |err| {
+                    if (err != error.EndOfStream) {
+                        log.warn("zlib decompression failed: {}", .{err});
+                        return error.DecompressionFailed;
+                    }
+                }
+
+                break :zlib counting_stream.bytes_read;
+            },
+        };
+    }
+
     /// Validate that the image appears valid.
-    pub fn validate(self: *const Image) !void {
+    pub fn validate(self: *const Image, alloc: Allocator) !void {
         const bpp: u32 = switch (self.format) {
             .rgb => 3,
             .rgba => 4,
@@ -86,11 +121,12 @@ pub const Image = struct {
         // applications fail because the test that Kitty documents itself
         // uses an invalid value.
         const expected_len = self.width * self.height * bpp;
+        const actual_len = try self.dataLen(alloc);
         std.log.warn(
             "width={} height={} bpp={} expected_len={} actual_len={}",
-            .{ self.width, self.height, bpp, expected_len, self.data.len },
+            .{ self.width, self.height, bpp, expected_len, actual_len },
         );
-        if (self.data.len < expected_len) return error.InvalidData;
+        if (actual_len < expected_len) return error.InvalidData;
     }
 
     /// Load an image from a transmission. The data in the command will be
@@ -135,6 +171,7 @@ pub const Image = struct {
             .number = t.image_number,
             .width = t.width,
             .height = t.height,
+            .compression = t.compression,
             .format = switch (t.format) {
                 .rgb => .rgb,
                 .rgba => .rgba,

commit c96fa2e85f56e435928a6bf79544d204ca5bf537
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 20:06:08 2023 -0700

    terminal/kitty-gfx: fix broken tests

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 2eef8943..0bd166e5 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -228,7 +228,9 @@ test "image load with image too wide" {
         .data = try alloc.dupe(u8, "AAAA"),
     };
     defer cmd.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
+    var img = try Image.load(alloc, &cmd);
+    defer img.deinit(alloc);
+    try testing.expectError(error.DimensionsTooLarge, img.validate(alloc));
 }
 
 test "image load with image too tall" {
@@ -245,5 +247,7 @@ test "image load with image too tall" {
         .data = try alloc.dupe(u8, "AAAA"),
     };
     defer cmd.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, Image.load(alloc, &cmd));
+    var img = try Image.load(alloc, &cmd);
+    defer img.deinit(alloc);
+    try testing.expectError(error.DimensionsTooLarge, img.validate(alloc));
 }

commit 89dfe85740bc14cbd46c081d5e23c22135000515
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 21:50:05 2023 -0700

    terminal/kitty-gfx: the data is base64 encoded!

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 0bd166e5..f3c92fa5 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -104,8 +104,9 @@ pub const Image = struct {
         };
     }
 
-    /// Validate that the image appears valid.
-    pub fn validate(self: *const Image, alloc: Allocator) !void {
+    /// Complete the image. This must be called after loading and after
+    /// being sure the data is complete (not chunked).
+    pub fn complete(self: *Image, alloc: Allocator) !void {
         const bpp: u32 = switch (self.format) {
             .rgb => 3,
             .rgba => 4,
@@ -115,18 +116,37 @@ pub const Image = struct {
         if (self.width == 0 or self.height == 0) return error.DimensionsRequired;
         if (self.width > max_dimension or self.height > max_dimension) return error.DimensionsTooLarge;
 
+        // The data is base64 encoded, we must decode it.
+        var decoded = decoded: {
+            const Base64Decoder = std.base64.standard.Decoder;
+            const size = Base64Decoder.calcSizeForSlice(self.data) catch |err| {
+                log.warn("failed to calculate base64 decoded size: {}", .{err});
+                return error.InvalidData;
+            };
+
+            var buf = try alloc.alloc(u8, size);
+            errdefer alloc.free(buf);
+            Base64Decoder.decode(buf, self.data) catch |err| {
+                log.warn("failed to decode base64 data: {}", .{err});
+                return error.InvalidData;
+            };
+
+            break :decoded buf;
+        };
+
+        // After decoding, we swap the data immediately and free the old.
+        // This will ensure that we never leak memory.
+        alloc.free(self.data);
+        self.data = decoded;
+
         // Data length must be what we expect
-        // NOTE: we use a "<" check here because Kitty itself doesn't validate
-        // this and if we validate exact data length then various Kitty
-        // applications fail because the test that Kitty documents itself
-        // uses an invalid value.
         const expected_len = self.width * self.height * bpp;
         const actual_len = try self.dataLen(alloc);
         std.log.warn(
             "width={} height={} bpp={} expected_len={} actual_len={}",
             .{ self.width, self.height, bpp, expected_len, actual_len },
         );
-        if (actual_len < expected_len) return error.InvalidData;
+        if (actual_len != expected_len) return error.InvalidData;
     }
 
     /// Load an image from a transmission. The data in the command will be
@@ -230,7 +250,7 @@ test "image load with image too wide" {
     defer cmd.deinit(alloc);
     var img = try Image.load(alloc, &cmd);
     defer img.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, img.validate(alloc));
+    try testing.expectError(error.DimensionsTooLarge, img.complete(alloc));
 }
 
 test "image load with image too tall" {
@@ -249,5 +269,5 @@ test "image load with image too tall" {
     defer cmd.deinit(alloc);
     var img = try Image.load(alloc, &cmd);
     defer img.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, img.validate(alloc));
+    try testing.expectError(error.DimensionsTooLarge, img.complete(alloc));
 }

commit b2432a672f931042d98bb87630c0908d2c762d2d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 08:28:20 2023 -0700

    terminal/kitty-gfx: add debug function to dump image data

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index f3c92fa5..aed2375c 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const builtin = @import("builtin");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
@@ -73,6 +74,31 @@ pub const Image = struct {
         UnsupportedMedium,
     };
 
+    /// Debug function to write the data to a file. This is useful for
+    /// capturing some test data for unit tests.
+    pub fn debugDump(self: Image) !void {
+        if (comptime builtin.mode != .Debug) @compileError("debugDump in non-debug");
+
+        var buf: [1024]u8 = undefined;
+        const filename = try std.fmt.bufPrint(
+            &buf,
+            "image-{s}-{s}-{d}x{d}-{}.data",
+            .{
+                @tagName(self.format),
+                @tagName(self.compression),
+                self.width,
+                self.height,
+                self.id,
+            },
+        );
+        const cwd = std.fs.cwd();
+        const f = try cwd.createFile(filename, .{});
+        defer f.close();
+
+        const writer = f.writer();
+        try writer.writeAll(self.data);
+    }
+
     /// The length of the data in bytes, uncompressed. While this will
     /// decompress compressed data to count the bytes it doesn't actually
     /// store the decompressed data so this doesn't allocate much.

commit a239f1198aa8df042272f6e42fd4bd3bb557588f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 08:48:30 2023 -0700

    terminal/kitty-gfx: decompress as part of image completion, tests

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index aed2375c..61f27055 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -11,6 +11,9 @@ const log = std.log.scoped(.kitty_gfx);
 /// Maximum width or height of an image. Taken directly from Kitty.
 const max_dimension = 10000;
 
+/// Maximum size in bytes, taken from Kitty.
+const max_size = 400 * 1024 * 1024; // 400MB
+
 /// A chunked image is an image that is in-progress and being constructed
 /// using chunks (the "m" parameter in the protocol).
 pub const ChunkedImage = struct {
@@ -99,37 +102,38 @@ pub const Image = struct {
         try writer.writeAll(self.data);
     }
 
-    /// The length of the data in bytes, uncompressed. While this will
-    /// decompress compressed data to count the bytes it doesn't actually
-    /// store the decompressed data so this doesn't allocate much.
-    pub fn dataLen(self: *const Image, alloc: Allocator) !usize {
+    /// Decompress the image data in-place.
+    fn decompress(self: *Image, alloc: Allocator) !void {
         return switch (self.compression) {
-            .none => self.data.len,
-            .zlib_deflate => zlib: {
-                var fbs = std.io.fixedBufferStream(self.data);
-
-                var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
-                    log.warn("zlib decompression failed: {}", .{err});
-                    return error.DecompressionFailed;
-                };
-                defer stream.deinit();
-
-                var counting_stream = std.io.countingReader(stream.reader());
-                const counting_reader = counting_stream.reader();
-
-                var buf: [4096]u8 = undefined;
-                while (counting_reader.readAll(&buf)) |_| {} else |err| {
-                    if (err != error.EndOfStream) {
-                        log.warn("zlib decompression failed: {}", .{err});
-                        return error.DecompressionFailed;
-                    }
-                }
-
-                break :zlib counting_stream.bytes_read;
-            },
+            .none => {},
+            .zlib_deflate => self.decompressZlib(alloc),
         };
     }
 
+    fn decompressZlib(self: *Image, alloc: Allocator) !void {
+        // Open our zlib stream
+        var fbs = std.io.fixedBufferStream(self.data);
+        var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
+            log.warn("zlib decompression failed: {}", .{err});
+            return error.DecompressionFailed;
+        };
+        defer stream.deinit();
+
+        // Write it to an array list
+        var list = std.ArrayList(u8).init(alloc);
+        defer list.deinit();
+        stream.reader().readAllArrayList(&list, max_size) catch |err| {
+            log.warn("failed to read decompressed data: {}", .{err});
+            return error.DecompressionFailed;
+        };
+
+        // Swap our data out
+        alloc.free(self.data);
+        self.data = "";
+        self.data = try list.toOwnedSlice();
+        self.compression = .none;
+    }
+
     /// Complete the image. This must be called after loading and after
     /// being sure the data is complete (not chunked).
     pub fn complete(self: *Image, alloc: Allocator) !void {
@@ -165,9 +169,12 @@ pub const Image = struct {
         alloc.free(self.data);
         self.data = decoded;
 
+        // Decompress the data if it is compressed.
+        try self.decompress(alloc);
+
         // Data length must be what we expect
         const expected_len = self.width * self.height * bpp;
-        const actual_len = try self.dataLen(alloc);
+        const actual_len = self.data.len;
         std.log.warn(
             "width={} height={} bpp={} expected_len={} actual_len={}",
             .{ self.width, self.height, bpp, expected_len, actual_len },
@@ -239,6 +246,14 @@ pub const Image = struct {
     }
 };
 
+/// Loads test data from a file path and base64 encodes it.
+fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
+    const B64Encoder = std.base64.standard.Encoder;
+    var b64 = try alloc.alloc(u8, B64Encoder.calcSize(data.len));
+    errdefer alloc.free(b64);
+    return B64Encoder.encode(b64, data);
+}
+
 // This specifically tests we ALLOW invalid RGB data because Kitty
 // documents that this should work.
 test "image load with invalid RGB data" {
@@ -297,3 +312,30 @@ test "image load with image too tall" {
     defer img.deinit(alloc);
     try testing.expectError(error.DimensionsTooLarge, img.complete(alloc));
 }
+
+test "image load: rgb, zlib compressed, direct" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .direct,
+            .compression = .zlib_deflate,
+            .height = 96,
+            .width = 128,
+            .image_id = 31,
+        } },
+        .data = try alloc.dupe(
+            u8,
+            @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data"),
+        ),
+    };
+    defer cmd.deinit(alloc);
+    var img = try Image.load(alloc, &cmd);
+    defer img.deinit(alloc);
+    try img.complete(alloc);
+
+    // should be decompressed
+    try testing.expect(img.compression == .none);
+}

commit 9c9a62bf3ceb69c76433b835bf86aeb36f27f7f3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 08:50:51 2023 -0700

    terminal/kitty-gfx: test for non-compressed rgb image

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 61f27055..490f1ce1 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -175,9 +175,9 @@ pub const Image = struct {
         // Data length must be what we expect
         const expected_len = self.width * self.height * bpp;
         const actual_len = self.data.len;
-        std.log.warn(
-            "width={} height={} bpp={} expected_len={} actual_len={}",
-            .{ self.width, self.height, bpp, expected_len, actual_len },
+        std.log.debug(
+            "complete image id={} width={} height={} bpp={} expected_len={} actual_len={}",
+            .{ self.id, self.width, self.height, bpp, expected_len, actual_len },
         );
         if (actual_len != expected_len) return error.InvalidData;
     }
@@ -339,3 +339,30 @@ test "image load: rgb, zlib compressed, direct" {
     // should be decompressed
     try testing.expect(img.compression == .none);
 }
+
+test "image load: rgb, not compressed, direct" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .direct,
+            .compression = .none,
+            .width = 20,
+            .height = 15,
+            .image_id = 31,
+        } },
+        .data = try alloc.dupe(
+            u8,
+            @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
+        ),
+    };
+    defer cmd.deinit(alloc);
+    var img = try Image.load(alloc, &cmd);
+    defer img.deinit(alloc);
+    try img.complete(alloc);
+
+    // should be decompressed
+    try testing.expect(img.compression == .none);
+}

commit e56bc01c7e9a4a0a62a8134f073b28c71e50b993
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 11:19:22 2023 -0700

    terminal/kitty-gfx: base64 decode data as it comes in

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 490f1ce1..a9cd83c7 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -47,6 +47,27 @@ pub const ChunkedImage = struct {
         alloc.destroy(self);
     }
 
+    /// Adds a chunk of base64-encoded data to the image.
+    pub fn addData(self: *ChunkedImage, alloc: Allocator, data: []const u8) !void {
+        const Base64Decoder = std.base64.standard.Decoder;
+
+        // Grow our array list by size capacity if it needs it
+        const size = Base64Decoder.calcSizeForSlice(data) catch |err| {
+            log.warn("failed to calculate size for base64 data: {}", .{err});
+            return error.InvalidData;
+        };
+        try self.data.ensureUnusedCapacity(alloc, size);
+
+        // We decode directly into the arraylist
+        const start_i = self.data.items.len;
+        self.data.items.len = start_i + size;
+        const buf = self.data.items[start_i..];
+        Base64Decoder.decode(buf, data) catch |err| {
+            log.warn("failed to decode base64 data: {}", .{err});
+            return error.InvalidData;
+        };
+    }
+
     /// Complete the chunked image, returning a completed image.
     pub fn complete(self: *ChunkedImage, alloc: Allocator) !Image {
         var result = self.image;
@@ -146,29 +167,6 @@ pub const Image = struct {
         if (self.width == 0 or self.height == 0) return error.DimensionsRequired;
         if (self.width > max_dimension or self.height > max_dimension) return error.DimensionsTooLarge;
 
-        // The data is base64 encoded, we must decode it.
-        var decoded = decoded: {
-            const Base64Decoder = std.base64.standard.Decoder;
-            const size = Base64Decoder.calcSizeForSlice(self.data) catch |err| {
-                log.warn("failed to calculate base64 decoded size: {}", .{err});
-                return error.InvalidData;
-            };
-
-            var buf = try alloc.alloc(u8, size);
-            errdefer alloc.free(buf);
-            Base64Decoder.decode(buf, self.data) catch |err| {
-                log.warn("failed to decode base64 data: {}", .{err});
-                return error.InvalidData;
-            };
-
-            break :decoded buf;
-        };
-
-        // After decoding, we swap the data immediately and free the old.
-        // This will ensure that we never leak memory.
-        alloc.free(self.data);
-        self.data = decoded;
-
         // Decompress the data if it is compressed.
         try self.decompress(alloc);
 
@@ -192,28 +190,53 @@ pub const Image = struct {
     pub fn load(alloc: Allocator, cmd: *command.Command) !Image {
         const t = cmd.transmission().?;
 
+        // We must have data to load an image
+        if (cmd.data.len == 0) return error.InvalidData;
+
         // Load the data
-        const data = switch (t.medium) {
-            .direct => cmd.data,
+        const raw_data = switch (t.medium) {
+            .direct => direct: {
+                const data = cmd.data;
+                _ = cmd.toOwnedData();
+                break :direct data;
+            },
+
             else => {
                 std.log.warn("unimplemented medium={}", .{t.medium});
                 return error.UnsupportedMedium;
             },
         };
 
+        // We always free the raw data because it is base64 decoded below
+        defer alloc.free(raw_data);
+
+        // We base64 the data immediately
+        const decoded_data = base64Decode(alloc, raw_data) catch |err| {
+            log.warn("failed to calculate base64 decoded size: {}", .{err});
+            return error.InvalidData;
+        };
+
         // If we loaded an image successfully then we take ownership
         // of the command data and we need to make sure to clean up on error.
-        _ = cmd.toOwnedData();
-        errdefer if (data.len > 0) alloc.free(data);
+        errdefer if (decoded_data.len > 0) alloc.free(decoded_data);
 
         const img = switch (t.format) {
-            .rgb, .rgba => try loadPacked(t, data),
+            .rgb, .rgba => try loadPacked(t, decoded_data),
             else => return error.UnsupportedFormat,
         };
 
         return img;
     }
 
+    /// Read the temporary file data from a command. This will also DELETE
+    /// the temporary file if it is successful and the temporary file is
+    /// in a safe, well-known location.
+    fn readTemporaryFile(alloc: Allocator, path: []const u8) ![]const u8 {
+        _ = alloc;
+        _ = path;
+        return "";
+    }
+
     /// Load a package image format, i.e. RGB or RGBA.
     fn loadPacked(
         t: command.Transmission,
@@ -246,6 +269,24 @@ pub const Image = struct {
     }
 };
 
+/// Helper to base64 decode some data. No data is freed.
+fn base64Decode(alloc: Allocator, data: []const u8) ![]const u8 {
+    const Base64Decoder = std.base64.standard.Decoder;
+    const size = Base64Decoder.calcSizeForSlice(data) catch |err| {
+        log.warn("failed to calculate base64 decoded size: {}", .{err});
+        return error.InvalidData;
+    };
+
+    var buf = try alloc.alloc(u8, size);
+    errdefer alloc.free(buf);
+    Base64Decoder.decode(buf, data) catch |err| {
+        log.warn("failed to decode base64 data: {}", .{err});
+        return error.InvalidData;
+    };
+
+    return buf;
+}
+
 /// Loads test data from a file path and base64 encodes it.
 fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
     const B64Encoder = std.base64.standard.Encoder;

commit fe79bd5cc914f2a3b1d15043d1c835477715349a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 11:40:03 2023 -0700

    terminal/kitty-gfx: centralize all image loading on LoadingImage

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index a9cd83c7..c3be5e90 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -14,9 +14,11 @@ const max_dimension = 10000;
 /// Maximum size in bytes, taken from Kitty.
 const max_size = 400 * 1024 * 1024; // 400MB
 
-/// A chunked image is an image that is in-progress and being constructed
-/// using chunks (the "m" parameter in the protocol).
-pub const ChunkedImage = struct {
+/// An image that is still being loaded. The image should be initialized
+/// using init on the first chunk and then addData for each subsequent
+/// chunk. Once all chunks have been added, complete should be called
+/// to finalize the image.
+pub const LoadingImage = struct {
     /// The in-progress image. The first chunk must have all the metadata
     /// so this comes from that initially.
     image: Image,
@@ -24,31 +26,66 @@ pub const ChunkedImage = struct {
     /// The data that is being built up.
     data: std.ArrayListUnmanaged(u8) = .{},
 
-    /// Initialize a chunked image from the first image part.
-    pub fn init(alloc: Allocator, image: Image) !ChunkedImage {
-        // Copy our initial set of data
-        var data = try std.ArrayListUnmanaged(u8).initCapacity(alloc, image.data.len * 2);
-        errdefer data.deinit(alloc);
-        try data.appendSlice(alloc, image.data);
+    /// Initialize a chunked immage from the first image transmission.
+    /// If this is a multi-chunk image, this should only be the FIRST
+    /// chunk.
+    pub fn init(alloc: Allocator, cmd: *command.Command) !LoadingImage {
+        // We must have data to load an image
+        if (cmd.data.len == 0) return error.InvalidData;
+
+        // Build our initial image from the properties sent via the control.
+        // These can be overwritten by the data loading process. For example,
+        // PNG loading sets the width/height from the data.
+        const t = cmd.transmission().?;
+        var result: LoadingImage = .{
+            .image = .{
+                .id = t.image_id,
+                .number = t.image_number,
+                .width = t.width,
+                .height = t.height,
+                .compression = t.compression,
+                .format = switch (t.format) {
+                    .rgb => .rgb,
+                    .rgba => .rgba,
+                    else => unreachable,
+                },
+            },
+        };
+
+        // Load the base64 encoded data from the transmission medium.
+        const raw_data = switch (t.medium) {
+            .direct => direct: {
+                const data = cmd.data;
+                _ = cmd.toOwnedData();
+                break :direct data;
+            },
+
+            else => {
+                std.log.warn("unimplemented medium={}", .{t.medium});
+                return error.UnsupportedMedium;
+            },
+        };
+        defer alloc.free(raw_data);
+
+        // Add the data
+        try result.addData(alloc, raw_data);
 
-        // Set data to empty so it doesn't get freed.
-        var result: ChunkedImage = .{ .image = image, .data = data };
-        result.image.data = "";
         return result;
     }
 
-    pub fn deinit(self: *ChunkedImage, alloc: Allocator) void {
+    pub fn deinit(self: *LoadingImage, alloc: Allocator) void {
         self.image.deinit(alloc);
         self.data.deinit(alloc);
     }
 
-    pub fn destroy(self: *ChunkedImage, alloc: Allocator) void {
+    pub fn destroy(self: *LoadingImage, alloc: Allocator) void {
         self.deinit(alloc);
         alloc.destroy(self);
     }
 
-    /// Adds a chunk of base64-encoded data to the image.
-    pub fn addData(self: *ChunkedImage, alloc: Allocator, data: []const u8) !void {
+    /// Adds a chunk of base64-encoded data to the image. Use this if the
+    /// image is coming in chunks (the "m" parameter in the protocol).
+    pub fn addData(self: *LoadingImage, alloc: Allocator, data: []const u8) !void {
         const Base64Decoder = std.base64.standard.Decoder;
 
         // Grow our array list by size capacity if it needs it
@@ -69,10 +106,12 @@ pub const ChunkedImage = struct {
     }
 
     /// Complete the chunked image, returning a completed image.
-    pub fn complete(self: *ChunkedImage, alloc: Allocator) !Image {
+    pub fn complete(self: *LoadingImage, alloc: Allocator) !Image {
         var result = self.image;
         result.data = try self.data.toOwnedSlice(alloc);
+        errdefer result.deinit(alloc);
         self.image = .{};
+        try result.complete(alloc);
         return result;
     }
 };
@@ -180,83 +219,6 @@ pub const Image = struct {
         if (actual_len != expected_len) return error.InvalidData;
     }
 
-    /// Load an image from a transmission. The data in the command will be
-    /// owned by the image if successful. Note that you still must deinit
-    /// the command, all the state change will be done internally.
-    ///
-    /// If the command represents a chunked image then this image will
-    /// be incomplete. The caller is expected to inspect the command
-    /// and determine if it is a chunked image.
-    pub fn load(alloc: Allocator, cmd: *command.Command) !Image {
-        const t = cmd.transmission().?;
-
-        // We must have data to load an image
-        if (cmd.data.len == 0) return error.InvalidData;
-
-        // Load the data
-        const raw_data = switch (t.medium) {
-            .direct => direct: {
-                const data = cmd.data;
-                _ = cmd.toOwnedData();
-                break :direct data;
-            },
-
-            else => {
-                std.log.warn("unimplemented medium={}", .{t.medium});
-                return error.UnsupportedMedium;
-            },
-        };
-
-        // We always free the raw data because it is base64 decoded below
-        defer alloc.free(raw_data);
-
-        // We base64 the data immediately
-        const decoded_data = base64Decode(alloc, raw_data) catch |err| {
-            log.warn("failed to calculate base64 decoded size: {}", .{err});
-            return error.InvalidData;
-        };
-
-        // If we loaded an image successfully then we take ownership
-        // of the command data and we need to make sure to clean up on error.
-        errdefer if (decoded_data.len > 0) alloc.free(decoded_data);
-
-        const img = switch (t.format) {
-            .rgb, .rgba => try loadPacked(t, decoded_data),
-            else => return error.UnsupportedFormat,
-        };
-
-        return img;
-    }
-
-    /// Read the temporary file data from a command. This will also DELETE
-    /// the temporary file if it is successful and the temporary file is
-    /// in a safe, well-known location.
-    fn readTemporaryFile(alloc: Allocator, path: []const u8) ![]const u8 {
-        _ = alloc;
-        _ = path;
-        return "";
-    }
-
-    /// Load a package image format, i.e. RGB or RGBA.
-    fn loadPacked(
-        t: command.Transmission,
-        data: []const u8,
-    ) !Image {
-        return Image{
-            .id = t.image_id,
-            .number = t.image_number,
-            .width = t.width,
-            .height = t.height,
-            .compression = t.compression,
-            .format = switch (t.format) {
-                .rgb => .rgb,
-                .rgba => .rgba,
-                else => unreachable,
-            },
-            .data = data,
-        };
-    }
-
     pub fn deinit(self: *Image, alloc: Allocator) void {
         if (self.data.len > 0) alloc.free(self.data);
     }
@@ -312,8 +274,8 @@ test "image load with invalid RGB data" {
         .data = try alloc.dupe(u8, "AAAA"),
     };
     defer cmd.deinit(alloc);
-    var img = try Image.load(alloc, &cmd);
-    defer img.deinit(alloc);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
 }
 
 test "image load with image too wide" {
@@ -330,9 +292,9 @@ test "image load with image too wide" {
         .data = try alloc.dupe(u8, "AAAA"),
     };
     defer cmd.deinit(alloc);
-    var img = try Image.load(alloc, &cmd);
-    defer img.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, img.complete(alloc));
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    try testing.expectError(error.DimensionsTooLarge, loading.complete(alloc));
 }
 
 test "image load with image too tall" {
@@ -349,9 +311,9 @@ test "image load with image too tall" {
         .data = try alloc.dupe(u8, "AAAA"),
     };
     defer cmd.deinit(alloc);
-    var img = try Image.load(alloc, &cmd);
-    defer img.deinit(alloc);
-    try testing.expectError(error.DimensionsTooLarge, img.complete(alloc));
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    try testing.expectError(error.DimensionsTooLarge, loading.complete(alloc));
 }
 
 test "image load: rgb, zlib compressed, direct" {
@@ -373,9 +335,10 @@ test "image load: rgb, zlib compressed, direct" {
         ),
     };
     defer cmd.deinit(alloc);
-    var img = try Image.load(alloc, &cmd);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    var img = try loading.complete(alloc);
     defer img.deinit(alloc);
-    try img.complete(alloc);
 
     // should be decompressed
     try testing.expect(img.compression == .none);
@@ -400,9 +363,10 @@ test "image load: rgb, not compressed, direct" {
         ),
     };
     defer cmd.deinit(alloc);
-    var img = try Image.load(alloc, &cmd);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    var img = try loading.complete(alloc);
     defer img.deinit(alloc);
-    try img.complete(alloc);
 
     // should be decompressed
     try testing.expect(img.compression == .none);

commit 53c39c39d661f133aefca38e9e4b4fae63c6e3e4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 11:52:12 2023 -0700

    terminal/kitty-gfx: move all image decompression to loadingimage

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index c3be5e90..8e4f9561 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -107,13 +107,68 @@ pub const LoadingImage = struct {
 
     /// Complete the chunked image, returning a completed image.
     pub fn complete(self: *LoadingImage, alloc: Allocator) !Image {
+        const img = &self.image;
+
+        // Validate our dimensions.
+        if (img.width == 0 or img.height == 0) return error.DimensionsRequired;
+        if (img.width > max_dimension or img.height > max_dimension) return error.DimensionsTooLarge;
+
+        // Decompress the data if it is compressed.
+        try self.decompress(alloc);
+
+        // Data length must be what we expect
+        const bpp: u32 = switch (img.format) {
+            .rgb => 3,
+            .rgba => 4,
+        };
+        const expected_len = img.width * img.height * bpp;
+        const actual_len = self.data.items.len;
+        std.log.debug(
+            "complete image id={} width={} height={} bpp={} expected_len={} actual_len={}",
+            .{ img.id, img.width, img.height, bpp, expected_len, actual_len },
+        );
+        if (actual_len != expected_len) return error.InvalidData;
+
+        // Everything looks good, copy the image data over.
         var result = self.image;
         result.data = try self.data.toOwnedSlice(alloc);
         errdefer result.deinit(alloc);
         self.image = .{};
-        try result.complete(alloc);
         return result;
     }
+
+    /// Decompress the data in-place.
+    fn decompress(self: *LoadingImage, alloc: Allocator) !void {
+        return switch (self.image.compression) {
+            .none => {},
+            .zlib_deflate => self.decompressZlib(alloc),
+        };
+    }
+
+    fn decompressZlib(self: *LoadingImage, alloc: Allocator) !void {
+        // Open our zlib stream
+        var fbs = std.io.fixedBufferStream(self.data.items);
+        var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
+            log.warn("zlib decompression failed: {}", .{err});
+            return error.DecompressionFailed;
+        };
+        defer stream.deinit();
+
+        // Write it to an array list
+        var list = std.ArrayList(u8).init(alloc);
+        errdefer list.deinit();
+        stream.reader().readAllArrayList(&list, max_size) catch |err| {
+            log.warn("failed to read decompressed data: {}", .{err});
+            return error.DecompressionFailed;
+        };
+
+        // Empty our current data list, take ownership over managed array list
+        self.data.deinit(alloc);
+        self.data = .{ .items = list.items, .capacity = list.capacity };
+
+        // Make sure we note that our image is no longer compressed
+        self.image.compression = .none;
+    }
 };
 
 /// Image represents a single fully loaded image.
@@ -137,6 +192,17 @@ pub const Image = struct {
         UnsupportedMedium,
     };
 
+    pub fn deinit(self: *Image, alloc: Allocator) void {
+        if (self.data.len > 0) alloc.free(self.data);
+    }
+
+    /// Mostly for logging
+    pub fn withoutData(self: *const Image) Image {
+        var copy = self.*;
+        copy.data = "";
+        return copy;
+    }
+
     /// Debug function to write the data to a file. This is useful for
     /// capturing some test data for unit tests.
     pub fn debugDump(self: Image) !void {
@@ -161,74 +227,6 @@ pub const Image = struct {
         const writer = f.writer();
         try writer.writeAll(self.data);
     }
-
-    /// Decompress the image data in-place.
-    fn decompress(self: *Image, alloc: Allocator) !void {
-        return switch (self.compression) {
-            .none => {},
-            .zlib_deflate => self.decompressZlib(alloc),
-        };
-    }
-
-    fn decompressZlib(self: *Image, alloc: Allocator) !void {
-        // Open our zlib stream
-        var fbs = std.io.fixedBufferStream(self.data);
-        var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
-            log.warn("zlib decompression failed: {}", .{err});
-            return error.DecompressionFailed;
-        };
-        defer stream.deinit();
-
-        // Write it to an array list
-        var list = std.ArrayList(u8).init(alloc);
-        defer list.deinit();
-        stream.reader().readAllArrayList(&list, max_size) catch |err| {
-            log.warn("failed to read decompressed data: {}", .{err});
-            return error.DecompressionFailed;
-        };
-
-        // Swap our data out
-        alloc.free(self.data);
-        self.data = "";
-        self.data = try list.toOwnedSlice();
-        self.compression = .none;
-    }
-
-    /// Complete the image. This must be called after loading and after
-    /// being sure the data is complete (not chunked).
-    pub fn complete(self: *Image, alloc: Allocator) !void {
-        const bpp: u32 = switch (self.format) {
-            .rgb => 3,
-            .rgba => 4,
-        };
-
-        // Validate our dimensions.
-        if (self.width == 0 or self.height == 0) return error.DimensionsRequired;
-        if (self.width > max_dimension or self.height > max_dimension) return error.DimensionsTooLarge;
-
-        // Decompress the data if it is compressed.
-        try self.decompress(alloc);
-
-        // Data length must be what we expect
-        const expected_len = self.width * self.height * bpp;
-        const actual_len = self.data.len;
-        std.log.debug(
-            "complete image id={} width={} height={} bpp={} expected_len={} actual_len={}",
-            .{ self.id, self.width, self.height, bpp, expected_len, actual_len },
-        );
-        if (actual_len != expected_len) return error.InvalidData;
-    }
-
-    pub fn deinit(self: *Image, alloc: Allocator) void {
-        if (self.data.len > 0) alloc.free(self.data);
-    }
-
-    /// Mostly for logging
-    pub fn withoutData(self: *const Image) Image {
-        var copy = self.*;
-        copy.data = "";
-        return copy;
-    }
 };
 
 /// Helper to base64 decode some data. No data is freed.

commit d821e023f3426edf63822a71e814ef5c26a1fe1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 12:06:26 2023 -0700

    terminal/kitty-gfx: test chunked loads

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 8e4f9561..9604529b 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -369,3 +369,39 @@ test "image load: rgb, not compressed, direct" {
     // should be decompressed
     try testing.expect(img.compression == .none);
 }
+
+test "image load: rgb, zlib compressed, direct, chunked" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data");
+
+    // Setup our initial chunk
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .direct,
+            .compression = .zlib_deflate,
+            .height = 96,
+            .width = 128,
+            .image_id = 31,
+            .more_chunks = true,
+        } },
+        .data = try alloc.dupe(u8, data[0..1024]),
+    };
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+
+    // Read our remaining chunks
+    var fbs = std.io.fixedBufferStream(data[1024..]);
+    var buf: [1024]u8 = undefined;
+    while (fbs.reader().readAll(&buf)) |size| {
+        try loading.addData(alloc, buf[0..size]);
+        if (size < buf.len) break;
+    } else |err| return err;
+
+    // Complete
+    var img = try loading.complete(alloc);
+    defer img.deinit(alloc);
+    try testing.expect(img.compression == .none);
+}

commit 5bb99efb84cad21303217b57cdd45cbf13df716a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 14:28:28 2023 -0700

    terminal/kitty-gfx: temporary file medium

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 9604529b..d415b8f7 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -5,6 +5,7 @@ const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 
 const command = @import("graphics_command.zig");
+const internal_os = @import("../../os/main.zig");
 
 const log = std.log.scoped(.kitty_gfx);
 
@@ -52,25 +53,112 @@ pub const LoadingImage = struct {
             },
         };
 
-        // Load the base64 encoded data from the transmission medium.
-        const raw_data = switch (t.medium) {
-            .direct => direct: {
-                const data = cmd.data;
-                _ = cmd.toOwnedData();
-                break :direct data;
-            },
+        // Special case for the direct medium, we just add it directly
+        // which will handle copying the data, base64 decoding, etc.
+        if (t.medium == .direct) {
+            try result.addData(alloc, cmd.data);
+            return result;
+        }
+
+        // For every other medium, we'll need to at least base64 decode
+        // the data to make it useful so let's do that. Also, all the data
+        // has to be path data so we can put it in a stack-allocated buffer.
+        var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+        const Base64Decoder = std.base64.standard.Decoder;
+        const size = Base64Decoder.calcSizeForSlice(cmd.data) catch |err| {
+            log.warn("failed to calculate base64 size for file path: {}", .{err});
+            return error.InvalidData;
+        };
+        if (size > buf.len) return error.FilePathTooLong;
+        Base64Decoder.decode(&buf, cmd.data) catch |err| {
+            log.warn("failed to decode base64 data: {}", .{err});
+            return error.InvalidData;
+        };
+        var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+        const path = std.os.realpath(buf[0..size], &abs_buf) catch |err| {
+            log.warn("failed to get absolute path: {}", .{err});
+            return error.InvalidData;
+        };
+
+        // Depending on the medium, load the data from the path.
+        switch (t.medium) {
+            .direct => unreachable, // handled above
+
+            .temporary_file => try result.readTemporaryFile(alloc, t, path),
 
             else => {
                 std.log.warn("unimplemented medium={}", .{t.medium});
                 return error.UnsupportedMedium;
             },
+        }
+
+        return result;
+    }
+
+    /// Reads the data from a temporary file and returns it. This allocates
+    /// and does not free any of the data, so the caller must free it.
+    ///
+    /// This will also delete the temporary file if it is in a safe location.
+    fn readTemporaryFile(
+        self: *LoadingImage,
+        alloc: Allocator,
+        t: command.Transmission,
+        path: []const u8,
+    ) !void {
+        if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
+
+        // Delete the temporary file
+        defer std.os.unlink(path) catch |err| {
+            log.warn("failed to delete temporary file: {}", .{err});
         };
-        defer alloc.free(raw_data);
 
-        // Add the data
-        try result.addData(alloc, raw_data);
+        var file = std.fs.cwd().openFile(path, .{}) catch |err| {
+            log.warn("failed to open temporary file: {}", .{err});
+            return error.InvalidData;
+        };
+        defer file.close();
+
+        if (t.offset > 0) {
+            file.seekTo(@intCast(t.offset)) catch |err| {
+                log.warn("failed to seek to offset {}: {}", .{ t.offset, err });
+                return error.InvalidData;
+            };
+        }
+
+        var buf_reader = std.io.bufferedReader(file.reader());
+        const reader = buf_reader.reader();
+
+        // Read the file
+        var managed = std.ArrayList(u8).init(alloc);
+        errdefer managed.deinit();
+        const size: usize = if (t.size > 0) @min(t.size, max_size) else max_size;
+        reader.readAllArrayList(&managed, size) catch |err| {
+            log.warn("failed to read temporary file: {}", .{err});
+            return error.InvalidData;
+        };
 
-        return result;
+        // Set our data
+        assert(self.data.items.len == 0);
+        self.data = .{ .items = managed.items, .capacity = managed.capacity };
+    }
+
+    /// Returns true if path appears to be in a temporary directory.
+    /// Copies logic from Kitty.
+    fn isPathInTempDir(path: []const u8) bool {
+        if (std.mem.startsWith(u8, path, "/tmp")) return true;
+        if (std.mem.startsWith(u8, path, "/dev/shm")) return true;
+        if (internal_os.tmpDir()) |dir| {
+            if (std.mem.startsWith(u8, path, dir)) return true;
+
+            // The temporary dir is sometimes a symlink. On macOS for
+            // example /tmp is /private/var/...
+            var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            if (std.os.realpath(dir, &buf)) |real_dir| {
+                if (std.mem.startsWith(u8, path, real_dir)) return true;
+            } else |_| {}
+        }
+
+        return false;
     }
 
     pub fn deinit(self: *LoadingImage, alloc: Allocator) void {
@@ -123,11 +211,13 @@ pub const LoadingImage = struct {
         };
         const expected_len = img.width * img.height * bpp;
         const actual_len = self.data.items.len;
-        std.log.debug(
-            "complete image id={} width={} height={} bpp={} expected_len={} actual_len={}",
-            .{ img.id, img.width, img.height, bpp, expected_len, actual_len },
-        );
-        if (actual_len != expected_len) return error.InvalidData;
+        if (actual_len != expected_len) {
+            std.log.warn(
+                "unexpected length image id={} width={} height={} bpp={} expected_len={} actual_len={}",
+                .{ img.id, img.width, img.height, bpp, expected_len, actual_len },
+            );
+            return error.InvalidData;
+        }
 
         // Everything looks good, copy the image data over.
         var result = self.image;
@@ -188,6 +278,8 @@ pub const Image = struct {
         DecompressionFailed,
         DimensionsRequired,
         DimensionsTooLarge,
+        FilePathTooLong,
+        TemporaryFileNotInTempDir,
         UnsupportedFormat,
         UnsupportedMedium,
     };
@@ -229,25 +321,7 @@ pub const Image = struct {
     }
 };
 
-/// Helper to base64 decode some data. No data is freed.
-fn base64Decode(alloc: Allocator, data: []const u8) ![]const u8 {
-    const Base64Decoder = std.base64.standard.Decoder;
-    const size = Base64Decoder.calcSizeForSlice(data) catch |err| {
-        log.warn("failed to calculate base64 decoded size: {}", .{err});
-        return error.InvalidData;
-    };
-
-    var buf = try alloc.alloc(u8, size);
-    errdefer alloc.free(buf);
-    Base64Decoder.decode(buf, data) catch |err| {
-        log.warn("failed to decode base64 data: {}", .{err});
-        return error.InvalidData;
-    };
-
-    return buf;
-}
-
-/// Loads test data from a file path and base64 encodes it.
+/// Easy base64 encoding function.
 fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
     const B64Encoder = std.base64.standard.Encoder;
     var b64 = try alloc.alloc(u8, B64Encoder.calcSize(data.len));
@@ -255,6 +329,15 @@ fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
     return B64Encoder.encode(b64, data);
 }
 
+/// Easy base64 decoding function.
+fn testB64Decode(alloc: Allocator, data: []const u8) ![]const u8 {
+    const B64Decoder = std.base64.standard.Decoder;
+    var result = try alloc.alloc(u8, try B64Decoder.calcSizeForSlice(data));
+    errdefer alloc.free(result);
+    try B64Decoder.decode(result, data);
+    return result;
+}
+
 // This specifically tests we ALLOW invalid RGB data because Kitty
 // documents that this should work.
 test "image load with invalid RGB data" {
@@ -389,6 +472,7 @@ test "image load: rgb, zlib compressed, direct, chunked" {
         } },
         .data = try alloc.dupe(u8, data[0..1024]),
     };
+    defer cmd.deinit(alloc);
     var loading = try LoadingImage.init(alloc, &cmd);
     defer loading.deinit(alloc);
 
@@ -405,3 +489,41 @@ test "image load: rgb, zlib compressed, direct, chunked" {
     defer img.deinit(alloc);
     try testing.expect(img.compression == .none);
 }
+
+test "image load: rgb, not compressed, temporary file" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var tmp_dir = try internal_os.TempDir.init();
+    defer tmp_dir.deinit();
+    const data = try testB64Decode(
+        alloc,
+        @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
+    );
+    defer alloc.free(data);
+    try tmp_dir.dir.writeFile("image.data", data);
+
+    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const path = try tmp_dir.dir.realpath("image.data", &buf);
+
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .temporary_file,
+            .compression = .none,
+            .width = 20,
+            .height = 15,
+            .image_id = 31,
+        } },
+        .data = try testB64(alloc, path),
+    };
+    defer cmd.deinit(alloc);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    var img = try loading.complete(alloc);
+    defer img.deinit(alloc);
+    try testing.expect(img.compression == .none);
+
+    // Temporary file should be gone
+    try testing.expectError(error.FileNotFound, tmp_dir.dir.access(path, .{}));
+}

commit a5a977be9f81b85efd74ca2e5b4cd5e5733f0489
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 14:52:46 2023 -0700

    terminal/kitty-gfx: file medium

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index d415b8f7..89c01d3a 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -83,33 +83,56 @@ pub const LoadingImage = struct {
         // Depending on the medium, load the data from the path.
         switch (t.medium) {
             .direct => unreachable, // handled above
-
-            .temporary_file => try result.readTemporaryFile(alloc, t, path),
-
-            else => {
-                std.log.warn("unimplemented medium={}", .{t.medium});
-                return error.UnsupportedMedium;
-            },
+            .file => try result.readFile(.file, alloc, t, path),
+            .temporary_file => try result.readFile(.temporary_file, alloc, t, path),
+            .shared_memory => try result.readSharedMemory(alloc, t, path),
         }
 
         return result;
     }
 
+    /// Reads the data from a shared memory segment.
+    fn readSharedMemory(
+        self: *LoadingImage,
+        alloc: Allocator,
+        t: command.Transmission,
+        path: []const u8,
+    ) !void {
+        // We require libc for this for shm_open
+        if (comptime !builtin.link_libc) return error.UnsupportedMedium;
+
+        // Todo: support shared memory
+        _ = self;
+        _ = alloc;
+        _ = t;
+        _ = path;
+        return error.UnsupportedMedium;
+    }
+
     /// Reads the data from a temporary file and returns it. This allocates
     /// and does not free any of the data, so the caller must free it.
     ///
     /// This will also delete the temporary file if it is in a safe location.
-    fn readTemporaryFile(
+    fn readFile(
         self: *LoadingImage,
+        comptime medium: command.Transmission.Medium,
         alloc: Allocator,
         t: command.Transmission,
         path: []const u8,
     ) !void {
-        if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
+        switch (medium) {
+            .file, .temporary_file => {},
+            else => @compileError("readFile only supports file and temporary_file"),
+        }
 
-        // Delete the temporary file
-        defer std.os.unlink(path) catch |err| {
-            log.warn("failed to delete temporary file: {}", .{err});
+        // Temporary file logic
+        if (medium == .temporary_file) {
+            if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
+        }
+        defer if (medium == .temporary_file) {
+            std.os.unlink(path) catch |err| {
+                log.warn("failed to delete temporary file: {}", .{err});
+            };
         };
 
         var file = std.fs.cwd().openFile(path, .{}) catch |err| {
@@ -527,3 +550,39 @@ test "image load: rgb, not compressed, temporary file" {
     // Temporary file should be gone
     try testing.expectError(error.FileNotFound, tmp_dir.dir.access(path, .{}));
 }
+
+test "image load: rgb, not compressed, regular file" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var tmp_dir = try internal_os.TempDir.init();
+    defer tmp_dir.deinit();
+    const data = try testB64Decode(
+        alloc,
+        @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
+    );
+    defer alloc.free(data);
+    try tmp_dir.dir.writeFile("image.data", data);
+
+    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const path = try tmp_dir.dir.realpath("image.data", &buf);
+
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .file,
+            .compression = .none,
+            .width = 20,
+            .height = 15,
+            .image_id = 31,
+        } },
+        .data = try testB64(alloc, path),
+    };
+    defer cmd.deinit(alloc);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    var img = try loading.complete(alloc);
+    defer img.deinit(alloc);
+    try testing.expect(img.compression == .none);
+    try tmp_dir.dir.access(path, .{});
+}

commit a02fa4e705991f7940b1daae1c38ad331dbb235d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 21 15:09:42 2023 -0700

    terminal/kitty-gfx: png decoding

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 89c01d3a..77b46264 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -6,6 +6,7 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 
 const command = @import("graphics_command.zig");
 const internal_os = @import("../../os/main.zig");
+const stb = @import("../../stb/main.zig");
 
 const log = std.log.scoped(.kitty_gfx);
 
@@ -45,11 +46,7 @@ pub const LoadingImage = struct {
                 .width = t.width,
                 .height = t.height,
                 .compression = t.compression,
-                .format = switch (t.format) {
-                    .rgb => .rgb,
-                    .rgba => .rgba,
-                    else => unreachable,
-                },
+                .format = t.format,
             },
         };
 
@@ -220,17 +217,21 @@ pub const LoadingImage = struct {
     pub fn complete(self: *LoadingImage, alloc: Allocator) !Image {
         const img = &self.image;
 
+        // Decompress the data if it is compressed.
+        try self.decompress(alloc);
+
+        // Decode the png if we have to
+        if (img.format == .png) try self.decodePng(alloc);
+
         // Validate our dimensions.
         if (img.width == 0 or img.height == 0) return error.DimensionsRequired;
         if (img.width > max_dimension or img.height > max_dimension) return error.DimensionsTooLarge;
 
-        // Decompress the data if it is compressed.
-        try self.decompress(alloc);
-
         // Data length must be what we expect
         const bpp: u32 = switch (img.format) {
             .rgb => 3,
             .rgba => 4,
+            .png => unreachable, // png should be decoded by here
         };
         const expected_len = img.width * img.height * bpp;
         const actual_len = self.data.items.len;
@@ -250,6 +251,31 @@ pub const LoadingImage = struct {
         return result;
     }
 
+    /// Debug function to write the data to a file. This is useful for
+    /// capturing some test data for unit tests.
+    pub fn debugDump(self: LoadingImage) !void {
+        if (comptime builtin.mode != .Debug) @compileError("debugDump in non-debug");
+
+        var buf: [1024]u8 = undefined;
+        const filename = try std.fmt.bufPrint(
+            &buf,
+            "image-{s}-{s}-{d}x{d}-{}.data",
+            .{
+                @tagName(self.image.format),
+                @tagName(self.image.compression),
+                self.image.width,
+                self.image.height,
+                self.image.id,
+            },
+        );
+        const cwd = std.fs.cwd();
+        const f = try cwd.createFile(filename, .{});
+        defer f.close();
+
+        const writer = f.writer();
+        try writer.writeAll(self.data.items);
+    }
+
     /// Decompress the data in-place.
     fn decompress(self: *LoadingImage, alloc: Allocator) !void {
         return switch (self.image.compression) {
@@ -282,6 +308,44 @@ pub const LoadingImage = struct {
         // Make sure we note that our image is no longer compressed
         self.image.compression = .none;
     }
+
+    /// Decode the data as PNG. This will also updated the image dimensions.
+    fn decodePng(self: *LoadingImage, alloc: Allocator) !void {
+        assert(self.image.format == .png);
+
+        // Decode PNG
+        var width: c_int = 0;
+        var height: c_int = 0;
+        var bpp: c_int = 0;
+        const data = stb.stbi_load_from_memory(
+            self.data.items.ptr,
+            @intCast(self.data.items.len),
+            &width,
+            &height,
+            &bpp,
+            0,
+        ) orelse return error.InvalidData;
+        defer stb.stbi_image_free(data);
+        const len: usize = @intCast(width * height * bpp);
+
+        // Validate our bpp
+        if (bpp != 3 and bpp != 4) return error.UnsupportedDepth;
+
+        // Replace our data
+        self.data.deinit(alloc);
+        self.data = .{};
+        try self.data.ensureUnusedCapacity(alloc, len);
+        try self.data.appendSlice(alloc, data[0..len]);
+
+        // Store updated image dimensions
+        self.image.width = @intCast(width);
+        self.image.height = @intCast(height);
+        self.image.format = switch (bpp) {
+            3 => .rgb,
+            4 => .rgba,
+            else => unreachable, // validated above
+        };
+    }
 };
 
 /// Image represents a single fully loaded image.
@@ -290,12 +354,10 @@ pub const Image = struct {
     number: u32 = 0,
     width: u32 = 0,
     height: u32 = 0,
-    format: Format = .rgb,
+    format: command.Transmission.Format = .rgb,
     compression: command.Transmission.Compression = .none,
     data: []const u8 = "",
 
-    pub const Format = enum { rgb, rgba };
-
     pub const Error = error{
         InvalidData,
         DecompressionFailed,
@@ -305,6 +367,7 @@ pub const Image = struct {
         TemporaryFileNotInTempDir,
         UnsupportedFormat,
         UnsupportedMedium,
+        UnsupportedDepth,
     };
 
     pub fn deinit(self: *Image, alloc: Allocator) void {
@@ -317,31 +380,6 @@ pub const Image = struct {
         copy.data = "";
         return copy;
     }
-
-    /// Debug function to write the data to a file. This is useful for
-    /// capturing some test data for unit tests.
-    pub fn debugDump(self: Image) !void {
-        if (comptime builtin.mode != .Debug) @compileError("debugDump in non-debug");
-
-        var buf: [1024]u8 = undefined;
-        const filename = try std.fmt.bufPrint(
-            &buf,
-            "image-{s}-{s}-{d}x{d}-{}.data",
-            .{
-                @tagName(self.format),
-                @tagName(self.compression),
-                self.width,
-                self.height,
-                self.id,
-            },
-        );
-        const cwd = std.fs.cwd();
-        const f = try cwd.createFile(filename, .{});
-        defer f.close();
-
-        const writer = f.writer();
-        try writer.writeAll(self.data);
-    }
 };
 
 /// Easy base64 encoding function.
@@ -586,3 +624,36 @@ test "image load: rgb, not compressed, regular file" {
     try testing.expect(img.compression == .none);
     try tmp_dir.dir.access(path, .{});
 }
+
+test "image load: png, not compressed, regular file" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var tmp_dir = try internal_os.TempDir.init();
+    defer tmp_dir.deinit();
+    const data = @embedFile("testdata/image-png-none-50x76-2147483647-raw.data");
+    try tmp_dir.dir.writeFile("image.data", data);
+
+    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    const path = try tmp_dir.dir.realpath("image.data", &buf);
+
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .png,
+            .medium = .file,
+            .compression = .none,
+            .width = 0,
+            .height = 0,
+            .image_id = 31,
+        } },
+        .data = try testB64(alloc, path),
+    };
+    defer cmd.deinit(alloc);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+    var img = try loading.complete(alloc);
+    defer img.deinit(alloc);
+    try testing.expect(img.compression == .none);
+    try testing.expect(img.format == .rgb);
+    try tmp_dir.dir.access(path, .{});
+}

commit 6f7a9c45238018927131409b58e46c0672a5b956
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 11:07:48 2023 -0700

    terminal/kitty-gfx: we need to use rect, not sel

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 77b46264..a0c4eaba 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -5,6 +5,7 @@ const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 
 const command = @import("graphics_command.zig");
+const point = @import("../point.zig");
 const internal_os = @import("../../os/main.zig");
 const stb = @import("../../stb/main.zig");
 
@@ -382,6 +383,22 @@ pub const Image = struct {
     }
 };
 
+/// The rect taken up by some image placement, in grid cells. This will
+/// be rounded up to the nearest grid cell since we can't place images
+/// in partial grid cells.
+pub const Rect = struct {
+    top_left: point.ScreenPoint = .{},
+    bottom_right: point.ScreenPoint = .{},
+
+    /// True if the rect contains a given screen point.
+    pub fn contains(self: Rect, p: point.ScreenPoint) bool {
+        return p.y >= self.top_left.y and
+            p.y <= self.bottom_right.y and
+            p.x >= self.top_left.x and
+            p.x <= self.bottom_right.x;
+    }
+};
+
 /// Easy base64 encoding function.
 fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
     const B64Encoder = std.base64.standard.Encoder;

commit c0b58802bae0f75381251e5303cfd338374d7ba0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 11:17:58 2023 -0700

    terminal/kitty-gfx: images store transmit time

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index a0c4eaba..4eb0d2f9 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -244,6 +244,12 @@ pub const LoadingImage = struct {
             return error.InvalidData;
         }
 
+        // Set our time
+        self.image.transmit_time = std.time.Instant.now() catch |err| {
+            log.warn("failed to get time: {}", .{err});
+            return error.InternalError;
+        };
+
         // Everything looks good, copy the image data over.
         var result = self.image;
         result.data = try self.data.toOwnedSlice(alloc);
@@ -358,8 +364,10 @@ pub const Image = struct {
     format: command.Transmission.Format = .rgb,
     compression: command.Transmission.Compression = .none,
     data: []const u8 = "",
+    transmit_time: std.time.Instant = undefined,
 
     pub const Error = error{
+        InternalError,
         InvalidData,
         DecompressionFailed,
         DimensionsRequired,

commit 91a4be4ca16a9b954756f0c932bf4b4b409acbc4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 11:52:31 2023 -0700

    terminal/kitty-gfx: add file loading safety checks from Kitty

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 4eb0d2f9..8a6ecacd 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -123,6 +123,16 @@ pub const LoadingImage = struct {
             else => @compileError("readFile only supports file and temporary_file"),
         }
 
+        // Verify file seems "safe". This is logic copied directly from Kitty,
+        // mostly. This is really rough but it will catch obvious bad actors.
+        if (std.mem.startsWith(u8, path, "/proc/") or
+            std.mem.startsWith(u8, path, "/sys/") or
+            (std.mem.startsWith(u8, path, "/dev/") and
+            !std.mem.startsWith(u8, path, "/dev/shm/")))
+        {
+            return error.InvalidData;
+        }
+
         // Temporary file logic
         if (medium == .temporary_file) {
             if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
@@ -139,6 +149,17 @@ pub const LoadingImage = struct {
         };
         defer file.close();
 
+        // File must be a regular file
+        if (file.stat()) |stat| {
+            if (stat.kind != .file) {
+                log.warn("file is not a regular file kind={}", .{stat.kind});
+                return error.InvalidData;
+            }
+        } else |err| {
+            log.warn("failed to stat file: {}", .{err});
+            return error.InvalidData;
+        }
+
         if (t.offset > 0) {
             file.seekTo(@intCast(t.offset)) catch |err| {
                 log.warn("failed to seek to offset {}: {}", .{ t.offset, err });

commit 83e396044bcdf93508ba2ece8d382dd76f981d72
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 14:14:31 2023 -0700

    terminal/kitty-gfx: add per-screen storage limit

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 8a6ecacd..0e549a44 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -223,6 +223,13 @@ pub const LoadingImage = struct {
             log.warn("failed to calculate size for base64 data: {}", .{err});
             return error.InvalidData;
         };
+
+        // If our data would get too big, return an error
+        if (self.data.items.len + size > max_size) {
+            log.warn("image data too large max_size={}", .{max_size});
+            return error.InvalidData;
+        }
+
         try self.data.ensureUnusedCapacity(alloc, size);
 
         // We decode directly into the arraylist
@@ -355,6 +362,10 @@ pub const LoadingImage = struct {
         ) orelse return error.InvalidData;
         defer stb.stbi_image_free(data);
         const len: usize = @intCast(width * height * bpp);
+        if (len > max_size) {
+            log.warn("png image too large size={} max_size={}", .{ len, max_size });
+            return error.InvalidData;
+        }
 
         // Validate our bpp
         if (bpp != 3 and bpp != 4) return error.UnsupportedDepth;

commit 53452bab78355811c13686bd6e621e9b3e69d06d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 17:55:41 2023 -0700

    terminal/kitty-gfx: chunked transmit and display

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 0e549a44..df19a02e 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -29,6 +29,10 @@ pub const LoadingImage = struct {
     /// The data that is being built up.
     data: std.ArrayListUnmanaged(u8) = .{},
 
+    /// This is non-null when a transmit and display command is given
+    /// so that we display the image after it is fully loaded.
+    display: ?command.Display = null,
+
     /// Initialize a chunked immage from the first image transmission.
     /// If this is a multi-chunk image, this should only be the FIRST
     /// chunk.
@@ -49,6 +53,8 @@ pub const LoadingImage = struct {
                 .compression = t.compression,
                 .format = t.format,
             },
+
+            .display = cmd.display(),
         };
 
         // Special case for the direct medium, we just add it directly

commit 21ce787cff28d6e58e09a393592cafb56b8f2053
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 19:31:46 2023 -0700

    terminal/kitty-gfx: data chunk can be zero size

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index df19a02e..f9ac2de8 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -37,9 +37,6 @@ pub const LoadingImage = struct {
     /// If this is a multi-chunk image, this should only be the FIRST
     /// chunk.
     pub fn init(alloc: Allocator, cmd: *command.Command) !LoadingImage {
-        // We must have data to load an image
-        if (cmd.data.len == 0) return error.InvalidData;
-
         // Build our initial image from the properties sent via the control.
         // These can be overwritten by the data loading process. For example,
         // PNG loading sets the width/height from the data.
@@ -222,9 +219,11 @@ pub const LoadingImage = struct {
     /// Adds a chunk of base64-encoded data to the image. Use this if the
     /// image is coming in chunks (the "m" parameter in the protocol).
     pub fn addData(self: *LoadingImage, alloc: Allocator, data: []const u8) !void {
-        const Base64Decoder = std.base64.standard.Decoder;
+        // If no data, skip
+        if (data.len == 0) return;
 
         // Grow our array list by size capacity if it needs it
+        const Base64Decoder = std.base64.standard.Decoder;
         const size = Base64Decoder.calcSizeForSlice(data) catch |err| {
             log.warn("failed to calculate size for base64 data: {}", .{err});
             return error.InvalidData;
@@ -614,6 +613,42 @@ test "image load: rgb, zlib compressed, direct, chunked" {
     try testing.expect(img.compression == .none);
 }
 
+test "image load: rgb, zlib compressed, direct, chunked with zero initial chunk" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data");
+
+    // Setup our initial chunk
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .direct,
+            .compression = .zlib_deflate,
+            .height = 96,
+            .width = 128,
+            .image_id = 31,
+            .more_chunks = true,
+        } },
+    };
+    defer cmd.deinit(alloc);
+    var loading = try LoadingImage.init(alloc, &cmd);
+    defer loading.deinit(alloc);
+
+    // Read our remaining chunks
+    var fbs = std.io.fixedBufferStream(data);
+    var buf: [1024]u8 = undefined;
+    while (fbs.reader().readAll(&buf)) |size| {
+        try loading.addData(alloc, buf[0..size]);
+        if (size < buf.len) break;
+    } else |err| return err;
+
+    // Complete
+    var img = try loading.complete(alloc);
+    defer img.deinit(alloc);
+    try testing.expect(img.compression == .none);
+}
+
 test "image load: rgb, not compressed, temporary file" {
     const testing = std.testing;
     const alloc = testing.allocator;

commit bf7054eeb6dbabd7036e26545bf93b2af48f8e73
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 21:52:50 2023 -0700

    terminal/kitty-gfx: ignore extra base64 padding

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index f9ac2de8..d924bbdb 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -241,9 +241,16 @@ pub const LoadingImage = struct {
         const start_i = self.data.items.len;
         self.data.items.len = start_i + size;
         const buf = self.data.items[start_i..];
-        Base64Decoder.decode(buf, data) catch |err| {
-            log.warn("failed to decode base64 data: {}", .{err});
-            return error.InvalidData;
+        Base64Decoder.decode(buf, data) catch |err| switch (err) {
+            // We have to ignore invalid padding because lots of encoders
+            // add the wrong padding. Since we validate image data later
+            // (PNG decode or simple dimensions check), we can ignore this.
+            error.InvalidPadding => {},
+
+            else => {
+                log.warn("failed to decode base64 data: {}", .{err});
+                return error.InvalidData;
+            },
         };
     }
 

commit 44a48f62f1f3888d9f91f5592effdfeed9041f9a
Author: Krzysztof Wolicki <der.teufel.mail@gmail.com>
Date:   Fri Nov 17 15:40:59 2023 +0100

    change unmodified `var`s to `const`s in anticipation of zig changes

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index d924bbdb..58c7eb67 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -454,7 +454,7 @@ pub const Rect = struct {
 /// Easy base64 encoding function.
 fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
     const B64Encoder = std.base64.standard.Encoder;
-    var b64 = try alloc.alloc(u8, B64Encoder.calcSize(data.len));
+    const b64 = try alloc.alloc(u8, B64Encoder.calcSize(data.len));
     errdefer alloc.free(b64);
     return B64Encoder.encode(b64, data);
 }
@@ -462,7 +462,7 @@ fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
 /// Easy base64 decoding function.
 fn testB64Decode(alloc: Allocator, data: []const u8) ![]const u8 {
     const B64Decoder = std.base64.standard.Decoder;
-    var result = try alloc.alloc(u8, try B64Decoder.calcSizeForSlice(data));
+    const result = try alloc.alloc(u8, try B64Decoder.calcSizeForSlice(data));
     errdefer alloc.free(result);
     try B64Decoder.decode(result, data);
     return result;

commit 7c8b156960636fa4fae2004a23b1df2f211ad6b5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jan 22 14:29:44 2024 -0800

    kitty images: support pngs with greyscale/alpha (bpp=2)
    
    Fixes #1355

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 58c7eb67..34dd2011 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -270,6 +270,7 @@ pub const LoadingImage = struct {
 
         // Data length must be what we expect
         const bpp: u32 = switch (img.format) {
+            .grey_alpha => 2,
             .rgb => 3,
             .rgba => 4,
             .png => unreachable, // png should be decoded by here
@@ -380,7 +381,10 @@ pub const LoadingImage = struct {
         }
 
         // Validate our bpp
-        if (bpp != 3 and bpp != 4) return error.UnsupportedDepth;
+        if (bpp < 2 or bpp > 4) {
+            log.warn("png with unsupported bpp={}", .{bpp});
+            return error.UnsupportedDepth;
+        }
 
         // Replace our data
         self.data.deinit(alloc);
@@ -392,6 +396,7 @@ pub const LoadingImage = struct {
         self.image.width = @intCast(width);
         self.image.height = @intCast(height);
         self.image.format = switch (bpp) {
+            2 => .grey_alpha,
             3 => .rgb,
             4 => .rgba,
             else => unreachable, // validated above

commit e1996ad1e5c7c39a0ce5cfd0d3495a9cb58a00b2
Author: Jonathan Marler <johnnymarler@gmail.com>
Date:   Sat Feb 10 21:09:05 2024 -0700

    os: remove UB, tmpDir is returning stack memory on Windows
    
    On Windows, the tmpDir function is currently using a buffer on the stack
    to convert the WTF16-encoded environment variable value "TMP" to utf8
    and then returns it as a slice...but that stack buffer is no longer valid
    when the function returns.  This was causing the "image load...temporary
    file" test to fail on Windows.
    
    I've updated the function to take an allocator but it only uses
    the allocator on Windows.  No allocation is needed on other platforms
    because they return environment variables that are already utf8 (ascii)
    encoded, and the OS pre-allocates all environment variables in the process.
    To keep the conditional that determines when allocation is required, I
    added the `freeTmpDir` function.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 34dd2011..fa20eaa1 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -192,7 +192,8 @@ pub const LoadingImage = struct {
     fn isPathInTempDir(path: []const u8) bool {
         if (std.mem.startsWith(u8, path, "/tmp")) return true;
         if (std.mem.startsWith(u8, path, "/dev/shm")) return true;
-        if (internal_os.tmpDir()) |dir| {
+        if (internal_os.allocTmpDir(std.heap.page_allocator)) |dir| {
+            defer internal_os.freeTmpDir(std.heap.page_allocator, dir);
             if (std.mem.startsWith(u8, path, dir)) return true;
 
             // The temporary dir is sometimes a symlink. On macOS for

commit 28ff9f7310fd459cc28279efdba9aba5e60daee2
Author: Nameless <truemedian@gmail.com>
Date:   Mon Feb 12 15:23:08 2024 -0600

    bug: std.os.realpath on non-windows asserts no nulls, make an error

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index fa20eaa1..7bd953ef 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -75,6 +75,12 @@ pub const LoadingImage = struct {
             log.warn("failed to decode base64 data: {}", .{err});
             return error.InvalidData;
         };
+
+        if (builtin.os != .windows and std.mem.indexOfScalar(u8, buf[0..size], 0) == null) {
+            // std.os.realpath *asserts* that the path does not have internal nulls instead of erroring.
+            log.warn("failed to get absolute path: BadPathName", .{});
+            return error.InvalidData;
+        }
         var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
         const path = std.os.realpath(buf[0..size], &abs_buf) catch |err| {
             log.warn("failed to get absolute path: {}", .{err});

commit 9193cfa6d2769a2a615674e0349afee529289412
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Feb 12 19:31:58 2024 -0800

    style nit

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 7bd953ef..b5c36db8 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -76,11 +76,15 @@ pub const LoadingImage = struct {
             return error.InvalidData;
         };
 
-        if (builtin.os != .windows and std.mem.indexOfScalar(u8, buf[0..size], 0) == null) {
-            // std.os.realpath *asserts* that the path does not have internal nulls instead of erroring.
-            log.warn("failed to get absolute path: BadPathName", .{});
-            return error.InvalidData;
+        if (comptime builtin.os != .windows) {
+            if (std.mem.indexOfScalar(u8, buf[0..size], 0) == null) {
+                // std.os.realpath *asserts* that the path does not have
+                // internal nulls instead of erroring.
+                log.warn("failed to get absolute path: BadPathName", .{});
+                return error.InvalidData;
+            }
         }
+
         var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
         const path = std.os.realpath(buf[0..size], &abs_buf) catch |err| {
             log.warn("failed to get absolute path: {}", .{err});

commit 6acf2b40afd0845175812197e86392e5cc3c4cfc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Feb 12 19:35:02 2024 -0800

    terminal/kitty-gfx: mistaken logic

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index b5c36db8..242954ec 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -76,8 +76,8 @@ pub const LoadingImage = struct {
             return error.InvalidData;
         };
 
-        if (comptime builtin.os != .windows) {
-            if (std.mem.indexOfScalar(u8, buf[0..size], 0) == null) {
+        if (comptime builtin.os.tag != .windows) {
+            if (std.mem.indexOfScalar(u8, buf[0..size], 0) != null) {
                 // std.os.realpath *asserts* that the path does not have
                 // internal nulls instead of erroring.
                 log.warn("failed to get absolute path: BadPathName", .{});

commit 4add6889d8ef8dc8329d5177bd4bb2ecab5591d4
Author: Krzysztof Wolicki <der.teufel.mail@gmail.com>
Date:   Fri Feb 16 10:19:57 2024 +0100

    Update to new compress.zlib API

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 242954ec..d84ea91d 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -346,11 +346,7 @@ pub const LoadingImage = struct {
     fn decompressZlib(self: *LoadingImage, alloc: Allocator) !void {
         // Open our zlib stream
         var fbs = std.io.fixedBufferStream(self.data.items);
-        var stream = std.compress.zlib.decompressStream(alloc, fbs.reader()) catch |err| {
-            log.warn("zlib decompression failed: {}", .{err});
-            return error.DecompressionFailed;
-        };
-        defer stream.deinit();
+        var stream = std.compress.zlib.decompressor(fbs.reader());
 
         // Write it to an array list
         var list = std.ArrayList(u8).init(alloc);

commit b7bf59d772a8a2ad0c9c935436f59cc6579aef59
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 22 11:15:26 2024 -0700

    update zig

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index d84ea91d..067217ea 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -3,6 +3,7 @@ const builtin = @import("builtin");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
+const posix = std.posix;
 
 const command = @import("graphics_command.zig");
 const point = @import("../point.zig");
@@ -78,7 +79,7 @@ pub const LoadingImage = struct {
 
         if (comptime builtin.os.tag != .windows) {
             if (std.mem.indexOfScalar(u8, buf[0..size], 0) != null) {
-                // std.os.realpath *asserts* that the path does not have
+                // posix.realpath *asserts* that the path does not have
                 // internal nulls instead of erroring.
                 log.warn("failed to get absolute path: BadPathName", .{});
                 return error.InvalidData;
@@ -86,7 +87,7 @@ pub const LoadingImage = struct {
         }
 
         var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-        const path = std.os.realpath(buf[0..size], &abs_buf) catch |err| {
+        const path = posix.realpath(buf[0..size], &abs_buf) catch |err| {
             log.warn("failed to get absolute path: {}", .{err});
             return error.InvalidData;
         };
@@ -151,7 +152,7 @@ pub const LoadingImage = struct {
             if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
         }
         defer if (medium == .temporary_file) {
-            std.os.unlink(path) catch |err| {
+            posix.unlink(path) catch |err| {
                 log.warn("failed to delete temporary file: {}", .{err});
             };
         };
@@ -209,7 +210,7 @@ pub const LoadingImage = struct {
             // The temporary dir is sometimes a symlink. On macOS for
             // example /tmp is /private/var/...
             var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-            if (std.os.realpath(dir, &buf)) |real_dir| {
+            if (posix.realpath(dir, &buf)) |real_dir| {
                 if (std.mem.startsWith(u8, path, real_dir)) return true;
             } else |_| {}
         }

commit 9b4ab0e209b84890cf53182078a6c42d85553263
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 8 10:17:41 2024 -0800

    zig build test with renamed terminal package

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 067217ea..4f3e3e48 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -7,6 +7,7 @@ const posix = std.posix;
 
 const command = @import("graphics_command.zig");
 const point = @import("../point.zig");
+const PageList = @import("../PageList.zig");
 const internal_os = @import("../../os/main.zig");
 const stb = @import("../../stb/main.zig");
 
@@ -452,16 +453,8 @@ pub const Image = struct {
 /// be rounded up to the nearest grid cell since we can't place images
 /// in partial grid cells.
 pub const Rect = struct {
-    top_left: point.ScreenPoint = .{},
-    bottom_right: point.ScreenPoint = .{},
-
-    /// True if the rect contains a given screen point.
-    pub fn contains(self: Rect, p: point.ScreenPoint) bool {
-        return p.y >= self.top_left.y and
-            p.y <= self.bottom_right.y and
-            p.x >= self.top_left.x and
-            p.x <= self.bottom_right.x;
-    }
+    top_left: PageList.Pin,
+    bottom_right: PageList.Pin,
 };
 
 /// Easy base64 encoding function.

commit ca4b55b486779c7523d1478a93de953b110b90ec
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Mar 31 21:09:37 2024 -0400

    terminal/kitty_graphics: ignore base64 padding
    
    Also move all base64 decoding to inside of the command parser.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 4f3e3e48..c661a8a2 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -5,6 +5,7 @@ const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const posix = std.posix;
 
+const fastmem = @import("../../fastmem.zig");
 const command = @import("graphics_command.zig");
 const point = @import("../point.zig");
 const PageList = @import("../PageList.zig");
@@ -56,30 +57,16 @@ pub const LoadingImage = struct {
             .display = cmd.display(),
         };
 
-        // Special case for the direct medium, we just add it directly
-        // which will handle copying the data, base64 decoding, etc.
+        // Special case for the direct medium, we just add the chunk directly.
         if (t.medium == .direct) {
             try result.addData(alloc, cmd.data);
             return result;
         }
 
-        // For every other medium, we'll need to at least base64 decode
-        // the data to make it useful so let's do that. Also, all the data
-        // has to be path data so we can put it in a stack-allocated buffer.
-        var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-        const Base64Decoder = std.base64.standard.Decoder;
-        const size = Base64Decoder.calcSizeForSlice(cmd.data) catch |err| {
-            log.warn("failed to calculate base64 size for file path: {}", .{err});
-            return error.InvalidData;
-        };
-        if (size > buf.len) return error.FilePathTooLong;
-        Base64Decoder.decode(&buf, cmd.data) catch |err| {
-            log.warn("failed to decode base64 data: {}", .{err});
-            return error.InvalidData;
-        };
+        // Otherwise, the payload data is guaranteed to be a path.
 
         if (comptime builtin.os.tag != .windows) {
-            if (std.mem.indexOfScalar(u8, buf[0..size], 0) != null) {
+            if (std.mem.indexOfScalar(u8, cmd.data, 0) != null) {
                 // posix.realpath *asserts* that the path does not have
                 // internal nulls instead of erroring.
                 log.warn("failed to get absolute path: BadPathName", .{});
@@ -88,7 +75,7 @@ pub const LoadingImage = struct {
         }
 
         var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
-        const path = posix.realpath(buf[0..size], &abs_buf) catch |err| {
+        const path = posix.realpath(cmd.data, &abs_buf) catch |err| {
             log.warn("failed to get absolute path: {}", .{err});
             return error.InvalidData;
         };
@@ -229,42 +216,25 @@ pub const LoadingImage = struct {
         alloc.destroy(self);
     }
 
-    /// Adds a chunk of base64-encoded data to the image. Use this if the
-    /// image is coming in chunks (the "m" parameter in the protocol).
+    /// Adds a chunk of data to the image. Use this if the image
+    /// is coming in chunks (the "m" parameter in the protocol).
     pub fn addData(self: *LoadingImage, alloc: Allocator, data: []const u8) !void {
         // If no data, skip
         if (data.len == 0) return;
 
-        // Grow our array list by size capacity if it needs it
-        const Base64Decoder = std.base64.standard.Decoder;
-        const size = Base64Decoder.calcSizeForSlice(data) catch |err| {
-            log.warn("failed to calculate size for base64 data: {}", .{err});
-            return error.InvalidData;
-        };
-
         // If our data would get too big, return an error
-        if (self.data.items.len + size > max_size) {
+        if (self.data.items.len + data.len > max_size) {
             log.warn("image data too large max_size={}", .{max_size});
             return error.InvalidData;
         }
 
-        try self.data.ensureUnusedCapacity(alloc, size);
+        // Ensure we have enough room to add the data
+        // to the end of the ArrayList before doing so.
+        try self.data.ensureUnusedCapacity(alloc, data.len);
 
-        // We decode directly into the arraylist
         const start_i = self.data.items.len;
-        self.data.items.len = start_i + size;
-        const buf = self.data.items[start_i..];
-        Base64Decoder.decode(buf, data) catch |err| switch (err) {
-            // We have to ignore invalid padding because lots of encoders
-            // add the wrong padding. Since we validate image data later
-            // (PNG decode or simple dimensions check), we can ignore this.
-            error.InvalidPadding => {},
-
-            else => {
-                log.warn("failed to decode base64 data: {}", .{err});
-                return error.InvalidData;
-            },
-        };
+        self.data.items.len = start_i + data.len;
+        fastmem.copy(u8, self.data.items[start_i..], data);
     }
 
     /// Complete the chunked image, returning a completed image.

commit 04ec8599251db4dcb23b3e5070d60a378cbdb4fd
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Mar 31 22:28:53 2024 -0400

    terminal/kitty_graphics: update tests
    
    Kitty Graphics command structures have been changed to hold decoded payloads not base64 strings.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index c661a8a2..09e9376e 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -427,23 +427,6 @@ pub const Rect = struct {
     bottom_right: PageList.Pin,
 };
 
-/// Easy base64 encoding function.
-fn testB64(alloc: Allocator, data: []const u8) ![]const u8 {
-    const B64Encoder = std.base64.standard.Encoder;
-    const b64 = try alloc.alloc(u8, B64Encoder.calcSize(data.len));
-    errdefer alloc.free(b64);
-    return B64Encoder.encode(b64, data);
-}
-
-/// Easy base64 decoding function.
-fn testB64Decode(alloc: Allocator, data: []const u8) ![]const u8 {
-    const B64Decoder = std.base64.standard.Decoder;
-    const result = try alloc.alloc(u8, try B64Decoder.calcSizeForSlice(data));
-    errdefer alloc.free(result);
-    try B64Decoder.decode(result, data);
-    return result;
-}
-
 // This specifically tests we ALLOW invalid RGB data because Kitty
 // documents that this should work.
 test "image load with invalid RGB data" {
@@ -518,7 +501,7 @@ test "image load: rgb, zlib compressed, direct" {
         } },
         .data = try alloc.dupe(
             u8,
-            @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data"),
+            @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647-raw.data"),
         ),
     };
     defer cmd.deinit(alloc);
@@ -546,7 +529,7 @@ test "image load: rgb, not compressed, direct" {
         } },
         .data = try alloc.dupe(
             u8,
-            @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
+            @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data"),
         ),
     };
     defer cmd.deinit(alloc);
@@ -563,7 +546,7 @@ test "image load: rgb, zlib compressed, direct, chunked" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data");
+    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647-raw.data");
 
     // Setup our initial chunk
     var cmd: command.Command = .{
@@ -600,7 +583,7 @@ test "image load: rgb, zlib compressed, direct, chunked with zero initial chunk"
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647.data");
+    const data = @embedFile("testdata/image-rgb-zlib_deflate-128x96-2147483647-raw.data");
 
     // Setup our initial chunk
     var cmd: command.Command = .{
@@ -638,11 +621,7 @@ test "image load: rgb, not compressed, temporary file" {
 
     var tmp_dir = try internal_os.TempDir.init();
     defer tmp_dir.deinit();
-    const data = try testB64Decode(
-        alloc,
-        @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
-    );
-    defer alloc.free(data);
+    const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
     try tmp_dir.dir.writeFile("image.data", data);
 
     var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
@@ -657,7 +636,7 @@ test "image load: rgb, not compressed, temporary file" {
             .height = 15,
             .image_id = 31,
         } },
-        .data = try testB64(alloc, path),
+        .data = try alloc.dupe(u8, path),
     };
     defer cmd.deinit(alloc);
     var loading = try LoadingImage.init(alloc, &cmd);
@@ -676,11 +655,7 @@ test "image load: rgb, not compressed, regular file" {
 
     var tmp_dir = try internal_os.TempDir.init();
     defer tmp_dir.deinit();
-    const data = try testB64Decode(
-        alloc,
-        @embedFile("testdata/image-rgb-none-20x15-2147483647.data"),
-    );
-    defer alloc.free(data);
+    const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
     try tmp_dir.dir.writeFile("image.data", data);
 
     var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
@@ -695,7 +670,7 @@ test "image load: rgb, not compressed, regular file" {
             .height = 15,
             .image_id = 31,
         } },
-        .data = try testB64(alloc, path),
+        .data = try alloc.dupe(u8, path),
     };
     defer cmd.deinit(alloc);
     var loading = try LoadingImage.init(alloc, &cmd);
@@ -727,7 +702,7 @@ test "image load: png, not compressed, regular file" {
             .height = 0,
             .image_id = 31,
         } },
-        .data = try testB64(alloc, path),
+        .data = try alloc.dupe(u8, path),
     };
     defer cmd.deinit(alloc);
     var loading = try LoadingImage.init(alloc, &cmd);

commit 53423f107124d23e7052eb97027008818915867b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jun 8 20:21:00 2024 -0700

    0.13 conversions

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 09e9376e..2cfb59cc 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -622,7 +622,10 @@ test "image load: rgb, not compressed, temporary file" {
     var tmp_dir = try internal_os.TempDir.init();
     defer tmp_dir.deinit();
     const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
-    try tmp_dir.dir.writeFile("image.data", data);
+    try tmp_dir.dir.writeFile(.{
+        .sub_path = "image.data",
+        .data = data,
+    });
 
     var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
@@ -656,7 +659,10 @@ test "image load: rgb, not compressed, regular file" {
     var tmp_dir = try internal_os.TempDir.init();
     defer tmp_dir.deinit();
     const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
-    try tmp_dir.dir.writeFile("image.data", data);
+    try tmp_dir.dir.writeFile(.{
+        .sub_path = "image.data",
+        .data = data,
+    });
 
     var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
@@ -688,7 +694,10 @@ test "image load: png, not compressed, regular file" {
     var tmp_dir = try internal_os.TempDir.init();
     defer tmp_dir.deinit();
     const data = @embedFile("testdata/image-png-none-50x76-2147483647-raw.data");
-    try tmp_dir.dir.writeFile("image.data", data);
+    try tmp_dir.dir.writeFile(.{
+        .sub_path = "image.data",
+        .data = data,
+    });
 
     var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);

commit 72c672adb7ff9d7ce766be4ed8b0f263775636b8
Author: multifred <github-ghostty@2al.ch>
Date:   Mon Jul 22 00:06:18 2024 +0200

    Fix multiple deprecated names for zig lib/std

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 2cfb59cc..83ae69f7 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -74,7 +74,7 @@ pub const LoadingImage = struct {
             }
         }
 
-        var abs_buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+        var abs_buf: [std.fs.max_path_bytes]u8 = undefined;
         const path = posix.realpath(cmd.data, &abs_buf) catch |err| {
             log.warn("failed to get absolute path: {}", .{err});
             return error.InvalidData;
@@ -197,7 +197,7 @@ pub const LoadingImage = struct {
 
             // The temporary dir is sometimes a symlink. On macOS for
             // example /tmp is /private/var/...
-            var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+            var buf: [std.fs.max_path_bytes]u8 = undefined;
             if (posix.realpath(dir, &buf)) |real_dir| {
                 if (std.mem.startsWith(u8, path, real_dir)) return true;
             } else |_| {}
@@ -627,7 +627,7 @@ test "image load: rgb, not compressed, temporary file" {
         .data = data,
     });
 
-    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var buf: [std.fs.max_path_bytes]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
 
     var cmd: command.Command = .{
@@ -664,7 +664,7 @@ test "image load: rgb, not compressed, regular file" {
         .data = data,
     });
 
-    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var buf: [std.fs.max_path_bytes]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
 
     var cmd: command.Command = .{
@@ -699,7 +699,7 @@ test "image load: png, not compressed, regular file" {
         .data = data,
     });
 
-    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
+    var buf: [std.fs.max_path_bytes]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
 
     var cmd: command.Command = .{

commit e2fe6bf74b4afb876bbcfed4ec38ab65e37c956e
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Thu Aug 8 15:28:31 2024 -0500

    kitty graphics: add support for shared memory transfer medium
    
    Adds support for using shared memory to transfer images between
    the CLI and Ghostty using the Kitty image protocol. This should be
    the fastest way to transfer images if the CLI program and Ghostty are
    running on the same system.
    
    Works for single image transfer using `kitten icat`:
    
    ```
    kitten icat --transfer-mode=memory images/icons/icon_256x256.png
    ```
    
    However trying to play a movie with `mpv` fails in Ghostty (although it
    works in Kitty):
    
    ```
    mpv --vo=kitty --vo-kitty-use-shm=yes --profile=sw-fast --really-quiet video.mp4
    ```
    
    `mpv` appears to be sending frames using the normal image transfer
    commands but always setting `more_chunks` to `true` which results in an
    image never being shown by Ghostty.
    
    Shared memory transfer on Windows remains to be implemented.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 83ae69f7..6b675857 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -75,9 +75,13 @@ pub const LoadingImage = struct {
         }
 
         var abs_buf: [std.fs.max_path_bytes]u8 = undefined;
-        const path = posix.realpath(cmd.data, &abs_buf) catch |err| {
-            log.warn("failed to get absolute path: {}", .{err});
-            return error.InvalidData;
+        const path = switch (t.medium) {
+            .direct => unreachable, // handled above
+            .file, .temporary_file => posix.realpath(cmd.data, &abs_buf) catch |err| {
+                log.warn("failed to get absolute path: {}", .{err});
+                return error.InvalidData;
+            },
+            .shared_memory => cmd.data,
         };
 
         // Depending on the medium, load the data from the path.
@@ -98,15 +102,53 @@ pub const LoadingImage = struct {
         t: command.Transmission,
         path: []const u8,
     ) !void {
-        // We require libc for this for shm_open
-        if (comptime !builtin.link_libc) return error.UnsupportedMedium;
-
-        // Todo: support shared memory
-        _ = self;
-        _ = alloc;
-        _ = t;
-        _ = path;
-        return error.UnsupportedMedium;
+        switch (builtin.target.os.tag) {
+            .windows => {
+                // TODO: support shared memory on windows
+                return error.UnsupportedMedium;
+            },
+            else => {
+                // libc is required for shm_open
+                if (comptime !builtin.link_libc) return error.UnsupportedMedium;
+
+                const pathz = try alloc.dupeZ(u8, path);
+                defer alloc.free(pathz);
+
+                const fd = std.c.shm_open(pathz, @as(c_int, @bitCast(std.c.O{ .ACCMODE = .RDONLY })), 0);
+                switch (std.posix.errno(fd)) {
+                    .SUCCESS => {
+                        defer _ = std.c.close(fd);
+                        defer _ = std.c.shm_unlink(pathz);
+
+                        const stat = std.posix.fstat(fd) catch |err| {
+                            log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
+                            return error.InvalidData;
+                        };
+
+                        if (stat.size <= 0) return error.InvalidData;
+
+                        const size: usize = @intCast(stat.size);
+
+                        const map = std.posix.mmap(null, size, std.c.PROT.READ, std.c.MAP{ .TYPE = .SHARED }, fd, 0) catch |err| {
+                            log.warn("unable to mmap shared memory {s}: {}", .{ path, err });
+                            return error.InvalidData;
+                        };
+                        defer std.posix.munmap(map);
+
+                        const start: usize = @intCast(t.offset);
+                        const end: usize = if (t.size > 0) @min(@as(usize, @intCast(t.offset)) + @as(usize, @intCast(t.size)), size) else size;
+
+                        assert(self.data.items.len == 0);
+                        try self.data.appendSlice(alloc, map[start..end]);
+                    },
+
+                    else => |err| {
+                        log.warn("unable to open shared memory {s}: {}", .{ path, err });
+                        return error.InvalidData;
+                    },
+                }
+            },
+        }
     }
 
     /// Reads the data from a temporary file and returns it. This allocates

commit c114979ee38d7e20c53aefcab92afe6d0da28262
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Aug 8 14:35:30 2024 -0700

    terminal/kitty: minor stylistic changes to shm

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 6b675857..8035c094 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -102,53 +102,61 @@ pub const LoadingImage = struct {
         t: command.Transmission,
         path: []const u8,
     ) !void {
-        switch (builtin.target.os.tag) {
-            .windows => {
-                // TODO: support shared memory on windows
-                return error.UnsupportedMedium;
-            },
-            else => {
-                // libc is required for shm_open
-                if (comptime !builtin.link_libc) return error.UnsupportedMedium;
-
-                const pathz = try alloc.dupeZ(u8, path);
-                defer alloc.free(pathz);
-
-                const fd = std.c.shm_open(pathz, @as(c_int, @bitCast(std.c.O{ .ACCMODE = .RDONLY })), 0);
-                switch (std.posix.errno(fd)) {
-                    .SUCCESS => {
-                        defer _ = std.c.close(fd);
-                        defer _ = std.c.shm_unlink(pathz);
-
-                        const stat = std.posix.fstat(fd) catch |err| {
-                            log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
-                            return error.InvalidData;
-                        };
-
-                        if (stat.size <= 0) return error.InvalidData;
-
-                        const size: usize = @intCast(stat.size);
-
-                        const map = std.posix.mmap(null, size, std.c.PROT.READ, std.c.MAP{ .TYPE = .SHARED }, fd, 0) catch |err| {
-                            log.warn("unable to mmap shared memory {s}: {}", .{ path, err });
-                            return error.InvalidData;
-                        };
-                        defer std.posix.munmap(map);
-
-                        const start: usize = @intCast(t.offset);
-                        const end: usize = if (t.size > 0) @min(@as(usize, @intCast(t.offset)) + @as(usize, @intCast(t.size)), size) else size;
-
-                        assert(self.data.items.len == 0);
-                        try self.data.appendSlice(alloc, map[start..end]);
-                    },
-
-                    else => |err| {
-                        log.warn("unable to open shared memory {s}: {}", .{ path, err });
-                        return error.InvalidData;
-                    },
-                }
+        // windows is currently unsupported, does it support shm?
+        if (comptime builtin.target.os.tag == .windows) {
+            return error.UnsupportedMedium;
+        }
+
+        // libc is required for shm_open
+        if (comptime !builtin.link_libc) {
+            return error.UnsupportedMedium;
+        }
+
+        // Since we're only supporting posix then max_path_bytes should
+        // be enough to stack allocate the path.
+        var buf: [std.fs.max_path_bytes]u8 = undefined;
+        const pathz = std.fmt.bufPrintZ(&buf, "{s}", .{path}) catch return error.InvalidData;
+
+        const fd = std.c.shm_open(pathz, @as(c_int, @bitCast(std.c.O{ .ACCMODE = .RDONLY })), 0);
+        switch (std.posix.errno(fd)) {
+            .SUCCESS => {},
+            else => |err| {
+                log.warn("unable to open shared memory {s}: {}", .{ path, err });
+                return error.InvalidData;
             },
         }
+        defer _ = std.c.close(fd);
+        defer _ = std.c.shm_unlink(pathz);
+
+        const stat = std.posix.fstat(fd) catch |err| {
+            log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
+            return error.InvalidData;
+        };
+        if (stat.size <= 0) return error.InvalidData;
+
+        const size: usize = @intCast(stat.size);
+
+        const map = std.posix.mmap(
+            null,
+            size,
+            std.c.PROT.READ,
+            std.c.MAP{ .TYPE = .SHARED },
+            fd,
+            0,
+        ) catch |err| {
+            log.warn("unable to mmap shared memory {s}: {}", .{ path, err });
+            return error.InvalidData;
+        };
+        defer std.posix.munmap(map);
+
+        const start: usize = @intCast(t.offset);
+        const end: usize = if (t.size > 0) @min(
+            @as(usize, @intCast(t.offset)) + @as(usize, @intCast(t.size)),
+            size,
+        ) else size;
+
+        assert(self.data.items.len == 0);
+        try self.data.appendSlice(alloc, map[start..end]);
     }
 
     /// Reads the data from a temporary file and returns it. This allocates

commit b368702a9d9ad35a3a12a6951d108f13d30fc571
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 9 20:33:39 2024 -0700

    terminal/kitty: shared memory size may be larger than expected for pages
    
    The shared memory segment size must be a multiple of page size. This
    means that it may be larger than our expected image size. In this case,
    we trim the padding at the end.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 8035c094..9e0a0ef4 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -128,17 +128,42 @@ pub const LoadingImage = struct {
         defer _ = std.c.close(fd);
         defer _ = std.c.shm_unlink(pathz);
 
-        const stat = std.posix.fstat(fd) catch |err| {
-            log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
-            return error.InvalidData;
+        // The size from stat on may be larger than our expected size because
+        // shared memory has to be a multiple of the page size.
+        const stat_size: usize = stat: {
+            const stat = std.posix.fstat(fd) catch |err| {
+                log.warn("unable to fstat shared memory {s}: {}", .{ path, err });
+                return error.InvalidData;
+            };
+            if (stat.size <= 0) return error.InvalidData;
+            break :stat @intCast(stat.size);
         };
-        if (stat.size <= 0) return error.InvalidData;
 
-        const size: usize = @intCast(stat.size);
+        const expected_size: usize = switch (self.image.format) {
+            // Png we decode the full data size because later decoding will
+            // get the proper dimensions and assert validity.
+            .png => stat_size,
+
+            // For these formats we have a size we must have.
+            .grey_alpha, .rgb, .rgba => |f| size: {
+                const bpp = f.bpp();
+                break :size self.image.width * self.image.height * bpp;
+            },
+        };
+
+        // Our stat size must be at least the expected size otherwise
+        // the shared memory data is invalid.
+        if (stat_size < expected_size) {
+            log.warn(
+                "shared memory size too small expected={} actual={}",
+                .{ expected_size, stat_size },
+            );
+            return error.InvalidData;
+        }
 
         const map = std.posix.mmap(
             null,
-            size,
+            stat_size, // mmap always uses the stat size
             std.c.PROT.READ,
             std.c.MAP{ .TYPE = .SHARED },
             fd,
@@ -149,11 +174,13 @@ pub const LoadingImage = struct {
         };
         defer std.posix.munmap(map);
 
+        // Our end size always uses the expected size so we cut off the
+        // padding for mmap alignment.
         const start: usize = @intCast(t.offset);
         const end: usize = if (t.size > 0) @min(
             @as(usize, @intCast(t.offset)) + @as(usize, @intCast(t.size)),
-            size,
-        ) else size;
+            expected_size,
+        ) else expected_size;
 
         assert(self.data.items.len == 0);
         try self.data.appendSlice(alloc, map[start..end]);
@@ -302,12 +329,7 @@ pub const LoadingImage = struct {
         if (img.width > max_dimension or img.height > max_dimension) return error.DimensionsTooLarge;
 
         // Data length must be what we expect
-        const bpp: u32 = switch (img.format) {
-            .grey_alpha => 2,
-            .rgb => 3,
-            .rgba => 4,
-            .png => unreachable, // png should be decoded by here
-        };
+        const bpp = img.format.bpp();
         const expected_len = img.width * img.height * bpp;
         const actual_len = self.data.items.len;
         if (actual_len != expected_len) {

commit 10b8ca3c694aa5e0b5cf7eaaae79a4990e3774c3
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Aug 11 18:02:12 2024 -0400

    spelling: normalize grey -> gray

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 9e0a0ef4..a4941dbb 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -145,7 +145,7 @@ pub const LoadingImage = struct {
             .png => stat_size,
 
             // For these formats we have a size we must have.
-            .grey_alpha, .rgb, .rgba => |f| size: {
+            .gray_alpha, .rgb, .rgba => |f| size: {
                 const bpp = f.bpp();
                 break :size self.image.width * self.image.height * bpp;
             },
@@ -447,7 +447,7 @@ pub const LoadingImage = struct {
         self.image.width = @intCast(width);
         self.image.height = @intCast(height);
         self.image.format = switch (bpp) {
-            2 => .grey_alpha,
+            2 => .gray_alpha,
             3 => .rgb,
             4 => .rgba,
             else => unreachable, // validated above

commit 37872afbceba2b940f73cdf5e2300842ce03badc
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Thu Aug 15 21:38:46 2024 -0400

    kitty graphics: support loading 1 channel grayscale images

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index a4941dbb..2dd12ccc 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -145,7 +145,7 @@ pub const LoadingImage = struct {
             .png => stat_size,
 
             // For these formats we have a size we must have.
-            .gray_alpha, .rgb, .rgba => |f| size: {
+            .gray, .gray_alpha, .rgb, .rgba => |f| size: {
                 const bpp = f.bpp();
                 break :size self.image.width * self.image.height * bpp;
             },
@@ -432,7 +432,7 @@ pub const LoadingImage = struct {
         }
 
         // Validate our bpp
-        if (bpp < 2 or bpp > 4) {
+        if (bpp < 1 or bpp > 4) {
             log.warn("png with unsupported bpp={}", .{bpp});
             return error.UnsupportedDepth;
         }
@@ -447,6 +447,7 @@ pub const LoadingImage = struct {
         self.image.width = @intCast(width);
         self.image.height = @intCast(height);
         self.image.format = switch (bpp) {
+            1 => .gray,
             2 => .gray_alpha,
             3 => .rgb,
             4 => .rgba,

commit 6dbb82c2592d4c33751b86eb12aade01a4b36e69
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Sun Sep 1 14:02:33 2024 -0500

    kitty graphics: performance enhancements
    
    Improve the performance of Kitty graphics by switching to the WUFFS
    library for decoding PNG images and for "swizzling" G, GA, and RGB data
    to RGBA formats needed by the renderers.
    
    WUFFS claims 2-3x performance benefits over other implementations, as
    well as memory-safe operations.
    
    Although not thorougly benchmarked, performance is on par with Kitty's
    graphics decoding.
    
    https://github.com/google/wuffs

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 2dd12ccc..3af3874c 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -10,7 +10,7 @@ const command = @import("graphics_command.zig");
 const point = @import("../point.zig");
 const PageList = @import("../PageList.zig");
 const internal_os = @import("../../os/main.zig");
-const stb = @import("../../stb/main.zig");
+const wuffs = @import("../../wuffs/main.zig");
 
 const log = std.log.scoped(.kitty_gfx);
 
@@ -412,47 +412,27 @@ pub const LoadingImage = struct {
     fn decodePng(self: *LoadingImage, alloc: Allocator) !void {
         assert(self.image.format == .png);
 
-        // Decode PNG
-        var width: c_int = 0;
-        var height: c_int = 0;
-        var bpp: c_int = 0;
-        const data = stb.stbi_load_from_memory(
-            self.data.items.ptr,
-            @intCast(self.data.items.len),
-            &width,
-            &height,
-            &bpp,
-            0,
-        ) orelse return error.InvalidData;
-        defer stb.stbi_image_free(data);
-        const len: usize = @intCast(width * height * bpp);
-        if (len > max_size) {
-            log.warn("png image too large size={} max_size={}", .{ len, max_size });
-            return error.InvalidData;
-        }
+        const result = wuffs.png.decode(alloc, self.data.items) catch |err| switch (err) {
+            error.WuffsError => return error.InvalidData,
+            else => |e| return e,
+        };
+        defer alloc.free(result.data);
 
-        // Validate our bpp
-        if (bpp < 1 or bpp > 4) {
-            log.warn("png with unsupported bpp={}", .{bpp});
-            return error.UnsupportedDepth;
+        if (result.data.len > max_size) {
+            log.warn("png image too large size={} max_size={}", .{ result.data.len, max_size });
+            return error.InvalidData;
         }
 
         // Replace our data
         self.data.deinit(alloc);
         self.data = .{};
-        try self.data.ensureUnusedCapacity(alloc, len);
-        try self.data.appendSlice(alloc, data[0..len]);
+        try self.data.ensureUnusedCapacity(alloc, result.data.len);
+        try self.data.appendSlice(alloc, result.data[0..result.data.len]);
 
         // Store updated image dimensions
-        self.image.width = @intCast(width);
-        self.image.height = @intCast(height);
-        self.image.format = switch (bpp) {
-            1 => .gray,
-            2 => .gray_alpha,
-            3 => .rgb,
-            4 => .rgba,
-            else => unreachable, // validated above
-        };
+        self.image.width = result.width;
+        self.image.height = result.height;
+        self.image.format = .rgba;
     }
 };
 
@@ -792,6 +772,6 @@ test "image load: png, not compressed, regular file" {
     var img = try loading.complete(alloc);
     defer img.deinit(alloc);
     try testing.expect(img.compression == .none);
-    try testing.expect(img.format == .rgb);
+    try testing.expect(img.format == .rgba);
     try tmp_dir.dir.access(path, .{});
 }

commit 6edeb45e7ed19708e5d261bdeca617c7c9483267
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Mon Sep 2 00:37:10 2024 -0500

    kitty graphics: address review comments
    
    - move wuffs code from src/ to pkg/
    - eliminate stray debug logs
    - make logs a warning instead of an error
    - remove initialization of some structs to zero

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 3af3874c..d1a20f16 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -10,7 +10,7 @@ const command = @import("graphics_command.zig");
 const point = @import("../point.zig");
 const PageList = @import("../PageList.zig");
 const internal_os = @import("../../os/main.zig");
-const wuffs = @import("../../wuffs/main.zig");
+const wuffs = @import("wuffs");
 
 const log = std.log.scoped(.kitty_gfx);
 

commit de612934a08cf4d3a7f9b6ab995fae2332c1a6e4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Sep 2 20:41:59 2024 -0700

    some tweaks for wuffs

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index d1a20f16..5adac912 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -412,9 +412,12 @@ pub const LoadingImage = struct {
     fn decodePng(self: *LoadingImage, alloc: Allocator) !void {
         assert(self.image.format == .png);
 
-        const result = wuffs.png.decode(alloc, self.data.items) catch |err| switch (err) {
+        const result = wuffs.png.decode(
+            alloc,
+            self.data.items,
+        ) catch |err| switch (err) {
             error.WuffsError => return error.InvalidData,
-            else => |e| return e,
+            error.OutOfMemory => return error.OutOfMemory,
         };
         defer alloc.free(result.data);
 

commit 761bcfad50e28dcd3b167fd2dd5b45adbab24a1f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 4 10:20:32 2024 -0700

    kitty gfx: handle `q` with chunked transmissions properly
    
    Fixes #2190
    
    The `q` value with chunk transmissions is a bit complicated. The initial
    transmission ("start" command) `q` value is used for all subsequent
    chunks UNLESS a subsequent chunk specifies a `q >= 1`. If a chunk
    specifies `q >= 1`, then that `q` value is subsequently used for all
    future chunks unless another chunk specifies `q >= 1`. And so on.
    
    This commit importantly also introduces the ability to test a full Kitty
    command from string request to structured response. This will let us
    prevent regressions in the future and ensure that we are correctly
    handling the complex underspecified behavior of Kitty Graphics.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 5adac912..931d068f 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -36,10 +36,14 @@ pub const LoadingImage = struct {
     /// so that we display the image after it is fully loaded.
     display: ?command.Display = null,
 
+    /// Quiet is the quiet settings for the initial load command. This is
+    /// used if q isn't set on subsequent chunks.
+    quiet: command.Command.Quiet,
+
     /// Initialize a chunked immage from the first image transmission.
     /// If this is a multi-chunk image, this should only be the FIRST
     /// chunk.
-    pub fn init(alloc: Allocator, cmd: *command.Command) !LoadingImage {
+    pub fn init(alloc: Allocator, cmd: *const command.Command) !LoadingImage {
         // Build our initial image from the properties sent via the control.
         // These can be overwritten by the data loading process. For example,
         // PNG loading sets the width/height from the data.
@@ -55,6 +59,7 @@ pub const LoadingImage = struct {
             },
 
             .display = cmd.display(),
+            .quiet = cmd.quiet,
         };
 
         // Special case for the direct medium, we just add the chunk directly.

commit 2f31e1b7fa2b324ae10366e0c91f0aa0fbfcce75
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Tue Dec 10 14:30:59 2024 -0500

    fix(kittygfx): don't respond to T commands with no i or I
    
    If a transmit and display command does not specify an ID or a number,
    then it should not be responded to. We currently automatically assign
    IDs in this situation, which isn't ideal since collisions can happen
    which shouldn't, but this at least fixes the glaring observable issue
    where transmit-and-display commands yield unexpected OK responses.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 931d068f..ff498cbb 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -455,6 +455,12 @@ pub const Image = struct {
     data: []const u8 = "",
     transmit_time: std.time.Instant = undefined,
 
+    /// Set this to true if this image was loaded by a command that
+    /// doesn't specify an ID or number, since such commands should
+    /// not be responded to, even though we do currently give them
+    /// IDs in the public range (which is bad!).
+    implicit_id: bool = false,
+
     pub const Error = error{
         InternalError,
         InvalidData,

commit c9dfcd27811303b71ffb689917dfe13c19333004
Author: David Leadbeater <dgl@dgl.cx>
Date:   Fri Jan 3 11:12:33 2025 +1100

    kittygfx: Ensure temporary files are named per spec
    
    Temporary files used with Kitty graphics must have
    "tty-graphics-protocol" somewhere in their full path.
    
    https://sw.kovidgoyal.net/kitty/graphics-protocol/#the-transmission-medium

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index ff498cbb..7a107208 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -220,6 +220,9 @@ pub const LoadingImage = struct {
         // Temporary file logic
         if (medium == .temporary_file) {
             if (!isPathInTempDir(path)) return error.TemporaryFileNotInTempDir;
+            if (std.mem.indexOf(u8, path, "tty-graphics-protocol") == null) {
+                return error.TemporaryFileNotNamedCorrectly;
+            }
         }
         defer if (medium == .temporary_file) {
             posix.unlink(path) catch |err| {
@@ -469,6 +472,7 @@ pub const Image = struct {
         DimensionsTooLarge,
         FilePathTooLong,
         TemporaryFileNotInTempDir,
+        TemporaryFileNotNamedCorrectly,
         UnsupportedFormat,
         UnsupportedMedium,
         UnsupportedDepth,

commit 4cb2fd4f79624de671e57c9dea7217349620b4a0
Author: David Leadbeater <dgl@dgl.cx>
Date:   Fri Jan 3 11:52:24 2025 +1100

    Add negative test for temporary filename and fix other tests

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 7a107208..094e1622 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -686,7 +686,7 @@ test "image load: rgb, zlib compressed, direct, chunked with zero initial chunk"
     try testing.expect(img.compression == .none);
 }
 
-test "image load: rgb, not compressed, temporary file" {
+test "image load: temporary file without correct path" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
@@ -701,6 +701,39 @@ test "image load: rgb, not compressed, temporary file" {
     var buf: [std.fs.max_path_bytes]u8 = undefined;
     const path = try tmp_dir.dir.realpath("image.data", &buf);
 
+    var cmd: command.Command = .{
+        .control = .{ .transmit = .{
+            .format = .rgb,
+            .medium = .temporary_file,
+            .compression = .none,
+            .width = 20,
+            .height = 15,
+            .image_id = 31,
+        } },
+        .data = try alloc.dupe(u8, path),
+    };
+    defer cmd.deinit(alloc);
+    try testing.expectError(error.TemporaryFileNotNamedCorrectly, LoadingImage.init(alloc, &cmd));
+
+    // Temporary file should still be there
+    try tmp_dir.dir.access(path, .{});
+}
+
+test "image load: rgb, not compressed, temporary file" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var tmp_dir = try internal_os.TempDir.init();
+    defer tmp_dir.deinit();
+    const data = @embedFile("testdata/image-rgb-none-20x15-2147483647-raw.data");
+    try tmp_dir.dir.writeFile(.{
+        .sub_path = "tty-graphics-protocol-image.data",
+        .data = data,
+    });
+
+    var buf: [std.fs.max_path_bytes]u8 = undefined;
+    const path = try tmp_dir.dir.realpath("tty-graphics-protocol-image.data", &buf);
+
     var cmd: command.Command = .{
         .control = .{ .transmit = .{
             .format = .rgb,
@@ -766,12 +799,12 @@ test "image load: png, not compressed, regular file" {
     defer tmp_dir.deinit();
     const data = @embedFile("testdata/image-png-none-50x76-2147483647-raw.data");
     try tmp_dir.dir.writeFile(.{
-        .sub_path = "image.data",
+        .sub_path = "tty-graphics-protocol-image.data",
         .data = data,
     });
 
     var buf: [std.fs.max_path_bytes]u8 = undefined;
-    const path = try tmp_dir.dir.realpath("image.data", &buf);
+    const path = try tmp_dir.dir.realpath("tty-graphics-protocol-image.data", &buf);
 
     var cmd: command.Command = .{
         .control = .{ .transmit = .{

commit 4d0bf303c652f2b0f11acf8f9375ffd33a38b4f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Mar 18 13:51:39 2025 -0700

    ci: zig fmt check
    
    This adds a CI test to ensure that all Zig files are properly formatted.
    This avoids unrelated diff noise in future PRs.

diff --git a/src/terminal/kitty/graphics_image.zig b/src/terminal/kitty/graphics_image.zig
index 094e1622..54ed1b93 100644
--- a/src/terminal/kitty/graphics_image.zig
+++ b/src/terminal/kitty/graphics_image.zig
@@ -212,7 +212,7 @@ pub const LoadingImage = struct {
         if (std.mem.startsWith(u8, path, "/proc/") or
             std.mem.startsWith(u8, path, "/sys/") or
             (std.mem.startsWith(u8, path, "/dev/") and
-            !std.mem.startsWith(u8, path, "/dev/shm/")))
+                !std.mem.startsWith(u8, path, "/dev/shm/")))
         {
             return error.InvalidData;
         }

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    