<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/ReactFiberUnwindWork.js - Gemini 2.5 Pro 05-06</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/ReactFiberUnwindWork.js</h1>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview/react_packages_react-reconciler_src_ReactFiberUnwindWork.js.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/ReactFiberUnwindWork.js

commit 94518b068bf52196abea0c83f4c9926bfe2065c6
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Feb 23 17:38:42 2018 -0800

    Add stack unwinding phase for handling errors (#12201)
    
    * Add stack unwinding phase for handling errors
    
    A rewrite of error handling, with semantics that more closely match
    stack unwinding.
    
    Errors that are thrown during the render phase unwind to the nearest
    error boundary, like before. But rather than synchronously unmount the
    children before retrying, we restart the failed subtree within the same
    render phase. The failed children are still unmounted (as if all their
    keys changed) but without an extra commit.
    
    Commit phase errors are different. They work by scheduling an error on
    the update queue of the error boundary. When we enter the render phase,
    the error is popped off the queue. The rest of the algorithm is
    the same.
    
    This approach is designed to work for throwing non-errors, too, though
    that feature is not implemented yet.
    
    * Add experimental getDerivedStateFromCatch lifecycle
    
    Fires during the render phase, so you can recover from an error within the same
    pass. This aligns error boundaries more closely with try-catch semantics.
    
    Let's keep this behind a feature flag until a future release. For now, the
    recommendation is to keep using componentDidCatch. Eventually, the advice will
    be to use getDerivedStateFromCatch for handling errors and componentDidCatch
    only for logging.
    
    * Reconcile twice to remount failed children, instead of using a boolean
    
    * Handle effect immediately after its thrown
    
    This way we don't have to store the thrown values on the effect list.
    
    * ReactFiberIncompleteWork -> ReactFiberUnwindWork
    
    * Remove startTime
    
    * Remove TypeOfException
    
    We don't need it yet. We'll reconsider once we add another exception type.
    
    * Move replay to outer catch block
    
    This moves it out of the hot path.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
new file mode 100644
index 0000000000..bb3ce84945
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -0,0 +1,139 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ */
+
+import {createCapturedValue} from './ReactCapturedValue';
+import {ensureUpdateQueues} from './ReactFiberUpdateQueue';
+
+import {
+  ClassComponent,
+  HostRoot,
+  HostComponent,
+  HostPortal,
+  ContextProvider,
+} from 'shared/ReactTypeOfWork';
+import {
+  NoEffect,
+  DidCapture,
+  Incomplete,
+  ShouldCapture,
+} from 'shared/ReactTypeOfSideEffect';
+
+import {enableGetDerivedStateFromCatch} from 'shared/ReactFeatureFlags';
+
+import {
+  popContextProvider as popLegacyContextProvider,
+  popTopLevelContextObject as popTopLevelLegacyContextObject,
+} from './ReactFiberContext';
+import {popProvider} from './ReactFiberNewContext';
+
+export default function(
+  hostContext: HostContext<C, CX>,
+  scheduleWork: (
+    fiber: Fiber,
+    startTime: ExpirationTime,
+    expirationTime: ExpirationTime,
+  ) => void,
+  isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
+) {
+  const {popHostContainer, popHostContext} = hostContext;
+
+  function throwException(
+    returnFiber: Fiber,
+    sourceFiber: Fiber,
+    rawValue: mixed,
+  ) {
+    // The source fiber did not complete.
+    sourceFiber.effectTag |= Incomplete;
+    // Its effect list is no longer valid.
+    sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+
+    const value = createCapturedValue(rawValue, sourceFiber);
+
+    let workInProgress = returnFiber;
+    do {
+      switch (workInProgress.tag) {
+        case HostRoot: {
+          // Uncaught error
+          const errorInfo = value;
+          ensureUpdateQueues(workInProgress);
+          const updateQueue: UpdateQueue = (workInProgress.updateQueue: any);
+          updateQueue.capturedValues = [errorInfo];
+          workInProgress.effectTag |= ShouldCapture;
+          return;
+        }
+        case ClassComponent:
+          // Capture and retry
+          const ctor = workInProgress.type;
+          const instance = workInProgress.stateNode;
+          if (
+            (workInProgress.effectTag & DidCapture) === NoEffect &&
+            ((typeof ctor.getDerivedStateFromCatch === 'function' &&
+              enableGetDerivedStateFromCatch) ||
+              (instance !== null &&
+                typeof instance.componentDidCatch === 'function' &&
+                !isAlreadyFailedLegacyErrorBoundary(instance)))
+          ) {
+            ensureUpdateQueues(workInProgress);
+            const updateQueue: UpdateQueue = (workInProgress.updateQueue: any);
+            const capturedValues = updateQueue.capturedValues;
+            if (capturedValues === null) {
+              updateQueue.capturedValues = [value];
+            } else {
+              capturedValues.push(value);
+            }
+            workInProgress.effectTag |= ShouldCapture;
+            return;
+          }
+          break;
+        default:
+          break;
+      }
+      workInProgress = workInProgress.return;
+    } while (workInProgress !== null);
+  }
+
+  function unwindWork(workInProgress) {
+    switch (workInProgress.tag) {
+      case ClassComponent: {
+        popLegacyContextProvider(workInProgress);
+        const effectTag = workInProgress.effectTag;
+        if (effectTag & ShouldCapture) {
+          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+          return workInProgress;
+        }
+        return null;
+      }
+      case HostRoot: {
+        popHostContainer(workInProgress);
+        popTopLevelLegacyContextObject(workInProgress);
+        const effectTag = workInProgress.effectTag;
+        if (effectTag & ShouldCapture) {
+          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+          return workInProgress;
+        }
+        return null;
+      }
+      case HostComponent: {
+        popHostContext(workInProgress);
+        return null;
+      }
+      case HostPortal:
+        popHostContainer(workInProgress);
+        return null;
+      case ContextProvider:
+        popProvider(workInProgress);
+        return null;
+      default:
+        return null;
+    }
+  }
+  return {
+    throwException,
+    unwindWork,
+  };
+}

commit 208b490ed907346ae3e37159535299899f74312d
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Mar 15 19:27:44 2018 -0700

    Unify context stack implementations (#12359)
    
    * Use module pattern so context stack is isolated per renderer
    
    * Unify context implementations
    
    Implements the new context API on top of the existing ReactStack that we
    already use for host context and legacy context. Now there is a single
    array that we push and pop from.
    
    This makes the interrupt path slightly slower, since when we reset the
    unit of work pointer, we have to iterate over the stack (like before)
    *and* switch on the type of work (not like before). On the other hand,
    this unifies all of the unwinding behavior in the UnwindWork module.
    
    * Add DEV only warning if stack is not reset properly

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index bb3ce84945..6565e4888d 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -4,8 +4,16 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  *
+ * @flow
  */
 
+import type {Fiber} from './ReactFiber';
+import type {ExpirationTime} from './ReactFiberExpirationTime';
+import type {HostContext} from './ReactFiberHostContext';
+import type {LegacyContext} from './ReactFiberContext';
+import type {NewContext} from './ReactFiberNewContext';
+import type {UpdateQueue} from './ReactFiberUpdateQueue';
+
 import {createCapturedValue} from './ReactCapturedValue';
 import {ensureUpdateQueues} from './ReactFiberUpdateQueue';
 
@@ -25,14 +33,10 @@ import {
 
 import {enableGetDerivedStateFromCatch} from 'shared/ReactFeatureFlags';
 
-import {
-  popContextProvider as popLegacyContextProvider,
-  popTopLevelContextObject as popTopLevelLegacyContextObject,
-} from './ReactFiberContext';
-import {popProvider} from './ReactFiberNewContext';
-
-export default function(
+export default function<C, CX>(
   hostContext: HostContext<C, CX>,
+  legacyContext: LegacyContext,
+  newContext: NewContext,
   scheduleWork: (
     fiber: Fiber,
     startTime: ExpirationTime,
@@ -41,6 +45,11 @@ export default function(
   isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
 ) {
   const {popHostContainer, popHostContext} = hostContext;
+  const {
+    popContextProvider: popLegacyContextProvider,
+    popTopLevelContextObject: popTopLevelLegacyContextObject,
+  } = legacyContext;
+  const {popProvider} = newContext;
 
   function throwException(
     returnFiber: Fiber,
@@ -61,7 +70,9 @@ export default function(
           // Uncaught error
           const errorInfo = value;
           ensureUpdateQueues(workInProgress);
-          const updateQueue: UpdateQueue = (workInProgress.updateQueue: any);
+          const updateQueue: UpdateQueue<
+            any,
+          > = (workInProgress.updateQueue: any);
           updateQueue.capturedValues = [errorInfo];
           workInProgress.effectTag |= ShouldCapture;
           return;
@@ -79,7 +90,9 @@ export default function(
                 !isAlreadyFailedLegacyErrorBoundary(instance)))
           ) {
             ensureUpdateQueues(workInProgress);
-            const updateQueue: UpdateQueue = (workInProgress.updateQueue: any);
+            const updateQueue: UpdateQueue<
+              any,
+            > = (workInProgress.updateQueue: any);
             const capturedValues = updateQueue.capturedValues;
             if (capturedValues === null) {
               updateQueue.capturedValues = [value];
@@ -97,7 +110,7 @@ export default function(
     } while (workInProgress !== null);
   }
 
-  function unwindWork(workInProgress) {
+  function unwindWork(workInProgress: Fiber) {
     switch (workInProgress.tag) {
       case ClassComponent: {
         popLegacyContextProvider(workInProgress);
@@ -132,8 +145,36 @@ export default function(
         return null;
     }
   }
+
+  function unwindInterruptedWork(interruptedWork: Fiber) {
+    switch (interruptedWork.tag) {
+      case ClassComponent: {
+        popLegacyContextProvider(interruptedWork);
+        break;
+      }
+      case HostRoot: {
+        popHostContainer(interruptedWork);
+        popTopLevelLegacyContextObject(interruptedWork);
+        break;
+      }
+      case HostComponent: {
+        popHostContext(interruptedWork);
+        break;
+      }
+      case HostPortal:
+        popHostContainer(interruptedWork);
+        break;
+      case ContextProvider:
+        popProvider(interruptedWork);
+        break;
+      default:
+        break;
+    }
+  }
+
   return {
     throwException,
     unwindWork,
+    unwindInterruptedWork,
   };
 }

commit b548b3cd640dbd515f5d67dafc0216bb7ee0d796
Author: Andrew Clark <acdlite@me.com>
Date:   Sun Apr 22 23:05:28 2018 -0700

    Decouple update queue from Fiber type (#12600)
    
    * Decouple update queue from Fiber type
    
    The update queue is in need of a refactor. Recent bugfixes (#12528) have
    exposed some flaws in how it's modeled. Upcoming features like Suspense
    and [redacted] also rely on the update queue in ways that weren't
    anticipated in the original design.
    
    Major changes:
    
    - Instead of boolean flags for `isReplace` and `isForceUpdate`, updates
    have a `tag` field (like Fiber). This lowers the cost for adding new
    types of updates.
    - Render phase updates are special cased. Updates scheduled during
    the render phase are dropped if the work-in-progress does not commit.
    This is used for `getDerivedStateFrom{Props,Catch}`.
    - `callbackList` has been replaced with a generic effect list. Aside
    from callbacks, this is also used for `componentDidCatch`.
    
    * Remove first class UpdateQueue types and use closures instead
    
    I tried to avoid this at first, since we avoid it everywhere else in the Fiber
    codebase, but since updates are not in a hot path, the trade off with file size
    seems worth it.
    
    * Store captured errors on a separate part of the update queue
    
    This way they can be reused independently of updates like
    getDerivedStateFromProps. This will be important for resuming.
    
    * Revert back to storing hasForceUpdate on the update queue
    
    Instead of using the effect tag. Ideally, this would be part of the
    return type of processUpdateQueue.
    
    * Rename UpdateQueue effect type back to Callback
    
    I don't love this name either, but it's less confusing than UpdateQueue
    I suppose. Conceptually, this is usually a callback: setState callbacks,
    componentDidCatch. The only case that feels a bit weird is Timeouts,
    which use this effect to attach a promise listener. I guess that kinda
    fits, too.
    
    * Call getDerivedStateFromProps every render, even if props did not change
    
    Rather than enqueue a new setState updater for every props change, we
    can skip the update queue entirely and merge the result into state at
    the end. This makes more sense, since "receiving props" is not an event
    that should be observed. It's still a bit weird, since eventually we do
    persist the derived state (in other words, it accumulates).
    
    * Store captured effects on separate list from "own" effects (callbacks)
    
    For resuming, we need the ability to discard the "own" effects while
    reusing the captured effects.
    
    * Optimize for class components
    
    Change `process` and `callback` to match the expected payload types
    for class components. I had intended for the update queue to be reusable
    for both class components and a future React API, but we'll likely have
    to fork anyway.
    
    * Only double-invoke render phase lifecycles functions in DEV
    
    * Use global state to track currently processing queue in DEV

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 6565e4888d..e59324c3c4 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -12,10 +12,16 @@ import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {HostContext} from './ReactFiberHostContext';
 import type {LegacyContext} from './ReactFiberContext';
 import type {NewContext} from './ReactFiberNewContext';
-import type {UpdateQueue} from './ReactFiberUpdateQueue';
+import type {CapturedValue} from './ReactCapturedValue';
+import type {Update} from './ReactUpdateQueue';
 
 import {createCapturedValue} from './ReactCapturedValue';
-import {ensureUpdateQueues} from './ReactFiberUpdateQueue';
+import {
+  enqueueCapturedUpdate,
+  createUpdate,
+  CaptureUpdate,
+} from './ReactUpdateQueue';
+import {logError} from './ReactFiberCommitWork';
 
 import {
   ClassComponent,
@@ -42,7 +48,9 @@ export default function<C, CX>(
     startTime: ExpirationTime,
     expirationTime: ExpirationTime,
   ) => void,
+  markLegacyErrorBoundaryAsFailed: (instance: mixed) => void,
   isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
+  onUncaughtError: (error: mixed) => void,
 ) {
   const {popHostContainer, popHostContext} = hostContext;
   const {
@@ -51,10 +59,71 @@ export default function<C, CX>(
   } = legacyContext;
   const {popProvider} = newContext;
 
+  function createRootErrorUpdate(
+    fiber: Fiber,
+    errorInfo: CapturedValue<mixed>,
+    expirationTime: ExpirationTime,
+  ): Update<null> {
+    const update = createUpdate(expirationTime);
+    // Unmount the root by rendering null.
+    update.tag = CaptureUpdate;
+    update.payload = {children: null};
+    const error = errorInfo.value;
+    update.callback = () => {
+      onUncaughtError(error);
+      logError(fiber, errorInfo);
+    };
+    return update;
+  }
+
+  function createClassErrorUpdate(
+    fiber: Fiber,
+    errorInfo: CapturedValue<mixed>,
+    expirationTime: ExpirationTime,
+  ): Update<mixed> {
+    const update = createUpdate(expirationTime);
+    update.tag = CaptureUpdate;
+    const getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
+    if (
+      enableGetDerivedStateFromCatch &&
+      typeof getDerivedStateFromCatch === 'function'
+    ) {
+      const error = errorInfo.value;
+      update.payload = () => {
+        return getDerivedStateFromCatch(error);
+      };
+    }
+
+    const inst = fiber.stateNode;
+    if (inst !== null && typeof inst.componentDidCatch === 'function') {
+      update.callback = function callback() {
+        if (
+          !enableGetDerivedStateFromCatch ||
+          getDerivedStateFromCatch !== 'function'
+        ) {
+          // To preserve the preexisting retry behavior of error boundaries,
+          // we keep track of which ones already failed during this batch.
+          // This gets reset before we yield back to the browser.
+          // TODO: Warn in strict mode if getDerivedStateFromCatch is
+          // not defined.
+          markLegacyErrorBoundaryAsFailed(this);
+        }
+        const error = errorInfo.value;
+        const stack = errorInfo.stack;
+        logError(fiber, errorInfo);
+        this.componentDidCatch(error, {
+          componentStack: stack !== null ? stack : '',
+        });
+      };
+    }
+    return update;
+  }
+
   function throwException(
     returnFiber: Fiber,
     sourceFiber: Fiber,
     rawValue: mixed,
+    renderExpirationTime: ExpirationTime,
   ) {
     // The source fiber did not complete.
     sourceFiber.effectTag |= Incomplete;
@@ -67,18 +136,19 @@ export default function<C, CX>(
     do {
       switch (workInProgress.tag) {
         case HostRoot: {
-          // Uncaught error
           const errorInfo = value;
-          ensureUpdateQueues(workInProgress);
-          const updateQueue: UpdateQueue<
-            any,
-          > = (workInProgress.updateQueue: any);
-          updateQueue.capturedValues = [errorInfo];
           workInProgress.effectTag |= ShouldCapture;
+          const update = createRootErrorUpdate(
+            workInProgress,
+            errorInfo,
+            renderExpirationTime,
+          );
+          enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
           return;
         }
         case ClassComponent:
           // Capture and retry
+          const errorInfo = value;
           const ctor = workInProgress.type;
           const instance = workInProgress.stateNode;
           if (
@@ -89,17 +159,14 @@ export default function<C, CX>(
                 typeof instance.componentDidCatch === 'function' &&
                 !isAlreadyFailedLegacyErrorBoundary(instance)))
           ) {
-            ensureUpdateQueues(workInProgress);
-            const updateQueue: UpdateQueue<
-              any,
-            > = (workInProgress.updateQueue: any);
-            const capturedValues = updateQueue.capturedValues;
-            if (capturedValues === null) {
-              updateQueue.capturedValues = [value];
-            } else {
-              capturedValues.push(value);
-            }
             workInProgress.effectTag |= ShouldCapture;
+            // Schedule the error boundary to re-render using updated state
+            const update = createClassErrorUpdate(
+              workInProgress,
+              errorInfo,
+              renderExpirationTime,
+            );
+            enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
             return;
           }
           break;
@@ -176,5 +243,7 @@ export default function<C, CX>(
     throwException,
     unwindWork,
     unwindInterruptedWork,
+    createRootErrorUpdate,
+    createClassErrorUpdate,
   };
 }

commit ad7cd686670d8e519789fb226d8ff9175fb69370
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue May 1 21:04:20 2018 +0100

    Rename internal property to fix React DevTools (#12727)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index e59324c3c4..05a8a1856d 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -67,7 +67,9 @@ export default function<C, CX>(
     const update = createUpdate(expirationTime);
     // Unmount the root by rendering null.
     update.tag = CaptureUpdate;
-    update.payload = {children: null};
+    // Caution: React DevTools currently depends on this property
+    // being called "element".
+    update.payload = {element: null};
     const error = errorInfo.value;
     update.callback = () => {
       onUncaughtError(error);

commit fc3777b1fe295fd2661f1974f5587d214791f04b
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu May 10 15:25:32 2018 -0700

    Add Profiler component for collecting new render timing info (#12745)
    
    Add a new component type, Profiler, that can be used to collect new render time metrics. Since this is a new, experimental API, it will be exported as React.unstable_Profiler initially.
    
    Most of the functionality for this component has been added behind a feature flag, enableProfileModeMetrics. When the feature flag is disabled, the component will just render its children with no additional behavior. When the flag is enabled, React will also collect timing information and pass it to the onRender function (as described below).

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 05a8a1856d..3337f02fcd 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -7,12 +7,14 @@
  * @flow
  */
 
+import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {HostContext} from './ReactFiberHostContext';
 import type {LegacyContext} from './ReactFiberContext';
 import type {NewContext} from './ReactFiberNewContext';
 import type {CapturedValue} from './ReactCapturedValue';
+import type {ProfilerTimer} from './ReactProfilerTimer';
 import type {Update} from './ReactUpdateQueue';
 
 import {createCapturedValue} from './ReactCapturedValue';
@@ -29,17 +31,21 @@ import {
   HostComponent,
   HostPortal,
   ContextProvider,
+  Profiler,
 } from 'shared/ReactTypeOfWork';
 import {
-  NoEffect,
   DidCapture,
   Incomplete,
+  NoEffect,
   ShouldCapture,
 } from 'shared/ReactTypeOfSideEffect';
+import {
+  enableGetDerivedStateFromCatch,
+  enableProfilerTimer,
+} from 'shared/ReactFeatureFlags';
 
-import {enableGetDerivedStateFromCatch} from 'shared/ReactFeatureFlags';
-
-export default function<C, CX>(
+export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
+  config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,
   hostContext: HostContext<C, CX>,
   legacyContext: LegacyContext,
   newContext: NewContext,
@@ -51,6 +57,7 @@ export default function<C, CX>(
   markLegacyErrorBoundaryAsFailed: (instance: mixed) => void,
   isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
   onUncaughtError: (error: mixed) => void,
+  profilerTimer: ProfilerTimer,
 ) {
   const {popHostContainer, popHostContext} = hostContext;
   const {
@@ -58,6 +65,10 @@ export default function<C, CX>(
     popTopLevelContextObject: popTopLevelLegacyContextObject,
   } = legacyContext;
   const {popProvider} = newContext;
+  const {
+    resumeActualRenderTimerIfPaused,
+    recordElapsedActualRenderTime,
+  } = profilerTimer;
 
   function createRootErrorUpdate(
     fiber: Fiber,
@@ -236,6 +247,13 @@ export default function<C, CX>(
       case ContextProvider:
         popProvider(interruptedWork);
         break;
+      case Profiler:
+        if (enableProfilerTimer) {
+          // Resume in case we're picking up on work that was paused.
+          resumeActualRenderTimerIfPaused();
+          recordElapsedActualRenderTime(interruptedWork);
+        }
+        break;
       default:
         break;
     }

commit 6565795377d1d2c79a7708766f1af9e1a87517de
Author: Andrew Clark <acdlite@me.com>
Date:   Thu May 10 18:09:10 2018 -0700

    Suspense (#12279)
    
    * Timeout component
    
    Adds Timeout component. If a promise is thrown from inside a Timeout component,
    React will suspend the in-progress render from committing. When the promise
    resolves, React will retry. If the render is suspended for longer than the
    maximum threshold, the Timeout switches to a placeholder state.
    
    The timeout threshold is defined as the minimum of:
    - The expiration time of the current render
    - The `ms` prop given to each Timeout component in the ancestor path of the
    thrown promise.
    
    * Add a test for nested fallbacks
    
    Co-authored-by: Andrew Clark <acdlite@fb.com>
    
    * Resume on promise rejection
    
    React should resume rendering regardless of whether it resolves
    or rejects.
    
    * Wrap Suspense code in feature flag
    
    * Children of a Timeout must be strict mode compatible
    
    Async is not required for Suspense, but strict mode is.
    
    * Simplify list of pending work
    
    Some of this was added with "soft expiration" in mind, but now with our revised
    model for how soft expiration will work, this isn't necessary.
    
    It would be nice to remove more of this, but I think the list itself is inherent
    because we need a way to track the start times, for <Timeout ms={ms} />.
    
    * Only use the Timeout update queue to store promises, not for state
    
    It already worked this way in practice.
    
    * Wrap more Suspense-only paths in the feature flag
    
    * Attach promise listener immediately on suspend
    
    Instead of waiting for commit phase.
    
    * Infer approximate start time using expiration time
    
    * Remove list of pending priority levels
    
    We can replicate almost all the functionality by tracking just five
    separate levels: the highest/lowest priority pending levels, the
    highest/lowest priority suspended levels, and the lowest pinged level.
    
    We lose a bit of granularity, in that if there are multiple levels of
    pending updates, only the first and last ones are known. But in practice
    this likely isn't a big deal.
    
    These heuristics are almost entirely isolated to a single module and
    can be adjusted later, without API changes, if necessary.
    
    Non-IO-bound work is not affected at all.
    
    * ReactFiberPendingWork -> ReactFiberPendingPriority
    
    * Renaming method names from "pending work" to "pending priority"
    
    * Get rid of SuspenseThenable module
    
    Idk why I thought this was neccessary
    
    * Nits based on Sebastian's feedback
    
    * More naming nits + comments
    
    * Add test for hiding a suspended tree to unblock
    
    * Revert change to expiration time rounding
    
    This means you have to account for the start time approximation
    heuristic when writing Suspense tests, but that's going to be
    true regardless.
    
    When updating the tests, I also made a fix related to offscreen
    priority. We should never timeout inside a hidden tree.
    
    * palceholder -> placeholder

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 3337f02fcd..31bb8a258b 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -9,6 +9,7 @@
 
 import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
+import type {FiberRoot} from './ReactFiberRoot';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {HostContext} from './ReactFiberHostContext';
 import type {LegacyContext} from './ReactFiberContext';
@@ -16,11 +17,13 @@ import type {NewContext} from './ReactFiberNewContext';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {ProfilerTimer} from './ReactProfilerTimer';
 import type {Update} from './ReactUpdateQueue';
+import type {Thenable} from './ReactFiberScheduler';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
   enqueueCapturedUpdate,
   createUpdate,
+  enqueueUpdate,
   CaptureUpdate,
 } from './ReactUpdateQueue';
 import {logError} from './ReactFiberCommitWork';
@@ -32,6 +35,7 @@ import {
   HostPortal,
   ContextProvider,
   Profiler,
+  TimeoutComponent,
 } from 'shared/ReactTypeOfWork';
 import {
   DidCapture,
@@ -42,22 +46,33 @@ import {
 import {
   enableGetDerivedStateFromCatch,
   enableProfilerTimer,
+  enableSuspense,
 } from 'shared/ReactFeatureFlags';
 
+import {Never, Sync, expirationTimeToMs} from './ReactFiberExpirationTime';
+
 export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
   config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,
   hostContext: HostContext<C, CX>,
   legacyContext: LegacyContext,
   newContext: NewContext,
-  scheduleWork: (
-    fiber: Fiber,
+  scheduleWork: (fiber: Fiber, expirationTime: ExpirationTime) => void,
+  computeExpirationForFiber: (
     startTime: ExpirationTime,
-    expirationTime: ExpirationTime,
-  ) => void,
+    fiber: Fiber,
+  ) => ExpirationTime,
+  recalculateCurrentTime: () => ExpirationTime,
   markLegacyErrorBoundaryAsFailed: (instance: mixed) => void,
   isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
   onUncaughtError: (error: mixed) => void,
   profilerTimer: ProfilerTimer,
+  suspendRoot: (
+    root: FiberRoot,
+    thenable: Thenable,
+    timeoutMs: number,
+    suspendedTime: ExpirationTime,
+  ) => void,
+  retrySuspendedRoot: (root: FiberRoot, suspendedTime: ExpirationTime) => void,
 ) {
   const {popHostContainer, popHostContext} = hostContext;
   const {
@@ -132,19 +147,133 @@ export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
     return update;
   }
 
+  function schedulePing(finishedWork) {
+    // Once the promise resolves, we should try rendering the non-
+    // placeholder state again.
+    const currentTime = recalculateCurrentTime();
+    const expirationTime = computeExpirationForFiber(currentTime, finishedWork);
+    const recoveryUpdate = createUpdate(expirationTime);
+    enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);
+    scheduleWork(finishedWork, expirationTime);
+  }
+
   function throwException(
+    root: FiberRoot,
     returnFiber: Fiber,
     sourceFiber: Fiber,
-    rawValue: mixed,
+    value: mixed,
+    renderIsExpired: boolean,
     renderExpirationTime: ExpirationTime,
+    currentTimeMs: number,
   ) {
     // The source fiber did not complete.
     sourceFiber.effectTag |= Incomplete;
     // Its effect list is no longer valid.
     sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
-    const value = createCapturedValue(rawValue, sourceFiber);
+    if (
+      enableSuspense &&
+      value !== null &&
+      typeof value === 'object' &&
+      typeof value.then === 'function'
+    ) {
+      // This is a thenable.
+      const thenable: Thenable = (value: any);
+
+      const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
+      const startTimeMs = expirationTimeMs - 5000;
+      let elapsedMs = currentTimeMs - startTimeMs;
+      if (elapsedMs < 0) {
+        elapsedMs = 0;
+      }
+      const remainingTimeMs = expirationTimeMs - currentTimeMs;
+
+      // Find the earliest timeout of all the timeouts in the ancestor path.
+      // TODO: Alternatively, we could store the earliest timeout on the context
+      // stack, rather than searching on every suspend.
+      let workInProgress = returnFiber;
+      let earliestTimeoutMs = -1;
+      searchForEarliestTimeout: do {
+        if (workInProgress.tag === TimeoutComponent) {
+          const current = workInProgress.alternate;
+          if (current !== null && current.memoizedState === true) {
+            // A parent Timeout already committed in a placeholder state. We
+            // need to handle this promise immediately. In other words, we
+            // should never suspend inside a tree that already expired.
+            earliestTimeoutMs = 0;
+            break searchForEarliestTimeout;
+          }
+          let timeoutPropMs = workInProgress.pendingProps.ms;
+          if (typeof timeoutPropMs === 'number') {
+            if (timeoutPropMs <= 0) {
+              earliestTimeoutMs = 0;
+              break searchForEarliestTimeout;
+            } else if (
+              earliestTimeoutMs === -1 ||
+              timeoutPropMs < earliestTimeoutMs
+            ) {
+              earliestTimeoutMs = timeoutPropMs;
+            }
+          } else if (earliestTimeoutMs === -1) {
+            earliestTimeoutMs = remainingTimeMs;
+          }
+        }
+        workInProgress = workInProgress.return;
+      } while (workInProgress !== null);
+
+      // Compute the remaining time until the timeout.
+      const msUntilTimeout = earliestTimeoutMs - elapsedMs;
+
+      if (renderExpirationTime === Never || msUntilTimeout > 0) {
+        // There's still time remaining.
+        suspendRoot(root, thenable, msUntilTimeout, renderExpirationTime);
+        const onResolveOrReject = () => {
+          retrySuspendedRoot(root, renderExpirationTime);
+        };
+        thenable.then(onResolveOrReject, onResolveOrReject);
+        return;
+      } else {
+        // No time remaining. Need to fallback to placeholder.
+        // Find the nearest timeout that can be retried.
+        workInProgress = returnFiber;
+        do {
+          switch (workInProgress.tag) {
+            case HostRoot: {
+              // The root expired, but no fallback was provided. Throw a
+              // helpful error.
+              const message =
+                renderExpirationTime === Sync
+                  ? 'A synchronous update was suspended, but no fallback UI ' +
+                    'was provided.'
+                  : 'An update was suspended for longer than the timeout, ' +
+                    'but no fallback UI was provided.';
+              value = new Error(message);
+              break;
+            }
+            case TimeoutComponent: {
+              if ((workInProgress.effectTag & DidCapture) === NoEffect) {
+                workInProgress.effectTag |= ShouldCapture;
+                const onResolveOrReject = schedulePing.bind(
+                  null,
+                  workInProgress,
+                );
+                thenable.then(onResolveOrReject, onResolveOrReject);
+                return;
+              }
+              // Already captured during this render. Continue to the next
+              // Timeout ancestor.
+              break;
+            }
+          }
+          workInProgress = workInProgress.return;
+        } while (workInProgress !== null);
+      }
+    }
 
+    // We didn't find a boundary that could handle this type of exception. Start
+    // over and traverse parent path again, this time treating the exception
+    // as an error.
+    value = createCapturedValue(value, sourceFiber);
     let workInProgress = returnFiber;
     do {
       switch (workInProgress.tag) {
@@ -190,7 +319,11 @@ export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
     } while (workInProgress !== null);
   }
 
-  function unwindWork(workInProgress: Fiber) {
+  function unwindWork(
+    workInProgress: Fiber,
+    renderIsExpired: boolean,
+    renderExpirationTime: ExpirationTime,
+  ) {
     switch (workInProgress.tag) {
       case ClassComponent: {
         popLegacyContextProvider(workInProgress);
@@ -215,6 +348,14 @@ export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
         popHostContext(workInProgress);
         return null;
       }
+      case TimeoutComponent: {
+        const effectTag = workInProgress.effectTag;
+        if (effectTag & ShouldCapture) {
+          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+          return workInProgress;
+        }
+        return null;
+      }
       case HostPortal:
         popHostContainer(workInProgress);
         return null;

commit 47b003a828fe98e12947ba98e819ec4e617deef1
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat May 19 11:29:11 2018 +0100

    Resolve host configs at build time (#12792)
    
    * Extract base Jest config
    
    This makes it easier to change the source config without affecting the build test config.
    
    * Statically import the host config
    
    This changes react-reconciler to import HostConfig instead of getting it through a function argument.
    
    Rather than start with packages like ReactDOM that want to inline it, I started with React Noop and ensured that *custom* renderers using react-reconciler package still work. To do this, I'm making HostConfig module in the reconciler look at a global variable by default (which, in case of the react-reconciler npm package, ends up being the host config argument in the top-level scope).
    
    This is still very broken.
    
    * Add scaffolding for importing an inlined renderer
    
    * Fix the build
    
    * ES exports for renderer methods
    
    * ES modules for host configs
    
    * Remove closures from the reconciler
    
    * Check each renderer's config with Flow
    
    * Fix uncovered Flow issue
    
    We know nextHydratableInstance doesn't get mutated inside this function, but Flow doesn't so it thinks it may be null.
    Help Flow.
    
    * Prettier
    
    * Get rid of enable*Reconciler flags
    
    They are not as useful anymore because for almost all cases (except third party renderers) we *know* whether it supports mutation or persistence.
    
    This refactoring means react-reconciler and react-reconciler/persistent third-party packages now ship the same thing.
    Not ideal, but this seems worth how simpler the code becomes. We can later look into addressing it by having a single toggle instead.
    
    * Prettier again
    
    * Fix Flow config creation issue
    
    * Fix imprecise Flow typing
    
    * Revert accidental changes

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 31bb8a258b..b4be270162 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -7,27 +7,13 @@
  * @flow
  */
 
-import type {HostConfig} from 'react-reconciler';
 import type {Fiber} from './ReactFiber';
 import type {FiberRoot} from './ReactFiberRoot';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
-import type {HostContext} from './ReactFiberHostContext';
-import type {LegacyContext} from './ReactFiberContext';
-import type {NewContext} from './ReactFiberNewContext';
 import type {CapturedValue} from './ReactCapturedValue';
-import type {ProfilerTimer} from './ReactProfilerTimer';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
 
-import {createCapturedValue} from './ReactCapturedValue';
-import {
-  enqueueCapturedUpdate,
-  createUpdate,
-  enqueueUpdate,
-  CaptureUpdate,
-} from './ReactUpdateQueue';
-import {logError} from './ReactFiberCommitWork';
-
 import {
   ClassComponent,
   HostRoot,
@@ -49,238 +35,252 @@ import {
   enableSuspense,
 } from 'shared/ReactFeatureFlags';
 
+import {createCapturedValue} from './ReactCapturedValue';
+import {
+  enqueueCapturedUpdate,
+  createUpdate,
+  enqueueUpdate,
+  CaptureUpdate,
+} from './ReactUpdateQueue';
+import {logError} from './ReactFiberCommitWork';
 import {Never, Sync, expirationTimeToMs} from './ReactFiberExpirationTime';
+import {popHostContainer, popHostContext} from './ReactFiberHostContext';
+import {
+  popContextProvider as popLegacyContextProvider,
+  popTopLevelContextObject as popTopLevelLegacyContextObject,
+} from './ReactFiberContext';
+import {popProvider} from './ReactFiberNewContext';
+import {
+  resumeActualRenderTimerIfPaused,
+  recordElapsedActualRenderTime,
+} from './ReactProfilerTimer';
+import {
+  suspendRoot,
+  onUncaughtError,
+  markLegacyErrorBoundaryAsFailed,
+  isAlreadyFailedLegacyErrorBoundary,
+  recalculateCurrentTime,
+  computeExpirationForFiber,
+  scheduleWork,
+  retrySuspendedRoot,
+} from './ReactFiberScheduler';
 
-export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
-  config: HostConfig<T, P, I, TI, HI, PI, C, CC, CX, PL>,
-  hostContext: HostContext<C, CX>,
-  legacyContext: LegacyContext,
-  newContext: NewContext,
-  scheduleWork: (fiber: Fiber, expirationTime: ExpirationTime) => void,
-  computeExpirationForFiber: (
-    startTime: ExpirationTime,
-    fiber: Fiber,
-  ) => ExpirationTime,
-  recalculateCurrentTime: () => ExpirationTime,
-  markLegacyErrorBoundaryAsFailed: (instance: mixed) => void,
-  isAlreadyFailedLegacyErrorBoundary: (instance: mixed) => boolean,
-  onUncaughtError: (error: mixed) => void,
-  profilerTimer: ProfilerTimer,
-  suspendRoot: (
-    root: FiberRoot,
-    thenable: Thenable,
-    timeoutMs: number,
-    suspendedTime: ExpirationTime,
-  ) => void,
-  retrySuspendedRoot: (root: FiberRoot, suspendedTime: ExpirationTime) => void,
-) {
-  const {popHostContainer, popHostContext} = hostContext;
-  const {
-    popContextProvider: popLegacyContextProvider,
-    popTopLevelContextObject: popTopLevelLegacyContextObject,
-  } = legacyContext;
-  const {popProvider} = newContext;
-  const {
-    resumeActualRenderTimerIfPaused,
-    recordElapsedActualRenderTime,
-  } = profilerTimer;
+function createRootErrorUpdate(
+  fiber: Fiber,
+  errorInfo: CapturedValue<mixed>,
+  expirationTime: ExpirationTime,
+): Update<null> {
+  const update = createUpdate(expirationTime);
+  // Unmount the root by rendering null.
+  update.tag = CaptureUpdate;
+  // Caution: React DevTools currently depends on this property
+  // being called "element".
+  update.payload = {element: null};
+  const error = errorInfo.value;
+  update.callback = () => {
+    onUncaughtError(error);
+    logError(fiber, errorInfo);
+  };
+  return update;
+}
 
-  function createRootErrorUpdate(
-    fiber: Fiber,
-    errorInfo: CapturedValue<mixed>,
-    expirationTime: ExpirationTime,
-  ): Update<null> {
-    const update = createUpdate(expirationTime);
-    // Unmount the root by rendering null.
-    update.tag = CaptureUpdate;
-    // Caution: React DevTools currently depends on this property
-    // being called "element".
-    update.payload = {element: null};
+function createClassErrorUpdate(
+  fiber: Fiber,
+  errorInfo: CapturedValue<mixed>,
+  expirationTime: ExpirationTime,
+): Update<mixed> {
+  const update = createUpdate(expirationTime);
+  update.tag = CaptureUpdate;
+  const getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
+  if (
+    enableGetDerivedStateFromCatch &&
+    typeof getDerivedStateFromCatch === 'function'
+  ) {
     const error = errorInfo.value;
-    update.callback = () => {
-      onUncaughtError(error);
-      logError(fiber, errorInfo);
+    update.payload = () => {
+      return getDerivedStateFromCatch(error);
     };
-    return update;
   }
 
-  function createClassErrorUpdate(
-    fiber: Fiber,
-    errorInfo: CapturedValue<mixed>,
-    expirationTime: ExpirationTime,
-  ): Update<mixed> {
-    const update = createUpdate(expirationTime);
-    update.tag = CaptureUpdate;
-    const getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
-    if (
-      enableGetDerivedStateFromCatch &&
-      typeof getDerivedStateFromCatch === 'function'
-    ) {
+  const inst = fiber.stateNode;
+  if (inst !== null && typeof inst.componentDidCatch === 'function') {
+    update.callback = function callback() {
+      if (
+        !enableGetDerivedStateFromCatch ||
+        getDerivedStateFromCatch !== 'function'
+      ) {
+        // To preserve the preexisting retry behavior of error boundaries,
+        // we keep track of which ones already failed during this batch.
+        // This gets reset before we yield back to the browser.
+        // TODO: Warn in strict mode if getDerivedStateFromCatch is
+        // not defined.
+        markLegacyErrorBoundaryAsFailed(this);
+      }
       const error = errorInfo.value;
-      update.payload = () => {
-        return getDerivedStateFromCatch(error);
-      };
-    }
-
-    const inst = fiber.stateNode;
-    if (inst !== null && typeof inst.componentDidCatch === 'function') {
-      update.callback = function callback() {
-        if (
-          !enableGetDerivedStateFromCatch ||
-          getDerivedStateFromCatch !== 'function'
-        ) {
-          // To preserve the preexisting retry behavior of error boundaries,
-          // we keep track of which ones already failed during this batch.
-          // This gets reset before we yield back to the browser.
-          // TODO: Warn in strict mode if getDerivedStateFromCatch is
-          // not defined.
-          markLegacyErrorBoundaryAsFailed(this);
-        }
-        const error = errorInfo.value;
-        const stack = errorInfo.stack;
-        logError(fiber, errorInfo);
-        this.componentDidCatch(error, {
-          componentStack: stack !== null ? stack : '',
-        });
-      };
-    }
-    return update;
+      const stack = errorInfo.stack;
+      logError(fiber, errorInfo);
+      this.componentDidCatch(error, {
+        componentStack: stack !== null ? stack : '',
+      });
+    };
   }
+  return update;
+}
 
-  function schedulePing(finishedWork) {
-    // Once the promise resolves, we should try rendering the non-
-    // placeholder state again.
-    const currentTime = recalculateCurrentTime();
-    const expirationTime = computeExpirationForFiber(currentTime, finishedWork);
-    const recoveryUpdate = createUpdate(expirationTime);
-    enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);
-    scheduleWork(finishedWork, expirationTime);
-  }
+function schedulePing(finishedWork) {
+  // Once the promise resolves, we should try rendering the non-
+  // placeholder state again.
+  const currentTime = recalculateCurrentTime();
+  const expirationTime = computeExpirationForFiber(currentTime, finishedWork);
+  const recoveryUpdate = createUpdate(expirationTime);
+  enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);
+  scheduleWork(finishedWork, expirationTime);
+}
 
-  function throwException(
-    root: FiberRoot,
-    returnFiber: Fiber,
-    sourceFiber: Fiber,
-    value: mixed,
-    renderIsExpired: boolean,
-    renderExpirationTime: ExpirationTime,
-    currentTimeMs: number,
-  ) {
-    // The source fiber did not complete.
-    sourceFiber.effectTag |= Incomplete;
-    // Its effect list is no longer valid.
-    sourceFiber.firstEffect = sourceFiber.lastEffect = null;
+function throwException(
+  root: FiberRoot,
+  returnFiber: Fiber,
+  sourceFiber: Fiber,
+  value: mixed,
+  renderIsExpired: boolean,
+  renderExpirationTime: ExpirationTime,
+  currentTimeMs: number,
+) {
+  // The source fiber did not complete.
+  sourceFiber.effectTag |= Incomplete;
+  // Its effect list is no longer valid.
+  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
-    if (
-      enableSuspense &&
-      value !== null &&
-      typeof value === 'object' &&
-      typeof value.then === 'function'
-    ) {
-      // This is a thenable.
-      const thenable: Thenable = (value: any);
+  if (
+    enableSuspense &&
+    value !== null &&
+    typeof value === 'object' &&
+    typeof value.then === 'function'
+  ) {
+    // This is a thenable.
+    const thenable: Thenable = (value: any);
 
-      const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
-      const startTimeMs = expirationTimeMs - 5000;
-      let elapsedMs = currentTimeMs - startTimeMs;
-      if (elapsedMs < 0) {
-        elapsedMs = 0;
-      }
-      const remainingTimeMs = expirationTimeMs - currentTimeMs;
+    const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
+    const startTimeMs = expirationTimeMs - 5000;
+    let elapsedMs = currentTimeMs - startTimeMs;
+    if (elapsedMs < 0) {
+      elapsedMs = 0;
+    }
+    const remainingTimeMs = expirationTimeMs - currentTimeMs;
 
-      // Find the earliest timeout of all the timeouts in the ancestor path.
-      // TODO: Alternatively, we could store the earliest timeout on the context
-      // stack, rather than searching on every suspend.
-      let workInProgress = returnFiber;
-      let earliestTimeoutMs = -1;
-      searchForEarliestTimeout: do {
-        if (workInProgress.tag === TimeoutComponent) {
-          const current = workInProgress.alternate;
-          if (current !== null && current.memoizedState === true) {
-            // A parent Timeout already committed in a placeholder state. We
-            // need to handle this promise immediately. In other words, we
-            // should never suspend inside a tree that already expired.
+    // Find the earliest timeout of all the timeouts in the ancestor path.
+    // TODO: Alternatively, we could store the earliest timeout on the context
+    // stack, rather than searching on every suspend.
+    let workInProgress = returnFiber;
+    let earliestTimeoutMs = -1;
+    searchForEarliestTimeout: do {
+      if (workInProgress.tag === TimeoutComponent) {
+        const current = workInProgress.alternate;
+        if (current !== null && current.memoizedState === true) {
+          // A parent Timeout already committed in a placeholder state. We
+          // need to handle this promise immediately. In other words, we
+          // should never suspend inside a tree that already expired.
+          earliestTimeoutMs = 0;
+          break searchForEarliestTimeout;
+        }
+        let timeoutPropMs = workInProgress.pendingProps.ms;
+        if (typeof timeoutPropMs === 'number') {
+          if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
             break searchForEarliestTimeout;
+          } else if (
+            earliestTimeoutMs === -1 ||
+            timeoutPropMs < earliestTimeoutMs
+          ) {
+            earliestTimeoutMs = timeoutPropMs;
+          }
+        } else if (earliestTimeoutMs === -1) {
+          earliestTimeoutMs = remainingTimeMs;
+        }
+      }
+      workInProgress = workInProgress.return;
+    } while (workInProgress !== null);
+
+    // Compute the remaining time until the timeout.
+    const msUntilTimeout = earliestTimeoutMs - elapsedMs;
+
+    if (renderExpirationTime === Never || msUntilTimeout > 0) {
+      // There's still time remaining.
+      suspendRoot(root, thenable, msUntilTimeout, renderExpirationTime);
+      const onResolveOrReject = () => {
+        retrySuspendedRoot(root, renderExpirationTime);
+      };
+      thenable.then(onResolveOrReject, onResolveOrReject);
+      return;
+    } else {
+      // No time remaining. Need to fallback to placeholder.
+      // Find the nearest timeout that can be retried.
+      workInProgress = returnFiber;
+      do {
+        switch (workInProgress.tag) {
+          case HostRoot: {
+            // The root expired, but no fallback was provided. Throw a
+            // helpful error.
+            const message =
+              renderExpirationTime === Sync
+                ? 'A synchronous update was suspended, but no fallback UI ' +
+                  'was provided.'
+                : 'An update was suspended for longer than the timeout, ' +
+                  'but no fallback UI was provided.';
+            value = new Error(message);
+            break;
           }
-          let timeoutPropMs = workInProgress.pendingProps.ms;
-          if (typeof timeoutPropMs === 'number') {
-            if (timeoutPropMs <= 0) {
-              earliestTimeoutMs = 0;
-              break searchForEarliestTimeout;
-            } else if (
-              earliestTimeoutMs === -1 ||
-              timeoutPropMs < earliestTimeoutMs
-            ) {
-              earliestTimeoutMs = timeoutPropMs;
+          case TimeoutComponent: {
+            if ((workInProgress.effectTag & DidCapture) === NoEffect) {
+              workInProgress.effectTag |= ShouldCapture;
+              const onResolveOrReject = schedulePing.bind(null, workInProgress);
+              thenable.then(onResolveOrReject, onResolveOrReject);
+              return;
             }
-          } else if (earliestTimeoutMs === -1) {
-            earliestTimeoutMs = remainingTimeMs;
+            // Already captured during this render. Continue to the next
+            // Timeout ancestor.
+            break;
           }
         }
         workInProgress = workInProgress.return;
       } while (workInProgress !== null);
+    }
+  }
 
-      // Compute the remaining time until the timeout.
-      const msUntilTimeout = earliestTimeoutMs - elapsedMs;
-
-      if (renderExpirationTime === Never || msUntilTimeout > 0) {
-        // There's still time remaining.
-        suspendRoot(root, thenable, msUntilTimeout, renderExpirationTime);
-        const onResolveOrReject = () => {
-          retrySuspendedRoot(root, renderExpirationTime);
-        };
-        thenable.then(onResolveOrReject, onResolveOrReject);
+  // We didn't find a boundary that could handle this type of exception. Start
+  // over and traverse parent path again, this time treating the exception
+  // as an error.
+  value = createCapturedValue(value, sourceFiber);
+  let workInProgress = returnFiber;
+  do {
+    switch (workInProgress.tag) {
+      case HostRoot: {
+        const errorInfo = value;
+        workInProgress.effectTag |= ShouldCapture;
+        const update = createRootErrorUpdate(
+          workInProgress,
+          errorInfo,
+          renderExpirationTime,
+        );
+        enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
         return;
-      } else {
-        // No time remaining. Need to fallback to placeholder.
-        // Find the nearest timeout that can be retried.
-        workInProgress = returnFiber;
-        do {
-          switch (workInProgress.tag) {
-            case HostRoot: {
-              // The root expired, but no fallback was provided. Throw a
-              // helpful error.
-              const message =
-                renderExpirationTime === Sync
-                  ? 'A synchronous update was suspended, but no fallback UI ' +
-                    'was provided.'
-                  : 'An update was suspended for longer than the timeout, ' +
-                    'but no fallback UI was provided.';
-              value = new Error(message);
-              break;
-            }
-            case TimeoutComponent: {
-              if ((workInProgress.effectTag & DidCapture) === NoEffect) {
-                workInProgress.effectTag |= ShouldCapture;
-                const onResolveOrReject = schedulePing.bind(
-                  null,
-                  workInProgress,
-                );
-                thenable.then(onResolveOrReject, onResolveOrReject);
-                return;
-              }
-              // Already captured during this render. Continue to the next
-              // Timeout ancestor.
-              break;
-            }
-          }
-          workInProgress = workInProgress.return;
-        } while (workInProgress !== null);
       }
-    }
-
-    // We didn't find a boundary that could handle this type of exception. Start
-    // over and traverse parent path again, this time treating the exception
-    // as an error.
-    value = createCapturedValue(value, sourceFiber);
-    let workInProgress = returnFiber;
-    do {
-      switch (workInProgress.tag) {
-        case HostRoot: {
-          const errorInfo = value;
+      case ClassComponent:
+        // Capture and retry
+        const errorInfo = value;
+        const ctor = workInProgress.type;
+        const instance = workInProgress.stateNode;
+        if (
+          (workInProgress.effectTag & DidCapture) === NoEffect &&
+          ((typeof ctor.getDerivedStateFromCatch === 'function' &&
+            enableGetDerivedStateFromCatch) ||
+            (instance !== null &&
+              typeof instance.componentDidCatch === 'function' &&
+              !isAlreadyFailedLegacyErrorBoundary(instance)))
+        ) {
           workInProgress.effectTag |= ShouldCapture;
-          const update = createRootErrorUpdate(
+          // Schedule the error boundary to re-render using updated state
+          const update = createClassErrorUpdate(
             workInProgress,
             errorInfo,
             renderExpirationTime,
@@ -288,123 +288,99 @@ export default function<T, P, I, TI, HI, PI, C, CC, CX, PL>(
           enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
           return;
         }
-        case ClassComponent:
-          // Capture and retry
-          const errorInfo = value;
-          const ctor = workInProgress.type;
-          const instance = workInProgress.stateNode;
-          if (
-            (workInProgress.effectTag & DidCapture) === NoEffect &&
-            ((typeof ctor.getDerivedStateFromCatch === 'function' &&
-              enableGetDerivedStateFromCatch) ||
-              (instance !== null &&
-                typeof instance.componentDidCatch === 'function' &&
-                !isAlreadyFailedLegacyErrorBoundary(instance)))
-          ) {
-            workInProgress.effectTag |= ShouldCapture;
-            // Schedule the error boundary to re-render using updated state
-            const update = createClassErrorUpdate(
-              workInProgress,
-              errorInfo,
-              renderExpirationTime,
-            );
-            enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
-            return;
-          }
-          break;
-        default:
-          break;
-      }
-      workInProgress = workInProgress.return;
-    } while (workInProgress !== null);
-  }
-
-  function unwindWork(
-    workInProgress: Fiber,
-    renderIsExpired: boolean,
-    renderExpirationTime: ExpirationTime,
-  ) {
-    switch (workInProgress.tag) {
-      case ClassComponent: {
-        popLegacyContextProvider(workInProgress);
-        const effectTag = workInProgress.effectTag;
-        if (effectTag & ShouldCapture) {
-          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-          return workInProgress;
-        }
-        return null;
-      }
-      case HostRoot: {
-        popHostContainer(workInProgress);
-        popTopLevelLegacyContextObject(workInProgress);
-        const effectTag = workInProgress.effectTag;
-        if (effectTag & ShouldCapture) {
-          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-          return workInProgress;
-        }
-        return null;
-      }
-      case HostComponent: {
-        popHostContext(workInProgress);
-        return null;
-      }
-      case TimeoutComponent: {
-        const effectTag = workInProgress.effectTag;
-        if (effectTag & ShouldCapture) {
-          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-          return workInProgress;
-        }
-        return null;
-      }
-      case HostPortal:
-        popHostContainer(workInProgress);
-        return null;
-      case ContextProvider:
-        popProvider(workInProgress);
-        return null;
+        break;
       default:
-        return null;
+        break;
     }
-  }
+    workInProgress = workInProgress.return;
+  } while (workInProgress !== null);
+}
 
-  function unwindInterruptedWork(interruptedWork: Fiber) {
-    switch (interruptedWork.tag) {
-      case ClassComponent: {
-        popLegacyContextProvider(interruptedWork);
-        break;
+function unwindWork(
+  workInProgress: Fiber,
+  renderIsExpired: boolean,
+  renderExpirationTime: ExpirationTime,
+) {
+  switch (workInProgress.tag) {
+    case ClassComponent: {
+      popLegacyContextProvider(workInProgress);
+      const effectTag = workInProgress.effectTag;
+      if (effectTag & ShouldCapture) {
+        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+        return workInProgress;
       }
-      case HostRoot: {
-        popHostContainer(interruptedWork);
-        popTopLevelLegacyContextObject(interruptedWork);
-        break;
+      return null;
+    }
+    case HostRoot: {
+      popHostContainer(workInProgress);
+      popTopLevelLegacyContextObject(workInProgress);
+      const effectTag = workInProgress.effectTag;
+      if (effectTag & ShouldCapture) {
+        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+        return workInProgress;
       }
-      case HostComponent: {
-        popHostContext(interruptedWork);
-        break;
+      return null;
+    }
+    case HostComponent: {
+      popHostContext(workInProgress);
+      return null;
+    }
+    case TimeoutComponent: {
+      const effectTag = workInProgress.effectTag;
+      if (effectTag & ShouldCapture) {
+        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+        return workInProgress;
       }
-      case HostPortal:
-        popHostContainer(interruptedWork);
-        break;
-      case ContextProvider:
-        popProvider(interruptedWork);
-        break;
-      case Profiler:
-        if (enableProfilerTimer) {
-          // Resume in case we're picking up on work that was paused.
-          resumeActualRenderTimerIfPaused();
-          recordElapsedActualRenderTime(interruptedWork);
-        }
-        break;
-      default:
-        break;
+      return null;
     }
+    case HostPortal:
+      popHostContainer(workInProgress);
+      return null;
+    case ContextProvider:
+      popProvider(workInProgress);
+      return null;
+    default:
+      return null;
   }
+}
 
-  return {
-    throwException,
-    unwindWork,
-    unwindInterruptedWork,
-    createRootErrorUpdate,
-    createClassErrorUpdate,
-  };
+function unwindInterruptedWork(interruptedWork: Fiber) {
+  switch (interruptedWork.tag) {
+    case ClassComponent: {
+      popLegacyContextProvider(interruptedWork);
+      break;
+    }
+    case HostRoot: {
+      popHostContainer(interruptedWork);
+      popTopLevelLegacyContextObject(interruptedWork);
+      break;
+    }
+    case HostComponent: {
+      popHostContext(interruptedWork);
+      break;
+    }
+    case HostPortal:
+      popHostContainer(interruptedWork);
+      break;
+    case ContextProvider:
+      popProvider(interruptedWork);
+      break;
+    case Profiler:
+      if (enableProfilerTimer) {
+        // Resume in case we're picking up on work that was paused.
+        resumeActualRenderTimerIfPaused();
+        recordElapsedActualRenderTime(interruptedWork);
+      }
+      break;
+    default:
+      break;
+  }
 }
+
+export {
+  throwException,
+  unwindWork,
+  unwindInterruptedWork,
+  createRootErrorUpdate,
+  createClassErrorUpdate,
+};

commit 55787006710bd8ef89a01d60c4a9cfa58c71035d
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri May 25 14:51:13 2018 -0700

    Record "actual" times for all Fibers within a Profiler tree (alt) (#12910)
    
    * Moved actual time fields from Profiler stateNode to Fiber
    
    * Record actual time for all Fibers within a ProfileMode tree
    
    * Changed how profiler accumulates time
    
    This change gives up on accumulating time across renders of different priority, but in exchange- simplifies how the commit phase (reset) code works, and perhaps also makes the profiling code more compatible with future resuming behavior

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index b4be270162..19bb46bfa5 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -20,7 +20,6 @@ import {
   HostComponent,
   HostPortal,
   ContextProvider,
-  Profiler,
   TimeoutComponent,
 } from 'shared/ReactTypeOfWork';
 import {
@@ -34,6 +33,7 @@ import {
   enableProfilerTimer,
   enableSuspense,
 } from 'shared/ReactFeatureFlags';
+import {ProfileMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -301,6 +301,12 @@ function unwindWork(
   renderIsExpired: boolean,
   renderExpirationTime: ExpirationTime,
 ) {
+  if (enableProfilerTimer) {
+    if (workInProgress.mode & ProfileMode) {
+      recordElapsedActualRenderTime(workInProgress);
+    }
+  }
+
   switch (workInProgress.tag) {
     case ClassComponent: {
       popLegacyContextProvider(workInProgress);
@@ -345,6 +351,14 @@ function unwindWork(
 }
 
 function unwindInterruptedWork(interruptedWork: Fiber) {
+  if (enableProfilerTimer) {
+    if (interruptedWork.mode & ProfileMode) {
+      // Resume in case we're picking up on work that was paused.
+      resumeActualRenderTimerIfPaused();
+      recordElapsedActualRenderTime(interruptedWork);
+    }
+  }
+
   switch (interruptedWork.tag) {
     case ClassComponent: {
       popLegacyContextProvider(interruptedWork);
@@ -365,13 +379,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case ContextProvider:
       popProvider(interruptedWork);
       break;
-    case Profiler:
-      if (enableProfilerTimer) {
-        // Resume in case we're picking up on work that was paused.
-        resumeActualRenderTimerIfPaused();
-        recordElapsedActualRenderTime(interruptedWork);
-      }
-      break;
     default:
       break;
   }

commit e0c78344e2f49fb91a75607ccdb170b5649bb1e9
Author: Andrew Clark <acdlite@me.com>
Date:   Wed Jun 13 10:47:14 2018 -0700

    Retry on error if there's lower priority pending work (#12957)
    
    * Remove enableSuspense flag from PendingPriority module
    
    We're going to use this for suspending on error, too.
    
    * Retry on error if there's lower priority pending work
    
    If an error is thrown, and there's lower priority work, it's possible
    the lower priority work will fix the error. Retry at the lower priority.
    
    If an error is thrown and there's no more work to try, handle the error
    like we normally do (trigger the nearest error boundary).

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 19bb46bfa5..ba441e7dd7 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -55,7 +55,7 @@ import {
   recordElapsedActualRenderTime,
 } from './ReactProfilerTimer';
 import {
-  suspendRoot,
+  markTimeout,
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
@@ -151,6 +151,20 @@ function throwException(
   // Its effect list is no longer valid.
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
+  // Check if there is lower priority work, regardless of whether it's pending.
+  // If so, it may have the effect of fixing the exception that was just thrown.
+  const latestPendingTime = root.latestPendingTime;
+  const latestSuspendedTime = root.latestSuspendedTime;
+  if (
+    renderExpirationTime !== latestPendingTime &&
+    renderExpirationTime !== latestSuspendedTime &&
+    renderExpirationTime !== Never
+  ) {
+    // There's lower priority work. Exit to suspend this render and retry at
+    // the lower priority.
+    return;
+  }
+
   if (
     enableSuspense &&
     value !== null &&
@@ -206,7 +220,7 @@ function throwException(
 
     if (renderExpirationTime === Never || msUntilTimeout > 0) {
       // There's still time remaining.
-      suspendRoot(root, thenable, msUntilTimeout, renderExpirationTime);
+      markTimeout(root, thenable, msUntilTimeout, renderExpirationTime);
       const onResolveOrReject = () => {
         retrySuspendedRoot(root, renderExpirationTime);
       };

commit 9bda7b28f3b149c8f8ca826f0c395a81ed2d3bec
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Jun 14 15:29:27 2018 -0700

    Suspended high pri work forces lower priority work to expire early  (#12965)
    
    * onFatal, onComplete, onSuspend, onYield
    
    For every call to renderRoot, one of onFatal, onComplete, onSuspend,
    and onYield is called upon exiting. We use these in lieu of returning a
    tuple. I've also chosen not to inline them into renderRoot because these
    will eventually be lifted into the renderer.
    
    * Suspended high pri work forces lower priority work to expire early
    
    If an error is thrown, and there is lower priority pending work, we
    retry at the lower priority. The lower priority work should expire
    at the same time at which the high priority work would have expired.
    Effectively, this increases the priority of the low priority work.
    
    Simple example: If an error is thrown during a synchronous render, and
    there's an async update, the async update should flush synchronously in
    case it's able to fix the error. I've added a unit test for
    this scenario.
    
    User provided timeouts should have the same behavior, but I'll leave
    that for a future PR.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index ba441e7dd7..afefe81c5c 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -142,7 +142,6 @@ function throwException(
   returnFiber: Fiber,
   sourceFiber: Fiber,
   value: mixed,
-  renderIsExpired: boolean,
   renderExpirationTime: ExpirationTime,
   currentTimeMs: number,
 ) {
@@ -174,6 +173,7 @@ function throwException(
     // This is a thenable.
     const thenable: Thenable = (value: any);
 
+    // TODO: Should use the earliest known expiration time
     const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
     const startTimeMs = expirationTimeMs - 5000;
     let elapsedMs = currentTimeMs - startTimeMs;
@@ -312,7 +312,6 @@ function throwException(
 
 function unwindWork(
   workInProgress: Fiber,
-  renderIsExpired: boolean,
   renderExpirationTime: ExpirationTime,
 ) {
   if (enableProfilerTimer) {

commit 9bd4d1fae21a6521c185cb114a15ca5dc74d6d9b
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Jun 14 16:37:30 2018 -0700

    Synchronously restart when an error is thrown during async rendering (#13041)
    
    In async mode, events are interleaved with rendering. If one of those
    events mutates state that is later accessed during render, it can lead
    to inconsistencies/tearing.
    
    Restarting the render from the root is often sufficient to fix the
    inconsistency. We'll flush the restart synchronously to prevent yet
    another mutation from happening during an interleaved event.
    
    We'll only restart during an async render. Sync renders are already
    sync, so there's no benefit in restarting. (Unless a mutation happens
    during the render phase, but we don't support that.)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index afefe81c5c..e419df6d7c 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -56,6 +56,7 @@ import {
 } from './ReactProfilerTimer';
 import {
   markTimeout,
+  markError,
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
@@ -64,6 +65,7 @@ import {
   scheduleWork,
   retrySuspendedRoot,
 } from './ReactFiberScheduler';
+import {hasLowerPriorityWork} from './ReactFiberPendingPriority';
 
 function createRootErrorUpdate(
   fiber: Fiber,
@@ -150,20 +152,6 @@ function throwException(
   // Its effect list is no longer valid.
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
-  // Check if there is lower priority work, regardless of whether it's pending.
-  // If so, it may have the effect of fixing the exception that was just thrown.
-  const latestPendingTime = root.latestPendingTime;
-  const latestSuspendedTime = root.latestSuspendedTime;
-  if (
-    renderExpirationTime !== latestPendingTime &&
-    renderExpirationTime !== latestSuspendedTime &&
-    renderExpirationTime !== Never
-  ) {
-    // There's lower priority work. Exit to suspend this render and retry at
-    // the lower priority.
-    return;
-  }
-
   if (
     enableSuspense &&
     value !== null &&
@@ -259,6 +247,20 @@ function throwException(
         workInProgress = workInProgress.return;
       } while (workInProgress !== null);
     }
+  } else {
+    // This is an error.
+    markError(root);
+    if (
+      // Retry (at the same priority) one more time before handling the error.
+      // The retry will flush synchronously. (Unless we're already rendering
+      // synchronously, in which case move to the next check.)
+      (!root.didError && renderExpirationTime !== Sync) ||
+      // There's lower priority work. If so, it may have the effect of fixing
+      // the exception that was just thrown.
+      hasLowerPriorityWork(root, renderExpirationTime)
+    ) {
+      return;
+    }
   }
 
   // We didn't find a boundary that could handle this type of exception. Start

commit 4fe6eec15bc69737910e5c6c749ebc6187d67be0
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jun 19 10:34:19 2018 -0700

    Always batch updates of like priority within the same event (#13071)
    
    Expiration times are computed by adding to the current time (the start
    time). However, if two updates are scheduled within the same event, we
    should treat their start times as simultaneous, even if the actual clock
    time has advanced between the first and second call.
    
    In other words, because expiration times determine how updates are
    batched, we want all updates of like priority that occur within the same
    event to receive the same expiration time. Otherwise we get tearing.
    
    We keep track of two separate times: the current "renderer" time and the
    current "scheduler" time. The renderer time can be updated whenever; it
    only exists to minimize the calls performance.now.
    
    But the scheduler time can only be updated if there's no pending work,
    or if we know for certain that we're not in the middle of an event.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index e419df6d7c..8bc5efa876 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -60,7 +60,7 @@ import {
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
-  recalculateCurrentTime,
+  requestCurrentTime,
   computeExpirationForFiber,
   scheduleWork,
   retrySuspendedRoot,
@@ -132,7 +132,7 @@ function createClassErrorUpdate(
 function schedulePing(finishedWork) {
   // Once the promise resolves, we should try rendering the non-
   // placeholder state again.
-  const currentTime = recalculateCurrentTime();
+  const currentTime = requestCurrentTime();
   const expirationTime = computeExpirationForFiber(currentTime, finishedWork);
   const recoveryUpdate = createUpdate(expirationTime);
   enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);
@@ -145,7 +145,6 @@ function throwException(
   sourceFiber: Fiber,
   value: mixed,
   renderExpirationTime: ExpirationTime,
-  currentTimeMs: number,
 ) {
   // The source fiber did not complete.
   sourceFiber.effectTag |= Incomplete;
@@ -162,7 +161,9 @@ function throwException(
     const thenable: Thenable = (value: any);
 
     // TODO: Should use the earliest known expiration time
+    const currentTime = requestCurrentTime();
     const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
+    const currentTimeMs = expirationTimeToMs(currentTime);
     const startTimeMs = expirationTimeMs - 5000;
     let elapsedMs = currentTimeMs - startTimeMs;
     if (elapsedMs < 0) {

commit aa8266c4f7da62788156bf0bdd95fd729c04388a
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jul 3 19:22:41 2018 -0700

    Prepare placeholders before timing out (#13092)
    
    * Prepare placeholders before timing out
    
    While a tree is suspended, prepare for the timeout by pre-rendering the
    placeholder state.
    
    This simplifies the implementation a bit because every render now
    results in a completed tree.
    
    * Suspend inside an already timed out Placeholder
    
    A component should be able to suspend inside an already timed out
    placeholder. The time at which the placeholder committed is used as
    the start time for a subsequent suspend.
    
    So, if a placeholder times out after 3 seconds, and an inner
    placeholder has a threshold of 2 seconds, the inner placeholder will
    not time out until 5 seconds total have elapsed.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 8bc5efa876..0c355d62b2 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -39,11 +39,9 @@ import {createCapturedValue} from './ReactCapturedValue';
 import {
   enqueueCapturedUpdate,
   createUpdate,
-  enqueueUpdate,
   CaptureUpdate,
 } from './ReactUpdateQueue';
 import {logError} from './ReactFiberCommitWork';
-import {Never, Sync, expirationTimeToMs} from './ReactFiberExpirationTime';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {
   popContextProvider as popLegacyContextProvider,
@@ -55,23 +53,27 @@ import {
   recordElapsedActualRenderTime,
 } from './ReactProfilerTimer';
 import {
-  markTimeout,
-  markError,
+  renderDidSuspend,
+  renderDidError,
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
-  requestCurrentTime,
-  computeExpirationForFiber,
-  scheduleWork,
   retrySuspendedRoot,
 } from './ReactFiberScheduler';
-import {hasLowerPriorityWork} from './ReactFiberPendingPriority';
+
+import invariant from 'shared/invariant';
+import maxSigned31BitInt from './maxSigned31BitInt';
+import {
+  expirationTimeToMs,
+  LOW_PRIORITY_EXPIRATION,
+} from './ReactFiberExpirationTime';
+import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
 
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
   expirationTime: ExpirationTime,
-): Update<null> {
+): Update<mixed> {
   const update = createUpdate(expirationTime);
   // Unmount the root by rendering null.
   update.tag = CaptureUpdate;
@@ -129,16 +131,6 @@ function createClassErrorUpdate(
   return update;
 }
 
-function schedulePing(finishedWork) {
-  // Once the promise resolves, we should try rendering the non-
-  // placeholder state again.
-  const currentTime = requestCurrentTime();
-  const expirationTime = computeExpirationForFiber(currentTime, finishedWork);
-  const recoveryUpdate = createUpdate(expirationTime);
-  enqueueUpdate(finishedWork, recoveryUpdate, expirationTime);
-  scheduleWork(finishedWork, expirationTime);
-}
-
 function throwException(
   root: FiberRoot,
   returnFiber: Fiber,
@@ -160,113 +152,113 @@ function throwException(
     // This is a thenable.
     const thenable: Thenable = (value: any);
 
-    // TODO: Should use the earliest known expiration time
-    const currentTime = requestCurrentTime();
-    const expirationTimeMs = expirationTimeToMs(renderExpirationTime);
-    const currentTimeMs = expirationTimeToMs(currentTime);
-    const startTimeMs = expirationTimeMs - 5000;
-    let elapsedMs = currentTimeMs - startTimeMs;
-    if (elapsedMs < 0) {
-      elapsedMs = 0;
-    }
-    const remainingTimeMs = expirationTimeMs - currentTimeMs;
-
-    // Find the earliest timeout of all the timeouts in the ancestor path.
-    // TODO: Alternatively, we could store the earliest timeout on the context
-    // stack, rather than searching on every suspend.
+    // Find the earliest timeout of all the timeouts in the ancestor path. We
+    // could avoid this traversal by storing the timeouts on the stack, but we
+    // choose not to because we only hit this path if we're IO-bound (i.e. if
+    // something suspends). Whereas the stack is used even in the non-IO-
+    // bound case.
     let workInProgress = returnFiber;
     let earliestTimeoutMs = -1;
-    searchForEarliestTimeout: do {
+    let startTimeMs = -1;
+    do {
       if (workInProgress.tag === TimeoutComponent) {
         const current = workInProgress.alternate;
-        if (current !== null && current.memoizedState === true) {
-          // A parent Timeout already committed in a placeholder state. We
-          // need to handle this promise immediately. In other words, we
-          // should never suspend inside a tree that already expired.
-          earliestTimeoutMs = 0;
-          break searchForEarliestTimeout;
+        if (
+          current !== null &&
+          current.memoizedState === true &&
+          current.stateNode !== null
+        ) {
+          // Reached a placeholder that already timed out. Each timed out
+          // placeholder acts as the root of a new suspense boundary.
+
+          // Use the time at which the placeholder timed out as the start time
+          // for the current render.
+          const timedOutAt = current.stateNode.timedOutAt;
+          startTimeMs = expirationTimeToMs(timedOutAt);
+
+          // Do not search any further.
+          break;
         }
         let timeoutPropMs = workInProgress.pendingProps.ms;
         if (typeof timeoutPropMs === 'number') {
           if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
-            break searchForEarliestTimeout;
           } else if (
             earliestTimeoutMs === -1 ||
             timeoutPropMs < earliestTimeoutMs
           ) {
             earliestTimeoutMs = timeoutPropMs;
           }
-        } else if (earliestTimeoutMs === -1) {
-          earliestTimeoutMs = remainingTimeMs;
         }
       }
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
 
-    // Compute the remaining time until the timeout.
-    const msUntilTimeout = earliestTimeoutMs - elapsedMs;
-
-    if (renderExpirationTime === Never || msUntilTimeout > 0) {
-      // There's still time remaining.
-      markTimeout(root, thenable, msUntilTimeout, renderExpirationTime);
-      const onResolveOrReject = () => {
-        retrySuspendedRoot(root, renderExpirationTime);
-      };
-      thenable.then(onResolveOrReject, onResolveOrReject);
-      return;
+    let absoluteTimeoutMs;
+    if (earliestTimeoutMs === -1) {
+      // If no explicit threshold is given, default to an abitrarily large
+      // value. The actual size doesn't matter because the threshold for the
+      // whole tree will be clamped to the expiration time.
+      absoluteTimeoutMs = maxSigned31BitInt;
     } else {
-      // No time remaining. Need to fallback to placeholder.
-      // Find the nearest timeout that can be retried.
-      workInProgress = returnFiber;
-      do {
-        switch (workInProgress.tag) {
-          case HostRoot: {
-            // The root expired, but no fallback was provided. Throw a
-            // helpful error.
-            const message =
-              renderExpirationTime === Sync
-                ? 'A synchronous update was suspended, but no fallback UI ' +
-                  'was provided.'
-                : 'An update was suspended for longer than the timeout, ' +
-                  'but no fallback UI was provided.';
-            value = new Error(message);
-            break;
-          }
-          case TimeoutComponent: {
-            if ((workInProgress.effectTag & DidCapture) === NoEffect) {
-              workInProgress.effectTag |= ShouldCapture;
-              const onResolveOrReject = schedulePing.bind(null, workInProgress);
-              thenable.then(onResolveOrReject, onResolveOrReject);
-              return;
-            }
-            // Already captured during this render. Continue to the next
-            // Timeout ancestor.
-            break;
-          }
-        }
-        workInProgress = workInProgress.return;
-      } while (workInProgress !== null);
-    }
-  } else {
-    // This is an error.
-    markError(root);
-    if (
-      // Retry (at the same priority) one more time before handling the error.
-      // The retry will flush synchronously. (Unless we're already rendering
-      // synchronously, in which case move to the next check.)
-      (!root.didError && renderExpirationTime !== Sync) ||
-      // There's lower priority work. If so, it may have the effect of fixing
-      // the exception that was just thrown.
-      hasLowerPriorityWork(root, renderExpirationTime)
-    ) {
-      return;
+      if (startTimeMs === -1) {
+        // This suspend happened outside of any already timed-out
+        // placeholders. We don't know exactly when the update was scheduled,
+        // but we can infer an approximate start time from the expiration
+        // time. First, find the earliest uncommitted expiration time in the
+        // tree, including work that is suspended. Then subtract the offset
+        // used to compute an async update's expiration time. This will cause
+        // high priority (interactive) work to expire earlier than neccessary,
+        // but we can account for this by adjusting for the Just Noticable
+        // Difference.
+        const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+          root,
+          renderExpirationTime,
+        );
+        const earliestExpirationTimeMs = expirationTimeToMs(
+          earliestExpirationTime,
+        );
+        startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
+      }
+      absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
     }
+
+    // Mark the earliest timeout in the suspended fiber's ancestor path. After
+    // completing the root, we'll take the largest of all the suspended
+    // fiber's timeouts and use it to compute a timeout for the whole tree.
+    renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
+
+    // Schedule the nearest Timeout to re-render using a placeholder.
+    workInProgress = returnFiber;
+    do {
+      if (workInProgress.tag === TimeoutComponent) {
+        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
+          workInProgress.effectTag |= ShouldCapture;
+          // Attach a listener to the promise to "ping" the root and retry.
+          const onResolveOrReject = retrySuspendedRoot.bind(
+            null,
+            root,
+            workInProgress,
+            renderExpirationTime,
+          );
+          thenable.then(onResolveOrReject, onResolveOrReject);
+          return;
+        }
+        // Already captured during this render. Continue to the next
+        // Timeout ancestor.
+      }
+      workInProgress = workInProgress.return;
+    } while (workInProgress !== null);
+    // No Timeout was found. Fallthrough to error mode.
+    value = new Error(
+      'An update was suspended, but no placeholder UI was provided.',
+    );
   }
 
   // We didn't find a boundary that could handle this type of exception. Start
   // over and traverse parent path again, this time treating the exception
   // as an error.
+  renderDidError(root);
   value = createCapturedValue(value, sourceFiber);
   let workInProgress = returnFiber;
   do {
@@ -337,11 +329,13 @@ function unwindWork(
       popHostContainer(workInProgress);
       popTopLevelLegacyContextObject(workInProgress);
       const effectTag = workInProgress.effectTag;
-      if (effectTag & ShouldCapture) {
-        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-        return workInProgress;
-      }
-      return null;
+      invariant(
+        (effectTag & DidCapture) === NoEffect,
+        'The root failed to unmount after an error. This is likely a bug in ' +
+          'React. Please file an issue.',
+      );
+      workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+      return workInProgress;
     }
     case HostComponent: {
       popHostContext(workInProgress);

commit f128fdea4840f494991054f608b99757a5ce5764
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jul 3 19:44:19 2018 -0700

    Suspending outside of strict trees and async trees (#13098)
    
    We can support components that suspend outside of an async mode tree
    by immediately committing their placeholders.
    
    In strict mode, the Timeout acts effectively like an error boundary.
    Within a single render pass, we unwind to the nearest Timeout and
    re-render the placeholder view.
    
    Outside of strict mode, it's not safe to unwind and re-render the
    siblings without committing. (Technically, this is true of error
    boundaries, too, though probably not a huge deal, since we don't support
    using error boundaries for control flow (yet, at least)). We need to be
    clever. What we do is pretend the suspended component rendered null.*
    There's no unwinding. The siblings commit like normal.
    
    Then, in the commit phase, schedule an update on the Timeout to
    synchronously re-render the placeholder. Although this requires an extra
    commit, it will not be observable. And because the siblings were not
    blocked from committing, they don't have to be strict mode compatible.
    
    Another caveat is that if a component suspends during an async render,
    but it's captured by a non-async Timeout, we need to revert to sync
    mode. In other words, if any non-async component renders, the entire
    tree must complete and commit without yielding.
    
    * The downside of rendering null is that the existing children will be
    deleted. We should hide them instead. I'll work on this in a follow-up.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 0c355d62b2..63f6b02dfa 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -15,6 +15,8 @@ import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
 
 import {
+  IndeterminateComponent,
+  FunctionalComponent,
   ClassComponent,
   HostRoot,
   HostComponent,
@@ -27,13 +29,14 @@ import {
   Incomplete,
   NoEffect,
   ShouldCapture,
+  Update as UpdateEffect,
 } from 'shared/ReactTypeOfSideEffect';
 import {
   enableGetDerivedStateFromCatch,
   enableProfilerTimer,
   enableSuspense,
 } from 'shared/ReactFeatureFlags';
-import {ProfileMode} from './ReactTypeOfMode';
+import {ProfileMode, StrictMode, AsyncMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -60,6 +63,7 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   retrySuspendedRoot,
 } from './ReactFiberScheduler';
+import {Sync} from './ReactFiberExpirationTime';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';
@@ -68,6 +72,7 @@ import {
   LOW_PRIORITY_EXPIRATION,
 } from './ReactFiberExpirationTime';
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
+import {reconcileChildrenAtExpirationTime} from './ReactFiberBeginWork';
 
 function createRootErrorUpdate(
   fiber: Fiber,
@@ -194,54 +199,98 @@ function throwException(
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
 
-    let absoluteTimeoutMs;
-    if (earliestTimeoutMs === -1) {
-      // If no explicit threshold is given, default to an abitrarily large
-      // value. The actual size doesn't matter because the threshold for the
-      // whole tree will be clamped to the expiration time.
-      absoluteTimeoutMs = maxSigned31BitInt;
-    } else {
-      if (startTimeMs === -1) {
-        // This suspend happened outside of any already timed-out
-        // placeholders. We don't know exactly when the update was scheduled,
-        // but we can infer an approximate start time from the expiration
-        // time. First, find the earliest uncommitted expiration time in the
-        // tree, including work that is suspended. Then subtract the offset
-        // used to compute an async update's expiration time. This will cause
-        // high priority (interactive) work to expire earlier than neccessary,
-        // but we can account for this by adjusting for the Just Noticable
-        // Difference.
-        const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
-          root,
-          renderExpirationTime,
-        );
-        const earliestExpirationTimeMs = expirationTimeToMs(
-          earliestExpirationTime,
-        );
-        startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-      }
-      absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
-    }
-
-    // Mark the earliest timeout in the suspended fiber's ancestor path. After
-    // completing the root, we'll take the largest of all the suspended
-    // fiber's timeouts and use it to compute a timeout for the whole tree.
-    renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
-
     // Schedule the nearest Timeout to re-render using a placeholder.
     workInProgress = returnFiber;
     do {
       if (workInProgress.tag === TimeoutComponent) {
-        if ((workInProgress.effectTag & DidCapture) === NoEffect) {
-          workInProgress.effectTag |= ShouldCapture;
+        const didTimeout = workInProgress.memoizedState;
+        if (!didTimeout) {
+          // Found the nearest Timeout.
+
+          // If the Timeout is not in async mode, we should not suspend, and
+          // likewise, when the promise resolves, we should ping synchronously.
+          const pingTime =
+            (workInProgress.mode & AsyncMode) === NoEffect
+              ? Sync
+              : renderExpirationTime;
+
           // Attach a listener to the promise to "ping" the root and retry.
           const onResolveOrReject = retrySuspendedRoot.bind(
             null,
             root,
             workInProgress,
-            renderExpirationTime,
+            pingTime,
           );
           thenable.then(onResolveOrReject, onResolveOrReject);
+
+          // If the Timeout component is outside of strict mode, we should *not*
+          // suspend the commit. Pretend as if the suspended component rendered
+          // null and keep rendering. In the commit phase, we'll schedule a
+          // subsequent synchronous update to re-render the Timeout.
+          //
+          // Note: It doesn't matter whether the component that suspended was
+          // inside a strict mode tree. If the Timeout is outside of it, we
+          // should *not* suspend the commit.
+          if ((workInProgress.mode & StrictMode) === NoEffect) {
+            workInProgress.effectTag |= UpdateEffect;
+
+            // Unmount the source fiber's children
+            const nextChildren = null;
+            reconcileChildrenAtExpirationTime(
+              sourceFiber.alternate,
+              sourceFiber,
+              nextChildren,
+              renderExpirationTime,
+            );
+            sourceFiber.effectTag &= ~Incomplete;
+            if (sourceFiber.tag === IndeterminateComponent) {
+              // Let's just assume it's a functional component. This fiber will
+              // be unmounted in the immediate next commit, anyway.
+              sourceFiber.tag = FunctionalComponent;
+            }
+
+            // Exit without suspending.
+            return;
+          }
+
+          // Confirmed that the Timeout is in a strict mode tree. Continue with
+          // the normal suspend path.
+
+          let absoluteTimeoutMs;
+          if (earliestTimeoutMs === -1) {
+            // If no explicit threshold is given, default to an abitrarily large
+            // value. The actual size doesn't matter because the threshold for the
+            // whole tree will be clamped to the expiration time.
+            absoluteTimeoutMs = maxSigned31BitInt;
+          } else {
+            if (startTimeMs === -1) {
+              // This suspend happened outside of any already timed-out
+              // placeholders. We don't know exactly when the update was scheduled,
+              // but we can infer an approximate start time from the expiration
+              // time. First, find the earliest uncommitted expiration time in the
+              // tree, including work that is suspended. Then subtract the offset
+              // used to compute an async update's expiration time. This will cause
+              // high priority (interactive) work to expire earlier than neccessary,
+              // but we can account for this by adjusting for the Just Noticable
+              // Difference.
+              const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+                root,
+                renderExpirationTime,
+              );
+              const earliestExpirationTimeMs = expirationTimeToMs(
+                earliestExpirationTime,
+              );
+              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
+            }
+            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+          }
+
+          // Mark the earliest timeout in the suspended fiber's ancestor path. After
+          // completing the root, we'll take the largest of all the suspended
+          // fiber's timeouts and use it to compute a timeout for the whole tree.
+          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
+
+          workInProgress.effectTag |= ShouldCapture;
           return;
         }
         // Already captured during this render. Continue to the next
@@ -258,7 +307,7 @@ function throwException(
   // We didn't find a boundary that could handle this type of exception. Start
   // over and traverse parent path again, this time treating the exception
   // as an error.
-  renderDidError(root);
+  renderDidError();
   value = createCapturedValue(value, sourceFiber);
   let workInProgress = returnFiber;
   do {

commit 88d7ed8bfbccd860c3e309da39d356d0a3127aa7
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jul 3 19:47:00 2018 -0700

    React.Timeout -> React.Placeholder (#13105)
    
    Changed the API to match what we've been using in our latest discussions.
    
    Our tentative plans are for <Placeholder> to automatically hide the timed-out
    children, instead of removing them, so their state is not lost. This part is
    not yet implemented. We'll likely have a lower level API that does not include
    the hiding behavior. This is also not yet implemented.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 63f6b02dfa..22f3cd1310 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -22,7 +22,7 @@ import {
   HostComponent,
   HostPortal,
   ContextProvider,
-  TimeoutComponent,
+  PlaceholderComponent,
 } from 'shared/ReactTypeOfWork';
 import {
   DidCapture,
@@ -157,16 +157,16 @@ function throwException(
     // This is a thenable.
     const thenable: Thenable = (value: any);
 
-    // Find the earliest timeout of all the timeouts in the ancestor path. We
-    // could avoid this traversal by storing the timeouts on the stack, but we
-    // choose not to because we only hit this path if we're IO-bound (i.e. if
-    // something suspends). Whereas the stack is used even in the non-IO-
-    // bound case.
+    // Find the earliest timeout threshold of all the placeholders in the
+    // ancestor path. We could avoid this traversal by storing the thresholds on
+    // the stack, but we choose not to because we only hit this path if we're
+    // IO-bound (i.e. if something suspends). Whereas the stack is used even in
+    // the non-IO- bound case.
     let workInProgress = returnFiber;
     let earliestTimeoutMs = -1;
     let startTimeMs = -1;
     do {
-      if (workInProgress.tag === TimeoutComponent) {
+      if (workInProgress.tag === PlaceholderComponent) {
         const current = workInProgress.alternate;
         if (
           current !== null &&
@@ -184,7 +184,7 @@ function throwException(
           // Do not search any further.
           break;
         }
-        let timeoutPropMs = workInProgress.pendingProps.ms;
+        let timeoutPropMs = workInProgress.pendingProps.delayMs;
         if (typeof timeoutPropMs === 'number') {
           if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
@@ -199,15 +199,15 @@ function throwException(
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
 
-    // Schedule the nearest Timeout to re-render using a placeholder.
+    // Schedule the nearest Placeholder to re-render the timed out view.
     workInProgress = returnFiber;
     do {
-      if (workInProgress.tag === TimeoutComponent) {
+      if (workInProgress.tag === PlaceholderComponent) {
         const didTimeout = workInProgress.memoizedState;
         if (!didTimeout) {
-          // Found the nearest Timeout.
+          // Found the nearest boundary.
 
-          // If the Timeout is not in async mode, we should not suspend, and
+          // If the boundary is not in async mode, we should not suspend, and
           // likewise, when the promise resolves, we should ping synchronously.
           const pingTime =
             (workInProgress.mode & AsyncMode) === NoEffect
@@ -223,13 +223,13 @@ function throwException(
           );
           thenable.then(onResolveOrReject, onResolveOrReject);
 
-          // If the Timeout component is outside of strict mode, we should *not*
-          // suspend the commit. Pretend as if the suspended component rendered
-          // null and keep rendering. In the commit phase, we'll schedule a
-          // subsequent synchronous update to re-render the Timeout.
+          // If the boundary is outside of strict mode, we should *not* suspend
+          // the commit. Pretend as if the suspended component rendered null and
+          // keep rendering. In the commit phase, we'll schedule a subsequent
+          // synchronous update to re-render the Placeholder.
           //
           // Note: It doesn't matter whether the component that suspended was
-          // inside a strict mode tree. If the Timeout is outside of it, we
+          // inside a strict mode tree. If the Placeholder is outside of it, we
           // should *not* suspend the commit.
           if ((workInProgress.mode & StrictMode) === NoEffect) {
             workInProgress.effectTag |= UpdateEffect;
@@ -253,7 +253,7 @@ function throwException(
             return;
           }
 
-          // Confirmed that the Timeout is in a strict mode tree. Continue with
+          // Confirmed that the bounary is in a strict mode tree. Continue with
           // the normal suspend path.
 
           let absoluteTimeoutMs;
@@ -285,20 +285,21 @@ function throwException(
             absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
           }
 
-          // Mark the earliest timeout in the suspended fiber's ancestor path. After
-          // completing the root, we'll take the largest of all the suspended
-          // fiber's timeouts and use it to compute a timeout for the whole tree.
+          // Mark the earliest timeout in the suspended fiber's ancestor path.
+          // After completing the root, we'll take the largest of all the
+          // suspended fiber's timeouts and use it to compute a timeout for the
+          // whole tree.
           renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
           workInProgress.effectTag |= ShouldCapture;
           return;
         }
-        // Already captured during this render. Continue to the next
-        // Timeout ancestor.
+        // This boundary already captured during this render. Continue to the
+        // next boundary.
       }
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
-    // No Timeout was found. Fallthrough to error mode.
+    // No boundary was found. Fallthrough to error mode.
     value = new Error(
       'An update was suspended, but no placeholder UI was provided.',
     );
@@ -390,7 +391,7 @@ function unwindWork(
       popHostContext(workInProgress);
       return null;
     }
-    case TimeoutComponent: {
+    case PlaceholderComponent: {
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;

commit 9faf389e79c647d7792e631f3d8e9a9ce1a70625
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Thu Jul 5 11:38:06 2018 -0700

    Reset profiler timer correctly after errors (#13123)
    
    * Reset ReactProfilerTimer's DEV-only Fiber stack after an error
    
    * Added ReactNoop functionality to error during "complete" phase
    
    * Added failing profiler stack unwinding test
    
    * Potential fix for unwinding time bug
    
    * Renamed test
    
    * Don't record time until complete phase succeeds. Simplifies unwinding.
    
    * Expanded ReactProfilerDevToolsIntegration-test coverage a bit
    
    * Added unstable_flushWithoutCommitting method to noop renderer
    
    * Added failing multi-root/batch test to ReactProfiler-test
    
    * Beefed up tests a bit and added some TODOs
    
    * Profiler timer differentiates between batched commits and in-progress async work
    
    This was a two-part change:
    1) Don't count time spent working on a batched commit against yielded async work.
    2) Don't assert an empty stack after processing a batched commit (because there may be yielded async work)
    
    This is kind of a hacky solution, and may have problems that I haven't thought of yet. I need to commit this so I can mentally clock out for a bit without worrying about it. I will think about it more when I'm back from PTO. In the meanwhile, input is welcome.
    
    * Removed TODO
    
    * Replaced FiberRoot map with boolean
    
    * Removed unnecessary whitespace edit

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 22f3cd1310..192d083c17 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -51,10 +51,7 @@ import {
   popTopLevelContextObject as popTopLevelLegacyContextObject,
 } from './ReactFiberContext';
 import {popProvider} from './ReactFiberNewContext';
-import {
-  resumeActualRenderTimerIfPaused,
-  recordElapsedActualRenderTime,
-} from './ReactProfilerTimer';
+import {recordElapsedActualRenderTime} from './ReactProfilerTimer';
 import {
   renderDidSuspend,
   renderDidError,
@@ -413,8 +410,6 @@ function unwindWork(
 function unwindInterruptedWork(interruptedWork: Fiber) {
   if (enableProfilerTimer) {
     if (interruptedWork.mode & ProfileMode) {
-      // Resume in case we're picking up on work that was paused.
-      resumeActualRenderTimerIfPaused();
       recordElapsedActualRenderTime(interruptedWork);
     }
   }

commit 43ffae2d1750ee32409e140e41ea562ff46d2516
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Jul 13 11:24:03 2018 -0700

    Suspending inside a constructor outside of strict mode (#13200)
    
    * Suspending inside a constructor outside of strict mode
    
    Outside of strict mode, suspended components commit in an incomplete
    state, then are synchronously deleted in a subsequent commit. If a
    component suspends inside the constructor, it mounts without
    an instance.
    
    This breaks at least one invariant: during deletion, we assume that
    every mounted component has an instance, and check the instance for
    the existence of `componentWillUnmount`.
    
    Rather than add a redundant check to the deletion of every class
    component, components that suspend inside their constructor and outside
    of strict mode are turned into empty functional components before they
    are mounted. This is a bit weird, but it's an edge case, and the empty
    component will be synchronously unmounted regardless.
    
    * Do not fire lifecycles of a suspended component
    
    In non-strict mode, suspended components commit, but their lifecycles
    should not fire.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 192d083c17..432c30d442 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -30,6 +30,7 @@ import {
   NoEffect,
   ShouldCapture,
   Update as UpdateEffect,
+  LifecycleEffectMask,
 } from 'shared/ReactTypeOfSideEffect';
 import {
   enableGetDerivedStateFromCatch,
@@ -71,6 +72,10 @@ import {
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
 import {reconcileChildrenAtExpirationTime} from './ReactFiberBeginWork';
 
+function NoopComponent() {
+  return null;
+}
+
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
@@ -246,6 +251,22 @@ function throwException(
               sourceFiber.tag = FunctionalComponent;
             }
 
+            if (sourceFiber.tag === ClassComponent) {
+              // We're going to commit this fiber even though it didn't
+              // complete. But we shouldn't call any lifecycle methods or
+              // callbacks. Remove all lifecycle effect tags.
+              sourceFiber.effectTag &= ~LifecycleEffectMask;
+              if (sourceFiber.alternate === null) {
+                // We're about to mount a class component that doesn't have an
+                // instance. Turn this into a dummy functional component instead,
+                // to prevent type errors. This is a bit weird but it's an edge
+                // case and we're about to synchronously delete this
+                // component, anyway.
+                sourceFiber.tag = FunctionalComponent;
+                sourceFiber.type = NoopComponent;
+              }
+            }
+
             // Exit without suspending.
             return;
           }

commit 606c30aa5f37f335f14ff94659ffcadfbdf4c791
Author: Fumiya Shibusawa <shibusawa@basicinc.jp>
Date:   Wed Jul 18 04:21:53 2018 +0900

    fixed a typo in commentout in ReactFiberUnwindWork.js (#13172)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 432c30d442..f60e314793 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -271,7 +271,7 @@ function throwException(
             return;
           }
 
-          // Confirmed that the bounary is in a strict mode tree. Continue with
+          // Confirmed that the boundary is in a strict mode tree. Continue with
           // the normal suspend path.
 
           let absoluteTimeoutMs;

commit 2b509e2c8c8c1fbc33ae59ce7c7dca0107732ff4
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Jul 20 16:49:06 2018 -0700

    [Experimental] API for reading context from within any render phase function (#13139)
    
    * Store list of contexts on the fiber
    
    Currently, context can only be read by a special type of component,
    ContextConsumer. We want to add support to all fibers, including
    classes and functional components.
    
    Each fiber may read from one or more contexts. To enable quick, mono-
    morphic access of this list, we'll store them on a fiber property.
    
    * Context.unstable_read
    
    unstable_read can be called anywhere within the render phase. That
    includes the render method, getDerivedStateFromProps, constructors,
    functional components, and context consumer render props.
    
    If it's called outside the render phase, an error is thrown.
    
    * Remove vestigial context cursor
    
    Wasn't being used.
    
    * Split fiber.expirationTime into two separate fields
    
    Currently, the `expirationTime` field represents the pending work of
    both the fiber itself ‚Äî including new props, state, and context ‚Äî and of
    any updates in that fiber's subtree.
    
    This commit adds a second field called `childExpirationTime`. Now
    `expirationTime` only represents the pending work of the fiber itself.
    The subtree's pending work is represented by `childExpirationTime`.
    
    The biggest advantage is it requires fewer checks to bailout on already
    finished work. For most types of work, if the `expirationTime` does not
    match the render expiration time, we can bailout immediately without
    any further checks. This won't work for fibers that have
    `shouldComponentUpdate` semantics (class components), for which we still
    need to check for props and state changes explicitly.
    
    * Performance nits
    
    Optimize `readContext` for most common case

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index f60e314793..489c669473 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -70,7 +70,7 @@ import {
   LOW_PRIORITY_EXPIRATION,
 } from './ReactFiberExpirationTime';
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
-import {reconcileChildrenAtExpirationTime} from './ReactFiberBeginWork';
+import {reconcileChildren} from './ReactFiberBeginWork';
 
 function NoopComponent() {
   return null;
@@ -238,7 +238,7 @@ function throwException(
 
             // Unmount the source fiber's children
             const nextChildren = null;
-            reconcileChildrenAtExpirationTime(
+            reconcileChildren(
               sourceFiber.alternate,
               sourceFiber,
               nextChildren,
@@ -310,6 +310,7 @@ function throwException(
           renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
           workInProgress.effectTag |= ShouldCapture;
+          workInProgress.expirationTime = renderExpirationTime;
           return;
         }
         // This boundary already captured during this render. Continue to the
@@ -334,12 +335,13 @@ function throwException(
       case HostRoot: {
         const errorInfo = value;
         workInProgress.effectTag |= ShouldCapture;
+        workInProgress.expirationTime = renderExpirationTime;
         const update = createRootErrorUpdate(
           workInProgress,
           errorInfo,
           renderExpirationTime,
         );
-        enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
+        enqueueCapturedUpdate(workInProgress, update);
         return;
       }
       case ClassComponent:
@@ -356,13 +358,14 @@ function throwException(
               !isAlreadyFailedLegacyErrorBoundary(instance)))
         ) {
           workInProgress.effectTag |= ShouldCapture;
+          workInProgress.expirationTime = renderExpirationTime;
           // Schedule the error boundary to re-render using updated state
           const update = createClassErrorUpdate(
             workInProgress,
             errorInfo,
             renderExpirationTime,
           );
-          enqueueCapturedUpdate(workInProgress, update, renderExpirationTime);
+          enqueueCapturedUpdate(workInProgress, update);
           return;
         }
         break;

commit 067cc24f55ef01a233be9e7564b337e35fed72ea
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Aug 8 09:42:53 2018 -0700

    Profiler actualDuration bugfix (#13313)
    
    * Simplified profiler actualDuration timing
    
    While testing the new DevTools profiler, I noticed that sometimes‚Äì in larger, more complicated applications‚Äì the actualDuration value was incorrect (either too large, or sometimes negative). I was not able to reproduce this in a smaller application or test (which sucks) but I assume it has something to do with the way I was tracking render times across priorities/roots. So this PR replaces the previous approach with a simpler one.
    
    * Changed bubbling logic after chatting out of band with Andrew
    
    * Replaced __PROFILE__ with feature-flag conditionals in test
    
    * Updated test comment

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 489c669473..35042016f3 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -34,10 +34,9 @@ import {
 } from 'shared/ReactTypeOfSideEffect';
 import {
   enableGetDerivedStateFromCatch,
-  enableProfilerTimer,
   enableSuspense,
 } from 'shared/ReactFeatureFlags';
-import {ProfileMode, StrictMode, AsyncMode} from './ReactTypeOfMode';
+import {StrictMode, AsyncMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -52,7 +51,6 @@ import {
   popTopLevelContextObject as popTopLevelLegacyContextObject,
 } from './ReactFiberContext';
 import {popProvider} from './ReactFiberNewContext';
-import {recordElapsedActualRenderTime} from './ReactProfilerTimer';
 import {
   renderDidSuspend,
   renderDidError,
@@ -380,12 +378,6 @@ function unwindWork(
   workInProgress: Fiber,
   renderExpirationTime: ExpirationTime,
 ) {
-  if (enableProfilerTimer) {
-    if (workInProgress.mode & ProfileMode) {
-      recordElapsedActualRenderTime(workInProgress);
-    }
-  }
-
   switch (workInProgress.tag) {
     case ClassComponent: {
       popLegacyContextProvider(workInProgress);
@@ -432,12 +424,6 @@ function unwindWork(
 }
 
 function unwindInterruptedWork(interruptedWork: Fiber) {
-  if (enableProfilerTimer) {
-    if (interruptedWork.mode & ProfileMode) {
-      recordElapsedActualRenderTime(interruptedWork);
-    }
-  }
-
   switch (interruptedWork.tag) {
     case ClassComponent: {
       popLegacyContextProvider(interruptedWork);

commit e0204084a03e04103864ab36df9456c99bd4ae1b
Author: Kazuhiro Sera <seratch@gmail.com>
Date:   Fri Aug 10 22:06:08 2018 +0900

    Fix typos detected by github.com/client9/misspell (#13349)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 35042016f3..1fd1d4fe0e 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -286,8 +286,8 @@ function throwException(
               // time. First, find the earliest uncommitted expiration time in the
               // tree, including work that is suspended. Then subtract the offset
               // used to compute an async update's expiration time. This will cause
-              // high priority (interactive) work to expire earlier than neccessary,
-              // but we can account for this by adjusting for the Just Noticable
+              // high priority (interactive) work to expire earlier than necessary,
+              // but we can account for this by adjusting for the Just Noticeable
               // Difference.
               const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
                 root,

commit 5031ebf6beddf88cac15f4d2c9e91f8dbb91d59d
Author: Andrew Clark <acdlite@me.com>
Date:   Thu Aug 16 09:21:59 2018 -0700

    Accept promise as element type (#13397)
    
    * Accept promise as element type
    
    On the initial render, the element will suspend as if a promise were
    thrown from inside the body of the unresolved component. Siblings should
    continue rendering and if the parent is a Placeholder, the promise
    should be captured by that Placeholder.
    
    When the promise resolves, rendering resumes. If the resolved value
    has a `default` property, it is assumed to be the default export of
    an ES module, and we use that as the component type. If it does not have
    a `default` property, we use the resolved value itself.
    
    The resolved value is stored as an expando on the promise/thenable.
    
    * Use special types of work for lazy components
    
    Because reconciliation is a hot path, this adds ClassComponentLazy,
    FunctionalComponentLazy, and ForwardRefLazy as special types of work.
    The other types are not supported, but wouldn't be placed into a
    separate module regardless.
    
    * Resolve defaultProps for lazy types
    
    * Remove some calls to isContextProvider
    
    isContextProvider checks the fiber tag, but it's typically called after
    we've already refined the type of work. We should get rid of it. I
    removed some of them in the previous commit, and deleted a few more
    in this one. I left a few behind because the remaining ones would
    require additional refactoring that feels outside the scope of this PR.
    
    * Remove getLazyComponentTypeIfResolved
    
    * Return baseProps instead of null
    
    The caller compares the result to baseProps to see if anything changed.
    
    * Avoid redundant checks by inlining getFiberTagFromObjectType
    
    * Move tag resolution to ReactFiber module
    
    * Pass next props to update* functions
    
    We should do this with all types of work in the future.
    
    * Refine component type before pushing/popping context
    
    Removes unnecessary checks.
    
    * Replace all occurrences of _reactResult with helper
    
    * Move shared thenable logic to `shared` package
    
    * Check type of wrapper object before resolving to `default` export
    
    * Return resolved tag instead of reassigning

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 1fd1d4fe0e..a6da20450f 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -18,6 +18,7 @@ import {
   IndeterminateComponent,
   FunctionalComponent,
   ClassComponent,
+  ClassComponentLazy,
   HostRoot,
   HostComponent,
   HostPortal,
@@ -47,7 +48,8 @@ import {
 import {logError} from './ReactFiberCommitWork';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {
-  popContextProvider as popLegacyContextProvider,
+  isContextProvider as isLegacyContextProvider,
+  popContext as popLegacyContext,
   popTopLevelContextObject as popTopLevelLegacyContextObject,
 } from './ReactFiberContext';
 import {popProvider} from './ReactFiberNewContext';
@@ -249,7 +251,10 @@ function throwException(
               sourceFiber.tag = FunctionalComponent;
             }
 
-            if (sourceFiber.tag === ClassComponent) {
+            if (
+              sourceFiber.tag === ClassComponent ||
+              sourceFiber.tag === ClassComponentLazy
+            ) {
               // We're going to commit this fiber even though it didn't
               // complete. But we shouldn't call any lifecycle methods or
               // callbacks. Remove all lifecycle effect tags.
@@ -343,6 +348,7 @@ function throwException(
         return;
       }
       case ClassComponent:
+      case ClassComponentLazy:
         // Capture and retry
         const errorInfo = value;
         const ctor = workInProgress.type;
@@ -380,7 +386,22 @@ function unwindWork(
 ) {
   switch (workInProgress.tag) {
     case ClassComponent: {
-      popLegacyContextProvider(workInProgress);
+      const Component = workInProgress.type;
+      if (isLegacyContextProvider(Component)) {
+        popLegacyContext(workInProgress);
+      }
+      const effectTag = workInProgress.effectTag;
+      if (effectTag & ShouldCapture) {
+        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+        return workInProgress;
+      }
+      return null;
+    }
+    case ClassComponentLazy: {
+      const Component = workInProgress.type._reactResult;
+      if (isLegacyContextProvider(Component)) {
+        popLegacyContext(workInProgress);
+      }
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
@@ -426,7 +447,18 @@ function unwindWork(
 function unwindInterruptedWork(interruptedWork: Fiber) {
   switch (interruptedWork.tag) {
     case ClassComponent: {
-      popLegacyContextProvider(interruptedWork);
+      const childContextTypes = interruptedWork.type.childContextTypes;
+      if (childContextTypes !== null && childContextTypes !== undefined) {
+        popLegacyContext(interruptedWork);
+      }
+      break;
+    }
+    case ClassComponentLazy: {
+      const childContextTypes =
+        interruptedWork.type._reactResult.childContextTypes;
+      if (childContextTypes !== null && childContextTypes !== undefined) {
+        popLegacyContext(interruptedWork);
+      }
       break;
     }
     case HostRoot: {

commit 340bfd9393e8173adca5380e6587e1ea1a23cefa
Author: Sophie Alpert <git@sophiebits.com>
Date:   Sun Aug 26 13:40:27 2018 -0700

    Rename ReactTypeOfWork to ReactWorkTags, ReactTypeOfSideEffect to ReactSideEffectTags (#13476)
    
    * Rename ReactTypeOfWork to ReactWorkTags
    
    And `type TypeOfWork` to `type WorkTag`.
    
    * Rename ReactTypeOfSideEffect too

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index a6da20450f..6cafb680dc 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -24,7 +24,7 @@ import {
   HostPortal,
   ContextProvider,
   PlaceholderComponent,
-} from 'shared/ReactTypeOfWork';
+} from 'shared/ReactWorkTags';
 import {
   DidCapture,
   Incomplete,
@@ -32,7 +32,7 @@ import {
   ShouldCapture,
   Update as UpdateEffect,
   LifecycleEffectMask,
-} from 'shared/ReactTypeOfSideEffect';
+} from 'shared/ReactSideEffectTags';
 import {
   enableGetDerivedStateFromCatch,
   enableSuspense,

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: H√©ctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 6cafb680dc..35885c8dd0 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 13965b4d3016de0ed28e73a38e60c18259bc2c23
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Tue Sep 25 09:27:41 2018 -0700

    Interaction tracking ref-counting bug fixes (WIP) (#13590)
    
    * Added new (failing) suspense+interaction tests
    * Add new tracing+suspense test harness fixture
    * Refactored interaction tracing to fix ref counting bug

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 35885c8dd0..546af6c0e2 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -36,6 +36,7 @@ import {
 import {
   enableGetDerivedStateFromCatch,
   enableSuspense,
+  enableSchedulerTracing,
 } from 'shared/ReactFeatureFlags';
 import {StrictMode, AsyncMode} from './ReactTypeOfMode';
 
@@ -60,6 +61,7 @@ import {
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
   retrySuspendedRoot,
+  captureWillSyncRenderPlaceholder,
 } from './ReactFiberScheduler';
 import {Sync} from './ReactFiberExpirationTime';
 
@@ -236,6 +238,13 @@ function throwException(
           if ((workInProgress.mode & StrictMode) === NoEffect) {
             workInProgress.effectTag |= UpdateEffect;
 
+            if (enableSchedulerTracing) {
+              // Handles the special case of unwinding a suspended sync render.
+              // We flag this to properly trace and count interactions.
+              // Otherwise interaction pending count will be decremented too many times.
+              captureWillSyncRenderPlaceholder();
+            }
+
             // Unmount the source fiber's children
             const nextChildren = null;
             reconcileChildren(

commit 0dc0ddc1ef5f90fe48b58f1a1ba753757961fc74
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Wed Sep 26 17:13:02 2018 +0100

    Rename AsyncMode -> ConcurrentMode (#13732)
    
    * Rename AsyncMode -> ConcurrentMode

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 546af6c0e2..bfd7714966 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -38,7 +38,7 @@ import {
   enableSuspense,
   enableSchedulerTracing,
 } from 'shared/ReactFeatureFlags';
-import {StrictMode, AsyncMode} from './ReactTypeOfMode';
+import {StrictMode, ConcurrentMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -211,10 +211,10 @@ function throwException(
         if (!didTimeout) {
           // Found the nearest boundary.
 
-          // If the boundary is not in async mode, we should not suspend, and
+          // If the boundary is not in concurrent mode, we should not suspend, and
           // likewise, when the promise resolves, we should ping synchronously.
           const pingTime =
-            (workInProgress.mode & AsyncMode) === NoEffect
+            (workInProgress.mode & ConcurrentMode) === NoEffect
               ? Sync
               : renderExpirationTime;
 

commit 806eebdaeec5a5b0e4e5df799bd98eb5f288bba5
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Fri Sep 28 13:05:01 2018 -0700

    Enable getDerivedStateFromError (#13746)
    
    * Removed the enableGetDerivedStateFromCatch feature flag (aka permanently enabled the feature)
    * Forked/copied ReactErrorBoundaries to ReactLegacyErrorBoundaries for testing componentDidCatch
    * Updated error boundaries tests to apply to getDerivedStateFromCatch
    * Renamed getDerivedStateFromCatch -> getDerivedStateFromError
    * Warn if boundary with only componentDidCatch swallows error
    * Fixed a subtle reconciliation bug with render phase error boundary

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index bfd7714966..bba16ed0b6 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -14,6 +14,8 @@ import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
 
+import getComponentName from 'shared/getComponentName';
+import warningWithoutStack from 'shared/warningWithoutStack';
 import {
   IndeterminateComponent,
   FunctionalComponent,
@@ -33,11 +35,7 @@ import {
   Update as UpdateEffect,
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
-import {
-  enableGetDerivedStateFromCatch,
-  enableSuspense,
-  enableSchedulerTracing,
-} from 'shared/ReactFeatureFlags';
+import {enableSuspense, enableSchedulerTracing} from 'shared/ReactFeatureFlags';
 import {StrictMode, ConcurrentMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
@@ -104,28 +102,22 @@ function createClassErrorUpdate(
 ): Update<mixed> {
   const update = createUpdate(expirationTime);
   update.tag = CaptureUpdate;
-  const getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;
-  if (
-    enableGetDerivedStateFromCatch &&
-    typeof getDerivedStateFromCatch === 'function'
-  ) {
+  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;
+  if (typeof getDerivedStateFromError === 'function') {
     const error = errorInfo.value;
     update.payload = () => {
-      return getDerivedStateFromCatch(error);
+      return getDerivedStateFromError(error);
     };
   }
 
   const inst = fiber.stateNode;
   if (inst !== null && typeof inst.componentDidCatch === 'function') {
     update.callback = function callback() {
-      if (
-        !enableGetDerivedStateFromCatch ||
-        getDerivedStateFromCatch !== 'function'
-      ) {
+      if (typeof getDerivedStateFromError !== 'function') {
         // To preserve the preexisting retry behavior of error boundaries,
         // we keep track of which ones already failed during this batch.
         // This gets reset before we yield back to the browser.
-        // TODO: Warn in strict mode if getDerivedStateFromCatch is
+        // TODO: Warn in strict mode if getDerivedStateFromError is
         // not defined.
         markLegacyErrorBoundaryAsFailed(this);
       }
@@ -135,6 +127,19 @@ function createClassErrorUpdate(
       this.componentDidCatch(error, {
         componentStack: stack !== null ? stack : '',
       });
+      if (__DEV__) {
+        if (typeof getDerivedStateFromError !== 'function') {
+          // If componentDidCatch is the only error boundary method defined,
+          // then it needs to call setState to recover from errors.
+          // If no state update is scheduled then the boundary will swallow the error.
+          warningWithoutStack(
+            fiber.expirationTime === Sync,
+            '%s: Error boundaries should implement getDerivedStateFromError(). ' +
+              'In that method, return a state update to display an error message or fallback UI.',
+            getComponentName(fiber.type) || 'Unknown',
+          );
+        }
+      }
     };
   }
   return update;
@@ -364,8 +369,7 @@ function throwException(
         const instance = workInProgress.stateNode;
         if (
           (workInProgress.effectTag & DidCapture) === NoEffect &&
-          ((typeof ctor.getDerivedStateFromCatch === 'function' &&
-            enableGetDerivedStateFromCatch) ||
+          (typeof ctor.getDerivedStateFromError === 'function' ||
             (instance !== null &&
               typeof instance.componentDidCatch === 'function' &&
               !isAlreadyFailedLegacyErrorBoundary(instance)))

commit 40a521aa7247872d0080d5a581120b64998152da
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 4 22:44:46 2018 +0100

    Terminology: Functional -> Function Component (#13775)
    
    * Terminology: Functional -> Function Component
    
    * Drop the "stateless" (functions are already stateless, right?)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index bba16ed0b6..b702139d70 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -18,7 +18,7 @@ import getComponentName from 'shared/getComponentName';
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {
   IndeterminateComponent,
-  FunctionalComponent,
+  FunctionComponent,
   ClassComponent,
   ClassComponentLazy,
   HostRoot,
@@ -260,9 +260,9 @@ function throwException(
             );
             sourceFiber.effectTag &= ~Incomplete;
             if (sourceFiber.tag === IndeterminateComponent) {
-              // Let's just assume it's a functional component. This fiber will
+              // Let's just assume it's a function component. This fiber will
               // be unmounted in the immediate next commit, anyway.
-              sourceFiber.tag = FunctionalComponent;
+              sourceFiber.tag = FunctionComponent;
             }
 
             if (
@@ -275,11 +275,11 @@ function throwException(
               sourceFiber.effectTag &= ~LifecycleEffectMask;
               if (sourceFiber.alternate === null) {
                 // We're about to mount a class component that doesn't have an
-                // instance. Turn this into a dummy functional component instead,
+                // instance. Turn this into a dummy function component instead,
                 // to prevent type errors. This is a bit weird but it's an edge
                 // case and we're about to synchronously delete this
                 // component, anyway.
-                sourceFiber.tag = FunctionalComponent;
+                sourceFiber.tag = FunctionComponent;
                 sourceFiber.type = NoopComponent;
               }
             }

commit d83601080a7c913cedcfbad86044702d008039c7
Author: Sophie Alpert <git@sophiebits.com>
Date:   Thu Oct 4 15:11:12 2018 -0700

    Wrap retrySuspendedRoot using SchedulerTracing (#13776)
    
    Previously, we were emptying root.pendingInteractionMap and permanently losing those interactions when applying an unrelated update to a tree that has no scheduled work that is waiting on promise resolution. (That is, one that is showing a fallback and waiting for the suspended content to resolve.)
    
    The logic I'm leaving untouched with `nextRenderIncludesTimedOutPlaceholder` is *not* correct -- what we want is instead to know if *any* placeholder anywhere in the tree is showing its fallback -- but we don't currently have a better replacement, and this should unblock tracing with suspense again.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index b702139d70..a77213a62a 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -14,6 +14,7 @@ import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
 
+import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {
@@ -59,7 +60,6 @@ import {
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
   retrySuspendedRoot,
-  captureWillSyncRenderPlaceholder,
 } from './ReactFiberScheduler';
 import {Sync} from './ReactFiberExpirationTime';
 
@@ -224,12 +224,15 @@ function throwException(
               : renderExpirationTime;
 
           // Attach a listener to the promise to "ping" the root and retry.
-          const onResolveOrReject = retrySuspendedRoot.bind(
+          let onResolveOrReject = retrySuspendedRoot.bind(
             null,
             root,
             workInProgress,
             pingTime,
           );
+          if (enableSchedulerTracing) {
+            onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
+          }
           thenable.then(onResolveOrReject, onResolveOrReject);
 
           // If the boundary is outside of strict mode, we should *not* suspend
@@ -243,13 +246,6 @@ function throwException(
           if ((workInProgress.mode & StrictMode) === NoEffect) {
             workInProgress.effectTag |= UpdateEffect;
 
-            if (enableSchedulerTracing) {
-              // Handles the special case of unwinding a suspended sync render.
-              // We flag this to properly trace and count interactions.
-              // Otherwise interaction pending count will be decremented too many times.
-              captureWillSyncRenderPlaceholder();
-            }
-
             // Unmount the source fiber's children
             const nextChildren = null;
             reconcileChildren(

commit 8af6728c6f105d37f9c0006288a6d1ac3903dc71
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Oct 10 17:02:04 2018 +0100

    Enable Suspense + rename Placeholder (#13799)
    
    * Enable Suspense
    
    * <unstable_Placeholder delayMs> => <unstable_Suspense maxDuration>
    
    * Update suspense fixture

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index a77213a62a..7918f64e6c 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -26,7 +26,7 @@ import {
   HostComponent,
   HostPortal,
   ContextProvider,
-  PlaceholderComponent,
+  SuspenseComponent,
 } from 'shared/ReactWorkTags';
 import {
   DidCapture,
@@ -36,7 +36,7 @@ import {
   Update as UpdateEffect,
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
-import {enableSuspense, enableSchedulerTracing} from 'shared/ReactFeatureFlags';
+import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
 import {StrictMode, ConcurrentMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
@@ -158,7 +158,6 @@ function throwException(
   sourceFiber.firstEffect = sourceFiber.lastEffect = null;
 
   if (
-    enableSuspense &&
     value !== null &&
     typeof value === 'object' &&
     typeof value.then === 'function'
@@ -175,7 +174,7 @@ function throwException(
     let earliestTimeoutMs = -1;
     let startTimeMs = -1;
     do {
-      if (workInProgress.tag === PlaceholderComponent) {
+      if (workInProgress.tag === SuspenseComponent) {
         const current = workInProgress.alternate;
         if (
           current !== null &&
@@ -193,7 +192,7 @@ function throwException(
           // Do not search any further.
           break;
         }
-        let timeoutPropMs = workInProgress.pendingProps.delayMs;
+        let timeoutPropMs = workInProgress.pendingProps.maxDuration;
         if (typeof timeoutPropMs === 'number') {
           if (timeoutPropMs <= 0) {
             earliestTimeoutMs = 0;
@@ -208,10 +207,10 @@ function throwException(
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
 
-    // Schedule the nearest Placeholder to re-render the timed out view.
+    // Schedule the nearest Suspense to re-render the timed out view.
     workInProgress = returnFiber;
     do {
-      if (workInProgress.tag === PlaceholderComponent) {
+      if (workInProgress.tag === SuspenseComponent) {
         const didTimeout = workInProgress.memoizedState;
         if (!didTimeout) {
           // Found the nearest boundary.
@@ -238,10 +237,10 @@ function throwException(
           // If the boundary is outside of strict mode, we should *not* suspend
           // the commit. Pretend as if the suspended component rendered null and
           // keep rendering. In the commit phase, we'll schedule a subsequent
-          // synchronous update to re-render the Placeholder.
+          // synchronous update to re-render the Suspense.
           //
           // Note: It doesn't matter whether the component that suspended was
-          // inside a strict mode tree. If the Placeholder is outside of it, we
+          // inside a strict mode tree. If the Suspense is outside of it, we
           // should *not* suspend the commit.
           if ((workInProgress.mode & StrictMode) === NoEffect) {
             workInProgress.effectTag |= UpdateEffect;
@@ -434,7 +433,7 @@ function unwindWork(
       popHostContext(workInProgress);
       return null;
     }
-    case PlaceholderComponent: {
+    case SuspenseComponent: {
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;

commit dac9202a9c5add480f853bcad2ee04d371e72c0c
Author: Andrew Clark <github@andrewclark.io>
Date:   Thu Oct 18 15:37:16 2018 -0700

    Hide timed-out children instead of deleting them so their state is preserved (#13823)
    
    * Store the start time on `updateQueue` instead of `stateNode`
    
    Originally I did this to free the `stateNode` field to store a second
    set of children. I don't we'll need this anymore, since we use fragment
    fibers instead. But I still think using `updateQueue` makes more sense
    so I'll leave this in.
    
    * Use fragment fibers to keep the primary and fallback children separate
    
    If the children timeout, we switch to showing the fallback children in
    place of the "primary" children. However, we don't want to delete the
    primary children because then their state will be lost (both the React
    state and the host state, e.g. uncontrolled form inputs). Instead we
    keep them mounted and hide them. Both the fallback children AND the
    primary children are rendered at the same time. Once the primary
    children are un-suspended, we can delete the fallback children ‚Äî don't
    need to preserve their state.
    
    The two sets of children are siblings in the host environment, but
    semantically, for purposes of reconciliation, they are two separate
    sets. So we store them using two fragment fibers.
    
    However, we want to avoid allocating extra fibers for every placeholder.
    They're only necessary when the children time out, because that's the
    only time when both sets are mounted.
    
    So, the extra fragment fibers are only used if the children time out.
    Otherwise, we render the primary children directly. This requires some
    custom reconciliation logic to preserve the state of the primary
    children. It's essentially a very basic form of re-parenting.
    
    * Use `memoizedState` to store various pieces of SuspenseComponent's state
    
    SuspenseComponent has three pieces of state:
    
    - alreadyCaptured: Whether a component in the child subtree already
    suspended. If true, subsequent suspends should bubble up to the
    next boundary.
    - didTimeout: Whether the boundary renders the primary or fallback
    children. This is separate from `alreadyCaptured` because outside of
    strict mode, when a boundary times out, the first commit renders the
    primary children in an incomplete state, then performs a second commit
    to switch the fallback. In that first commit, `alreadyCaptured` is
    false and `didTimeout` is true.
    - timedOutAt: The time at which the boundary timed out. This is separate
    from `didTimeout` because it's not set unless the boundary
    actually commits.
    
    
    These were previously spread across several fields.
    
    This happens to make the non-strict case a bit less hacky; the logic for
    that special case is now mostly localized to the UnwindWork module.
    
    * Hide timed-out Suspense children
    
    When a subtree takes too long to load, we swap its contents out for
    a fallback to unblock the rest of the tree. Because we don't want
    to lose the state of the timed out view, we shouldn't actually delete
    the nodes from the tree. Instead, we'll keep them mounted and hide
    them visually. When the subtree is unblocked, we un-hide it, having
    preserved the existing state.
    
    Adds additional host config methods. For mutation mode:
    
    - hideInstance
    - hideTextInstance
    - unhideInstance
    - unhideTextInstance
    
    For persistent mode:
    
    - cloneHiddenInstance
    - cloneUnhiddenInstance
    - createHiddenTextInstance
    
    I've only implemented the new methods in the noop and test renderers.
    I'll implement them in the other renderers in subsequent commits.
    
    * Include `hidden` prop in noop renderer's output
    
    This will be used in subsequent commits to test that timed-out children
    are properly hidden.
    
    Also adds getChildrenAsJSX() method as an alternative to using
    getChildren(). (Ideally all our tests would use test renderer #oneday.)
    
    * Implement hide/unhide host config methods for DOM renderer
    
    For DOM nodes, we hide using `el.style.display = 'none'`.
    
    Text nodes don't have style, so we hide using `text.textContent = ''`.
    
    * Implement hide/unhide host config methods for Art renderer
    
    * Create DOM fixture that tests state preservation of timed out content
    
    * Account for class components that suspend outside concurrent mode
    
    Need to distinguish mount from update. An unfortunate edge case :(
    
    * Fork appendAllChildren between persistent and mutation mode
    
    * Remove redundant check for existence of el.style
    
    * Schedule placement effect on indeterminate components
    
    In non-concurrent mode, indeterminate fibers may commit in an
    inconsistent state. But when they update, we should throw out the
    old fiber and start fresh. Which means the new fiber needs a
    placement effect.
    
    * Pass null instead of current everywhere in mountIndeterminateComponent

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 7918f64e6c..49f37d7445 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -18,7 +18,6 @@ import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {
-  IndeterminateComponent,
   FunctionComponent,
   ClassComponent,
   ClassComponentLazy,
@@ -33,7 +32,7 @@ import {
   Incomplete,
   NoEffect,
   ShouldCapture,
-  Update as UpdateEffect,
+  Callback as CallbackEffect,
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
 import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
@@ -61,7 +60,7 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   retrySuspendedRoot,
 } from './ReactFiberScheduler';
-import {Sync} from './ReactFiberExpirationTime';
+import {NoWork, Sync} from './ReactFiberExpirationTime';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';
@@ -176,21 +175,16 @@ function throwException(
     do {
       if (workInProgress.tag === SuspenseComponent) {
         const current = workInProgress.alternate;
-        if (
-          current !== null &&
-          current.memoizedState === true &&
-          current.stateNode !== null
-        ) {
-          // Reached a placeholder that already timed out. Each timed out
-          // placeholder acts as the root of a new suspense boundary.
-
-          // Use the time at which the placeholder timed out as the start time
-          // for the current render.
-          const timedOutAt = current.stateNode.timedOutAt;
-          startTimeMs = expirationTimeToMs(timedOutAt);
-
-          // Do not search any further.
-          break;
+        if (current !== null) {
+          const currentState = current.memoizedState;
+          if (currentState !== null && currentState.didTimeout) {
+            // Reached a boundary that already timed out. Do not search
+            // any further.
+            const timedOutAt = currentState.timedOutAt;
+            startTimeMs = expirationTimeToMs(timedOutAt);
+            // Do not search any further.
+            break;
+          }
         }
         let timeoutPropMs = workInProgress.pendingProps.maxDuration;
         if (typeof timeoutPropMs === 'number') {
@@ -211,7 +205,8 @@ function throwException(
     workInProgress = returnFiber;
     do {
       if (workInProgress.tag === SuspenseComponent) {
-        const didTimeout = workInProgress.memoizedState;
+        const state = workInProgress.memoizedState;
+        const didTimeout = state !== null && state.didTimeout;
         if (!didTimeout) {
           // Found the nearest boundary.
 
@@ -227,6 +222,7 @@ function throwException(
             null,
             root,
             workInProgress,
+            sourceFiber,
             pingTime,
           );
           if (enableSchedulerTracing) {
@@ -243,7 +239,7 @@ function throwException(
           // inside a strict mode tree. If the Suspense is outside of it, we
           // should *not* suspend the commit.
           if ((workInProgress.mode & StrictMode) === NoEffect) {
-            workInProgress.effectTag |= UpdateEffect;
+            workInProgress.effectTag |= CallbackEffect;
 
             // Unmount the source fiber's children
             const nextChildren = null;
@@ -254,11 +250,6 @@ function throwException(
               renderExpirationTime,
             );
             sourceFiber.effectTag &= ~Incomplete;
-            if (sourceFiber.tag === IndeterminateComponent) {
-              // Let's just assume it's a function component. This fiber will
-              // be unmounted in the immediate next commit, anyway.
-              sourceFiber.tag = FunctionComponent;
-            }
 
             if (
               sourceFiber.tag === ClassComponent ||
@@ -437,6 +428,32 @@ function unwindWork(
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Set the boundary's `alreadyCaptured`
+        // state to true so we know to render the fallback.
+        const current = workInProgress.alternate;
+        const currentState = current !== null ? current.memoizedState : null;
+        let nextState = workInProgress.memoizedState;
+        if (currentState === null) {
+          // No existing state. Create a new object.
+          nextState = {
+            alreadyCaptured: true,
+            didTimeout: false,
+            timedOutAt: NoWork,
+          };
+        } else if (currentState === nextState) {
+          // There is an existing state but it's the same as the current tree's.
+          // Clone the object.
+          nextState = {
+            alreadyCaptured: true,
+            didTimeout: currentState.didTimeout,
+            timedOutAt: currentState.timedOutAt,
+          };
+        } else {
+          // Already have a clone, so it's safe to mutate.
+          nextState.alreadyCaptured = true;
+        }
+        workInProgress.memoizedState = nextState;
+        // Re-render the boundary.
         return workInProgress;
       }
       return null;

commit 55b82794237a14a5cf106f61d84237dc9a3e04f6
Author: Andrew Clark <github@andrewclark.io>
Date:   Thu Oct 18 15:42:40 2018 -0700

    Strict mode and default mode should have same Suspense semantics (#13882)
    
    In the default mode, Suspense has special semantics where, in
    addition to timing out immediately, we don't unwind the stack before
    rendering the fallback. Instead, we commit the tree in an inconsistent
    state, then synchronous render *again* to switch to the fallback. This
    is slower but is less likely to cause issues with older components that
    perform side effects in the render phase (e.g. componentWillMount,
    componentWillUpdate, and componentWillReceiveProps).
    
    We should do this in strict mode, too, so that there are no semantic
    differences (in prod, at least) between default mode and strict mode.
    The rationale is that it makes it easier to wrap a tree in strict mode
    and start migrating components incrementally without worrying about new
    bugs in production.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 49f37d7445..2f0b87b89b 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -36,7 +36,7 @@ import {
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
 import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
-import {StrictMode, ConcurrentMode} from './ReactTypeOfMode';
+import {ConcurrentMode} from './ReactTypeOfMode';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -230,15 +230,15 @@ function throwException(
           }
           thenable.then(onResolveOrReject, onResolveOrReject);
 
-          // If the boundary is outside of strict mode, we should *not* suspend
-          // the commit. Pretend as if the suspended component rendered null and
-          // keep rendering. In the commit phase, we'll schedule a subsequent
-          // synchronous update to re-render the Suspense.
+          // If the boundary is outside of concurrent mode, we should *not*
+          // suspend the commit. Pretend as if the suspended component rendered
+          // null and keep rendering. In the commit phase, we'll schedule a
+          // subsequent synchronous update to re-render the Suspense.
           //
           // Note: It doesn't matter whether the component that suspended was
-          // inside a strict mode tree. If the Suspense is outside of it, we
+          // inside a concurrent mode tree. If the Suspense is outside of it, we
           // should *not* suspend the commit.
-          if ((workInProgress.mode & StrictMode) === NoEffect) {
+          if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
             workInProgress.effectTag |= CallbackEffect;
 
             // Unmount the source fiber's children
@@ -274,8 +274,8 @@ function throwException(
             return;
           }
 
-          // Confirmed that the boundary is in a strict mode tree. Continue with
-          // the normal suspend path.
+          // Confirmed that the boundary is in a concurrent mode tree. Continue
+          // with the normal suspend path.
 
           let absoluteTimeoutMs;
           if (earliestTimeoutMs === -1) {

commit 8ced545e3df95afab6fa35bc29f9320bafbcef26
Author: Andrew Clark <github@andrewclark.io>
Date:   Thu Oct 18 16:07:22 2018 -0700

    Suspense component does not capture if `fallback` is not defined (#13879)
    
    * Suspense component does not capture if `fallback` is not defined
    
    A missing fallback prop means the exception should propagate to the next
    parent (like a rethrow). That way a Suspense component can specify other
    props like maxDuration without needing to provide a fallback, too.
    
    Closes #13864
    
    * Change order of checks

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 2f0b87b89b..afec1bc821 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -205,9 +205,9 @@ function throwException(
     workInProgress = returnFiber;
     do {
       if (workInProgress.tag === SuspenseComponent) {
-        const state = workInProgress.memoizedState;
-        const didTimeout = state !== null && state.didTimeout;
-        if (!didTimeout) {
+        const fallback = workInProgress.memoizedProps.fallback;
+        const didTimeout = workInProgress.memoizedState;
+        if (!didTimeout && workInProgress.memoizedProps.fallback !== undefined) {
           // Found the nearest boundary.
 
           // If the boundary is not in concurrent mode, we should not suspend, and

commit 98bab66c35624250eba6ed32d24c06f70a433a67
Author: Andrew Clark <acdlite@fb.com>
Date:   Thu Oct 18 18:06:39 2018 -0700

    Fix lint

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index afec1bc821..f9a0899040 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -78,7 +78,7 @@ function NoopComponent() {
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime,
+  expirationTime: ExpirationTime
 ): Update<mixed> {
   const update = createUpdate(expirationTime);
   // Unmount the root by rendering null.
@@ -97,7 +97,7 @@ function createRootErrorUpdate(
 function createClassErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime,
+  expirationTime: ExpirationTime
 ): Update<mixed> {
   const update = createUpdate(expirationTime);
   update.tag = CaptureUpdate;
@@ -135,7 +135,7 @@ function createClassErrorUpdate(
             fiber.expirationTime === Sync,
             '%s: Error boundaries should implement getDerivedStateFromError(). ' +
               'In that method, return a state update to display an error message or fallback UI.',
-            getComponentName(fiber.type) || 'Unknown',
+            getComponentName(fiber.type) || 'Unknown'
           );
         }
       }
@@ -149,7 +149,7 @@ function throwException(
   returnFiber: Fiber,
   sourceFiber: Fiber,
   value: mixed,
-  renderExpirationTime: ExpirationTime,
+  renderExpirationTime: ExpirationTime
 ) {
   // The source fiber did not complete.
   sourceFiber.effectTag |= Incomplete;
@@ -205,9 +205,11 @@ function throwException(
     workInProgress = returnFiber;
     do {
       if (workInProgress.tag === SuspenseComponent) {
-        const fallback = workInProgress.memoizedProps.fallback;
         const didTimeout = workInProgress.memoizedState;
-        if (!didTimeout && workInProgress.memoizedProps.fallback !== undefined) {
+        if (
+          !didTimeout &&
+          workInProgress.memoizedProps.fallback !== undefined
+        ) {
           // Found the nearest boundary.
 
           // If the boundary is not in concurrent mode, we should not suspend, and
@@ -223,7 +225,7 @@ function throwException(
             root,
             workInProgress,
             sourceFiber,
-            pingTime,
+            pingTime
           );
           if (enableSchedulerTracing) {
             onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
@@ -247,7 +249,7 @@ function throwException(
               sourceFiber.alternate,
               sourceFiber,
               nextChildren,
-              renderExpirationTime,
+              renderExpirationTime
             );
             sourceFiber.effectTag &= ~Incomplete;
 
@@ -296,10 +298,10 @@ function throwException(
               // Difference.
               const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
                 root,
-                renderExpirationTime,
+                renderExpirationTime
               );
               const earliestExpirationTimeMs = expirationTimeToMs(
-                earliestExpirationTime,
+                earliestExpirationTime
               );
               startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
             }
@@ -323,7 +325,7 @@ function throwException(
     } while (workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
     value = new Error(
-      'An update was suspended, but no placeholder UI was provided.',
+      'An update was suspended, but no placeholder UI was provided.'
     );
   }
 
@@ -342,7 +344,7 @@ function throwException(
         const update = createRootErrorUpdate(
           workInProgress,
           errorInfo,
-          renderExpirationTime,
+          renderExpirationTime
         );
         enqueueCapturedUpdate(workInProgress, update);
         return;
@@ -366,7 +368,7 @@ function throwException(
           const update = createClassErrorUpdate(
             workInProgress,
             errorInfo,
-            renderExpirationTime,
+            renderExpirationTime
           );
           enqueueCapturedUpdate(workInProgress, update);
           return;
@@ -381,7 +383,7 @@ function throwException(
 
 function unwindWork(
   workInProgress: Fiber,
-  renderExpirationTime: ExpirationTime,
+  renderExpirationTime: ExpirationTime
 ) {
   switch (workInProgress.tag) {
     case ClassComponent: {
@@ -415,7 +417,7 @@ function unwindWork(
       invariant(
         (effectTag & DidCapture) === NoEffect,
         'The root failed to unmount after an error. This is likely a bug in ' +
-          'React. Please file an issue.',
+          'React. Please file an issue.'
       );
       workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
       return workInProgress;

commit 4dd772ac10032f2391af188c757d366af777e584
Author: Andrew Clark <acdlite@fb.com>
Date:   Thu Oct 18 18:38:44 2018 -0700

    Prettier :(

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index f9a0899040..b2c8397a76 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -78,7 +78,7 @@ function NoopComponent() {
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime
+  expirationTime: ExpirationTime,
 ): Update<mixed> {
   const update = createUpdate(expirationTime);
   // Unmount the root by rendering null.
@@ -97,7 +97,7 @@ function createRootErrorUpdate(
 function createClassErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime
+  expirationTime: ExpirationTime,
 ): Update<mixed> {
   const update = createUpdate(expirationTime);
   update.tag = CaptureUpdate;
@@ -135,7 +135,7 @@ function createClassErrorUpdate(
             fiber.expirationTime === Sync,
             '%s: Error boundaries should implement getDerivedStateFromError(). ' +
               'In that method, return a state update to display an error message or fallback UI.',
-            getComponentName(fiber.type) || 'Unknown'
+            getComponentName(fiber.type) || 'Unknown',
           );
         }
       }
@@ -149,7 +149,7 @@ function throwException(
   returnFiber: Fiber,
   sourceFiber: Fiber,
   value: mixed,
-  renderExpirationTime: ExpirationTime
+  renderExpirationTime: ExpirationTime,
 ) {
   // The source fiber did not complete.
   sourceFiber.effectTag |= Incomplete;
@@ -225,7 +225,7 @@ function throwException(
             root,
             workInProgress,
             sourceFiber,
-            pingTime
+            pingTime,
           );
           if (enableSchedulerTracing) {
             onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
@@ -249,7 +249,7 @@ function throwException(
               sourceFiber.alternate,
               sourceFiber,
               nextChildren,
-              renderExpirationTime
+              renderExpirationTime,
             );
             sourceFiber.effectTag &= ~Incomplete;
 
@@ -298,10 +298,10 @@ function throwException(
               // Difference.
               const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
                 root,
-                renderExpirationTime
+                renderExpirationTime,
               );
               const earliestExpirationTimeMs = expirationTimeToMs(
-                earliestExpirationTime
+                earliestExpirationTime,
               );
               startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
             }
@@ -325,7 +325,7 @@ function throwException(
     } while (workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
     value = new Error(
-      'An update was suspended, but no placeholder UI was provided.'
+      'An update was suspended, but no placeholder UI was provided.',
     );
   }
 
@@ -344,7 +344,7 @@ function throwException(
         const update = createRootErrorUpdate(
           workInProgress,
           errorInfo,
-          renderExpirationTime
+          renderExpirationTime,
         );
         enqueueCapturedUpdate(workInProgress, update);
         return;
@@ -368,7 +368,7 @@ function throwException(
           const update = createClassErrorUpdate(
             workInProgress,
             errorInfo,
-            renderExpirationTime
+            renderExpirationTime,
           );
           enqueueCapturedUpdate(workInProgress, update);
           return;
@@ -383,7 +383,7 @@ function throwException(
 
 function unwindWork(
   workInProgress: Fiber,
-  renderExpirationTime: ExpirationTime
+  renderExpirationTime: ExpirationTime,
 ) {
   switch (workInProgress.tag) {
     case ClassComponent: {
@@ -417,7 +417,7 @@ function unwindWork(
       invariant(
         (effectTag & DidCapture) === NoEffect,
         'The root failed to unmount after an error. This is likely a bug in ' +
-          'React. Please file an issue.'
+          'React. Please file an issue.',
       );
       workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
       return workInProgress;

commit 0fc04467987c187d557744f27c8ba90ea0a06cad
Author: Andrew Clark <github@andrewclark.io>
Date:   Fri Oct 19 18:41:47 2018 -0700

    Class component can suspend without losing state outside concurrent mode (#13899)
    
    Outside of concurrent mode, schedules a force update on a suspended
    class component to force it to prevent it from bailing out and
    reusing the current fiber, which we know to be inconsistent.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index b2c8397a76..a39d3d6a9e 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -18,7 +18,6 @@ import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {
-  FunctionComponent,
   ClassComponent,
   ClassComponentLazy,
   HostRoot,
@@ -71,10 +70,6 @@ import {
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
 import {reconcileChildren} from './ReactFiberBeginWork';
 
-function NoopComponent() {
-  return null;
-}
-
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
@@ -262,13 +257,9 @@ function throwException(
               // callbacks. Remove all lifecycle effect tags.
               sourceFiber.effectTag &= ~LifecycleEffectMask;
               if (sourceFiber.alternate === null) {
-                // We're about to mount a class component that doesn't have an
-                // instance. Turn this into a dummy function component instead,
-                // to prevent type errors. This is a bit weird but it's an edge
-                // case and we're about to synchronously delete this
-                // component, anyway.
-                sourceFiber.tag = FunctionComponent;
-                sourceFiber.type = NoopComponent;
+                // Set the instance back to null. We use this as a heuristic to
+                // detect that the fiber mounted in an inconsistent state.
+                sourceFiber.stateNode = null;
               }
             }
 

commit 95a313ec0b957f71798a69d8e83408f40e76765b
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Fri Oct 19 22:22:45 2018 -0700

    Unfork Lazy Component Branches (#13902)
    
    * Introduce elementType field
    
    This will be used to store the wrapped type of an element. E.g. pure and
    lazy.
    
    The existing type field will be used for the unwrapped type within them.
    
    * Store the unwrapped type on the type field of lazy components
    
    * Use the raw tags for lazy components
    
    Instead, we check if the elementType and type are equal to test if
    we need to resolve props. This is slightly slower in the normal case
    but will yield less code and branching.
    
    * Clean up lazy branches
    
    * Collapse work tag numbering
    
    * Split IndeterminateComponent out from Lazy
    
    This way we don't have to check the type in a hacky way in the
    indeterminate path. Also, lets us deal with lazy that resolves to
    indeterminate and such.
    
    * Missing clean up in rebase

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index a39d3d6a9e..872fb1cd89 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -19,7 +19,6 @@ import getComponentName from 'shared/getComponentName';
 import warningWithoutStack from 'shared/warningWithoutStack';
 import {
   ClassComponent,
-  ClassComponentLazy,
   HostRoot,
   HostComponent,
   HostPortal,
@@ -248,10 +247,7 @@ function throwException(
             );
             sourceFiber.effectTag &= ~Incomplete;
 
-            if (
-              sourceFiber.tag === ClassComponent ||
-              sourceFiber.tag === ClassComponentLazy
-            ) {
+            if (sourceFiber.tag === ClassComponent) {
               // We're going to commit this fiber even though it didn't
               // complete. But we shouldn't call any lifecycle methods or
               // callbacks. Remove all lifecycle effect tags.
@@ -341,7 +337,6 @@ function throwException(
         return;
       }
       case ClassComponent:
-      case ClassComponentLazy:
         // Capture and retry
         const errorInfo = value;
         const ctor = workInProgress.type;
@@ -389,18 +384,6 @@ function unwindWork(
       }
       return null;
     }
-    case ClassComponentLazy: {
-      const Component = workInProgress.type._reactResult;
-      if (isLegacyContextProvider(Component)) {
-        popLegacyContext(workInProgress);
-      }
-      const effectTag = workInProgress.effectTag;
-      if (effectTag & ShouldCapture) {
-        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-        return workInProgress;
-      }
-      return null;
-    }
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelLegacyContextObject(workInProgress);
@@ -471,14 +454,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
       }
       break;
     }
-    case ClassComponentLazy: {
-      const childContextTypes =
-        interruptedWork.type._reactResult.childContextTypes;
-      if (childContextTypes !== null && childContextTypes !== undefined) {
-        popLegacyContext(interruptedWork);
-      }
-      break;
-    }
     case HostRoot: {
       popHostContainer(interruptedWork);
       popTopLevelLegacyContextObject(interruptedWork);

commit 55444a6f490ce84550ba664b9a82f1724134fb76
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Oct 22 22:37:15 2018 -0700

    Try rendering again if a timed out tree receives an update (#13921)
    
    Found a bug related to suspending inside an already mounted tree. While
    investigating this I noticed we really don't have much coverage of
    suspended updates. I think this would greatly benefit from some fuzz
    testing; still haven't thought of a good test case, though.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 872fb1cd89..44f5a20ee8 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -13,6 +13,7 @@ import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
@@ -35,6 +36,7 @@ import {
 } from 'shared/ReactSideEffectTags';
 import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
 import {ConcurrentMode} from './ReactTypeOfMode';
+import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
 
 import {createCapturedValue} from './ReactCapturedValue';
 import {
@@ -170,7 +172,7 @@ function throwException(
       if (workInProgress.tag === SuspenseComponent) {
         const current = workInProgress.alternate;
         if (current !== null) {
-          const currentState = current.memoizedState;
+          const currentState: SuspenseState | null = current.memoizedState;
           if (currentState !== null && currentState.didTimeout) {
             // Reached a boundary that already timed out. Do not search
             // any further.
@@ -198,116 +200,113 @@ function throwException(
     // Schedule the nearest Suspense to re-render the timed out view.
     workInProgress = returnFiber;
     do {
-      if (workInProgress.tag === SuspenseComponent) {
-        const didTimeout = workInProgress.memoizedState;
-        if (
-          !didTimeout &&
-          workInProgress.memoizedProps.fallback !== undefined
-        ) {
-          // Found the nearest boundary.
+      if (
+        workInProgress.tag === SuspenseComponent &&
+        shouldCaptureSuspense(workInProgress.alternate, workInProgress)
+      ) {
+        // Found the nearest boundary.
 
-          // If the boundary is not in concurrent mode, we should not suspend, and
-          // likewise, when the promise resolves, we should ping synchronously.
-          const pingTime =
-            (workInProgress.mode & ConcurrentMode) === NoEffect
-              ? Sync
-              : renderExpirationTime;
+        // If the boundary is not in concurrent mode, we should not suspend, and
+        // likewise, when the promise resolves, we should ping synchronously.
+        const pingTime =
+          (workInProgress.mode & ConcurrentMode) === NoEffect
+            ? Sync
+            : renderExpirationTime;
 
-          // Attach a listener to the promise to "ping" the root and retry.
-          let onResolveOrReject = retrySuspendedRoot.bind(
-            null,
-            root,
-            workInProgress,
-            sourceFiber,
-            pingTime,
-          );
-          if (enableSchedulerTracing) {
-            onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
-          }
-          thenable.then(onResolveOrReject, onResolveOrReject);
+        // Attach a listener to the promise to "ping" the root and retry.
+        let onResolveOrReject = retrySuspendedRoot.bind(
+          null,
+          root,
+          workInProgress,
+          sourceFiber,
+          pingTime,
+        );
+        if (enableSchedulerTracing) {
+          onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
+        }
+        thenable.then(onResolveOrReject, onResolveOrReject);
 
-          // If the boundary is outside of concurrent mode, we should *not*
-          // suspend the commit. Pretend as if the suspended component rendered
-          // null and keep rendering. In the commit phase, we'll schedule a
-          // subsequent synchronous update to re-render the Suspense.
-          //
-          // Note: It doesn't matter whether the component that suspended was
-          // inside a concurrent mode tree. If the Suspense is outside of it, we
-          // should *not* suspend the commit.
-          if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
-            workInProgress.effectTag |= CallbackEffect;
+        // If the boundary is outside of concurrent mode, we should *not*
+        // suspend the commit. Pretend as if the suspended component rendered
+        // null and keep rendering. In the commit phase, we'll schedule a
+        // subsequent synchronous update to re-render the Suspense.
+        //
+        // Note: It doesn't matter whether the component that suspended was
+        // inside a concurrent mode tree. If the Suspense is outside of it, we
+        // should *not* suspend the commit.
+        if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
+          workInProgress.effectTag |= CallbackEffect;
 
-            // Unmount the source fiber's children
-            const nextChildren = null;
-            reconcileChildren(
-              sourceFiber.alternate,
-              sourceFiber,
-              nextChildren,
-              renderExpirationTime,
-            );
-            sourceFiber.effectTag &= ~Incomplete;
+          // Unmount the source fiber's children
+          const nextChildren = null;
+          reconcileChildren(
+            sourceFiber.alternate,
+            sourceFiber,
+            nextChildren,
+            renderExpirationTime,
+          );
+          sourceFiber.effectTag &= ~Incomplete;
 
-            if (sourceFiber.tag === ClassComponent) {
-              // We're going to commit this fiber even though it didn't
-              // complete. But we shouldn't call any lifecycle methods or
-              // callbacks. Remove all lifecycle effect tags.
-              sourceFiber.effectTag &= ~LifecycleEffectMask;
-              if (sourceFiber.alternate === null) {
-                // Set the instance back to null. We use this as a heuristic to
-                // detect that the fiber mounted in an inconsistent state.
-                sourceFiber.stateNode = null;
-              }
+          if (sourceFiber.tag === ClassComponent) {
+            // We're going to commit this fiber even though it didn't complete.
+            // But we shouldn't call any lifecycle methods or callbacks. Remove
+            // all lifecycle effect tags.
+            sourceFiber.effectTag &= ~LifecycleEffectMask;
+            if (sourceFiber.alternate === null) {
+              // Set the instance back to null. We use this as a heuristic to
+              // detect that the fiber mounted in an inconsistent state.
+              sourceFiber.stateNode = null;
             }
-
-            // Exit without suspending.
-            return;
           }
 
-          // Confirmed that the boundary is in a concurrent mode tree. Continue
-          // with the normal suspend path.
+          // Exit without suspending.
+          return;
+        }
 
-          let absoluteTimeoutMs;
-          if (earliestTimeoutMs === -1) {
-            // If no explicit threshold is given, default to an abitrarily large
-            // value. The actual size doesn't matter because the threshold for the
-            // whole tree will be clamped to the expiration time.
-            absoluteTimeoutMs = maxSigned31BitInt;
-          } else {
-            if (startTimeMs === -1) {
-              // This suspend happened outside of any already timed-out
-              // placeholders. We don't know exactly when the update was scheduled,
-              // but we can infer an approximate start time from the expiration
-              // time. First, find the earliest uncommitted expiration time in the
-              // tree, including work that is suspended. Then subtract the offset
-              // used to compute an async update's expiration time. This will cause
-              // high priority (interactive) work to expire earlier than necessary,
-              // but we can account for this by adjusting for the Just Noticeable
-              // Difference.
-              const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
-                root,
-                renderExpirationTime,
-              );
-              const earliestExpirationTimeMs = expirationTimeToMs(
-                earliestExpirationTime,
-              );
-              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
-            }
-            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        // Confirmed that the boundary is in a concurrent mode tree. Continue
+        // with the normal suspend path.
+
+        let absoluteTimeoutMs;
+        if (earliestTimeoutMs === -1) {
+          // If no explicit threshold is given, default to an abitrarily large
+          // value. The actual size doesn't matter because the threshold for the
+          // whole tree will be clamped to the expiration time.
+          absoluteTimeoutMs = maxSigned31BitInt;
+        } else {
+          if (startTimeMs === -1) {
+            // This suspend happened outside of any already timed-out
+            // placeholders. We don't know exactly when the update was
+            // scheduled, but we can infer an approximate start time from the
+            // expiration time. First, find the earliest uncommitted expiration
+            // time in the tree, including work that is suspended. Then subtract
+            // the offset used to compute an async update's expiration time.
+            // This will cause high priority (interactive) work to expire
+            // earlier than necessary, but we can account for this by adjusting
+            // for the Just Noticeable Difference.
+            const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+              root,
+              renderExpirationTime,
+            );
+            const earliestExpirationTimeMs = expirationTimeToMs(
+              earliestExpirationTime,
+            );
+            startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
           }
+          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
+        }
 
-          // Mark the earliest timeout in the suspended fiber's ancestor path.
-          // After completing the root, we'll take the largest of all the
-          // suspended fiber's timeouts and use it to compute a timeout for the
-          // whole tree.
-          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
+        // Mark the earliest timeout in the suspended fiber's ancestor path.
+        // After completing the root, we'll take the largest of all the
+        // suspended fiber's timeouts and use it to compute a timeout for the
+        // whole tree.
+        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
-          workInProgress.effectTag |= ShouldCapture;
-          workInProgress.expirationTime = renderExpirationTime;
-          return;
-        }
-        // This boundary already captured during this render. Continue to the
-        // next boundary.
+        workInProgress.effectTag |= ShouldCapture;
+        workInProgress.expirationTime = renderExpirationTime;
+        return;
       }
+      // This boundary already captured during this render. Continue to the next
+      // boundary.
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
@@ -407,9 +406,10 @@ function unwindWork(
         // Captured a suspense effect. Set the boundary's `alreadyCaptured`
         // state to true so we know to render the fallback.
         const current = workInProgress.alternate;
-        const currentState = current !== null ? current.memoizedState : null;
-        let nextState = workInProgress.memoizedState;
-        if (currentState === null) {
+        const currentState: SuspenseState | null =
+          current !== null ? current.memoizedState : null;
+        let nextState: SuspenseState | null = workInProgress.memoizedState;
+        if (nextState === null) {
           // No existing state. Create a new object.
           nextState = {
             alreadyCaptured: true,
@@ -421,8 +421,8 @@ function unwindWork(
           // Clone the object.
           nextState = {
             alreadyCaptured: true,
-            didTimeout: currentState.didTimeout,
-            timedOutAt: currentState.timedOutAt,
+            didTimeout: nextState.didTimeout,
+            timedOutAt: nextState.timedOutAt,
           };
         } else {
           // Already have a clone, so it's safe to mutate.

commit cbbc2b6c4d0d8519145560bd8183ecde55168b12
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 23 11:36:56 2018 -0700

    [Synchronous Suspense] Suspending a class outside concurrent mode (#13926)
    
    * [Synchronous Suspense] Suspending a class outside concurrent mode
    
    When a class component suspends during mount outside concurrent mode,
    change the tag so it's not mistaken for a completed component. For
    example, we should not call componentWillUnmount if it is deleted.
    
    * PR nits

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 44f5a20ee8..40c814a37d 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -25,6 +25,7 @@ import {
   HostPortal,
   ContextProvider,
   SuspenseComponent,
+  IncompleteClassComponent,
 } from 'shared/ReactWorkTags';
 import {
   DidCapture,
@@ -252,10 +253,12 @@ function throwException(
             // But we shouldn't call any lifecycle methods or callbacks. Remove
             // all lifecycle effect tags.
             sourceFiber.effectTag &= ~LifecycleEffectMask;
-            if (sourceFiber.alternate === null) {
-              // Set the instance back to null. We use this as a heuristic to
-              // detect that the fiber mounted in an inconsistent state.
-              sourceFiber.stateNode = null;
+            const current = sourceFiber.alternate;
+            if (current === null) {
+              // This is a new mount. Change the tag so it's not mistaken for a
+              // completed component. For example, we should not call
+              // componentWillUnmount if it is deleted.
+              sourceFiber.tag = IncompleteClassComponent;
             }
           }
 

commit acb48996373ee0cbf1b2462972cd7644862d770e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 23 00:41:22 2018 -0700

    Clear effect tags from a fiber that suspends in non-concurrent mode
    
    Even though we commit the fiber in an incomplete state, we shouldn't
    fire any lifecycles or effects.
    
    We already did this for classes, but now with useEffect, the same is
    needed for other types of work, too.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 40c814a37d..26ab5bea0f 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -248,15 +248,16 @@ function throwException(
           );
           sourceFiber.effectTag &= ~Incomplete;
 
+          // We're going to commit this fiber even though it didn't complete.
+          // But we shouldn't call any lifecycle methods or callbacks. Remove
+          // all lifecycle effect tags.
+          sourceFiber.effectTag &= ~LifecycleEffectMask;
+
           if (sourceFiber.tag === ClassComponent) {
-            // We're going to commit this fiber even though it didn't complete.
-            // But we shouldn't call any lifecycle methods or callbacks. Remove
-            // all lifecycle effect tags.
-            sourceFiber.effectTag &= ~LifecycleEffectMask;
             const current = sourceFiber.alternate;
             if (current === null) {
               // This is a new mount. Change the tag so it's not mistaken for a
-              // completed component. For example, we should not call
+              // completed class component. For example, we should not call
               // componentWillUnmount if it is deleted.
               sourceFiber.tag = IncompleteClassComponent;
             }

commit d5d10d140ed8739c83f3cee5d43f0bf60eea1002
Author: Maksim Markelov <maks-markel@mail.ru>
Date:   Thu Nov 1 07:12:51 2018 +0300

    Simplify imports in react reconciler (#13718)
    
    * Simplify imports in ReactChildFiber
    * Import type first in ReactCurrentFiber
    * Simplify imports in ReactFiberBeginWork
    * Simplify imports in ReactFiberScheduler
    * Simplify import in ReactFiberTreeReflection
    * Simplify import in ReactFiberUnwindWork
    * Remove repeated import
    * Fix imports from ReactFiberExpirationTime
    * Master imports in ReactFiberBeginWork

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 26ab5bea0f..6ec30e8d78 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -61,11 +61,12 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   retrySuspendedRoot,
 } from './ReactFiberScheduler';
-import {NoWork, Sync} from './ReactFiberExpirationTime';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';
 import {
+  NoWork,
+  Sync,
   expirationTimeToMs,
   LOW_PRIORITY_EXPIRATION,
 } from './ReactFiberExpirationTime';

commit c84b9bf828c38e0b24042ebb9cd859292146a6fb
Author: Sophie Alpert <git@sophiebits.com>
Date:   Thu Nov 1 22:45:23 2018 -0700

    Tweak error message for missing fallback (#14068)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 6ec30e8d78..004d5e5f6a 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -46,6 +46,7 @@ import {
   CaptureUpdate,
 } from './ReactUpdateQueue';
 import {logError} from './ReactFiberCommitWork';
+import {getStackByFiberInDevAndProd} from './ReactCurrentFiber';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {
   isContextProvider as isLegacyContextProvider,
@@ -315,8 +316,14 @@ function throwException(
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
     // No boundary was found. Fallthrough to error mode.
+    // TODO: Use invariant so the message is stripped in prod?
     value = new Error(
-      'An update was suspended, but no placeholder UI was provided.',
+      (getComponentName(sourceFiber.type) || 'A React component') +
+        ' suspended while rendering, but no fallback UI was specified.\n' +
+        '\n' +
+        'Add a <Suspense fallback=...> component higher in the tree to ' +
+        'provide a loading indicator or placeholder to display.' +
+        getStackByFiberInDevAndProd(sourceFiber),
     );
   }
 

commit e9a2ec915655fa1968b7d41c4e8ad9e90f7268cb
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Nov 5 16:32:50 2018 -0800

    [suspense] Avoid double commit by re-rendering immediately and reusing primary children (#14083)
    
    * Avoid double commit by re-rendering immediately and reusing children
    
    To support Suspense outside of concurrent mode, any component that
    starts rendering must commit synchronously without being interrupted.
    This means normal path, where we unwind the stack and try again from the
    nearest Suspense boundary, won't work.
    
    We used to have a special case where we commit the suspended tree in an
    incomplete state. Then, in a subsequent commit, we re-render using the
    fallback.
    
    The first part ‚Äî committing an incomplete tree ‚Äî hasn't changed with
    this PR. But I've changed the second part ‚Äî now we render the fallback
    children immediately, within the same commit.
    
    * Add a failing test for remounting fallback in sync mode
    
    * Add failing test for stuck Suspense fallback
    
    * Toggle visibility of Suspense children in mutation phase, not layout
    
    If parent reads visibility of children in a lifecycle, they should have
    already updated.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 004d5e5f6a..6fb2e08068 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -32,7 +32,6 @@ import {
   Incomplete,
   NoEffect,
   ShouldCapture,
-  Callback as CallbackEffect,
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
 import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
@@ -66,7 +65,6 @@ import {
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';
 import {
-  NoWork,
   Sync,
   expirationTimeToMs,
   LOW_PRIORITY_EXPIRATION,
@@ -176,7 +174,7 @@ function throwException(
         const current = workInProgress.alternate;
         if (current !== null) {
           const currentState: SuspenseState | null = current.memoizedState;
-          if (currentState !== null && currentState.didTimeout) {
+          if (currentState !== null) {
             // Reached a boundary that already timed out. Do not search
             // any further.
             const timedOutAt = currentState.timedOutAt;
@@ -238,7 +236,7 @@ function throwException(
         // inside a concurrent mode tree. If the Suspense is outside of it, we
         // should *not* suspend the commit.
         if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
-          workInProgress.effectTag |= CallbackEffect;
+          workInProgress.effectTag |= DidCapture;
 
           // Unmount the source fiber's children
           const nextChildren = null;
@@ -265,6 +263,10 @@ function throwException(
             }
           }
 
+          // The source fiber did not complete. Mark it with the current
+          // render priority to indicate that it still has pending work.
+          sourceFiber.expirationTime = renderExpirationTime;
+
           // Exit without suspending.
           return;
         }
@@ -415,33 +417,7 @@ function unwindWork(
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-        // Captured a suspense effect. Set the boundary's `alreadyCaptured`
-        // state to true so we know to render the fallback.
-        const current = workInProgress.alternate;
-        const currentState: SuspenseState | null =
-          current !== null ? current.memoizedState : null;
-        let nextState: SuspenseState | null = workInProgress.memoizedState;
-        if (nextState === null) {
-          // No existing state. Create a new object.
-          nextState = {
-            alreadyCaptured: true,
-            didTimeout: false,
-            timedOutAt: NoWork,
-          };
-        } else if (currentState === nextState) {
-          // There is an existing state but it's the same as the current tree's.
-          // Clone the object.
-          nextState = {
-            alreadyCaptured: true,
-            didTimeout: nextState.didTimeout,
-            timedOutAt: nextState.timedOutAt,
-          };
-        } else {
-          // Already have a clone, so it's safe to mutate.
-          nextState.alreadyCaptured = true;
-        }
-        workInProgress.memoizedState = nextState;
-        // Re-render the boundary.
+        // Captured a suspense effect. Re-render the boundary.
         return workInProgress;
       }
       return null;

commit f9e9913f0eaee7c2fabb801dccec97fd61873c5f
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Nov 8 11:38:38 2018 -0800

    [Synchronous Suspense] Don't delete children of suspended component (#14157)
    
    Vestigial behavior that should have been removed in #13823.
    
    Found using the Suspense fuzz tester in #14147.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 6fb2e08068..4ddd5db8a9 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -70,7 +70,6 @@ import {
   LOW_PRIORITY_EXPIRATION,
 } from './ReactFiberExpirationTime';
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
-import {reconcileChildren} from './ReactFiberBeginWork';
 
 function createRootErrorUpdate(
   fiber: Fiber,
@@ -238,20 +237,10 @@ function throwException(
         if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
           workInProgress.effectTag |= DidCapture;
 
-          // Unmount the source fiber's children
-          const nextChildren = null;
-          reconcileChildren(
-            sourceFiber.alternate,
-            sourceFiber,
-            nextChildren,
-            renderExpirationTime,
-          );
-          sourceFiber.effectTag &= ~Incomplete;
-
           // We're going to commit this fiber even though it didn't complete.
           // But we shouldn't call any lifecycle methods or callbacks. Remove
           // all lifecycle effect tags.
-          sourceFiber.effectTag &= ~LifecycleEffectMask;
+          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
 
           if (sourceFiber.tag === ClassComponent) {
             const current = sourceFiber.alternate;

commit 4a1072194fcef2da1aae2510886c274736017fbd
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Dec 14 11:03:23 2018 -0800

    Memoize promise listeners to prevent exponential growth (#14429)
    
    * Memoize promise listeners to prevent exponential growth
    
    Previously, React would attach a new listener every time a promise is
    thrown, regardless of whether the same listener was already attached
    during a previous render. Because React attempts to render every time
    a promise resolves, the number of listeners grows quickly.
    
    This was especially bad in synchronous mode because the renders that
    happen when the promise pings are not batched together. So if a single
    promise has multiple listeners for the same root, there will be multiple
    renders, which in turn results in more listeners being added to the
    remaining unresolved promises. This results in exponential growth in
    the number of listeners with respect to the number of IO-bound
    components in a single render.
    
    Fixes #14220
    
    * Memoize on the root and Suspense fiber instead of on the promise
    
    * Add TODO to fix persistent mode tests

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 4ddd5db8a9..86e2b1a964 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -43,6 +43,8 @@ import {
   enqueueCapturedUpdate,
   createUpdate,
   CaptureUpdate,
+  ForceUpdate,
+  enqueueUpdate,
 } from './ReactUpdateQueue';
 import {logError} from './ReactFiberCommitWork';
 import {getStackByFiberInDevAndProd} from './ReactCurrentFiber';
@@ -59,7 +61,7 @@ import {
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
-  retrySuspendedRoot,
+  pingSuspendedRoot,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
@@ -71,6 +73,8 @@ import {
 } from './ReactFiberExpirationTime';
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
 
+const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
+
 function createRootErrorUpdate(
   fiber: Fiber,
   errorInfo: CapturedValue<mixed>,
@@ -202,29 +206,18 @@ function throwException(
     do {
       if (
         workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(workInProgress.alternate, workInProgress)
+        shouldCaptureSuspense(workInProgress)
       ) {
         // Found the nearest boundary.
 
-        // If the boundary is not in concurrent mode, we should not suspend, and
-        // likewise, when the promise resolves, we should ping synchronously.
-        const pingTime =
-          (workInProgress.mode & ConcurrentMode) === NoEffect
-            ? Sync
-            : renderExpirationTime;
-
-        // Attach a listener to the promise to "ping" the root and retry.
-        let onResolveOrReject = retrySuspendedRoot.bind(
-          null,
-          root,
-          workInProgress,
-          sourceFiber,
-          pingTime,
-        );
-        if (enableSchedulerTracing) {
-          onResolveOrReject = Schedule_tracing_wrap(onResolveOrReject);
+        // Stash the promise on the boundary fiber. If the boundary times out, we'll
+        // attach another listener to flip the boundary back to its normal state.
+        const thenables: Set<Thenable> = (workInProgress.updateQueue: any);
+        if (thenables === null) {
+          workInProgress.updateQueue = (new Set([thenable]): any);
+        } else {
+          thenables.add(thenable);
         }
-        thenable.then(onResolveOrReject, onResolveOrReject);
 
         // If the boundary is outside of concurrent mode, we should *not*
         // suspend the commit. Pretend as if the suspended component rendered
@@ -243,18 +236,25 @@ function throwException(
           sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
 
           if (sourceFiber.tag === ClassComponent) {
-            const current = sourceFiber.alternate;
-            if (current === null) {
+            const currentSourceFiber = sourceFiber.alternate;
+            if (currentSourceFiber === null) {
               // This is a new mount. Change the tag so it's not mistaken for a
               // completed class component. For example, we should not call
               // componentWillUnmount if it is deleted.
               sourceFiber.tag = IncompleteClassComponent;
+            } else {
+              // When we try rendering again, we should not reuse the current fiber,
+              // since it's known to be in an inconsistent state. Use a force updte to
+              // prevent a bail out.
+              const update = createUpdate(Sync);
+              update.tag = ForceUpdate;
+              enqueueUpdate(sourceFiber, update);
             }
           }
 
-          // The source fiber did not complete. Mark it with the current
-          // render priority to indicate that it still has pending work.
-          sourceFiber.expirationTime = renderExpirationTime;
+          // The source fiber did not complete. Mark it with Sync priority to
+          // indicate that it still has pending work.
+          sourceFiber.expirationTime = Sync;
 
           // Exit without suspending.
           return;
@@ -263,6 +263,37 @@ function throwException(
         // Confirmed that the boundary is in a concurrent mode tree. Continue
         // with the normal suspend path.
 
+        // Attach a listener to the promise to "ping" the root and retry. But
+        // only if one does not already exist for the current render expiration
+        // time (which acts like a "thread ID" here).
+        let pingCache = root.pingCache;
+        let threadIDs;
+        if (pingCache === null) {
+          pingCache = root.pingCache = new PossiblyWeakMap();
+          threadIDs = new Set();
+          pingCache.set(thenable, threadIDs);
+        } else {
+          threadIDs = pingCache.get(thenable);
+          if (threadIDs === undefined) {
+            threadIDs = new Set();
+            pingCache.set(thenable, threadIDs);
+          }
+        }
+        if (!threadIDs.has(renderExpirationTime)) {
+          // Memoize using the thread ID to prevent redundant listeners.
+          threadIDs.add(renderExpirationTime);
+          let ping = pingSuspendedRoot.bind(
+            null,
+            root,
+            thenable,
+            renderExpirationTime,
+          );
+          if (enableSchedulerTracing) {
+            ping = Schedule_tracing_wrap(ping);
+          }
+          thenable.then(ping, ping);
+        }
+
         let absoluteTimeoutMs;
         if (earliestTimeoutMs === -1) {
           // If no explicit threshold is given, default to an abitrarily large

commit 0fc15475139206f1f999b5c16bbe6f90142e936a
Author: Brandon Dail <aweary@users.noreply.github.com>
Date:   Mon Jan 14 17:00:15 2019 -0800

    Avoid new Set([iterable]) for thenables (#14592)
    
    Fixes https://github.com/facebook/react/issues/14583
    
    Using `new Set([iterable])` does not work with IE11's non-compliant Set
    implementation. By avoiding this pattern we don't need to require a Set
    polyfill for IE11

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 86e2b1a964..f8c0b050f0 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -214,7 +214,8 @@ function throwException(
         // attach another listener to flip the boundary back to its normal state.
         const thenables: Set<Thenable> = (workInProgress.updateQueue: any);
         if (thenables === null) {
-          workInProgress.updateQueue = (new Set([thenable]): any);
+          workInProgress.updateQueue = (new Set(): any);
+          workInProgress.updateQueue.add(thenable);
         } else {
           thenables.add(thenable);
         }

commit 7ad9806d114bea575300394e84a1bb4ef2b4a329
Author: Brandon Dail <aweary@users.noreply.github.com>
Date:   Mon Jan 14 17:39:27 2019 -0800

    Tweak to avoid property read (#14593)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index f8c0b050f0..68cd4988f7 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -214,8 +214,9 @@ function throwException(
         // attach another listener to flip the boundary back to its normal state.
         const thenables: Set<Thenable> = (workInProgress.updateQueue: any);
         if (thenables === null) {
-          workInProgress.updateQueue = (new Set(): any);
-          workInProgress.updateQueue.add(thenable);
+          const updateQueue = (new Set(): any);
+          updateQueue.add(thenable);
+          workInProgress.updateQueue = updateQueue;
         } else {
           thenables.add(thenable);
         }

commit 9d483dcfd6aad53ce082d249845436a56eb39248
Author: Peter Donald <peter@realityforge.org>
Date:   Mon Jan 28 01:54:37 2019 +1100

    Spelling abitrarily -> arbitrarily (#14710)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 68cd4988f7..df5efdf241 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -298,7 +298,7 @@ function throwException(
 
         let absoluteTimeoutMs;
         if (earliestTimeoutMs === -1) {
-          // If no explicit threshold is given, default to an abitrarily large
+          // If no explicit threshold is given, default to an arbitrarily large
           // value. The actual size doesn't matter because the threshold for the
           // whole tree will be clamped to the expiration time.
           absoluteTimeoutMs = maxSigned31BitInt;

commit f3a14951ab9bccfd59ca977493b72321b24e50a5
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Mon Feb 11 21:25:44 2019 -0800

    Partial Hydration (#14717)
    
    * Basic partial hydration test
    
    * Render comments around Suspense components
    
    We need this to be able to identify how far to skip ahead if we're not
    going to hydrate this subtree yet.
    
    * Add DehydratedSuspenseComponent type of work
    
    Will be used for Suspense boundaries that are left with their server
    rendered content intact.
    
    * Add comment node as hydratable instance type as placeholder for suspense
    
    * Skip past nodes within the Suspense boundary
    
    This lets us continue hydrating sibling nodes.
    
    * A dehydrated suspense boundary comment should be considered a sibling
    
    * Retry hydrating at offscreen pri or after ping if suspended
    
    * Enter hydration state when retrying dehydrated suspense boundary
    
    * Delete all children within a dehydrated suspense boundary when it's deleted
    
    * Delete server rendered content when props change before hydration completes
    
    * Make test internal
    
    * Wrap in act
    
    * Change SSR Fixture to use Partial Hydration
    
    This requires the enableSuspenseServerRenderer flag to be manually enabled
    for the build to work.
    
    * Changes to any parent Context forces clearing dehydrated content
    
    We mark dehydrated boundaries as having child work, since they might have
    components that read from the changed context.
    
    We check this in beginWork and if it does we treat it as if the input
    has changed (same as if props changes).
    
    * Wrap in feature flag
    
    * Treat Suspense boundaries without fallbacks as if not-boundaries
    
    These don't come into play for purposes of hydration.
    
    * Fix clearing of nested suspense boundaries
    
    * ping -> retry
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Typo
    
    Co-Authored-By: sebmarkbage <sebastian@calyptus.eu>
    
    * Use didReceiveUpdate instead of manually comparing props
    
    * Leave comment for why it's ok to ignore the timeout

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index df5efdf241..e0cb09cb25 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -25,6 +25,7 @@ import {
   HostPortal,
   ContextProvider,
   SuspenseComponent,
+  DehydratedSuspenseComponent,
   IncompleteClassComponent,
 } from 'shared/ReactWorkTags';
 import {
@@ -34,7 +35,10 @@ import {
   ShouldCapture,
   LifecycleEffectMask,
 } from 'shared/ReactSideEffectTags';
-import {enableSchedulerTracing} from 'shared/ReactFeatureFlags';
+import {
+  enableSchedulerTracing,
+  enableSuspenseServerRenderer,
+} from 'shared/ReactFeatureFlags';
 import {ConcurrentMode} from './ReactTypeOfMode';
 import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
 
@@ -62,6 +66,7 @@ import {
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
+  retryTimedOutBoundary,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
@@ -73,6 +78,7 @@ import {
 } from './ReactFiberExpirationTime';
 import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
 
+const PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
 const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
 
 function createRootErrorUpdate(
@@ -144,6 +150,43 @@ function createClassErrorUpdate(
   return update;
 }
 
+function attachPingListener(
+  root: FiberRoot,
+  renderExpirationTime: ExpirationTime,
+  thenable: Thenable,
+) {
+  // Attach a listener to the promise to "ping" the root and retry. But
+  // only if one does not already exist for the current render expiration
+  // time (which acts like a "thread ID" here).
+  let pingCache = root.pingCache;
+  let threadIDs;
+  if (pingCache === null) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    threadIDs = new Set();
+    pingCache.set(thenable, threadIDs);
+  } else {
+    threadIDs = pingCache.get(thenable);
+    if (threadIDs === undefined) {
+      threadIDs = new Set();
+      pingCache.set(thenable, threadIDs);
+    }
+  }
+  if (!threadIDs.has(renderExpirationTime)) {
+    // Memoize using the thread ID to prevent redundant listeners.
+    threadIDs.add(renderExpirationTime);
+    let ping = pingSuspendedRoot.bind(
+      null,
+      root,
+      thenable,
+      renderExpirationTime,
+    );
+    if (enableSchedulerTracing) {
+      ping = Schedule_tracing_wrap(ping);
+    }
+    thenable.then(ping, ping);
+  }
+}
+
 function throwException(
   root: FiberRoot,
   returnFiber: Fiber,
@@ -198,6 +241,9 @@ function throwException(
           }
         }
       }
+      // If there is a DehydratedSuspenseComponent we don't have to do anything because
+      // if something suspends inside it, we will simply leave that as dehydrated. It
+      // will never timeout.
       workInProgress = workInProgress.return;
     } while (workInProgress !== null);
 
@@ -265,36 +311,7 @@ function throwException(
         // Confirmed that the boundary is in a concurrent mode tree. Continue
         // with the normal suspend path.
 
-        // Attach a listener to the promise to "ping" the root and retry. But
-        // only if one does not already exist for the current render expiration
-        // time (which acts like a "thread ID" here).
-        let pingCache = root.pingCache;
-        let threadIDs;
-        if (pingCache === null) {
-          pingCache = root.pingCache = new PossiblyWeakMap();
-          threadIDs = new Set();
-          pingCache.set(thenable, threadIDs);
-        } else {
-          threadIDs = pingCache.get(thenable);
-          if (threadIDs === undefined) {
-            threadIDs = new Set();
-            pingCache.set(thenable, threadIDs);
-          }
-        }
-        if (!threadIDs.has(renderExpirationTime)) {
-          // Memoize using the thread ID to prevent redundant listeners.
-          threadIDs.add(renderExpirationTime);
-          let ping = pingSuspendedRoot.bind(
-            null,
-            root,
-            thenable,
-            renderExpirationTime,
-          );
-          if (enableSchedulerTracing) {
-            ping = Schedule_tracing_wrap(ping);
-          }
-          thenable.then(ping, ping);
-        }
+        attachPingListener(root, renderExpirationTime, thenable);
 
         let absoluteTimeoutMs;
         if (earliestTimeoutMs === -1) {
@@ -331,6 +348,40 @@ function throwException(
         // whole tree.
         renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
 
+        workInProgress.effectTag |= ShouldCapture;
+        workInProgress.expirationTime = renderExpirationTime;
+        return;
+      } else if (
+        enableSuspenseServerRenderer &&
+        workInProgress.tag === DehydratedSuspenseComponent
+      ) {
+        attachPingListener(root, renderExpirationTime, thenable);
+
+        // Since we already have a current fiber, we can eagerly add a retry listener.
+        let retryCache = workInProgress.memoizedState;
+        if (retryCache === null) {
+          retryCache = workInProgress.memoizedState = new PossiblyWeakSet();
+          const current = workInProgress.alternate;
+          invariant(
+            current,
+            'A dehydrated suspense boundary must commit before trying to render. ' +
+              'This is probably a bug in React.',
+          );
+          current.memoizedState = retryCache;
+        }
+        // Memoize using the boundary fiber to prevent redundant listeners.
+        if (!retryCache.has(thenable)) {
+          retryCache.add(thenable);
+          let retry = retryTimedOutBoundary.bind(
+            null,
+            workInProgress,
+            thenable,
+          );
+          if (enableSchedulerTracing) {
+            retry = Schedule_tracing_wrap(retry);
+          }
+          thenable.then(retry, retry);
+        }
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
         return;
@@ -432,6 +483,7 @@ function unwindWork(
       return workInProgress;
     }
     case HostComponent: {
+      // TODO: popHydrationState
       popHostContext(workInProgress);
       return null;
     }
@@ -444,6 +496,18 @@ function unwindWork(
       }
       return null;
     }
+    case DehydratedSuspenseComponent: {
+      if (enableSuspenseServerRenderer) {
+        // TODO: popHydrationState
+        const effectTag = workInProgress.effectTag;
+        if (effectTag & ShouldCapture) {
+          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
+          // Captured a suspense effect. Re-render the boundary.
+          return workInProgress;
+        }
+      }
+      return null;
+    }
     case HostPortal:
       popHostContainer(workInProgress);
       return null;

commit 13645d224d66dc7d295c5e65dae4b2bb62ee174d
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue Feb 19 13:07:41 2019 -0800

    Deal with fallback content in Partial Hydration (#14884)
    
    * Replace SSR fallback content with new suspense content
    
    * The three states of a Dehydrated Suspense
    
    This introduces three states for dehydrated suspense boundaries
    
    Pending - This means that the tree is still waiting for additional data or
    to be populated with its final content.
    
    Fallback - This means that the tree has entered a permanent fallback state
    and no more data from the server is to be expected. This means that the
    client should take over and try to render instead. The fallback nodes will
    be deleted.
    
    Normal - The node has entered its final content and is now ready to be
    hydrated.
    
    * Rename retryTimedOutBoundary to resolveRetryThenable
    
    This doesn't just retry. It assumes that resolving a thenable means that
    it is ok to clear it from the thenable cache.
    
    We'll reuse the retryTimedOutBoundary logic separately.
    
    * Register a callback to be fired when a boundary changes away from pending
    
    It's now possible to switch from a pending state to either hydrating
    or replacing the content.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index e0cb09cb25..2d76a3b6b5 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -66,7 +66,7 @@ import {
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
-  retryTimedOutBoundary,
+  resolveRetryThenable,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
@@ -372,11 +372,7 @@ function throwException(
         // Memoize using the boundary fiber to prevent redundant listeners.
         if (!retryCache.has(thenable)) {
           retryCache.add(thenable);
-          let retry = retryTimedOutBoundary.bind(
-            null,
-            workInProgress,
-            thenable,
-          );
+          let retry = resolveRetryThenable.bind(null, workInProgress, thenable);
           if (enableSchedulerTracing) {
             retry = Schedule_tracing_wrap(retry);
           }

commit 45f571736cd0fe1d6c9db6cdde85fb2274b1670e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 20 16:27:59 2019 -0700

    ReactFiberScheduler -> ReactFiberScheduler.old
    
    Doing this in its own commit so history and blame are preserved.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 2d76a3b6b5..65f4c333f8 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -12,7 +12,7 @@ import type {FiberRoot} from './ReactFiberRoot';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
-import type {Thenable} from './ReactFiberScheduler';
+import type {Thenable} from './ReactFiberScheduler.old';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
@@ -67,7 +67,7 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
   resolveRetryThenable,
-} from './ReactFiberScheduler';
+} from './ReactFiberScheduler.old';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';

commit b1a56abd6aec4379c2fc9400b413f6f42d0c9b1f
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 20 16:28:33 2019 -0700

    Fork ReactFiberScheduler with feature flag
    
    Adds a feature flag `enableNewScheduler` that toggles between two
    implementations of ReactFiberScheduler. This will let us land changes in
    master while preserving the ability to quickly rollback.
    
    Ideally this will be a short-lived fork. Once we've tested the new
    scheduler for a week or so without issues, we will get rid of it. Until
    then, we'll need to maintain two parallel implementations and run tests
    against both of them. We rarely land changes to ReactFiberScheduler, so
    I don't expect this will be a huge burden.
    
    This commit does not implement anything new. The flag is still off and
    tests run against the existing implementation.
    
    Use `yarn test-new-scheduler` to run tests against the new one.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 65f4c333f8..2d76a3b6b5 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -12,7 +12,7 @@ import type {FiberRoot} from './ReactFiberRoot';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
-import type {Thenable} from './ReactFiberScheduler.old';
+import type {Thenable} from './ReactFiberScheduler';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
@@ -67,7 +67,7 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
   resolveRetryThenable,
-} from './ReactFiberScheduler.old';
+} from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';

commit 4482fddeda166b0ce4ff3e4f1d8f8b6d9b26179c
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Mon Apr 1 19:33:39 2019 +0100

    Fix host context issues around EventComponents and EventTargets (#15284)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 2d76a3b6b5..006cc5e749 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -27,6 +27,8 @@ import {
   SuspenseComponent,
   DehydratedSuspenseComponent,
   IncompleteClassComponent,
+  EventComponent,
+  EventTarget,
 } from 'shared/ReactWorkTags';
 import {
   DidCapture,
@@ -38,6 +40,7 @@ import {
 import {
   enableSchedulerTracing,
   enableSuspenseServerRenderer,
+  enableEventAPI,
 } from 'shared/ReactFeatureFlags';
 import {ConcurrentMode} from './ReactTypeOfMode';
 import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
@@ -510,6 +513,12 @@ function unwindWork(
     case ContextProvider:
       popProvider(workInProgress);
       return null;
+    case EventComponent:
+    case EventTarget:
+      if (enableEventAPI) {
+        popHostContext(workInProgress);
+      }
+      return null;
     default:
       return null;
   }

commit 4c75881ee38ba2596c5c603d268f0dff178b8581
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue Apr 2 14:27:44 2019 -0700

    Remove maxDuration from tests (#15272)
    
    We instead assume a 150ms duration.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 006cc5e749..f3b4d749df 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -232,16 +232,12 @@ function throwException(
             break;
           }
         }
-        let timeoutPropMs = workInProgress.pendingProps.maxDuration;
-        if (typeof timeoutPropMs === 'number') {
-          if (timeoutPropMs <= 0) {
-            earliestTimeoutMs = 0;
-          } else if (
-            earliestTimeoutMs === -1 ||
-            timeoutPropMs < earliestTimeoutMs
-          ) {
-            earliestTimeoutMs = timeoutPropMs;
-          }
+        const defaultSuspenseTimeout = 150;
+        if (
+          earliestTimeoutMs === -1 ||
+          defaultSuspenseTimeout < earliestTimeoutMs
+        ) {
+          earliestTimeoutMs = defaultSuspenseTimeout;
         }
       }
       // If there is a DehydratedSuspenseComponent we don't have to do anything because

commit 4d5cb64aa2beacf982cf0e01628ddda6bd92014c
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 2 15:49:07 2019 -0700

    Rewrite ReactFiberScheduler for better integration with Scheduler package (#15151)
    
    * Rewrite ReactFiberScheduler
    
    Adds a new implementation of ReactFiberScheduler behind a feature flag.
    We will maintain both implementations in parallel until the new one
    is proven stable enough to replace the old one.
    
    The main difference between the implementations is that the new one is
    integrated with the Scheduler package's priority levels.
    
    * Conditionally add fields to FiberRoot
    
    Some fields only used by the old scheduler, and some by the new.
    
    * Add separate build that enables new scheduler
    
    * Re-enable skipped test
    
    If synchronous updates are scheduled by a passive effect, that work
    should be flushed synchronously, even if flushPassiveEffects is
    called inside batchedUpdates.
    
    * Passive effects have same priority as render
    
    * Revert ability to cancel the current callback
    
    React doesn't need this anyway because it never schedules callbacks if
    it's already rendering.
    
    * Revert change to FiberDebugPerf
    
    Turns out this isn't neccessary.
    
    * Fix ReactFiberScheduler dead code elimination
    
    Should initialize to nothing, then assign the exports conditionally,
    instead of initializing to the old exports and then reassigning to the
    new ones.
    
    * Don't yield before commit during sync error retry
    
    * Call Scheduler.flushAll unconditionally in tests
    
    Instead of wrapping in enableNewScheduler flag.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index f3b4d749df..4f53408575 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -70,16 +70,12 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
   resolveRetryThenable,
+  inferStartTimeFromExpirationTime,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
 import maxSigned31BitInt from './maxSigned31BitInt';
-import {
-  Sync,
-  expirationTimeToMs,
-  LOW_PRIORITY_EXPIRATION,
-} from './ReactFiberExpirationTime';
-import {findEarliestOutstandingPriorityLevel} from './ReactFiberPendingPriority';
+import {Sync, expirationTimeToMs} from './ReactFiberExpirationTime';
 
 const PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
 const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
@@ -322,21 +318,12 @@ function throwException(
           if (startTimeMs === -1) {
             // This suspend happened outside of any already timed-out
             // placeholders. We don't know exactly when the update was
-            // scheduled, but we can infer an approximate start time from the
-            // expiration time. First, find the earliest uncommitted expiration
-            // time in the tree, including work that is suspended. Then subtract
-            // the offset used to compute an async update's expiration time.
-            // This will cause high priority (interactive) work to expire
-            // earlier than necessary, but we can account for this by adjusting
-            // for the Just Noticeable Difference.
-            const earliestExpirationTime = findEarliestOutstandingPriorityLevel(
+            // scheduled, but we can infer an approximate start time based on
+            // the expiration time and the priority.
+            startTimeMs = inferStartTimeFromExpirationTime(
               root,
               renderExpirationTime,
             );
-            const earliestExpirationTimeMs = expirationTimeToMs(
-              earliestExpirationTime,
-            );
-            startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;
           }
           absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
         }

commit 4c78ac0b9df88edec73492f92f09d5438dd74c4d
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue Apr 9 18:59:39 2019 -0700

    Track Event Time as the Start Time for Suspense (#15358)
    
    * Track the earliest event time in this render
    
    Rebase
    
    * Track the time of the fallback being shown as an event time
    
    When we switch back from fallback to content, we made progress and we track
    the time from when we showed the fallback in the first place as the
    last time we made progress.
    
    * Don't retry if synchronous
    
    * Only suspend when we switch to fallback mode
    
    This ensures that we don't resuspend unnecessarily if we're just retrying
    the same exact boundary again. We can still unnecessarily suspend
    for nested boundaries.
    
    * Rename timedOutAt to fallbackExpirationTime
    
    * Account for suspense in devtools suspense test

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 4f53408575..c6c8276733 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -13,7 +13,6 @@ import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
-import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
@@ -42,7 +41,7 @@ import {
   enableSuspenseServerRenderer,
   enableEventAPI,
 } from 'shared/ReactFeatureFlags';
-import {ConcurrentMode} from './ReactTypeOfMode';
+import {ConcurrentMode, NoContext} from './ReactTypeOfMode';
 import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
 
 import {createCapturedValue} from './ReactCapturedValue';
@@ -63,19 +62,17 @@ import {
 } from './ReactFiberContext';
 import {popProvider} from './ReactFiberNewContext';
 import {
-  renderDidSuspend,
   renderDidError,
   onUncaughtError,
   markLegacyErrorBoundaryAsFailed,
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
   resolveRetryThenable,
-  inferStartTimeFromExpirationTime,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
-import maxSigned31BitInt from './maxSigned31BitInt';
-import {Sync, expirationTimeToMs} from './ReactFiberExpirationTime';
+
+import {Sync} from './ReactFiberExpirationTime';
 
 const PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
 const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
@@ -206,44 +203,8 @@ function throwException(
     // This is a thenable.
     const thenable: Thenable = (value: any);
 
-    // Find the earliest timeout threshold of all the placeholders in the
-    // ancestor path. We could avoid this traversal by storing the thresholds on
-    // the stack, but we choose not to because we only hit this path if we're
-    // IO-bound (i.e. if something suspends). Whereas the stack is used even in
-    // the non-IO- bound case.
-    let workInProgress = returnFiber;
-    let earliestTimeoutMs = -1;
-    let startTimeMs = -1;
-    do {
-      if (workInProgress.tag === SuspenseComponent) {
-        const current = workInProgress.alternate;
-        if (current !== null) {
-          const currentState: SuspenseState | null = current.memoizedState;
-          if (currentState !== null) {
-            // Reached a boundary that already timed out. Do not search
-            // any further.
-            const timedOutAt = currentState.timedOutAt;
-            startTimeMs = expirationTimeToMs(timedOutAt);
-            // Do not search any further.
-            break;
-          }
-        }
-        const defaultSuspenseTimeout = 150;
-        if (
-          earliestTimeoutMs === -1 ||
-          defaultSuspenseTimeout < earliestTimeoutMs
-        ) {
-          earliestTimeoutMs = defaultSuspenseTimeout;
-        }
-      }
-      // If there is a DehydratedSuspenseComponent we don't have to do anything because
-      // if something suspends inside it, we will simply leave that as dehydrated. It
-      // will never timeout.
-      workInProgress = workInProgress.return;
-    } while (workInProgress !== null);
-
     // Schedule the nearest Suspense to re-render the timed out view.
-    workInProgress = returnFiber;
+    let workInProgress = returnFiber;
     do {
       if (
         workInProgress.tag === SuspenseComponent &&
@@ -270,7 +231,7 @@ function throwException(
         // Note: It doesn't matter whether the component that suspended was
         // inside a concurrent mode tree. If the Suspense is outside of it, we
         // should *not* suspend the commit.
-        if ((workInProgress.mode & ConcurrentMode) === NoEffect) {
+        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
           workInProgress.effectTag |= DidCapture;
 
           // We're going to commit this fiber even though it didn't complete.
@@ -308,32 +269,6 @@ function throwException(
 
         attachPingListener(root, renderExpirationTime, thenable);
 
-        let absoluteTimeoutMs;
-        if (earliestTimeoutMs === -1) {
-          // If no explicit threshold is given, default to an arbitrarily large
-          // value. The actual size doesn't matter because the threshold for the
-          // whole tree will be clamped to the expiration time.
-          absoluteTimeoutMs = maxSigned31BitInt;
-        } else {
-          if (startTimeMs === -1) {
-            // This suspend happened outside of any already timed-out
-            // placeholders. We don't know exactly when the update was
-            // scheduled, but we can infer an approximate start time based on
-            // the expiration time and the priority.
-            startTimeMs = inferStartTimeFromExpirationTime(
-              root,
-              renderExpirationTime,
-            );
-          }
-          absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;
-        }
-
-        // Mark the earliest timeout in the suspended fiber's ancestor path.
-        // After completing the root, we'll take the largest of all the
-        // suspended fiber's timeouts and use it to compute a timeout for the
-        // whole tree.
-        renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);
-
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
         return;

commit f9e60c8a197b8fbdaebfe4b2a9bcbcd319ea3dd5
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue May 7 16:50:04 2019 -0700

    Warn when suspending at wrong priority (#15492)
    
    * Warn when suspending at wrong priority
    
    Adds a warning when a user-blocking update is suspended.
    
    Ideally, all we would need to do is check the current priority level.
    But we currently have no rigorous way to distinguish work that was
    scheduled at user- blocking priority from work that expired a bit and
    was "upgraded" to a higher priority. That's because we don't schedule
    separate callbacks for every level, only the highest priority level per
    root. The priority of subsequent levels is inferred from the expiration
    time, but this is an imprecise heuristic.
    
    However, we do store the last discrete pending update per root. So we
    can reliably compare to that one. (If we broaden this warning to include
    high pri updates that aren't discrete, then this won't be sufficient.)
    
    My rationale is that it's better for this warning to have false
    negatives than false positives.
    
    Potential follow-ups:
    - Bikeshed more on the message. I don't like what I landed on that much
    but I think it's good enough to start.
    - Include the names of the components that updated. (The ideal place to
    fire the warning is during the setState call but we don't know if
    something will suspend until the next update. Maybe we could be clever
    and warn during a subsequent update to the same component?)
    
    * Move Suspense priority check to throwException

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index c6c8276733..79525c96ad 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -68,6 +68,7 @@ import {
   isAlreadyFailedLegacyErrorBoundary,
   pingSuspendedRoot,
   resolveRetryThenable,
+  checkForWrongSuspensePriorityInDEV,
 } from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
@@ -203,6 +204,8 @@ function throwException(
     // This is a thenable.
     const thenable: Thenable = (value: any);
 
+    checkForWrongSuspensePriorityInDEV(sourceFiber);
+
     // Schedule the nearest Suspense to re-render the timed out view.
     let workInProgress = returnFiber;
     do {

commit c7398f33966c4fedcba2c48e915b379e8f334607
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue May 7 18:08:05 2019 -0700

    Add Suspense Boundary Context (and unstable_avoidThisFallback) (#15578)
    
    * Avoidable suspense boundaries
    
    * Move the context out of SuspenseComponent
    
    * Use setDefaultShallowSuspenseContext instead of passing 0

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 79525c96ad..c0c67c2536 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -13,6 +13,7 @@ import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {CapturedValue} from './ReactCapturedValue';
 import type {Update} from './ReactUpdateQueue';
 import type {Thenable} from './ReactFiberScheduler';
+import type {SuspenseContext} from './ReactFiberSuspenseContext';
 
 import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
 import getComponentName from 'shared/getComponentName';
@@ -55,6 +56,12 @@ import {
 import {logError} from './ReactFiberCommitWork';
 import {getStackByFiberInDevAndProd} from './ReactCurrentFiber';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
+import {
+  suspenseStackCursor,
+  InvisibleParentSuspenseContext,
+  hasSuspenseContext,
+  popSuspenseContext,
+} from './ReactFiberSuspenseContext';
 import {
   isContextProvider as isLegacyContextProvider,
   popContext as popLegacyContext,
@@ -206,12 +213,17 @@ function throwException(
 
     checkForWrongSuspensePriorityInDEV(sourceFiber);
 
+    let hasInvisibleParentBoundary = hasSuspenseContext(
+      suspenseStackCursor.current,
+      (InvisibleParentSuspenseContext: SuspenseContext),
+    );
+
     // Schedule the nearest Suspense to re-render the timed out view.
     let workInProgress = returnFiber;
     do {
       if (
         workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(workInProgress)
+        shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)
       ) {
         // Found the nearest boundary.
 
@@ -274,6 +286,13 @@ function throwException(
 
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
+
+        if (!hasInvisibleParentBoundary) {
+          // TODO: If we're not in an invisible subtree, then we need to mark this render
+          // pass as needing to suspend for longer to avoid showing this fallback state.
+          // We could do it here or when we render the fallback.
+        }
+
         return;
       } else if (
         enableSuspenseServerRenderer &&
@@ -408,6 +427,7 @@ function unwindWork(
       return null;
     }
     case SuspenseComponent: {
+      popSuspenseContext(workInProgress);
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
@@ -419,6 +439,7 @@ function unwindWork(
     case DehydratedSuspenseComponent: {
       if (enableSuspenseServerRenderer) {
         // TODO: popHydrationState
+        popSuspenseContext(workInProgress);
         const effectTag = workInProgress.effectTag;
         if (effectTag & ShouldCapture) {
           workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
@@ -466,6 +487,15 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case HostPortal:
       popHostContainer(interruptedWork);
       break;
+    case SuspenseComponent:
+      popSuspenseContext(interruptedWork);
+      break;
+    case DehydratedSuspenseComponent:
+      if (enableSuspenseServerRenderer) {
+        // TODO: popHydrationState
+        popSuspenseContext(interruptedWork);
+      }
+      break;
     case ContextProvider:
       popProvider(interruptedWork);
       break;

commit 3d8b836e22981063d0396e04eefcb10fdec600ee
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu May 9 17:01:18 2019 +0100

    Event API: ensure we pop context for event system fibers (#15599)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index c0c67c2536..c1d068c679 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -499,6 +499,12 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case ContextProvider:
       popProvider(interruptedWork);
       break;
+    case EventComponent:
+    case EventTarget:
+      if (enableEventAPI) {
+        popHostContext(interruptedWork);
+      }
+      break;
     default:
       break;
   }

commit 862f499facfba9635f21c25b17368cb980b17c7e
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon May 13 14:30:39 2019 -0700

    Add Batched Mode (#15502)
    
    * Add Batched Mode
    
    React has an unfortunate quirk where updates are sometimes synchronous
    -- where React starts rendering immediately within the call stack of
    `setState` ‚Äî and sometimes batched, where updates are flushed at the
    end of the current event. Any update that originates within the call
    stack of the React event system is batched. This encompasses most
    updates, since most updates originate from an event handler like
    `onClick` or `onChange`. It also includes updates triggered by lifecycle
    methods or effects. But there are also updates that originate outside
    React's event system, like timer events, network events, and microtasks
    (promise resolution handlers). These are not batched, which results in
    both worse performance (multiple render passes instead of single one)
    and confusing semantics.
    
    Ideally all updates would be batched by default. Unfortunately, it's
    easy for components to accidentally rely on this behavior, so changing
    it could break existing apps in subtle ways.
    
    One way to move to a batched-by-default model is to opt into Concurrent
    Mode (still experimental). But Concurrent Mode introduces additional
    semantic changes that apps may not be ready to adopt.
    
    This commit introduces an additional mode called Batched Mode. Batched
    Mode enables a batched-by-default model that defers all updates to the
    next React event. Once it begins rendering, React will not yield to
    the browser until the entire render is finished.
    
    Batched Mode is superset of Strict Mode. It fires all the same warnings.
    It also drops the forked Suspense behavior used by Legacy Mode, in favor
    of the proper semantics used by Concurrent Mode.
    
    I have not added any public APIs that expose the new mode yet. I'll do
    that in subsequent commits.
    
    * Suspense in Batched Mode
    
    Should have same semantics as Concurrent Mode.
    
    * Use RootTag field to configure type of root
    
    There are three types of roots: Legacy, Batched, and Concurrent.
    
    * flushSync should not flush batched work
    
    Treat Sync and Batched expiration times separately. Only Sync updates
    are pushed to our internal queue of synchronous callbacks.
    
    Renamed `flushImmediateQueue` to `flushSyncCallbackQueue` for clarity.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index c1d068c679..1d4a4cbe23 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -42,7 +42,7 @@ import {
   enableSuspenseServerRenderer,
   enableEventAPI,
 } from 'shared/ReactFeatureFlags';
-import {ConcurrentMode, NoContext} from './ReactTypeOfMode';
+import {NoMode, BatchedMode} from './ReactTypeOfMode';
 import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
 
 import {createCapturedValue} from './ReactCapturedValue';
@@ -238,15 +238,15 @@ function throwException(
           thenables.add(thenable);
         }
 
-        // If the boundary is outside of concurrent mode, we should *not*
+        // If the boundary is outside of batched mode, we should *not*
         // suspend the commit. Pretend as if the suspended component rendered
         // null and keep rendering. In the commit phase, we'll schedule a
         // subsequent synchronous update to re-render the Suspense.
         //
         // Note: It doesn't matter whether the component that suspended was
-        // inside a concurrent mode tree. If the Suspense is outside of it, we
+        // inside a batched mode tree. If the Suspense is outside of it, we
         // should *not* suspend the commit.
-        if ((workInProgress.mode & ConcurrentMode) === NoContext) {
+        if ((workInProgress.mode & BatchedMode) === NoMode) {
           workInProgress.effectTag |= DidCapture;
 
           // We're going to commit this fiber even though it didn't complete.

commit 9c6de716d028f17736d0892d8a3d8f3ac2cb62bd
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Thu May 16 16:51:18 2019 -0700

    Add withSuspenseConfig API (#15593)
    
    * Add suspendIfNeeded API and a global scope to track it
    
    Adds a "current" suspense config that gets applied to all updates scheduled
    during the current scope.
    
    I suspect we might want to add other types of configurations to the "batch"
    so I called it the "batch config".
    
    This works across renderers/roots but they won't actually necessarily go
    into the same batch.
    
    * Add the suspenseConfig to all updates created during this scope
    
    * Compute expiration time based on the timeout of the suspense config
    
    * Track if there was a processed suspenseConfig this render pass
    
    We'll use this info to suspend a commit for longer when necessary.
    
    * Mark suspended states that should be avoided as a separate flag
    
    This lets us track which renders we want to suspend for a short time vs
    a longer time if possible.
    
    * Suspend until the full expiration time if something asked to suspend
    
    * Reenable an old test that we can now repro again
    
    * Suspend the commit even if it is complete if there is a minimum delay
    
    This can be used to implement spinners that don't flicker if the data
    and rendering is really fast.
    
    * Default timeoutMs to low pri expiration if not provided
    
    This is a required argument in the type signature but people may not
    supply it and this is a user facing object.
    
    * Rename to withSuspenseConfig and drop the default config
    
    This allow opting out of suspending in some nested scope.
    
    A lot of time when you use this function you'll use it with high level
    helpers. Those helpers often want to accept some additional configuration
    for suspense and if it should suspend at all. The easiest way is to just
    have the api accept null or a suspense config and pass it through. However,
    then you have to remember that calling suspendIfNeeded has a default.
    
    It gets simpler by just saying tat you can pass the config. You can have
    your own default in user space.
    
    * Track the largest suspense config expiration separately
    
    This ensures that if we've scheduled lower pri work that doesn't have a
    suspenseConfig, we don't consider its expiration as the timeout.
    
    * Add basic tests for functionality using each update mechanism
    
    * Fix issue when newly created avoided boundary doesn't suspend with delay
    
    * Add test for loading indicator with minLoadingDurationMs option

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 1d4a4cbe23..4db7a3a76a 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -90,7 +90,7 @@ function createRootErrorUpdate(
   errorInfo: CapturedValue<mixed>,
   expirationTime: ExpirationTime,
 ): Update<mixed> {
-  const update = createUpdate(expirationTime);
+  const update = createUpdate(expirationTime, null);
   // Unmount the root by rendering null.
   update.tag = CaptureUpdate;
   // Caution: React DevTools currently depends on this property
@@ -109,7 +109,7 @@ function createClassErrorUpdate(
   errorInfo: CapturedValue<mixed>,
   expirationTime: ExpirationTime,
 ): Update<mixed> {
-  const update = createUpdate(expirationTime);
+  const update = createUpdate(expirationTime, null);
   update.tag = CaptureUpdate;
   const getDerivedStateFromError = fiber.type.getDerivedStateFromError;
   if (typeof getDerivedStateFromError === 'function') {
@@ -265,7 +265,7 @@ function throwException(
               // When we try rendering again, we should not reuse the current fiber,
               // since it's known to be in an inconsistent state. Use a force updte to
               // prevent a bail out.
-              const update = createUpdate(Sync);
+              const update = createUpdate(Sync, null);
               update.tag = ForceUpdate;
               enqueueUpdate(sourceFiber, update);
             }
@@ -287,12 +287,6 @@ function throwException(
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
 
-        if (!hasInvisibleParentBoundary) {
-          // TODO: If we're not in an invisible subtree, then we need to mark this render
-          // pass as needing to suspend for longer to avoid showing this fallback state.
-          // We could do it here or when we render the fallback.
-        }
-
         return;
       } else if (
         enableSuspenseServerRenderer &&

commit 31487dd82e82ef62243806b2e76b23a6fb21d0bc
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Sat May 18 01:38:13 2019 +0100

    [Fresh] Set up initial scaffolding (#15619)
    
    * Add a minimal failing test for hot reload
    
    * Set up scaffolding for React Fresh
    
    * Consider type family when comparing elementType
    
    Rendering an element with stale type should not cause it to remount.
    
    We only do this for FunctionComponent tag since checking is unnecessary for classes or host components.
    
    * Add support for forwardRef()
    
    Initially I thought I would compare families of inner .render functions.
    
    However, there is a corner case where this can create false positives. Such as when you forwardRef(X) the same X twice. Those are supposed to be distinct. But if we compare .render functions, we wouldn't be able to distinguish them after first reload.
    
    It seems safer to rely on explicit registration for those. This should be easy when forwardRef() call is in the same file, and usually it would be. For cases like HOCs and style.div`...` factories that return forwardRef(), we could have the __register__ helper itself "dig deeper" and register the inner function.
    
    * Show how forwardRef inner identity can be inferred
    
    The __register__ implementation can read the inner identity itself.
    
    * Add missing __DEV__ to tests
    
    * Add support for memo() (without fixing bailouts)
    
    This adds rudimentary support for memo components. However, we don't actually skip bailouts yet, so this is not very useful by itself alone. Tests have TODOs that we need to remove after bailout skipping is done.
    
    * Refactor type comparison for clarity
    
    * Hot update shouldn't re-render ancestor components unnecessarily
    
    My code had a bug where it checked for a wrong thing in a wrong set, leading us to always re-render.
    
    This fixes the checks so that we only schedule updates for things that were actually edited.
    
    * Add test coverage for memo(fn, areEqual)
    
    * Explicitly skip bailouts for hot reloading fibers
    
    This forces even memo() with shallow comparison to re-render on hot update.
    
    * Refactor scheduling update to reduce duplication
    
    * Remove unused variable in test
    
    * Don't check presence in a set while not hot reloading
    
    * Make scheduleHotUpdate() take named arguments
    
    * Don't keep unedited component types in the type => family map
    
    It's unnecessary because if they haven't been edited, there's no special reconciliation logic.
    
    * Add signatures that force remounting
    
    Signatures let us force a remount of a type even if from React's point of view, type is the same.
    
    A type has one current signature. If that signature changes during next hot update, all Fibers with that type should be deleted and remounted.
    
    We do this by mutating elementType scheduling a parent.
    
    This will be handy to force remount of mismatching Hooks, as well as failed error boundaries.
    
    For this to fully work, we'll need to add a way to skip built-in bailouts for all Fiber types. This will be the most invasive and annoying change. I did it for HostRoot in this PR but there's more. I'll add an automated test case that catches the missing bailout bailouts.
    
    * Support forced remounting for all component types
    
    This teaches all parent component types to remount their child if necessary.
    
    It also adds tests for them.
    
    * Remount effects while preserving state for hot reloaded components
    
    This makes sure that changes to *code* always propagate.
    
    It can break components that aren't resilient to useEffect over-firing, but that seems like a good constraint since you might need to add a dependency later anyway, and this helps avoid coding yourself into the corner.
    
    * Add missing __DEV__ blocks to tests
    
    * Fix unused variables in tests
    
    * Remove outdated TODO
    
    * Expose scheduleHotUpdate directly
    
    * Inline isCompatibleType
    
    * Run one check per component for invalidating deps
    
    This also makes the bailouts more targeted--no need to remount useEffect for a parent component of remounted fiber.
    
    * Resolve .type early
    
    This moves resolving to set up the right .type early instead of doing this before render.
    A bit more future-proof in case we want to restructure the begin phase later.
    
    ForwardRef is special because its type is a wrapper but it can be hot reloaded by itself.
    So we have a special overload for it that reconstucts the wrapper type if needed.
    
    * Add a Suspense todo
    
    * Use current.type !== workInProgress.type for ignoring deps
    
    This gets rid of one of the sets.
    
    * Use workInProgress.type !== current.type check for force re-render
    
    We still use a set for forced remount though.
    
    * Use wip.type !== current.type check in more places
    
    This also disables the remounting tests. They need a separate approach.
    
    * Use a dedicated remount mechanism
    
    * Add a test for offscreen trees
    
    It has a TODO because it seems like offscreen updates are incorrectly applied too soon.
    
    * Enable offscreen test now that it is fixed
    
    * Fix corner cases in the new remounting mechanism
    
    * Remount failed error boundaries on hot reload
    
    * Fix test now that act() flushes
    
    This test is manual so I don't actually want act here.
    
    * Nits
    
    * Add comments

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 4db7a3a76a..f15815ffe3 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -56,6 +56,7 @@ import {
 import {logError} from './ReactFiberCommitWork';
 import {getStackByFiberInDevAndProd} from './ReactCurrentFiber';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
+import {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading';
 import {
   suspenseStackCursor,
   InvisibleParentSuspenseContext,
@@ -122,6 +123,9 @@ function createClassErrorUpdate(
   const inst = fiber.stateNode;
   if (inst !== null && typeof inst.componentDidCatch === 'function') {
     update.callback = function callback() {
+      if (__DEV__) {
+        markFailedErrorBoundaryForHotReloading(fiber);
+      }
       if (typeof getDerivedStateFromError !== 'function') {
         // To preserve the preexisting retry behavior of error boundaries,
         // we keep track of which ones already failed during this batch.
@@ -150,6 +154,10 @@ function createClassErrorUpdate(
         }
       }
     };
+  } else if (__DEV__) {
+    update.callback = () => {
+      markFailedErrorBoundaryForHotReloading(fiber);
+    };
   }
   return update;
 }

commit 8af1f879299e88f9e370c1f01d90efaeefcefd27
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Thu May 23 14:24:18 2019 -0700

    Rename ReactFiberScheduler -> ReactFiberWorkLoop and extract throwException from Unwind (#15725)
    
    * Rename ReactFiberScheduler to ReactFiberWorkLoop
    
    The scheduling part is mostly extracted out to the scheduler package.
    
    What's remaining is mostly around the loop around each section of work.
    I name it something with Work in it because it's very related to the
    BeginWork, CompleteWork and UnwindWork sections.
    
    * Extract throwException from UnwindWork
    
    Our throwing works more like algebraic effects in that it's a separate
    phase where we find a handler and we later unwind.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index f15815ffe3..111a9d786b 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -8,16 +8,8 @@
  */
 
 import type {Fiber} from './ReactFiber';
-import type {FiberRoot} from './ReactFiberRoot';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
-import type {CapturedValue} from './ReactCapturedValue';
-import type {Update} from './ReactUpdateQueue';
-import type {Thenable} from './ReactFiberScheduler';
-import type {SuspenseContext} from './ReactFiberSuspenseContext';
 
-import {unstable_wrap as Schedule_tracing_wrap} from 'scheduler/tracing';
-import getComponentName from 'shared/getComponentName';
-import warningWithoutStack from 'shared/warningWithoutStack';
 import {
   ClassComponent,
   HostRoot,
@@ -26,374 +18,26 @@ import {
   ContextProvider,
   SuspenseComponent,
   DehydratedSuspenseComponent,
-  IncompleteClassComponent,
   EventComponent,
   EventTarget,
 } from 'shared/ReactWorkTags';
+import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
 import {
-  DidCapture,
-  Incomplete,
-  NoEffect,
-  ShouldCapture,
-  LifecycleEffectMask,
-} from 'shared/ReactSideEffectTags';
-import {
-  enableSchedulerTracing,
   enableSuspenseServerRenderer,
   enableEventAPI,
 } from 'shared/ReactFeatureFlags';
-import {NoMode, BatchedMode} from './ReactTypeOfMode';
-import {shouldCaptureSuspense} from './ReactFiberSuspenseComponent';
 
-import {createCapturedValue} from './ReactCapturedValue';
-import {
-  enqueueCapturedUpdate,
-  createUpdate,
-  CaptureUpdate,
-  ForceUpdate,
-  enqueueUpdate,
-} from './ReactUpdateQueue';
-import {logError} from './ReactFiberCommitWork';
-import {getStackByFiberInDevAndProd} from './ReactCurrentFiber';
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
-import {markFailedErrorBoundaryForHotReloading} from './ReactFiberHotReloading';
-import {
-  suspenseStackCursor,
-  InvisibleParentSuspenseContext,
-  hasSuspenseContext,
-  popSuspenseContext,
-} from './ReactFiberSuspenseContext';
+import {popSuspenseContext} from './ReactFiberSuspenseContext';
 import {
   isContextProvider as isLegacyContextProvider,
   popContext as popLegacyContext,
   popTopLevelContextObject as popTopLevelLegacyContextObject,
 } from './ReactFiberContext';
 import {popProvider} from './ReactFiberNewContext';
-import {
-  renderDidError,
-  onUncaughtError,
-  markLegacyErrorBoundaryAsFailed,
-  isAlreadyFailedLegacyErrorBoundary,
-  pingSuspendedRoot,
-  resolveRetryThenable,
-  checkForWrongSuspensePriorityInDEV,
-} from './ReactFiberScheduler';
 
 import invariant from 'shared/invariant';
 
-import {Sync} from './ReactFiberExpirationTime';
-
-const PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;
-const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
-
-function createRootErrorUpdate(
-  fiber: Fiber,
-  errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime,
-): Update<mixed> {
-  const update = createUpdate(expirationTime, null);
-  // Unmount the root by rendering null.
-  update.tag = CaptureUpdate;
-  // Caution: React DevTools currently depends on this property
-  // being called "element".
-  update.payload = {element: null};
-  const error = errorInfo.value;
-  update.callback = () => {
-    onUncaughtError(error);
-    logError(fiber, errorInfo);
-  };
-  return update;
-}
-
-function createClassErrorUpdate(
-  fiber: Fiber,
-  errorInfo: CapturedValue<mixed>,
-  expirationTime: ExpirationTime,
-): Update<mixed> {
-  const update = createUpdate(expirationTime, null);
-  update.tag = CaptureUpdate;
-  const getDerivedStateFromError = fiber.type.getDerivedStateFromError;
-  if (typeof getDerivedStateFromError === 'function') {
-    const error = errorInfo.value;
-    update.payload = () => {
-      return getDerivedStateFromError(error);
-    };
-  }
-
-  const inst = fiber.stateNode;
-  if (inst !== null && typeof inst.componentDidCatch === 'function') {
-    update.callback = function callback() {
-      if (__DEV__) {
-        markFailedErrorBoundaryForHotReloading(fiber);
-      }
-      if (typeof getDerivedStateFromError !== 'function') {
-        // To preserve the preexisting retry behavior of error boundaries,
-        // we keep track of which ones already failed during this batch.
-        // This gets reset before we yield back to the browser.
-        // TODO: Warn in strict mode if getDerivedStateFromError is
-        // not defined.
-        markLegacyErrorBoundaryAsFailed(this);
-      }
-      const error = errorInfo.value;
-      const stack = errorInfo.stack;
-      logError(fiber, errorInfo);
-      this.componentDidCatch(error, {
-        componentStack: stack !== null ? stack : '',
-      });
-      if (__DEV__) {
-        if (typeof getDerivedStateFromError !== 'function') {
-          // If componentDidCatch is the only error boundary method defined,
-          // then it needs to call setState to recover from errors.
-          // If no state update is scheduled then the boundary will swallow the error.
-          warningWithoutStack(
-            fiber.expirationTime === Sync,
-            '%s: Error boundaries should implement getDerivedStateFromError(). ' +
-              'In that method, return a state update to display an error message or fallback UI.',
-            getComponentName(fiber.type) || 'Unknown',
-          );
-        }
-      }
-    };
-  } else if (__DEV__) {
-    update.callback = () => {
-      markFailedErrorBoundaryForHotReloading(fiber);
-    };
-  }
-  return update;
-}
-
-function attachPingListener(
-  root: FiberRoot,
-  renderExpirationTime: ExpirationTime,
-  thenable: Thenable,
-) {
-  // Attach a listener to the promise to "ping" the root and retry. But
-  // only if one does not already exist for the current render expiration
-  // time (which acts like a "thread ID" here).
-  let pingCache = root.pingCache;
-  let threadIDs;
-  if (pingCache === null) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    threadIDs = new Set();
-    pingCache.set(thenable, threadIDs);
-  } else {
-    threadIDs = pingCache.get(thenable);
-    if (threadIDs === undefined) {
-      threadIDs = new Set();
-      pingCache.set(thenable, threadIDs);
-    }
-  }
-  if (!threadIDs.has(renderExpirationTime)) {
-    // Memoize using the thread ID to prevent redundant listeners.
-    threadIDs.add(renderExpirationTime);
-    let ping = pingSuspendedRoot.bind(
-      null,
-      root,
-      thenable,
-      renderExpirationTime,
-    );
-    if (enableSchedulerTracing) {
-      ping = Schedule_tracing_wrap(ping);
-    }
-    thenable.then(ping, ping);
-  }
-}
-
-function throwException(
-  root: FiberRoot,
-  returnFiber: Fiber,
-  sourceFiber: Fiber,
-  value: mixed,
-  renderExpirationTime: ExpirationTime,
-) {
-  // The source fiber did not complete.
-  sourceFiber.effectTag |= Incomplete;
-  // Its effect list is no longer valid.
-  sourceFiber.firstEffect = sourceFiber.lastEffect = null;
-
-  if (
-    value !== null &&
-    typeof value === 'object' &&
-    typeof value.then === 'function'
-  ) {
-    // This is a thenable.
-    const thenable: Thenable = (value: any);
-
-    checkForWrongSuspensePriorityInDEV(sourceFiber);
-
-    let hasInvisibleParentBoundary = hasSuspenseContext(
-      suspenseStackCursor.current,
-      (InvisibleParentSuspenseContext: SuspenseContext),
-    );
-
-    // Schedule the nearest Suspense to re-render the timed out view.
-    let workInProgress = returnFiber;
-    do {
-      if (
-        workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)
-      ) {
-        // Found the nearest boundary.
-
-        // Stash the promise on the boundary fiber. If the boundary times out, we'll
-        // attach another listener to flip the boundary back to its normal state.
-        const thenables: Set<Thenable> = (workInProgress.updateQueue: any);
-        if (thenables === null) {
-          const updateQueue = (new Set(): any);
-          updateQueue.add(thenable);
-          workInProgress.updateQueue = updateQueue;
-        } else {
-          thenables.add(thenable);
-        }
-
-        // If the boundary is outside of batched mode, we should *not*
-        // suspend the commit. Pretend as if the suspended component rendered
-        // null and keep rendering. In the commit phase, we'll schedule a
-        // subsequent synchronous update to re-render the Suspense.
-        //
-        // Note: It doesn't matter whether the component that suspended was
-        // inside a batched mode tree. If the Suspense is outside of it, we
-        // should *not* suspend the commit.
-        if ((workInProgress.mode & BatchedMode) === NoMode) {
-          workInProgress.effectTag |= DidCapture;
-
-          // We're going to commit this fiber even though it didn't complete.
-          // But we shouldn't call any lifecycle methods or callbacks. Remove
-          // all lifecycle effect tags.
-          sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
-
-          if (sourceFiber.tag === ClassComponent) {
-            const currentSourceFiber = sourceFiber.alternate;
-            if (currentSourceFiber === null) {
-              // This is a new mount. Change the tag so it's not mistaken for a
-              // completed class component. For example, we should not call
-              // componentWillUnmount if it is deleted.
-              sourceFiber.tag = IncompleteClassComponent;
-            } else {
-              // When we try rendering again, we should not reuse the current fiber,
-              // since it's known to be in an inconsistent state. Use a force updte to
-              // prevent a bail out.
-              const update = createUpdate(Sync, null);
-              update.tag = ForceUpdate;
-              enqueueUpdate(sourceFiber, update);
-            }
-          }
-
-          // The source fiber did not complete. Mark it with Sync priority to
-          // indicate that it still has pending work.
-          sourceFiber.expirationTime = Sync;
-
-          // Exit without suspending.
-          return;
-        }
-
-        // Confirmed that the boundary is in a concurrent mode tree. Continue
-        // with the normal suspend path.
-
-        attachPingListener(root, renderExpirationTime, thenable);
-
-        workInProgress.effectTag |= ShouldCapture;
-        workInProgress.expirationTime = renderExpirationTime;
-
-        return;
-      } else if (
-        enableSuspenseServerRenderer &&
-        workInProgress.tag === DehydratedSuspenseComponent
-      ) {
-        attachPingListener(root, renderExpirationTime, thenable);
-
-        // Since we already have a current fiber, we can eagerly add a retry listener.
-        let retryCache = workInProgress.memoizedState;
-        if (retryCache === null) {
-          retryCache = workInProgress.memoizedState = new PossiblyWeakSet();
-          const current = workInProgress.alternate;
-          invariant(
-            current,
-            'A dehydrated suspense boundary must commit before trying to render. ' +
-              'This is probably a bug in React.',
-          );
-          current.memoizedState = retryCache;
-        }
-        // Memoize using the boundary fiber to prevent redundant listeners.
-        if (!retryCache.has(thenable)) {
-          retryCache.add(thenable);
-          let retry = resolveRetryThenable.bind(null, workInProgress, thenable);
-          if (enableSchedulerTracing) {
-            retry = Schedule_tracing_wrap(retry);
-          }
-          thenable.then(retry, retry);
-        }
-        workInProgress.effectTag |= ShouldCapture;
-        workInProgress.expirationTime = renderExpirationTime;
-        return;
-      }
-      // This boundary already captured during this render. Continue to the next
-      // boundary.
-      workInProgress = workInProgress.return;
-    } while (workInProgress !== null);
-    // No boundary was found. Fallthrough to error mode.
-    // TODO: Use invariant so the message is stripped in prod?
-    value = new Error(
-      (getComponentName(sourceFiber.type) || 'A React component') +
-        ' suspended while rendering, but no fallback UI was specified.\n' +
-        '\n' +
-        'Add a <Suspense fallback=...> component higher in the tree to ' +
-        'provide a loading indicator or placeholder to display.' +
-        getStackByFiberInDevAndProd(sourceFiber),
-    );
-  }
-
-  // We didn't find a boundary that could handle this type of exception. Start
-  // over and traverse parent path again, this time treating the exception
-  // as an error.
-  renderDidError();
-  value = createCapturedValue(value, sourceFiber);
-  let workInProgress = returnFiber;
-  do {
-    switch (workInProgress.tag) {
-      case HostRoot: {
-        const errorInfo = value;
-        workInProgress.effectTag |= ShouldCapture;
-        workInProgress.expirationTime = renderExpirationTime;
-        const update = createRootErrorUpdate(
-          workInProgress,
-          errorInfo,
-          renderExpirationTime,
-        );
-        enqueueCapturedUpdate(workInProgress, update);
-        return;
-      }
-      case ClassComponent:
-        // Capture and retry
-        const errorInfo = value;
-        const ctor = workInProgress.type;
-        const instance = workInProgress.stateNode;
-        if (
-          (workInProgress.effectTag & DidCapture) === NoEffect &&
-          (typeof ctor.getDerivedStateFromError === 'function' ||
-            (instance !== null &&
-              typeof instance.componentDidCatch === 'function' &&
-              !isAlreadyFailedLegacyErrorBoundary(instance)))
-        ) {
-          workInProgress.effectTag |= ShouldCapture;
-          workInProgress.expirationTime = renderExpirationTime;
-          // Schedule the error boundary to re-render using updated state
-          const update = createClassErrorUpdate(
-            workInProgress,
-            errorInfo,
-            renderExpirationTime,
-          );
-          enqueueCapturedUpdate(workInProgress, update);
-          return;
-        }
-        break;
-      default:
-        break;
-    }
-    workInProgress = workInProgress.return;
-  } while (workInProgress !== null);
-}
-
 function unwindWork(
   workInProgress: Fiber,
   renderExpirationTime: ExpirationTime,
@@ -512,10 +156,4 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
   }
 }
 
-export {
-  throwException,
-  unwindWork,
-  unwindInterruptedWork,
-  createRootErrorUpdate,
-  createClassErrorUpdate,
-};
+export {unwindWork, unwindInterruptedWork};

commit 76864f7ff729f8293e8e772da7ad8416d7def6b3
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Wed Jun 19 19:34:28 2019 -0700

    Add SuspenseList Component (#15902)
    
    * Add SuspenseList component type
    
    * Push SuspenseContext for SuspenseList
    
    * Force Suspense boundaries into their fallback state
    
    In the "together" mode, we do a second render pass that forces the
    fallbacks to stay in place, if not all can unsuspend at once.
    
    * Add test
    
    * Transfer thennables to the SuspenseList
    
    This way, we end up retrying the SuspenseList in case the nested boundary
    that just suspended doesn't actually get mounted with this set of
    thennables. This happens when the second pass renders the fallback
    directly without first attempting to render the content.
    
    * Add warning for unsupported displayOrder
    
    * Add tests for nested sibling boundaries and nested lists
    
    * Fix nested SuspenseList forwarding thennables
    
    * Rename displayOrder to revealOrder
    
    Display order has some "display list" connotations making it sound like
    a z-index thing.
    
    Reveal indicates that this isn't really about when something gets rendered
    or is ready to be rendered. It's about when content that is already there
    gets to be revealed.
    
    * Add test for avoided boundaries
    
    * Make SuspenseList a noop in legacy mode
    
    * Use an explicit suspense list state object
    
    This will be used for more things in the directional case.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 111a9d786b..db8fce69c3 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -17,6 +17,7 @@ import {
   HostPortal,
   ContextProvider,
   SuspenseComponent,
+  SuspenseListComponent,
   DehydratedSuspenseComponent,
   EventComponent,
   EventTarget,
@@ -95,6 +96,12 @@ function unwindWork(
       }
       return null;
     }
+    case SuspenseListComponent: {
+      popSuspenseContext(workInProgress);
+      // SuspenseList doesn't actually catch anything. It should've been
+      // caught by a nested boundary. If not, it should bubble through.
+      return null;
+    }
     case HostPortal:
       popHostContainer(workInProgress);
       return null;
@@ -142,6 +149,9 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
         popSuspenseContext(interruptedWork);
       }
       break;
+    case SuspenseListComponent:
+      popSuspenseContext(interruptedWork);
+      break;
     case ContextProvider:
       popProvider(interruptedWork);
       break;

commit 8b88ac2592c5f555f315f9440cbb665dd1e7457a
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Thu Jun 27 23:58:48 2019 +0100

    [Flare] Remove event targets including TouchHitTarget (#16011)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index db8fce69c3..08075ff01c 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -20,7 +20,6 @@ import {
   SuspenseListComponent,
   DehydratedSuspenseComponent,
   EventComponent,
-  EventTarget,
 } from 'shared/ReactWorkTags';
 import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
 import {
@@ -109,7 +108,6 @@ function unwindWork(
       popProvider(workInProgress);
       return null;
     case EventComponent:
-    case EventTarget:
       if (enableEventAPI) {
         popHostContext(workInProgress);
       }
@@ -156,7 +154,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
       popProvider(interruptedWork);
       break;
     case EventComponent:
-    case EventTarget:
       if (enableEventAPI) {
         popHostContext(interruptedWork);
       }

commit 9b0bd43550206e04bfe9ca695e5981eff0e2d03f
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Fri Jun 28 01:11:11 2019 +0100

    [Flare] Re-label Flare flag (#16014)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 08075ff01c..84eb065bc0 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -24,7 +24,7 @@ import {
 import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
 import {
   enableSuspenseServerRenderer,
-  enableEventAPI,
+  enableFlareAPI,
 } from 'shared/ReactFeatureFlags';
 
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
@@ -108,7 +108,7 @@ function unwindWork(
       popProvider(workInProgress);
       return null;
     case EventComponent:
-      if (enableEventAPI) {
+      if (enableFlareAPI) {
         popHostContext(workInProgress);
       }
       return null;
@@ -154,7 +154,7 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
       popProvider(interruptedWork);
       break;
     case EventComponent:
-      if (enableEventAPI) {
+      if (enableFlareAPI) {
         popHostContext(interruptedWork);
       }
       break;

commit 509889119360ed83ca6ef3f83bcf01e5aa7dcd81
Author: Dominic Gannaway <trueadm@users.noreply.github.com>
Date:   Tue Jul 23 23:46:44 2019 +0100

    [Flare] Redesign core event system (#16163)

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 84eb065bc0..3db10c23ac 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -19,13 +19,9 @@ import {
   SuspenseComponent,
   SuspenseListComponent,
   DehydratedSuspenseComponent,
-  EventComponent,
 } from 'shared/ReactWorkTags';
 import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
-import {
-  enableSuspenseServerRenderer,
-  enableFlareAPI,
-} from 'shared/ReactFeatureFlags';
+import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {popSuspenseContext} from './ReactFiberSuspenseContext';
@@ -107,11 +103,6 @@ function unwindWork(
     case ContextProvider:
       popProvider(workInProgress);
       return null;
-    case EventComponent:
-      if (enableFlareAPI) {
-        popHostContext(workInProgress);
-      }
-      return null;
     default:
       return null;
   }
@@ -153,11 +144,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case ContextProvider:
       popProvider(interruptedWork);
       break;
-    case EventComponent:
-      if (enableFlareAPI) {
-        popHostContext(interruptedWork);
-      }
-      break;
     default:
       break;
   }

commit 6f3c8332d8b2f92784a731e6cc6a707a92495a23
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Wed Aug 7 14:56:12 2019 -0700

    Reset hydration state after reentering (#16306)
    
    We might reenter a hydration state, when attempting to hydrate a boundary.
    We need to ensure that we reset it to not hydrating once we exit it.
    Otherwise the next sibling will still be in hydration mode.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 3db10c23ac..425eb7d00c 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -25,6 +25,7 @@ import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
 import {popSuspenseContext} from './ReactFiberSuspenseContext';
+import {resetHydrationState} from './ReactFiberHydrationContext';
 import {
   isContextProvider as isLegacyContextProvider,
   popContext as popLegacyContext,
@@ -80,8 +81,12 @@ function unwindWork(
     }
     case DehydratedSuspenseComponent: {
       if (enableSuspenseServerRenderer) {
-        // TODO: popHydrationState
         popSuspenseContext(workInProgress);
+        if (workInProgress.alternate === null) {
+          // TODO: popHydrationState
+        } else {
+          resetHydrationState();
+        }
         const effectTag = workInProgress.effectTag;
         if (effectTag & ShouldCapture) {
           workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
@@ -134,7 +139,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
       break;
     case DehydratedSuspenseComponent:
       if (enableSuspenseServerRenderer) {
-        // TODO: popHydrationState
         popSuspenseContext(interruptedWork);
       }
       break;

commit 50addf4c0e411e351de7290c8c60ec775c25c8c4
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Mon Aug 12 15:58:38 2019 -0700

    Refactor Partial Hydration (#16346)
    
    * Move dehydrated to be child of regular SuspenseComponent
    
    We now store the comment node on SuspenseState instead and that indicates
    that this SuspenseComponent is still dehydrated.
    
    We also store a child but that is only used to represent the DOM node for
    deletions and getNextHostSibling.
    
    * Move logic from DehydratedSuspenseComponent to SuspenseComponent
    
    Forked based on SuspenseState.dehydrated instead.
    
    * Retry logic for dehydrated boundary
    
    We can now simplify the logic for retrying dehydrated boundaries without
    hydrating. This is becomes simply a reconciliation against the dehydrated
    fragment which gets deleted, and the new children gets inserted.
    
    * Remove dehydrated from throw
    
    Instead we use the regular Suspense path. To save code, we attach retry
    listeners in the commit phase even though technically we don't have to.
    
    * Pop to nearest Suspense
    
    I think this is right...?
    
    * Popping hydration state should skip past the dehydrated instance
    
    * Split mount from update and special case suspended second pass
    
    The DidCapture flag isn't used consistently in the same way. We need
    further refactor for this.
    
    * Reorganize update path
    
    If we remove the dehydration status in the first pass and then do a second
    pass because we suspended, then we need to continue as if it didn't
    previously suspend. Since there is no fragment child etc.
    
    However, we must readd the deletion.
    
    * Schedule context work on the boundary and not the child
    
    * Warn for Suspense hydration in legacy mode
    
    It does a two pass render that client renders the content.
    
    * Rename DehydratedSuspenseComponent -> DehydratedFragment
    
    This now doesn't represent a suspense boundary itself. Its parent does.
    
    This Fiber represents the fragment around the dehydrated content.
    
    * Refactor returns
    
    Avoids the temporary mutable variables. I kept losing track of them.
    
    * Add a comment explaining the type.
    
    Placing it in the type since that's the central point as opposed to spread
    out.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 425eb7d00c..8ce3870468 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -9,6 +9,7 @@
 
 import type {Fiber} from './ReactFiber';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
 import {
   ClassComponent,
@@ -18,7 +19,6 @@ import {
   ContextProvider,
   SuspenseComponent,
   SuspenseListComponent,
-  DehydratedSuspenseComponent,
 } from 'shared/ReactWorkTags';
 import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
@@ -71,6 +71,18 @@ function unwindWork(
     }
     case SuspenseComponent: {
       popSuspenseContext(workInProgress);
+      if (enableSuspenseServerRenderer) {
+        const suspenseState: null | SuspenseState =
+          workInProgress.memoizedState;
+        if (suspenseState !== null && suspenseState.dehydrated !== null) {
+          invariant(
+            workInProgress.alternate !== null,
+            'Threw in newly mounted dehydrated component. This is likely a bug in ' +
+              'React. Please file an issue.',
+          );
+          resetHydrationState();
+        }
+      }
       const effectTag = workInProgress.effectTag;
       if (effectTag & ShouldCapture) {
         workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
@@ -79,23 +91,6 @@ function unwindWork(
       }
       return null;
     }
-    case DehydratedSuspenseComponent: {
-      if (enableSuspenseServerRenderer) {
-        popSuspenseContext(workInProgress);
-        if (workInProgress.alternate === null) {
-          // TODO: popHydrationState
-        } else {
-          resetHydrationState();
-        }
-        const effectTag = workInProgress.effectTag;
-        if (effectTag & ShouldCapture) {
-          workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-          // Captured a suspense effect. Re-render the boundary.
-          return workInProgress;
-        }
-      }
-      return null;
-    }
     case SuspenseListComponent: {
       popSuspenseContext(workInProgress);
       // SuspenseList doesn't actually catch anything. It should've been
@@ -137,11 +132,6 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case SuspenseComponent:
       popSuspenseContext(interruptedWork);
       break;
-    case DehydratedSuspenseComponent:
-      if (enableSuspenseServerRenderer) {
-        popSuspenseContext(interruptedWork);
-      }
-      break;
     case SuspenseListComponent:
       popSuspenseContext(interruptedWork);
       break;

commit 322cdcd3abfaca985a001a12247f02c5d31d311e
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed Mar 11 12:34:39 2020 -0700

    useMutableSource hook (#18000)
    
    useMutableSource hook
    
    useMutableSource() enables React components to safely and efficiently read from a mutable external source in Concurrent Mode. The API will detect mutations that occur during a render to avoid tearing and it will automatically schedule updates when the source is mutated.
    
    RFC: reactjs/rfcs#147

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 8ce3870468..2bd46b9831 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -11,6 +11,7 @@ import type {Fiber} from './ReactFiber';
 import type {ExpirationTime} from './ReactFiberExpirationTime';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 
+import {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';
 import {
   ClassComponent,
   HostRoot,
@@ -55,6 +56,7 @@ function unwindWork(
     case HostRoot: {
       popHostContainer(workInProgress);
       popTopLevelLegacyContextObject(workInProgress);
+      resetMutableSourceWorkInProgressVersions();
       const effectTag = workInProgress.effectTag;
       invariant(
         (effectTag & DidCapture) === NoEffect,
@@ -120,6 +122,7 @@ function unwindInterruptedWork(interruptedWork: Fiber) {
     case HostRoot: {
       popHostContainer(interruptedWork);
       popTopLevelLegacyContextObject(interruptedWork);
+      resetMutableSourceWorkInProgressVersions();
       break;
     }
     case HostComponent: {

commit c5d2fc7127654e43de59fff865b74765a103c4a5
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Sat Mar 21 15:22:01 2020 -0700

    Move some files out of /shared and rename to upper case (#18363)
    
    * Rename lower case isomorphic default exports modules to upper case named exports
    
    We're somewhat inconsistent here between e.g. ReactLazy and memo.
    
    Let's pick one.
    
    This also moves the responder, fundamental, scope creators from shared
    since they're isomorphic and same as the other creators.
    
    * Move some files that are specific to the react-reconciler from shared
    
    Individual renderers are allowed to deep require into the reconciler.
    
    * Move files specific to react-dom from shared
    
    react-interactions is right now dom specific (it wasn't before) so we can
    type check it together with other dom stuff. Avoids the need for
    a shared ReactDOMTypes to be checked by RN for example.
    
    * Move ReactWorkTags to the reconciler
    
    * Move createPortal to export from reconciler
    
    Otherwise Noop can't access it since it's not allowed deep requires.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 2bd46b9831..37bb664824 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -20,8 +20,8 @@ import {
   ContextProvider,
   SuspenseComponent,
   SuspenseListComponent,
-} from 'shared/ReactWorkTags';
-import {DidCapture, NoEffect, ShouldCapture} from 'shared/ReactSideEffectTags';
+} from './ReactWorkTags';
+import {DidCapture, NoEffect, ShouldCapture} from './ReactSideEffectTags';
 import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
 
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';

commit d686f3f16a796025ce32cfb431b70eef6de1934e
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 8 19:44:52 2020 -0700

    Add `.old` prefix to reconciler modules

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
deleted file mode 100644
index 37bb664824..0000000000
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ /dev/null
@@ -1,149 +0,0 @@
-/**
- * Copyright (c) Facebook, Inc. and its affiliates.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @flow
- */
-
-import type {Fiber} from './ReactFiber';
-import type {ExpirationTime} from './ReactFiberExpirationTime';
-import type {SuspenseState} from './ReactFiberSuspenseComponent';
-
-import {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';
-import {
-  ClassComponent,
-  HostRoot,
-  HostComponent,
-  HostPortal,
-  ContextProvider,
-  SuspenseComponent,
-  SuspenseListComponent,
-} from './ReactWorkTags';
-import {DidCapture, NoEffect, ShouldCapture} from './ReactSideEffectTags';
-import {enableSuspenseServerRenderer} from 'shared/ReactFeatureFlags';
-
-import {popHostContainer, popHostContext} from './ReactFiberHostContext';
-import {popSuspenseContext} from './ReactFiberSuspenseContext';
-import {resetHydrationState} from './ReactFiberHydrationContext';
-import {
-  isContextProvider as isLegacyContextProvider,
-  popContext as popLegacyContext,
-  popTopLevelContextObject as popTopLevelLegacyContextObject,
-} from './ReactFiberContext';
-import {popProvider} from './ReactFiberNewContext';
-
-import invariant from 'shared/invariant';
-
-function unwindWork(
-  workInProgress: Fiber,
-  renderExpirationTime: ExpirationTime,
-) {
-  switch (workInProgress.tag) {
-    case ClassComponent: {
-      const Component = workInProgress.type;
-      if (isLegacyContextProvider(Component)) {
-        popLegacyContext(workInProgress);
-      }
-      const effectTag = workInProgress.effectTag;
-      if (effectTag & ShouldCapture) {
-        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-        return workInProgress;
-      }
-      return null;
-    }
-    case HostRoot: {
-      popHostContainer(workInProgress);
-      popTopLevelLegacyContextObject(workInProgress);
-      resetMutableSourceWorkInProgressVersions();
-      const effectTag = workInProgress.effectTag;
-      invariant(
-        (effectTag & DidCapture) === NoEffect,
-        'The root failed to unmount after an error. This is likely a bug in ' +
-          'React. Please file an issue.',
-      );
-      workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-      return workInProgress;
-    }
-    case HostComponent: {
-      // TODO: popHydrationState
-      popHostContext(workInProgress);
-      return null;
-    }
-    case SuspenseComponent: {
-      popSuspenseContext(workInProgress);
-      if (enableSuspenseServerRenderer) {
-        const suspenseState: null | SuspenseState =
-          workInProgress.memoizedState;
-        if (suspenseState !== null && suspenseState.dehydrated !== null) {
-          invariant(
-            workInProgress.alternate !== null,
-            'Threw in newly mounted dehydrated component. This is likely a bug in ' +
-              'React. Please file an issue.',
-          );
-          resetHydrationState();
-        }
-      }
-      const effectTag = workInProgress.effectTag;
-      if (effectTag & ShouldCapture) {
-        workInProgress.effectTag = (effectTag & ~ShouldCapture) | DidCapture;
-        // Captured a suspense effect. Re-render the boundary.
-        return workInProgress;
-      }
-      return null;
-    }
-    case SuspenseListComponent: {
-      popSuspenseContext(workInProgress);
-      // SuspenseList doesn't actually catch anything. It should've been
-      // caught by a nested boundary. If not, it should bubble through.
-      return null;
-    }
-    case HostPortal:
-      popHostContainer(workInProgress);
-      return null;
-    case ContextProvider:
-      popProvider(workInProgress);
-      return null;
-    default:
-      return null;
-  }
-}
-
-function unwindInterruptedWork(interruptedWork: Fiber) {
-  switch (interruptedWork.tag) {
-    case ClassComponent: {
-      const childContextTypes = interruptedWork.type.childContextTypes;
-      if (childContextTypes !== null && childContextTypes !== undefined) {
-        popLegacyContext(interruptedWork);
-      }
-      break;
-    }
-    case HostRoot: {
-      popHostContainer(interruptedWork);
-      popTopLevelLegacyContextObject(interruptedWork);
-      resetMutableSourceWorkInProgressVersions();
-      break;
-    }
-    case HostComponent: {
-      popHostContext(interruptedWork);
-      break;
-    }
-    case HostPortal:
-      popHostContainer(interruptedWork);
-      break;
-    case SuspenseComponent:
-      popSuspenseContext(interruptedWork);
-      break;
-    case SuspenseListComponent:
-      popSuspenseContext(interruptedWork);
-      break;
-    case ContextProvider:
-      popProvider(interruptedWork);
-      break;
-    default:
-      break;
-  }
-}
-
-export {unwindWork, unwindInterruptedWork};

commit f101c2d0d3a6cb5a788a3d91faef48462e45f515
Author: Jan Kassens <jkassens@meta.com>
Date:   Thu Dec 1 23:19:13 2022 -0500

    Remove Reconciler fork (2/2) (#25775)
    
    We've heard from multiple contributors that the Reconciler forking
    mechanism was confusing and/or annoying to deal with. Since it's
    currently unused and there's no immediate plans to start using it again,
    this removes the forking.
    
    Fully removing the fork is split into 2 steps to preserve file history:
    
    **#25774 previous PR that did the bulk of the work:**
    - remove `enableNewReconciler` feature flag.
    - remove `unstable_isNewReconciler` export
    - remove eslint rules for cross fork imports
    - remove `*.new.js` files and update imports
    - merge non-suffixed files into `*.old` files where both exist
    (sometimes types were defined there)
    
    **This PR**
    - rename `*.old` files

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
new file mode 100644
index 0000000000..d6e7e500b5
--- /dev/null
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -0,0 +1,285 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ */
+
+import type {ReactContext} from 'shared/ReactTypes';
+import type {Fiber, FiberRoot} from './ReactInternalTypes';
+import type {Lanes} from './ReactFiberLane';
+import type {SuspenseState} from './ReactFiberSuspenseComponent';
+import type {Cache} from './ReactFiberCacheComponent';
+import type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';
+
+import {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';
+import {
+  ClassComponent,
+  HostRoot,
+  HostComponent,
+  HostResource,
+  HostSingleton,
+  HostPortal,
+  ContextProvider,
+  SuspenseComponent,
+  SuspenseListComponent,
+  OffscreenComponent,
+  LegacyHiddenComponent,
+  CacheComponent,
+  TracingMarkerComponent,
+} from './ReactWorkTags';
+import {DidCapture, NoFlags, ShouldCapture} from './ReactFiberFlags';
+import {NoMode, ProfileMode} from './ReactTypeOfMode';
+import {
+  enableProfilerTimer,
+  enableCache,
+  enableTransitionTracing,
+} from 'shared/ReactFeatureFlags';
+
+import {popHostContainer, popHostContext} from './ReactFiberHostContext';
+import {
+  popSuspenseListContext,
+  popSuspenseHandler,
+} from './ReactFiberSuspenseContext';
+import {popHiddenContext} from './ReactFiberHiddenContext';
+import {resetHydrationState} from './ReactFiberHydrationContext';
+import {
+  isContextProvider as isLegacyContextProvider,
+  popContext as popLegacyContext,
+  popTopLevelContextObject as popTopLevelLegacyContextObject,
+} from './ReactFiberContext';
+import {popProvider} from './ReactFiberNewContext';
+import {popCacheProvider} from './ReactFiberCacheComponent';
+import {transferActualDuration} from './ReactProfilerTimer';
+import {popTreeContext} from './ReactFiberTreeContext';
+import {popRootTransition, popTransition} from './ReactFiberTransition';
+import {
+  popMarkerInstance,
+  popRootMarkerInstance,
+} from './ReactFiberTracingMarkerComponent';
+
+function unwindWork(
+  current: Fiber | null,
+  workInProgress: Fiber,
+  renderLanes: Lanes,
+): Fiber | null {
+  // Note: This intentionally doesn't check if we're hydrating because comparing
+  // to the current tree provider fiber is just as fast and less error-prone.
+  // Ideally we would have a special version of the work loop only
+  // for hydration.
+  popTreeContext(workInProgress);
+  switch (workInProgress.tag) {
+    case ClassComponent: {
+      const Component = workInProgress.type;
+      if (isLegacyContextProvider(Component)) {
+        popLegacyContext(workInProgress);
+      }
+      const flags = workInProgress.flags;
+      if (flags & ShouldCapture) {
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+        if (
+          enableProfilerTimer &&
+          (workInProgress.mode & ProfileMode) !== NoMode
+        ) {
+          transferActualDuration(workInProgress);
+        }
+        return workInProgress;
+      }
+      return null;
+    }
+    case HostRoot: {
+      const root: FiberRoot = workInProgress.stateNode;
+      if (enableCache) {
+        const cache: Cache = workInProgress.memoizedState.cache;
+        popCacheProvider(workInProgress, cache);
+      }
+
+      if (enableTransitionTracing) {
+        popRootMarkerInstance(workInProgress);
+      }
+
+      popRootTransition(workInProgress, root, renderLanes);
+      popHostContainer(workInProgress);
+      popTopLevelLegacyContextObject(workInProgress);
+      resetMutableSourceWorkInProgressVersions();
+      const flags = workInProgress.flags;
+      if (
+        (flags & ShouldCapture) !== NoFlags &&
+        (flags & DidCapture) === NoFlags
+      ) {
+        // There was an error during render that wasn't captured by a suspense
+        // boundary. Do a second pass on the root to unmount the children.
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+        return workInProgress;
+      }
+      // We unwound to the root without completing it. Exit.
+      return null;
+    }
+    case HostResource:
+    case HostSingleton:
+    case HostComponent: {
+      // TODO: popHydrationState
+      popHostContext(workInProgress);
+      return null;
+    }
+    case SuspenseComponent: {
+      popSuspenseHandler(workInProgress);
+      const suspenseState: null | SuspenseState = workInProgress.memoizedState;
+      if (suspenseState !== null && suspenseState.dehydrated !== null) {
+        if (workInProgress.alternate === null) {
+          throw new Error(
+            'Threw in newly mounted dehydrated component. This is likely a bug in ' +
+              'React. Please file an issue.',
+          );
+        }
+
+        resetHydrationState();
+      }
+
+      const flags = workInProgress.flags;
+      if (flags & ShouldCapture) {
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Re-render the boundary.
+        if (
+          enableProfilerTimer &&
+          (workInProgress.mode & ProfileMode) !== NoMode
+        ) {
+          transferActualDuration(workInProgress);
+        }
+        return workInProgress;
+      }
+      return null;
+    }
+    case SuspenseListComponent: {
+      popSuspenseListContext(workInProgress);
+      // SuspenseList doesn't actually catch anything. It should've been
+      // caught by a nested boundary. If not, it should bubble through.
+      return null;
+    }
+    case HostPortal:
+      popHostContainer(workInProgress);
+      return null;
+    case ContextProvider:
+      const context: ReactContext<any> = workInProgress.type._context;
+      popProvider(context, workInProgress);
+      return null;
+    case OffscreenComponent:
+    case LegacyHiddenComponent: {
+      popSuspenseHandler(workInProgress);
+      popHiddenContext(workInProgress);
+      popTransition(workInProgress, current);
+      const flags = workInProgress.flags;
+      if (flags & ShouldCapture) {
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Re-render the boundary.
+        if (
+          enableProfilerTimer &&
+          (workInProgress.mode & ProfileMode) !== NoMode
+        ) {
+          transferActualDuration(workInProgress);
+        }
+        return workInProgress;
+      }
+      return null;
+    }
+    case CacheComponent:
+      if (enableCache) {
+        const cache: Cache = workInProgress.memoizedState.cache;
+        popCacheProvider(workInProgress, cache);
+      }
+      return null;
+    case TracingMarkerComponent:
+      if (enableTransitionTracing) {
+        if (workInProgress.stateNode !== null) {
+          popMarkerInstance(workInProgress);
+        }
+      }
+      return null;
+    default:
+      return null;
+  }
+}
+
+function unwindInterruptedWork(
+  current: Fiber | null,
+  interruptedWork: Fiber,
+  renderLanes: Lanes,
+) {
+  // Note: This intentionally doesn't check if we're hydrating because comparing
+  // to the current tree provider fiber is just as fast and less error-prone.
+  // Ideally we would have a special version of the work loop only
+  // for hydration.
+  popTreeContext(interruptedWork);
+  switch (interruptedWork.tag) {
+    case ClassComponent: {
+      const childContextTypes = interruptedWork.type.childContextTypes;
+      if (childContextTypes !== null && childContextTypes !== undefined) {
+        popLegacyContext(interruptedWork);
+      }
+      break;
+    }
+    case HostRoot: {
+      const root: FiberRoot = interruptedWork.stateNode;
+      if (enableCache) {
+        const cache: Cache = interruptedWork.memoizedState.cache;
+        popCacheProvider(interruptedWork, cache);
+      }
+
+      if (enableTransitionTracing) {
+        popRootMarkerInstance(interruptedWork);
+      }
+
+      popRootTransition(interruptedWork, root, renderLanes);
+      popHostContainer(interruptedWork);
+      popTopLevelLegacyContextObject(interruptedWork);
+      resetMutableSourceWorkInProgressVersions();
+      break;
+    }
+    case HostResource:
+    case HostSingleton:
+    case HostComponent: {
+      popHostContext(interruptedWork);
+      break;
+    }
+    case HostPortal:
+      popHostContainer(interruptedWork);
+      break;
+    case SuspenseComponent:
+      popSuspenseHandler(interruptedWork);
+      break;
+    case SuspenseListComponent:
+      popSuspenseListContext(interruptedWork);
+      break;
+    case ContextProvider:
+      const context: ReactContext<any> = interruptedWork.type._context;
+      popProvider(context, interruptedWork);
+      break;
+    case OffscreenComponent:
+    case LegacyHiddenComponent:
+      popSuspenseHandler(interruptedWork);
+      popHiddenContext(interruptedWork);
+      popTransition(interruptedWork, current);
+      break;
+    case CacheComponent:
+      if (enableCache) {
+        const cache: Cache = interruptedWork.memoizedState.cache;
+        popCacheProvider(interruptedWork, cache);
+      }
+      break;
+    case TracingMarkerComponent:
+      if (enableTransitionTracing) {
+        const instance: TracingMarkerInstance | null =
+          interruptedWork.stateNode;
+        if (instance !== null) {
+          popMarkerInstance(interruptedWork);
+        }
+      }
+      break;
+    default:
+      break;
+  }
+}
+
+export {unwindWork, unwindInterruptedWork};

commit 6396b664118442f3c2eae7bf13732fcb27bda98f
Author: Josh Story <story@hey.com>
Date:   Thu Feb 9 22:59:29 2023 -0800

    Model Float on Hoistables semantics (#26106)
    
    ## Hoistables
    
    In the original implementation of Float, all hoisted elements were
    treated like Resources. They had deduplication semantics and hydrated
    based on a key. This made certain kinds of hoists very challenging such
    as sequences of meta tags for `og:image:...` metadata. The reason is
    each tag along is not dedupable based on only it's intrinsic properties.
    two identical tags may need to be included and hoisted together with
    preceding meta tags that describe a semantic object with a linear set of
    html nodes.
    
    It was clear that the concept of Browser Resources (stylesheets /
    scripts / preloads) did not extend universally to all hositable tags
    (title, meta, other links, etc...)
    
    Additionally while Resources benefit from deduping they suffer an
    inability to update because while we may have multiple rendered elements
    that refer to a single Resource it isn't unambiguous which element owns
    the props on the underlying resource. We could try merging props, but
    that is still really hard to reason about for authors. Instead we
    restrict Resource semantics to freezing the props at the time the
    Resource is first constructed and warn if you attempt to render the same
    Resource with different props via another rendered element or by
    updating an existing element for that Resource.
    
    This lack of updating restriction is however way more extreme than
    necessary for instances that get hoisted but otherwise do not dedupe;
    where there is a well defined DOM instance for each rendered element. We
    should be able to update props on these instances.
    
    Hoistable is a generalization of what Float tries to model for hoisting.
    Instead of assuming every hoistable element is a Resource we now have
    two distinct categories, hoistable elements and hoistable resources. As
    one might guess the former has semantics that match regular Host
    Components except the placement of the node is usually in the <head>.
    The latter continues to behave how the original implementation of
    HostResource behaved with the first iteration of Float
    
    ### Hoistable Element
    On the server hoistable elements render just like regular tags except
    the output is stored in special queues that can be emitted in the stream
    earlier than they otherwise would be if rendered in place. This also
    allow for instance the ability to render a hoistable before even
    rendering the <html> tag because the queues for hoistable elements won't
    flush until after we have flushed the preamble (`<DOCTYPE
    html><html><head>`).
    
    On the client, hoistable elements largely operate like HostComponents.
    The most notable difference is in the hydration strategy. If we are
    hydrating and encounter a hoistable element we will look for all tags in
    the document that could potentially be a match and we check whether the
    attributes match the props for this particular instance. We also do this
    in the commit phase rather than the render phase. The reason hydration
    can be done for HostComponents in render is the instance will be removed
    from the document if hydration fails so mutating it in render is safe.
    For hoistables the nodes are not in a hydration boundary (Root or
    SuspenseBoundary at time of writing) and thus if hydration fails and we
    may have an instance marked as bound to some Fiber when that Fiber never
    commits. Moving the hydration matching to commit ensures we will always
    succeed in pairing the hoisted DOM instance with a Fiber that has
    committed.
    
    ### Hoistable Resource
    On the server and client the semantics of Resources are largely the same
    they just don't apply to title, meta, and most link tags anymore.
    Resources hoist and dedupe via an `href` key and are ref counted. In a
    future update we will add a garbage collector so we can clean up
    Resources that no longer have any references
    
    ## `<style>` support
    In earlier implementations there was no support for <style> tags. This
    PR adds support for treating `<style href="..."
    precedence="...">...</style>` as a Resource analagous to `<link
    rel="stylesheet" href="..." precedence="..." />`
    
    It may seem odd at first to require an href to get Resource semantics
    for a style tag. The rationale is that these are for inlining of actual
    external stylesheets as an optimization and for URI like scoping of
    inline styles for css-in-js libraries. The href indicates that the key
    space for `<style>` and `<link rel="stylesheet" />` Resources is shared.
    and the precedence is there to allow for interleaving of both kinds of
    Style resources. This is an advanced feature that we do not expect most
    app developers to use directly but will be quite handy for various
    styling libraries and for folks who want to inline as much as possible
    once Fizz supports this feature.
    
    ## refactor notes
    * HostResource Fiber type is renamed HostHoistable to reflect the
    generalization of the concept
    * The Resource object representation is modified to reduce hidden class
    checks and to use less memory overall
    * The thing that distinguishes a resource from an element is whether the
    Fiber has a memoizedState. If it does, it will use resource semantics,
    otherwise element semantics
    * The time complexity of matching hositable elements for hydration
    should be improved

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index d6e7e500b5..592596e5ec 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -19,7 +19,7 @@ import {
   ClassComponent,
   HostRoot,
   HostComponent,
-  HostResource,
+  HostHoistable,
   HostSingleton,
   HostPortal,
   ContextProvider,
@@ -117,7 +117,7 @@ function unwindWork(
       // We unwound to the root without completing it. Exit.
       return null;
     }
-    case HostResource:
+    case HostHoistable:
     case HostSingleton:
     case HostComponent: {
       // TODO: popHydrationState
@@ -237,7 +237,7 @@ function unwindInterruptedWork(
       resetMutableSourceWorkInProgressVersions();
       break;
     }
-    case HostResource:
+    case HostHoistable:
     case HostSingleton:
     case HostComponent: {
       popHostContext(interruptedWork);

commit 80d9a40114bb43c07d021e8254790852f450bd2b
Author: Noah Lemen <noah.lemen@gmail.com>
Date:   Tue Jun 27 12:45:46 2023 -0400

    Remove useMutableSource (#27011)
    
    ## Summary
    
    This PR cleans up `useMutableSource`. This has been blocked by a
    remaining dependency internally at Meta, but that has now been deleted.
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    
    ## How did you test this change?
    
    ```
    yarn flow
    yarn lint
    yarn test --prod
    ```
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index 592596e5ec..fdbd3357ed 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -14,7 +14,6 @@ import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {Cache} from './ReactFiberCacheComponent';
 import type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';
 
-import {resetWorkInProgressVersions as resetMutableSourceWorkInProgressVersions} from './ReactMutableSource';
 import {
   ClassComponent,
   HostRoot,
@@ -103,7 +102,6 @@ function unwindWork(
       popRootTransition(workInProgress, root, renderLanes);
       popHostContainer(workInProgress);
       popTopLevelLegacyContextObject(workInProgress);
-      resetMutableSourceWorkInProgressVersions();
       const flags = workInProgress.flags;
       if (
         (flags & ShouldCapture) !== NoFlags &&
@@ -234,7 +232,6 @@ function unwindInterruptedWork(
       popRootTransition(interruptedWork, root, renderLanes);
       popHostContainer(interruptedWork);
       popTopLevelLegacyContextObject(interruptedWork);
-      resetMutableSourceWorkInProgressVersions();
       break;
     }
     case HostHoistable:

commit 14fd9630ee04387f4361da289393234e2b7d93b6
Author: dan <dan.abramov@me.com>
Date:   Tue Feb 13 15:04:49 2024 +0000

    Switch <Context> to mean <Context.Provider> (#28226)
    
    Previously, `<Context>` was equivalent to `<Context.Consumer>`. However,
    since the introduction of Hooks, the `<Context.Consumer>` API is rarely
    used. The goal here is to make the common case cleaner:
    
    ```js
    const ThemeContext = createContext('light')
    
    function App() {
      return (
        <ThemeContext value="dark">
          ...
        </ThemeContext>
      )
    }
    
    function Button() {
      const theme = use(ThemeContext)
      // ...
    }
    ```
    
    This is technically a breaking change, but we've been warning about
    rendering `<Context>` directly for several years by now, so it's
    unlikely much code in the wild depends on the old behavior. [Proof that
    it warns today (check
    console).](https://codesandbox.io/p/sandbox/peaceful-nobel-pdxtfl)
    
    ---
    
    **The relevant commit is 5696782b428a5ace96e66c1857e13249b6c07958.** It
    switches `createContext` implementation so that `Context.Provider ===
    Context`.
    
    The main assumption that changed is that a Provider's fiber type is now
    the context itself (rather than an intermediate object). Whereas a
    Consumer's fiber type is now always an intermediate object (rather than
    it being sometimes the context itself and sometimes an intermediate
    object).
    
    My methodology was to start with the relevant symbols, work tags, and
    types, and work my way backwards to all usages.
    
    This might break tooling that depends on inspecting React's internal
    fields. I've added DevTools support in the second commit. This didn't
    need explicit versioning‚Äîthe structure tells us enough.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index fdbd3357ed..cc77647cb8 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -35,6 +35,7 @@ import {
   enableProfilerTimer,
   enableCache,
   enableTransitionTracing,
+  enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
 
 import {popHostContainer, popHostContext} from './ReactFiberHostContext';
@@ -160,7 +161,12 @@ function unwindWork(
       popHostContainer(workInProgress);
       return null;
     case ContextProvider:
-      const context: ReactContext<any> = workInProgress.type._context;
+      let context: ReactContext<any>;
+      if (enableRenderableContext) {
+        context = workInProgress.type;
+      } else {
+        context = workInProgress.type._context;
+      }
       popProvider(context, workInProgress);
       return null;
     case OffscreenComponent:
@@ -250,7 +256,12 @@ function unwindInterruptedWork(
       popSuspenseListContext(interruptedWork);
       break;
     case ContextProvider:
-      const context: ReactContext<any> = interruptedWork.type._context;
+      let context: ReactContext<any>;
+      if (enableRenderableContext) {
+        context = interruptedWork.type;
+      } else {
+        context = interruptedWork.type._context;
+      }
       popProvider(context, interruptedWork);
       break;
     case OffscreenComponent:

commit e06c72fcf4632ad3117add713a25f6354631f037
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Sun Dec 15 12:34:08 2024 -0500

    [flags] Cleanup enableCache (#31778)
    
    This is landed everywhere

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index cc77647cb8..cdc887b5af 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -33,7 +33,6 @@ import {DidCapture, NoFlags, ShouldCapture} from './ReactFiberFlags';
 import {NoMode, ProfileMode} from './ReactTypeOfMode';
 import {
   enableProfilerTimer,
-  enableCache,
   enableTransitionTracing,
   enableRenderableContext,
 } from 'shared/ReactFeatureFlags';
@@ -91,10 +90,8 @@ function unwindWork(
     }
     case HostRoot: {
       const root: FiberRoot = workInProgress.stateNode;
-      if (enableCache) {
-        const cache: Cache = workInProgress.memoizedState.cache;
-        popCacheProvider(workInProgress, cache);
-      }
+      const cache: Cache = workInProgress.memoizedState.cache;
+      popCacheProvider(workInProgress, cache);
 
       if (enableTransitionTracing) {
         popRootMarkerInstance(workInProgress);
@@ -189,10 +186,8 @@ function unwindWork(
       return null;
     }
     case CacheComponent:
-      if (enableCache) {
-        const cache: Cache = workInProgress.memoizedState.cache;
-        popCacheProvider(workInProgress, cache);
-      }
+      const cache: Cache = workInProgress.memoizedState.cache;
+      popCacheProvider(workInProgress, cache);
       return null;
     case TracingMarkerComponent:
       if (enableTransitionTracing) {
@@ -226,10 +221,8 @@ function unwindInterruptedWork(
     }
     case HostRoot: {
       const root: FiberRoot = interruptedWork.stateNode;
-      if (enableCache) {
-        const cache: Cache = interruptedWork.memoizedState.cache;
-        popCacheProvider(interruptedWork, cache);
-      }
+      const cache: Cache = interruptedWork.memoizedState.cache;
+      popCacheProvider(interruptedWork, cache);
 
       if (enableTransitionTracing) {
         popRootMarkerInstance(interruptedWork);
@@ -271,10 +264,8 @@ function unwindInterruptedWork(
       popTransition(interruptedWork, current);
       break;
     case CacheComponent:
-      if (enableCache) {
-        const cache: Cache = interruptedWork.memoizedState.cache;
-        popCacheProvider(interruptedWork, cache);
-      }
+      const cache: Cache = interruptedWork.memoizedState.cache;
+      popCacheProvider(interruptedWork, cache);
       break;
     case TracingMarkerComponent:
       if (enableTransitionTracing) {

commit 3ef31d196a83e45d4c70b300a265a9c657c386b4
Author: Sebastian Markb√•ge <sebastian@calyptus.eu>
Date:   Tue Apr 22 21:00:30 2025 -0400

    Implement Partial Hydration for Activity (#32863)
    
    Stacked on #32862 and #32842.
    
    This means that Activity boundaries now act as boundaries which can have
    their effects mounted independently. Just like Suspense boundaries, we
    hydrate the outer content first and then start hydrating the content in
    an Offscreen lane. Flowing props or interacting with the content
    increases the priority just like Suspense boundaries.
    
    This skips emitting even the comments for `<Activity mode="hidden">` so
    we don't hydrate those. Instead those are deferred to a later client
    render.
    
    The implementation are just forked copies of the SuspenseComponent
    branches and then carefully going through each line and tweaking it.
    
    The main interesting bit is that, unlike Suspense, Activity boundaries
    don't have fallbacks so all those branches where you might commit a
    suspended tree disappears. Instead, if something suspends while
    hydration, we can just leave the dehydrated content in place. However,
    if something does suspend during client rendering then it should bubble
    up to the parent. Therefore, we have to be careful to only
    pushSuspenseHandler when hydrating. That's really the main difference.
    
    This just uses the existing basic Activity tests but I've started work
    on port all of the applicable Suspense tests in SelectiveHydration-test
    and PartialHydration-test to Activity versions.

diff --git a/packages/react-reconciler/src/ReactFiberUnwindWork.js b/packages/react-reconciler/src/ReactFiberUnwindWork.js
index cdc887b5af..a1d3797cd1 100644
--- a/packages/react-reconciler/src/ReactFiberUnwindWork.js
+++ b/packages/react-reconciler/src/ReactFiberUnwindWork.js
@@ -10,6 +10,7 @@
 import type {ReactContext} from 'shared/ReactTypes';
 import type {Fiber, FiberRoot} from './ReactInternalTypes';
 import type {Lanes} from './ReactFiberLane';
+import type {ActivityState} from './ReactFiberActivityComponent';
 import type {SuspenseState} from './ReactFiberSuspenseComponent';
 import type {Cache} from './ReactFiberCacheComponent';
 import type {TracingMarkerInstance} from './ReactFiberTracingMarkerComponent';
@@ -22,6 +23,7 @@ import {
   HostSingleton,
   HostPortal,
   ContextProvider,
+  ActivityComponent,
   SuspenseComponent,
   SuspenseListComponent,
   OffscreenComponent,
@@ -120,6 +122,35 @@ function unwindWork(
       popHostContext(workInProgress);
       return null;
     }
+    case ActivityComponent: {
+      const activityState: null | ActivityState = workInProgress.memoizedState;
+      if (activityState !== null) {
+        popSuspenseHandler(workInProgress);
+
+        if (workInProgress.alternate === null) {
+          throw new Error(
+            'Threw in newly mounted dehydrated component. This is likely a bug in ' +
+              'React. Please file an issue.',
+          );
+        }
+
+        resetHydrationState();
+      }
+
+      const flags = workInProgress.flags;
+      if (flags & ShouldCapture) {
+        workInProgress.flags = (flags & ~ShouldCapture) | DidCapture;
+        // Captured a suspense effect. Re-render the boundary.
+        if (
+          enableProfilerTimer &&
+          (workInProgress.mode & ProfileMode) !== NoMode
+        ) {
+          transferActualDuration(workInProgress);
+        }
+        return workInProgress;
+      }
+      return null;
+    }
     case SuspenseComponent: {
       popSuspenseHandler(workInProgress);
       const suspenseState: null | SuspenseState = workInProgress.memoizedState;
@@ -242,6 +273,12 @@ function unwindInterruptedWork(
     case HostPortal:
       popHostContainer(interruptedWork);
       break;
+    case ActivityComponent: {
+      if (interruptedWork.memoizedState !== null) {
+        popSuspenseHandler(interruptedWork);
+      }
+      break;
+    }
     case SuspenseComponent:
       popSuspenseHandler(interruptedWork);
       break;

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    