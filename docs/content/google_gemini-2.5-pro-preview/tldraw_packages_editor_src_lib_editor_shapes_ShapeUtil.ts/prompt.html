<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/editor/src/lib/editor/shapes/ShapeUtil.ts - Gemini 2.5 Pro 05-06</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/editor/src/lib/editor/shapes/ShapeUtil.ts</h1>
        <h2>Model: Gemini 2.5 Pro 05-06</h2>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview/tldraw_packages_editor_src_lib_editor_shapes_ShapeUtil.ts.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/editor/src/lib/editor/shapes/ShapeUtil.ts

commit 7b03ef9d0c6244c00de7bf92d3c022e2873977fa
Author: alex <alex@dytry.ch>
Date:   Mon Jun 12 16:39:50 2023 +0100

    shapes folder, move tools into shape defs (#1574)
    
    This diff adds a new property to `defineShape`: `tool`.
    
    The tool prop allows shapes to bring a tool along with them as part of
    their definition. E.g. the draw shape isn't much use without the draw
    tool, so adding the draw shape to your app gives you the draw tool tool.
    
    As part of this, i renamed the `shapeutils` folder to just `shapes`, and
    moved a bunch of shape-specific tools from the tools folder into the
    shapes folder. This more closely reflects how things will be once we
    move our default shapes out of core for tldraw-zero.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    Tested locally
    
    ### Release Notes
    
    n/a

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
new file mode 100644
index 000000000..2cb9754e5
--- /dev/null
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -0,0 +1,734 @@
+/* eslint-disable @typescript-eslint/no-unused-vars */
+import { Box2d, linesIntersect, Matrix2d, VecLike } from '@tldraw/primitives'
+import { ComputedCache } from '@tldraw/store'
+import { TLHandle, TLShape, TLShapePartial, TLUnknownShape, Vec2dModel } from '@tldraw/tlschema'
+import { computed, EMPTY_ARRAY } from 'signia'
+import { WeakMapCache } from '../../utils/WeakMapCache'
+import type { Editor } from '../Editor'
+import { TLResizeHandle } from '../types/selection-types'
+import { TLExportColors } from './shared/TLExportColors'
+
+const points = new WeakMapCache<TLShape, Vec2dModel>()
+const transforms = new WeakMapCache<TLShape, Matrix2d>()
+
+/** @public */
+export interface TLShapeUtilConstructor<
+	T extends TLUnknownShape,
+	U extends ShapeUtil<T> = ShapeUtil<T>
+> {
+	new (editor: Editor, type: T['type']): U
+	type: T['type']
+}
+
+/** @public */
+export type TLShapeUtilFlag<T> = (shape: T) => boolean
+
+/** @public */
+export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
+	constructor(public editor: Editor, public readonly type: T['type']) {}
+
+	/**
+	 * The type of the shape util, which should match the shape's type.
+	 *
+	 * @public
+	 */
+	static type: string
+
+	/**
+	 * Whether the shape can be scrolled while editing.
+	 *
+	 * @public
+	 */
+	canScroll: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
+	 *
+	 * @public
+	 */
+	canUnmount: TLShapeUtilFlag<T> = () => true
+
+	/**
+	 * Whether the shape can be bound to by an arrow.
+	 *
+	 * @param _otherShape - The other shape attempting to bind to this shape.
+	 * @public
+	 */
+	canBind = <K>(_shape: T, _otherShape?: K) => true
+
+	/**
+	 * Whether the shape can be double clicked to edit.
+	 *
+	 * @public
+	 */
+	canEdit: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape can be resized.
+	 *
+	 * @public
+	 */
+	canResize: TLShapeUtilFlag<T> = () => true
+
+	/**
+	 * Whether the shape can be cropped.
+	 *
+	 * @public
+	 */
+	canCrop: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Bounds of the shape to edit.
+	 *
+	 * Note: this could be a text area within a shape for example arrow labels.
+	 *
+	 * @public
+	 */
+	getEditingBounds = (shape: T) => {
+		return this.bounds(shape)
+	}
+
+	/**
+	 * Whether the shape's outline is closed.
+	 *
+	 * @public
+	 */
+	isClosed: TLShapeUtilFlag<T> = () => true
+
+	/**
+	 * Whether the shape should hide its resize handles when selected.
+	 *
+	 * @public
+	 */
+	hideResizeHandles: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape should hide its resize handles when selected.
+	 *
+	 * @public
+	 */
+	hideRotateHandle: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape should hide its selection bounds background when selected.
+	 *
+	 * @public
+	 */
+	hideSelectionBoundsBg: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape should hide its selection bounds foreground when selected.
+	 *
+	 * @public
+	 */
+	hideSelectionBoundsFg: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Whether the shape's aspect ratio is locked.
+	 *
+	 * @public
+	 */
+	isAspectRatioLocked: TLShapeUtilFlag<T> = () => false
+
+	/**
+	 * Get the default props for a shape.
+	 *
+	 * @public
+	 */
+	abstract defaultProps(): T['props']
+
+	/**
+	 * Get a JSX element for the shape (as an HTML element).
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract render(shape: T): any
+
+	/**
+	 * Get JSX describing the shape's indicator (as an SVG element).
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract indicator(shape: T): any
+
+	/**
+	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
+	 *
+	 * @param shape - The shape.
+	 * @internal
+	 */
+	renderBackground?(shape: T): any
+
+	/**
+	 * Get an array of handle models for the shape. This is an optional method.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getHandles?.(myShape)
+	 * ```
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	protected getHandles?(shape: T): TLHandle[]
+
+	@computed
+	private get handlesCache(): ComputedCache<TLHandle[], TLShape> {
+		return this.editor.store.createComputedCache('handles:' + this.type, (shape) => {
+			return this.getHandles!(shape as any)
+		})
+	}
+
+	/**
+	 * Get the cached handles (this should not be overridden!)
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	handles(shape: T): TLHandle[] {
+		if (!this.getHandles) return EMPTY_ARRAY
+		return this.handlesCache.get(shape.id) ?? EMPTY_ARRAY
+	}
+
+	/**
+	 * Get the (not cached) bounds for the shape.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	protected abstract getBounds(shape: T): Box2d
+
+	@computed
+	private get boundsCache(): ComputedCache<Box2d, TLShape> {
+		return this.editor.store.createComputedCache('bounds:' + this.type, (shape) => {
+			return this.getBounds(shape as any)
+		})
+	}
+
+	/**
+	 * Get the cached bounds for the shape.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	bounds(shape: T): Box2d {
+		const result = this.boundsCache.get(shape.id) ?? new Box2d()
+		if (result.width === 0 || result.height === 0) {
+			return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))
+		}
+		return result
+	}
+
+	/**
+	 * Get the cached transform. Do not override this method!
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	transform(shape: T): Matrix2d {
+		return transforms.get<T>(shape, (shape) =>
+			Matrix2d.Compose(Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation))
+		)
+	}
+
+	/**
+	 * Get the cached point. Do not override this method!
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	point(shape: T): Vec2dModel {
+		return points.get<T>(shape, (shape) => ({ x: shape.x, y: shape.y }))
+	}
+
+	/**
+	 * Get the shape's (not cached) outline. Do not override this method!
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	protected abstract getOutline(shape: T): Vec2dModel[]
+
+	@computed
+	private get outlineCache(): ComputedCache<Vec2dModel[], TLShape> {
+		return this.editor.store.createComputedCache('outline:' + this.type, (shape) => {
+			return this.getOutline(shape as any)
+		})
+	}
+
+	/**
+	 * Get the shape's outline. Do not override this method!
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	outline(shape: T): Vec2dModel[] {
+		return this.outlineCache.get(shape.id) ?? EMPTY_ARRAY
+	}
+
+	/**
+	 * Get the shape's snap points.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	snapPoints(shape: T) {
+		return this.bounds(shape).snapPoints
+	}
+
+	/**
+	 * Get the shape's cached center.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	center(shape: T): Vec2dModel {
+		return this.getCenter(shape)
+	}
+
+	/**
+	 * Get the shape's (not cached) center.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract getCenter(shape: T): Vec2dModel
+
+	/**
+	 * Get whether the shape can receive children of a given type.
+	 *
+	 * @param type - The shape type.
+	 * @public
+	 */
+	canReceiveNewChildrenOfType(shape: T, type: TLShape['type']) {
+		return false
+	}
+
+	/**
+	 * Get whether the shape can receive children of a given type.
+	 *
+	 * @param shape - The shape type.
+	 * @param shapes - The shapes that are being dropped.
+	 * @public
+	 */
+	canDropShapes(shape: T, shapes: TLShape[]) {
+		return false
+	}
+
+	/**
+	 * Get the shape as an SVG object.
+	 *
+	 * @param shape - The shape.
+	 * @param color - The shape's CSS color (actual).
+	 * @param font - The shape's CSS font (actual).
+	 * @returns An SVG element.
+	 * @public
+	 */
+	toSvg?(
+		shape: T,
+		font: string | undefined,
+		colors: TLExportColors
+	): SVGElement | Promise<SVGElement>
+
+	/**
+	 * Get the shape's background layer as an SVG object.
+	 *
+	 * @param shape - The shape.
+	 * @param color - The shape's CSS color (actual).
+	 * @param font - The shape's CSS font (actual).
+	 * @returns An SVG element.
+	 * @public
+	 */
+	toBackgroundSvg?(
+		shape: T,
+		font: string | undefined,
+		colors: TLExportColors
+	): SVGElement | Promise<SVGElement> | null
+
+	/**
+	 * Get whether a point intersects the shape.
+	 *
+	 * @param shape - The shape.
+	 * @param point - The point to test.
+	 * @returns Whether the point intersects the shape.
+	 * @public
+	 */
+	hitTestPoint(shape: T, point: VecLike): boolean {
+		return this.bounds(shape).containsPoint(point)
+	}
+
+	/**
+	 * Get whether a point intersects the shape.
+	 *
+	 * @param shape - The shape.
+	 * @param A - The line segment's first point.
+	 * @param B - The line segment's second point.
+	 * @returns Whether the line segment intersects the shape.
+	 * @public
+	 */
+	hitTestLineSegment(shape: T, A: VecLike, B: VecLike): boolean {
+		const outline = this.outline(shape)
+
+		for (let i = 0; i < outline.length; i++) {
+			const C = outline[i]
+			const D = outline[(i + 1) % outline.length]
+			if (linesIntersect(A, B, C, D)) return true
+		}
+
+		return false
+	}
+
+	/** @internal */
+	expandSelectionOutlinePx(shape: T): number {
+		return 0
+	}
+
+	/**
+	 * Does this shape provide a background for its children? If this is true,
+	 * then any children with a `renderBackground` method will have their
+	 * backgrounds rendered _above_ this shape. Otherwise, the children's
+	 * backgrounds will be rendered above either the next ancestor that provides
+	 * a background, or the canvas background.
+	 *
+	 * @internal
+	 */
+	providesBackgroundForChildren(shape: T): boolean {
+		return false
+	}
+
+	//  Events
+
+	/**
+	 * A callback called just before a shape is created. This method provides a last chance to modify
+	 * the created shape.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onBeforeCreate = (next) => {
+	 * 	return { ...next, x: next.x + 1 }
+	 * }
+	 * ```
+	 *
+	 * @param next - The next shape.
+	 * @returns The next shape or void.
+	 * @public
+	 */
+	onBeforeCreate?: TLOnBeforeCreateHandler<T>
+
+	/**
+	 * A callback called just before a shape is updated. This method provides a last chance to modify
+	 * the updated shape.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onBeforeUpdate = (prev, next) => {
+	 * 	if (prev.x === next.x) {
+	 * 		return { ...next, x: next.x + 1 }
+	 * 	}
+	 * }
+	 * ```
+	 *
+	 * @param prev - The previous shape.
+	 * @param next - The next shape.
+	 * @returns The next shape or void.
+	 * @public
+	 */
+	onBeforeUpdate?: TLOnBeforeUpdateHandler<T>
+
+	/**
+	 * A callback called when some other shapes are dragged over this one.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * onDragShapesOver = (shape, shapes) => {
+	 * 	return { shouldHint: true }
+	 * }
+	 * ```
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dragged over this one.
+	 * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
+	 * @public
+	 */
+	onDragShapesOver?: TLOnDragHandler<T, { shouldHint: boolean }>
+
+	/**
+	 * A callback called when some other shapes are dragged out of this one.
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dragged out.
+	 * @public
+	 */
+	onDragShapesOut?: TLOnDragHandler<T>
+
+	/**
+	 * A callback called when some other shapes are dropped over this one.
+	 *
+	 * @param shape - The shape.
+	 * @param shapes - The shapes that are being dropped over this one.
+	 * @public
+	 */
+	onDropShapesOver?: TLOnDragHandler<T>
+
+	/**
+	 * A callback called when a shape starts being resized.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onResizeStart?: TLOnResizeStartHandler<T>
+
+	/**
+	 * A callback called when a shape changes from a resize.
+	 *
+	 * @param shape - The shape at the start of the resize.
+	 * @param info - Info about the resize.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onResize?: TLOnResizeHandler<T>
+
+	/**
+	 * A callback called when a shape finishes resizing.
+	 *
+	 * @param initial - The shape at the start of the resize.
+	 * @param current - The current shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onResizeEnd?: TLOnResizeEndHandler<T>
+
+	/**
+	 * A callback called when a shape starts being translated.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onTranslateStart?: TLOnTranslateStartHandler<T>
+
+	/**
+	 * A callback called when a shape changes from a translation.
+	 *
+	 * @param initial - The shape at the start of the translation.
+	 * @param current - The current shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onTranslate?: TLOnTranslateHandler<T>
+
+	/**
+	 * A callback called when a shape finishes translating.
+	 *
+	 * @param initial - The shape at the start of the translation.
+	 * @param current - The current shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onTranslateEnd?: TLOnTranslateEndHandler<T>
+
+	/**
+	 * A callback called when a shape starts being rotated.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onRotateStart?: TLOnRotateStartHandler<T>
+
+	/**
+	 * A callback called when a shape changes from a rotation.
+	 *
+	 * @param initial - The shape at the start of the rotation.
+	 * @param current - The current shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onRotate?: TLOnRotateHandler<T>
+
+	/**
+	 * A callback called when a shape finishes rotating.
+	 *
+	 * @param initial - The shape at the start of the rotation.
+	 * @param current - The current shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onRotateEnd?: TLOnRotateEndHandler<T>
+
+	/**
+	 * A callback called when a shape's handle changes.
+	 *
+	 * @param shape - The shape.
+	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onHandleChange?: TLOnHandleChangeHandler<T>
+
+	/**
+	 * Not currently used.
+	 *
+	 * @internal
+	 */
+	onBindingChange?: TLOnBindingChangeHandler<T>
+
+	/**
+	 * A callback called when a shape's children change.
+	 *
+	 * @param shape - The shape.
+	 * @returns An array of shape updates, or void.
+	 * @public
+	 */
+	onChildrenChange?: TLOnChildrenChangeHandler<T>
+
+	/**
+	 * A callback called when a shape's handle is double clicked.
+	 *
+	 * @param shape - The shape.
+	 * @param handle - The handle that is double-clicked.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onDoubleClickHandle?: TLOnDoubleClickHandleHandler<T>
+
+	/**
+	 * A callback called when a shape's edge is double clicked.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onDoubleClickEdge?: TLOnDoubleClickHandler<T>
+
+	/**
+	 * A callback called when a shape is double clicked.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onDoubleClick?: TLOnDoubleClickHandler<T>
+
+	/**
+	 * A callback called when a shape is clicked.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onClick?: TLOnClickHandler<T>
+
+	/**
+	 * A callback called when a shape finishes being editing.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	onEditEnd?: TLOnEditEndHandler<T>
+}
+
+/** @public */
+export type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void
+/** @public */
+export type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void
+/** @public */
+export type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>
+/** @public */
+export type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>
+/** @public */
+export type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+/** @public */
+export type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>
+/** @public */
+export type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>
+/** @public */
+export type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+
+/**
+ * The type of resize.
+ *
+ * 'scale_shape' - The shape is being scaled, usually as part of a larger selection.
+ *
+ * 'resize_bounds' - The user is directly manipulating an individual shape's bounds using a resize
+ * handle. It is up to shape util implementers to decide how they want to handle the two
+ * situations.
+ *
+ * @public
+ */
+export type TLResizeMode = 'scale_shape' | 'resize_bounds'
+
+/**
+ * Info about a resize.
+ * @param newPoint - The new local position of the shape.
+ * @param handle - The handle being dragged.
+ * @param mode - The type of resize.
+ * @param scaleX - The scale in the x-axis.
+ * @param scaleY - The scale in the y-axis.
+ * @param initialBounds - The bounds of the shape at the start of the resize.
+ * @param initialShape - The shape at the start of the resize.
+ * @public
+ */
+export type TLResizeInfo<T extends TLShape> = {
+	newPoint: Vec2dModel
+	handle: TLResizeHandle
+	mode: TLResizeMode
+	scaleX: number
+	scaleY: number
+	initialBounds: Box2d
+	initialShape: T
+}
+
+/** @public */
+export type TLOnResizeHandler<T extends TLShape> = (
+	shape: T,
+	info: TLResizeInfo<T>
+) => Partial<TLShapePartial<T>> | undefined | void
+
+/** @public */
+export type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>
+
+/** @public */
+export type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+
+/* -------------------- Dragging -------------------- */
+
+/** @public */
+export type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R
+
+/** @internal */
+export type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+
+/** @public */
+export type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void
+
+/** @public */
+export type TLOnHandleChangeHandler<T extends TLShape> = (
+	shape: T,
+	info: {
+		handle: TLHandle
+		isPrecise: boolean
+	}
+) => TLShapePartial<T> | void
+
+/** @public */
+export type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+/** @public */
+export type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void
+/** @public */
+export type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+/** @public */
+export type TLOnDoubleClickHandleHandler<T extends TLShape> = (
+	shape: T,
+	handle: TLHandle
+) => TLShapePartial<T> | void
+
+type TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+type TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void

commit c937b019159bd457730f67f6757bd0d4b53b9628
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jun 15 12:53:09 2023 +0100

    remove `ShapeUtil.point` (#1591)
    
    Removes the unused `ShapeUtil.point`.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.point`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 2cb9754e5..500df6e19 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -8,7 +8,6 @@ import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
 import { TLExportColors } from './shared/TLExportColors'
 
-const points = new WeakMapCache<TLShape, Vec2dModel>()
 const transforms = new WeakMapCache<TLShape, Matrix2d>()
 
 /** @public */
@@ -234,16 +233,6 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 		)
 	}
 
-	/**
-	 * Get the cached point. Do not override this method!
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	point(shape: T): Vec2dModel {
-		return points.get<T>(shape, (shape) => ({ x: shape.x, y: shape.y }))
-	}
-
 	/**
 	 * Get the shape's (not cached) outline. Do not override this method!
 	 *

commit 4650869988fe3592a0b2937d8b7155c0a351fdff
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jun 15 13:42:18 2023 +0100

    remove `ShapeUtil.transform` (#1590)
    
    Removes the cached (but not really needed) local transform for shapes.
    We almost never get the local transform except when getting the page
    transform.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.transform`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 500df6e19..9bb7922f8 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,15 +1,12 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
-import { Box2d, linesIntersect, Matrix2d, VecLike } from '@tldraw/primitives'
+import { Box2d, linesIntersect, VecLike } from '@tldraw/primitives'
 import { ComputedCache } from '@tldraw/store'
 import { TLHandle, TLShape, TLShapePartial, TLUnknownShape, Vec2dModel } from '@tldraw/tlschema'
 import { computed, EMPTY_ARRAY } from 'signia'
-import { WeakMapCache } from '../../utils/WeakMapCache'
 import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
 import { TLExportColors } from './shared/TLExportColors'
 
-const transforms = new WeakMapCache<TLShape, Matrix2d>()
-
 /** @public */
 export interface TLShapeUtilConstructor<
 	T extends TLUnknownShape,
@@ -221,18 +218,6 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 		return result
 	}
 
-	/**
-	 * Get the cached transform. Do not override this method!
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	transform(shape: T): Matrix2d {
-		return transforms.get<T>(shape, (shape) =>
-			Matrix2d.Compose(Matrix2d.Translate(shape.x, shape.y), Matrix2d.Rotate(shape.rotation))
-		)
-	}
-
 	/**
 	 * Get the shape's (not cached) outline. Do not override this method!
 	 *

commit b22bb13bb0f1294f0b9e31a06c304c39e52dcd9b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jun 15 15:36:46 2023 +0100

    [refactor] snapping (#1589)
    
    This PR is a refactor / tidy up of some snapping logic.
    
    - Fix a bug where the recursive call to `findAdjacentGaps` could lead to
    a maximum call stack error
    - Fixed an issue that caused handle snapping to expensively recompute
    - Fixed a dependency from the snap manager to the line shape
    
    ### Change Type
    
    - [x] `patch`
    
    ### Test Plan
    
    Our snap tests are pretty thorough, they should work here.
    
    ### Release Notes
    
    - [editor] fix bug in snapping

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 9bb7922f8..ccffad7bd 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,7 +1,7 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
-import { Box2d, linesIntersect, VecLike } from '@tldraw/primitives'
+import { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'
 import { ComputedCache } from '@tldraw/store'
-import { TLHandle, TLShape, TLShapePartial, TLUnknownShape, Vec2dModel } from '@tldraw/tlschema'
+import { TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
 import { computed, EMPTY_ARRAY } from 'signia'
 import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
@@ -30,6 +30,13 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 */
 	static type: string
 
+	/**
+	 * Whether the shape can be snapped to by another shape.
+	 *
+	 * @public
+	 */
+	canSnap: TLShapeUtilFlag<T> = () => true
+
 	/**
 	 * Whether the shape can be scrolled while editing.
 	 *
@@ -189,6 +196,43 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 		return this.handlesCache.get(shape.id) ?? EMPTY_ARRAY
 	}
 
+	/**
+	 * Get an array of outline segments for the shape. For most shapes,
+	 * this will be a single segment that includes the entire outline.
+	 * For shapes with handles, this might be segments of the outline
+	 * between each handle.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getOutlineSegments(myShape)
+	 * ```
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	protected getOutlineSegments(shape: T): Vec2d[][] {
+		return [this.outline(shape)]
+	}
+
+	@computed
+	private get outlineSegmentsCache(): ComputedCache<Vec2d[][], TLShape> {
+		return this.editor.store.createComputedCache('outline-segments:' + this.type, (shape) => {
+			return this.getOutlineSegments!(shape as any)
+		})
+	}
+
+	/**
+	 * Get the cached outline segments (this should not be overridden!)
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	outlineSegments(shape: T): Vec2d[][] {
+		if (!this.getOutlineSegments) return EMPTY_ARRAY
+		return this.outlineSegmentsCache.get(shape.id) ?? EMPTY_ARRAY
+	}
+
 	/**
 	 * Get the (not cached) bounds for the shape.
 	 *
@@ -224,10 +268,10 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected abstract getOutline(shape: T): Vec2dModel[]
+	protected abstract getOutline(shape: T): Vec2d[]
 
 	@computed
-	private get outlineCache(): ComputedCache<Vec2dModel[], TLShape> {
+	private get outlineCache(): ComputedCache<Vec2d[], TLShape> {
 		return this.editor.store.createComputedCache('outline:' + this.type, (shape) => {
 			return this.getOutline(shape as any)
 		})
@@ -239,7 +283,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	outline(shape: T): Vec2dModel[] {
+	outline(shape: T): Vec2d[] {
 		return this.outlineCache.get(shape.id) ?? EMPTY_ARRAY
 	}
 
@@ -259,7 +303,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	center(shape: T): Vec2dModel {
+	center(shape: T): Vec2d {
 		return this.getCenter(shape)
 	}
 
@@ -269,7 +313,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract getCenter(shape: T): Vec2dModel
+	abstract getCenter(shape: T): Vec2d
 
 	/**
 	 * Get whether the shape can receive children of a given type.
@@ -651,7 +695,7 @@ export type TLResizeMode = 'scale_shape' | 'resize_bounds'
  * @public
  */
 export type TLResizeInfo<T extends TLShape> = {
-	newPoint: Vec2dModel
+	newPoint: Vec2d
 	handle: TLResizeHandle
 	mode: TLResizeMode
 	scaleX: number

commit b88a2370b314855237774548d627ed4d3301a1ad
Author: alex <alex@dytry.ch>
Date:   Fri Jun 16 11:33:47 2023 +0100

    Styles API (#1580)
    
    Removes `propsForNextShape` and replaces it with the new styles API.
    
    Changes in here:
    - New custom style example
    - `setProp` is now `setStyle` and takes a `StyleProp` instead of a
    string
    - `Editor.props` and `Editor.opacity` are now `Editor.sharedStyles` and
    `Editor.sharedOpacity`
    - They return an object that flags mixed vs shared types instead of
    using null to signal mixed types
    - `Editor.styles` returns a `SharedStyleMap` - keyed on `StyleProp`
    instead of `string`
    - `StateNode.shapeType` is now the shape util rather than just a string.
    This lets us pull the styles from the shape type directly.
    - `color` is no longer a core part of the editor set on the shape
    parent. Individual child shapes have to use color directly.
    - `propsForNextShape` is now `stylesForNextShape`
    - `InstanceRecordType` is created at runtime in the same way
    `ShapeRecordType` is. This is so it can pull style validators out of
    shape defs for `stylesForNextShape`
    - Shape type are now defined by their props rather than having separate
    validators & type defs
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Big time regression testing around styles!
    2. Check UI works as intended for all shape/style/tool combos
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    -
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index ccffad7bd..ab2e86e90 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,7 +1,7 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'
 import { ComputedCache } from '@tldraw/store'
-import { TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
+import { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
 import { computed, EMPTY_ARRAY } from 'signia'
 import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
@@ -12,7 +12,7 @@ export interface TLShapeUtilConstructor<
 	T extends TLUnknownShape,
 	U extends ShapeUtil<T> = ShapeUtil<T>
 > {
-	new (editor: Editor, type: T['type']): U
+	new (editor: Editor, type: T['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>): U
 	type: T['type']
 }
 
@@ -20,8 +20,45 @@ export interface TLShapeUtilConstructor<
 export type TLShapeUtilFlag<T> = (shape: T) => boolean
 
 /** @public */
-export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
-	constructor(public editor: Editor, public readonly type: T['type']) {}
+export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
+	constructor(
+		public editor: Editor,
+		public readonly type: Shape['type'],
+		public readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>
+	) {}
+
+	hasStyle(style: StyleProp<unknown>) {
+		return this.styleProps.has(style)
+	}
+
+	getStyleIfExists<T>(style: StyleProp<T>, shape: Shape | TLShapePartial<Shape>): T | undefined {
+		const styleKey = this.styleProps.get(style)
+		if (!styleKey) return undefined
+		return (shape.props as any)[styleKey]
+	}
+
+	*iterateStyles(shape: Shape | TLShapePartial<Shape>) {
+		for (const [style, styleKey] of this.styleProps) {
+			const value = (shape.props as any)[styleKey]
+			yield [style, value] as [StyleProp<unknown>, unknown]
+		}
+	}
+
+	setStyleInPartial<T>(
+		style: StyleProp<T>,
+		shape: TLShapePartial<Shape>,
+		value: T
+	): TLShapePartial<Shape> {
+		const styleKey = this.styleProps.get(style)
+		if (!styleKey) return shape
+		return {
+			...shape,
+			props: {
+				...shape.props,
+				[styleKey]: value,
+			},
+		}
+	}
 
 	/**
 	 * The type of the shape util, which should match the shape's type.
@@ -35,21 +72,21 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	canSnap: TLShapeUtilFlag<T> = () => true
+	canSnap: TLShapeUtilFlag<Shape> = () => true
 
 	/**
 	 * Whether the shape can be scrolled while editing.
 	 *
 	 * @public
 	 */
-	canScroll: TLShapeUtilFlag<T> = () => false
+	canScroll: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
 	 *
 	 * @public
 	 */
-	canUnmount: TLShapeUtilFlag<T> = () => true
+	canUnmount: TLShapeUtilFlag<Shape> = () => true
 
 	/**
 	 * Whether the shape can be bound to by an arrow.
@@ -57,28 +94,28 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param _otherShape - The other shape attempting to bind to this shape.
 	 * @public
 	 */
-	canBind = <K>(_shape: T, _otherShape?: K) => true
+	canBind = <K>(_shape: Shape, _otherShape?: K) => true
 
 	/**
 	 * Whether the shape can be double clicked to edit.
 	 *
 	 * @public
 	 */
-	canEdit: TLShapeUtilFlag<T> = () => false
+	canEdit: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape can be resized.
 	 *
 	 * @public
 	 */
-	canResize: TLShapeUtilFlag<T> = () => true
+	canResize: TLShapeUtilFlag<Shape> = () => true
 
 	/**
 	 * Whether the shape can be cropped.
 	 *
 	 * @public
 	 */
-	canCrop: TLShapeUtilFlag<T> = () => false
+	canCrop: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Bounds of the shape to edit.
@@ -87,7 +124,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	getEditingBounds = (shape: T) => {
+	getEditingBounds = (shape: Shape) => {
 		return this.bounds(shape)
 	}
 
@@ -96,49 +133,49 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	isClosed: TLShapeUtilFlag<T> = () => true
+	isClosed: TLShapeUtilFlag<Shape> = () => true
 
 	/**
 	 * Whether the shape should hide its resize handles when selected.
 	 *
 	 * @public
 	 */
-	hideResizeHandles: TLShapeUtilFlag<T> = () => false
+	hideResizeHandles: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape should hide its resize handles when selected.
 	 *
 	 * @public
 	 */
-	hideRotateHandle: TLShapeUtilFlag<T> = () => false
+	hideRotateHandle: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape should hide its selection bounds background when selected.
 	 *
 	 * @public
 	 */
-	hideSelectionBoundsBg: TLShapeUtilFlag<T> = () => false
+	hideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape should hide its selection bounds foreground when selected.
 	 *
 	 * @public
 	 */
-	hideSelectionBoundsFg: TLShapeUtilFlag<T> = () => false
+	hideSelectionBoundsFg: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Whether the shape's aspect ratio is locked.
 	 *
 	 * @public
 	 */
-	isAspectRatioLocked: TLShapeUtilFlag<T> = () => false
+	isAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false
 
 	/**
 	 * Get the default props for a shape.
 	 *
 	 * @public
 	 */
-	abstract defaultProps(): T['props']
+	abstract defaultProps(): Shape['props']
 
 	/**
 	 * Get a JSX element for the shape (as an HTML element).
@@ -146,7 +183,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract render(shape: T): any
+	abstract render(shape: Shape): any
 
 	/**
 	 * Get JSX describing the shape's indicator (as an SVG element).
@@ -154,7 +191,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract indicator(shape: T): any
+	abstract indicator(shape: Shape): any
 
 	/**
 	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
@@ -162,7 +199,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @internal
 	 */
-	renderBackground?(shape: T): any
+	renderBackground?(shape: Shape): any
 
 	/**
 	 * Get an array of handle models for the shape. This is an optional method.
@@ -176,7 +213,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected getHandles?(shape: T): TLHandle[]
+	protected getHandles?(shape: Shape): TLHandle[]
 
 	@computed
 	private get handlesCache(): ComputedCache<TLHandle[], TLShape> {
@@ -191,7 +228,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	handles(shape: T): TLHandle[] {
+	handles(shape: Shape): TLHandle[] {
 		if (!this.getHandles) return EMPTY_ARRAY
 		return this.handlesCache.get(shape.id) ?? EMPTY_ARRAY
 	}
@@ -211,7 +248,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected getOutlineSegments(shape: T): Vec2d[][] {
+	protected getOutlineSegments(shape: Shape): Vec2d[][] {
 		return [this.outline(shape)]
 	}
 
@@ -228,7 +265,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	outlineSegments(shape: T): Vec2d[][] {
+	outlineSegments(shape: Shape): Vec2d[][] {
 		if (!this.getOutlineSegments) return EMPTY_ARRAY
 		return this.outlineSegmentsCache.get(shape.id) ?? EMPTY_ARRAY
 	}
@@ -239,7 +276,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected abstract getBounds(shape: T): Box2d
+	protected abstract getBounds(shape: Shape): Box2d
 
 	@computed
 	private get boundsCache(): ComputedCache<Box2d, TLShape> {
@@ -254,7 +291,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	bounds(shape: T): Box2d {
+	bounds(shape: Shape): Box2d {
 		const result = this.boundsCache.get(shape.id) ?? new Box2d()
 		if (result.width === 0 || result.height === 0) {
 			return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))
@@ -268,7 +305,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected abstract getOutline(shape: T): Vec2d[]
+	protected abstract getOutline(shape: Shape): Vec2d[]
 
 	@computed
 	private get outlineCache(): ComputedCache<Vec2d[], TLShape> {
@@ -283,7 +320,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	outline(shape: T): Vec2d[] {
+	outline(shape: Shape): Vec2d[] {
 		return this.outlineCache.get(shape.id) ?? EMPTY_ARRAY
 	}
 
@@ -293,7 +330,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	snapPoints(shape: T) {
+	snapPoints(shape: Shape) {
 		return this.bounds(shape).snapPoints
 	}
 
@@ -303,7 +340,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	center(shape: T): Vec2d {
+	center(shape: Shape): Vec2d {
 		return this.getCenter(shape)
 	}
 
@@ -313,7 +350,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract getCenter(shape: T): Vec2d
+	abstract getCenter(shape: Shape): Vec2d
 
 	/**
 	 * Get whether the shape can receive children of a given type.
@@ -321,7 +358,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param type - The shape type.
 	 * @public
 	 */
-	canReceiveNewChildrenOfType(shape: T, type: TLShape['type']) {
+	canReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']) {
 		return false
 	}
 
@@ -332,7 +369,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dropped.
 	 * @public
 	 */
-	canDropShapes(shape: T, shapes: TLShape[]) {
+	canDropShapes(shape: Shape, shapes: TLShape[]) {
 		return false
 	}
 
@@ -346,7 +383,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	toSvg?(
-		shape: T,
+		shape: Shape,
 		font: string | undefined,
 		colors: TLExportColors
 	): SVGElement | Promise<SVGElement>
@@ -361,7 +398,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	toBackgroundSvg?(
-		shape: T,
+		shape: Shape,
 		font: string | undefined,
 		colors: TLExportColors
 	): SVGElement | Promise<SVGElement> | null
@@ -374,7 +411,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns Whether the point intersects the shape.
 	 * @public
 	 */
-	hitTestPoint(shape: T, point: VecLike): boolean {
+	hitTestPoint(shape: Shape, point: VecLike): boolean {
 		return this.bounds(shape).containsPoint(point)
 	}
 
@@ -387,7 +424,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns Whether the line segment intersects the shape.
 	 * @public
 	 */
-	hitTestLineSegment(shape: T, A: VecLike, B: VecLike): boolean {
+	hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean {
 		const outline = this.outline(shape)
 
 		for (let i = 0; i < outline.length; i++) {
@@ -400,7 +437,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	}
 
 	/** @internal */
-	expandSelectionOutlinePx(shape: T): number {
+	expandSelectionOutlinePx(shape: Shape): number {
 		return 0
 	}
 
@@ -413,7 +450,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @internal
 	 */
-	providesBackgroundForChildren(shape: T): boolean {
+	providesBackgroundForChildren(shape: Shape): boolean {
 		return false
 	}
 
@@ -435,7 +472,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns The next shape or void.
 	 * @public
 	 */
-	onBeforeCreate?: TLOnBeforeCreateHandler<T>
+	onBeforeCreate?: TLOnBeforeCreateHandler<Shape>
 
 	/**
 	 * A callback called just before a shape is updated. This method provides a last chance to modify
@@ -456,7 +493,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns The next shape or void.
 	 * @public
 	 */
-	onBeforeUpdate?: TLOnBeforeUpdateHandler<T>
+	onBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>
 
 	/**
 	 * A callback called when some other shapes are dragged over this one.
@@ -474,7 +511,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
 	 * @public
 	 */
-	onDragShapesOver?: TLOnDragHandler<T, { shouldHint: boolean }>
+	onDragShapesOver?: TLOnDragHandler<Shape, { shouldHint: boolean }>
 
 	/**
 	 * A callback called when some other shapes are dragged out of this one.
@@ -483,7 +520,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dragged out.
 	 * @public
 	 */
-	onDragShapesOut?: TLOnDragHandler<T>
+	onDragShapesOut?: TLOnDragHandler<Shape>
 
 	/**
 	 * A callback called when some other shapes are dropped over this one.
@@ -492,7 +529,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dropped over this one.
 	 * @public
 	 */
-	onDropShapesOver?: TLOnDragHandler<T>
+	onDropShapesOver?: TLOnDragHandler<Shape>
 
 	/**
 	 * A callback called when a shape starts being resized.
@@ -501,7 +538,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResizeStart?: TLOnResizeStartHandler<T>
+	onResizeStart?: TLOnResizeStartHandler<Shape>
 
 	/**
 	 * A callback called when a shape changes from a resize.
@@ -511,7 +548,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResize?: TLOnResizeHandler<T>
+	onResize?: TLOnResizeHandler<Shape>
 
 	/**
 	 * A callback called when a shape finishes resizing.
@@ -521,7 +558,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResizeEnd?: TLOnResizeEndHandler<T>
+	onResizeEnd?: TLOnResizeEndHandler<Shape>
 
 	/**
 	 * A callback called when a shape starts being translated.
@@ -530,7 +567,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslateStart?: TLOnTranslateStartHandler<T>
+	onTranslateStart?: TLOnTranslateStartHandler<Shape>
 
 	/**
 	 * A callback called when a shape changes from a translation.
@@ -540,7 +577,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslate?: TLOnTranslateHandler<T>
+	onTranslate?: TLOnTranslateHandler<Shape>
 
 	/**
 	 * A callback called when a shape finishes translating.
@@ -550,7 +587,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslateEnd?: TLOnTranslateEndHandler<T>
+	onTranslateEnd?: TLOnTranslateEndHandler<Shape>
 
 	/**
 	 * A callback called when a shape starts being rotated.
@@ -559,7 +596,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotateStart?: TLOnRotateStartHandler<T>
+	onRotateStart?: TLOnRotateStartHandler<Shape>
 
 	/**
 	 * A callback called when a shape changes from a rotation.
@@ -569,7 +606,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotate?: TLOnRotateHandler<T>
+	onRotate?: TLOnRotateHandler<Shape>
 
 	/**
 	 * A callback called when a shape finishes rotating.
@@ -579,7 +616,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotateEnd?: TLOnRotateEndHandler<T>
+	onRotateEnd?: TLOnRotateEndHandler<Shape>
 
 	/**
 	 * A callback called when a shape's handle changes.
@@ -589,14 +626,14 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onHandleChange?: TLOnHandleChangeHandler<T>
+	onHandleChange?: TLOnHandleChangeHandler<Shape>
 
 	/**
 	 * Not currently used.
 	 *
 	 * @internal
 	 */
-	onBindingChange?: TLOnBindingChangeHandler<T>
+	onBindingChange?: TLOnBindingChangeHandler<Shape>
 
 	/**
 	 * A callback called when a shape's children change.
@@ -605,7 +642,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns An array of shape updates, or void.
 	 * @public
 	 */
-	onChildrenChange?: TLOnChildrenChangeHandler<T>
+	onChildrenChange?: TLOnChildrenChangeHandler<Shape>
 
 	/**
 	 * A callback called when a shape's handle is double clicked.
@@ -615,7 +652,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClickHandle?: TLOnDoubleClickHandleHandler<T>
+	onDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>
 
 	/**
 	 * A callback called when a shape's edge is double clicked.
@@ -624,7 +661,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClickEdge?: TLOnDoubleClickHandler<T>
+	onDoubleClickEdge?: TLOnDoubleClickHandler<Shape>
 
 	/**
 	 * A callback called when a shape is double clicked.
@@ -633,7 +670,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClick?: TLOnDoubleClickHandler<T>
+	onDoubleClick?: TLOnDoubleClickHandler<Shape>
 
 	/**
 	 * A callback called when a shape is clicked.
@@ -642,7 +679,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onClick?: TLOnClickHandler<T>
+	onClick?: TLOnClickHandler<Shape>
 
 	/**
 	 * A callback called when a shape finishes being editing.
@@ -650,7 +687,7 @@ export abstract class ShapeUtil<T extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	onEditEnd?: TLOnEditEndHandler<T>
+	onEditEnd?: TLOnEditEndHandler<Shape>
 }
 
 /** @public */

commit 3129bae6e27715921f2d700549c938c8764c1fc8
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jun 18 10:46:53 2023 +0100

    Rename `ShapeUtil.render` -> `ShapeUtil.component` (#1609)
    
    This PR renames `ShapeUtil.render` to `ShapeUtil.component`.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - [editor] rename `ShapeUtil.render` to `ShapeUtil.component`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index ab2e86e90..c6585c20f 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -183,7 +183,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract render(shape: Shape): any
+	abstract component(shape: Shape): any
 
 	/**
 	 * Get JSX describing the shape's indicator (as an SVG element).

commit 57bb341593d5f66261de4f0341736681aa6a71b6
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jun 19 15:01:18 2023 +0100

    `ShapeUtil` refactor, `Editor` cleanup (#1611)
    
    This PR improves the ergonomics of `ShapeUtil` classes.
    
    ### Cached methods
    
    First, I've remove the cached methods (such as `bounds`) from the
    `ShapeUtil` class and lifted this to the `Editor` class.
    
    Previously, calling `ShapeUtil.getBounds` would return the un-cached
    bounds of a shape, while calling `ShapeUtil.bounds` would return the
    cached bounds of a shape. We also had `Editor.getBounds`, which would
    call `ShapeUtil.bounds`. It was confusing. The cached methods like
    `outline` were also marked with "please don't override", which suggested
    the architecture was just wrong.
    
    The only weirdness from this is that utils sometimes reach out to the
    editor for cached versions of data rather than calling their own cached
    methods. It's still an easier story to tell than what we had before.
    
    ### More defaults
    
    We now have three and only three `abstract` methods for a `ShapeUtil`:
    - `getDefaultProps` (renamed from `defaultProps`)
    - `getBounds`,
    - `component`
    -  `indicator`
    
    Previously, we also had `getCenter` as an abstract method, though this
    was usually just the middle of the bounds anyway.
    
    ### Editing bounds
    
    This PR removes the concept of editingBounds. The viewport will no
    longer animate to editing shapes.
    
    ### Active area manager
    
    This PR also removes the active area manager, which was not being used
    in the way we expected it to be.
    
    ### Dpr manager
    
    This PR removes the dpr manager and uses a hook instead to update it
    from React. This is one less runtime browser dependency in the app, one
    less thing to document.
    
    ### Moving things around
    
    This PR also continues to try to organize related methods and properties
    in the editor.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - [editor] renames `defaultProps` to `getDefaultProps`
    - [editor] removes `outline`, `outlineSegments`, `handles`, `bounds`
    - [editor] renames `renderBackground` to `backgroundComponent`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index c6585c20f..712cdd6a7 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,8 +1,6 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'
-import { ComputedCache } from '@tldraw/store'
 import { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
-import { computed, EMPTY_ARRAY } from 'signia'
 import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
 import { TLExportColors } from './shared/TLExportColors'
@@ -67,6 +65,29 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	static type: string
 
+	/**
+	 * Get the default props for a shape.
+	 *
+	 * @public
+	 */
+	abstract getDefaultProps(): Shape['props']
+
+	/**
+	 * Get a JSX element for the shape (as an HTML element).
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract component(shape: Shape): any
+
+	/**
+	 * Get JSX describing the shape's indicator (as an SVG element).
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract indicator(shape: Shape): any
+
 	/**
 	 * Whether the shape can be snapped to by another shape.
 	 *
@@ -118,14 +139,16 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	canCrop: TLShapeUtilFlag<Shape> = () => false
 
 	/**
-	 * Bounds of the shape to edit.
-	 *
-	 * Note: this could be a text area within a shape for example arrow labels.
+	 * Does this shape provide a background for its children? If this is true,
+	 * then any children with a `renderBackground` method will have their
+	 * backgrounds rendered _above_ this shape. Otherwise, the children's
+	 * backgrounds will be rendered above either the next ancestor that provides
+	 * a background, or the canvas background.
 	 *
-	 * @public
+	 * @internal
 	 */
-	getEditingBounds = (shape: Shape) => {
-		return this.bounds(shape)
+	providesBackgroundForChildren(shape: Shape): boolean {
+		return false
 	}
 
 	/**
@@ -170,36 +193,13 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	isAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false
 
-	/**
-	 * Get the default props for a shape.
-	 *
-	 * @public
-	 */
-	abstract defaultProps(): Shape['props']
-
-	/**
-	 * Get a JSX element for the shape (as an HTML element).
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	abstract component(shape: Shape): any
-
-	/**
-	 * Get JSX describing the shape's indicator (as an SVG element).
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	abstract indicator(shape: Shape): any
-
 	/**
 	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
 	 *
 	 * @param shape - The shape.
 	 * @internal
 	 */
-	renderBackground?(shape: Shape): any
+	backgroundComponent?(shape: Shape): any
 
 	/**
 	 * Get an array of handle models for the shape. This is an optional method.
@@ -213,25 +213,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected getHandles?(shape: Shape): TLHandle[]
-
-	@computed
-	private get handlesCache(): ComputedCache<TLHandle[], TLShape> {
-		return this.editor.store.createComputedCache('handles:' + this.type, (shape) => {
-			return this.getHandles!(shape as any)
-		})
-	}
-
-	/**
-	 * Get the cached handles (this should not be overridden!)
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	handles(shape: Shape): TLHandle[] {
-		if (!this.getHandles) return EMPTY_ARRAY
-		return this.handlesCache.get(shape.id) ?? EMPTY_ARRAY
-	}
+	getHandles?(shape: Shape): TLHandle[]
 
 	/**
 	 * Get an array of outline segments for the shape. For most shapes,
@@ -248,26 +230,8 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected getOutlineSegments(shape: Shape): Vec2d[][] {
-		return [this.outline(shape)]
-	}
-
-	@computed
-	private get outlineSegmentsCache(): ComputedCache<Vec2d[][], TLShape> {
-		return this.editor.store.createComputedCache('outline-segments:' + this.type, (shape) => {
-			return this.getOutlineSegments!(shape as any)
-		})
-	}
-
-	/**
-	 * Get the cached outline segments (this should not be overridden!)
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	outlineSegments(shape: Shape): Vec2d[][] {
-		if (!this.getOutlineSegments) return EMPTY_ARRAY
-		return this.outlineSegmentsCache.get(shape.id) ?? EMPTY_ARRAY
+	getOutlineSegments(shape: Shape): Vec2d[][] {
+		return [this.editor.getOutline(shape)]
 	}
 
 	/**
@@ -276,52 +240,16 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected abstract getBounds(shape: Shape): Box2d
-
-	@computed
-	private get boundsCache(): ComputedCache<Box2d, TLShape> {
-		return this.editor.store.createComputedCache('bounds:' + this.type, (shape) => {
-			return this.getBounds(shape as any)
-		})
-	}
-
-	/**
-	 * Get the cached bounds for the shape.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	bounds(shape: Shape): Box2d {
-		const result = this.boundsCache.get(shape.id) ?? new Box2d()
-		if (result.width === 0 || result.height === 0) {
-			return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1))
-		}
-		return result
-	}
+	abstract getBounds(shape: Shape): Box2d
 
 	/**
-	 * Get the shape's (not cached) outline. Do not override this method!
+	 * Get the shape's (not cached) outline.
 	 *
 	 * @param shape - The shape.
 	 * @public
 	 */
-	protected abstract getOutline(shape: Shape): Vec2d[]
-
-	@computed
-	private get outlineCache(): ComputedCache<Vec2d[], TLShape> {
-		return this.editor.store.createComputedCache('outline:' + this.type, (shape) => {
-			return this.getOutline(shape as any)
-		})
-	}
-
-	/**
-	 * Get the shape's outline. Do not override this method!
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	outline(shape: Shape): Vec2d[] {
-		return this.outlineCache.get(shape.id) ?? EMPTY_ARRAY
+	getOutline(shape: Shape): Vec2d[] {
+		return this.editor.getBounds(shape).corners
 	}
 
 	/**
@@ -331,7 +259,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	snapPoints(shape: Shape) {
-		return this.bounds(shape).snapPoints
+		return this.editor.getBounds(shape).snapPoints
 	}
 
 	/**
@@ -350,7 +278,9 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	abstract getCenter(shape: Shape): Vec2d
+	getCenter(shape: Shape) {
+		return this.editor.getBounds(shape).center
+	}
 
 	/**
 	 * Get whether the shape can receive children of a given type.
@@ -403,6 +333,11 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		colors: TLExportColors
 	): SVGElement | Promise<SVGElement> | null
 
+	/** @internal */
+	expandSelectionOutlinePx(shape: Shape): number {
+		return 0
+	}
+
 	/**
 	 * Get whether a point intersects the shape.
 	 *
@@ -412,7 +347,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	hitTestPoint(shape: Shape, point: VecLike): boolean {
-		return this.bounds(shape).containsPoint(point)
+		return this.editor.getBounds(shape).containsPoint(point)
 	}
 
 	/**
@@ -425,7 +360,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean {
-		const outline = this.outline(shape)
+		const outline = this.editor.getOutline(shape)
 
 		for (let i = 0; i < outline.length; i++) {
 			const C = outline[i]
@@ -436,24 +371,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return false
 	}
 
-	/** @internal */
-	expandSelectionOutlinePx(shape: Shape): number {
-		return 0
-	}
-
-	/**
-	 * Does this shape provide a background for its children? If this is true,
-	 * then any children with a `renderBackground` method will have their
-	 * backgrounds rendered _above_ this shape. Otherwise, the children's
-	 * backgrounds will be rendered above either the next ancestor that provides
-	 * a background, or the canvas background.
-	 *
-	 * @internal
-	 */
-	providesBackgroundForChildren(shape: Shape): boolean {
-		return false
-	}
-
 	//  Events
 
 	/**
@@ -745,7 +662,7 @@ export type TLResizeInfo<T extends TLShape> = {
 export type TLOnResizeHandler<T extends TLShape> = (
 	shape: T,
 	info: TLResizeInfo<T>
-) => Partial<TLShapePartial<T>> | undefined | void
+) => Omit<TLShapePartial<T>, 'id' | 'type'> | undefined | void
 
 /** @public */
 export type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>

commit e8bc114bf3ccd666079a704880622e300234bf88
Author: alex <alex@dytry.ch>
Date:   Sat Jun 24 14:46:04 2023 +0100

    Styles API follow-ups (#1636)
    
    tldraw-zero themed follow-ups to the styles API added in #1580.
    
    - Removed style related helpers from `ShapeUtil`
    - `editor.css` no longer includes the tldraw default color palette.
    Instead, a global `DefaultColorPalette` is defined as part of the color
    style. If developers wish to cusomise the colors, they can mutate that
    global.
    - `ShapeUtil.toSvg` no longer takes font/color. Instead, it takes an
    "svg export context" that can be used to add `<defs>` to the exported
    SVG element. Converting e.g. fonts to inlined data urls is now the
    responsibility of the shapes that use them rather than the Editor.
    - `usePattern` is not longer a core part of the editor. Instead,
    `ShapeUtil` has a `getCanvasSvgDefs` method for returning react
    components representing anything a shape needs included in `<defs>` for
    the canvas.
    - The shape-specific cleanup logic in `setStyle` has been deleted. It
    turned out that none of that logic has been running anyway, and instead
    the relevant logic lives in shape `onBeforeChange` callbacks already.
    
    ### Change Type
    - [x] `minor` — New feature
    
    ### Test Plan
    
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
     --
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 712cdd6a7..14c142876 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -3,7 +3,7 @@ import { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'
 import { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
 import type { Editor } from '../Editor'
 import { TLResizeHandle } from '../types/selection-types'
-import { TLExportColors } from './shared/TLExportColors'
+import { SvgExportContext } from './shared/SvgExportContext'
 
 /** @public */
 export interface TLShapeUtilConstructor<
@@ -17,6 +17,12 @@ export interface TLShapeUtilConstructor<
 /** @public */
 export type TLShapeUtilFlag<T> = (shape: T) => boolean
 
+/** @public */
+export interface TLShapeUtilCanvasSvgDef {
+	key: string
+	component: React.ComponentType
+}
+
 /** @public */
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	constructor(
@@ -25,23 +31,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		public readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>
 	) {}
 
-	hasStyle(style: StyleProp<unknown>) {
-		return this.styleProps.has(style)
-	}
-
-	getStyleIfExists<T>(style: StyleProp<T>, shape: Shape | TLShapePartial<Shape>): T | undefined {
-		const styleKey = this.styleProps.get(style)
-		if (!styleKey) return undefined
-		return (shape.props as any)[styleKey]
-	}
-
-	*iterateStyles(shape: Shape | TLShapePartial<Shape>) {
-		for (const [style, styleKey] of this.styleProps) {
-			const value = (shape.props as any)[styleKey]
-			yield [style, value] as [StyleProp<unknown>, unknown]
-		}
-	}
-
 	setStyleInPartial<T>(
 		style: StyleProp<T>,
 		shape: TLShapePartial<Shape>,
@@ -307,31 +296,21 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * Get the shape as an SVG object.
 	 *
 	 * @param shape - The shape.
-	 * @param color - The shape's CSS color (actual).
-	 * @param font - The shape's CSS font (actual).
+	 * @param ctx - The export context for the SVG - used for adding e.g. \<def\>s
 	 * @returns An SVG element.
 	 * @public
 	 */
-	toSvg?(
-		shape: Shape,
-		font: string | undefined,
-		colors: TLExportColors
-	): SVGElement | Promise<SVGElement>
+	toSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement>
 
 	/**
 	 * Get the shape's background layer as an SVG object.
 	 *
 	 * @param shape - The shape.
-	 * @param color - The shape's CSS color (actual).
-	 * @param font - The shape's CSS font (actual).
+	 * @param ctx - ctx - The export context for the SVG - used for adding e.g. \<def\>s
 	 * @returns An SVG element.
 	 * @public
 	 */
-	toBackgroundSvg?(
-		shape: Shape,
-		font: string | undefined,
-		colors: TLExportColors
-	): SVGElement | Promise<SVGElement> | null
+	toBackgroundSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement> | null
 
 	/** @internal */
 	expandSelectionOutlinePx(shape: Shape): number {
@@ -371,6 +350,18 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return false
 	}
 
+	/**
+	 * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
+	 * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
+	 * elements returned by `component`.
+	 *
+	 * Each def should have a unique `key`. If multiple defs from different shapes all have the same
+	 * key, only one will be used.
+	 */
+	getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
+		return []
+	}
+
 	//  Events
 
 	/**

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 14c142876..36170a988 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,17 +1,22 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
-import { Box2d, linesIntersect, Vec2d, VecLike } from '@tldraw/primitives'
-import { StyleProp, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
+import { Migrations } from '@tldraw/store'
+import { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
+import { Box2d } from '../../primitives/Box2d'
+import { Vec2d, VecLike } from '../../primitives/Vec2d'
+import { linesIntersect } from '../../primitives/intersect'
 import type { Editor } from '../Editor'
+import { SvgExportContext } from '../types/SvgExportContext'
 import { TLResizeHandle } from '../types/selection-types'
-import { SvgExportContext } from './shared/SvgExportContext'
 
 /** @public */
 export interface TLShapeUtilConstructor<
 	T extends TLUnknownShape,
 	U extends ShapeUtil<T> = ShapeUtil<T>
 > {
-	new (editor: Editor, type: T['type'], styleProps: ReadonlyMap<StyleProp<unknown>, string>): U
+	new (editor: Editor): U
 	type: T['type']
+	props?: ShapeProps<T>
+	migrations?: Migrations
 }
 
 /** @public */
@@ -25,27 +30,9 @@ export interface TLShapeUtilCanvasSvgDef {
 
 /** @public */
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
-	constructor(
-		public editor: Editor,
-		public readonly type: Shape['type'],
-		public readonly styleProps: ReadonlyMap<StyleProp<unknown>, string>
-	) {}
-
-	setStyleInPartial<T>(
-		style: StyleProp<T>,
-		shape: TLShapePartial<Shape>,
-		value: T
-	): TLShapePartial<Shape> {
-		const styleKey = this.styleProps.get(style)
-		if (!styleKey) return shape
-		return {
-			...shape,
-			props: {
-				...shape.props,
-				[styleKey]: value,
-			},
-		}
-	}
+	constructor(public editor: Editor) {}
+	static props?: ShapeProps<TLUnknownShape>
+	static migrations?: Migrations
 
 	/**
 	 * The type of the shape util, which should match the shape's type.

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 36170a988..d09fd35c2 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -2,8 +2,8 @@
 import { Migrations } from '@tldraw/store'
 import { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
 import { Box2d } from '../../primitives/Box2d'
-import { Vec2d, VecLike } from '../../primitives/Vec2d'
-import { linesIntersect } from '../../primitives/intersect'
+import { Vec2d } from '../../primitives/Vec2d'
+import { Geometry2d } from '../../primitives/geometry/Geometry2d'
 import type { Editor } from '../Editor'
 import { SvgExportContext } from '../types/SvgExportContext'
 import { TLResizeHandle } from '../types/selection-types'
@@ -48,6 +48,14 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	abstract getDefaultProps(): Shape['props']
 
+	/**
+	 * Get the shape's geometry.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	abstract getGeometry(shape: Shape): Geometry2d
+
 	/**
 	 * Get a JSX element for the shape (as an HTML element).
 	 *
@@ -127,13 +135,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return false
 	}
 
-	/**
-	 * Whether the shape's outline is closed.
-	 *
-	 * @public
-	 */
-	isClosed: TLShapeUtilFlag<Shape> = () => true
-
 	/**
 	 * Whether the shape should hide its resize handles when selected.
 	 *
@@ -148,13 +149,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	hideRotateHandle: TLShapeUtilFlag<Shape> = () => false
 
-	/**
-	 * Whether the shape should hide its selection bounds background when selected.
-	 *
-	 * @public
-	 */
-	hideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false
-
 	/**
 	 * Whether the shape should hide its selection bounds foreground when selected.
 	 *
@@ -207,55 +201,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	getOutlineSegments(shape: Shape): Vec2d[][] {
-		return [this.editor.getOutline(shape)]
-	}
-
-	/**
-	 * Get the (not cached) bounds for the shape.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	abstract getBounds(shape: Shape): Box2d
-
-	/**
-	 * Get the shape's (not cached) outline.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	getOutline(shape: Shape): Vec2d[] {
-		return this.editor.getBounds(shape).corners
-	}
-
-	/**
-	 * Get the shape's snap points.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	snapPoints(shape: Shape) {
-		return this.editor.getBounds(shape).snapPoints
-	}
-
-	/**
-	 * Get the shape's cached center.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	center(shape: Shape): Vec2d {
-		return this.getCenter(shape)
-	}
-
-	/**
-	 * Get the shape's (not cached) center.
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	getCenter(shape: Shape) {
-		return this.editor.getBounds(shape).center
+		return [this.editor.getGeometry(shape).vertices]
 	}
 
 	/**
@@ -304,39 +250,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return 0
 	}
 
-	/**
-	 * Get whether a point intersects the shape.
-	 *
-	 * @param shape - The shape.
-	 * @param point - The point to test.
-	 * @returns Whether the point intersects the shape.
-	 * @public
-	 */
-	hitTestPoint(shape: Shape, point: VecLike): boolean {
-		return this.editor.getBounds(shape).containsPoint(point)
-	}
-
-	/**
-	 * Get whether a point intersects the shape.
-	 *
-	 * @param shape - The shape.
-	 * @param A - The line segment's first point.
-	 * @param B - The line segment's second point.
-	 * @returns Whether the line segment intersects the shape.
-	 * @public
-	 */
-	hitTestLineSegment(shape: Shape, A: VecLike, B: VecLike): boolean {
-		const outline = this.editor.getOutline(shape)
-
-		for (let i = 0; i < outline.length; i++) {
-			const C = outline[i]
-			const D = outline[(i + 1) % outline.length]
-			if (linesIntersect(A, B, C, D)) return true
-		}
-
-		return false
-	}
-
 	/**
 	 * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
 	 * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg

commit 28b92c5e764ac8ce8dc1a66cd1d6248e3ddda085
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jul 26 16:32:33 2023 +0100

    [fix] restore bg option, fix calculations (#1765)
    
    This PR fixes a bug introduced with #1751 where pointing the bounds of
    rotated selections would not correctly hit the bounds background.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create a rotated selection.
    2. Point into the bounds background
    
    - [x] Unit Tests

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index d09fd35c2..454da4ca7 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -149,6 +149,13 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	hideRotateHandle: TLShapeUtilFlag<Shape> = () => false
 
+	/**
+	 * Whether the shape should hide its selection bounds background when selected.
+	 *
+	 * @public
+	 */
+	hideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false
+
 	/**
 	 * Whether the shape should hide its selection bounds foreground when selected.
 	 *

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 454da4ca7..9edd1baaf 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -208,7 +208,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @public
 	 */
 	getOutlineSegments(shape: Shape): Vec2d[][] {
-		return [this.editor.getGeometry(shape).vertices]
+		return [this.editor.getShapeGeometry(shape).vertices]
 	}
 
 	/**

commit fb2f515b74b42640d251bd08ea68320840843703
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Oct 3 12:03:01 2023 +0100

    [improvement] prevent editing in readonly (#1990)
    
    This PR prevents certain shapes from being edited while in readonly
    mode. It adds `ShapeUtil.canEditInReadOnly` to allow developers to opt
    in to editing shapes. It's currently applied only to embed shapes.
    
    ### Change Type
    
    - [x] `major`
    
    ### Test Plan
    
    1. In a readonly mode, try to edit text / sticky notes / arrow labels
    via double click / enter. You should not be able to edit them.
    2. Try to edit an embed. You should be able to edit it.
    
    ### Release Notes
    
    - Prevent editing text shapes in readonly mode.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 9edd1baaf..973c07709 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -115,6 +115,13 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	canResize: TLShapeUtilFlag<Shape> = () => true
 
+	/**
+	 * Whether the shape can be edited in read-only mode.
+	 *
+	 * @public
+	 */
+	canEditInReadOnly: TLShapeUtilFlag<Shape> = () => false
+
 	/**
 	 * Whether the shape can be cropped.
 	 *

commit 2360a01e90654aa9abe9c870109ef6dd1a8ff6d5
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Fri Oct 27 14:33:50 2023 +0100

    Taha/initial shape in handle change (#2117)
    
    This PR passes the initial shape to the onHandleChange method. It makes
    it a bit easier to work with handles in custom shapes.
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [x] `internal` — Any other changes that don't affect the published
    package[^2]
    - [] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 973c07709..07ea80799 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -443,7 +443,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	/**
 	 * A callback called when a shape's handle changes.
 	 *
-	 * @param shape - The shape.
+	 * @param shape - The current shape.
 	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
 	 * @returns A change to apply to the shape, or void.
 	 * @public
@@ -592,6 +592,7 @@ export type TLOnHandleChangeHandler<T extends TLShape> = (
 	info: {
 		handle: TLHandle
 		isPrecise: boolean
+		initial?: T | undefined
 	}
 ) => TLShapePartial<T> | void
 

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 07ea80799..766555a48 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,8 +1,8 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { Migrations } from '@tldraw/store'
 import { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
-import { Box2d } from '../../primitives/Box2d'
-import { Vec2d } from '../../primitives/Vec2d'
+import { Box } from '../../primitives/Box'
+import { Vec } from '../../primitives/Vec'
 import { Geometry2d } from '../../primitives/geometry/Geometry2d'
 import type { Editor } from '../Editor'
 import { SvgExportContext } from '../types/SvgExportContext'
@@ -214,7 +214,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	getOutlineSegments(shape: Shape): Vec2d[][] {
+	getOutlineSegments(shape: Shape): Vec[][] {
 		return [this.editor.getShapeGeometry(shape).vertices]
 	}
 
@@ -554,12 +554,12 @@ export type TLResizeMode = 'scale_shape' | 'resize_bounds'
  * @public
  */
 export type TLResizeInfo<T extends TLShape> = {
-	newPoint: Vec2d
+	newPoint: Vec
 	handle: TLResizeHandle
 	mode: TLResizeMode
 	scaleX: number
 	scaleY: number
-	initialBounds: Box2d
+	initialBounds: Box
 	initialShape: T
 }
 

commit 29044867dd2e49a3711e95c547fa9352e66720b9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 15 12:33:15 2024 +0000

    Add docs (#2470)
    
    This PR adds the docs app back into the tldraw monorepo.
    
    ## Deploying
    
    We'll want to update our deploy script to update the SOURCE_SHA to the
    newest release sha... and then deploy the docs pulling api.json files
    from that release. We _could_ update the docs on every push to main, but
    we don't have to unless something has changed. Right now there's no
    automated deployments from this repo.
    
    ## Side effects
    
    To make this one work, I needed to update the lock file. This might be
    ok (new year new lock file), and everything builds as expected, though
    we may want to spend some time with our scripts to be sure that things
    are all good.
    
    I also updated our prettier installation, which decided to add trailing
    commas to every generic type. Which is, I suppose, [correct
    behavior](https://github.com/prettier/prettier-vscode/issues/955)? But
    that caused diffs in every file, which is unfortunate.
    
    ### Change Type
    
    - [x] `internal` — Any other changes that don't affect the published
    package[^2]

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 766555a48..2661e130b 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -11,7 +11,7 @@ import { TLResizeHandle } from '../types/selection-types'
 /** @public */
 export interface TLShapeUtilConstructor<
 	T extends TLUnknownShape,
-	U extends ShapeUtil<T> = ShapeUtil<T>
+	U extends ShapeUtil<T> = ShapeUtil<T>,
 > {
 	new (editor: Editor): U
 	type: T['type']

commit b7fb31f8f9decf0f663695e87b32d64e7d64b57c
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Jan 15 13:41:48 2024 +0000

    fix typo in hideRotateHandle method (#2473)
    
    fix typo in hideRotateHandle method
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [x] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - fix typo in hideRotateHandle method

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 2661e130b..50aa1db18 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -150,7 +150,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	hideResizeHandles: TLShapeUtilFlag<Shape> = () => false
 
 	/**
-	 * Whether the shape should hide its resize handles when selected.
+	 * Whether the shape should hide its rotation handles when selected.
 	 *
 	 * @public
 	 */

commit 07cda7ef9fd9008c2feebce20659e2d087ddbdd3
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jan 24 10:19:20 2024 +0000

    arrows: add ability to change label placement (#2557)
    
    This adds the ability to drag the label on an arrow to a different
    location within the line segment/arc.
    
    
    https://github.com/tldraw/tldraw/assets/469604/dbd2ee35-bebc-48d6-b8ee-fcf12ce91fa5
    
    - A lot of the complexity lay in ensuring a fixed distance from the ends
    of the arrowheads.
    - I added a new type of handle `text-adjust` that makes the text box the
    very handle itself.
    - I added a `ARROW_HANDLES` enum - we should use more enums!
    - The bulk of the changes are in ArrowShapeUtil — check that out in
    particular obviously :)
    
    Along the way, I tried to improve a couple spots as I touched them:
    - added some more documentation to Vec.ts because some of the functions
    in there were obscure/new to me. (at least the naming, hah)
    - added `getPointOnCircle` which was being done in a couple places
    independently and refactored those places.
    
    ### Questions
    - the `getPointOnCircle` API changed. Is this considered breaking and/or
    should I leave the signature the same? Wasn't sure if it was a big deal
    or not.
    - I made `labelPosition` in the schema always but I guess it could have
    been optional? Lemme know if there's a preference.
    - Any feedback on tests? Happy to expand those if necessary.
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [x] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. For arrow in [straightArrow, curvedArrow] test the following:
       a. Label in the middle
       b. Label at both ends of the arrow
       c. Test arrows in different directions
    d. Rotating the endpoints and seeing that the label stays at the end of
    the arrow at a fixed width.
       e. Test different stroke widths.
       f. Test with different arrowheads.
    2. Also, test arcs that are more circle like than arc-like.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Adds ability to change label position on arrows.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 50aa1db18..064c4679b 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -411,6 +411,34 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onTranslateEnd?: TLOnTranslateEndHandler<Shape>
 
+	/**
+	 * A callback called when a shape starts being dragged.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onHandleDragStart?: TLOnHandleDragStartHandler<Shape>
+
+	/**
+	 * A callback called when a shape's handle changes.
+	 *
+	 * @param shape - The current shape.
+	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onHandleDrag?: TLOnHandleDragHandler<Shape>
+
+	/**
+	 * A callback called when a shape starts being dragged.
+	 *
+	 * @param shape - The shape.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onHandleDragEnd?: TLOnHandleDragStartHandler<Shape>
+
 	/**
 	 * A callback called when a shape starts being rotated.
 	 *
@@ -440,16 +468,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onRotateEnd?: TLOnRotateEndHandler<Shape>
 
-	/**
-	 * A callback called when a shape's handle changes.
-	 *
-	 * @param shape - The current shape.
-	 * @param info - An object containing the handle and whether the handle is 'precise' or not.
-	 * @returns A change to apply to the shape, or void.
-	 * @public
-	 */
-	onHandleChange?: TLOnHandleChangeHandler<Shape>
-
 	/**
 	 * Not currently used.
 	 *
@@ -587,7 +605,10 @@ export type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapeP
 export type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void
 
 /** @public */
-export type TLOnHandleChangeHandler<T extends TLShape> = (
+export type TLOnHandleDragStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+
+/** @public */
+export type TLOnHandleDragHandler<T extends TLShape> = (
 	shape: T,
 	info: {
 		handle: TLHandle
@@ -596,6 +617,9 @@ export type TLOnHandleChangeHandler<T extends TLShape> = (
 	}
 ) => TLShapePartial<T> | void
 
+/** @public */
+export type TLOnHandleDragEndHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
+
 /** @public */
 export type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
 /** @public */

commit 34a95b2ec8811fc50eaf74a9a4139909e9b834b7
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jan 31 11:17:03 2024 +0000

    arrows: separate out handle behavior from labels (#2621)
    
    This is a followup on the arrows work.
    - allow labels to go to the ends if no arrowhead is present
    - avoid using / overloading TLHandle and use a new PointingLabel state
    to specifically address label movement
    - removes the feature flag to launch this feature!
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Release Notes
    
    - Arrow labels: provide more polish on label placement
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 064c4679b..894ae80b1 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -411,15 +411,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onTranslateEnd?: TLOnTranslateEndHandler<Shape>
 
-	/**
-	 * A callback called when a shape starts being dragged.
-	 *
-	 * @param shape - The shape.
-	 * @returns A change to apply to the shape, or void.
-	 * @public
-	 */
-	onHandleDragStart?: TLOnHandleDragStartHandler<Shape>
-
 	/**
 	 * A callback called when a shape's handle changes.
 	 *
@@ -430,15 +421,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onHandleDrag?: TLOnHandleDragHandler<Shape>
 
-	/**
-	 * A callback called when a shape starts being dragged.
-	 *
-	 * @param shape - The shape.
-	 * @returns A change to apply to the shape, or void.
-	 * @public
-	 */
-	onHandleDragEnd?: TLOnHandleDragStartHandler<Shape>
-
 	/**
 	 * A callback called when a shape starts being rotated.
 	 *
@@ -604,9 +586,6 @@ export type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapeP
 /** @public */
 export type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void
 
-/** @public */
-export type TLOnHandleDragStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-
 /** @public */
 export type TLOnHandleDragHandler<T extends TLShape> = (
 	shape: T,
@@ -617,9 +596,6 @@ export type TLOnHandleDragHandler<T extends TLShape> = (
 	}
 ) => TLShapePartial<T> | void
 
-/** @public */
-export type TLOnHandleDragEndHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-
 /** @public */
 export type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
 /** @public */

commit 77865d9f5ef82eca1c3d236542460408f47161f9
Author: alex <alex@dytry.ch>
Date:   Thu Feb 15 15:10:04 2024 +0000

    [Snapping 3/5] Custom snapping API (#2793)
    
    This diff adds an API for customising our existing snap types. These
    are:
    1. Bound snapping. When translating or resizing a shape, it'll snap to
    certain key points on the bounds of particular shapes. Previously, these
    were hard-coded to the corners and center of the bounding box of the
    shape. Now, a shape can bring its own (e.g. a triangle may add snapping
    for its 3 corners, and it's centroid rather than bounding box center.
    2. Handle outline snapping. When dragging a handle, it'll snap to the
    outline of other shapes geometry. Now, shapes can return different
    geometry for this sort of snapping if they like.
    
    Each of these is customised through a method on `ShapeUtil`:
    `getBoundsSnapGeometry` and `getHandleSnapGeometry`. These return
    interfaces describing the different geometry that can be snapped to in
    both these cases. Currently, each returns an object with a single
    property, but there are more types of snapping coming in follow-up PRs.
    When reviewing this PR, start with the definitions of
    `BoundsSnapGeometry` in `BoundsSnaps.ts` and `HandleSnapGeometry` in
    `HandleSnaps.ts`
    
    This doesn't add point snapping - i'll add that in a follow-up! It'll be
    customisable with the `getHandleSnapGeometry` API.
    
    Fixes TLD-2197
    
    This PR is part of a series - please don't merge it until the things
    before it have landed!
    1. #2827
    4. #2831
    5. #2793 (you are here)
    6. #2841
    7. #2845
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Add `ShapeUtil.getSnapInfo` for customising shape snaps.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 894ae80b1..e7bb6ac21 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -5,6 +5,8 @@ import { Box } from '../../primitives/Box'
 import { Vec } from '../../primitives/Vec'
 import { Geometry2d } from '../../primitives/geometry/Geometry2d'
 import type { Editor } from '../Editor'
+import { BoundsSnapGeometry } from '../managers/SnapManager/BoundsSnaps'
+import { HandleSnapGeometry } from '../managers/SnapManager/HandleSnaps'
 import { SvgExportContext } from '../types/SvgExportContext'
 import { TLResizeHandle } from '../types/selection-types'
 
@@ -276,6 +278,22 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return []
 	}
 
+	/**
+	 * Get the geometry to use when snapping to this this shape in translate/resize operations. See
+	 * {@link BoundsSnapGeometry} for details.
+	 */
+	getBoundsSnapGeometry(shape: Shape): BoundsSnapGeometry {
+		return {}
+	}
+
+	/**
+	 * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
+	 * for details.
+	 */
+	getHandleSnapGeometry(shape: Shape): HandleSnapGeometry {
+		return {}
+	}
+
 	//  Events
 
 	/**

commit 50f77fe75c5962e61a628e58faa52ef218e68d14
Author: alex <alex@dytry.ch>
Date:   Mon Feb 19 17:27:29 2024 +0000

    [Snapping 6/6] Self-snapping API (#2869)
    
    This diff adds a self-snapping API for handles. Self-snapping is used
    when a shape's handles want to snap to the shape itself. By default,
    this isn't allowed because moving the handle might move the snap point,
    which creates a janky user experience.
    
    Now, shapes can return customised versions of their normal handle
    snapping geometry in these cases. As a bonus, line shapes now snap to
    other handles on their own line!
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Line handles should snap to other handles on the same line when
    holding command
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Line handles now snap to other handles on the same line when holding
    command
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index e7bb6ac21..1e4d13f4f 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -201,25 +201,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	getHandles?(shape: Shape): TLHandle[]
 
-	/**
-	 * Get an array of outline segments for the shape. For most shapes,
-	 * this will be a single segment that includes the entire outline.
-	 * For shapes with handles, this might be segments of the outline
-	 * between each handle.
-	 *
-	 * @example
-	 *
-	 * ```ts
-	 * util.getOutlineSegments(myShape)
-	 * ```
-	 *
-	 * @param shape - The shape.
-	 * @public
-	 */
-	getOutlineSegments(shape: Shape): Vec[][] {
-		return [this.editor.getShapeGeometry(shape).vertices]
-	}
-
 	/**
 	 * Get whether the shape can receive children of a given type.
 	 *

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 1e4d13f4f..d2c3c9553 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,6 +1,7 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { Migrations } from '@tldraw/store'
 import { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
+import { ReactElement } from 'react'
 import { Box } from '../../primitives/Box'
 import { Vec } from '../../primitives/Vec'
 import { Geometry2d } from '../../primitives/geometry/Geometry2d'
@@ -230,7 +231,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns An SVG element.
 	 * @public
 	 */
-	toSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement>
+	toSvg?(shape: Shape, ctx: SvgExportContext): ReactElement | null | Promise<ReactElement | null>
 
 	/**
 	 * Get the shape's background layer as an SVG object.
@@ -240,7 +241,10 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns An SVG element.
 	 * @public
 	 */
-	toBackgroundSvg?(shape: Shape, ctx: SvgExportContext): SVGElement | Promise<SVGElement> | null
+	toBackgroundSvg?(
+		shape: Shape,
+		ctx: SvgExportContext
+	): ReactElement | null | Promise<ReactElement | null>
 
 	/** @internal */
 	expandSelectionOutlinePx(shape: Shape): number {

commit f1e0af763184584a3297e7137d745af8567f1895
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Apr 5 15:23:02 2024 +0200

    Display none for culled shapes (#3291)
    
    Comparing different culling optimizations:
    
    
    https://github.com/tldraw/tldraw/assets/2523721/0b3b8b42-ed70-45b7-bf83-41023c36a563
    
    I think we should go with the `display: none` + showing the skeleteon.
    The way it works is:
    - We now add a sibling to the shape wrapper div which serves as the
    skeleton for the culled shapes.
    - Only one of the two divs (shape wrapper and skeleton div) is
    displayed. The other one is using `display: none` to improve
    performance.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [ ] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [x] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    - Improve performance of culled shapes by using `display: none`.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index d2c3c9553..fcdd38ce4 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -89,13 +89,6 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	canScroll: TLShapeUtilFlag<Shape> = () => false
 
-	/**
-	 * Whether the shape should unmount when not visible in the editor. Consider keeping this to false if the shape's `component` has local state.
-	 *
-	 * @public
-	 */
-	canUnmount: TLShapeUtilFlag<Shape> = () => true
-
 	/**
 	 * Whether the shape can be bound to by an arrow.
 	 *

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index fcdd38ce4..7cf297a5f 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -320,16 +320,15 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * ```ts
 	 * onDragShapesOver = (shape, shapes) => {
-	 * 	return { shouldHint: true }
+	 * 	this.editor.reparentShapes(shapes, shape.id)
 	 * }
 	 * ```
 	 *
 	 * @param shape - The shape.
 	 * @param shapes - The shapes that are being dragged over this one.
-	 * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
 	 * @public
 	 */
-	onDragShapesOver?: TLOnDragHandler<Shape, { shouldHint: boolean }>
+	onDragShapesOver?: TLOnDragHandler<Shape>
 
 	/**
 	 * A callback called when some other shapes are dragged out of this one.

commit 4f70a4f4e85b278e79a4afadec2eeb08f26879a8
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Apr 15 13:53:42 2024 +0100

    New migrations again (#3220)
    
    Describe what your pull request does. If appropriate, add GIFs or images
    showing the before and after.
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `galaxy brain` — Architectural changes
    
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    #### BREAKING CHANGES
    
    - The `Migrations` type is now called `LegacyMigrations`.
    - The serialized schema format (e.g. returned by
    `StoreSchema.serialize()` and `Store.getSnapshot()`) has changed. You
    don't need to do anything about it unless you were reading data directly
    from the schema for some reason. In which case it'd be best to avoid
    that in the future! We have no plans to change the schema format again
    (this time was traumatic enough) but you never know.
    - `compareRecordVersions` and the `RecordVersion` type have both
    disappeared. There is no replacement. These were public by mistake
    anyway, so hopefully nobody had been using it.
    - `compareSchemas` is a bit less useful now. Our migrations system has
    become a little fuzzy to allow for simpler UX when adding/removing
    custom extensions and 3rd party dependencies, and as a result we can no
    longer compare serialized schemas in any rigorous manner. You can rely
    on this function to return `0` if the schemas are the same. Otherwise it
    will return `-1` if the schema on the right _seems_ to be newer than the
    schema on the left, but it cannot guarantee that in situations where
    migration sequences have been removed over time (e.g. if you remove one
    of the builtin tldraw shapes).
    
    Generally speaking, the best way to check schema compatibility now is to
    call `store.schema.getMigrationsSince(persistedSchema)`. This will throw
    an error if there is no upgrade path from the `persistedSchema` to the
    current version.
    
    - `defineMigrations` has been deprecated and will be removed in a future
    release. For upgrade instructions see
    https://tldraw.dev/docs/persistence#Updating-legacy-shape-migrations-defineMigrations
    
    - `migrate` has been removed. Nobody should have been using this but if
    you were you'll need to find an alternative. For migrating tldraw data,
    you should stick to using `schema.migrateStoreSnapshot` and, if you are
    building a nuanced sync engine that supports some amount of backwards
    compatibility, also feel free to use `schema.migratePersistedRecord`.
    - the `Migration` type has changed. If you need the old one for some
    reason it has been renamed to `LegacyMigration`. It will be removed in a
    future release.
    - the `Migrations` type has been renamed to `LegacyMigrations` and will
    be removed in a future release.
    - the `SerializedSchema` type has been augmented. If you need the old
    version specifically you can use `SerializedSchemaV1`
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 7cf297a5f..e596d90f5 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,6 +1,13 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
-import { Migrations } from '@tldraw/store'
-import { ShapeProps, TLHandle, TLShape, TLShapePartial, TLUnknownShape } from '@tldraw/tlschema'
+import { LegacyMigrations, MigrationSequence } from '@tldraw/store'
+import {
+	ShapeProps,
+	TLHandle,
+	TLShape,
+	TLShapePartial,
+	TLShapePropsMigrations,
+	TLUnknownShape,
+} from '@tldraw/tlschema'
 import { ReactElement } from 'react'
 import { Box } from '../../primitives/Box'
 import { Vec } from '../../primitives/Vec'
@@ -19,7 +26,7 @@ export interface TLShapeUtilConstructor<
 	new (editor: Editor): U
 	type: T['type']
 	props?: ShapeProps<T>
-	migrations?: Migrations
+	migrations?: LegacyMigrations | TLShapePropsMigrations | MigrationSequence
 }
 
 /** @public */
@@ -35,7 +42,7 @@ export interface TLShapeUtilCanvasSvgDef {
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	constructor(public editor: Editor) {}
 	static props?: ShapeProps<TLUnknownShape>
-	static migrations?: Migrations
+	static migrations?: LegacyMigrations | TLShapePropsMigrations
 
 	/**
 	 * The type of the shape util, which should match the shape's type.

commit da35f2bd75e43fd48d11a9a74f60ee01c84a41d1
Author: alex <alex@dytry.ch>
Date:   Wed May 8 13:37:31 2024 +0100

    Bindings (#3326)
    
    First draft of the new bindings API. We'll follow this up with some API
    refinements, tests, documentation, and examples.
    
    Bindings are a new record type for establishing relationships between
    two shapes so they can update at the same time.
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Release Notes
    
    #### Breaking changes
    - The `start` and `end` properties on `TLArrowShape` no longer have
    `type: point | binding`. Instead, they're always a point, which may be
    out of date if a binding exists. To check for & retrieve arrow bindings,
    use `getArrowBindings(editor, shape)` instead.
    - `getArrowTerminalsInArrowSpace` must be passed a `TLArrowBindings` as
    a third argument: `getArrowTerminalsInArrowSpace(editor, shape,
    getArrowBindings(editor, shape))`
    - The following types have been renamed:
        - `ShapeProps` -> `RecordProps`
        - `ShapePropsType` -> `RecordPropsType`
        - `TLShapePropsMigrations` -> `TLPropsMigrations`
        - `SchemaShapeInfo` -> `SchemaPropsInfo`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index e596d90f5..838d8a941 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,11 +1,11 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
 import { LegacyMigrations, MigrationSequence } from '@tldraw/store'
 import {
-	ShapeProps,
+	RecordProps,
 	TLHandle,
+	TLPropsMigrations,
 	TLShape,
 	TLShapePartial,
-	TLShapePropsMigrations,
 	TLUnknownShape,
 } from '@tldraw/tlschema'
 import { ReactElement } from 'react'
@@ -25,8 +25,8 @@ export interface TLShapeUtilConstructor<
 > {
 	new (editor: Editor): U
 	type: T['type']
-	props?: ShapeProps<T>
-	migrations?: LegacyMigrations | TLShapePropsMigrations | MigrationSequence
+	props?: RecordProps<T>
+	migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence
 }
 
 /** @public */
@@ -41,8 +41,8 @@ export interface TLShapeUtilCanvasSvgDef {
 /** @public */
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	constructor(public editor: Editor) {}
-	static props?: ShapeProps<TLUnknownShape>
-	static migrations?: LegacyMigrations | TLShapePropsMigrations
+	static props?: RecordProps<TLUnknownShape>
+	static migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence
 
 	/**
 	 * The type of the shape util, which should match the shape's type.
@@ -132,6 +132,13 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	canCrop: TLShapeUtilFlag<Shape> = () => false
 
+	/**
+	 * Whether the shape participates in stacking, aligning, and distributing.
+	 *
+	 * @public
+	 */
+	canBeLaidOut: TLShapeUtilFlag<Shape> = () => true
+
 	/**
 	 * Does this shape provide a background for its children? If this is true,
 	 * then any children with a `renderBackground` method will have their

commit f9ed1bf2c9480b1c49f591a8609adfb4fcf91eae
Author: alex <alex@dytry.ch>
Date:   Wed May 22 16:55:49 2024 +0100

    Force `interface` instead of `type` for better docs (#3815)
    
    Typescript's type aliases (`type X = thing`) can refer to basically
    anything, which makes it hard to write an automatic document formatter
    for them. Interfaces on the other hand are only object, so they play
    much nicer with docs. Currently, object-flavoured type aliases don't
    really get expanded at all on our docs site, which means we have a bunch
    of docs content that's not shown on the site.
    
    This diff introduces a lint rule that forces `interface X {foo: bar}`s
    instead of `type X = {foo: bar}` where possible, as it results in a much
    better documentation experience:
    
    Before:
    <img width="437" alt="Screenshot 2024-05-22 at 15 24 13"
    src="https://github.com/tldraw/tldraw/assets/1489520/32606fd1-6832-4a1e-aa5f-f0534d160c92">
    
    After:
    <img width="431" alt="Screenshot 2024-05-22 at 15 33 01"
    src="https://github.com/tldraw/tldraw/assets/1489520/4e0d59ee-c38e-4056-b9fd-6a7f15d28f0f">
    
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `docs` — Changes to the documentation, examples, or templates.
    - [x] `improvement` — Improving existing features

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 838d8a941..f84672486 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -562,7 +562,7 @@ export type TLResizeMode = 'scale_shape' | 'resize_bounds'
  * @param initialShape - The shape at the start of the resize.
  * @public
  */
-export type TLResizeInfo<T extends TLShape> = {
+export interface TLResizeInfo<T extends TLShape> {
 	newPoint: Vec
 	handle: TLResizeHandle
 	mode: TLResizeMode

commit 87e3d60c9008e91dec81297f327fa5c6a8b76c6f
Author: alex <alex@dytry.ch>
Date:   Thu May 23 14:32:02 2024 +0100

    rework canBind callback (#3797)
    
    This PR reworks the `canBind` callback to work with customizable
    bindings. It now accepts an object with a the shape, the other shape
    (optional - it may not exist yet), the direction, and the type of the
    binding. Devs can use this to create shapes that only participate in
    certain binding types, can have bindings from but not to them, etc.
    
    If you're implementing a binding, you can see if binding two shapes is
    allowed using `editor.canBindShapes(fromShape, toShape, 'my binding
    type')`
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `improvement` — Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    The `canBind` flag now accepts an options object instead of just the
    shape in question. If you're relying on its arguments, you need to
    change from `canBind(shape) {}` to `canBind({shape}) {}`.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index f84672486..68f7e7828 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -32,6 +32,21 @@ export interface TLShapeUtilConstructor<
 /** @public */
 export type TLShapeUtilFlag<T> = (shape: T) => boolean
 
+/**
+ * Options passed to {@link ShapeUtil.canBind}. A binding that could be made. At least one of
+ * `fromShapeType` or `toShapeType` will belong to this shape util.
+ *
+ * @public
+ */
+export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLShape> {
+	/** The type of shape referenced by the `fromId` of the binding. */
+	fromShapeType: string
+	/** The type of shape referenced by the `toId` of the binding. */
+	toShapeType: string
+	/** The type of binding. */
+	bindingType: string
+}
+
 /** @public */
 export interface TLShapeUtilCanvasSvgDef {
 	key: string
@@ -97,12 +112,13 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	canScroll: TLShapeUtilFlag<Shape> = () => false
 
 	/**
-	 * Whether the shape can be bound to by an arrow.
+	 * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
 	 *
-	 * @param _otherShape - The other shape attempting to bind to this shape.
 	 * @public
 	 */
-	canBind = <K>(_shape: Shape, _otherShape?: K) => true
+	canBind(opts: TLShapeUtilCanBindOpts<Shape>): boolean {
+		return true
+	}
 
 	/**
 	 * Whether the shape can be double clicked to edit.

commit fb0dd1d2fe7d974dfa194264b4c3f196469cba97
Author: alex <alex@dytry.ch>
Date:   Mon Jun 10 14:50:03 2024 +0100

    make sure everything marked @public gets documented (#3892)
    
    Previously, we had the `ae-forgotten-export` rule from api-extractor
    disabled. This rule makes sure that everything that's referred to in the
    public API is actually exported. There are more details on the rule
    [here](https://api-extractor.com/pages/messages/ae-forgotten-export/),
    but not exporting public API entires is bad because they're hard to
    document and can't be typed/called from consumer code. For us, the big
    effect is that they don't appear in our docs at all.
    
    This diff re-enables that rule. Now, if you introduce something new to
    the public API but don't export it, your build will fail.
    
    ### Change Type
    
    - [x] `docs` — Changes to the documentation, examples, or templates.
    - [x] `improvement` — Improving existing features

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 68f7e7828..ce7596c26 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -542,17 +542,29 @@ export type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void
 /** @public */
 export type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void
 /** @public */
-export type TLOnTranslateStartHandler<T extends TLShape> = TLEventStartHandler<T>
+export type TLOnTranslateStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
 /** @public */
-export type TLOnTranslateHandler<T extends TLShape> = TLEventChangeHandler<T>
+export type TLOnTranslateHandler<T extends TLShape> = (
+	initial: T,
+	current: T
+) => TLShapePartial<T> | void
 /** @public */
-export type TLOnTranslateEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+export type TLOnTranslateEndHandler<T extends TLShape> = (
+	initial: T,
+	current: T
+) => TLShapePartial<T> | void
 /** @public */
-export type TLOnRotateStartHandler<T extends TLShape> = TLEventStartHandler<T>
+export type TLOnRotateStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
 /** @public */
-export type TLOnRotateHandler<T extends TLShape> = TLEventChangeHandler<T>
+export type TLOnRotateHandler<T extends TLShape> = (
+	initial: T,
+	current: T
+) => TLShapePartial<T> | void
 /** @public */
-export type TLOnRotateEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+export type TLOnRotateEndHandler<T extends TLShape> = (
+	initial: T,
+	current: T
+) => TLShapePartial<T> | void
 
 /**
  * The type of resize.
@@ -595,10 +607,13 @@ export type TLOnResizeHandler<T extends TLShape> = (
 ) => Omit<TLShapePartial<T>, 'id' | 'type'> | undefined | void
 
 /** @public */
-export type TLOnResizeStartHandler<T extends TLShape> = TLEventStartHandler<T>
+export type TLOnResizeStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
 
 /** @public */
-export type TLOnResizeEndHandler<T extends TLShape> = TLEventChangeHandler<T>
+export type TLOnResizeEndHandler<T extends TLShape> = (
+	initial: T,
+	current: T
+) => TLShapePartial<T> | void
 
 /* -------------------- Dragging -------------------- */
 
@@ -632,6 +647,3 @@ export type TLOnDoubleClickHandleHandler<T extends TLShape> = (
 	shape: T,
 	handle: TLHandle
 ) => TLShapePartial<T> | void
-
-type TLEventStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-type TLEventChangeHandler<T extends TLShape> = (initial: T, current: T) => TLShapePartial<T> | void

commit f4ceb581ddea5a0ed8aacab64f4a7ee0fe138879
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 15 15:04:22 2024 +0100

    `ShapeUtil.getInterpolatedProps` (#4162)
    
    This PR adds a `getInterpolatedProps` method to the `ShapeUtil` class.
    It is used in `Editor.animateShapes` to allow shapes to lerp values that
    the editor doesn't specifically know about.
    
    ![Kapture 2024-07-13 at 09 12
    48](https://github.com/user-attachments/assets/f9711aa0-278b-4a26-84d3-4b6bbe610b81)
    
    ### Change type
    
    - [x] `feature`
    - [x] `api`
    
    ### Test plan
    
    1. Animate a shape's props.
    
    ```ts
    
    const shape = editor.getOnlySelectedShape()
    
    setInterval(() => {
            editor.animateShape(
                    {
                            ...shape,
                            x: Math.random() * 500,
                            y: Math.random() * 200,
                            props: { w: 200 + Math.random() * 200, h: 200 + Math.random() * 200 },
                    },
                    { animation: { duration: 500 } }
            )
    }, 1000)
    ```
    
    - [ ] Unit tests (Could be done!)
    
    ### Release notes
    
    - SDK: adds `ShapeUtil.getInterpolatedProps` so that shapes can better
    participate in animations.
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index ce7596c26..047fd0309 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -211,6 +211,22 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	backgroundComponent?(shape: Shape): any
 
+	/**
+	 * Get the interpolated props for an animating shape. This is an optional method.
+	 *
+	 * @example
+	 *
+	 * ```ts
+	 * util.getInterpolatedProps?.(startShape, endShape, t)
+	 * ```
+	 *
+	 * @param startShape - The initial shape.
+	 * @param endShape - The initial shape.
+	 * @param progress - The normalized progress between zero (start) and 1 (end).
+	 * @public
+	 */
+	getInterpolatedProps?(startShape: Shape, endShape: Shape, progress: number): Shape['props']
+
 	/**
 	 * Get an array of handle models for the shape. This is an optional method.
 	 *

commit 423a0507b88d7a15fd08c0e1bf5e5fe92b7a656c
Author: alex <alex@dytry.ch>
Date:   Wed Jul 24 14:42:30 2024 +0100

    More sync papercuts (#4273)
    
    - Fix a bug in the cloudflare template
    - Remove awkward `cloudflare:*` dep from template
    - Slightly rework cloudflare readme for clarity
    - Add custom shapes section to sync docs
    - Make sure we have at least some reference docs on the relevant
    concepts needed for custom shapes.
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 047fd0309..314c6723b 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -56,7 +56,41 @@ export interface TLShapeUtilCanvasSvgDef {
 /** @public */
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	constructor(public editor: Editor) {}
+
+	/**
+	 * Props allow you to define the shape's properties in a way that the editor can understand.
+	 * This has two main uses:
+	 *
+	 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
+	 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
+	 *    once, and will be remembered from one shape to the next.
+	 *
+	 * @example
+	 * ```tsx
+	 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
+	 *
+	 * type MyShape = TLBaseShape<'mine', {
+	 *      color: TLDefaultColorStyle,
+	 *      text: string,
+	 * }>
+	 *
+	 * class MyShapeUtil extends ShapeUtil<MyShape> {
+	 *     static props = {
+	 *         // we use tldraw's built-in color style:
+	 *         color: DefaultColorStyle,
+	 *         // validate that the text prop is a string:
+	 *         text: T.string,
+	 *     }
+	 * }
+	 * ```
+	 */
 	static props?: RecordProps<TLUnknownShape>
+
+	/**
+	 * Migrations allow you to make changes to a shape's props over time. Read the
+	 * {@link https://staging.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
+	 * guide for more information.
+	 */
 	static migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence
 
 	/**

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 314c6723b..8803a949f 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -29,9 +29,6 @@ export interface TLShapeUtilConstructor<
 	migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence
 }
 
-/** @public */
-export type TLShapeUtilFlag<T> = (shape: T) => boolean
-
 /**
  * Options passed to {@link ShapeUtil.canBind}. A binding that could be made. At least one of
  * `fromShapeType` or `toShapeType` will belong to this shape util.
@@ -136,21 +133,25 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	canSnap: TLShapeUtilFlag<Shape> = () => true
+	canSnap(_shape: Shape): boolean {
+		return true
+	}
 
 	/**
 	 * Whether the shape can be scrolled while editing.
 	 *
 	 * @public
 	 */
-	canScroll: TLShapeUtilFlag<Shape> = () => false
+	canScroll(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
 	 *
 	 * @public
 	 */
-	canBind(opts: TLShapeUtilCanBindOpts<Shape>): boolean {
+	canBind(_opts: TLShapeUtilCanBindOpts<Shape>): boolean {
 		return true
 	}
 
@@ -159,35 +160,45 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	canEdit: TLShapeUtilFlag<Shape> = () => false
+	canEdit(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape can be resized.
 	 *
 	 * @public
 	 */
-	canResize: TLShapeUtilFlag<Shape> = () => true
+	canResize(_shape: Shape): boolean {
+		return true
+	}
 
 	/**
 	 * Whether the shape can be edited in read-only mode.
 	 *
 	 * @public
 	 */
-	canEditInReadOnly: TLShapeUtilFlag<Shape> = () => false
+	canEditInReadOnly(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape can be cropped.
 	 *
 	 * @public
 	 */
-	canCrop: TLShapeUtilFlag<Shape> = () => false
+	canCrop(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape participates in stacking, aligning, and distributing.
 	 *
 	 * @public
 	 */
-	canBeLaidOut: TLShapeUtilFlag<Shape> = () => true
+	canBeLaidOut(_shape: Shape): boolean {
+		return true
+	}
 
 	/**
 	 * Does this shape provide a background for its children? If this is true,
@@ -198,7 +209,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @internal
 	 */
-	providesBackgroundForChildren(shape: Shape): boolean {
+	providesBackgroundForChildren(_shape: Shape): boolean {
 		return false
 	}
 
@@ -207,35 +218,45 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	hideResizeHandles: TLShapeUtilFlag<Shape> = () => false
+	hideResizeHandles(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape should hide its rotation handles when selected.
 	 *
 	 * @public
 	 */
-	hideRotateHandle: TLShapeUtilFlag<Shape> = () => false
+	hideRotateHandle(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape should hide its selection bounds background when selected.
 	 *
 	 * @public
 	 */
-	hideSelectionBoundsBg: TLShapeUtilFlag<Shape> = () => false
+	hideSelectionBoundsBg(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape should hide its selection bounds foreground when selected.
 	 *
 	 * @public
 	 */
-	hideSelectionBoundsFg: TLShapeUtilFlag<Shape> = () => false
+	hideSelectionBoundsFg(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Whether the shape's aspect ratio is locked.
 	 *
 	 * @public
 	 */
-	isAspectRatioLocked: TLShapeUtilFlag<Shape> = () => false
+	isAspectRatioLocked(_shape: Shape): boolean {
+		return false
+	}
 
 	/**
 	 * Get a JSX element for the shape (as an HTML element) to be rendered as part of the canvas background - behind any other shape content.
@@ -281,7 +302,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param type - The shape type.
 	 * @public
 	 */
-	canReceiveNewChildrenOfType(shape: Shape, type: TLShape['type']) {
+	canReceiveNewChildrenOfType(_shape: Shape, _type: TLShape['type']) {
 		return false
 	}
 
@@ -292,7 +313,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dropped.
 	 * @public
 	 */
-	canDropShapes(shape: Shape, shapes: TLShape[]) {
+	canDropShapes(_shape: Shape, _shapes: TLShape[]) {
 		return false
 	}
 
@@ -340,7 +361,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * Get the geometry to use when snapping to this this shape in translate/resize operations. See
 	 * {@link BoundsSnapGeometry} for details.
 	 */
-	getBoundsSnapGeometry(shape: Shape): BoundsSnapGeometry {
+	getBoundsSnapGeometry(_shape: Shape): BoundsSnapGeometry {
 		return {}
 	}
 
@@ -348,7 +369,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
 	 * for details.
 	 */
-	getHandleSnapGeometry(shape: Shape): HandleSnapGeometry {
+	getHandleSnapGeometry(_shape: Shape): HandleSnapGeometry {
 		return {}
 	}
 
@@ -370,7 +391,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns The next shape or void.
 	 * @public
 	 */
-	onBeforeCreate?: TLOnBeforeCreateHandler<Shape>
+	onBeforeCreate?(next: Shape): Shape | void
 
 	/**
 	 * A callback called just before a shape is updated. This method provides a last chance to modify
@@ -391,7 +412,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns The next shape or void.
 	 * @public
 	 */
-	onBeforeUpdate?: TLOnBeforeUpdateHandler<Shape>
+	onBeforeUpdate?(prev: Shape, next: Shape): Shape | void
 
 	/**
 	 * A callback called when some other shapes are dragged over this one.
@@ -408,7 +429,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dragged over this one.
 	 * @public
 	 */
-	onDragShapesOver?: TLOnDragHandler<Shape>
+	onDragShapesOver?(shape: Shape, shapes: TLShape[]): void
 
 	/**
 	 * A callback called when some other shapes are dragged out of this one.
@@ -417,7 +438,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dragged out.
 	 * @public
 	 */
-	onDragShapesOut?: TLOnDragHandler<Shape>
+	onDragShapesOut?(shape: Shape, shapes: TLShape[]): void
 
 	/**
 	 * A callback called when some other shapes are dropped over this one.
@@ -426,7 +447,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shapes - The shapes that are being dropped over this one.
 	 * @public
 	 */
-	onDropShapesOver?: TLOnDragHandler<Shape>
+	onDropShapesOver?(shape: Shape, shapes: TLShape[]): void
 
 	/**
 	 * A callback called when a shape starts being resized.
@@ -435,7 +456,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResizeStart?: TLOnResizeStartHandler<Shape>
+	onResizeStart?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape changes from a resize.
@@ -445,7 +466,10 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResize?: TLOnResizeHandler<Shape>
+	onResize?(
+		shape: Shape,
+		info: TLResizeInfo<Shape>
+	): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void
 
 	/**
 	 * A callback called when a shape finishes resizing.
@@ -455,7 +479,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onResizeEnd?: TLOnResizeEndHandler<Shape>
+	onResizeEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape starts being translated.
@@ -464,7 +488,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslateStart?: TLOnTranslateStartHandler<Shape>
+	onTranslateStart?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape changes from a translation.
@@ -474,7 +498,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslate?: TLOnTranslateHandler<Shape>
+	onTranslate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape finishes translating.
@@ -484,7 +508,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onTranslateEnd?: TLOnTranslateEndHandler<Shape>
+	onTranslateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape's handle changes.
@@ -494,7 +518,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onHandleDrag?: TLOnHandleDragHandler<Shape>
+	onHandleDrag?(shape: Shape, info: TLHandleDragInfo<Shape>): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape starts being rotated.
@@ -503,7 +527,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotateStart?: TLOnRotateStartHandler<Shape>
+	onRotateStart?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape changes from a rotation.
@@ -513,7 +537,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotate?: TLOnRotateHandler<Shape>
+	onRotate?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape finishes rotating.
@@ -523,14 +547,14 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onRotateEnd?: TLOnRotateEndHandler<Shape>
+	onRotateEnd?(initial: Shape, current: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * Not currently used.
 	 *
 	 * @internal
 	 */
-	onBindingChange?: TLOnBindingChangeHandler<Shape>
+	onBindingChange?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape's children change.
@@ -539,7 +563,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns An array of shape updates, or void.
 	 * @public
 	 */
-	onChildrenChange?: TLOnChildrenChangeHandler<Shape>
+	onChildrenChange?(shape: Shape): TLShapePartial[] | void
 
 	/**
 	 * A callback called when a shape's handle is double clicked.
@@ -549,7 +573,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClickHandle?: TLOnDoubleClickHandleHandler<Shape>
+	onDoubleClickHandle?(shape: Shape, handle: TLHandle): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape's edge is double clicked.
@@ -558,7 +582,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClickEdge?: TLOnDoubleClickHandler<Shape>
+	onDoubleClickEdge?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape is double clicked.
@@ -567,7 +591,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onDoubleClick?: TLOnDoubleClickHandler<Shape>
+	onDoubleClick?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape is clicked.
@@ -576,7 +600,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @returns A change to apply to the shape, or void.
 	 * @public
 	 */
-	onClick?: TLOnClickHandler<Shape>
+	onClick?(shape: Shape): TLShapePartial<Shape> | void
 
 	/**
 	 * A callback called when a shape finishes being editing.
@@ -584,38 +608,9 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * @param shape - The shape.
 	 * @public
 	 */
-	onEditEnd?: TLOnEditEndHandler<Shape>
+	onEditEnd?(shape: Shape): void
 }
 
-/** @public */
-export type TLOnBeforeCreateHandler<T extends TLShape> = (next: T) => T | void
-/** @public */
-export type TLOnBeforeUpdateHandler<T extends TLShape> = (prev: T, next: T) => T | void
-/** @public */
-export type TLOnTranslateStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-/** @public */
-export type TLOnTranslateHandler<T extends TLShape> = (
-	initial: T,
-	current: T
-) => TLShapePartial<T> | void
-/** @public */
-export type TLOnTranslateEndHandler<T extends TLShape> = (
-	initial: T,
-	current: T
-) => TLShapePartial<T> | void
-/** @public */
-export type TLOnRotateStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-/** @public */
-export type TLOnRotateHandler<T extends TLShape> = (
-	initial: T,
-	current: T
-) => TLShapePartial<T> | void
-/** @public */
-export type TLOnRotateEndHandler<T extends TLShape> = (
-	initial: T,
-	current: T
-) => TLShapePartial<T> | void
-
 /**
  * The type of resize.
  *
@@ -650,50 +645,11 @@ export interface TLResizeInfo<T extends TLShape> {
 	initialShape: T
 }
 
-/** @public */
-export type TLOnResizeHandler<T extends TLShape> = (
-	shape: T,
-	info: TLResizeInfo<T>
-) => Omit<TLShapePartial<T>, 'id' | 'type'> | undefined | void
-
-/** @public */
-export type TLOnResizeStartHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-
-/** @public */
-export type TLOnResizeEndHandler<T extends TLShape> = (
-	initial: T,
-	current: T
-) => TLShapePartial<T> | void
-
 /* -------------------- Dragging -------------------- */
 
 /** @public */
-export type TLOnDragHandler<T extends TLShape, R = void> = (shape: T, shapes: TLShape[]) => R
-
-/** @internal */
-export type TLOnBindingChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-
-/** @public */
-export type TLOnChildrenChangeHandler<T extends TLShape> = (shape: T) => TLShapePartial[] | void
-
-/** @public */
-export type TLOnHandleDragHandler<T extends TLShape> = (
-	shape: T,
-	info: {
-		handle: TLHandle
-		isPrecise: boolean
-		initial?: T | undefined
-	}
-) => TLShapePartial<T> | void
-
-/** @public */
-export type TLOnClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-/** @public */
-export type TLOnEditEndHandler<T extends TLShape> = (shape: T) => void
-/** @public */
-export type TLOnDoubleClickHandler<T extends TLShape> = (shape: T) => TLShapePartial<T> | void
-/** @public */
-export type TLOnDoubleClickHandleHandler<T extends TLShape> = (
-	shape: T,
+export interface TLHandleDragInfo<T extends TLShape> {
 	handle: TLHandle
-) => TLShapePartial<T> | void
+	isPrecise: boolean
+	initial?: T | undefined
+}

commit e0f36407d9b8297ed77e5507c52b88949cdfc745
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Aug 1 16:47:01 2024 +0200

    [Feature, Example] Text search example and `getText` API (#4306)
    
    Motivated by #3495
    
    An example of how to add custom search via`⌘+f` keyboard shortcuts. This
    also adds `getText` method to `ShapeUtil`, which allows the users to
    query the shapes for text.
    
    Down the line we could choose to add something like `getShapesWithText`
    to the editor and maybe even add some UI to dotcom. For now, let's just
    expose the API.
    
    
    https://github.com/user-attachments/assets/5631301c-a02a-4b66-8dbf-09571e67a46c
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Adds `getText` to the `ShapeUtil` api so that we can allow searching
    for text in a nicely extensible way.
    - Adds an example of how to add text search.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 8803a949f..71b438a1b 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -373,6 +373,10 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return {}
 	}
 
+	getText(_shape: Shape): string | undefined {
+		return undefined
+	}
+
 	//  Events
 
 	/**

commit 8f092336a1663c2bb25d9046bf66b266113c59cf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Aug 2 12:24:55 2024 +0100

    Fix some broken links in the docs (#4340)
    
    This PR fixes some broken links in the docs.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 71b438a1b..6c4d4cc6b 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -85,7 +85,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 
 	/**
 	 * Migrations allow you to make changes to a shape's props over time. Read the
-	 * {@link https://staging.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
+	 * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 	 * guide for more information.
 	 */
 	static migrations?: LegacyMigrations | TLPropsMigrations | MigrationSequence

commit adda30254754d9985bdc1b4c2eca94a176c0dea2
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Sep 30 13:08:56 2024 +0200

    Add eslint rule to check that tsdoc params match with function params (#4615)
    
    After this
    [conversation](https://discord.com/channels/859816885297741824/859816885801713728/1289133853822423050)
    I noticed that our tsdocs `@params` and our function / method
    definitions don't always match. We often miss tsdoc params or have
    outdated names for them.
    
    This PR:
    - Adds an eslint rule to check whether the tsdoc params and the function
    params / method arguments match. It allows for using `_` in function
    params (you can specifiy `@param shapes` in the tsdocs but use `_shapes:
    SomeType` in function. This helps with some functions that get
    overriden, like [this
    one](https://github.com/tldraw/tldraw/blob/a19c8f73898d59500accd87d416b4ae9a7a82ece/packages/editor/src/lib/editor/shapes/ShapeUtil.ts#L299-L308).
    - It fixes the issues that the new rule found.
    - Also adds the `select` argument back to the `createShape` and
    `createShapes` methods. We could also go the other way and remove the
    docs instead of adding the argument.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Add lint rules to check for discrepancies between tsdoc params and
    function params and fix all the discovered issues.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 6c4d4cc6b..5029979fc 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -299,6 +299,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	/**
 	 * Get whether the shape can receive children of a given type.
 	 *
+	 * @param shape - The shape.
 	 * @param type - The shape type.
 	 * @public
 	 */

commit 48cd187b3a258ea75864e9e572217e990b5a0c00
Author: Trygve Aaberge <trygve.aaberge@autodesk.com>
Date:   Mon Jan 6 18:25:03 2025 +0100

    Allow expandSelectionOutlinePx to return a Box (#5168)
    
    This allows the selection outline to be expanded by different amounts on
    each side by supporting returning a `Box` from
    `expandSelectionOutlinePx`. Currently it only supports returning a
    number which will expand the selection that amount on each side.
    
    Together with #5137 this allows us to implement an alternative cropping
    behavior where the shape size remains fixed while cropping, while the
    uncropped image size is what you change instead. This is useful in
    scenarios where you want to first lay out shapes in a certain layout,
    and afterwards crop them so they display the portion of the image you
    want.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Add a `expandSelectionOutlinePx` function to a shape that returns a
    Box.
    2. Verify that the selection outline is expanded according to this Box.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Support expanding the selection outline by different amounts on each
    side by returning a `Box` from `expandSelectionOutlinePx`.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 5029979fc..d7c64349e 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -342,7 +342,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	): ReactElement | null | Promise<ReactElement | null>
 
 	/** @internal */
-	expandSelectionOutlinePx(shape: Shape): number {
+	expandSelectionOutlinePx(shape: Shape): number | Box {
 		return 0
 	}
 

commit 7a17cab026a311d76361825f446407b0e330597c
Author: Trygve Aaberge <trygve.aaberge@autodesk.com>
Date:   Tue Jan 28 11:42:43 2025 +0100

    Add an onCrop handler to ShapeUtil (#5137)
    
    This is called when cropping and allows you to override the crop
    calculations. This is useful for instance to set a min width and/or
    height for the cropping.
    
    It can also be used to provide a completely different cropping
    mechanism, e.g. to keep the size of the shape fixed and instead resize
    the image when cropping. This would require overriding the
    SelectionForeground component, but it's better to only have to override
    that than the whole selection tool. And maybe that component can be made
    more dynamic in the future.
    
    This also defines specific crop interfaces instead of using the ones
    from the image shape and uses the correct util instead of the image util
    when cropping. Any shape can define that it supports cropping, so I
    don't think it should be tied to the image shape.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Add an onCrop handler to a util for a shape that can be cropped.
    1. Create a shape with a crop prop.
    2. Try to crop the shape and see that the behavior in onCrop is applied.
    
    - [x] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Add support for an onCrop handler on shape utils that allows you to
    prevent or modify the crop.
    - The `TLImageShapeCrop` type has been replaced by `TLShapeCrop`.
    
    ---------
    
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index d7c64349e..6df8d3dfa 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -5,11 +5,12 @@ import {
 	TLHandle,
 	TLPropsMigrations,
 	TLShape,
+	TLShapeCrop,
 	TLShapePartial,
 	TLUnknownShape,
 } from '@tldraw/tlschema'
 import { ReactElement } from 'react'
-import { Box } from '../../primitives/Box'
+import { Box, SelectionHandle } from '../../primitives/Box'
 import { Vec } from '../../primitives/Vec'
 import { Geometry2d } from '../../primitives/geometry/Geometry2d'
 import type { Editor } from '../Editor'
@@ -419,6 +420,19 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	onBeforeUpdate?(prev: Shape, next: Shape): Shape | void
 
+	/**
+	 * A callback called when a shape changes from a crop.
+	 *
+	 * @param shape - The shape at the start of the crop.
+	 * @param info - Info about the crop.
+	 * @returns A change to apply to the shape, or void.
+	 * @public
+	 */
+	onCrop?(
+		shape: Shape,
+		info: TLCropInfo<Shape>
+	): Omit<TLShapePartial<Shape>, 'id' | 'type'> | undefined | void
+
 	/**
 	 * A callback called when some other shapes are dragged over this one.
 	 *
@@ -616,6 +630,21 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	onEditEnd?(shape: Shape): void
 }
 
+/**
+ * Info about a crop.
+ * @param handle - The handle being dragged.
+ * @param change - The distance the handle is moved.
+ * @param initialShape - The shape at the start of the resize.
+ * @public
+ */
+export interface TLCropInfo<T extends TLShape> {
+	handle: SelectionHandle
+	change: Vec
+	crop: TLShapeCrop
+	uncroppedSize: { w: number; h: number }
+	initialShape: T
+}
+
 /**
  * The type of resize.
  *

commit 9ba9ef2308bf7b3d41842f4f945e61e4d5f8c6a7
Author: alex <alex@dytry.ch>
Date:   Mon Feb 10 18:02:12 2025 +0000

    ShapeUtil.configure for shape options (#5399)
    
    This diff tweaks the shape options API added in #5349 so that it's no
    longer global. Instead, shape utils have a `.configure()` method, which
    accepts a partial of their options and returns a new shape util with
    those options applied.
    
    We also tweak the behaviour of passing in custom shape utils to play
    nicer with this: previously, if you passed in a shape util with type
    "arrow", an error would be thrown complaining about duplicate shape
    utils because the default one was already specified. Now, we won't try
    to include the default arrow util because we can see you using a custom
    one. If you pass two utils with the type "arrow", you'll still get an
    error.
    
    ### Change type
    - [x] `api`
    
    ### Release notes
    
    - introduces shape options & `ShapeUtil.configure`, a utility for
    passing options to a shape util
    - moves (unreleased) noteShapeResizeMode to NoteShapeOptions.resizeMode
    - If you pass tldraw a shape util with the same type as a default, it'll
    now replace the default rather than crash
    - **BREAKING** `options.maxDrawShapePoints` should now be specified with
    `DrawShapeUtil.configure({maxPoints})` and
    `HighlightShapeUtil.configure({maxPoints})`

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 6df8d3dfa..25689239f 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -53,8 +53,27 @@ export interface TLShapeUtilCanvasSvgDef {
 
 /** @public */
 export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
+	/** Configure this shape utils {@link ShapeUtil.options | `options`}. */
+	static configure<T extends TLShapeUtilConstructor<any, any>>(
+		this: T,
+		options: T extends new (...args: any[]) => { options: infer Options } ? Partial<Options> : never
+	): T {
+		// @ts-expect-error -- typescript has no idea what's going on here but it's fine
+		return class extends this {
+			// @ts-expect-error
+			options = { ...this.options, ...options }
+		}
+	}
+
 	constructor(public editor: Editor) {}
 
+	/**
+	 * Options for this shape util. If you're implementing a custom shape util, you can override
+	 * this to provide customization options for your shape. If using an existing shape util, you
+	 * can customizing this by calling {@link ShapeUtil.configure}.
+	 */
+	options = {}
+
 	/**
 	 * Props allow you to define the shape's properties in a way that the editor can understand.
 	 * This has two main uses:

commit d799df28e99e17bb71d1ab198f7c910fc3987a88
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Feb 25 14:17:56 2025 +0000

    Fix text padding, add context to shape geometry (#5487)
    
    Long have we suffered from this:
    
    <img width="630" alt="image"
    src="https://github.com/user-attachments/assets/6675d2be-09e4-4f08-8d1b-5c30ec8ff2c5"
    />
    
    Text has no horizontal padding. We've tried adding horizontal padding
    before (see #1084, #2855) however we always ran into a circular problem.
    
    - Adding horizontal text padding makes arrows look better
    - ...but then it runs alignment / snapping / selection
    - ...and it makes text move around
    
    
    ![image](https://github.com/user-attachments/assets/ab12d896-d5df-486b-aca8-19170cae781b)
    
    What do we really want? **Contextual geometry**.
    
    ![Kapture 2025-02-24 at 15 42
    22](https://github.com/user-attachments/assets/84e4c2b9-3688-410c-ae3f-e386d5fd8b6c)
    
    If I'm creating arrow info, I might want a different geometry than if
    I'm snapping or aligning.
    
    **Pros:**
    
     - Additive API, no other changes
     - No migrations needed
     - Opens the door for other contextual geometries
    - Might be useful also for lines, highlighters, draw shapes, and other
    shapes
    
    **Cons**
    
    - More geometries cached (ie any shape that I've ever pointed an arrow
    to)
    
    ### Change type
    
    - [x] `improvement`
    - [x] `api`
    
    ### Test plan
    
    1. Create a text shape
    2. Make a horizontal arrow pointing from the text shape to something
    else
    
    ### Release notes
    
    - Improved horizontal padding for arrows bound to text shapes

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 25689239f..a7398af9a 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -45,6 +45,16 @@ export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLShape>
 	bindingType: string
 }
 
+/**
+ * Additional options for the {@link ShapeUtil.getGeometry} method.
+ *
+ * @public
+ */
+export interface TLGeometryOpts {
+	/** The context in which the geometry is being requested. */
+	context?: string
+}
+
 /** @public */
 export interface TLShapeUtilCanvasSvgDef {
 	key: string
@@ -128,9 +138,10 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 * Get the shape's geometry.
 	 *
 	 * @param shape - The shape.
+	 * @param opts - Additional options for the request.
 	 * @public
 	 */
-	abstract getGeometry(shape: Shape): Geometry2d
+	abstract getGeometry(shape: Shape, opts?: TLGeometryOpts): Geometry2d
 
 	/**
 	 * Get a JSX element for the shape (as an HTML element).

commit 54b645dd9728bc7629b4a451dc96867a39cf98f6
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Feb 25 16:05:20 2025 +0000

    Improve / fix layout methods: alignment, distribute, flip, stack. (#5479)
    
    This PR fixes various bugs in our layout methods: align, distribute,
    flip, stack, pack, etc.
    
    There are a lot of small changes and fixes in this PR but the main one
    is **shape clustering**.
    
    ## Shape clustering
    
    Previously, all of our layout options had bugs related to arrows. Our
    early solution was to ignore arrows, however this only partially solved
    the problem. Often the results would not be anywhere near
    expectations—obviously wrong—but there wasn't a clear idea of what would
    be correct.
    
    While working on this problem, I had the idea to try treating networks
    of bound-and-selected shapes as "clusters" that would move together.
    This was specifically to solve a problem that could occur when aligning
    a shape that had an arrow bound to it and the other end not bound to
    anything.
    
    In this PR, all of our layout functions (except flip) move "clusters"
    rather than individual shapes—though most clusters only contain a single
    shape.
    
    <img width="553" alt="image"
    src="https://github.com/user-attachments/assets/7245689c-80bd-4ae0-85df-d42d00251d44"
    />
    
    This fixes many problems which were previously impossible to solve. A
    use can bail out of the behavior by not selecting the arrows, just as
    they could before.
    
    ## Alignment
    
    Alignment now works correctly with clusters of bound shapes.
    
    ![Kapture 2025-02-23 at 09 41
    23](https://github.com/user-attachments/assets/de75ae58-17ab-430d-871f-cd8a0f3ad05e)
    
    ![Kapture 2025-02-23 at 18 19
    47](https://github.com/user-attachments/assets/10cc8841-8ec0-4d98-9872-545edcc1002d)
    
    ![Kapture 2025-02-23 at 18 21
    57](https://github.com/user-attachments/assets/fee0d432-5242-45dd-a47c-c659326f91fa)
    
    ## Distribution
    
    Distribution now works correctly with clusters of bound shapes.
    
    Adjusts the logic for distribution so that the result will **space
    shapes out evenly between** the first and last shapes, rather than
    spacing out the centers of the shapes.
    
    Fixes a bug when distributing shapes if the same shape constituted the
    first and last shape.
    
    Fixes a bug when distributing shapes if the last shape would change the
    dimensions of the selection.
    
    ![Kapture 2025-02-23 at 09 44
    11](https://github.com/user-attachments/assets/9991a149-9eb1-43e7-bc7c-0dcc6f1a087b)
    
    ![Kapture 2025-02-23 at 18 24
    40](https://github.com/user-attachments/assets/2dd815a1-7e0c-424f-b1d5-5377fbe41ddb)
    
    ## Flip
    
    I fixed a minor bug with arrows in flipping.
    
    ![Kapture 2025-02-23 at 15 03
    04](https://github.com/user-attachments/assets/59a1d7cc-6956-4f1b-a772-a4ae1fd4414c)
    
    ## Stretch
    
    Stretch now works with clusters of shapes.
    
    Fixed a limitation with rotated shapes. Previously, stretching did not
    support any page-rotated shapes unless their page rotation was a
    multiple of PI2. It now supports shapes with any rotation equal to PI /
    2 (e.g. 90, 180, 270, or 360 degrees, and so on).
    
    ## Pack
    
    Pack not works with clusters of shapes.
    
    ![Kapture 2025-02-23 at 17 48
    12](https://github.com/user-attachments/assets/2b9a35d4-1387-42db-97d1-80966a3822b0)
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Test plan
    
    1. Align a shape to an edge where that edge in the shape bounds is
    defined by an arrow
    2. Distribute overlapping or irregular shapes
    
    - [x] Unit tests
    
    ### Release notes
    
    - Fixes several bugs when aligning / flipping / distributing /
    stretching / stacking a selection that included with arrows.
    - Fixed a bug with distribution with overlapping shapes
    - Fixed a bug with distribution that could lead to changed selection.
    - Fixed a bug preventing rotated shapes from being stretched.

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index a7398af9a..626770c84 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -36,7 +36,7 @@ export interface TLShapeUtilConstructor<
  *
  * @public
  */
-export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLShape> {
+export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLUnknownShape> {
 	/** The type of shape referenced by the `fromId` of the binding. */
 	fromShapeType: string
 	/** The type of shape referenced by the `toId` of the binding. */
@@ -46,7 +46,18 @@ export interface TLShapeUtilCanBindOpts<Shape extends TLUnknownShape = TLShape>
 }
 
 /**
- * Additional options for the {@link ShapeUtil.getGeometry} method.
+ * Options passed to {@link ShapeUtil.canBeLaidOut}.
+ *
+ * @public
+ */
+export interface TLShapeUtilCanBeLaidOutOpts {
+	/** The type of action causing the layout. */
+	type?: 'align' | 'distribute' | 'pack' | 'stack' | 'flip' | 'stretch'
+	/** The other shapes being laid out */
+	shapes?: TLShape[]
+}
+
+/** Additional options for the {@link ShapeUtil.getGeometry} method.
  *
  * @public
  */
@@ -162,6 +173,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	/**
 	 * Whether the shape can be snapped to by another shape.
 	 *
+	 * @param shape - The shape.
 	 * @public
 	 */
 	canSnap(_shape: Shape): boolean {
@@ -182,7 +194,7 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 *
 	 * @public
 	 */
-	canBind(_opts: TLShapeUtilCanBindOpts<Shape>): boolean {
+	canBind(_opts: TLShapeUtilCanBindOpts): boolean {
 		return true
 	}
 
@@ -223,11 +235,15 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	}
 
 	/**
-	 * Whether the shape participates in stacking, aligning, and distributing.
+	 * Whether the shape can participate in layout functions such as alignment or distribution.
+	 *
+	 * @param shape - The shape.
+	 * @param info - Additional context information: the type of action causing the layout and the
+	 * @public
 	 *
 	 * @public
 	 */
-	canBeLaidOut(_shape: Shape): boolean {
+	canBeLaidOut(_shape: Shape, _info: TLShapeUtilCanBeLaidOutOpts): boolean {
 		return true
 	}
 

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists↔headers, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster — I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool — can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 626770c84..6f4eba70e 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -1,4 +1,5 @@
 /* eslint-disable @typescript-eslint/no-unused-vars */
+import { EMPTY_ARRAY } from '@tldraw/state'
 import { LegacyMigrations, MigrationSequence } from '@tldraw/store'
 import {
 	RecordProps,
@@ -14,6 +15,7 @@ import { Box, SelectionHandle } from '../../primitives/Box'
 import { Vec } from '../../primitives/Vec'
 import { Geometry2d } from '../../primitives/geometry/Geometry2d'
 import type { Editor } from '../Editor'
+import { TLFontFace } from '../managers/FontManager'
 import { BoundsSnapGeometry } from '../managers/SnapManager/BoundsSnaps'
 import { HandleSnapGeometry } from '../managers/SnapManager/HandleSnaps'
 import { SvgExportContext } from '../types/SvgExportContext'
@@ -170,6 +172,17 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 	 */
 	abstract indicator(shape: Shape): any
 
+	/**
+	 * Get the font faces that should be rendered in the document in order for this shape to render
+	 * correctly.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	getFontFaces(shape: Shape): TLFontFace[] {
+		return EMPTY_ARRAY
+	}
+
 	/**
 	 * Whether the shape can be snapped to by another shape.
 	 *

commit 629125a2e474effa3536411584aaac8f77657673
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Apr 3 16:07:49 2025 +0100

    a11y: navigable shapes (#5761)
    
    As part of a [larger push](https://github.com/tldraw/tldraw/issues/5215)
    to add accessibility to our SDK, a big piece of that work is being able
    to navigate through our shapes in some kind of predictable fashion. This
    builds upon @Taha-Hassan-Git 's great work and knowledge in this area,
    thanks man. :tip-o-the-hat:
    
    Things that were tackled in this PR:
    - navigating shapes using the Tab key, when in the Select tool.
    - navigating shapes using Cmd/Ctrl+Arrow keys, when in the Select tool.
    - only allowing certain shapes to be navigated to. We ignore
    draw/highlighter/arrow/group/line. Groups need exploration and will be
    tackled later.
    - panning the camera to the selected shape, but avoiding doing so in a
    jarring way. We don't center the shape to avoid too much whiplashy-ness.
    
    An initial foray into this was relaying purely on DOM but it had a bunch
    of browser quirks which forced making this purely a programmatic control
    on our end. Things like ensuring culled shapes are still accessible even
    though they're not rendered was one of the issues but also tab order
    became unpredictable at times which steered me away from that direction.
    
    We coud have considered using something like rbush for some spatial
    indexing of the shapes. For the intents and purposes of this PR, it
    seemed like overkill at the moment. But we might cross that bridge down
    the line, we'll see.
    
    The reading-direction heuristics are a combination of dividing the pages
    into rows and then looking at distance and angles to see what is the
    spatially "next" shape to be read. It takes _all_ of the shapes and
    sorts them into a logical order so that nothing is missed/skipped when
    tabbing around.
    The directional-arrow heuristics don't divide things into rows and don't
    create a sorted set of shapes. Instead, they decide based on the current
    shape and direction which is the next spatially to go to, depending on
    distance+angle.
    
    There's a decent amount of nuance in this kind of navigation but it's
    not all covered in this PR, for separate PRs, we'll look at:
    - [x] adding a "skipping to content" button
    - [ ] question whether maybe directional navigation visits ‘canTabTo’
    shapes, maybe yes?
    - [ ] tackling what Enter/Escape should do when on the canvas shapes
    - [ ] how to deal with hierarchy / parent-child / frame / group shapes
    - [ ] and more
    
    
    
    https://github.com/user-attachments/assets/49b6b34e-2553-4047-846f-5d3383e1e3c6
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - a11y: navigable shapes using Tab and Cmd/Ctrl+Arrow

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 6f4eba70e..3caeb1efe 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -193,6 +193,16 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return true
 	}
 
+	/**
+	 * Whether the shape can be tabbed to.
+	 *
+	 * @param shape - The shape.
+	 * @public
+	 */
+	canTabTo(_shape: Shape): boolean {
+		return true
+	}
+
 	/**
 	 * Whether the shape can be scrolled while editing.
 	 *

commit 4ecb34d3434dbd9ad3119d4dfc66b7af4e598faf
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Apr 7 22:05:44 2025 +0100

    a11y: announce shapes as they're visited (#5773)
    
    Building off of https://github.com/tldraw/tldraw/pull/5634 and
    https://github.com/tldraw/tldraw/pull/5761 this is adding a11y live text
    to be read aloud when visiting a shape.
    
    We add an overridable method for shapes to customize this called
    `getAriaLiveText`.
    Furthermore, we lay the groundwork here to start letting media shapes
    have `altText`.
    Drive-by fix of `heart` being missing in `geo-styles` list.
    Also, drive-by fix of us calling our Image button "Asset" (what are we
    selling financial instruments here? :P) "Media" is a better word for
    this button, more human.
    
    Some of the i18n translation is funky. It's a shortcoming of our current
    system that we don't support interpolation :-/
    It sucks, and we'll revisit in the future.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - a11y: announce shapes as they're visited
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
index 3caeb1efe..f8a37bc6e 100644
--- a/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
+++ b/packages/editor/src/lib/editor/shapes/ShapeUtil.ts
@@ -448,6 +448,10 @@ export abstract class ShapeUtil<Shape extends TLUnknownShape = TLUnknownShape> {
 		return undefined
 	}
 
+	getAriaDescriptor(_shape: Shape): string | undefined {
+		return undefined
+	}
+
 	//  Events
 
 	/**

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    