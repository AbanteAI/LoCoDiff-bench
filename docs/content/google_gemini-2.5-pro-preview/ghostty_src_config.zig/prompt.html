<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/config.zig - Gemini 2.5 Pro 05-06</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/config.zig</h1>
        <h2>Model: Gemini 2.5 Pro 05-06</h2>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview/ghostty_src_config.zig.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/config.zig

commit 3b54d05aeca9b3fe1116a975e0c7df470722e0e6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 14:00:35 2022 -0700

    CLI parsing, can set default foreground/background color

diff --git a/src/config.zig b/src/config.zig
new file mode 100644
index 00000000..e5a6d031
--- /dev/null
+++ b/src/config.zig
@@ -0,0 +1,60 @@
+const std = @import("std");
+
+pub const Config = struct {
+    /// Background color for the window.
+    background: Color = .{ .r = 0, .g = 0, .b = 0 },
+
+    /// Foreground color for the window.
+    foreground: Color = .{ .r = 0xFF, .g = 0xA5, .b = 0 },
+};
+
+/// Color represents a color using RGB.
+pub const Color = struct {
+    r: u8,
+    g: u8,
+    b: u8,
+
+    pub const Error = error{
+        InvalidFormat,
+    };
+
+    pub fn parseCLI(input: ?[]const u8) !Color {
+        return fromHex(input orelse return error.ValueRequired);
+    }
+
+    /// fromHex parses a color from a hex value such as #RRGGBB. The "#"
+    /// is optional.
+    pub fn fromHex(input: []const u8) !Color {
+        // Trim the beginning '#' if it exists
+        const trimmed = if (input.len != 0 and input[0] == '#') input[1..] else input;
+
+        // We expect exactly 6 for RRGGBB
+        if (trimmed.len != 6) return Error.InvalidFormat;
+
+        // Parse the colors two at a time.
+        var result: Color = undefined;
+        comptime var i: usize = 0;
+        inline while (i < 6) : (i += 2) {
+            const v: u8 =
+                ((try std.fmt.charToDigit(trimmed[i], 16)) * 10) +
+                try std.fmt.charToDigit(trimmed[i + 1], 16);
+
+            @field(result, switch (i) {
+                0 => "r",
+                2 => "g",
+                4 => "b",
+                else => unreachable,
+            }) = v;
+        }
+
+        return result;
+    }
+};
+
+test "Color.fromHex" {
+    const testing = std.testing;
+
+    try testing.expectEqual(Color{ .r = 0, .g = 0, .b = 0 }, try Color.fromHex("#000000"));
+    try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("#0A0B0C"));
+    try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("0A0B0C"));
+}

commit 57f257fd773ecd496c71aa85e1fb1623756aebc7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 15:20:28 2022 -0700

    cli args support optional types

diff --git a/src/config.zig b/src/config.zig
index e5a6d031..2df4b75f 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,6 +6,10 @@ pub const Config = struct {
 
     /// Foreground color for the window.
     foreground: Color = .{ .r = 0xFF, .g = 0xA5, .b = 0 },
+
+    /// The command to run, usually a shell. If this is not an absolute path,
+    /// it'll be looked up in the PATH.
+    command: ?[]const u8 = null,
 };
 
 /// Color represents a color using RGB.

commit da359b8e3664ded902d7287bcb9832e6db45de4f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu May 19 15:49:26 2022 -0700

    properly copy string cli flags

diff --git a/src/config.zig b/src/config.zig
index 2df4b75f..47297b80 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const ArenaAllocator = std.heap.ArenaAllocator;
 
 pub const Config = struct {
     /// Background color for the window.
@@ -10,6 +11,14 @@ pub const Config = struct {
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH.
     command: ?[]const u8 = null,
+
+    /// This is set by the CLI parser for deinit.
+    _arena: ?ArenaAllocator = null,
+
+    pub fn deinit(self: *Config) void {
+        if (self._arena) |arena| arena.deinit();
+        self.* = undefined;
+    }
 };
 
 /// Color represents a color using RGB.

commit 439e72536a99870345b2b5f500bcdb1b2b19d142
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri May 20 15:47:18 2022 -0700

    misparsing colors

diff --git a/src/config.zig b/src/config.zig
index 47297b80..bcd07dfb 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -49,7 +49,7 @@ pub const Color = struct {
         comptime var i: usize = 0;
         inline while (i < 6) : (i += 2) {
             const v: u8 =
-                ((try std.fmt.charToDigit(trimmed[i], 16)) * 10) +
+                ((try std.fmt.charToDigit(trimmed[i], 16)) * 16) +
                 try std.fmt.charToDigit(trimmed[i + 1], 16);
 
             @field(result, switch (i) {
@@ -70,4 +70,5 @@ test "Color.fromHex" {
     try testing.expectEqual(Color{ .r = 0, .g = 0, .b = 0 }, try Color.fromHex("#000000"));
     try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("#0A0B0C"));
     try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("0A0B0C"));
+    try testing.expectEqual(Color{ .r = 255, .g = 255, .b = 255 }, try Color.fromHex("FFFFFF"));
 }

commit 6641fcbd4c749d2f731b33baf1199c7f41ebbba0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 21 21:35:04 2022 -0700

    add --font-size flag for font size in pixels

diff --git a/src/config.zig b/src/config.zig
index bcd07dfb..a77c1f1f 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -2,6 +2,9 @@ const std = @import("std");
 const ArenaAllocator = std.heap.ArenaAllocator;
 
 pub const Config = struct {
+    /// Font size
+    @"font-size": u8 = 14,
+
     /// Background color for the window.
     background: Color = .{ .r = 0, .g = 0, .b = 0 },
 

commit 0249f3c174907ca8fdfe966c98c2a355d760e68f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 1 11:54:51 2022 -0700

    cli parsing supports modification, add "RepeatableString" as example
    
    This lets values modify themselves, which we use to make a repeatable
    string implementation. We will use this initially to specify config
    files to load.

diff --git a/src/config.zig b/src/config.zig
index a77c1f1f..efd89caa 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 
 pub const Config = struct {
@@ -15,6 +16,9 @@ pub const Config = struct {
     /// it'll be looked up in the PATH.
     command: ?[]const u8 = null,
 
+    /// Additional configuration files to read.
+    @"config-file": RepeatableString = .{},
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 
@@ -65,13 +69,46 @@ pub const Color = struct {
 
         return result;
     }
+
+    test "fromHex" {
+        const testing = std.testing;
+
+        try testing.expectEqual(Color{ .r = 0, .g = 0, .b = 0 }, try Color.fromHex("#000000"));
+        try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("#0A0B0C"));
+        try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("0A0B0C"));
+        try testing.expectEqual(Color{ .r = 255, .g = 255, .b = 255 }, try Color.fromHex("FFFFFF"));
+    }
 };
 
-test "Color.fromHex" {
-    const testing = std.testing;
+/// RepeatableString is a string value that can be repeated to accumulate
+/// a list of strings. This isn't called "StringList" because I find that
+/// sometimes leads to confusion that it _accepts_ a list such as
+/// comma-separated values.
+pub const RepeatableString = struct {
+    const Self = @This();
+
+    // Allocator for the list is the arena for the parent config.
+    list: std.ArrayListUnmanaged([]const u8) = .{},
+
+    pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {
+        const value = input orelse return error.ValueRequired;
+        try self.list.append(alloc, value);
+    }
+
+    test "parseCLI" {
+        const testing = std.testing;
+        var arena = ArenaAllocator.init(testing.allocator);
+        defer arena.deinit();
+        const alloc = arena.allocator();
+
+        var list: Self = .{};
+        try list.parseCLI(alloc, "A");
+        try list.parseCLI(alloc, "B");
+
+        try testing.expectEqual(@as(usize, 2), list.list.items.len);
+    }
+};
 
-    try testing.expectEqual(Color{ .r = 0, .g = 0, .b = 0 }, try Color.fromHex("#000000"));
-    try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("#0A0B0C"));
-    try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("0A0B0C"));
-    try testing.expectEqual(Color{ .r = 255, .g = 255, .b = 255 }, try Color.fromHex("FFFFFF"));
+test {
+    std.testing.refAllDecls(@This());
 }

commit 782ddfe722dd6aa145a72f5b7d85a347b59c0b26
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 1 18:04:39 2022 -0700

    --config-file to load a config file
    
    The config file is just CLI args one per line.

diff --git a/src/config.zig b/src/config.zig
index efd89caa..63043eb4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -2,6 +2,8 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 
+/// Config is the main config struct. These fields map directly to the
+/// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
     /// Font size
     @"font-size": u8 = 14,

commit e3ddffdf369a19a9999efa8d900db1b518cc92b8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 9 10:21:23 2022 -0700

    don't scale up OpenGL projection in Retina, use true values
    
    This gets rid of blurriness.

diff --git a/src/config.zig b/src/config.zig
index 63043eb4..0b68542e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,7 +6,10 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
     /// Font size
-    @"font-size": u8 = 14,
+    /// TODO: this default size is too big, what we need to do is use a reasonable
+    /// size and then mult a high-DPI scaling factor. This is only high because
+    /// all our test machines are high-DPI right now.
+    @"font-size": u8 = 32,
 
     /// Background color for the window.
     background: Color = .{ .r = 0, .g = 0, .b = 0 },

commit 2800a468546b1068da6f518dd93b011a4d2e6f60
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 24 09:31:14 2022 -0700

    keybind parsing in CLI args

diff --git a/src/config.zig b/src/config.zig
index 0b68542e..8e24814f 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,6 +1,7 @@
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
+const inputpkg = @import("input.zig");
 
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
@@ -21,6 +22,37 @@ pub const Config = struct {
     /// it'll be looked up in the PATH.
     command: ?[]const u8 = null,
 
+    /// Key bindings. The format is "trigger=action". Duplicate triggers
+    /// will overwrite previously set values.
+    ///
+    /// Trigger: "+"-separated list of keys and modifiers. Example:
+    /// "ctrl+a", "ctrl+shift+b", "up". Some notes:
+    ///
+    ///   - modifiers cannot repeat, "ctrl+ctrl+a" is invalid.
+    ///   - modifers and key scan be in any order, "shift+a+ctrl" is weird,
+    ///     but valid.
+    ///   - only a single key input is allowed, "ctrl+a+b" is invalid.
+    ///
+    /// Action is the action to take when the trigger is satisfied. It takes
+    /// the format "action" or "action:param". The latter form is only valid
+    /// if the action requires a parameter.
+    ///
+    ///   - "ignore" - Do nothing, ignore the key input. This can be used to
+    ///     black hole certain inputs to have no effect.
+    ///   - "unbind" - Remove the binding. This makes it so the previous action
+    ///     is removed, and the key will be sent through to the child command
+    ///     if it is printable.
+    ///   - "csi:text" - Send a CSI sequence. i.e. "csi:A" sends "cursor up".
+    ///
+    /// Some notes for the action:
+    ///
+    ///   - The parameter is taken as-is after the ":". Double quotes or
+    ///     other mechanisms are included and NOT parsed. If you want to
+    ///     send a string value that includes spaces, wrap the entire
+    ///     trigger/action in double quotes. Example: --keybind="up=csi:A B"
+    ///
+    keybind: Keybinds = .{},
+
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 
@@ -114,6 +146,48 @@ pub const RepeatableString = struct {
     }
 };
 
+/// Stores a set of keybinds.
+pub const Keybinds = struct {
+    set: inputpkg.Binding.Set = .{},
+
+    pub fn parseCLI(self: *Keybinds, alloc: Allocator, input: ?[]const u8) !void {
+        var copy: ?[]u8 = null;
+        var value = value: {
+            const value = input orelse return error.ValueRequired;
+
+            // If we don't have a colon, use the value as-is, no copy
+            if (std.mem.indexOf(u8, value, ":") == null)
+                break :value value;
+
+            // If we have a colon, we copy the whole value for now. We could
+            // do this more efficiently later if we wanted to.
+            const buf = try alloc.alloc(u8, value.len);
+            copy = buf;
+
+            std.mem.copy(u8, buf, value);
+            break :value buf;
+        };
+        errdefer if (copy) |v| alloc.free(v);
+
+        const binding = try inputpkg.Binding.parse(value);
+        switch (binding.action) {
+            .unbind => self.set.remove(binding.trigger),
+            else => try self.set.put(alloc, binding.trigger, binding.action),
+        }
+    }
+
+    test "parseCLI" {
+        const testing = std.testing;
+        var arena = ArenaAllocator.init(testing.allocator);
+        defer arena.deinit();
+        const alloc = arena.allocator();
+
+        var set: Keybinds = .{};
+        try set.parseCLI(alloc, "shift+a=copy_to_clipboard");
+        try set.parseCLI(alloc, "shift+a=csi:hello");
+    }
+};
+
 test {
     std.testing.refAllDecls(@This());
 }

commit 80376ce6da94e44d6d7e62ebc083ff32ae1b30ed
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 24 11:08:39 2022 -0700

    hook up keybindings for copy/paste and arrow keys

diff --git a/src/config.zig b/src/config.zig
index 8e24814f..87f773d3 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -20,7 +20,7 @@ pub const Config = struct {
 
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH.
-    command: ?[]const u8 = null,
+    command: ?[]const u8,
 
     /// Key bindings. The format is "trigger=action". Duplicate triggers
     /// will overwrite previously set values.
@@ -63,6 +63,38 @@ pub const Config = struct {
         if (self._arena) |arena| arena.deinit();
         self.* = undefined;
     }
+
+    pub fn default(alloc_gpa: Allocator) Allocator.Error!Config {
+        var arena = ArenaAllocator.init(alloc_gpa);
+        errdefer arena.deinit();
+        const alloc = arena.allocator();
+
+        // Build up our basic config
+        var result: Config = .{
+            ._arena = arena,
+            .command = "sh",
+        };
+
+        // Add our default keybindings
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .c, .mods = .{ .super = true } },
+            .{ .copy_to_clipboard = 0 },
+        );
+
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .v, .mods = .{ .super = true } },
+            .{ .paste_from_clipboard = 0 },
+        );
+
+        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .csi = "A" });
+        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .csi = "B" });
+        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .csi = "C" });
+        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .csi = "D" });
+
+        return result;
+    }
 };
 
 /// Color represents a color using RGB.

commit 3b5a9caff5fbe1dc0d48190fd66c5e7a872ed5c4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 24 11:16:36 2022 -0700

    hook up more control keys: home, end, page up, page down

diff --git a/src/config.zig b/src/config.zig
index 87f773d3..c8a622ce 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -92,6 +92,10 @@ pub const Config = struct {
         try result.keybind.set.put(alloc, .{ .key = .down }, .{ .csi = "B" });
         try result.keybind.set.put(alloc, .{ .key = .right }, .{ .csi = "C" });
         try result.keybind.set.put(alloc, .{ .key = .left }, .{ .csi = "D" });
+        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .csi = "H" });
+        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .csi = "F" });
+        try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
+        try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
 
         return result;
     }

commit 9601920b4dab1ddfb1e26ef4397a12a443f04c23
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Aug 25 12:29:28 2022 -0700

    font size is now in font points, determine size based on window DPI

diff --git a/src/config.zig b/src/config.zig
index c8a622ce..1fa3dc93 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,11 +6,8 @@ const inputpkg = @import("input.zig");
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
-    /// Font size
-    /// TODO: this default size is too big, what we need to do is use a reasonable
-    /// size and then mult a high-DPI scaling factor. This is only high because
-    /// all our test machines are high-DPI right now.
-    @"font-size": u8 = 32,
+    /// Font size in points
+    @"font-size": u8 = 12,
 
     /// Background color for the window.
     background: Color = .{ .r = 0, .g = 0, .b = 0 },

commit 469515c02bd34201d762c00b996e996100d2a6b1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 26 10:27:41 2022 -0700

    bind function keys (F1 to F12)

diff --git a/src/config.zig b/src/config.zig
index 1fa3dc93..a1adb6bb 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -94,6 +94,26 @@ pub const Config = struct {
         try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
         try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
 
+        // From xterm:
+        // Note that F1 through F4 are prefixed with SS3 , while the other keys are
+        // prefixed with CSI .  Older versions of xterm implement different escape
+        // sequences for F1 through F4, with a CSI  prefix.  These can be activated
+        // by setting the oldXtermFKeys resource.  However, since they do not
+        // correspond to any hardware terminal, they have been deprecated.  (The
+        // DEC VT220 reserves F1 through F5 for local functions such as Setup).
+        try result.keybind.set.put(alloc, .{ .key = .f1 }, .{ .csi = "11~" });
+        try result.keybind.set.put(alloc, .{ .key = .f2 }, .{ .csi = "12~" });
+        try result.keybind.set.put(alloc, .{ .key = .f3 }, .{ .csi = "13~" });
+        try result.keybind.set.put(alloc, .{ .key = .f4 }, .{ .csi = "14~" });
+        try result.keybind.set.put(alloc, .{ .key = .f5 }, .{ .csi = "15~" });
+        try result.keybind.set.put(alloc, .{ .key = .f6 }, .{ .csi = "17~" });
+        try result.keybind.set.put(alloc, .{ .key = .f7 }, .{ .csi = "18~" });
+        try result.keybind.set.put(alloc, .{ .key = .f8 }, .{ .csi = "19~" });
+        try result.keybind.set.put(alloc, .{ .key = .f9 }, .{ .csi = "20~" });
+        try result.keybind.set.put(alloc, .{ .key = .f10 }, .{ .csi = "21~" });
+        try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
+        try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
+
         return result;
     }
 };

commit 5567564dd0b37da47db6252d04f6f1b05ddb9305
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 29 13:14:20 2022 -0700

    cli args fix stage1 miscompilation, add font families

diff --git a/src/config.zig b/src/config.zig
index a1adb6bb..d93f8678 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,6 +6,12 @@ const inputpkg = @import("input.zig");
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
+    /// The font families to use.
+    @"font-family": ?[]const u8 = null,
+    @"font-family-bold": ?[]const u8 = null,
+    @"font-family-italic": ?[]const u8 = null,
+    @"font-family-bold-italic": ?[]const u8 = null,
+
     /// Font size in points
     @"font-size": u8 = 12,
 

commit 53aab0a163baf726104bb46738f4fe77c95e8412
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 29 14:51:31 2022 -0700

    --font-family CLI config

diff --git a/src/config.zig b/src/config.zig
index d93f8678..7448f7ae 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -7,10 +7,10 @@ const inputpkg = @import("input.zig");
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
     /// The font families to use.
-    @"font-family": ?[]const u8 = null,
-    @"font-family-bold": ?[]const u8 = null,
-    @"font-family-italic": ?[]const u8 = null,
-    @"font-family-bold-italic": ?[]const u8 = null,
+    @"font-family": ?[:0]const u8 = null,
+    @"font-family-bold": ?[:0]const u8 = null,
+    @"font-family-italic": ?[:0]const u8 = null,
+    @"font-family-bold-italic": ?[:0]const u8 = null,
 
     /// Font size in points
     @"font-size": u8 = 12,
@@ -122,6 +122,25 @@ pub const Config = struct {
 
         return result;
     }
+
+    pub fn finalize(self: *Config) !void {
+        // If we have a font-family set and don't set the others, default
+        // the others to the font family. This way, if someone does
+        // --font-family=foo, then we try to get the stylized versions of
+        // "foo" as well.
+        if (self.@"font-family") |family| {
+            const fields = &[_][]const u8{
+                "font-family-bold",
+                "font-family-italic",
+                "font-family-bold-italic",
+            };
+            inline for (fields) |field| {
+                if (@field(self, field) == null) {
+                    @field(self, field) = family;
+                }
+            }
+        }
+    }
 };
 
 /// Color represents a color using RGB.

commit f29393bca64ac05ea721170cef093fa248b3a903
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 16 16:20:08 2022 -0700

    Imgui (#20)
    
    * vendor/cimgui
    
    * Add a "dev mode" window which for now is just imgui demo

diff --git a/src/config.zig b/src/config.zig
index 7448f7ae..6bd7a322 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -120,6 +120,13 @@ pub const Config = struct {
         try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
         try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
 
+        // Dev Mode
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .grave_accent, .mods = .{ .shift = true, .super = true } },
+            .{ .toggle_dev_mode = 0 },
+        );
+
         return result;
     }
 

commit c103a278f1a890282283a6b147e54944eb7c6235
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Oct 17 14:47:51 2022 -0700

    render font info in dev mode

diff --git a/src/config.zig b/src/config.zig
index 6bd7a322..acdab5a4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -123,7 +123,7 @@ pub const Config = struct {
         // Dev Mode
         try result.keybind.set.put(
             alloc,
-            .{ .key = .grave_accent, .mods = .{ .shift = true, .super = true } },
+            .{ .key = .down, .mods = .{ .shift = true, .super = true } },
             .{ .toggle_dev_mode = 0 },
         );
 

commit d8cdd5d8fe6c9d7fa88cf9f5652867f59082e07d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 25 15:48:13 2022 -0700

    Fix the primary leak with config

diff --git a/src/config.zig b/src/config.zig
index acdab5a4..02fa61d5 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -68,15 +68,13 @@ pub const Config = struct {
     }
 
     pub fn default(alloc_gpa: Allocator) Allocator.Error!Config {
-        var arena = ArenaAllocator.init(alloc_gpa);
-        errdefer arena.deinit();
-        const alloc = arena.allocator();
-
         // Build up our basic config
         var result: Config = .{
-            ._arena = arena,
+            ._arena = ArenaAllocator.init(alloc_gpa),
             .command = "sh",
         };
+        errdefer result.deinit();
+        const alloc = result._arena.?.allocator();
 
         // Add our default keybindings
         try result.keybind.set.put(

commit f09ba38c6f5dea8734bc6fd5b4d87973a56fde6e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 13:25:20 2022 -0700

    remove stage1 hack

diff --git a/src/config.zig b/src/config.zig
index 02fa61d5..a35885ad 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -80,13 +80,13 @@ pub const Config = struct {
         try result.keybind.set.put(
             alloc,
             .{ .key = .c, .mods = .{ .super = true } },
-            .{ .copy_to_clipboard = 0 },
+            .{ .copy_to_clipboard = {} },
         );
 
         try result.keybind.set.put(
             alloc,
             .{ .key = .v, .mods = .{ .super = true } },
-            .{ .paste_from_clipboard = 0 },
+            .{ .paste_from_clipboard = {} },
         );
 
         try result.keybind.set.put(alloc, .{ .key = .up }, .{ .csi = "A" });
@@ -122,7 +122,7 @@ pub const Config = struct {
         try result.keybind.set.put(
             alloc,
             .{ .key = .down, .mods = .{ .shift = true, .super = true } },
-            .{ .toggle_dev_mode = 0 },
+            .{ .toggle_dev_mode = {} },
         );
 
         return result;

commit 7da18d8063042d6e46519391492fb598912247f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 14:02:10 2022 -0700

    look up default shell in user passwd entry

diff --git a/src/config.zig b/src/config.zig
index a35885ad..37c85483 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,8 +1,18 @@
 const std = @import("std");
+const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const inputpkg = @import("input.zig");
 
+const log = std.log.scoped(.config);
+
+/// Used to determine the default shell and directory on Unixes.
+const c = @cImport({
+    @cInclude("sys/types.h");
+    @cInclude("unistd.h");
+    @cInclude("pwd.h");
+});
+
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
@@ -23,7 +33,7 @@ pub const Config = struct {
 
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH.
-    command: ?[]const u8,
+    command: ?[]const u8 = null,
 
     /// Key bindings. The format is "trigger=action". Duplicate triggers
     /// will overwrite previously set values.
@@ -71,7 +81,6 @@ pub const Config = struct {
         // Build up our basic config
         var result: Config = .{
             ._arena = ArenaAllocator.init(alloc_gpa),
-            .command = "sh",
         };
         errdefer result.deinit();
         const alloc = result._arena.?.allocator();
@@ -145,6 +154,36 @@ pub const Config = struct {
                 }
             }
         }
+
+        // If we are missing either a command or home directory, we need
+        // to look up defaults which is kind of expensive.
+        if (self.command == null) command: {
+            var buf: [1024]u8 = undefined;
+            var pw: c.struct_passwd = undefined;
+            var pw_ptr: ?*c.struct_passwd = null;
+            const res = c.getpwuid_r(c.getuid(), &pw, &buf, buf.len, &pw_ptr);
+            if (res != 0) {
+                log.warn("error retrieving pw entry code={d}", .{res});
+                break :command;
+            }
+
+            if (pw_ptr == null) {
+                // Future: let's check if a better shell is available like zsh
+                log.warn("no pw entry to detect default shell, will default to 'sh'", .{});
+                self.command = "sh";
+                break :command;
+            }
+
+            if (pw.pw_shell) |ptr| {
+                const source = std.mem.sliceTo(ptr, 0);
+                const alloc = self._arena.?.allocator();
+                const sh = try alloc.alloc(u8, source.len);
+                std.mem.copy(u8, sh, source);
+
+                log.debug("default shell={s}", .{sh});
+                self.command = sh;
+            }
+        }
     }
 };
 

commit 74d8d6cd6c2ef51357392f1509eb9ff4566e83dc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 14:09:40 2022 -0700

    source default shell from SHELL if set

diff --git a/src/config.zig b/src/config.zig
index 37c85483..ddd1e069 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -32,7 +32,12 @@ pub const Config = struct {
     foreground: Color = .{ .r = 0xFF, .g = 0xA5, .b = 0 },
 
     /// The command to run, usually a shell. If this is not an absolute path,
-    /// it'll be looked up in the PATH.
+    /// it'll be looked up in the PATH. If this is not set, a default will
+    /// be looked up from your system. The rules for the default lookup are:
+    ///
+    ///   - SHELL environment variable
+    ///   - passwd entry (user information)
+    ///
     command: ?[]const u8 = null,
 
     /// Key bindings. The format is "trigger=action". Duplicate triggers
@@ -158,6 +163,15 @@ pub const Config = struct {
         // If we are missing either a command or home directory, we need
         // to look up defaults which is kind of expensive.
         if (self.command == null) command: {
+            const alloc = self._arena.?.allocator();
+
+            // First look up the command using the SHELL env var.
+            if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
+                log.debug("default shell source=env value={s}", .{value});
+                self.command = value;
+                break :command;
+            } else |_| {}
+
             var buf: [1024]u8 = undefined;
             var pw: c.struct_passwd = undefined;
             var pw_ptr: ?*c.struct_passwd = null;
@@ -176,11 +190,10 @@ pub const Config = struct {
 
             if (pw.pw_shell) |ptr| {
                 const source = std.mem.sliceTo(ptr, 0);
-                const alloc = self._arena.?.allocator();
                 const sh = try alloc.alloc(u8, source.len);
                 std.mem.copy(u8, sh, source);
 
-                log.debug("default shell={s}", .{sh});
+                log.debug("default shell src=passwd value={s}", .{sh});
                 self.command = sh;
             }
         }

commit be1fa7851131b55465bd921dab09327f7a1d200a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 17:47:34 2022 -0700

    extract passwd to its own file so its easier to test

diff --git a/src/config.zig b/src/config.zig
index ddd1e069..859e21d8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,16 +3,10 @@ const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const inputpkg = @import("input.zig");
+const passwd = @import("passwd.zig");
 
 const log = std.log.scoped(.config);
 
-/// Used to determine the default shell and directory on Unixes.
-const c = @cImport({
-    @cInclude("sys/types.h");
-    @cInclude("unistd.h");
-    @cInclude("pwd.h");
-});
-
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
@@ -172,27 +166,9 @@ pub const Config = struct {
                 break :command;
             } else |_| {}
 
-            var buf: [1024]u8 = undefined;
-            var pw: c.struct_passwd = undefined;
-            var pw_ptr: ?*c.struct_passwd = null;
-            const res = c.getpwuid_r(c.getuid(), &pw, &buf, buf.len, &pw_ptr);
-            if (res != 0) {
-                log.warn("error retrieving pw entry code={d}", .{res});
-                break :command;
-            }
-
-            if (pw_ptr == null) {
-                // Future: let's check if a better shell is available like zsh
-                log.warn("no pw entry to detect default shell, will default to 'sh'", .{});
-                self.command = "sh";
-                break :command;
-            }
-
-            if (pw.pw_shell) |ptr| {
-                const source = std.mem.sliceTo(ptr, 0);
-                const sh = try alloc.alloc(u8, source.len);
-                std.mem.copy(u8, sh, source);
-
+            // Get the shell from the passwd entry
+            const pw = try passwd.get(alloc);
+            if (pw.shell) |sh| {
                 log.debug("default shell src=passwd value={s}", .{sh});
                 self.command = sh;
             }

commit df50aacff162146c54ad8ec8486072cec92283a2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 18:10:30 2022 -0700

    macos: Default working directory to home dir if launched from app
    
    This also introduces a `--working-directory` config flag.

diff --git a/src/config.zig b/src/config.zig
index 859e21d8..c1dd56c1 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -7,6 +7,11 @@ const passwd = @import("passwd.zig");
 
 const log = std.log.scoped(.config);
 
+/// Used on Unixes for some defaults.
+const c = @cImport({
+    @cInclude("unistd.h");
+});
+
 /// Config is the main config struct. These fields map directly to the
 /// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
 pub const Config = struct {
@@ -34,6 +39,20 @@ pub const Config = struct {
     ///
     command: ?[]const u8 = null,
 
+    /// The directory to change to after starting the command.
+    ///
+    /// The default is "inherit" except in special scenarios listed next.
+    /// If ghostty can detect it is launched on macOS from launchd
+    /// (double-clicked), then it defaults to "home".
+    ///
+    /// The value of this must be an absolute value or one of the special
+    /// values below:
+    ///
+    ///   - "home" - The home directory of the executing user.
+    ///   - "inherit" - The working directory of the launching process.
+    ///
+    @"working-directory": ?[]const u8 = null,
+
     /// Key bindings. The format is "trigger=action". Duplicate triggers
     /// will overwrite previously set values.
     ///
@@ -154,23 +173,41 @@ pub const Config = struct {
             }
         }
 
+        // The default for the working directory depends on the system.
+        const wd_default = switch (builtin.os.tag) {
+            .macos => if (c.getppid() == 1) "home" else "inherit",
+            else => "inherit",
+        };
+
         // If we are missing either a command or home directory, we need
         // to look up defaults which is kind of expensive.
-        if (self.command == null) command: {
+        const wd_home = std.mem.eql(u8, "home", self.@"working-directory" orelse wd_default);
+        if (self.command == null or wd_home) command: {
             const alloc = self._arena.?.allocator();
 
             // First look up the command using the SHELL env var.
             if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
                 log.debug("default shell source=env value={s}", .{value});
                 self.command = value;
-                break :command;
+
+                // If we don't need the working directory, then we can exit now.
+                if (!wd_home) break :command;
             } else |_| {}
 
-            // Get the shell from the passwd entry
+            // We need the passwd entry for the remainder
             const pw = try passwd.get(alloc);
-            if (pw.shell) |sh| {
-                log.debug("default shell src=passwd value={s}", .{sh});
-                self.command = sh;
+            if (self.command == null) {
+                if (pw.shell) |sh| {
+                    log.debug("default shell src=passwd value={s}", .{sh});
+                    self.command = sh;
+                }
+            }
+
+            if (wd_home) {
+                if (pw.home) |home| {
+                    log.debug("default working directory src=passwd value={s}", .{home});
+                    self.@"working-directory" = home;
+                }
             }
         }
     }

commit b528d435fbd9932ddb361c5b8b6127c29ed091e2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 18:22:33 2022 -0700

    properly handle "inherit" working directory value

diff --git a/src/config.zig b/src/config.zig
index c1dd56c1..0b937bf7 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -174,14 +174,14 @@ pub const Config = struct {
         }
 
         // The default for the working directory depends on the system.
-        const wd_default = switch (builtin.os.tag) {
+        const wd = self.@"working-directory" orelse switch (builtin.os.tag) {
             .macos => if (c.getppid() == 1) "home" else "inherit",
             else => "inherit",
         };
 
         // If we are missing either a command or home directory, we need
         // to look up defaults which is kind of expensive.
-        const wd_home = std.mem.eql(u8, "home", self.@"working-directory" orelse wd_default);
+        const wd_home = std.mem.eql(u8, "home", wd);
         if (self.command == null or wd_home) command: {
             const alloc = self._arena.?.allocator();
 
@@ -210,6 +210,10 @@ pub const Config = struct {
                 }
             }
         }
+
+        // If we have the special value "inherit" then set it to null which
+        // does the same. In the future we should change to a tagged union.
+        if (std.mem.eql(u8, wd, "inherit")) self.@"working-directory" = null;
     }
 };
 

commit 116a157e170dee753545610546dbbdbfb4d3ad44
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 1 18:25:36 2022 -0700

    change defaults to be more aesthetically pleasing

diff --git a/src/config.zig b/src/config.zig
index 0b937bf7..9cd4ebdc 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -22,13 +22,18 @@ pub const Config = struct {
     @"font-family-bold-italic": ?[:0]const u8 = null,
 
     /// Font size in points
-    @"font-size": u8 = 12,
+    @"font-size": u8 = switch (builtin.os.tag) {
+        // On Mac we default a little bigger since this tends to look better.
+        // This is purely subjective but this is easy to modify.
+        .macos => 13,
+        else => 12,
+    },
 
     /// Background color for the window.
-    background: Color = .{ .r = 0, .g = 0, .b = 0 },
+    background: Color = .{ .r = 0x28, .g = 0x2C, .b = 0x34 },
 
     /// Foreground color for the window.
-    foreground: Color = .{ .r = 0xFF, .g = 0xA5, .b = 0 },
+    foreground: Color = .{ .r = 0xFF, .g = 0xFF, .b = 0xFF },
 
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH. If this is not set, a default will

commit ecbd119654e7846fb9931ad3445c9625a0f3414e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 10:34:43 2022 -0800

    Hook up new window, modify renderers

diff --git a/src/config.zig b/src/config.zig
index 9cd4ebdc..4874f99e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -157,6 +157,12 @@ pub const Config = struct {
             .{ .toggle_dev_mode = {} },
         );
 
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .up, .mods = .{ .super = true } },
+            .{ .new_window = {} },
+        );
+
         return result;
     }
 

commit be76bc6c1a9bad8a7ccd7972adbcc6c07a35db1f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 10:44:23 2022 -0800

    close window action

diff --git a/src/config.zig b/src/config.zig
index 4874f99e..179a5b95 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -159,9 +159,14 @@ pub const Config = struct {
 
         try result.keybind.set.put(
             alloc,
-            .{ .key = .up, .mods = .{ .super = true } },
+            .{ .key = .n, .mods = .{ .super = true } },
             .{ .new_window = {} },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .w, .mods = .{ .super = true } },
+            .{ .close_window = {} },
+        );
 
         return result;
     }

commit c9b01fdc6c0a3daf5db6eb44434ba4756446928b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 14:10:28 2022 -0800

    support app quitting to close all windows

diff --git a/src/config.zig b/src/config.zig
index 179a5b95..9249254d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -168,6 +168,14 @@ pub const Config = struct {
             .{ .close_window = {} },
         );
 
+        if (builtin.os.tag == .macos) {
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .q, .mods = .{ .super = true } },
+                .{ .close_window = {} },
+            );
+        }
+
         return result;
     }
 

commit c602820dc9098e94be1c42771349d18198ff7763
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 6 17:27:17 2022 -0800

    Set proper keybinds

diff --git a/src/config.zig b/src/config.zig
index 9249254d..341b41bb 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -157,6 +157,7 @@ pub const Config = struct {
             .{ .toggle_dev_mode = {} },
         );
 
+        // Windowing
         try result.keybind.set.put(
             alloc,
             .{ .key = .n, .mods = .{ .super = true } },
@@ -167,12 +168,11 @@ pub const Config = struct {
             .{ .key = .w, .mods = .{ .super = true } },
             .{ .close_window = {} },
         );
-
         if (builtin.os.tag == .macos) {
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .q, .mods = .{ .super = true } },
-                .{ .close_window = {} },
+                .{ .quit = {} },
             );
         }
 

commit c515cb9b5f440db47527cedb0b2e92a3b1da8552
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 14 16:19:20 2022 -0800

    initial padding options

diff --git a/src/config.zig b/src/config.zig
index 341b41bb..796894d3 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -89,6 +89,27 @@ pub const Config = struct {
     ///
     keybind: Keybinds = .{},
 
+    /// Window padding. This applies padding between the terminal cells and
+    /// the window border. The "x" option applies to the left and right
+    /// padding and the "y" option is top and bottom. The value is in points,
+    /// meaning that it will be scaled appropriately for screen DPI.
+    @"window-padding-x": u32 = 0,
+    @"window-padding-y": u32 = 0,
+
+    /// The viewport dimensions are usually not perfectly divisible by
+    /// the cell size. In this case, some extra padding on the end of a
+    /// column and the bottom of the final row may exist. If this is true,
+    /// then this extra padding is automatically balanced between all four
+    /// edges to minimize imbalance on one side. If this is false, the top
+    /// left grid cell will always hug the edge with zero padding other than
+    /// what may be specified with the other "window-padding" options.
+    ///
+    /// If other "window-padding" fields are set and this is true, this will
+    /// still apply. The other padding is applied first and may affect how
+    /// many grid cells actually exist, and this is applied last in order
+    /// to balance the padding given a certain viewport size and grid cell size.
+    @"window-padding-balance": bool = true,
+
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 

commit 334743e8a7182fd7f233cbcf7c4a057700d7c7fe
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 14 17:41:15 2022 -0800

    Don't crash on huge padding, warn users if padding is absurd

diff --git a/src/config.zig b/src/config.zig
index 796894d3..d7a60753 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -93,6 +93,11 @@ pub const Config = struct {
     /// the window border. The "x" option applies to the left and right
     /// padding and the "y" option is top and bottom. The value is in points,
     /// meaning that it will be scaled appropriately for screen DPI.
+    ///
+    /// If this value is set too large, the screen will render nothing, because
+    /// the grid will be completely squished by the padding. It is up to you
+    /// as the user to pick a reasonable value. If you pick an unreasonable
+    /// value, a warning will appear in the logs.
     @"window-padding-x": u32 = 0,
     @"window-padding-y": u32 = 0,
 

commit dad49239015c3793e409e637016af01774eaa4a9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 15 20:10:50 2022 -0800

    hook up all the keyboard actions

diff --git a/src/config.zig b/src/config.zig
index d7a60753..2d94fc42 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -176,6 +176,23 @@ pub const Config = struct {
         try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
         try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
 
+        // Fonts
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .equal, .mods = .{ .super = true } },
+            .{ .increase_font_size = 1 },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .minus, .mods = .{ .super = true } },
+            .{ .decrease_font_size = 1 },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .zero, .mods = .{ .super = true } },
+            .{ .reset_font_size = {} },
+        );
+
         // Dev Mode
         try result.keybind.set.put(
             alloc,

commit 8eb97cd9adf67b2d5d610de7163393d2a4199d6c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 09:51:59 2022 -0800

    Option (def true) to inherit font size on new window

diff --git a/src/config.zig b/src/config.zig
index 2d94fc42..74b5e93d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -115,6 +115,12 @@ pub const Config = struct {
     /// to balance the padding given a certain viewport size and grid cell size.
     @"window-padding-balance": bool = true,
 
+    /// If true, new windows will inherit the font size of the previously
+    /// focused window. If no window was previously focused, the default
+    /// font size will be used. If this is false, the default font size
+    /// specified in the configuration "font-size" will be used.
+    @"window-inherit-font-size": bool = true,
+
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 

commit 8ac90d33e6de115e6cdb6ef708ce792f3dce2279
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 21:17:41 2022 -0800

    new_tab action

diff --git a/src/config.zig b/src/config.zig
index 74b5e93d..bac96785 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -217,7 +217,12 @@ pub const Config = struct {
             .{ .key = .w, .mods = .{ .super = true } },
             .{ .close_window = {} },
         );
-        if (builtin.os.tag == .macos) {
+        if (comptime builtin.target.isDarwin()) {
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .t, .mods = .{ .super = true } },
+                .{ .new_tab = {} },
+            );
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .q, .mods = .{ .super = true } },

commit b4d59012253d1de2a9511be71cc966007071112e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 16 21:18:37 2022 -0800

    update some docs

diff --git a/src/config.zig b/src/config.zig
index bac96785..74926d65 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -115,7 +115,7 @@ pub const Config = struct {
     /// to balance the padding given a certain viewport size and grid cell size.
     @"window-padding-balance": bool = true,
 
-    /// If true, new windows will inherit the font size of the previously
+    /// If true, new windows and tabs will inherit the font size of the previously
     /// focused window. If no window was previously focused, the default
     /// font size will be used. If this is false, the default font size
     /// specified in the configuration "font-size" will be used.

commit 01573819ea8bd55218b81a38221dcc5501550514
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 20 15:25:51 2022 -0800

    Configurable 256 Color Palette (#50)
    
    The 256 color palette can now be configured with the `palette=N=HEX` format in the config. Example, Dracula:
    
    ```
    foreground=#f8f8f2
    background=#282a36
    palette=0=#21222c
    palette=8=#6272a4
    palette=1=#ff5555
    palette=9=#ff6e6e
    palette=2=#50fa7b
    palette=10=#69ff94
    palette=3=#f1fa8c
    palette=11=#ffffa5
    palette=4=#bd93f9
    palette=12=#d6acff
    palette=5=#ff79c6
    palette=13=#ff92df
    palette=6=#8be9fd
    palette=14=#a4ffff
    palette=7=#f8f8f2
    palette=15=#ffffff
    ```

diff --git a/src/config.zig b/src/config.zig
index 74926d65..8a4d64fa 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -4,6 +4,7 @@ const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const inputpkg = @import("input.zig");
 const passwd = @import("passwd.zig");
+const terminal = @import("terminal/main.zig");
 
 const log = std.log.scoped(.config);
 
@@ -35,6 +36,16 @@ pub const Config = struct {
     /// Foreground color for the window.
     foreground: Color = .{ .r = 0xFF, .g = 0xFF, .b = 0xFF },
 
+    /// Color palette for the 256 color form that many terminal applications
+    /// use. The syntax of this configuration is "N=HEXCODE" where "n"
+    /// is 0 to 255 (for the 256 colors) and HEXCODE is a typical RGB
+    /// color code such as "#AABBCC". The 0 to 255 correspond to the
+    /// terminal color table.
+    ///
+    /// For definitions on all the codes:
+    /// https://www.ditig.com/256-colors-cheat-sheet
+    palette: Palette = .{},
+
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH. If this is not set, a default will
     /// be looked up from your system. The rules for the default lookup are:
@@ -347,6 +358,49 @@ pub const Color = struct {
     }
 };
 
+/// Palette is the 256 color palette for 256-color mode. This is still
+/// used by many terminal applications.
+pub const Palette = struct {
+    const Self = @This();
+
+    /// The actual value that is updated as we parse.
+    value: terminal.color.Palette = terminal.color.default,
+
+    pub const Error = error{
+        InvalidFormat,
+    };
+
+    pub fn parseCLI(
+        self: *Self,
+        input: ?[]const u8,
+    ) !void {
+        const value = input orelse return error.ValueRequired;
+        const eqlIdx = std.mem.indexOf(u8, value, "=") orelse
+            return Error.InvalidFormat;
+
+        const key = try std.fmt.parseInt(u8, value[0..eqlIdx], 10);
+        const rgb = try Color.parseCLI(value[eqlIdx + 1 ..]);
+        self.value[key] = .{ .r = rgb.r, .g = rgb.g, .b = rgb.b };
+    }
+
+    test "parseCLI" {
+        const testing = std.testing;
+
+        var p: Self = .{};
+        try p.parseCLI("0=#AABBCC");
+        try testing.expect(p.value[0].r == 0xAA);
+        try testing.expect(p.value[0].g == 0xBB);
+        try testing.expect(p.value[0].b == 0xCC);
+    }
+
+    test "parseCLI overflow" {
+        const testing = std.testing;
+
+        var p: Self = .{};
+        try testing.expectError(error.Overflow, p.parseCLI("256=#AABBCC"));
+    }
+};
+
 /// RepeatableString is a string value that can be repeated to accumulate
 /// a list of strings. This isn't called "StringList" because I find that
 /// sometimes leads to confusion that it _accepts_ a list such as

commit 2e74b7af9eff20fd9615cd78fb85d7073bf32f8b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 20 20:27:12 2022 -0800

    ability to set selection fg/bg colors

diff --git a/src/config.zig b/src/config.zig
index 8a4d64fa..6bb9ddff 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -36,6 +36,12 @@ pub const Config = struct {
     /// Foreground color for the window.
     foreground: Color = .{ .r = 0xFF, .g = 0xFF, .b = 0xFF },
 
+    /// The foreground and background color for selection. If this is not
+    /// set, then the selection color is just the inverted window background
+    /// and foreground (note: not to be confused with the cell bg/fg).
+    @"selection-foreground": ?Color = null,
+    @"selection-background": ?Color = null,
+
     /// Color palette for the 256 color form that many terminal applications
     /// use. The syntax of this configuration is "N=HEXCODE" where "n"
     /// is 0 to 255 (for the 256 colors) and HEXCODE is a typical RGB
@@ -316,6 +322,11 @@ pub const Color = struct {
         InvalidFormat,
     };
 
+    /// Convert this to the terminal RGB struct
+    pub fn toTerminalRGB(self: Color) terminal.color.RGB {
+        return .{ .r = self.r, .g = self.g, .b = self.b };
+    }
+
     pub fn parseCLI(input: ?[]const u8) !Color {
         return fromHex(input orelse return error.ValueRequired);
     }

commit 611760f98b287dfcd155637fa0996f048d038d3f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 20 20:35:20 2022 -0800

    ability to customize cursor color

diff --git a/src/config.zig b/src/config.zig
index 6bb9ddff..a6526ec4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -52,6 +52,9 @@ pub const Config = struct {
     /// https://www.ditig.com/256-colors-cheat-sheet
     palette: Palette = .{},
 
+    /// The color of the cursor. If this is not set, a default will be chosen.
+    @"cursor-color": ?Color = null,
+
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH. If this is not set, a default will
     /// be looked up from your system. The rules for the default lookup are:

commit 56de5846f45b08e2d8ff67e62d96fd88ea629bd9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 21 15:12:00 2022 -0800

    OSC 52: Clipboard Control (#52)
    
    This adds support for OSC 52 -- applications can read/write the clipboard. Due to the security risk of this, the default configuration allows for writing but _not reading_. This is configurable using two new settings: `clipboard-read` and `clipboard-write` (both booleans).

diff --git a/src/config.zig b/src/config.zig
index a6526ec4..6b40a0d8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -141,6 +141,12 @@ pub const Config = struct {
     /// specified in the configuration "font-size" will be used.
     @"window-inherit-font-size": bool = true,
 
+    /// Whether to allow programs running in the terminal to read/write to
+    /// the system clipboard (OSC 52, for googling). The default is to
+    /// disallow clipboard reading but allow writing.
+    @"clipboard-read": bool = false,
+    @"clipboard-write": bool = true,
+
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 

commit 29b651ee462082c35559818e655c5fc337a58383
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 22 10:57:57 2022 -0800

    configurable click interval with `click-repeat-interval`

diff --git a/src/config.zig b/src/config.zig
index 6b40a0d8..633d328e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -147,6 +147,12 @@ pub const Config = struct {
     @"clipboard-read": bool = false,
     @"clipboard-write": bool = true,
 
+    /// The time in milliseconds between clicks to consider a click a repeat
+    /// (double, triple, etc.) or an entirely new single click. A value of
+    /// zero will use a platform-specific default. The default on macOS
+    /// is determined by the OS settings. On every other platform it is 500ms.
+    @"click-repeat-interval": u32 = 0,
+
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 
@@ -318,6 +324,11 @@ pub const Config = struct {
         // If we have the special value "inherit" then set it to null which
         // does the same. In the future we should change to a tagged union.
         if (std.mem.eql(u8, wd, "inherit")) self.@"working-directory" = null;
+
+        // Default our click interval
+        if (self.@"click-repeat-interval" == 0) {
+            self.@"click-repeat-interval" = 500;
+        }
     }
 };
 

commit 66078493e6f893b8fc0a8da5adaec313bd532163
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 22 11:07:25 2022 -0800

    mac: get default click repeat interval from NSEvent

diff --git a/src/config.zig b/src/config.zig
index 633d328e..0029878a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -5,6 +5,7 @@ const ArenaAllocator = std.heap.ArenaAllocator;
 const inputpkg = @import("input.zig");
 const passwd = @import("passwd.zig");
 const terminal = @import("terminal/main.zig");
+const internal_os = @import("os/main.zig");
 
 const log = std.log.scoped(.config);
 
@@ -327,7 +328,7 @@ pub const Config = struct {
 
         // Default our click interval
         if (self.@"click-repeat-interval" == 0) {
-            self.@"click-repeat-interval" = 500;
+            self.@"click-repeat-interval" = internal_os.clickInterval() orelse 500;
         }
     }
 };

commit 70b017200a55167c818c245fb65cd1a1fd7432c0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 22 21:27:05 2022 -0800

    copying selection trims trailing whitespace
    
    This is configurable with `clipboard-trim-trailing-spaces`.
    
    This also fixes a bug where debug builds would crash when copying blank
    lines. This never affected release builds.

diff --git a/src/config.zig b/src/config.zig
index 0029878a..1b06ace8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -148,6 +148,10 @@ pub const Config = struct {
     @"clipboard-read": bool = false,
     @"clipboard-write": bool = true,
 
+    /// Trims trailing whitespace on data that is copied to the clipboard.
+    /// This does not affect data sent to the clipboard via "clipboard-write".
+    @"clipboard-trim-trailing-spaces": bool = true,
+
     /// The time in milliseconds between clicks to consider a click a repeat
     /// (double, triple, etc.) or an entirely new single click. A value of
     /// zero will use a platform-specific default. The default on macOS

commit b8832833cb056572509f6fcba333e028dafe33f2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 27 20:57:58 2022 -0800

    respect application cursor keys for arrow (DECCKM)
    
    This fixes the arrow keys in htop.

diff --git a/src/config.zig b/src/config.zig
index 1b06ace8..fd92e2de 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -190,12 +190,31 @@ pub const Config = struct {
             .{ .paste_from_clipboard = {} },
         );
 
-        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .csi = "A" });
-        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .csi = "B" });
-        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .csi = "C" });
-        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .csi = "D" });
-        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .csi = "H" });
-        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .csi = "F" });
+        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
+            .normal = "\x1b[A",
+            .application = "\x1bOA",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .cursor_key = .{
+            .normal = "\x1b[B",
+            .application = "\x1bOB",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .cursor_key = .{
+            .normal = "\x1b[C",
+            .application = "\x1bOC",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .cursor_key = .{
+            .normal = "\x1b[D",
+            .application = "\x1bOD",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .cursor_key = .{
+            .normal = "\x1b[H",
+            .application = "\x1bOH",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .cursor_key = .{
+            .normal = "\x1b[F",
+            .application = "\x1bOF",
+        } });
+
         try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
         try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
 

commit 7c291a2c4c28b4dca63e0e4397fb5435983e1ab4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 16:19:54 2022 -0800

    config: API for wasm

diff --git a/src/config.zig b/src/config.zig
index fd92e2de..58a90082 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -527,6 +527,59 @@ pub const Keybinds = struct {
     }
 };
 
+// Wasm API.
+pub const Wasm = struct {
+    const wasm = @import("os/wasm.zig");
+    const alloc = wasm.alloc;
+    const cli_args = @import("cli_args.zig");
+
+    /// Create a new configuration filled with the initial default values.
+    export fn config_new() ?*Config {
+        const result = alloc.create(Config) catch |err| {
+            log.err("error allocating config err={}", .{err});
+            return null;
+        };
+
+        result.* = Config.default(alloc) catch |err| {
+            log.err("error creating config err={}", .{err});
+            return null;
+        };
+
+        return result;
+    }
+
+    export fn config_free(ptr: ?*Config) void {
+        if (ptr) |v| {
+            v.deinit();
+            alloc.destroy(v);
+        }
+    }
+
+    /// Load the configuration from a string in the same format as
+    /// the file-based syntax for the desktop version of the terminal.
+    export fn config_load_string(
+        self: *Config,
+        str: [*]const u8,
+        len: usize,
+    ) void {
+        config_load_string_(self, str[0..len]) catch |err| {
+            log.err("error loading config err={}", .{err});
+        };
+    }
+
+    fn config_load_string_(self: *Config, str: []const u8) !void {
+        var fbs = std.io.fixedBufferStream(str);
+        var iter = cli_args.lineIterator(fbs.reader());
+        try cli_args.parse(Config, alloc, self, &iter);
+    }
+
+    export fn config_finalize(self: *Config) void {
+        self.finalize() catch |err| {
+            log.err("error finalizing config err={}", .{err});
+        };
+    }
+};
+
 test {
     std.testing.refAllDecls(@This());
 }

commit 1093cf5254376256f179b80190578eed094f7237
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 16:32:49 2022 -0800

    config: enable passwd isn't compiled for wasm

diff --git a/src/config.zig b/src/config.zig
index 58a90082..0e9ee894 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -314,33 +314,36 @@ pub const Config = struct {
         };
 
         // If we are missing either a command or home directory, we need
-        // to look up defaults which is kind of expensive.
+        // to look up defaults which is kind of expensive. We only do this
+        // on desktop.
         const wd_home = std.mem.eql(u8, "home", wd);
-        if (self.command == null or wd_home) command: {
-            const alloc = self._arena.?.allocator();
-
-            // First look up the command using the SHELL env var.
-            if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
-                log.debug("default shell source=env value={s}", .{value});
-                self.command = value;
-
-                // If we don't need the working directory, then we can exit now.
-                if (!wd_home) break :command;
-            } else |_| {}
-
-            // We need the passwd entry for the remainder
-            const pw = try passwd.get(alloc);
-            if (self.command == null) {
-                if (pw.shell) |sh| {
-                    log.debug("default shell src=passwd value={s}", .{sh});
-                    self.command = sh;
+        if (comptime !builtin.target.isWasm()) {
+            if (self.command == null or wd_home) command: {
+                const alloc = self._arena.?.allocator();
+
+                // First look up the command using the SHELL env var.
+                if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
+                    log.debug("default shell source=env value={s}", .{value});
+                    self.command = value;
+
+                    // If we don't need the working directory, then we can exit now.
+                    if (!wd_home) break :command;
+                } else |_| {}
+
+                // We need the passwd entry for the remainder
+                const pw = try passwd.get(alloc);
+                if (self.command == null) {
+                    if (pw.shell) |sh| {
+                        log.debug("default shell src=passwd value={s}", .{sh});
+                        self.command = sh;
+                    }
                 }
-            }
 
-            if (wd_home) {
-                if (pw.home) |home| {
-                    log.debug("default working directory src=passwd value={s}", .{home});
-                    self.@"working-directory" = home;
+                if (wd_home) {
+                    if (pw.home) |home| {
+                        log.debug("default working directory src=passwd value={s}", .{home});
+                        self.@"working-directory" = home;
+                    }
                 }
             }
         }
@@ -528,7 +531,7 @@ pub const Keybinds = struct {
 };
 
 // Wasm API.
-pub const Wasm = struct {
+pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");
     const alloc = wasm.alloc;
     const cli_args = @import("cli_args.zig");

commit 9bd527fe00a89aa34f396e82609e8913c2410e31
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 14 15:53:28 2023 -0800

    macos: config API

diff --git a/src/config.zig b/src/config.zig
index 0e9ee894..ece999da 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -583,6 +583,59 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     }
 };
 
+// Wasm API.
+pub const CAPI = struct {
+    const Ghostty = @import("main_c.zig").Ghostty;
+    const cli_args = @import("cli_args.zig");
+
+    /// Create a new configuration filled with the initial default values.
+    export fn ghostty_config_new(g: *Ghostty) ?*Config {
+        const result = g.alloc.create(Config) catch |err| {
+            log.err("error allocating config err={}", .{err});
+            return null;
+        };
+
+        result.* = Config.default(g.alloc) catch |err| {
+            log.err("error creating config err={}", .{err});
+            return null;
+        };
+
+        return result;
+    }
+
+    export fn ghostty_config_free(g: *Ghostty, ptr: ?*Config) void {
+        if (ptr) |v| {
+            v.deinit();
+            g.alloc.destroy(v);
+        }
+    }
+
+    /// Load the configuration from a string in the same format as
+    /// the file-based syntax for the desktop version of the terminal.
+    export fn ghostty_config_load_string(
+        g: *Ghostty,
+        self: *Config,
+        str: [*]const u8,
+        len: usize,
+    ) void {
+        config_load_string_(g, self, str[0..len]) catch |err| {
+            log.err("error loading config err={}", .{err});
+        };
+    }
+
+    fn config_load_string_(g: *Ghostty, self: *Config, str: []const u8) !void {
+        var fbs = std.io.fixedBufferStream(str);
+        var iter = cli_args.lineIterator(fbs.reader());
+        try cli_args.parse(Config, g.alloc, self, &iter);
+    }
+
+    export fn ghostty_config_finalize(self: *Config) void {
+        self.finalize() catch |err| {
+            log.err("error finalizing config err={}", .{err});
+        };
+    }
+};
+
 test {
     std.testing.refAllDecls(@This());
 }

commit 26182611c616f6c5dd9f8bfb080c5b0c7a8c6729
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 15 15:38:51 2023 -0800

    move allocator to global state

diff --git a/src/config.zig b/src/config.zig
index ece999da..36095942 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -583,19 +583,19 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     }
 };
 
-// Wasm API.
+// C API.
 pub const CAPI = struct {
-    const Ghostty = @import("main_c.zig").Ghostty;
+    const global = &@import("main.zig").state;
     const cli_args = @import("cli_args.zig");
 
     /// Create a new configuration filled with the initial default values.
-    export fn ghostty_config_new(g: *Ghostty) ?*Config {
-        const result = g.alloc.create(Config) catch |err| {
+    export fn ghostty_config_new() ?*Config {
+        const result = global.alloc.create(Config) catch |err| {
             log.err("error allocating config err={}", .{err});
             return null;
         };
 
-        result.* = Config.default(g.alloc) catch |err| {
+        result.* = Config.default(global.alloc) catch |err| {
             log.err("error creating config err={}", .{err});
             return null;
         };
@@ -603,30 +603,29 @@ pub const CAPI = struct {
         return result;
     }
 
-    export fn ghostty_config_free(g: *Ghostty, ptr: ?*Config) void {
+    export fn ghostty_config_free(ptr: ?*Config) void {
         if (ptr) |v| {
             v.deinit();
-            g.alloc.destroy(v);
+            global.alloc.destroy(v);
         }
     }
 
     /// Load the configuration from a string in the same format as
     /// the file-based syntax for the desktop version of the terminal.
     export fn ghostty_config_load_string(
-        g: *Ghostty,
         self: *Config,
         str: [*]const u8,
         len: usize,
     ) void {
-        config_load_string_(g, self, str[0..len]) catch |err| {
+        config_load_string_(self, str[0..len]) catch |err| {
             log.err("error loading config err={}", .{err});
         };
     }
 
-    fn config_load_string_(g: *Ghostty, self: *Config, str: []const u8) !void {
+    fn config_load_string_(self: *Config, str: []const u8) !void {
         var fbs = std.io.fixedBufferStream(str);
         var iter = cli_args.lineIterator(fbs.reader());
-        try cli_args.parse(Config, g.alloc, self, &iter);
+        try cli_args.parse(Config, global.alloc, self, &iter);
     }
 
     export fn ghostty_config_finalize(self: *Config) void {

commit ac1c961c4e0ff7313f45135bfca28da12ab0c4af
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 24 15:54:36 2023 -0800

    gtk: close tab button

diff --git a/src/config.zig b/src/config.zig
index 36095942..c83198ab 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -273,12 +273,12 @@ pub const Config = struct {
             .{ .key = .w, .mods = .{ .super = true } },
             .{ .close_window = {} },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .t, .mods = .{ .super = true } },
+            .{ .new_tab = {} },
+        );
         if (comptime builtin.target.isDarwin()) {
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .t, .mods = .{ .super = true } },
-                .{ .new_tab = {} },
-            );
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .q, .mods = .{ .super = true } },

commit aa2d3720b63cd010bd5d5d7fa252d77e47b13c5a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 25 10:29:58 2023 -0800

    gtk: previous/next tab bindings

diff --git a/src/config.zig b/src/config.zig
index c83198ab..280a71d7 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -278,6 +278,16 @@ pub const Config = struct {
             .{ .key = .t, .mods = .{ .super = true } },
             .{ .new_tab = {} },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
+            .{ .previous_tab = {} },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
+            .{ .next_tab = {} },
+        );
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,

commit 6c6a3d6a5d360427a8c837f0392f1b552a688faf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 25 10:48:38 2023 -0800

    "goto_tab" key binding to jump to a specific tab, defaults to Super+N
    
    The apprt surface must implement `gotoTab` to make this work. This is
    only implemented in GTK for now.

diff --git a/src/config.zig b/src/config.zig
index 280a71d7..324bc713 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -288,6 +288,19 @@ pub const Config = struct {
             .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
             .{ .next_tab = {} },
         );
+        {
+            // Cmd+N for goto tab N
+            const start = @enumToInt(inputpkg.Key.one);
+            const end = @enumToInt(inputpkg.Key.nine);
+            var i: usize = start;
+            while (i <= end) : (i += 1) {
+                try result.keybind.set.put(
+                    alloc,
+                    .{ .key = @intToEnum(inputpkg.Key, i), .mods = .{ .super = true } },
+                    .{ .goto_tab = (i - start) + 1 },
+                );
+            }
+        }
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,

commit 6b23dbb1696f2b124766487ea38ccfaaae6e2f17
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 25 21:56:51 2023 -0800

    flatpak: use host-spawn to find default shell

diff --git a/src/config.zig b/src/config.zig
index 324bc713..b0e13e1e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -344,14 +344,18 @@ pub const Config = struct {
             if (self.command == null or wd_home) command: {
                 const alloc = self._arena.?.allocator();
 
-                // First look up the command using the SHELL env var.
-                if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
-                    log.debug("default shell source=env value={s}", .{value});
-                    self.command = value;
-
-                    // If we don't need the working directory, then we can exit now.
-                    if (!wd_home) break :command;
-                } else |_| {}
+                // We don't do this in flatpak because SHELL in Flatpak is
+                // always set to /bin/sh
+                if (!internal_os.isFlatpak()) {
+                    // First look up the command using the SHELL env var.
+                    if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
+                        log.debug("default shell source=env value={s}", .{value});
+                        self.command = value;
+
+                        // If we don't need the working directory, then we can exit now.
+                        if (!wd_home) break :command;
+                    } else |_| {}
+                }
 
                 // We need the passwd entry for the remainder
                 const pw = try passwd.get(alloc);

commit e28d20a05d543f152ce714213b9072525c0ad795
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 2 12:55:46 2023 -0800

    disable the auto balance config by default, add some padding
    
    This makes resizing too jittery which I think is a worse out of the box
    experience than the padding.

diff --git a/src/config.zig b/src/config.zig
index b0e13e1e..36761bd8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -119,8 +119,8 @@ pub const Config = struct {
     /// the grid will be completely squished by the padding. It is up to you
     /// as the user to pick a reasonable value. If you pick an unreasonable
     /// value, a warning will appear in the logs.
-    @"window-padding-x": u32 = 0,
-    @"window-padding-y": u32 = 0,
+    @"window-padding-x": u32 = 2,
+    @"window-padding-y": u32 = 2,
 
     /// The viewport dimensions are usually not perfectly divisible by
     /// the cell size. In this case, some extra padding on the end of a
@@ -134,7 +134,7 @@ pub const Config = struct {
     /// still apply. The other padding is applied first and may affect how
     /// many grid cells actually exist, and this is applied last in order
     /// to balance the padding given a certain viewport size and grid cell size.
-    @"window-padding-balance": bool = true,
+    @"window-padding-balance": bool = false,
 
     /// If true, new windows and tabs will inherit the font size of the previously
     /// focused window. If no window was previously focused, the default

commit d8537732dde396441db54aa72f858852a7bf0544
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 3 08:57:21 2023 -0800

    config: add functions to load from home and load configured

diff --git a/src/config.zig b/src/config.zig
index 36761bd8..6a9ab1a8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,6 +6,8 @@ const inputpkg = @import("input.zig");
 const passwd = @import("passwd.zig");
 const terminal = @import("terminal/main.zig");
 const internal_os = @import("os/main.zig");
+const xdg = @import("xdg.zig");
+const cli_args = @import("cli_args.zig");
 
 const log = std.log.scoped(.config);
 
@@ -312,6 +314,59 @@ pub const Config = struct {
         return result;
     }
 
+    /// Load the configuration from the default file locations. Currently,
+    /// this loads from $XDG_CONFIG_HOME/ghostty/config.
+    pub fn loadDefaultFiles(self: *Config, alloc: Allocator) !void {
+        const home_config_path = try xdg.config(alloc, .{ .subdir = "ghostty/config" });
+        defer alloc.free(home_config_path);
+
+        const cwd = std.fs.cwd();
+        if (cwd.openFile(home_config_path, .{})) |file| {
+            defer file.close();
+            std.log.info("reading configuration file path={s}", .{home_config_path});
+
+            var buf_reader = std.io.bufferedReader(file.reader());
+            var iter = cli_args.lineIterator(buf_reader.reader());
+            try cli_args.parse(Config, alloc, self, &iter);
+        } else |err| switch (err) {
+            error.FileNotFound => std.log.info(
+                "homedir config not found, not loading path={s}",
+                .{home_config_path},
+            ),
+
+            else => std.log.warn(
+                "error reading homedir config file, not loading err={} path={s}",
+                .{ err, home_config_path },
+            ),
+        }
+    }
+
+    /// Load and parse the config files that were added in the "config-file" key.
+    pub fn loadRecursive(self: *Config, alloc: Allocator) !void {
+        // TODO(mitchellh): we should parse the files form the homedir first
+        // TODO(mitchellh): support nesting (config-file in a config file)
+        // TODO(mitchellh): detect cycles when nesting
+
+        if (self.@"config-file".list.items.len == 0) return;
+
+        const cwd = std.fs.cwd();
+        const len = self.@"config-file".list.items.len;
+        for (self.@"config-file".list.items) |path| {
+            var file = try cwd.openFile(path, .{});
+            defer file.close();
+
+            var buf_reader = std.io.bufferedReader(file.reader());
+            var iter = cli_args.lineIterator(buf_reader.reader());
+            try cli_args.parse(Config, alloc, self, &iter);
+
+            // We don't currently support adding more config files to load
+            // from within a loaded config file. This can be supported
+            // later.
+            if (self.@"config-file".list.items.len > len)
+                return error.ConfigFileInConfigFile;
+        }
+    }
+
     pub fn finalize(self: *Config) !void {
         // If we have a font-family set and don't set the others, default
         // the others to the font family. This way, if someone does
@@ -561,7 +616,6 @@ pub const Keybinds = struct {
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");
     const alloc = wasm.alloc;
-    const cli_args = @import("cli_args.zig");
 
     /// Create a new configuration filled with the initial default values.
     export fn config_new() ?*Config {
@@ -613,7 +667,6 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
 // C API.
 pub const CAPI = struct {
     const global = &@import("main.zig").state;
-    const cli_args = @import("cli_args.zig");
 
     /// Create a new configuration filled with the initial default values.
     export fn ghostty_config_new() ?*Config {

commit 2a40bdabca96c7cc0a99b6c9c878da33d9fc7716
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 3 09:01:13 2023 -0800

    macos: load config file default file locations

diff --git a/src/config.zig b/src/config.zig
index 6a9ab1a8..97987020 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -342,7 +342,7 @@ pub const Config = struct {
     }
 
     /// Load and parse the config files that were added in the "config-file" key.
-    pub fn loadRecursive(self: *Config, alloc: Allocator) !void {
+    pub fn loadRecursiveFiles(self: *Config, alloc: Allocator) !void {
         // TODO(mitchellh): we should parse the files form the homedir first
         // TODO(mitchellh): support nesting (config-file in a config file)
         // TODO(mitchellh): detect cycles when nesting
@@ -708,6 +708,24 @@ pub const CAPI = struct {
         try cli_args.parse(Config, global.alloc, self, &iter);
     }
 
+    /// Load the configuration from the default file locations. This
+    /// is usually done first. The default file locations are locations
+    /// such as the home directory.
+    export fn ghostty_config_load_default_files(self: *Config) void {
+        self.loadDefaultFiles(global.alloc) catch |err| {
+            log.err("error loading config err={}", .{err});
+        };
+    }
+
+    /// Load the configuration from the user-specified configuration
+    /// file locations in the previously loaded configuration. This will
+    /// recursively continue to load up to a built-in limit.
+    export fn ghostty_config_load_recursive_files(self: *Config) void {
+        self.loadRecursiveFiles(global.alloc) catch |err| {
+            log.err("error loading config err={}", .{err});
+        };
+    }
+
     export fn ghostty_config_finalize(self: *Config) void {
         self.finalize() catch |err| {
             log.err("error finalizing config err={}", .{err});

commit 89d07fcd83379a0c5c93391e2402982110438bb1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 3 09:27:47 2023 -0800

    clear_history binding, default Cmd+K

diff --git a/src/config.zig b/src/config.zig
index 97987020..06adb691 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -192,6 +192,12 @@ pub const Config = struct {
             .{ .paste_from_clipboard = {} },
         );
 
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .k, .mods = .{ .super = true } },
+            .{ .clear_screen = {} },
+        );
+
         try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
             .normal = "\x1b[A",
             .application = "\x1bOA",

commit 8ce6f349f882c9ef86b674214f09a9be395af504
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 8 08:56:17 2023 -0800

    input: new_split binding, can parse enums

diff --git a/src/config.zig b/src/config.zig
index 06adb691..0e8762ba 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -296,6 +296,16 @@ pub const Config = struct {
             .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
             .{ .next_tab = {} },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .d, .mods = .{ .super = true } },
+            .{ .new_split = .right },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .d, .mods = .{ .super = true, .shift = true } },
+            .{ .new_split = .down },
+        );
         {
             // Cmd+N for goto tab N
             const start = @enumToInt(inputpkg.Key.one);

commit 6c857877e8f164b03cedceb0981689cb6863d9b4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 8 15:05:15 2023 -0800

    apprt/embedded: close surface callback

diff --git a/src/config.zig b/src/config.zig
index 0e8762ba..a9d74c27 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -278,8 +278,8 @@ pub const Config = struct {
         );
         try result.keybind.set.put(
             alloc,
-            .{ .key = .w, .mods = .{ .super = true } },
-            .{ .close_window = {} },
+            .{ .key = .w, .mods = .{ .super = true, .shift = true } },
+            .{ .close_surface = {} },
         );
         try result.keybind.set.put(
             alloc,

commit 0aadd192827a78ce5eb63bdeb6ed0180fb70b1b6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 10 14:44:33 2023 -0800

    macos: close surface works

diff --git a/src/config.zig b/src/config.zig
index a9d74c27..2b6b3766 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -278,9 +278,14 @@ pub const Config = struct {
         );
         try result.keybind.set.put(
             alloc,
-            .{ .key = .w, .mods = .{ .super = true, .shift = true } },
+            .{ .key = .w, .mods = .{ .super = true } },
             .{ .close_surface = {} },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .w, .mods = .{ .super = true, .shift = true } },
+            .{ .close_window = {} },
+        );
         try result.keybind.set.put(
             alloc,
             .{ .key = .t, .mods = .{ .super = true } },

commit b5826911851304193a639cc692993eda31ca8fbc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 11 16:22:04 2023 -0800

    macos: hook up all the bindings so we're ready to handle focus event

diff --git a/src/config.zig b/src/config.zig
index 2b6b3766..193bd69a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -311,6 +311,16 @@ pub const Config = struct {
             .{ .key = .d, .mods = .{ .super = true, .shift = true } },
             .{ .new_split = .down },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .left_bracket, .mods = .{ .super = true } },
+            .{ .previous_split = {} },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .right_bracket, .mods = .{ .super = true } },
+            .{ .next_split = {} },
+        );
         {
             // Cmd+N for goto tab N
             const start = @enumToInt(inputpkg.Key.one);

commit 04c38ef3b0e5f8ca8cc514bf9de6217b0266091a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 11 17:44:00 2023 -0800

    macos: change focus callback to use an enum so we can get other dirs

diff --git a/src/config.zig b/src/config.zig
index 193bd69a..3df202cd 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -314,12 +314,12 @@ pub const Config = struct {
         try result.keybind.set.put(
             alloc,
             .{ .key = .left_bracket, .mods = .{ .super = true } },
-            .{ .previous_split = {} },
+            .{ .goto_split = .previous },
         );
         try result.keybind.set.put(
             alloc,
             .{ .key = .right_bracket, .mods = .{ .super = true } },
-            .{ .next_split = {} },
+            .{ .goto_split = .next },
         );
         {
             // Cmd+N for goto tab N

commit 3976da8149544362a8210e5fdff5563c0dd39c72
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 11 17:55:31 2023 -0800

    macos: navigate splits directionally

diff --git a/src/config.zig b/src/config.zig
index 3df202cd..a3c88c1e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -321,6 +321,26 @@ pub const Config = struct {
             .{ .key = .right_bracket, .mods = .{ .super = true } },
             .{ .goto_split = .next },
         );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .up, .mods = .{ .super = true, .alt = true } },
+            .{ .goto_split = .top },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .down, .mods = .{ .super = true, .alt = true } },
+            .{ .goto_split = .bottom },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .left, .mods = .{ .super = true, .alt = true } },
+            .{ .goto_split = .left },
+        );
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .right, .mods = .{ .super = true, .alt = true } },
+            .{ .goto_split = .right },
+        );
         {
             // Cmd+N for goto tab N
             const start = @enumToInt(inputpkg.Key.one);

commit 0744e504e176c4ed5fdfe2ad08ae67785b85e4d6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 16 21:59:17 2023 -0700

    Use proper Linux default keybindings
    
    These are just different from macOS. I've looked at various Linux
    terminals and there seems to be some general consensus around this.

diff --git a/src/config.zig b/src/config.zig
index a3c88c1e..212d7ffb 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -182,22 +182,16 @@ pub const Config = struct {
         // Add our default keybindings
         try result.keybind.set.put(
             alloc,
-            .{ .key = .c, .mods = .{ .super = true } },
+            .{ .key = .c, .mods = ctrlOrSuper(.{}) },
             .{ .copy_to_clipboard = {} },
         );
-
         try result.keybind.set.put(
             alloc,
-            .{ .key = .v, .mods = .{ .super = true } },
+            .{ .key = .v, .mods = ctrlOrSuper(.{}) },
             .{ .paste_from_clipboard = {} },
         );
 
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .k, .mods = .{ .super = true } },
-            .{ .clear_screen = {} },
-        );
-
+        // Some control keys
         try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
             .normal = "\x1b[A",
             .application = "\x1bOA",
@@ -249,17 +243,17 @@ pub const Config = struct {
         // Fonts
         try result.keybind.set.put(
             alloc,
-            .{ .key = .equal, .mods = .{ .super = true } },
+            .{ .key = .equal, .mods = ctrlOrSuper(.{}) },
             .{ .increase_font_size = 1 },
         );
         try result.keybind.set.put(
             alloc,
-            .{ .key = .minus, .mods = .{ .super = true } },
+            .{ .key = .minus, .mods = ctrlOrSuper(.{}) },
             .{ .decrease_font_size = 1 },
         );
         try result.keybind.set.put(
             alloc,
-            .{ .key = .zero, .mods = .{ .super = true } },
+            .{ .key = .zero, .mods = ctrlOrSuper(.{}) },
             .{ .reset_font_size = {} },
         );
 
@@ -271,100 +265,204 @@ pub const Config = struct {
         );
 
         // Windowing
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .n, .mods = .{ .super = true } },
-            .{ .new_window = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .w, .mods = .{ .super = true } },
-            .{ .close_surface = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .w, .mods = .{ .super = true, .shift = true } },
-            .{ .close_window = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .t, .mods = .{ .super = true } },
-            .{ .new_tab = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
-            .{ .previous_tab = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
-            .{ .next_tab = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .d, .mods = .{ .super = true } },
-            .{ .new_split = .right },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .d, .mods = .{ .super = true, .shift = true } },
-            .{ .new_split = .down },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .left_bracket, .mods = .{ .super = true } },
-            .{ .goto_split = .previous },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .right_bracket, .mods = .{ .super = true } },
-            .{ .goto_split = .next },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .up, .mods = .{ .super = true, .alt = true } },
-            .{ .goto_split = .top },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .down, .mods = .{ .super = true, .alt = true } },
-            .{ .goto_split = .bottom },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .left, .mods = .{ .super = true, .alt = true } },
-            .{ .goto_split = .left },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .right, .mods = .{ .super = true, .alt = true } },
-            .{ .goto_split = .right },
-        );
+        if (comptime !builtin.target.isDarwin()) {
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .n, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .new_window = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .w, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .close_surface = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .f4, .mods = .{ .alt = true } },
+                .{ .close_window = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .t, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .new_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .previous_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .next_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .d, .mods = .{ .ctrl = true } },
+                .{ .new_split = .right },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .d, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .new_split = .down },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left_bracket, .mods = .{ .ctrl = true } },
+                .{ .goto_split = .previous },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right_bracket, .mods = .{ .ctrl = true } },
+                .{ .goto_split = .next },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .up, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .goto_split = .top },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .down, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .goto_split = .bottom },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .goto_split = .left },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .goto_split = .right },
+            );
+        }
         {
             // Cmd+N for goto tab N
             const start = @enumToInt(inputpkg.Key.one);
             const end = @enumToInt(inputpkg.Key.nine);
             var i: usize = start;
             while (i <= end) : (i += 1) {
+                // On macOS we default to super but everywhere else
+                // is alt.
+                const mods: inputpkg.Mods = if (builtin.target.isDarwin())
+                    .{ .super = true }
+                else
+                    .{ .alt = true };
+
                 try result.keybind.set.put(
                     alloc,
-                    .{ .key = @intToEnum(inputpkg.Key, i), .mods = .{ .super = true } },
+                    .{ .key = @intToEnum(inputpkg.Key, i), .mods = mods },
                     .{ .goto_tab = (i - start) + 1 },
                 );
             }
         }
+
+        // Mac-specific keyboard bindings.
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .q, .mods = .{ .super = true } },
                 .{ .quit = {} },
             );
+
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .k, .mods = .{ .super = true } },
+                .{ .clear_screen = {} },
+            );
+
+            // Mac windowing
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .n, .mods = .{ .super = true } },
+                .{ .new_window = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .w, .mods = .{ .super = true } },
+                .{ .close_surface = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .w, .mods = .{ .super = true, .shift = true } },
+                .{ .close_window = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .t, .mods = .{ .super = true } },
+                .{ .new_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
+                .{ .previous_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
+                .{ .next_tab = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .d, .mods = .{ .super = true } },
+                .{ .new_split = .right },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .d, .mods = .{ .super = true, .shift = true } },
+                .{ .new_split = .down },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left_bracket, .mods = .{ .super = true } },
+                .{ .goto_split = .previous },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right_bracket, .mods = .{ .super = true } },
+                .{ .goto_split = .next },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .up, .mods = .{ .super = true, .alt = true } },
+                .{ .goto_split = .top },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .down, .mods = .{ .super = true, .alt = true } },
+                .{ .goto_split = .bottom },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .left, .mods = .{ .super = true, .alt = true } },
+                .{ .goto_split = .left },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .right, .mods = .{ .super = true, .alt = true } },
+                .{ .goto_split = .right },
+            );
         }
 
         return result;
     }
 
+    /// This sets either "ctrl" or "super" to true (but not both)
+    /// on mods depending on if the build target is Mac or not. On
+    /// Mac, we default to super (i.e. super+c for copy) and on
+    /// non-Mac we default to ctrl (i.e. ctrl+c for copy).
+    fn ctrlOrSuper(mods: inputpkg.Mods) inputpkg.Mods {
+        var copy = mods;
+        if (comptime builtin.target.isDarwin()) {
+            copy.super = true;
+        } else {
+            copy.ctrl = true;
+        }
+
+        return copy;
+    }
+
     /// Load the configuration from the default file locations. Currently,
     /// this loads from $XDG_CONFIG_HOME/ghostty/config.
     pub fn loadDefaultFiles(self: *Config, alloc: Allocator) !void {

commit b0cb46dab9325a67a2342d5e4ca5df391dc3100c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 16 23:27:21 2023 -0700

    linux copy/paste defaults to ctrl+shift+c/v

diff --git a/src/config.zig b/src/config.zig
index 212d7ffb..7c3fed02 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -180,16 +180,25 @@ pub const Config = struct {
         const alloc = result._arena.?.allocator();
 
         // Add our default keybindings
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .c, .mods = ctrlOrSuper(.{}) },
-            .{ .copy_to_clipboard = {} },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .v, .mods = ctrlOrSuper(.{}) },
-            .{ .paste_from_clipboard = {} },
-        );
+        {
+            // On macOS we default to super but Linux ctrl+shift since
+            // ctrl+c is to kill the process.
+            const mods: inputpkg.Mods = if (builtin.target.isDarwin())
+                .{ .super = true }
+            else
+                .{ .ctrl = true, .shift = true };
+
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .c, .mods = mods },
+                .{ .copy_to_clipboard = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .v, .mods = mods },
+                .{ .paste_from_clipboard = {} },
+            );
+        }
 
         // Some control keys
         try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{

commit 8b9a1d8530b2dc1c68b20de25c68bae6a4c8a41b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Mar 17 14:27:49 2023 -0700

    linux: proper split shortcuts

diff --git a/src/config.zig b/src/config.zig
index 7c3fed02..711a6995 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -307,12 +307,12 @@ pub const Config = struct {
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .ctrl = true } },
+                .{ .key = .o, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_split = .right },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .e, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_split = .down },
             );
             try result.keybind.set.put(

commit f28b6774174345173c2ca0ecf4b02cbf23e4623e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 19 12:13:41 2023 -0700

    don't look up default shell from SHELL env if shell is set

diff --git a/src/config.zig b/src/config.zig
index 711a6995..8e71a576 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -557,34 +557,42 @@ pub const Config = struct {
             if (self.command == null or wd_home) command: {
                 const alloc = self._arena.?.allocator();
 
-                // We don't do this in flatpak because SHELL in Flatpak is
-                // always set to /bin/sh
-                if (!internal_os.isFlatpak()) {
-                    // First look up the command using the SHELL env var.
-                    if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
-                        log.debug("default shell source=env value={s}", .{value});
-                        self.command = value;
-
-                        // If we don't need the working directory, then we can exit now.
-                        if (!wd_home) break :command;
-                    } else |_| {}
+                // First look up the command using the SHELL env var if needed.
+                // We don't do this in flatpak because SHELL in Flatpak is always
+                // set to /bin/sh.
+                if (self.command) |cmd|
+                    log.info("shell src=config value={s}", .{cmd})
+                else {
+                    if (!internal_os.isFlatpak()) {
+                        if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
+                            log.info("default shell source=env value={s}", .{value});
+                            self.command = value;
+
+                            // If we don't need the working directory, then we can exit now.
+                            if (!wd_home) break :command;
+                        } else |_| {}
+                    }
                 }
 
                 // We need the passwd entry for the remainder
                 const pw = try passwd.get(alloc);
                 if (self.command == null) {
                     if (pw.shell) |sh| {
-                        log.debug("default shell src=passwd value={s}", .{sh});
+                        log.info("default shell src=passwd value={s}", .{sh});
                         self.command = sh;
                     }
                 }
 
                 if (wd_home) {
                     if (pw.home) |home| {
-                        log.debug("default working directory src=passwd value={s}", .{home});
+                        log.info("default working directory src=passwd value={s}", .{home});
                         self.@"working-directory" = home;
                     }
                 }
+
+                if (self.command == null) {
+                    log.warn("no default shell found, will default to using sh", .{});
+                }
             }
         }
 

commit 510f4b46997ea5f0b7e8e4f4382948fbdcf95afd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 14:19:18 2023 -0700

    config supports clone() operation for a deep copy

diff --git a/src/config.zig b/src/config.zig
index 711a6995..d10f8b58 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -597,6 +597,76 @@ pub const Config = struct {
             self.@"click-repeat-interval" = internal_os.clickInterval() orelse 500;
         }
     }
+
+    /// Create a copy of this configuration. This is useful as a starting
+    /// point for modifying a configuration since a config can NOT be
+    /// modified once it is in use by an app or surface.
+    pub fn clone(self: *const Config, alloc_gpa: Allocator) !Config {
+        // Start with an empty config with a new arena we're going
+        // to use for all our copies.
+        var result: Config = .{
+            ._arena = ArenaAllocator.init(alloc_gpa),
+        };
+        errdefer result.deinit();
+        const alloc = result._arena.?.allocator();
+
+        inline for (@typeInfo(Config).Struct.fields) |field| {
+            // Ignore fields starting with "_" since they're internal and
+            // not copied ever.
+            if (field.name[0] == '_') continue;
+
+            @field(result, field.name) = try cloneValue(
+                alloc,
+                field.type,
+                @field(self, field.name),
+            );
+        }
+
+        return result;
+    }
+
+    fn cloneValue(alloc: Allocator, comptime T: type, src: T) !T {
+        // Do known named types first
+        switch (T) {
+            []const u8 => return try alloc.dupe(u8, src),
+            [:0]const u8 => return try alloc.dupeZ(u8, src),
+
+            else => {},
+        }
+
+        // Back into types of types
+        switch (@typeInfo(T)) {
+            inline .Bool,
+            .Int,
+            => return src,
+
+            .Optional => |info| return try cloneValue(
+                alloc,
+                info.child,
+                src orelse return null,
+            ),
+
+            .Struct => return try src.clone(alloc),
+
+            else => {
+                @compileLog(T);
+                @compileError("unsupported field type");
+            },
+        }
+    }
+
+    test "clone default" {
+        const testing = std.testing;
+        const alloc = testing.allocator;
+
+        var source = try Config.default(alloc);
+        defer source.deinit();
+        var dest = try source.clone(alloc);
+        defer dest.deinit();
+
+        // I want to do this but this doesn't work (the API doesn't work)
+        // try testing.expectEqualDeep(dest, source);
+    }
 };
 
 /// Color represents a color using RGB.
@@ -618,6 +688,11 @@ pub const Color = struct {
         return fromHex(input orelse return error.ValueRequired);
     }
 
+    /// Deep copy of the struct. Required by Config.
+    pub fn clone(self: Color, _: Allocator) !Color {
+        return self;
+    }
+
     /// fromHex parses a color from a hex value such as #RRGGBB. The "#"
     /// is optional.
     pub fn fromHex(input: []const u8) !Color {
@@ -681,6 +756,11 @@ pub const Palette = struct {
         self.value[key] = .{ .r = rgb.r, .g = rgb.g, .b = rgb.b };
     }
 
+    /// Deep copy of the struct. Required by Config.
+    pub fn clone(self: Self, _: Allocator) !Self {
+        return self;
+    }
+
     test "parseCLI" {
         const testing = std.testing;
 
@@ -714,6 +794,13 @@ pub const RepeatableString = struct {
         try self.list.append(alloc, value);
     }
 
+    /// Deep copy of the struct. Required by Config.
+    pub fn clone(self: *const Self, alloc: Allocator) !Self {
+        return .{
+            .list = try self.list.clone(alloc),
+        };
+    }
+
     test "parseCLI" {
         const testing = std.testing;
         var arena = ArenaAllocator.init(testing.allocator);
@@ -758,6 +845,15 @@ pub const Keybinds = struct {
         }
     }
 
+    /// Deep copy of the struct. Required by Config.
+    pub fn clone(self: *const Keybinds, alloc: Allocator) !Keybinds {
+        return .{
+            .set = .{
+                .bindings = try self.set.bindings.clone(alloc),
+            },
+        };
+    }
+
     test "parseCLI" {
         const testing = std.testing;
         var arena = ArenaAllocator.init(testing.allocator);

commit 16166b629708d28f555191d39042c4e60930bdec
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 15:07:23 2023 -0700

    config: implement change iterator (one todo)

diff --git a/src/config.zig b/src/config.zig
index d10f8b58..31021217 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -166,6 +166,30 @@ pub const Config = struct {
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 
+    /// Key is an enum of all the available configuration keys. This is used
+    /// when paired with diff to determine what fields have changed in a config,
+    /// amongst other things.
+    pub const Key = key: {
+        const field_infos = std.meta.fields(Config);
+        var enumFields: [field_infos.len]std.builtin.Type.EnumField = undefined;
+        var decls = [_]std.builtin.Type.Declaration{};
+        inline for (field_infos, 0..) |field, i| {
+            enumFields[i] = .{
+                .name = field.name,
+                .value = i,
+            };
+        }
+
+        break :key @Type(.{
+            .Enum = .{
+                .tag_type = std.math.IntFittingRange(0, field_infos.len - 1),
+                .fields = &enumFields,
+                .decls = &decls,
+                .is_exhaustive = true,
+            },
+        });
+    };
+
     pub fn deinit(self: *Config) void {
         if (self._arena) |arena| arena.deinit();
         self.* = undefined;
@@ -655,6 +679,77 @@ pub const Config = struct {
         }
     }
 
+    /// Returns an iterator that goes through each changed field from
+    /// old to new.
+    pub fn changeIterator(old: *const Config, new: *const Config) ChangeIterator {
+        return .{
+            .old = old,
+            .new = new,
+        };
+    }
+
+    fn equal(comptime T: type, old: T, new: T) bool {
+        // Do known named types first
+        switch (T) {
+            inline []const u8,
+            [:0]const u8,
+            => return std.mem.eql(u8, old, new),
+
+            else => {},
+        }
+
+        // Back into types of types
+        switch (@typeInfo(T)) {
+            inline .Bool,
+            .Int,
+            => return old == new,
+
+            .Optional => |info| {
+                if (old == null and new == null) return true;
+                if (old == null or new == null) return false;
+                return equal(info.child, old.?, new.?);
+            },
+
+            .Struct => return old.equal(new),
+
+            else => {
+                @compileLog(T);
+                @compileError("unsupported field type");
+            },
+        }
+    }
+
+    pub const ChangeIterator = struct {
+        old: *const Config,
+        new: *const Config,
+        i: usize = 0,
+
+        pub fn next(self: *ChangeIterator) ?Key {
+            const fields = comptime std.meta.fields(Config);
+
+            while (self.i < fields.len) {
+                switch (self.i) {
+                    inline 0...(fields.len - 1) => |i| {
+                        const field = fields[i];
+                        self.i += 1;
+
+                        if (field.name[0] == '_') return self.next();
+
+                        const old_value = @field(self.old, field.name);
+                        const new_value = @field(self.new, field.name);
+                        if (!equal(field.type, old_value, new_value)) {
+                            return @field(Key, field.name);
+                        }
+                    },
+
+                    else => unreachable,
+                }
+            }
+
+            return null;
+        }
+    };
+
     test "clone default" {
         const testing = std.testing;
         const alloc = testing.allocator;
@@ -664,6 +759,10 @@ pub const Config = struct {
         var dest = try source.clone(alloc);
         defer dest.deinit();
 
+        // Should have no changes
+        var it = source.changeIterator(&dest);
+        try testing.expectEqual(@as(?Key, null), it.next());
+
         // I want to do this but this doesn't work (the API doesn't work)
         // try testing.expectEqualDeep(dest, source);
     }
@@ -693,6 +792,11 @@ pub const Color = struct {
         return self;
     }
 
+    /// Compare if two of our value are requal. Required by Config.
+    pub fn equal(self: Color, other: Color) bool {
+        return std.meta.eql(self, other);
+    }
+
     /// fromHex parses a color from a hex value such as #RRGGBB. The "#"
     /// is optional.
     pub fn fromHex(input: []const u8) !Color {
@@ -761,6 +865,11 @@ pub const Palette = struct {
         return self;
     }
 
+    /// Compare if two of our value are requal. Required by Config.
+    pub fn equal(self: Self, other: Self) bool {
+        return std.meta.eql(self, other);
+    }
+
     test "parseCLI" {
         const testing = std.testing;
 
@@ -801,6 +910,16 @@ pub const RepeatableString = struct {
         };
     }
 
+    /// Compare if two of our value are requal. Required by Config.
+    pub fn equal(self: Self, other: Self) bool {
+        const itemsA = self.list.items;
+        const itemsB = other.list.items;
+        if (itemsA.len != itemsB.len) return false;
+        for (itemsA, itemsB) |a, b| {
+            if (!std.mem.eql(u8, a, b)) return false;
+        } else return true;
+    }
+
     test "parseCLI" {
         const testing = std.testing;
         var arena = ArenaAllocator.init(testing.allocator);
@@ -854,6 +973,14 @@ pub const Keybinds = struct {
         };
     }
 
+    /// Compare if two of our value are requal. Required by Config.
+    pub fn equal(self: Keybinds, other: Keybinds) bool {
+        // TODO
+        _ = self;
+        _ = other;
+        return true;
+    }
+
     test "parseCLI" {
         const testing = std.testing;
         var arena = ArenaAllocator.init(testing.allocator);

commit 0d93da5f3055935345fb00fa8cf3c01d5e90052e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 21:34:06 2023 -0700

    config: changed() to test if a specific key has changed

diff --git a/src/config.zig b/src/config.zig
index 31021217..262a59a8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -172,18 +172,24 @@ pub const Config = struct {
     pub const Key = key: {
         const field_infos = std.meta.fields(Config);
         var enumFields: [field_infos.len]std.builtin.Type.EnumField = undefined;
-        var decls = [_]std.builtin.Type.Declaration{};
-        inline for (field_infos, 0..) |field, i| {
+        var i: usize = 0;
+        inline for (field_infos) |field| {
+            // Ignore fields starting with "_" since they're internal and
+            // not copied ever.
+            if (field.name[0] == '_') continue;
+
             enumFields[i] = .{
                 .name = field.name,
                 .value = i,
             };
+            i += 1;
         }
 
+        var decls = [_]std.builtin.Type.Declaration{};
         break :key @Type(.{
             .Enum = .{
                 .tag_type = std.math.IntFittingRange(0, field_infos.len - 1),
-                .fields = &enumFields,
+                .fields = enumFields[0..i],
                 .decls = &decls,
                 .is_exhaustive = true,
             },
@@ -635,10 +641,7 @@ pub const Config = struct {
         const alloc = result._arena.?.allocator();
 
         inline for (@typeInfo(Config).Struct.fields) |field| {
-            // Ignore fields starting with "_" since they're internal and
-            // not copied ever.
-            if (field.name[0] == '_') continue;
-
+            if (!@hasField(Key, field.name)) continue;
             @field(result, field.name) = try cloneValue(
                 alloc,
                 field.type,
@@ -680,7 +683,7 @@ pub const Config = struct {
     }
 
     /// Returns an iterator that goes through each changed field from
-    /// old to new.
+    /// old to new. The order of old or new do not matter.
     pub fn changeIterator(old: *const Config, new: *const Config) ChangeIterator {
         return .{
             .old = old,
@@ -688,6 +691,26 @@ pub const Config = struct {
         };
     }
 
+    /// Returns true if the given key has changed from old to new. This
+    /// requires the key to be comptime known to make this more efficient.
+    pub fn changed(self: *const Config, new: *const Config, comptime key: Key) bool {
+        // Get the field at comptime
+        const field = comptime field: {
+            const fields = std.meta.fields(Config);
+            for (fields) |field| {
+                if (@field(Key, field.name) == key) {
+                    break :field field;
+                }
+            }
+
+            unreachable;
+        };
+
+        const old_value = @field(self, field.name);
+        const new_value = @field(new, field.name);
+        return !equal(field.type, old_value, new_value);
+    }
+
     fn equal(comptime T: type, old: T, new: T) bool {
         // Do known named types first
         switch (T) {
@@ -719,27 +742,21 @@ pub const Config = struct {
         }
     }
 
+    /// This yields a key for every changed field between old and new.
     pub const ChangeIterator = struct {
         old: *const Config,
         new: *const Config,
         i: usize = 0,
 
         pub fn next(self: *ChangeIterator) ?Key {
-            const fields = comptime std.meta.fields(Config);
-
+            const fields = comptime std.meta.fields(Key);
             while (self.i < fields.len) {
                 switch (self.i) {
                     inline 0...(fields.len - 1) => |i| {
                         const field = fields[i];
+                        const key = @field(Key, field.name);
                         self.i += 1;
-
-                        if (field.name[0] == '_') return self.next();
-
-                        const old_value = @field(self.old, field.name);
-                        const new_value = @field(self.new, field.name);
-                        if (!equal(field.type, old_value, new_value)) {
-                            return @field(Key, field.name);
-                        }
+                        if (self.old.changed(self.new, key)) return key;
                     },
 
                     else => unreachable,
@@ -766,6 +783,20 @@ pub const Config = struct {
         // I want to do this but this doesn't work (the API doesn't work)
         // try testing.expectEqualDeep(dest, source);
     }
+
+    test "changed" {
+        const testing = std.testing;
+        const alloc = testing.allocator;
+
+        var source = try Config.default(alloc);
+        defer source.deinit();
+        var dest = try source.clone(alloc);
+        defer dest.deinit();
+        dest.@"font-family" = "something else";
+
+        try testing.expect(source.changed(&dest, .@"font-family"));
+        try testing.expect(!source.changed(&dest, .@"font-size"));
+    }
 };
 
 /// Color represents a color using RGB.

commit 11e4215f9fba4878d35239e4851fc721a3943019
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 21:52:48 2023 -0700

    config: implement comparison for keybinding change

diff --git a/src/config.zig b/src/config.zig
index 262a59a8..06626b3e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,3 +1,4 @@
+const config = @This();
 const std = @import("std");
 const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
@@ -711,37 +712,6 @@ pub const Config = struct {
         return !equal(field.type, old_value, new_value);
     }
 
-    fn equal(comptime T: type, old: T, new: T) bool {
-        // Do known named types first
-        switch (T) {
-            inline []const u8,
-            [:0]const u8,
-            => return std.mem.eql(u8, old, new),
-
-            else => {},
-        }
-
-        // Back into types of types
-        switch (@typeInfo(T)) {
-            inline .Bool,
-            .Int,
-            => return old == new,
-
-            .Optional => |info| {
-                if (old == null and new == null) return true;
-                if (old == null or new == null) return false;
-                return equal(info.child, old.?, new.?);
-            },
-
-            .Struct => return old.equal(new),
-
-            else => {
-                @compileLog(T);
-                @compileError("unsupported field type");
-            },
-        }
-    }
-
     /// This yields a key for every changed field between old and new.
     pub const ChangeIterator = struct {
         old: *const Config,
@@ -799,6 +769,78 @@ pub const Config = struct {
     }
 };
 
+/// A config-specific helper to determine if two values of the same
+/// type are equal. This isn't the same as std.mem.eql or std.testing.equals
+/// because we expect structs to implement their own equality.
+///
+/// This also doesn't support ALL Zig types, because we only add to it
+/// as we need types for the config.
+fn equal(comptime T: type, old: T, new: T) bool {
+    // Do known named types first
+    switch (T) {
+        inline []const u8,
+        [:0]const u8,
+        => return std.mem.eql(u8, old, new),
+
+        else => {},
+    }
+
+    // Back into types of types
+    switch (@typeInfo(T)) {
+        .Void => return true,
+
+        inline .Bool,
+        .Int,
+        .Enum,
+        => return old == new,
+
+        .Optional => |info| {
+            if (old == null and new == null) return true;
+            if (old == null or new == null) return false;
+            return equal(info.child, old.?, new.?);
+        },
+
+        .Struct => |info| {
+            if (@hasDecl(T, "equal")) return old.equal(new);
+
+            // If a struct doesn't declare an "equal" function, we fall back
+            // to a recursive field-by-field compare.
+            inline for (info.fields) |field_info| {
+                if (!equal(
+                    field_info.type,
+                    @field(old, field_info.name),
+                    @field(new, field_info.name),
+                )) return false;
+            }
+            return true;
+        },
+
+        .Union => |info| {
+            const tag_type = info.tag_type.?;
+            const old_tag = std.meta.activeTag(old);
+            const new_tag = std.meta.activeTag(new);
+            if (old_tag != new_tag) return false;
+
+            inline for (info.fields) |field_info| {
+                if (@field(tag_type, field_info.name) == old_tag) {
+                    return equal(
+                        field_info.type,
+                        @field(old, field_info.name),
+                        @field(new, field_info.name),
+                    );
+                }
+            }
+
+            unreachable;
+        },
+
+        else => {
+            @compileLog(T);
+            @compileError("unsupported field type");
+        },
+    }
+}
+
 /// Color represents a color using RGB.
 pub const Color = struct {
     r: u8,
@@ -1006,9 +1048,21 @@ pub const Keybinds = struct {
 
     /// Compare if two of our value are requal. Required by Config.
     pub fn equal(self: Keybinds, other: Keybinds) bool {
-        // TODO
-        _ = self;
-        _ = other;
+        const self_map = self.set.bindings;
+        const other_map = other.set.bindings;
+        if (self_map.count() != other_map.count()) return false;
+
+        var it = self_map.iterator();
+        while (it.next()) |self_entry| {
+            const other_entry = other_map.getEntry(self_entry.key_ptr.*) orelse
+                return false;
+            if (!config.equal(
+                inputpkg.Binding.Action,
+                self_entry.value_ptr.*,
+                other_entry.value_ptr.*,
+            )) return false;
+        }
+
         return true;
     }
 

commit 3ce7baf30e4540a8bfbc71b593638858ce9a797c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 22:03:20 2023 -0700

    config: dedicated load func so we can reload

diff --git a/src/config.zig b/src/config.zig
index 06626b3e..3789fe1a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -202,6 +202,34 @@ pub const Config = struct {
         self.* = undefined;
     }
 
+    /// Load the configuration according to the default rules:
+    ///
+    ///   1. Defaults
+    ///   2. XDG Config File
+    ///   3. CLI flags
+    ///   4. Recursively defined configuration files
+    ///
+    pub fn load(alloc_gpa: Allocator) !Config {
+        var result = try default(alloc_gpa);
+        errdefer result.deinit();
+
+        // If we have a configuration file in our home directory, parse that first.
+        try result.loadDefaultFiles(alloc_gpa);
+
+        // Parse the config from the CLI args
+        {
+            var iter = try std.process.argsWithAllocator(alloc_gpa);
+            defer iter.deinit();
+            try cli_args.parse(Config, alloc_gpa, &result, &iter);
+        }
+
+        // Parse the config files that were added from our file and CLI args.
+        try result.loadRecursiveFiles(alloc_gpa);
+        try result.finalize();
+
+        return result;
+    }
+
     pub fn default(alloc_gpa: Allocator) Allocator.Error!Config {
         // Build up our basic config
         var result: Config = .{

commit f5c1dfa37471e8ea2ceff494e9b09953a6b485e4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 22:00:10 2023 -0700

    reload_config keybinding (defaults to ctrl+alt+super+space)

diff --git a/src/config.zig b/src/config.zig
index 3789fe1a..c30355f5 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -239,6 +239,12 @@ pub const Config = struct {
         const alloc = result._arena.?.allocator();
 
         // Add our default keybindings
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .space, .mods = .{ .super = true, .alt = true, .ctrl = true } },
+            .{ .reload_config = {} },
+        );
+
         {
             // On macOS we default to super but Linux ctrl+shift since
             // ctrl+c is to kill the process.

commit b26e51d2226db0b2123e78b337613457bfee5822
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Mar 16 15:29:46 2023 -0700

    macos: implement config reloading callback

diff --git a/src/config.zig b/src/config.zig
index c30355f5..3f9e6ede 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -217,11 +217,7 @@ pub const Config = struct {
         try result.loadDefaultFiles(alloc_gpa);
 
         // Parse the config from the CLI args
-        {
-            var iter = try std.process.argsWithAllocator(alloc_gpa);
-            defer iter.deinit();
-            try cli_args.parse(Config, alloc_gpa, &result, &iter);
-        }
+        try result.loadCliArgs(alloc_gpa);
 
         // Parse the config files that were added from our file and CLI args.
         try result.loadRecursiveFiles(alloc_gpa);
@@ -564,6 +560,14 @@ pub const Config = struct {
         }
     }
 
+    /// Load and parse the CLI args.
+    pub fn loadCliArgs(self: *Config, alloc_gpa: Allocator) !void {
+        // Parse the config from the CLI args
+        var iter = try std.process.argsWithAllocator(alloc_gpa);
+        defer iter.deinit();
+        try cli_args.parse(Config, alloc_gpa, self, &iter);
+    }
+
     /// Load and parse the config files that were added in the "config-file" key.
     pub fn loadRecursiveFiles(self: *Config, alloc: Allocator) !void {
         // TODO(mitchellh): we should parse the files form the homedir first
@@ -1190,6 +1194,13 @@ pub const CAPI = struct {
         }
     }
 
+    /// Load the configuration from the CLI args.
+    export fn ghostty_config_load_cli_args(self: *Config) void {
+        self.loadCliArgs(global.alloc) catch |err| {
+            log.err("error loading config err={}", .{err});
+        };
+    }
+
     /// Load the configuration from a string in the same format as
     /// the file-based syntax for the desktop version of the terminal.
     export fn ghostty_config_load_string(

commit ce10d875b6f09e19df1ef36cf8da52d7cb694688
Merge: f28b6774 b0b3b0af
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 19 12:32:23 2023 -0700

    Merge pull request #117 from mitchellh/config-stuff
    
    Reloadable Configuration


commit 0cd6e08ca36629b72fd62ea7749504344c8c06ec
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 20 15:51:27 2023 -0700

    if no argv, then don't load CLI args

diff --git a/src/config.zig b/src/config.zig
index be7f8c83..527ac54c 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -562,6 +562,13 @@ pub const Config = struct {
 
     /// Load and parse the CLI args.
     pub fn loadCliArgs(self: *Config, alloc_gpa: Allocator) !void {
+        switch (builtin.os.tag) {
+            .windows => {},
+
+            // Fast-path if we are non-Windows and no args, do nothing.
+            else => if (std.os.argv.len <= 1) return,
+        }
+
         // Parse the config from the CLI args
         var iter = try std.process.argsWithAllocator(alloc_gpa);
         defer iter.deinit();

commit 16244d0dab32d67a96d4200698ab199dae2a8f1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 27 10:24:01 2023 -0700

    apprt/gtk: close keybind doesn't leak memory

diff --git a/src/config.zig b/src/config.zig
index 527ac54c..c7b55060 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -346,6 +346,11 @@ pub const Config = struct {
                 .{ .key = .w, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .close_surface = {} },
             );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .q, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .quit = {} },
+            );
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .f4, .mods = .{ .alt = true } },

commit 5aa351412212d0db86f792368a1adc82456c303a
Author: Jack Pearkes <jackpearkes@gmail.com>
Date:   Wed Apr 5 12:49:03 2023 -0700

    config: add confirm-close-surface

diff --git a/src/config.zig b/src/config.zig
index c7b55060..6d75e4e1 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -164,6 +164,10 @@ pub const Config = struct {
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 
+    // Confirms that a surface should be closed before closing it. This defaults
+    // to true. If set to false, surfaces will close without any confirmation.
+    @"confirm-close-surface": bool = true,
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 

commit f31d6fb8fe64ba52d5adde20a17c6709abe7d0c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 21:08:50 2023 -0700

    apprt: clean up how apprt initializes surfaces

diff --git a/src/config.zig b/src/config.zig
index 6d75e4e1..9a82c59d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -691,6 +691,21 @@ pub const Config = struct {
         }
     }
 
+    /// Create a shallow copy of this config. This will share all the memory
+    /// allocated with the previous config but will have a new arena for
+    /// any changes or new allocations. The config should have `deinit`
+    /// called when it is complete.
+    ///
+    /// Beware: these shallow clones are not meant for a long lifetime,
+    /// they are just meant to exist temporarily for the duration of some
+    /// modifications. It is very important that the original config not
+    /// be deallocated while shallow clones exist.
+    pub fn shallowClone(self: *const Config, alloc_gpa: Allocator) Config {
+        var result = self.*;
+        result._arena = ArenaAllocator.init(alloc_gpa);
+        return result;
+    }
+
     /// Create a copy of this configuration. This is useful as a starting
     /// point for modifying a configuration since a config can NOT be
     /// modified once it is in use by an app or surface.

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/config.zig b/src/config.zig
index 9a82c59d..442b17ee 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -418,8 +418,8 @@ pub const Config = struct {
         }
         {
             // Cmd+N for goto tab N
-            const start = @enumToInt(inputpkg.Key.one);
-            const end = @enumToInt(inputpkg.Key.nine);
+            const start = @intFromEnum(inputpkg.Key.one);
+            const end = @intFromEnum(inputpkg.Key.nine);
             var i: usize = start;
             while (i <= end) : (i += 1) {
                 // On macOS we default to super but everywhere else
@@ -431,7 +431,7 @@ pub const Config = struct {
 
                 try result.keybind.set.put(
                     alloc,
-                    .{ .key = @intToEnum(inputpkg.Key, i), .mods = mods },
+                    .{ .key = @enumFromInt(inputpkg.Key, i), .mods = mods },
                     .{ .goto_tab = (i - start) + 1 },
                 );
             }

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/config.zig b/src/config.zig
index 442b17ee..a6c7c3b5 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -431,7 +431,7 @@ pub const Config = struct {
 
                 try result.keybind.set.put(
                     alloc,
-                    .{ .key = @enumFromInt(inputpkg.Key, i), .mods = mods },
+                    .{ .key = @enumFromInt(i), .mods = mods },
                     .{ .goto_tab = (i - start) + 1 },
                 );
             }

commit 3795cd6c2d8864e846c24a63f2f720244c79d783
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 09:55:19 2023 -0700

    font: turn rasterization options into a struct, add thicken

diff --git a/src/config.zig b/src/config.zig
index a6c7c3b5..a5de9afc 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -34,6 +34,10 @@ pub const Config = struct {
         else => 12,
     },
 
+    /// Draw fonts with a thicker stroke, if supported. This is only supported
+    /// currently on macOS.
+    @"font-thicken": bool = false,
+
     /// Background color for the window.
     background: Color = .{ .r = 0x28, .g = 0x2C, .b = 0x34 },
 

commit 8e464db04924bc0f79c7a86c6561a9e79cfdd09f
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sun Jul 2 19:59:41 2023 +0200

    Toggle fullscreen on super/ctrl+return, only macOS for now
    
    This fixes or at least is the first step towards #171:
    
    - it adds `cmd/super + return` as the default keybinding to toggle
      fullscreen for currently focused window.
    - it adds a keybinding handler to the embedded apprt and then changes
      the macOS app to handle the keybinding by toggling currently focused
      window.

diff --git a/src/config.zig b/src/config.zig
index a5de9afc..c1c9f1f7 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -441,6 +441,13 @@ pub const Config = struct {
             }
         }
 
+        // Toggle fullscreen
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .enter, .mods = ctrlOrSuper(.{}) },
+            .{ .toggle_fullscreen = {} },
+        );
+
         // Mac-specific keyboard bindings.
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(

commit 875609026604c74fd6911bd3a900c94fdbcd9275
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 17:50:45 2023 -0700

    config: add background-opacity and float parsing for config

diff --git a/src/config.zig b/src/config.zig
index c1c9f1f7..63038c74 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -63,6 +63,10 @@ pub const Config = struct {
     /// The color of the cursor. If this is not set, a default will be chosen.
     @"cursor-color": ?Color = null,
 
+    /// The opacity level (opposite of transparency) of the background.
+    /// A value of 1 is fully opaque and a value of 0 is fully transparent.
+    @"background-opacity": f64 = 1.0,
+
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH. If this is not set, a default will
     /// be looked up from your system. The rules for the default lookup are:
@@ -754,6 +758,7 @@ pub const Config = struct {
         switch (@typeInfo(T)) {
             inline .Bool,
             .Int,
+            .Float,
             => return src,
 
             .Optional => |info| return try cloneValue(
@@ -879,6 +884,7 @@ fn equal(comptime T: type, old: T, new: T) bool {
 
         inline .Bool,
         .Int,
+        .Float,
         .Enum,
         => return old == new,
 

commit 017da411f8935c6b249ff2d2b9f4fb89751854c3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 17:59:50 2023 -0700

    metal: start setting up background transparency

diff --git a/src/config.zig b/src/config.zig
index 63038c74..e5a8d787 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -65,6 +65,11 @@ pub const Config = struct {
 
     /// The opacity level (opposite of transparency) of the background.
     /// A value of 1 is fully opaque and a value of 0 is fully transparent.
+    /// A value less than 0 or greater than 1 will be clamped to the nearest
+    /// valid value.
+    ///
+    /// This can be changed at runtime for native macOS and Linux GTK builds.
+    /// This can NOT be changed at runtime for GLFW builds (not common).
     @"background-opacity": f64 = 1.0,
 
     /// The command to run, usually a shell. If this is not an absolute path,

commit 7896f99f2f46303ecb871589f9ab47ddbe654cdd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 19:45:36 2023 -0700

    config: clarify reload

diff --git a/src/config.zig b/src/config.zig
index e5a8d787..ca4d8ff9 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -68,8 +68,8 @@ pub const Config = struct {
     /// A value less than 0 or greater than 1 will be clamped to the nearest
     /// valid value.
     ///
-    /// This can be changed at runtime for native macOS and Linux GTK builds.
-    /// This can NOT be changed at runtime for GLFW builds (not common).
+    /// Changing this value at runtime (and reloading config) will only
+    /// affect new windows, tabs, and splits.
     @"background-opacity": f64 = 1.0,
 
     /// The command to run, usually a shell. If this is not an absolute path,

commit 9a079bb5b9f1adf8b73547d989d1db43d55110d1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 20:41:01 2023 -0700

    background-blur-radius for macOS

diff --git a/src/config.zig b/src/config.zig
index ca4d8ff9..cd92cbbf 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -72,6 +72,15 @@ pub const Config = struct {
     /// affect new windows, tabs, and splits.
     @"background-opacity": f64 = 1.0,
 
+    /// A positive value enables blurring of the background when
+    /// background-opacity is less than 1. The value is the blur radius to
+    /// apply. A value of 20 is reasonable for a good looking blur.
+    /// Higher values will cause strange rendering issues as well as
+    /// performance issues.
+    ///
+    /// This is only supported on macOS.
+    @"background-blur-radius": u8 = 0,
+
     /// The command to run, usually a shell. If this is not an absolute path,
     /// it'll be looked up in the PATH. If this is not set, a default will
     /// be looked up from your system. The rules for the default lookup are:

commit 45ac9b5d4c59b4af1659cbb8de482ebadd6e50fe
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Jul 5 13:05:51 2023 -0700

    font-feature config to enable/disable OpenType Font Features

diff --git a/src/config.zig b/src/config.zig
index cd92cbbf..456ba97b 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -26,6 +26,17 @@ pub const Config = struct {
     @"font-family-italic": ?[:0]const u8 = null,
     @"font-family-bold-italic": ?[:0]const u8 = null,
 
+    /// Apply a font feature. This can be repeated multiple times to enable
+    /// multiple font features. You can NOT set multiple font features with
+    /// a single value (yet).
+    ///
+    /// The font feature will apply to all fonts rendered by Ghostty. A
+    /// future enhancement will allow targetting specific faces.
+    ///
+    /// A valid value is the name of a feature. Prefix the feature with a
+    /// "-" to explicitly disable it. Example: "ss20" or "-ss20".
+    @"font-feature": RepeatableString = .{},
+
     /// Font size in points
     @"font-size": u8 = switch (builtin.os.tag) {
         // On Mac we default a little bigger since this tends to look better.

commit 9f86c48fd88eef9634942f95cf2eb63fbc3f4a48
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 10:30:29 2023 -0700

    keybinding jump_to_prompt for semantic prompts

diff --git a/src/config.zig b/src/config.zig
index 456ba97b..a54c5e06 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -491,6 +491,18 @@ pub const Config = struct {
                 .{ .clear_screen = {} },
             );
 
+            // Semantic prompts
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .up, .mods = .{ .super = true, .shift = true } },
+                .{ .jump_to_prompt = -1 },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .down, .mods = .{ .super = true, .shift = true } },
+                .{ .jump_to_prompt = 1 },
+            );
+
             // Mac windowing
             try result.keybind.set.put(
                 alloc,

commit 8239f09d9d76a3f16afae631270bbeefd130f177
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 18:04:12 2023 -0700

    allow configuring shell integration injection

diff --git a/src/config.zig b/src/config.zig
index a54c5e06..8b5bc091 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -197,10 +197,32 @@ pub const Config = struct {
     /// Additional configuration files to read.
     @"config-file": RepeatableString = .{},
 
-    // Confirms that a surface should be closed before closing it. This defaults
-    // to true. If set to false, surfaces will close without any confirmation.
+    /// Confirms that a surface should be closed before closing it. This defaults
+    /// to true. If set to false, surfaces will close without any confirmation.
     @"confirm-close-surface": bool = true,
 
+    /// Whether to enable shell integration auto-injection or not. Shell
+    /// integration greatly enhances the terminal experience by enabling
+    /// a number of features:
+    ///
+    ///   * Working directory reporting so new tabs, splits inherit the
+    ///     previous terminal's working directory.
+    ///   * Prompt marking that enables the "scroll_to_prompt" keybinding.
+    ///   * If you're sitting at a prompt, closing a terminal will not ask
+    ///     for confirmation.
+    ///   * Resizing the window with a complex prompt usually paints much
+    ///     better.
+    ///
+    /// Allowable values are:
+    ///
+    ///   * "none" - Do not do any automatic injection. You can still manually
+    ///     configure your shell to enable the integration.
+    ///   * "auto" - Detect the shell based on the filename.
+    ///   * "fish", "zsh" - Use this specific shell injection scheme.
+    ///
+    /// The default value is "auto".
+    @"shell-integration": ShellIntegration = .auto,
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 
@@ -1209,6 +1231,13 @@ pub const Keybinds = struct {
     }
 };
 
+pub const ShellIntegration = enum {
+    none,
+    auto,
+    fish,
+    zsh,
+};
+
 // Wasm API.
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");

commit 02d0619f8775515e7a5e96ccc2267c1aec663527
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 18:05:01 2023 -0700

    change "auto" to "detect" for shell integration

diff --git a/src/config.zig b/src/config.zig
index 8b5bc091..ac147d01 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -217,11 +217,11 @@ pub const Config = struct {
     ///
     ///   * "none" - Do not do any automatic injection. You can still manually
     ///     configure your shell to enable the integration.
-    ///   * "auto" - Detect the shell based on the filename.
+    ///   * "detect" - Detect the shell based on the filename.
     ///   * "fish", "zsh" - Use this specific shell injection scheme.
     ///
-    /// The default value is "auto".
-    @"shell-integration": ShellIntegration = .auto,
+    /// The default value is "detect".
+    @"shell-integration": ShellIntegration = .detect,
 
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
@@ -1233,7 +1233,7 @@ pub const Keybinds = struct {
 
 pub const ShellIntegration = enum {
     none,
-    auto,
+    detect,
     fish,
     zsh,
 };

commit 247638c2da1f8af953b942fb2ecd14d46de66547
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jul 6 18:13:26 2023 -0700

    config: support enum cloning

diff --git a/src/config.zig b/src/config.zig
index ac147d01..feeea8cd 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -818,6 +818,7 @@ pub const Config = struct {
             inline .Bool,
             .Int,
             .Float,
+            .Enum,
             => return src,
 
             .Optional => |info| return try cloneValue(

commit 5faafbbfa5d0104b70e1361dea34e9c5b6f0d2b7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jul 9 12:28:48 2023 -0700

    write_scrollback_file binding

diff --git a/src/config.zig b/src/config.zig
index feeea8cd..0a7f9f53 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -393,6 +393,12 @@ pub const Config = struct {
             .{ .toggle_dev_mode = {} },
         );
 
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = true }) },
+            .{ .write_scrollback_file = {} },
+        );
+
         // Windowing
         if (comptime !builtin.target.isDarwin()) {
             try result.keybind.set.put(

commit bf25bf0a6a6b506241eaff337e1f41628eee23b5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 10 16:48:22 2023 -0700

    move a bunch of files to src/os

diff --git a/src/config.zig b/src/config.zig
index 0a7f9f53..e70ff794 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -4,10 +4,8 @@ const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
 const inputpkg = @import("input.zig");
-const passwd = @import("passwd.zig");
 const terminal = @import("terminal/main.zig");
 const internal_os = @import("os/main.zig");
-const xdg = @import("xdg.zig");
 const cli_args = @import("cli_args.zig");
 
 const log = std.log.scoped(.config);
@@ -625,7 +623,7 @@ pub const Config = struct {
     /// Load the configuration from the default file locations. Currently,
     /// this loads from $XDG_CONFIG_HOME/ghostty/config.
     pub fn loadDefaultFiles(self: *Config, alloc: Allocator) !void {
-        const home_config_path = try xdg.config(alloc, .{ .subdir = "ghostty/config" });
+        const home_config_path = try internal_os.xdg.config(alloc, .{ .subdir = "ghostty/config" });
         defer alloc.free(home_config_path);
 
         const cwd = std.fs.cwd();
@@ -740,7 +738,7 @@ pub const Config = struct {
                 }
 
                 // We need the passwd entry for the remainder
-                const pw = try passwd.get(alloc);
+                const pw = try internal_os.passwd.get(alloc);
                 if (self.command == null) {
                     if (pw.shell) |sh| {
                         log.info("default shell src=passwd value={s}", .{sh});

commit 920b90ba1aaf0e0535d2c89c36b93f70a2b46d3c
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sun Jul 23 14:02:39 2023 +0200

    config: change default keybind for goto-split on non-Darwin
    
    Feel free to ignore or close this, because this is personal and if I
    could figure out the syntax, I'm sure I could overwrite the keybindings
    in the config myself.
    
    But here's my case: `Ctrl+[` sends escape and I use that instead of
    `Esc` because it's easier to reach (capslock is remapped to `ctrl`, so
    `ctrl+[` is homerow only).
    
    Kitty uses it's own "kittymod" combo for a lot of keybindings and for
    the equivalent of these two, it uses `Ctrl+shift`. That's already taken
    by other keybindings, so I added `.super` here.
    
    Again: feel free to ignore. Personal preference. If you close this PR,
    I'll have to tweak my config on Linux.

diff --git a/src/config.zig b/src/config.zig
index e70ff794..86ea3a7e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -446,12 +446,12 @@ pub const Config = struct {
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .ctrl = true } },
+                .{ .key = .left_bracket, .mods = .{ .ctrl = true, .super = true } },
                 .{ .goto_split = .previous },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .ctrl = true } },
+                .{ .key = .right_bracket, .mods = .{ .ctrl = true, .super = true } },
                 .{ .goto_split = .next },
             );
             try result.keybind.set.put(

commit b56ffa6285c9e79722514c3823ebfa98f7cb716e
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sat Jul 29 21:05:49 2023 +0200

    Add config setting to turn non-native fullscreen on or off

diff --git a/src/config.zig b/src/config.zig
index 86ea3a7e..7d2a7fc2 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -221,6 +221,12 @@ pub const Config = struct {
     /// The default value is "detect".
     @"shell-integration": ShellIntegration = .detect,
 
+    /// If true, fullscreen mode on macOS will not use the native fullscreen,
+    /// but make the window fullscreen without animations and using a new space.
+    /// That's faster than the native fullscreen mode since it doesn't use
+    /// animations.
+    @"macos-non-native-fullscreen": bool = false,
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 

commit 2840062ad5048a7db86fbf72d6fcc81f9d2418f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 5 21:32:30 2023 -0700

    bind shift+<page-up/down> to jump_to_prompt back/forward, respectively

diff --git a/src/config.zig b/src/config.zig
index 7d2a7fc2..e812cbec 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -480,6 +480,18 @@ pub const Config = struct {
                 .{ .key = .right, .mods = .{ .ctrl = true, .alt = true } },
                 .{ .goto_split = .right },
             );
+
+            // Semantic prompts
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_up, .mods = .{ .shift = true } },
+                .{ .jump_to_prompt = -1 },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_down, .mods = .{ .shift = true } },
+                .{ .jump_to_prompt = 1 },
+            );
         }
         {
             // Cmd+N for goto tab N

commit 67cbabd605b064100c1588d0ec63fafa1764186c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 14:33:56 2023 -0700

    make keyboard modifiers left/right-aware throughout core

diff --git a/src/config.zig b/src/config.zig
index e812cbec..961a6725 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -300,7 +300,7 @@ pub const Config = struct {
         // Add our default keybindings
         try result.keybind.set.put(
             alloc,
-            .{ .key = .space, .mods = .{ .super = true, .alt = true, .ctrl = true } },
+            .{ .key = .space, .mods = .{ .super = .both, .alt = .both, .ctrl = .both } },
             .{ .reload_config = {} },
         );
 
@@ -308,9 +308,9 @@ pub const Config = struct {
             // On macOS we default to super but Linux ctrl+shift since
             // ctrl+c is to kill the process.
             const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                .{ .super = true }
+                .{ .super = .both }
             else
-                .{ .ctrl = true, .shift = true };
+                .{ .ctrl = .both, .shift = .both };
 
             try result.keybind.set.put(
                 alloc,
@@ -393,13 +393,13 @@ pub const Config = struct {
         // Dev Mode
         try result.keybind.set.put(
             alloc,
-            .{ .key = .down, .mods = .{ .shift = true, .super = true } },
+            .{ .key = .down, .mods = .{ .shift = .both, .super = .both } },
             .{ .toggle_dev_mode = {} },
         );
 
         try result.keybind.set.put(
             alloc,
-            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = true }) },
+            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = .both }) },
             .{ .write_scrollback_file = {} },
         );
 
@@ -407,89 +407,89 @@ pub const Config = struct {
         if (comptime !builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .n, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .n, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .new_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .w, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .close_surface = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .q, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .q, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .quit = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .f4, .mods = .{ .alt = true } },
+                .{ .key = .f4, .mods = .{ .alt = .both } },
                 .{ .close_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .t, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .t, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .new_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .left, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .previous_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .right, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .next_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .o, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .o, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .new_split = .right },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .e, .mods = .{ .ctrl = true, .shift = true } },
+                .{ .key = .e, .mods = .{ .ctrl = .both, .shift = .both } },
                 .{ .new_split = .down },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .ctrl = true, .super = true } },
+                .{ .key = .left_bracket, .mods = .{ .ctrl = .both, .super = .both } },
                 .{ .goto_split = .previous },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .ctrl = true, .super = true } },
+                .{ .key = .right_bracket, .mods = .{ .ctrl = .both, .super = .both } },
                 .{ .goto_split = .next },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .key = .up, .mods = .{ .ctrl = .both, .alt = .both } },
                 .{ .goto_split = .top },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .key = .down, .mods = .{ .ctrl = .both, .alt = .both } },
                 .{ .goto_split = .bottom },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .key = .left, .mods = .{ .ctrl = .both, .alt = .both } },
                 .{ .goto_split = .left },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .ctrl = true, .alt = true } },
+                .{ .key = .right, .mods = .{ .ctrl = .both, .alt = .both } },
                 .{ .goto_split = .right },
             );
 
             // Semantic prompts
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .page_up, .mods = .{ .shift = true } },
+                .{ .key = .page_up, .mods = .{ .shift = .both } },
                 .{ .jump_to_prompt = -1 },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .page_down, .mods = .{ .shift = true } },
+                .{ .key = .page_down, .mods = .{ .shift = .both } },
                 .{ .jump_to_prompt = 1 },
             );
         }
@@ -502,9 +502,9 @@ pub const Config = struct {
                 // On macOS we default to super but everywhere else
                 // is alt.
                 const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                    .{ .super = true }
+                    .{ .super = .both }
                 else
-                    .{ .alt = true };
+                    .{ .alt = .both };
 
                 try result.keybind.set.put(
                     alloc,
@@ -525,97 +525,97 @@ pub const Config = struct {
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .q, .mods = .{ .super = true } },
+                .{ .key = .q, .mods = .{ .super = .both } },
                 .{ .quit = {} },
             );
 
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .k, .mods = .{ .super = true } },
+                .{ .key = .k, .mods = .{ .super = .both } },
                 .{ .clear_screen = {} },
             );
 
             // Semantic prompts
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .up, .mods = .{ .super = .both, .shift = .both } },
                 .{ .jump_to_prompt = -1 },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .down, .mods = .{ .super = .both, .shift = .both } },
                 .{ .jump_to_prompt = 1 },
             );
 
             // Mac windowing
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .n, .mods = .{ .super = true } },
+                .{ .key = .n, .mods = .{ .super = .both } },
                 .{ .new_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .super = true } },
+                .{ .key = .w, .mods = .{ .super = .both } },
                 .{ .close_surface = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .w, .mods = .{ .super = .both, .shift = .both } },
                 .{ .close_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .t, .mods = .{ .super = true } },
+                .{ .key = .t, .mods = .{ .super = .both } },
                 .{ .new_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .left_bracket, .mods = .{ .super = .both, .shift = .both } },
                 .{ .previous_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .right_bracket, .mods = .{ .super = .both, .shift = .both } },
                 .{ .next_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .super = true } },
+                .{ .key = .d, .mods = .{ .super = .both } },
                 .{ .new_split = .right },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .super = true, .shift = true } },
+                .{ .key = .d, .mods = .{ .super = .both, .shift = .both } },
                 .{ .new_split = .down },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = true } },
+                .{ .key = .left_bracket, .mods = .{ .super = .both } },
                 .{ .goto_split = .previous },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = true } },
+                .{ .key = .right_bracket, .mods = .{ .super = .both } },
                 .{ .goto_split = .next },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .super = true, .alt = true } },
+                .{ .key = .up, .mods = .{ .super = .both, .alt = .both } },
                 .{ .goto_split = .top },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .super = true, .alt = true } },
+                .{ .key = .down, .mods = .{ .super = .both, .alt = .both } },
                 .{ .goto_split = .bottom },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .super = true, .alt = true } },
+                .{ .key = .left, .mods = .{ .super = .both, .alt = .both } },
                 .{ .goto_split = .left },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .super = true, .alt = true } },
+                .{ .key = .right, .mods = .{ .super = .both, .alt = .both } },
                 .{ .goto_split = .right },
             );
         }
@@ -630,9 +630,9 @@ pub const Config = struct {
     fn ctrlOrSuper(mods: inputpkg.Mods) inputpkg.Mods {
         var copy = mods;
         if (comptime builtin.target.isDarwin()) {
-            copy.super = true;
+            copy.super = .both;
         } else {
-            copy.ctrl = true;
+            copy.ctrl = .both;
         }
 
         return copy;

commit 32eb226fa3de2d3909872439005fbb6f9cbea864
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 14:52:20 2023 -0700

    non-macos doesn't support directional bindings

diff --git a/src/config.zig b/src/config.zig
index 961a6725..ef56f3d4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,6 +3,7 @@ const std = @import("std");
 const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
+const apprt = @import("apprt.zig");
 const inputpkg = @import("input.zig");
 const terminal = @import("terminal/main.zig");
 const internal_os = @import("os/main.zig");
@@ -1206,7 +1207,18 @@ pub const Keybinds = struct {
         };
         errdefer if (copy) |v| alloc.free(v);
 
-        const binding = try inputpkg.Binding.parse(value);
+        const binding = binding: {
+            var binding = try inputpkg.Binding.parse(value);
+
+            // Unless we're on native macOS, we don't allow directional
+            // keys, so we just remap them to "both".
+            if (comptime !(builtin.target.isDarwin() and apprt.runtime == apprt.embedded)) {
+                binding.trigger.mods = binding.trigger.mods.removeDirection();
+            }
+
+            break :binding binding;
+        };
+
         switch (binding.action) {
             .unbind => self.set.remove(binding.trigger),
             else => try self.set.put(alloc, binding.trigger, binding.action),

commit 22296b377a9336114c56a92fe82653b63328a646
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 17:06:40 2023 -0700

    Revert "Merge pull request #244 from mitchellh/alt-as-esc"
    
    This reverts commit c139279d479682c17f63d9b57c2d56608d09d16a, reversing
    changes made to 4ed21047a734d7c586debe0026e3b6ea90ed1622.
    
    We do want to do this but this broke bindings.

diff --git a/src/config.zig b/src/config.zig
index ef56f3d4..e812cbec 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,7 +3,6 @@ const std = @import("std");
 const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
-const apprt = @import("apprt.zig");
 const inputpkg = @import("input.zig");
 const terminal = @import("terminal/main.zig");
 const internal_os = @import("os/main.zig");
@@ -301,7 +300,7 @@ pub const Config = struct {
         // Add our default keybindings
         try result.keybind.set.put(
             alloc,
-            .{ .key = .space, .mods = .{ .super = .both, .alt = .both, .ctrl = .both } },
+            .{ .key = .space, .mods = .{ .super = true, .alt = true, .ctrl = true } },
             .{ .reload_config = {} },
         );
 
@@ -309,9 +308,9 @@ pub const Config = struct {
             // On macOS we default to super but Linux ctrl+shift since
             // ctrl+c is to kill the process.
             const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                .{ .super = .both }
+                .{ .super = true }
             else
-                .{ .ctrl = .both, .shift = .both };
+                .{ .ctrl = true, .shift = true };
 
             try result.keybind.set.put(
                 alloc,
@@ -394,13 +393,13 @@ pub const Config = struct {
         // Dev Mode
         try result.keybind.set.put(
             alloc,
-            .{ .key = .down, .mods = .{ .shift = .both, .super = .both } },
+            .{ .key = .down, .mods = .{ .shift = true, .super = true } },
             .{ .toggle_dev_mode = {} },
         );
 
         try result.keybind.set.put(
             alloc,
-            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = .both }) },
+            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = true }) },
             .{ .write_scrollback_file = {} },
         );
 
@@ -408,89 +407,89 @@ pub const Config = struct {
         if (comptime !builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .n, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .n, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .w, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .close_surface = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .q, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .q, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .quit = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .f4, .mods = .{ .alt = .both } },
+                .{ .key = .f4, .mods = .{ .alt = true } },
                 .{ .close_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .t, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .t, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .left, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .previous_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .right, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .next_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .o, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .o, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_split = .right },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .e, .mods = .{ .ctrl = .both, .shift = .both } },
+                .{ .key = .e, .mods = .{ .ctrl = true, .shift = true } },
                 .{ .new_split = .down },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .ctrl = .both, .super = .both } },
+                .{ .key = .left_bracket, .mods = .{ .ctrl = true, .super = true } },
                 .{ .goto_split = .previous },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .ctrl = .both, .super = .both } },
+                .{ .key = .right_bracket, .mods = .{ .ctrl = true, .super = true } },
                 .{ .goto_split = .next },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .ctrl = .both, .alt = .both } },
+                .{ .key = .up, .mods = .{ .ctrl = true, .alt = true } },
                 .{ .goto_split = .top },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .ctrl = .both, .alt = .both } },
+                .{ .key = .down, .mods = .{ .ctrl = true, .alt = true } },
                 .{ .goto_split = .bottom },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .ctrl = .both, .alt = .both } },
+                .{ .key = .left, .mods = .{ .ctrl = true, .alt = true } },
                 .{ .goto_split = .left },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .ctrl = .both, .alt = .both } },
+                .{ .key = .right, .mods = .{ .ctrl = true, .alt = true } },
                 .{ .goto_split = .right },
             );
 
             // Semantic prompts
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .page_up, .mods = .{ .shift = .both } },
+                .{ .key = .page_up, .mods = .{ .shift = true } },
                 .{ .jump_to_prompt = -1 },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .page_down, .mods = .{ .shift = .both } },
+                .{ .key = .page_down, .mods = .{ .shift = true } },
                 .{ .jump_to_prompt = 1 },
             );
         }
@@ -503,9 +502,9 @@ pub const Config = struct {
                 // On macOS we default to super but everywhere else
                 // is alt.
                 const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                    .{ .super = .both }
+                    .{ .super = true }
                 else
-                    .{ .alt = .both };
+                    .{ .alt = true };
 
                 try result.keybind.set.put(
                     alloc,
@@ -526,97 +525,97 @@ pub const Config = struct {
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .q, .mods = .{ .super = .both } },
+                .{ .key = .q, .mods = .{ .super = true } },
                 .{ .quit = {} },
             );
 
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .k, .mods = .{ .super = .both } },
+                .{ .key = .k, .mods = .{ .super = true } },
                 .{ .clear_screen = {} },
             );
 
             // Semantic prompts
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .up, .mods = .{ .super = true, .shift = true } },
                 .{ .jump_to_prompt = -1 },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .down, .mods = .{ .super = true, .shift = true } },
                 .{ .jump_to_prompt = 1 },
             );
 
             // Mac windowing
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .n, .mods = .{ .super = .both } },
+                .{ .key = .n, .mods = .{ .super = true } },
                 .{ .new_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .super = .both } },
+                .{ .key = .w, .mods = .{ .super = true } },
                 .{ .close_surface = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .w, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .w, .mods = .{ .super = true, .shift = true } },
                 .{ .close_window = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .t, .mods = .{ .super = .both } },
+                .{ .key = .t, .mods = .{ .super = true } },
                 .{ .new_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
                 .{ .previous_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
                 .{ .next_tab = {} },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .super = .both } },
+                .{ .key = .d, .mods = .{ .super = true } },
                 .{ .new_split = .right },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .d, .mods = .{ .super = .both, .shift = .both } },
+                .{ .key = .d, .mods = .{ .super = true, .shift = true } },
                 .{ .new_split = .down },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = .both } },
+                .{ .key = .left_bracket, .mods = .{ .super = true } },
                 .{ .goto_split = .previous },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = .both } },
+                .{ .key = .right_bracket, .mods = .{ .super = true } },
                 .{ .goto_split = .next },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .up, .mods = .{ .super = .both, .alt = .both } },
+                .{ .key = .up, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .top },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .down, .mods = .{ .super = .both, .alt = .both } },
+                .{ .key = .down, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .bottom },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .left, .mods = .{ .super = .both, .alt = .both } },
+                .{ .key = .left, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .left },
             );
             try result.keybind.set.put(
                 alloc,
-                .{ .key = .right, .mods = .{ .super = .both, .alt = .both } },
+                .{ .key = .right, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .right },
             );
         }
@@ -631,9 +630,9 @@ pub const Config = struct {
     fn ctrlOrSuper(mods: inputpkg.Mods) inputpkg.Mods {
         var copy = mods;
         if (comptime builtin.target.isDarwin()) {
-            copy.super = .both;
+            copy.super = true;
         } else {
-            copy.ctrl = .both;
+            copy.ctrl = true;
         }
 
         return copy;
@@ -1207,18 +1206,7 @@ pub const Keybinds = struct {
         };
         errdefer if (copy) |v| alloc.free(v);
 
-        const binding = binding: {
-            var binding = try inputpkg.Binding.parse(value);
-
-            // Unless we're on native macOS, we don't allow directional
-            // keys, so we just remap them to "both".
-            if (comptime !(builtin.target.isDarwin() and apprt.runtime == apprt.embedded)) {
-                binding.trigger.mods = binding.trigger.mods.removeDirection();
-            }
-
-            break :binding binding;
-        };
-
+        const binding = try inputpkg.Binding.parse(value);
         switch (binding.action) {
             .unbind => self.set.remove(binding.trigger),
             else => try self.set.put(alloc, binding.trigger, binding.action),

commit 22b81731649bd1aca3e6fd33f215747d29ba1f72
Author: Kevin Hovsäter <kevin@hovsater.com>
Date:   Tue Aug 8 14:27:34 2023 +0200

    Fix typos

diff --git a/src/config.zig b/src/config.zig
index e812cbec..3ebd1c7b 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -29,7 +29,7 @@ pub const Config = struct {
     /// a single value (yet).
     ///
     /// The font feature will apply to all fonts rendered by Ghostty. A
-    /// future enhancement will allow targetting specific faces.
+    /// future enhancement will allow targeting specific faces.
     ///
     /// A valid value is the name of a feature. Prefix the feature with a
     /// "-" to explicitly disable it. Example: "ss20" or "-ss20".
@@ -120,7 +120,7 @@ pub const Config = struct {
     /// "ctrl+a", "ctrl+shift+b", "up". Some notes:
     ///
     ///   - modifiers cannot repeat, "ctrl+ctrl+a" is invalid.
-    ///   - modifers and key scan be in any order, "shift+a+ctrl" is weird,
+    ///   - modifiers and key scan be in any order, "shift+a+ctrl" is weird,
     ///     but valid.
     ///   - only a single key input is allowed, "ctrl+a+b" is invalid.
     ///

commit 7ac61469c9655f9307c983eaf086e50ef0b21301
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 8 16:43:27 2023 -0700

    bind sequences for PC style function keys from xterm
    
    Fixes #256
    
    This makes a whole lot more sequences work, such as `ctrl+left`,
    `ctrl+shift+f1`, etc. We were just missing these completely.
    
    This also found an issue where if you split a sequence across two
    `write()` syscalls, then `/bin/sh` (I didn't test other shells)
    treats it as two literals rather than parsing as a single sequence.
    Great.

diff --git a/src/config.zig b/src/config.zig
index 3ebd1c7b..c4388455 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -297,6 +297,9 @@ pub const Config = struct {
         errdefer result.deinit();
         const alloc = result._arena.?.allocator();
 
+        // Add the PC style function keys first so that we can override any later.
+        try result.defaultPCStyleFunctionKeys(alloc);
+
         // Add our default keybindings
         try result.keybind.set.put(
             alloc,
@@ -324,55 +327,6 @@ pub const Config = struct {
             );
         }
 
-        // Some control keys
-        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
-            .normal = "\x1b[A",
-            .application = "\x1bOA",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .cursor_key = .{
-            .normal = "\x1b[B",
-            .application = "\x1bOB",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .cursor_key = .{
-            .normal = "\x1b[C",
-            .application = "\x1bOC",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .cursor_key = .{
-            .normal = "\x1b[D",
-            .application = "\x1bOD",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .cursor_key = .{
-            .normal = "\x1b[H",
-            .application = "\x1bOH",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .cursor_key = .{
-            .normal = "\x1b[F",
-            .application = "\x1bOF",
-        } });
-
-        try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
-        try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
-
-        // From xterm:
-        // Note that F1 through F4 are prefixed with SS3 , while the other keys are
-        // prefixed with CSI .  Older versions of xterm implement different escape
-        // sequences for F1 through F4, with a CSI  prefix.  These can be activated
-        // by setting the oldXtermFKeys resource.  However, since they do not
-        // correspond to any hardware terminal, they have been deprecated.  (The
-        // DEC VT220 reserves F1 through F5 for local functions such as Setup).
-        try result.keybind.set.put(alloc, .{ .key = .f1 }, .{ .csi = "11~" });
-        try result.keybind.set.put(alloc, .{ .key = .f2 }, .{ .csi = "12~" });
-        try result.keybind.set.put(alloc, .{ .key = .f3 }, .{ .csi = "13~" });
-        try result.keybind.set.put(alloc, .{ .key = .f4 }, .{ .csi = "14~" });
-        try result.keybind.set.put(alloc, .{ .key = .f5 }, .{ .csi = "15~" });
-        try result.keybind.set.put(alloc, .{ .key = .f6 }, .{ .csi = "17~" });
-        try result.keybind.set.put(alloc, .{ .key = .f7 }, .{ .csi = "18~" });
-        try result.keybind.set.put(alloc, .{ .key = .f8 }, .{ .csi = "19~" });
-        try result.keybind.set.put(alloc, .{ .key = .f9 }, .{ .csi = "20~" });
-        try result.keybind.set.put(alloc, .{ .key = .f10 }, .{ .csi = "21~" });
-        try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
-        try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
-
         // Fonts
         try result.keybind.set.put(
             alloc,
@@ -623,6 +577,129 @@ pub const Config = struct {
         return result;
     }
 
+    fn defaultPCStyleFunctionKeys(result: *Config, alloc: Allocator) !void {
+        // Some control keys
+        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
+            .normal = "\x1b[A",
+            .application = "\x1bOA",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .cursor_key = .{
+            .normal = "\x1b[B",
+            .application = "\x1bOB",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .cursor_key = .{
+            .normal = "\x1b[C",
+            .application = "\x1bOC",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .cursor_key = .{
+            .normal = "\x1b[D",
+            .application = "\x1bOD",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .cursor_key = .{
+            .normal = "\x1b[H",
+            .application = "\x1bOH",
+        } });
+        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .cursor_key = .{
+            .normal = "\x1b[F",
+            .application = "\x1bOF",
+        } });
+
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .tab, .mods = .{ .shift = true } },
+            .{ .csi = "Z" },
+        );
+
+        try result.keybind.set.put(alloc, .{ .key = .insert }, .{ .csi = "2~" });
+        try result.keybind.set.put(alloc, .{ .key = .delete }, .{ .csi = "3~" });
+        try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
+        try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
+
+        // From xterm:
+        // Note that F1 through F4 are prefixed with SS3 , while the other keys are
+        // prefixed with CSI .  Older versions of xterm implement different escape
+        // sequences for F1 through F4, with a CSI  prefix.  These can be activated
+        // by setting the oldXtermFKeys resource.  However, since they do not
+        // correspond to any hardware terminal, they have been deprecated.  (The
+        // DEC VT220 reserves F1 through F5 for local functions such as Setup).
+        try result.keybind.set.put(alloc, .{ .key = .f1 }, .{ .csi = "11~" });
+        try result.keybind.set.put(alloc, .{ .key = .f2 }, .{ .csi = "12~" });
+        try result.keybind.set.put(alloc, .{ .key = .f3 }, .{ .csi = "13~" });
+        try result.keybind.set.put(alloc, .{ .key = .f4 }, .{ .csi = "14~" });
+        try result.keybind.set.put(alloc, .{ .key = .f5 }, .{ .csi = "15~" });
+        try result.keybind.set.put(alloc, .{ .key = .f6 }, .{ .csi = "17~" });
+        try result.keybind.set.put(alloc, .{ .key = .f7 }, .{ .csi = "18~" });
+        try result.keybind.set.put(alloc, .{ .key = .f8 }, .{ .csi = "19~" });
+        try result.keybind.set.put(alloc, .{ .key = .f9 }, .{ .csi = "20~" });
+        try result.keybind.set.put(alloc, .{ .key = .f10 }, .{ .csi = "21~" });
+        try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
+        try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
+
+        // From: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
+        //
+        // In normal mode, i.e., a Sun/PC keyboard when the sunKeyboard resource is
+        // false (and none of the other keyboard resources such as oldXtermFKeys
+        // resource is set), xterm encodes function key modifiers as parameters
+        // appended before the final character of the control sequence.  As a
+        // special case, the SS3  sent before F1 through F4 is altered to CSI  when
+        // sending a function key modifier as a parameter.
+        //
+        //      Code     Modifiers
+        //    ---------+---------------------------
+        //       2     | Shift
+        //       3     | Alt
+        //       4     | Shift + Alt
+        //       5     | Control
+        //       6     | Shift + Control
+        //       7     | Alt + Control
+        //       8     | Shift + Alt + Control
+        //       9     | Meta
+        //       10    | Meta + Shift
+        //       11    | Meta + Alt
+        //       12    | Meta + Alt + Shift
+        //       13    | Meta + Ctrl
+        //       14    | Meta + Ctrl + Shift
+        //       15    | Meta + Ctrl + Alt
+        //       16    | Meta + Ctrl + Alt + Shift
+        //    ---------+---------------------------
+        const modifiers: []const inputpkg.Mods = &.{
+            .{ .shift = true },
+            .{ .alt = true },
+            .{ .shift = true, .alt = true },
+            .{ .ctrl = true },
+            .{ .shift = true, .ctrl = true },
+            .{ .alt = true, .ctrl = true },
+            .{ .shift = true, .alt = true, .ctrl = true },
+            // todo: do we do meta or not?
+        };
+        inline for (modifiers, 2..) |mods, code| {
+            const m: []const u8 = &.{code + 48};
+            const set = &result.keybind.set;
+            try set.put(alloc, .{ .key = .end, .mods = mods }, .{ .csi = "1;" ++ m ++ "F" });
+            try set.put(alloc, .{ .key = .home, .mods = mods }, .{ .csi = "1;" ++ m ++ "H" });
+            try set.put(alloc, .{ .key = .insert, .mods = mods }, .{ .csi = "2;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .delete, .mods = mods }, .{ .csi = "3;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .page_up, .mods = mods }, .{ .csi = "5;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .page_down, .mods = mods }, .{ .csi = "6;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .up, .mods = mods }, .{ .csi = "1;" ++ m ++ "A" });
+            try set.put(alloc, .{ .key = .down, .mods = mods }, .{ .csi = "1;" ++ m ++ "B" });
+            try set.put(alloc, .{ .key = .right, .mods = mods }, .{ .csi = "1;" ++ m ++ "C" });
+            try set.put(alloc, .{ .key = .left, .mods = mods }, .{ .csi = "1;" ++ m ++ "D" });
+            try set.put(alloc, .{ .key = .f1, .mods = mods }, .{ .csi = "11;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f2, .mods = mods }, .{ .csi = "12;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f3, .mods = mods }, .{ .csi = "13;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f4, .mods = mods }, .{ .csi = "14;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f5, .mods = mods }, .{ .csi = "15;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f6, .mods = mods }, .{ .csi = "17;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f7, .mods = mods }, .{ .csi = "18;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f8, .mods = mods }, .{ .csi = "19;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f9, .mods = mods }, .{ .csi = "20;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f10, .mods = mods }, .{ .csi = "21;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f11, .mods = mods }, .{ .csi = "23;" ++ m ++ "~" });
+            try set.put(alloc, .{ .key = .f12, .mods = mods }, .{ .csi = "24;" ++ m ++ "~" });
+        }
+    }
+
     /// This sets either "ctrl" or "super" to true (but not both)
     /// on mods depending on if the build target is Mac or not. On
     /// Mac, we default to super (i.e. super+c for copy) and on

commit a8380e937dce4bfb5b920d917e773dca337c07b3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 07:24:11 2023 -0700

    scroll top, bot, page up, page down binding actions

diff --git a/src/config.zig b/src/config.zig
index c4388455..de195476 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -489,6 +489,28 @@ pub const Config = struct {
                 .{ .clear_screen = {} },
             );
 
+            // Viewport scrolling
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .home, .mods = .{ .super = true } },
+                .{ .scroll_to_top = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .end, .mods = .{ .super = true } },
+                .{ .scroll_to_bottom = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_up, .mods = .{ .super = true } },
+                .{ .scroll_page_up = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_down, .mods = .{ .super = true } },
+                .{ .scroll_page_down = {} },
+            );
+
             // Semantic prompts
             try result.keybind.set.put(
                 alloc,

commit 2fb8ad8196182d45caf65145d0c874f13e25be02
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 07:40:55 2023 -0700

    linux default keybindings for scroll top, bot, page up, down

diff --git a/src/config.zig b/src/config.zig
index de195476..b5afc068 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -435,15 +435,37 @@ pub const Config = struct {
                 .{ .goto_split = .right },
             );
 
-            // Semantic prompts
+            // Viewport scrolling
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .home, .mods = .{ .shift = true } },
+                .{ .scroll_to_top = {} },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .end, .mods = .{ .shift = true } },
+                .{ .scroll_to_bottom = {} },
+            );
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .page_up, .mods = .{ .shift = true } },
-                .{ .jump_to_prompt = -1 },
+                .{ .scroll_page_up = {} },
             );
             try result.keybind.set.put(
                 alloc,
                 .{ .key = .page_down, .mods = .{ .shift = true } },
+                .{ .scroll_page_down = {} },
+            );
+
+            // Semantic prompts
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_up, .mods = .{ .shift = true, .ctrl = true } },
+                .{ .jump_to_prompt = -1 },
+            );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .page_down, .mods = .{ .shift = true, .ctrl = true } },
                 .{ .jump_to_prompt = 1 },
             );
         }

commit 5d6086a1b11cfb66e99a7a6b3aa9ce2147c2cb9d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 14:44:24 2023 -0700

    "copy-on-select" configuation to disable

diff --git a/src/config.zig b/src/config.zig
index b5afc068..ae41072a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -186,6 +186,17 @@ pub const Config = struct {
     /// This does not affect data sent to the clipboard via "clipboard-write".
     @"clipboard-trim-trailing-spaces": bool = true,
 
+    /// Whether to automatically copy selected text to the clipboard. "true"
+    /// will only copy on systems that support a selection clipboard.
+    ///
+    /// The value "clipboard" will copy to the system clipboard, making this
+    /// work on macOS. Note that middle-click will also paste from the system
+    /// clipboard in this case.
+    ///
+    /// Note that if this is disabled, middle-click paste will also be
+    /// disabled.
+    @"copy-on-select": CopyOnSelect = .true,
+
     /// The time in milliseconds between clicks to consider a click a repeat
     /// (double, triple, etc.) or an entirely new single click. A value of
     /// zero will use a platform-specific default. The default on macOS
@@ -1375,6 +1386,20 @@ pub const Keybinds = struct {
     }
 };
 
+/// Options for copy on select behavior.
+pub const CopyOnSelect = enum {
+    /// Disables copy on select entirely.
+    false,
+
+    /// Copy on select is enabled, but goes to the selection clipboard.
+    /// This is not supported on platforms such as macOS. This is the default.
+    true,
+
+    /// Copy on select is enabled and goes to the system clipboard.
+    clipboard,
+};
+
+/// Shell integration values
 pub const ShellIntegration = enum {
     none,
     detect,

commit 5e2fa50d0b9fe4d8372d4068679860bbf64a993a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 12 16:30:52 2023 -0700

    macos-option-as-alt config, handle alt-prefix for charCallback

diff --git a/src/config.zig b/src/config.zig
index ae41072a..a5731289 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -238,6 +238,19 @@ pub const Config = struct {
     /// animations.
     @"macos-non-native-fullscreen": bool = false,
 
+    /// If true, the Option key will be treated as Alt. This makes terminal
+    /// sequences expecting Alt to work properly, but will break Unicode
+    /// input sequences on macOS if you use them via the alt key. You may
+    /// set this to false to restore the macOS alt-key unicode sequences
+    /// but this will break terminal sequences expecting Alt to work.
+    ///
+    /// Note that if an Option-sequence doesn't produce a printable
+    /// character, it will be treated as Alt regardless of this setting.
+    /// (i.e. alt+ctrl+a).
+    ///
+    /// This does not work with GLFW builds.
+    @"macos-option-as-alt": bool = false,
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 

commit 2ed6e6a40afea0df898b1125e8fcf7985282d8b0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 08:04:03 2023 -0700

    config: remove pc style function keys, handled separately now

diff --git a/src/config.zig b/src/config.zig
index a5731289..b1e84715 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -321,9 +321,6 @@ pub const Config = struct {
         errdefer result.deinit();
         const alloc = result._arena.?.allocator();
 
-        // Add the PC style function keys first so that we can override any later.
-        try result.defaultPCStyleFunctionKeys(alloc);
-
         // Add our default keybindings
         try result.keybind.set.put(
             alloc,
@@ -645,129 +642,6 @@ pub const Config = struct {
         return result;
     }
 
-    fn defaultPCStyleFunctionKeys(result: *Config, alloc: Allocator) !void {
-        // Some control keys
-        try result.keybind.set.put(alloc, .{ .key = .up }, .{ .cursor_key = .{
-            .normal = "\x1b[A",
-            .application = "\x1bOA",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .down }, .{ .cursor_key = .{
-            .normal = "\x1b[B",
-            .application = "\x1bOB",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .right }, .{ .cursor_key = .{
-            .normal = "\x1b[C",
-            .application = "\x1bOC",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .left }, .{ .cursor_key = .{
-            .normal = "\x1b[D",
-            .application = "\x1bOD",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .home }, .{ .cursor_key = .{
-            .normal = "\x1b[H",
-            .application = "\x1bOH",
-        } });
-        try result.keybind.set.put(alloc, .{ .key = .end }, .{ .cursor_key = .{
-            .normal = "\x1b[F",
-            .application = "\x1bOF",
-        } });
-
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .tab, .mods = .{ .shift = true } },
-            .{ .csi = "Z" },
-        );
-
-        try result.keybind.set.put(alloc, .{ .key = .insert }, .{ .csi = "2~" });
-        try result.keybind.set.put(alloc, .{ .key = .delete }, .{ .csi = "3~" });
-        try result.keybind.set.put(alloc, .{ .key = .page_up }, .{ .csi = "5~" });
-        try result.keybind.set.put(alloc, .{ .key = .page_down }, .{ .csi = "6~" });
-
-        // From xterm:
-        // Note that F1 through F4 are prefixed with SS3 , while the other keys are
-        // prefixed with CSI .  Older versions of xterm implement different escape
-        // sequences for F1 through F4, with a CSI  prefix.  These can be activated
-        // by setting the oldXtermFKeys resource.  However, since they do not
-        // correspond to any hardware terminal, they have been deprecated.  (The
-        // DEC VT220 reserves F1 through F5 for local functions such as Setup).
-        try result.keybind.set.put(alloc, .{ .key = .f1 }, .{ .csi = "11~" });
-        try result.keybind.set.put(alloc, .{ .key = .f2 }, .{ .csi = "12~" });
-        try result.keybind.set.put(alloc, .{ .key = .f3 }, .{ .csi = "13~" });
-        try result.keybind.set.put(alloc, .{ .key = .f4 }, .{ .csi = "14~" });
-        try result.keybind.set.put(alloc, .{ .key = .f5 }, .{ .csi = "15~" });
-        try result.keybind.set.put(alloc, .{ .key = .f6 }, .{ .csi = "17~" });
-        try result.keybind.set.put(alloc, .{ .key = .f7 }, .{ .csi = "18~" });
-        try result.keybind.set.put(alloc, .{ .key = .f8 }, .{ .csi = "19~" });
-        try result.keybind.set.put(alloc, .{ .key = .f9 }, .{ .csi = "20~" });
-        try result.keybind.set.put(alloc, .{ .key = .f10 }, .{ .csi = "21~" });
-        try result.keybind.set.put(alloc, .{ .key = .f11 }, .{ .csi = "23~" });
-        try result.keybind.set.put(alloc, .{ .key = .f12 }, .{ .csi = "24~" });
-
-        // From: https://invisible-island.net/xterm/ctlseqs/ctlseqs.html
-        //
-        // In normal mode, i.e., a Sun/PC keyboard when the sunKeyboard resource is
-        // false (and none of the other keyboard resources such as oldXtermFKeys
-        // resource is set), xterm encodes function key modifiers as parameters
-        // appended before the final character of the control sequence.  As a
-        // special case, the SS3  sent before F1 through F4 is altered to CSI  when
-        // sending a function key modifier as a parameter.
-        //
-        //      Code     Modifiers
-        //    ---------+---------------------------
-        //       2     | Shift
-        //       3     | Alt
-        //       4     | Shift + Alt
-        //       5     | Control
-        //       6     | Shift + Control
-        //       7     | Alt + Control
-        //       8     | Shift + Alt + Control
-        //       9     | Meta
-        //       10    | Meta + Shift
-        //       11    | Meta + Alt
-        //       12    | Meta + Alt + Shift
-        //       13    | Meta + Ctrl
-        //       14    | Meta + Ctrl + Shift
-        //       15    | Meta + Ctrl + Alt
-        //       16    | Meta + Ctrl + Alt + Shift
-        //    ---------+---------------------------
-        const modifiers: []const inputpkg.Mods = &.{
-            .{ .shift = true },
-            .{ .alt = true },
-            .{ .shift = true, .alt = true },
-            .{ .ctrl = true },
-            .{ .shift = true, .ctrl = true },
-            .{ .alt = true, .ctrl = true },
-            .{ .shift = true, .alt = true, .ctrl = true },
-            // todo: do we do meta or not?
-        };
-        inline for (modifiers, 2..) |mods, code| {
-            const m: []const u8 = &.{code + 48};
-            const set = &result.keybind.set;
-            try set.put(alloc, .{ .key = .end, .mods = mods }, .{ .csi = "1;" ++ m ++ "F" });
-            try set.put(alloc, .{ .key = .home, .mods = mods }, .{ .csi = "1;" ++ m ++ "H" });
-            try set.put(alloc, .{ .key = .insert, .mods = mods }, .{ .csi = "2;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .delete, .mods = mods }, .{ .csi = "3;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .page_up, .mods = mods }, .{ .csi = "5;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .page_down, .mods = mods }, .{ .csi = "6;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .up, .mods = mods }, .{ .csi = "1;" ++ m ++ "A" });
-            try set.put(alloc, .{ .key = .down, .mods = mods }, .{ .csi = "1;" ++ m ++ "B" });
-            try set.put(alloc, .{ .key = .right, .mods = mods }, .{ .csi = "1;" ++ m ++ "C" });
-            try set.put(alloc, .{ .key = .left, .mods = mods }, .{ .csi = "1;" ++ m ++ "D" });
-            try set.put(alloc, .{ .key = .f1, .mods = mods }, .{ .csi = "11;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f2, .mods = mods }, .{ .csi = "12;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f3, .mods = mods }, .{ .csi = "13;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f4, .mods = mods }, .{ .csi = "14;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f5, .mods = mods }, .{ .csi = "15;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f6, .mods = mods }, .{ .csi = "17;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f7, .mods = mods }, .{ .csi = "18;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f8, .mods = mods }, .{ .csi = "19;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f9, .mods = mods }, .{ .csi = "20;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f10, .mods = mods }, .{ .csi = "21;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f11, .mods = mods }, .{ .csi = "23;" ++ m ++ "~" });
-            try set.put(alloc, .{ .key = .f12, .mods = mods }, .{ .csi = "24;" ++ m ++ "~" });
-        }
-    }
-
     /// This sets either "ctrl" or "super" to true (but not both)
     /// on mods depending on if the build target is Mac or not. On
     /// Mac, we default to super (i.e. super+c for copy) and on

commit cbd6a325e95e8fe492d5a4ed054ab81fd03b3e48
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 14 12:50:21 2023 -0700

    config: macos-option-as-alt now accepts "left", "right"

diff --git a/src/config.zig b/src/config.zig
index b1e84715..773017a9 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -249,7 +249,7 @@ pub const Config = struct {
     /// (i.e. alt+ctrl+a).
     ///
     /// This does not work with GLFW builds.
-    @"macos-option-as-alt": bool = false,
+    @"macos-option-as-alt": OptionAsAlt = .false,
 
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
@@ -1036,6 +1036,14 @@ fn equal(comptime T: type, old: T, new: T) bool {
     }
 }
 
+/// Valid values for macos-option-as-alt.
+pub const OptionAsAlt = enum {
+    false,
+    true,
+    left,
+    right,
+};
+
 /// Color represents a color using RGB.
 pub const Color = struct {
     r: u8,

commit e92021e0c925e20bdfe3f94eeb19f0f0eb6c5f7d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 18 18:13:19 2023 -0700

    config: repeatablestring must copy values it parses into arena

diff --git a/src/config.zig b/src/config.zig
index 773017a9..a39e2981 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1176,7 +1176,8 @@ pub const RepeatableString = struct {
 
     pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {
         const value = input orelse return error.ValueRequired;
-        try self.list.append(alloc, value);
+        const copy = try alloc.dupe(u8, value);
+        try self.list.append(alloc, copy);
     }
 
     /// Deep copy of the struct. Required by Config.

commit 7ccf86b1758dc559b0a5074187a1f6813bf9c94c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 08:50:24 2023 -0700

    remove imgui and devmode
    
    imgui has been a source of compilation challenges (our fault not theirs)
    and devmode hasn't worked in awhile, so drop it.

diff --git a/src/config.zig b/src/config.zig
index a39e2981..b16ead7c 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -365,13 +365,6 @@ pub const Config = struct {
             .{ .reset_font_size = {} },
         );
 
-        // Dev Mode
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .down, .mods = .{ .shift = true, .super = true } },
-            .{ .toggle_dev_mode = {} },
-        );
-
         try result.keybind.set.put(
             alloc,
             .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = true }) },

commit 46ba3189f6ddac3f21282650f243c81f17c80265
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 23 16:58:16 2023 -0700

    config: image-storage-limit to set maximum image memory per terminal

diff --git a/src/config.zig b/src/config.zig
index b16ead7c..d76dba11 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -186,6 +186,15 @@ pub const Config = struct {
     /// This does not affect data sent to the clipboard via "clipboard-write".
     @"clipboard-trim-trailing-spaces": bool = true,
 
+    /// The total amount of bytes that can be used for image data (i.e.
+    /// the Kitty image protocol) per terminal scren. The maximum value
+    /// is 4,294,967,295 (4GB). The default is 320MB. If this is set to zero,
+    /// then all image protocols will be disabled.
+    ///
+    /// This value is separate for primary and alternate screens so the
+    /// effective limit per surface is double.
+    @"image-storage-limit": u32 = 320 * 1000 * 1000,
+
     /// Whether to automatically copy selected text to the clipboard. "true"
     /// will only copy on systems that support a selection clipboard.
     ///

commit 8b9a11db4b30a6b2bd6d6070552ed079acc3e452
Author: Kevin Hovsäter <kevin@hovsater.com>
Date:   Fri Aug 25 14:52:29 2023 +0200

    Implement cursor text in addition to color

diff --git a/src/config.zig b/src/config.zig
index d76dba11..b292a28b 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -71,6 +71,7 @@ pub const Config = struct {
 
     /// The color of the cursor. If this is not set, a default will be chosen.
     @"cursor-color": ?Color = null,
+    @"cursor-text": ?Color = null,
 
     /// The opacity level (opposite of transparency) of the background.
     /// A value of 1 is fully opaque and a value of 0 is fully transparent.

commit 14c9279c21d4945fcb5c74389ab48df1ab785e23
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 26 09:39:25 2023 -0700

    config: add doc comment for cursor-text

diff --git a/src/config.zig b/src/config.zig
index b292a28b..d91e9668 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -71,6 +71,9 @@ pub const Config = struct {
 
     /// The color of the cursor. If this is not set, a default will be chosen.
     @"cursor-color": ?Color = null,
+
+    /// The color of the text under the cursor. If this is not set, a default
+    /// will be chosen.
     @"cursor-text": ?Color = null,
 
     /// The opacity level (opposite of transparency) of the background.

commit 906852976ba101c214cccdbcf16a1ab5ce0a255d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 27 13:04:12 2023 -0700

    config: new "font-variation" set of configurations to set variable font

diff --git a/src/config.zig b/src/config.zig
index d91e9668..6f454412 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,6 +3,7 @@ const std = @import("std");
 const builtin = @import("builtin");
 const Allocator = std.mem.Allocator;
 const ArenaAllocator = std.heap.ArenaAllocator;
+const fontpkg = @import("font/main.zig");
 const inputpkg = @import("input.zig");
 const terminal = @import("terminal/main.zig");
 const internal_os = @import("os/main.zig");
@@ -43,6 +44,30 @@ pub const Config = struct {
         else => 12,
     },
 
+    /// A repeatable configuration to set one or more font variations values
+    /// for a variable font. A variable font is a single font, usually
+    /// with a filename ending in "-VF.ttf" or "-VF.otf" that contains
+    /// one or more configurable axes for things such as weight, slant,
+    /// etc. Not all fonts support variations; only fonts that explicitly
+    /// state they are variable fonts will work.
+    ///
+    /// The format of this is "id=value" where "id" is the axis identifier.
+    /// An axis identifier is always a 4 character string, such as "wght".
+    /// To get the list of supported axes, look at your font documentation
+    /// or use a font inspection tool.
+    ///
+    /// Invalid ids and values are usually ignored. For example, if a font
+    /// only supports weights from 100 to 700, setting "wght=800" will
+    /// do nothing (it will not be clamped to 700). You must consult your
+    /// font's documentation to see what values are supported.
+    ///
+    /// Common axes are: "wght" (weight), "slnt" (slant), "ital" (italic),
+    /// "opsz" (optical size), "wdth" (width), "GRAD" (gradient), etc.
+    @"font-variation": RepeatableFontVariation = .{},
+    @"font-variation-bold": RepeatableFontVariation = .{},
+    @"font-variation-italic": RepeatableFontVariation = .{},
+    @"font-variation-bold-italic": RepeatableFontVariation = .{},
+
     /// Draw fonts with a thicker stroke, if supported. This is only supported
     /// currently on macOS.
     @"font-thicken": bool = false,
@@ -1217,6 +1242,97 @@ pub const RepeatableString = struct {
     }
 };
 
+/// FontVariation is a repeatable configuration value that sets a single
+/// font variation value. Font variations are configurations for what
+/// are often called "variable fonts." The font files usually end in
+/// "-VF.ttf."
+///
+/// The value for this is in the format of `id=value` where `id` is the
+/// 4-character font variation axis identifier and `value` is the
+/// floating point value for that axis. For more details on font variations
+/// see the MDN font-variation-settings documentation since this copies that
+/// behavior almost exactly:
+///
+/// https://developer.mozilla.org/en-US/docs/Web/CSS/font-variation-settings
+pub const RepeatableFontVariation = struct {
+    const Self = @This();
+
+    // Allocator for the list is the arena for the parent config.
+    list: std.ArrayListUnmanaged(fontpkg.face.Variation) = .{},
+
+    pub fn parseCLI(self: *Self, alloc: Allocator, input_: ?[]const u8) !void {
+        const input = input_ orelse return error.ValueRequired;
+        const eql_idx = std.mem.indexOf(u8, input, "=") orelse return error.InvalidFormat;
+        const whitespace = " \t";
+        const key = std.mem.trim(u8, input[0..eql_idx], whitespace);
+        const value = std.mem.trim(u8, input[eql_idx + 1 ..], whitespace);
+        if (key.len != 4) return error.InvalidFormat;
+        try self.list.append(alloc, .{
+            .id = fontpkg.face.Variation.Id.init(@ptrCast(key.ptr)),
+            .value = std.fmt.parseFloat(f64, value) catch return error.InvalidFormat,
+        });
+    }
+
+    /// Deep copy of the struct. Required by Config.
+    pub fn clone(self: *const Self, alloc: Allocator) !Self {
+        return .{
+            .list = try self.list.clone(alloc),
+        };
+    }
+
+    /// Compare if two of our value are requal. Required by Config.
+    pub fn equal(self: Self, other: Self) bool {
+        const itemsA = self.list.items;
+        const itemsB = other.list.items;
+        if (itemsA.len != itemsB.len) return false;
+        for (itemsA, itemsB) |a, b| {
+            if (!std.meta.eql(a, b)) return false;
+        } else return true;
+    }
+
+    test "parseCLI" {
+        const testing = std.testing;
+        var arena = ArenaAllocator.init(testing.allocator);
+        defer arena.deinit();
+        const alloc = arena.allocator();
+
+        var list: Self = .{};
+        try list.parseCLI(alloc, "wght=200");
+        try list.parseCLI(alloc, "slnt=-15");
+
+        try testing.expectEqual(@as(usize, 2), list.list.items.len);
+        try testing.expectEqual(fontpkg.face.Variation{
+            .id = fontpkg.face.Variation.Id.init("wght"),
+            .value = 200,
+        }, list.list.items[0]);
+        try testing.expectEqual(fontpkg.face.Variation{
+            .id = fontpkg.face.Variation.Id.init("slnt"),
+            .value = -15,
+        }, list.list.items[1]);
+    }
+
+    test "parseCLI with whitespace" {
+        const testing = std.testing;
+        var arena = ArenaAllocator.init(testing.allocator);
+        defer arena.deinit();
+        const alloc = arena.allocator();
+
+        var list: Self = .{};
+        try list.parseCLI(alloc, "wght =200");
+        try list.parseCLI(alloc, "slnt= -15");
+
+        try testing.expectEqual(@as(usize, 2), list.list.items.len);
+        try testing.expectEqual(fontpkg.face.Variation{
+            .id = fontpkg.face.Variation.Id.init("wght"),
+            .value = 200,
+        }, list.list.items[0]);
+        try testing.expectEqual(fontpkg.face.Variation{
+            .id = fontpkg.face.Variation.Id.init("slnt"),
+            .value = -15,
+        }, list.list.items[1]);
+    }
+};
+
 /// Stores a set of keybinds.
 pub const Keybinds = struct {
     set: inputpkg.Binding.Set = .{},

commit fcf1537f82473abffbbd30733fe28eb8b4c85348
Author: SoraTenshi <dream@neoncity.dev>
Date:   Mon Aug 28 18:20:45 2023 +0200

    config: Add option for custom cursor style

diff --git a/src/config.zig b/src/config.zig
index 6f454412..0f8eb97d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -97,6 +97,9 @@ pub const Config = struct {
     /// The color of the cursor. If this is not set, a default will be chosen.
     @"cursor-color": ?Color = null,
 
+    /// The style of the cursor.
+    @"cursor-style": terminal.CursorStyle = .default,
+
     /// The color of the text under the cursor. If this is not set, a default
     /// will be chosen.
     @"cursor-text": ?Color = null,

commit ead70eadae293464f5d7f5270d266d07d4aa9a98
Author: SoraTenshi <dream@neoncity.dev>
Date:   Mon Aug 28 19:44:01 2023 +0200

    Add Caveat information for shell integration

diff --git a/src/config.zig b/src/config.zig
index 0f8eb97d..891595aa 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -98,6 +98,11 @@ pub const Config = struct {
     @"cursor-color": ?Color = null,
 
     /// The style of the cursor.
+    ///
+    /// Caveat: Shell integration currently defaults to always be a bar
+    /// In order to fix it, we probably would want to add something similar to Kitty's
+    /// shell integration options (no-cursor). For more information see:
+    /// https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.shell_integration
     @"cursor-style": terminal.CursorStyle = .default,
 
     /// The color of the text under the cursor. If this is not set, a default

commit ba883ce39ae11237acf34065cf20474f4428ca6a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 30 22:14:44 2023 -0700

    add ghostty_config_trigger C API to find a trigger for an action

diff --git a/src/config.zig b/src/config.zig
index 891595aa..fea08593 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1559,6 +1559,25 @@ pub const CAPI = struct {
             log.err("error finalizing config err={}", .{err});
         };
     }
+
+    export fn ghostty_config_trigger(
+        self: *Config,
+        str: [*]const u8,
+        len: usize,
+    ) inputpkg.Binding.Trigger {
+        return config_trigger_(self, str[0..len]) catch |err| err: {
+            log.err("error finding trigger err={}", .{err});
+            break :err .{};
+        };
+    }
+
+    fn config_trigger_(
+        self: *Config,
+        str: []const u8,
+    ) !inputpkg.Binding.Trigger {
+        const action = try inputpkg.Binding.Action.parse(str);
+        return self.keybind.set.getTrigger(action) orelse .{};
+    }
 };
 
 test {

commit 86122624e005f2798ced461970140578a21f3ade
Author: Will Pragnell <wpragnell@gmail.com>
Date:   Fri Sep 1 20:17:30 2023 -0700

    macos: add visible-menu non-native-fullscreen option

diff --git a/src/config.zig b/src/config.zig
index fea08593..bd826c5d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -278,11 +278,17 @@ pub const Config = struct {
     /// The default value is "detect".
     @"shell-integration": ShellIntegration = .detect,
 
-    /// If true, fullscreen mode on macOS will not use the native fullscreen,
-    /// but make the window fullscreen without animations and using a new space.
-    /// That's faster than the native fullscreen mode since it doesn't use
-    /// animations.
-    @"macos-non-native-fullscreen": bool = false,
+    /// If anything other than false, fullscreen mode on macOS will not use the
+    /// native fullscreen, but make the window fullscreen without animations and
+    /// using a new space. It's faster than the native fullscreen mode since it
+    /// doesn't use animations.
+    ///
+    /// Allowable values are:
+    ///
+    ///   * "visible-menu" - Use non-native macOS fullscreen, keep the menu bar visible
+    ///   * "true" - Use non-native macOS fullscreen, hide the menu bar
+    ///   * "false" - Use native macOS fullscreeen
+    @"macos-non-native-fullscreen": NonNativeFullscreen = .false,
 
     /// If true, the Option key will be treated as Alt. This makes terminal
     /// sequences expecting Alt to work properly, but will break Unicode
@@ -1075,6 +1081,15 @@ fn equal(comptime T: type, old: T, new: T) bool {
     }
 }
 
+/// Valid values for macos-non-native-fullscreen
+/// c_int because it needs to be extern compatible
+/// If this is changed, you must also update ghostty.h
+pub const NonNativeFullscreen = enum(c_int) {
+    false,
+    true,
+    @"visible-menu",
+};
+
 /// Valid values for macos-option-as-alt.
 pub const OptionAsAlt = enum {
     false,

commit 50a1a52ae350067568e2d6c080865d05d71152a8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 2 14:52:43 2023 -0700

    core: add zoom keybinding for splits

diff --git a/src/config.zig b/src/config.zig
index bd826c5d..c73b288c 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -682,6 +682,12 @@ pub const Config = struct {
                 .{ .key = .right, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .right },
             );
+
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .equal, .mods = .{ .super = true, .shift = true } },
+                .{ .zoom_split = {} },
+            );
         }
 
         return result;

commit 519a97b782e5a9b556661f220977d3bfb1b15cb9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 2 15:15:12 2023 -0700

    core: add unzoom_split binding

diff --git a/src/config.zig b/src/config.zig
index c73b288c..c99845ef 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -688,6 +688,11 @@ pub const Config = struct {
                 .{ .key = .equal, .mods = .{ .super = true, .shift = true } },
                 .{ .zoom_split = {} },
             );
+            try result.keybind.set.put(
+                alloc,
+                .{ .key = .minus, .mods = .{ .super = true, .shift = true } },
+                .{ .unzoom_split = {} },
+            );
         }
 
         return result;

commit 4570356e577995578a7120c01837c24d918cf96c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 2 16:03:51 2023 -0700

    turn zoom into a toggle rather than an explicit zoom/unzoom

diff --git a/src/config.zig b/src/config.zig
index c99845ef..7c111ca9 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -563,6 +563,13 @@ pub const Config = struct {
             .{ .toggle_fullscreen = {} },
         );
 
+        // Toggle zoom a split
+        try result.keybind.set.put(
+            alloc,
+            .{ .key = .enter, .mods = ctrlOrSuper(.{ .shift = true }) },
+            .{ .toggle_split_zoom = {} },
+        );
+
         // Mac-specific keyboard bindings.
         if (comptime builtin.target.isDarwin()) {
             try result.keybind.set.put(
@@ -682,17 +689,6 @@ pub const Config = struct {
                 .{ .key = .right, .mods = .{ .super = true, .alt = true } },
                 .{ .goto_split = .right },
             );
-
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .equal, .mods = .{ .super = true, .shift = true } },
-                .{ .zoom_split = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .minus, .mods = .{ .super = true, .shift = true } },
-                .{ .unzoom_split = {} },
-            );
         }
 
         return result;

commit 6faed268e00fc1efab1fcbde628509f0ec2a4fc1
Author: SoraTenshi <dream@neoncity.dev>
Date:   Sun Sep 3 14:20:18 2023 +0200

    config: clean up cursor style configuration

diff --git a/src/config.zig b/src/config.zig
index 7c111ca9..df3ed1d1 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -97,13 +97,19 @@ pub const Config = struct {
     /// The color of the cursor. If this is not set, a default will be chosen.
     @"cursor-color": ?Color = null,
 
-    /// The style of the cursor.
+    /// The style of the cursor. This sets the default style. A running
+    /// programn can still request an explicit cursor style using escape
+    /// sequences (such as CSI q). Shell configurations will often request
+    /// specific cursor styles.
     ///
     /// Caveat: Shell integration currently defaults to always be a bar
     /// In order to fix it, we probably would want to add something similar to Kitty's
     /// shell integration options (no-cursor). For more information see:
     /// https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.shell_integration
-    @"cursor-style": terminal.CursorStyle = .default,
+    @"cursor-style": CursorStyle = .bar,
+
+    /// Whether the cursor shall blink
+    @"cursor-style-blink": bool = true,
 
     /// The color of the text under the cursor. If this is not set, a default
     /// will be chosen.
@@ -1455,6 +1461,22 @@ pub const ShellIntegration = enum {
     zsh,
 };
 
+/// Available options for `cursor-style`. Blinking is configured with
+/// the `cursor-style-blink` option.
+pub const CursorStyle = enum {
+    bar,
+    block,
+    underline,
+
+    pub fn toTerminalCursorStyle(self: CursorStyle, blinks: bool) terminal.CursorStyle {
+        return switch (self) {
+            .bar => if (blinks) .blinking_bar else .steady_bar,
+            .block => if (blinks) .blinking_block else .steady_block,
+            .underline => if (blinks) .blinking_underline else .steady_underline,
+        };
+    }
+};
+
 // Wasm API.
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");

commit a1a48eb3f065c716fd2276ba387fef9f7bbecea8
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Sun Sep 3 21:27:21 2023 +0200

    gtk: allow hiding window decoration in configuration
    
    This is part of #319 by fixing it for GTK and introducing the
    configuration option.
    
    This adds `window-decoration = false` as a possible configuration
    option. If set to `false`, then no window decorations are used.

diff --git a/src/config.zig b/src/config.zig
index bd826c5d..f74aa0b4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -213,6 +213,11 @@ pub const Config = struct {
     /// specified in the configuration "font-size" will be used.
     @"window-inherit-font-size": bool = true,
 
+    /// If false, windows won't have native decorations, i.e. titlebar and
+    /// borders.
+    /// Currently only supported with GTK.
+    @"window-decoration": bool = true,
+
     /// Whether to allow programs running in the terminal to read/write to
     /// the system clipboard (OSC 52, for googling). The default is to
     /// disallow clipboard reading but allow writing.

commit 2c5271ca824f68ddf421e3a6d8f8843e60404977
Merge: 5221a2f7 a1a48eb3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 3 12:41:14 2023 -0700

    Merge pull request #397 from mitchellh/mrn/gtk-window-decoration
    
    gtk: allow hiding window decoration in configuration


commit cac5b00d94e53a78b6af05968d513e4914736544
Author: Thorsten Ball <mrnugget@gmail.com>
Date:   Tue Sep 5 13:59:07 2023 +0200

    gtk: add gtk-single-instance setting to allow disabling of it
    
    This is based on our conversation on Discord and adds a setting for GTK
    that allows disabling the GTK single-instance mode.
    
    If this is off, it's possible to start multiple applications from the
    same release binary.
    
    Tested like this:
    
    ```
    $ zig build -Dapp-runtime=gtk -Doptimize=ReleaseFast && ./zig-out/bin/ghostty --gtk-single-instance=false
    
    [... starts new application ...]
    ```
    
    and
    
    ```
    $ zig build -Dapp-runtime=gtk -Doptimize=ReleaseFast && ./zig-out/bin/ghostty --gtk-single-instance=true
    info: ghostty version=0.1.0-main+42a22893
    info: runtime=apprt.Runtime.gtk
    info: font_backend=font.main.Backend.fontconfig_freetype
    info: dependency harfbuzz=8.0.0
    info: dependency fontconfig=21400
    info: renderer=renderer.OpenGL
    info: libxev backend=main.Backend.io_uring
    info(os): LANG is not valid according to libc, will use en_US.UTF-8
    info: reading configuration file path=/home/mrnugget/.config/ghostty/config
    info(config): default shell source=env value=/usr/bin/zsh
    
    (process:49045): GLib-GIO-WARNING **: 13:55:56.116: Your application did not unregister from D-Bus before destruction. Consider using g_application_run().
    
    [exits]
    ```

diff --git a/src/config.zig b/src/config.zig
index 5e59bc42..9e582305 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -314,6 +314,15 @@ pub const Config = struct {
     /// This does not work with GLFW builds.
     @"macos-option-as-alt": OptionAsAlt = .false,
 
+    /// If true (default), then the Ghostty GTK application will run in
+    /// single-instance mode: each new `ghostty` process launched will result
+    /// in a new window, if there is already a running process.
+    ///
+    /// If false, each new ghostty process will launch a separate application.
+    ///
+    /// Debug builds of Ghostty have a separate single-instance ID.
+    @"gtk-single-instance": bool = true,
+
     /// This is set by the CLI parser for deinit.
     _arena: ?ArenaAllocator = null,
 

commit d9cfd00e9fc77d123fc20fa51fa9554af31c09d3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 9 20:17:55 2023 -0700

    Big Cursor State Refactor
    
    This makes a few major changes:
    
      - cursor style on terminal is single source of stylistic truth
      - cursor style is split between style and style request
      - cursor blinking is handled by the renderer thread
      - cursor style/visibility is no longer stored as persistent state on
        renderers
      - cursor style computation is extracted to be shared by all renderers
      - mode 12 "cursor_blinking" is now source of truth on whether blinking
        is enabled or not
      - CSI q and mode 12 are synced like xterm

diff --git a/src/config.zig b/src/config.zig
index 9e582305..cc90a3c2 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -106,7 +106,7 @@ pub const Config = struct {
     /// In order to fix it, we probably would want to add something similar to Kitty's
     /// shell integration options (no-cursor). For more information see:
     /// https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.shell_integration
-    @"cursor-style": CursorStyle = .bar,
+    @"cursor-style": terminal.Cursor.Style = .bar,
 
     /// Whether the cursor shall blink
     @"cursor-style-blink": bool = true,
@@ -1475,22 +1475,6 @@ pub const ShellIntegration = enum {
     zsh,
 };
 
-/// Available options for `cursor-style`. Blinking is configured with
-/// the `cursor-style-blink` option.
-pub const CursorStyle = enum {
-    bar,
-    block,
-    underline,
-
-    pub fn toTerminalCursorStyle(self: CursorStyle, blinks: bool) terminal.CursorStyle {
-        return switch (self) {
-            .bar => if (blinks) .blinking_bar else .steady_bar,
-            .block => if (blinks) .blinking_block else .steady_block,
-            .underline => if (blinks) .blinking_underline else .steady_underline,
-        };
-    }
-};
-
 // Wasm API.
 pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
     const wasm = @import("os/wasm.zig");

commit b14ba8c0227f48a63b4c8eef60d52264d3f26418
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 10 16:17:19 2023 -0700

    config: extract into dedicated dir, split into files

diff --git a/src/config.zig b/src/config.zig
index cc90a3c2..8d0dd2e4 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,1627 +1,16 @@
-const config = @This();
-const std = @import("std");
-const builtin = @import("builtin");
-const Allocator = std.mem.Allocator;
-const ArenaAllocator = std.heap.ArenaAllocator;
-const fontpkg = @import("font/main.zig");
-const inputpkg = @import("input.zig");
-const terminal = @import("terminal/main.zig");
-const internal_os = @import("os/main.zig");
-const cli_args = @import("cli_args.zig");
+pub const Config = @import("config/Config.zig");
+pub const Key = @import("config/key.zig").Key;
 
-const log = std.log.scoped(.config);
+// Field types
+pub const CopyOnSelect = Config.CopyOnSelect;
+pub const Keybinds = Config.Keybinds;
+pub const NonNativeFullscreen = Config.NonNativeFullscreen;
+pub const OptionAsAlt = Config.OptionAsAlt;
 
-/// Used on Unixes for some defaults.
-const c = @cImport({
-    @cInclude("unistd.h");
-});
-
-/// Config is the main config struct. These fields map directly to the
-/// CLI flag names hence we use a lot of `@""` syntax to support hyphens.
-pub const Config = struct {
-    /// The font families to use.
-    @"font-family": ?[:0]const u8 = null,
-    @"font-family-bold": ?[:0]const u8 = null,
-    @"font-family-italic": ?[:0]const u8 = null,
-    @"font-family-bold-italic": ?[:0]const u8 = null,
-
-    /// Apply a font feature. This can be repeated multiple times to enable
-    /// multiple font features. You can NOT set multiple font features with
-    /// a single value (yet).
-    ///
-    /// The font feature will apply to all fonts rendered by Ghostty. A
-    /// future enhancement will allow targeting specific faces.
-    ///
-    /// A valid value is the name of a feature. Prefix the feature with a
-    /// "-" to explicitly disable it. Example: "ss20" or "-ss20".
-    @"font-feature": RepeatableString = .{},
-
-    /// Font size in points
-    @"font-size": u8 = switch (builtin.os.tag) {
-        // On Mac we default a little bigger since this tends to look better.
-        // This is purely subjective but this is easy to modify.
-        .macos => 13,
-        else => 12,
-    },
-
-    /// A repeatable configuration to set one or more font variations values
-    /// for a variable font. A variable font is a single font, usually
-    /// with a filename ending in "-VF.ttf" or "-VF.otf" that contains
-    /// one or more configurable axes for things such as weight, slant,
-    /// etc. Not all fonts support variations; only fonts that explicitly
-    /// state they are variable fonts will work.
-    ///
-    /// The format of this is "id=value" where "id" is the axis identifier.
-    /// An axis identifier is always a 4 character string, such as "wght".
-    /// To get the list of supported axes, look at your font documentation
-    /// or use a font inspection tool.
-    ///
-    /// Invalid ids and values are usually ignored. For example, if a font
-    /// only supports weights from 100 to 700, setting "wght=800" will
-    /// do nothing (it will not be clamped to 700). You must consult your
-    /// font's documentation to see what values are supported.
-    ///
-    /// Common axes are: "wght" (weight), "slnt" (slant), "ital" (italic),
-    /// "opsz" (optical size), "wdth" (width), "GRAD" (gradient), etc.
-    @"font-variation": RepeatableFontVariation = .{},
-    @"font-variation-bold": RepeatableFontVariation = .{},
-    @"font-variation-italic": RepeatableFontVariation = .{},
-    @"font-variation-bold-italic": RepeatableFontVariation = .{},
-
-    /// Draw fonts with a thicker stroke, if supported. This is only supported
-    /// currently on macOS.
-    @"font-thicken": bool = false,
-
-    /// Background color for the window.
-    background: Color = .{ .r = 0x28, .g = 0x2C, .b = 0x34 },
-
-    /// Foreground color for the window.
-    foreground: Color = .{ .r = 0xFF, .g = 0xFF, .b = 0xFF },
-
-    /// The foreground and background color for selection. If this is not
-    /// set, then the selection color is just the inverted window background
-    /// and foreground (note: not to be confused with the cell bg/fg).
-    @"selection-foreground": ?Color = null,
-    @"selection-background": ?Color = null,
-
-    /// Color palette for the 256 color form that many terminal applications
-    /// use. The syntax of this configuration is "N=HEXCODE" where "n"
-    /// is 0 to 255 (for the 256 colors) and HEXCODE is a typical RGB
-    /// color code such as "#AABBCC". The 0 to 255 correspond to the
-    /// terminal color table.
-    ///
-    /// For definitions on all the codes:
-    /// https://www.ditig.com/256-colors-cheat-sheet
-    palette: Palette = .{},
-
-    /// The color of the cursor. If this is not set, a default will be chosen.
-    @"cursor-color": ?Color = null,
-
-    /// The style of the cursor. This sets the default style. A running
-    /// programn can still request an explicit cursor style using escape
-    /// sequences (such as CSI q). Shell configurations will often request
-    /// specific cursor styles.
-    ///
-    /// Caveat: Shell integration currently defaults to always be a bar
-    /// In order to fix it, we probably would want to add something similar to Kitty's
-    /// shell integration options (no-cursor). For more information see:
-    /// https://sw.kovidgoyal.net/kitty/conf/#opt-kitty.shell_integration
-    @"cursor-style": terminal.Cursor.Style = .bar,
-
-    /// Whether the cursor shall blink
-    @"cursor-style-blink": bool = true,
-
-    /// The color of the text under the cursor. If this is not set, a default
-    /// will be chosen.
-    @"cursor-text": ?Color = null,
-
-    /// The opacity level (opposite of transparency) of the background.
-    /// A value of 1 is fully opaque and a value of 0 is fully transparent.
-    /// A value less than 0 or greater than 1 will be clamped to the nearest
-    /// valid value.
-    ///
-    /// Changing this value at runtime (and reloading config) will only
-    /// affect new windows, tabs, and splits.
-    @"background-opacity": f64 = 1.0,
-
-    /// A positive value enables blurring of the background when
-    /// background-opacity is less than 1. The value is the blur radius to
-    /// apply. A value of 20 is reasonable for a good looking blur.
-    /// Higher values will cause strange rendering issues as well as
-    /// performance issues.
-    ///
-    /// This is only supported on macOS.
-    @"background-blur-radius": u8 = 0,
-
-    /// The command to run, usually a shell. If this is not an absolute path,
-    /// it'll be looked up in the PATH. If this is not set, a default will
-    /// be looked up from your system. The rules for the default lookup are:
-    ///
-    ///   - SHELL environment variable
-    ///   - passwd entry (user information)
-    ///
-    command: ?[]const u8 = null,
-
-    /// The directory to change to after starting the command.
-    ///
-    /// The default is "inherit" except in special scenarios listed next.
-    /// If ghostty can detect it is launched on macOS from launchd
-    /// (double-clicked), then it defaults to "home".
-    ///
-    /// The value of this must be an absolute value or one of the special
-    /// values below:
-    ///
-    ///   - "home" - The home directory of the executing user.
-    ///   - "inherit" - The working directory of the launching process.
-    ///
-    @"working-directory": ?[]const u8 = null,
-
-    /// Key bindings. The format is "trigger=action". Duplicate triggers
-    /// will overwrite previously set values.
-    ///
-    /// Trigger: "+"-separated list of keys and modifiers. Example:
-    /// "ctrl+a", "ctrl+shift+b", "up". Some notes:
-    ///
-    ///   - modifiers cannot repeat, "ctrl+ctrl+a" is invalid.
-    ///   - modifiers and key scan be in any order, "shift+a+ctrl" is weird,
-    ///     but valid.
-    ///   - only a single key input is allowed, "ctrl+a+b" is invalid.
-    ///
-    /// Action is the action to take when the trigger is satisfied. It takes
-    /// the format "action" or "action:param". The latter form is only valid
-    /// if the action requires a parameter.
-    ///
-    ///   - "ignore" - Do nothing, ignore the key input. This can be used to
-    ///     black hole certain inputs to have no effect.
-    ///   - "unbind" - Remove the binding. This makes it so the previous action
-    ///     is removed, and the key will be sent through to the child command
-    ///     if it is printable.
-    ///   - "csi:text" - Send a CSI sequence. i.e. "csi:A" sends "cursor up".
-    ///
-    /// Some notes for the action:
-    ///
-    ///   - The parameter is taken as-is after the ":". Double quotes or
-    ///     other mechanisms are included and NOT parsed. If you want to
-    ///     send a string value that includes spaces, wrap the entire
-    ///     trigger/action in double quotes. Example: --keybind="up=csi:A B"
-    ///
-    keybind: Keybinds = .{},
-
-    /// Window padding. This applies padding between the terminal cells and
-    /// the window border. The "x" option applies to the left and right
-    /// padding and the "y" option is top and bottom. The value is in points,
-    /// meaning that it will be scaled appropriately for screen DPI.
-    ///
-    /// If this value is set too large, the screen will render nothing, because
-    /// the grid will be completely squished by the padding. It is up to you
-    /// as the user to pick a reasonable value. If you pick an unreasonable
-    /// value, a warning will appear in the logs.
-    @"window-padding-x": u32 = 2,
-    @"window-padding-y": u32 = 2,
-
-    /// The viewport dimensions are usually not perfectly divisible by
-    /// the cell size. In this case, some extra padding on the end of a
-    /// column and the bottom of the final row may exist. If this is true,
-    /// then this extra padding is automatically balanced between all four
-    /// edges to minimize imbalance on one side. If this is false, the top
-    /// left grid cell will always hug the edge with zero padding other than
-    /// what may be specified with the other "window-padding" options.
-    ///
-    /// If other "window-padding" fields are set and this is true, this will
-    /// still apply. The other padding is applied first and may affect how
-    /// many grid cells actually exist, and this is applied last in order
-    /// to balance the padding given a certain viewport size and grid cell size.
-    @"window-padding-balance": bool = false,
-
-    /// If true, new windows and tabs will inherit the font size of the previously
-    /// focused window. If no window was previously focused, the default
-    /// font size will be used. If this is false, the default font size
-    /// specified in the configuration "font-size" will be used.
-    @"window-inherit-font-size": bool = true,
-
-    /// If false, windows won't have native decorations, i.e. titlebar and
-    /// borders.
-    /// Currently only supported with GTK.
-    @"window-decoration": bool = true,
-
-    /// Whether to allow programs running in the terminal to read/write to
-    /// the system clipboard (OSC 52, for googling). The default is to
-    /// disallow clipboard reading but allow writing.
-    @"clipboard-read": bool = false,
-    @"clipboard-write": bool = true,
-
-    /// Trims trailing whitespace on data that is copied to the clipboard.
-    /// This does not affect data sent to the clipboard via "clipboard-write".
-    @"clipboard-trim-trailing-spaces": bool = true,
-
-    /// The total amount of bytes that can be used for image data (i.e.
-    /// the Kitty image protocol) per terminal scren. The maximum value
-    /// is 4,294,967,295 (4GB). The default is 320MB. If this is set to zero,
-    /// then all image protocols will be disabled.
-    ///
-    /// This value is separate for primary and alternate screens so the
-    /// effective limit per surface is double.
-    @"image-storage-limit": u32 = 320 * 1000 * 1000,
-
-    /// Whether to automatically copy selected text to the clipboard. "true"
-    /// will only copy on systems that support a selection clipboard.
-    ///
-    /// The value "clipboard" will copy to the system clipboard, making this
-    /// work on macOS. Note that middle-click will also paste from the system
-    /// clipboard in this case.
-    ///
-    /// Note that if this is disabled, middle-click paste will also be
-    /// disabled.
-    @"copy-on-select": CopyOnSelect = .true,
-
-    /// The time in milliseconds between clicks to consider a click a repeat
-    /// (double, triple, etc.) or an entirely new single click. A value of
-    /// zero will use a platform-specific default. The default on macOS
-    /// is determined by the OS settings. On every other platform it is 500ms.
-    @"click-repeat-interval": u32 = 0,
-
-    /// Additional configuration files to read.
-    @"config-file": RepeatableString = .{},
-
-    /// Confirms that a surface should be closed before closing it. This defaults
-    /// to true. If set to false, surfaces will close without any confirmation.
-    @"confirm-close-surface": bool = true,
-
-    /// Whether to enable shell integration auto-injection or not. Shell
-    /// integration greatly enhances the terminal experience by enabling
-    /// a number of features:
-    ///
-    ///   * Working directory reporting so new tabs, splits inherit the
-    ///     previous terminal's working directory.
-    ///   * Prompt marking that enables the "scroll_to_prompt" keybinding.
-    ///   * If you're sitting at a prompt, closing a terminal will not ask
-    ///     for confirmation.
-    ///   * Resizing the window with a complex prompt usually paints much
-    ///     better.
-    ///
-    /// Allowable values are:
-    ///
-    ///   * "none" - Do not do any automatic injection. You can still manually
-    ///     configure your shell to enable the integration.
-    ///   * "detect" - Detect the shell based on the filename.
-    ///   * "fish", "zsh" - Use this specific shell injection scheme.
-    ///
-    /// The default value is "detect".
-    @"shell-integration": ShellIntegration = .detect,
-
-    /// If anything other than false, fullscreen mode on macOS will not use the
-    /// native fullscreen, but make the window fullscreen without animations and
-    /// using a new space. It's faster than the native fullscreen mode since it
-    /// doesn't use animations.
-    ///
-    /// Allowable values are:
-    ///
-    ///   * "visible-menu" - Use non-native macOS fullscreen, keep the menu bar visible
-    ///   * "true" - Use non-native macOS fullscreen, hide the menu bar
-    ///   * "false" - Use native macOS fullscreeen
-    @"macos-non-native-fullscreen": NonNativeFullscreen = .false,
-
-    /// If true, the Option key will be treated as Alt. This makes terminal
-    /// sequences expecting Alt to work properly, but will break Unicode
-    /// input sequences on macOS if you use them via the alt key. You may
-    /// set this to false to restore the macOS alt-key unicode sequences
-    /// but this will break terminal sequences expecting Alt to work.
-    ///
-    /// Note that if an Option-sequence doesn't produce a printable
-    /// character, it will be treated as Alt regardless of this setting.
-    /// (i.e. alt+ctrl+a).
-    ///
-    /// This does not work with GLFW builds.
-    @"macos-option-as-alt": OptionAsAlt = .false,
-
-    /// If true (default), then the Ghostty GTK application will run in
-    /// single-instance mode: each new `ghostty` process launched will result
-    /// in a new window, if there is already a running process.
-    ///
-    /// If false, each new ghostty process will launch a separate application.
-    ///
-    /// Debug builds of Ghostty have a separate single-instance ID.
-    @"gtk-single-instance": bool = true,
-
-    /// This is set by the CLI parser for deinit.
-    _arena: ?ArenaAllocator = null,
-
-    /// Key is an enum of all the available configuration keys. This is used
-    /// when paired with diff to determine what fields have changed in a config,
-    /// amongst other things.
-    pub const Key = key: {
-        const field_infos = std.meta.fields(Config);
-        var enumFields: [field_infos.len]std.builtin.Type.EnumField = undefined;
-        var i: usize = 0;
-        inline for (field_infos) |field| {
-            // Ignore fields starting with "_" since they're internal and
-            // not copied ever.
-            if (field.name[0] == '_') continue;
-
-            enumFields[i] = .{
-                .name = field.name,
-                .value = i,
-            };
-            i += 1;
-        }
-
-        var decls = [_]std.builtin.Type.Declaration{};
-        break :key @Type(.{
-            .Enum = .{
-                .tag_type = std.math.IntFittingRange(0, field_infos.len - 1),
-                .fields = enumFields[0..i],
-                .decls = &decls,
-                .is_exhaustive = true,
-            },
-        });
-    };
-
-    pub fn deinit(self: *Config) void {
-        if (self._arena) |arena| arena.deinit();
-        self.* = undefined;
-    }
-
-    /// Load the configuration according to the default rules:
-    ///
-    ///   1. Defaults
-    ///   2. XDG Config File
-    ///   3. CLI flags
-    ///   4. Recursively defined configuration files
-    ///
-    pub fn load(alloc_gpa: Allocator) !Config {
-        var result = try default(alloc_gpa);
-        errdefer result.deinit();
-
-        // If we have a configuration file in our home directory, parse that first.
-        try result.loadDefaultFiles(alloc_gpa);
-
-        // Parse the config from the CLI args
-        try result.loadCliArgs(alloc_gpa);
-
-        // Parse the config files that were added from our file and CLI args.
-        try result.loadRecursiveFiles(alloc_gpa);
-        try result.finalize();
-
-        return result;
-    }
-
-    pub fn default(alloc_gpa: Allocator) Allocator.Error!Config {
-        // Build up our basic config
-        var result: Config = .{
-            ._arena = ArenaAllocator.init(alloc_gpa),
-        };
-        errdefer result.deinit();
-        const alloc = result._arena.?.allocator();
-
-        // Add our default keybindings
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .space, .mods = .{ .super = true, .alt = true, .ctrl = true } },
-            .{ .reload_config = {} },
-        );
-
-        {
-            // On macOS we default to super but Linux ctrl+shift since
-            // ctrl+c is to kill the process.
-            const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                .{ .super = true }
-            else
-                .{ .ctrl = true, .shift = true };
-
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .c, .mods = mods },
-                .{ .copy_to_clipboard = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .v, .mods = mods },
-                .{ .paste_from_clipboard = {} },
-            );
-        }
-
-        // Fonts
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .equal, .mods = ctrlOrSuper(.{}) },
-            .{ .increase_font_size = 1 },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .minus, .mods = ctrlOrSuper(.{}) },
-            .{ .decrease_font_size = 1 },
-        );
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .zero, .mods = ctrlOrSuper(.{}) },
-            .{ .reset_font_size = {} },
-        );
-
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .j, .mods = ctrlOrSuper(.{ .shift = true }) },
-            .{ .write_scrollback_file = {} },
-        );
-
-        // Windowing
-        if (comptime !builtin.target.isDarwin()) {
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .n, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .new_window = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .w, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .close_surface = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .q, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .quit = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .f4, .mods = .{ .alt = true } },
-                .{ .close_window = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .t, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .new_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .previous_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .next_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .o, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .new_split = .right },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .e, .mods = .{ .ctrl = true, .shift = true } },
-                .{ .new_split = .down },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left_bracket, .mods = .{ .ctrl = true, .super = true } },
-                .{ .goto_split = .previous },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right_bracket, .mods = .{ .ctrl = true, .super = true } },
-                .{ .goto_split = .next },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .up, .mods = .{ .ctrl = true, .alt = true } },
-                .{ .goto_split = .top },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .down, .mods = .{ .ctrl = true, .alt = true } },
-                .{ .goto_split = .bottom },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left, .mods = .{ .ctrl = true, .alt = true } },
-                .{ .goto_split = .left },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right, .mods = .{ .ctrl = true, .alt = true } },
-                .{ .goto_split = .right },
-            );
-
-            // Viewport scrolling
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .home, .mods = .{ .shift = true } },
-                .{ .scroll_to_top = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .end, .mods = .{ .shift = true } },
-                .{ .scroll_to_bottom = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_up, .mods = .{ .shift = true } },
-                .{ .scroll_page_up = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_down, .mods = .{ .shift = true } },
-                .{ .scroll_page_down = {} },
-            );
-
-            // Semantic prompts
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_up, .mods = .{ .shift = true, .ctrl = true } },
-                .{ .jump_to_prompt = -1 },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_down, .mods = .{ .shift = true, .ctrl = true } },
-                .{ .jump_to_prompt = 1 },
-            );
-        }
-        {
-            // Cmd+N for goto tab N
-            const start = @intFromEnum(inputpkg.Key.one);
-            const end = @intFromEnum(inputpkg.Key.nine);
-            var i: usize = start;
-            while (i <= end) : (i += 1) {
-                // On macOS we default to super but everywhere else
-                // is alt.
-                const mods: inputpkg.Mods = if (builtin.target.isDarwin())
-                    .{ .super = true }
-                else
-                    .{ .alt = true };
-
-                try result.keybind.set.put(
-                    alloc,
-                    .{ .key = @enumFromInt(i), .mods = mods },
-                    .{ .goto_tab = (i - start) + 1 },
-                );
-            }
-        }
-
-        // Toggle fullscreen
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .enter, .mods = ctrlOrSuper(.{}) },
-            .{ .toggle_fullscreen = {} },
-        );
-
-        // Toggle zoom a split
-        try result.keybind.set.put(
-            alloc,
-            .{ .key = .enter, .mods = ctrlOrSuper(.{ .shift = true }) },
-            .{ .toggle_split_zoom = {} },
-        );
-
-        // Mac-specific keyboard bindings.
-        if (comptime builtin.target.isDarwin()) {
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .q, .mods = .{ .super = true } },
-                .{ .quit = {} },
-            );
-
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .k, .mods = .{ .super = true } },
-                .{ .clear_screen = {} },
-            );
-
-            // Viewport scrolling
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .home, .mods = .{ .super = true } },
-                .{ .scroll_to_top = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .end, .mods = .{ .super = true } },
-                .{ .scroll_to_bottom = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_up, .mods = .{ .super = true } },
-                .{ .scroll_page_up = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .page_down, .mods = .{ .super = true } },
-                .{ .scroll_page_down = {} },
-            );
-
-            // Semantic prompts
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .up, .mods = .{ .super = true, .shift = true } },
-                .{ .jump_to_prompt = -1 },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .down, .mods = .{ .super = true, .shift = true } },
-                .{ .jump_to_prompt = 1 },
-            );
-
-            // Mac windowing
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .n, .mods = .{ .super = true } },
-                .{ .new_window = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .w, .mods = .{ .super = true } },
-                .{ .close_surface = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .w, .mods = .{ .super = true, .shift = true } },
-                .{ .close_window = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .t, .mods = .{ .super = true } },
-                .{ .new_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = true, .shift = true } },
-                .{ .previous_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = true, .shift = true } },
-                .{ .next_tab = {} },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .d, .mods = .{ .super = true } },
-                .{ .new_split = .right },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .d, .mods = .{ .super = true, .shift = true } },
-                .{ .new_split = .down },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left_bracket, .mods = .{ .super = true } },
-                .{ .goto_split = .previous },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right_bracket, .mods = .{ .super = true } },
-                .{ .goto_split = .next },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .up, .mods = .{ .super = true, .alt = true } },
-                .{ .goto_split = .top },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .down, .mods = .{ .super = true, .alt = true } },
-                .{ .goto_split = .bottom },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .left, .mods = .{ .super = true, .alt = true } },
-                .{ .goto_split = .left },
-            );
-            try result.keybind.set.put(
-                alloc,
-                .{ .key = .right, .mods = .{ .super = true, .alt = true } },
-                .{ .goto_split = .right },
-            );
-        }
-
-        return result;
-    }
-
-    /// This sets either "ctrl" or "super" to true (but not both)
-    /// on mods depending on if the build target is Mac or not. On
-    /// Mac, we default to super (i.e. super+c for copy) and on
-    /// non-Mac we default to ctrl (i.e. ctrl+c for copy).
-    fn ctrlOrSuper(mods: inputpkg.Mods) inputpkg.Mods {
-        var copy = mods;
-        if (comptime builtin.target.isDarwin()) {
-            copy.super = true;
-        } else {
-            copy.ctrl = true;
-        }
-
-        return copy;
-    }
-
-    /// Load the configuration from the default file locations. Currently,
-    /// this loads from $XDG_CONFIG_HOME/ghostty/config.
-    pub fn loadDefaultFiles(self: *Config, alloc: Allocator) !void {
-        const home_config_path = try internal_os.xdg.config(alloc, .{ .subdir = "ghostty/config" });
-        defer alloc.free(home_config_path);
-
-        const cwd = std.fs.cwd();
-        if (cwd.openFile(home_config_path, .{})) |file| {
-            defer file.close();
-            std.log.info("reading configuration file path={s}", .{home_config_path});
-
-            var buf_reader = std.io.bufferedReader(file.reader());
-            var iter = cli_args.lineIterator(buf_reader.reader());
-            try cli_args.parse(Config, alloc, self, &iter);
-        } else |err| switch (err) {
-            error.FileNotFound => std.log.info(
-                "homedir config not found, not loading path={s}",
-                .{home_config_path},
-            ),
-
-            else => std.log.warn(
-                "error reading homedir config file, not loading err={} path={s}",
-                .{ err, home_config_path },
-            ),
-        }
-    }
-
-    /// Load and parse the CLI args.
-    pub fn loadCliArgs(self: *Config, alloc_gpa: Allocator) !void {
-        switch (builtin.os.tag) {
-            .windows => {},
-
-            // Fast-path if we are non-Windows and no args, do nothing.
-            else => if (std.os.argv.len <= 1) return,
-        }
-
-        // Parse the config from the CLI args
-        var iter = try std.process.argsWithAllocator(alloc_gpa);
-        defer iter.deinit();
-        try cli_args.parse(Config, alloc_gpa, self, &iter);
-    }
-
-    /// Load and parse the config files that were added in the "config-file" key.
-    pub fn loadRecursiveFiles(self: *Config, alloc: Allocator) !void {
-        // TODO(mitchellh): we should parse the files form the homedir first
-        // TODO(mitchellh): support nesting (config-file in a config file)
-        // TODO(mitchellh): detect cycles when nesting
-
-        if (self.@"config-file".list.items.len == 0) return;
-
-        const cwd = std.fs.cwd();
-        const len = self.@"config-file".list.items.len;
-        for (self.@"config-file".list.items) |path| {
-            var file = try cwd.openFile(path, .{});
-            defer file.close();
-
-            var buf_reader = std.io.bufferedReader(file.reader());
-            var iter = cli_args.lineIterator(buf_reader.reader());
-            try cli_args.parse(Config, alloc, self, &iter);
-
-            // We don't currently support adding more config files to load
-            // from within a loaded config file. This can be supported
-            // later.
-            if (self.@"config-file".list.items.len > len)
-                return error.ConfigFileInConfigFile;
-        }
-    }
-
-    pub fn finalize(self: *Config) !void {
-        // If we have a font-family set and don't set the others, default
-        // the others to the font family. This way, if someone does
-        // --font-family=foo, then we try to get the stylized versions of
-        // "foo" as well.
-        if (self.@"font-family") |family| {
-            const fields = &[_][]const u8{
-                "font-family-bold",
-                "font-family-italic",
-                "font-family-bold-italic",
-            };
-            inline for (fields) |field| {
-                if (@field(self, field) == null) {
-                    @field(self, field) = family;
-                }
-            }
-        }
-
-        // The default for the working directory depends on the system.
-        const wd = self.@"working-directory" orelse switch (builtin.os.tag) {
-            .macos => if (c.getppid() == 1) "home" else "inherit",
-            else => "inherit",
-        };
-
-        // If we are missing either a command or home directory, we need
-        // to look up defaults which is kind of expensive. We only do this
-        // on desktop.
-        const wd_home = std.mem.eql(u8, "home", wd);
-        if (comptime !builtin.target.isWasm()) {
-            if (self.command == null or wd_home) command: {
-                const alloc = self._arena.?.allocator();
-
-                // First look up the command using the SHELL env var if needed.
-                // We don't do this in flatpak because SHELL in Flatpak is always
-                // set to /bin/sh.
-                if (self.command) |cmd|
-                    log.info("shell src=config value={s}", .{cmd})
-                else {
-                    if (!internal_os.isFlatpak()) {
-                        if (std.process.getEnvVarOwned(alloc, "SHELL")) |value| {
-                            log.info("default shell source=env value={s}", .{value});
-                            self.command = value;
-
-                            // If we don't need the working directory, then we can exit now.
-                            if (!wd_home) break :command;
-                        } else |_| {}
-                    }
-                }
-
-                // We need the passwd entry for the remainder
-                const pw = try internal_os.passwd.get(alloc);
-                if (self.command == null) {
-                    if (pw.shell) |sh| {
-                        log.info("default shell src=passwd value={s}", .{sh});
-                        self.command = sh;
-                    }
-                }
-
-                if (wd_home) {
-                    if (pw.home) |home| {
-                        log.info("default working directory src=passwd value={s}", .{home});
-                        self.@"working-directory" = home;
-                    }
-                }
-
-                if (self.command == null) {
-                    log.warn("no default shell found, will default to using sh", .{});
-                }
-            }
-        }
-
-        // If we have the special value "inherit" then set it to null which
-        // does the same. In the future we should change to a tagged union.
-        if (std.mem.eql(u8, wd, "inherit")) self.@"working-directory" = null;
-
-        // Default our click interval
-        if (self.@"click-repeat-interval" == 0) {
-            self.@"click-repeat-interval" = internal_os.clickInterval() orelse 500;
-        }
-    }
-
-    /// Create a shallow copy of this config. This will share all the memory
-    /// allocated with the previous config but will have a new arena for
-    /// any changes or new allocations. The config should have `deinit`
-    /// called when it is complete.
-    ///
-    /// Beware: these shallow clones are not meant for a long lifetime,
-    /// they are just meant to exist temporarily for the duration of some
-    /// modifications. It is very important that the original config not
-    /// be deallocated while shallow clones exist.
-    pub fn shallowClone(self: *const Config, alloc_gpa: Allocator) Config {
-        var result = self.*;
-        result._arena = ArenaAllocator.init(alloc_gpa);
-        return result;
-    }
-
-    /// Create a copy of this configuration. This is useful as a starting
-    /// point for modifying a configuration since a config can NOT be
-    /// modified once it is in use by an app or surface.
-    pub fn clone(self: *const Config, alloc_gpa: Allocator) !Config {
-        // Start with an empty config with a new arena we're going
-        // to use for all our copies.
-        var result: Config = .{
-            ._arena = ArenaAllocator.init(alloc_gpa),
-        };
-        errdefer result.deinit();
-        const alloc = result._arena.?.allocator();
-
-        inline for (@typeInfo(Config).Struct.fields) |field| {
-            if (!@hasField(Key, field.name)) continue;
-            @field(result, field.name) = try cloneValue(
-                alloc,
-                field.type,
-                @field(self, field.name),
-            );
-        }
-
-        return result;
-    }
-
-    fn cloneValue(alloc: Allocator, comptime T: type, src: T) !T {
-        // Do known named types first
-        switch (T) {
-            []const u8 => return try alloc.dupe(u8, src),
-            [:0]const u8 => return try alloc.dupeZ(u8, src),
-
-            else => {},
-        }
-
-        // Back into types of types
-        switch (@typeInfo(T)) {
-            inline .Bool,
-            .Int,
-            .Float,
-            .Enum,
-            => return src,
-
-            .Optional => |info| return try cloneValue(
-                alloc,
-                info.child,
-                src orelse return null,
-            ),
-
-            .Struct => return try src.clone(alloc),
-
-            else => {
-                @compileLog(T);
-                @compileError("unsupported field type");
-            },
-        }
-    }
-
-    /// Returns an iterator that goes through each changed field from
-    /// old to new. The order of old or new do not matter.
-    pub fn changeIterator(old: *const Config, new: *const Config) ChangeIterator {
-        return .{
-            .old = old,
-            .new = new,
-        };
-    }
-
-    /// Returns true if the given key has changed from old to new. This
-    /// requires the key to be comptime known to make this more efficient.
-    pub fn changed(self: *const Config, new: *const Config, comptime key: Key) bool {
-        // Get the field at comptime
-        const field = comptime field: {
-            const fields = std.meta.fields(Config);
-            for (fields) |field| {
-                if (@field(Key, field.name) == key) {
-                    break :field field;
-                }
-            }
-
-            unreachable;
-        };
-
-        const old_value = @field(self, field.name);
-        const new_value = @field(new, field.name);
-        return !equal(field.type, old_value, new_value);
-    }
-
-    /// This yields a key for every changed field between old and new.
-    pub const ChangeIterator = struct {
-        old: *const Config,
-        new: *const Config,
-        i: usize = 0,
-
-        pub fn next(self: *ChangeIterator) ?Key {
-            const fields = comptime std.meta.fields(Key);
-            while (self.i < fields.len) {
-                switch (self.i) {
-                    inline 0...(fields.len - 1) => |i| {
-                        const field = fields[i];
-                        const key = @field(Key, field.name);
-                        self.i += 1;
-                        if (self.old.changed(self.new, key)) return key;
-                    },
-
-                    else => unreachable,
-                }
-            }
-
-            return null;
-        }
-    };
-
-    test "clone default" {
-        const testing = std.testing;
-        const alloc = testing.allocator;
-
-        var source = try Config.default(alloc);
-        defer source.deinit();
-        var dest = try source.clone(alloc);
-        defer dest.deinit();
-
-        // Should have no changes
-        var it = source.changeIterator(&dest);
-        try testing.expectEqual(@as(?Key, null), it.next());
-
-        // I want to do this but this doesn't work (the API doesn't work)
-        // try testing.expectEqualDeep(dest, source);
-    }
-
-    test "changed" {
-        const testing = std.testing;
-        const alloc = testing.allocator;
-
-        var source = try Config.default(alloc);
-        defer source.deinit();
-        var dest = try source.clone(alloc);
-        defer dest.deinit();
-        dest.@"font-family" = "something else";
-
-        try testing.expect(source.changed(&dest, .@"font-family"));
-        try testing.expect(!source.changed(&dest, .@"font-size"));
-    }
-};
-
-/// A config-specific helper to determine if two values of the same
-/// type are equal. This isn't the same as std.mem.eql or std.testing.equals
-/// because we expect structs to implement their own equality.
-///
-/// This also doesn't support ALL Zig types, because we only add to it
-/// as we need types for the config.
-fn equal(comptime T: type, old: T, new: T) bool {
-    // Do known named types first
-    switch (T) {
-        inline []const u8,
-        [:0]const u8,
-        => return std.mem.eql(u8, old, new),
-
-        else => {},
-    }
-
-    // Back into types of types
-    switch (@typeInfo(T)) {
-        .Void => return true,
-
-        inline .Bool,
-        .Int,
-        .Float,
-        .Enum,
-        => return old == new,
-
-        .Optional => |info| {
-            if (old == null and new == null) return true;
-            if (old == null or new == null) return false;
-            return equal(info.child, old.?, new.?);
-        },
-
-        .Struct => |info| {
-            if (@hasDecl(T, "equal")) return old.equal(new);
-
-            // If a struct doesn't declare an "equal" function, we fall back
-            // to a recursive field-by-field compare.
-            inline for (info.fields) |field_info| {
-                if (!equal(
-                    field_info.type,
-                    @field(old, field_info.name),
-                    @field(new, field_info.name),
-                )) return false;
-            }
-            return true;
-        },
-
-        .Union => |info| {
-            const tag_type = info.tag_type.?;
-            const old_tag = std.meta.activeTag(old);
-            const new_tag = std.meta.activeTag(new);
-            if (old_tag != new_tag) return false;
-
-            inline for (info.fields) |field_info| {
-                if (@field(tag_type, field_info.name) == old_tag) {
-                    return equal(
-                        field_info.type,
-                        @field(old, field_info.name),
-                        @field(new, field_info.name),
-                    );
-                }
-            }
-
-            unreachable;
-        },
-
-        else => {
-            @compileLog(T);
-            @compileError("unsupported field type");
-        },
-    }
-}
-
-/// Valid values for macos-non-native-fullscreen
-/// c_int because it needs to be extern compatible
-/// If this is changed, you must also update ghostty.h
-pub const NonNativeFullscreen = enum(c_int) {
-    false,
-    true,
-    @"visible-menu",
-};
-
-/// Valid values for macos-option-as-alt.
-pub const OptionAsAlt = enum {
-    false,
-    true,
-    left,
-    right,
-};
-
-/// Color represents a color using RGB.
-pub const Color = struct {
-    r: u8,
-    g: u8,
-    b: u8,
-
-    pub const Error = error{
-        InvalidFormat,
-    };
-
-    /// Convert this to the terminal RGB struct
-    pub fn toTerminalRGB(self: Color) terminal.color.RGB {
-        return .{ .r = self.r, .g = self.g, .b = self.b };
-    }
-
-    pub fn parseCLI(input: ?[]const u8) !Color {
-        return fromHex(input orelse return error.ValueRequired);
-    }
-
-    /// Deep copy of the struct. Required by Config.
-    pub fn clone(self: Color, _: Allocator) !Color {
-        return self;
-    }
-
-    /// Compare if two of our value are requal. Required by Config.
-    pub fn equal(self: Color, other: Color) bool {
-        return std.meta.eql(self, other);
-    }
-
-    /// fromHex parses a color from a hex value such as #RRGGBB. The "#"
-    /// is optional.
-    pub fn fromHex(input: []const u8) !Color {
-        // Trim the beginning '#' if it exists
-        const trimmed = if (input.len != 0 and input[0] == '#') input[1..] else input;
-
-        // We expect exactly 6 for RRGGBB
-        if (trimmed.len != 6) return Error.InvalidFormat;
-
-        // Parse the colors two at a time.
-        var result: Color = undefined;
-        comptime var i: usize = 0;
-        inline while (i < 6) : (i += 2) {
-            const v: u8 =
-                ((try std.fmt.charToDigit(trimmed[i], 16)) * 16) +
-                try std.fmt.charToDigit(trimmed[i + 1], 16);
-
-            @field(result, switch (i) {
-                0 => "r",
-                2 => "g",
-                4 => "b",
-                else => unreachable,
-            }) = v;
-        }
-
-        return result;
-    }
-
-    test "fromHex" {
-        const testing = std.testing;
-
-        try testing.expectEqual(Color{ .r = 0, .g = 0, .b = 0 }, try Color.fromHex("#000000"));
-        try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("#0A0B0C"));
-        try testing.expectEqual(Color{ .r = 10, .g = 11, .b = 12 }, try Color.fromHex("0A0B0C"));
-        try testing.expectEqual(Color{ .r = 255, .g = 255, .b = 255 }, try Color.fromHex("FFFFFF"));
-    }
-};
-
-/// Palette is the 256 color palette for 256-color mode. This is still
-/// used by many terminal applications.
-pub const Palette = struct {
-    const Self = @This();
-
-    /// The actual value that is updated as we parse.
-    value: terminal.color.Palette = terminal.color.default,
-
-    pub const Error = error{
-        InvalidFormat,
-    };
-
-    pub fn parseCLI(
-        self: *Self,
-        input: ?[]const u8,
-    ) !void {
-        const value = input orelse return error.ValueRequired;
-        const eqlIdx = std.mem.indexOf(u8, value, "=") orelse
-            return Error.InvalidFormat;
-
-        const key = try std.fmt.parseInt(u8, value[0..eqlIdx], 10);
-        const rgb = try Color.parseCLI(value[eqlIdx + 1 ..]);
-        self.value[key] = .{ .r = rgb.r, .g = rgb.g, .b = rgb.b };
-    }
-
-    /// Deep copy of the struct. Required by Config.
-    pub fn clone(self: Self, _: Allocator) !Self {
-        return self;
-    }
-
-    /// Compare if two of our value are requal. Required by Config.
-    pub fn equal(self: Self, other: Self) bool {
-        return std.meta.eql(self, other);
-    }
-
-    test "parseCLI" {
-        const testing = std.testing;
-
-        var p: Self = .{};
-        try p.parseCLI("0=#AABBCC");
-        try testing.expect(p.value[0].r == 0xAA);
-        try testing.expect(p.value[0].g == 0xBB);
-        try testing.expect(p.value[0].b == 0xCC);
-    }
-
-    test "parseCLI overflow" {
-        const testing = std.testing;
-
-        var p: Self = .{};
-        try testing.expectError(error.Overflow, p.parseCLI("256=#AABBCC"));
-    }
-};
-
-/// RepeatableString is a string value that can be repeated to accumulate
-/// a list of strings. This isn't called "StringList" because I find that
-/// sometimes leads to confusion that it _accepts_ a list such as
-/// comma-separated values.
-pub const RepeatableString = struct {
-    const Self = @This();
-
-    // Allocator for the list is the arena for the parent config.
-    list: std.ArrayListUnmanaged([]const u8) = .{},
-
-    pub fn parseCLI(self: *Self, alloc: Allocator, input: ?[]const u8) !void {
-        const value = input orelse return error.ValueRequired;
-        const copy = try alloc.dupe(u8, value);
-        try self.list.append(alloc, copy);
-    }
-
-    /// Deep copy of the struct. Required by Config.
-    pub fn clone(self: *const Self, alloc: Allocator) !Self {
-        return .{
-            .list = try self.list.clone(alloc),
-        };
-    }
-
-    /// Compare if two of our value are requal. Required by Config.
-    pub fn equal(self: Self, other: Self) bool {
-        const itemsA = self.list.items;
-        const itemsB = other.list.items;
-        if (itemsA.len != itemsB.len) return false;
-        for (itemsA, itemsB) |a, b| {
-            if (!std.mem.eql(u8, a, b)) return false;
-        } else return true;
-    }
-
-    test "parseCLI" {
-        const testing = std.testing;
-        var arena = ArenaAllocator.init(testing.allocator);
-        defer arena.deinit();
-        const alloc = arena.allocator();
-
-        var list: Self = .{};
-        try list.parseCLI(alloc, "A");
-        try list.parseCLI(alloc, "B");
-
-        try testing.expectEqual(@as(usize, 2), list.list.items.len);
-    }
-};
-
-/// FontVariation is a repeatable configuration value that sets a single
-/// font variation value. Font variations are configurations for what
-/// are often called "variable fonts." The font files usually end in
-/// "-VF.ttf."
-///
-/// The value for this is in the format of `id=value` where `id` is the
-/// 4-character font variation axis identifier and `value` is the
-/// floating point value for that axis. For more details on font variations
-/// see the MDN font-variation-settings documentation since this copies that
-/// behavior almost exactly:
-///
-/// https://developer.mozilla.org/en-US/docs/Web/CSS/font-variation-settings
-pub const RepeatableFontVariation = struct {
-    const Self = @This();
-
-    // Allocator for the list is the arena for the parent config.
-    list: std.ArrayListUnmanaged(fontpkg.face.Variation) = .{},
-
-    pub fn parseCLI(self: *Self, alloc: Allocator, input_: ?[]const u8) !void {
-        const input = input_ orelse return error.ValueRequired;
-        const eql_idx = std.mem.indexOf(u8, input, "=") orelse return error.InvalidFormat;
-        const whitespace = " \t";
-        const key = std.mem.trim(u8, input[0..eql_idx], whitespace);
-        const value = std.mem.trim(u8, input[eql_idx + 1 ..], whitespace);
-        if (key.len != 4) return error.InvalidFormat;
-        try self.list.append(alloc, .{
-            .id = fontpkg.face.Variation.Id.init(@ptrCast(key.ptr)),
-            .value = std.fmt.parseFloat(f64, value) catch return error.InvalidFormat,
-        });
-    }
-
-    /// Deep copy of the struct. Required by Config.
-    pub fn clone(self: *const Self, alloc: Allocator) !Self {
-        return .{
-            .list = try self.list.clone(alloc),
-        };
-    }
-
-    /// Compare if two of our value are requal. Required by Config.
-    pub fn equal(self: Self, other: Self) bool {
-        const itemsA = self.list.items;
-        const itemsB = other.list.items;
-        if (itemsA.len != itemsB.len) return false;
-        for (itemsA, itemsB) |a, b| {
-            if (!std.meta.eql(a, b)) return false;
-        } else return true;
-    }
-
-    test "parseCLI" {
-        const testing = std.testing;
-        var arena = ArenaAllocator.init(testing.allocator);
-        defer arena.deinit();
-        const alloc = arena.allocator();
-
-        var list: Self = .{};
-        try list.parseCLI(alloc, "wght=200");
-        try list.parseCLI(alloc, "slnt=-15");
-
-        try testing.expectEqual(@as(usize, 2), list.list.items.len);
-        try testing.expectEqual(fontpkg.face.Variation{
-            .id = fontpkg.face.Variation.Id.init("wght"),
-            .value = 200,
-        }, list.list.items[0]);
-        try testing.expectEqual(fontpkg.face.Variation{
-            .id = fontpkg.face.Variation.Id.init("slnt"),
-            .value = -15,
-        }, list.list.items[1]);
-    }
-
-    test "parseCLI with whitespace" {
-        const testing = std.testing;
-        var arena = ArenaAllocator.init(testing.allocator);
-        defer arena.deinit();
-        const alloc = arena.allocator();
-
-        var list: Self = .{};
-        try list.parseCLI(alloc, "wght =200");
-        try list.parseCLI(alloc, "slnt= -15");
-
-        try testing.expectEqual(@as(usize, 2), list.list.items.len);
-        try testing.expectEqual(fontpkg.face.Variation{
-            .id = fontpkg.face.Variation.Id.init("wght"),
-            .value = 200,
-        }, list.list.items[0]);
-        try testing.expectEqual(fontpkg.face.Variation{
-            .id = fontpkg.face.Variation.Id.init("slnt"),
-            .value = -15,
-        }, list.list.items[1]);
-    }
-};
-
-/// Stores a set of keybinds.
-pub const Keybinds = struct {
-    set: inputpkg.Binding.Set = .{},
-
-    pub fn parseCLI(self: *Keybinds, alloc: Allocator, input: ?[]const u8) !void {
-        var copy: ?[]u8 = null;
-        var value = value: {
-            const value = input orelse return error.ValueRequired;
-
-            // If we don't have a colon, use the value as-is, no copy
-            if (std.mem.indexOf(u8, value, ":") == null)
-                break :value value;
-
-            // If we have a colon, we copy the whole value for now. We could
-            // do this more efficiently later if we wanted to.
-            const buf = try alloc.alloc(u8, value.len);
-            copy = buf;
-
-            std.mem.copy(u8, buf, value);
-            break :value buf;
-        };
-        errdefer if (copy) |v| alloc.free(v);
-
-        const binding = try inputpkg.Binding.parse(value);
-        switch (binding.action) {
-            .unbind => self.set.remove(binding.trigger),
-            else => try self.set.put(alloc, binding.trigger, binding.action),
-        }
-    }
-
-    /// Deep copy of the struct. Required by Config.
-    pub fn clone(self: *const Keybinds, alloc: Allocator) !Keybinds {
-        return .{
-            .set = .{
-                .bindings = try self.set.bindings.clone(alloc),
-            },
-        };
-    }
-
-    /// Compare if two of our value are requal. Required by Config.
-    pub fn equal(self: Keybinds, other: Keybinds) bool {
-        const self_map = self.set.bindings;
-        const other_map = other.set.bindings;
-        if (self_map.count() != other_map.count()) return false;
-
-        var it = self_map.iterator();
-        while (it.next()) |self_entry| {
-            const other_entry = other_map.getEntry(self_entry.key_ptr.*) orelse
-                return false;
-            if (!config.equal(
-                inputpkg.Binding.Action,
-                self_entry.value_ptr.*,
-                other_entry.value_ptr.*,
-            )) return false;
-        }
-
-        return true;
-    }
-
-    test "parseCLI" {
-        const testing = std.testing;
-        var arena = ArenaAllocator.init(testing.allocator);
-        defer arena.deinit();
-        const alloc = arena.allocator();
-
-        var set: Keybinds = .{};
-        try set.parseCLI(alloc, "shift+a=copy_to_clipboard");
-        try set.parseCLI(alloc, "shift+a=csi:hello");
-    }
-};
-
-/// Options for copy on select behavior.
-pub const CopyOnSelect = enum {
-    /// Disables copy on select entirely.
-    false,
-
-    /// Copy on select is enabled, but goes to the selection clipboard.
-    /// This is not supported on platforms such as macOS. This is the default.
-    true,
-
-    /// Copy on select is enabled and goes to the system clipboard.
-    clipboard,
-};
-
-/// Shell integration values
-pub const ShellIntegration = enum {
-    none,
-    detect,
-    fish,
-    zsh,
-};
-
-// Wasm API.
-pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {
-    const wasm = @import("os/wasm.zig");
-    const alloc = wasm.alloc;
-
-    /// Create a new configuration filled with the initial default values.
-    export fn config_new() ?*Config {
-        const result = alloc.create(Config) catch |err| {
-            log.err("error allocating config err={}", .{err});
-            return null;
-        };
-
-        result.* = Config.default(alloc) catch |err| {
-            log.err("error creating config err={}", .{err});
-            return null;
-        };
-
-        return result;
-    }
-
-    export fn config_free(ptr: ?*Config) void {
-        if (ptr) |v| {
-            v.deinit();
-            alloc.destroy(v);
-        }
-    }
-
-    /// Load the configuration from a string in the same format as
-    /// the file-based syntax for the desktop version of the terminal.
-    export fn config_load_string(
-        self: *Config,
-        str: [*]const u8,
-        len: usize,
-    ) void {
-        config_load_string_(self, str[0..len]) catch |err| {
-            log.err("error loading config err={}", .{err});
-        };
-    }
-
-    fn config_load_string_(self: *Config, str: []const u8) !void {
-        var fbs = std.io.fixedBufferStream(str);
-        var iter = cli_args.lineIterator(fbs.reader());
-        try cli_args.parse(Config, alloc, self, &iter);
-    }
-
-    export fn config_finalize(self: *Config) void {
-        self.finalize() catch |err| {
-            log.err("error finalizing config err={}", .{err});
-        };
-    }
-};
-
-// C API.
-pub const CAPI = struct {
-    const global = &@import("main.zig").state;
-
-    /// Create a new configuration filled with the initial default values.
-    export fn ghostty_config_new() ?*Config {
-        const result = global.alloc.create(Config) catch |err| {
-            log.err("error allocating config err={}", .{err});
-            return null;
-        };
-
-        result.* = Config.default(global.alloc) catch |err| {
-            log.err("error creating config err={}", .{err});
-            return null;
-        };
-
-        return result;
-    }
-
-    export fn ghostty_config_free(ptr: ?*Config) void {
-        if (ptr) |v| {
-            v.deinit();
-            global.alloc.destroy(v);
-        }
-    }
-
-    /// Load the configuration from the CLI args.
-    export fn ghostty_config_load_cli_args(self: *Config) void {
-        self.loadCliArgs(global.alloc) catch |err| {
-            log.err("error loading config err={}", .{err});
-        };
-    }
-
-    /// Load the configuration from a string in the same format as
-    /// the file-based syntax for the desktop version of the terminal.
-    export fn ghostty_config_load_string(
-        self: *Config,
-        str: [*]const u8,
-        len: usize,
-    ) void {
-        config_load_string_(self, str[0..len]) catch |err| {
-            log.err("error loading config err={}", .{err});
-        };
-    }
-
-    fn config_load_string_(self: *Config, str: []const u8) !void {
-        var fbs = std.io.fixedBufferStream(str);
-        var iter = cli_args.lineIterator(fbs.reader());
-        try cli_args.parse(Config, global.alloc, self, &iter);
-    }
-
-    /// Load the configuration from the default file locations. This
-    /// is usually done first. The default file locations are locations
-    /// such as the home directory.
-    export fn ghostty_config_load_default_files(self: *Config) void {
-        self.loadDefaultFiles(global.alloc) catch |err| {
-            log.err("error loading config err={}", .{err});
-        };
-    }
-
-    /// Load the configuration from the user-specified configuration
-    /// file locations in the previously loaded configuration. This will
-    /// recursively continue to load up to a built-in limit.
-    export fn ghostty_config_load_recursive_files(self: *Config) void {
-        self.loadRecursiveFiles(global.alloc) catch |err| {
-            log.err("error loading config err={}", .{err});
-        };
-    }
-
-    export fn ghostty_config_finalize(self: *Config) void {
-        self.finalize() catch |err| {
-            log.err("error finalizing config err={}", .{err});
-        };
-    }
-
-    export fn ghostty_config_trigger(
-        self: *Config,
-        str: [*]const u8,
-        len: usize,
-    ) inputpkg.Binding.Trigger {
-        return config_trigger_(self, str[0..len]) catch |err| err: {
-            log.err("error finding trigger err={}", .{err});
-            break :err .{};
-        };
-    }
-
-    fn config_trigger_(
-        self: *Config,
-        str: []const u8,
-    ) !inputpkg.Binding.Trigger {
-        const action = try inputpkg.Binding.Action.parse(str);
-        return self.keybind.set.getTrigger(action) orelse .{};
-    }
-};
+// Alternate APIs
+pub const CAPI = @import("config/CAPI.zig");
+pub const Wasm = @import("config/Wasm.zig");
 
 test {
-    std.testing.refAllDecls(@This());
+    @import("std").testing.refAllDecls(@This());
 }

commit 2820db55bee278306f44158415c35896de2a8298
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 10 18:45:02 2023 -0700

    config: add C API ghostty_config_get to read configuration values

diff --git a/src/config.zig b/src/config.zig
index 8d0dd2e4..23687d14 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,5 +1,7 @@
+const builtin = @import("builtin");
+
+pub usingnamespace @import("config/key.zig");
 pub const Config = @import("config/Config.zig");
-pub const Key = @import("config/key.zig").Key;
 
 // Field types
 pub const CopyOnSelect = Config.CopyOnSelect;
@@ -9,8 +11,10 @@ pub const OptionAsAlt = Config.OptionAsAlt;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");
-pub const Wasm = @import("config/Wasm.zig");
+pub const Wasm = if (!builtin.target.isWasm()) struct {} else @import("config/Wasm.zig");
 
 test {
     @import("std").testing.refAllDecls(@This());
+
+    _ = @import("config/c_get.zig");
 }

commit 24af24a086cd91d3fc63ef9db501c9ad27a91ac3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Sep 10 22:01:17 2023 -0700

    terminal: CSI q requires a space intermediate

diff --git a/src/config.zig b/src/config.zig
index 23687d14..7115b04a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -15,6 +15,4 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else @import("config/Wa
 
 test {
     @import("std").testing.refAllDecls(@This());
-
-    _ = @import("config/c_get.zig");
 }

commit f7cc5ccdd61da6e82e79d0ac5e2c3814df0ed4a4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 11 21:38:52 2023 -0700

    config: add mouse-shift-capture configuration

diff --git a/src/config.zig b/src/config.zig
index 7115b04a..a6f4113f 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -6,6 +6,7 @@ pub const Config = @import("config/Config.zig");
 // Field types
 pub const CopyOnSelect = Config.CopyOnSelect;
 pub const Keybinds = Config.Keybinds;
+pub const MouseShiftCapture = Config.MouseShiftCapture;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;
 pub const OptionAsAlt = Config.OptionAsAlt;
 

commit 18c852d47c9cdc9cb0be0c3aadbe9ad7dbc5fb63
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 7 17:05:09 2023 -0800

    config: switch shell-integration-features

diff --git a/src/config.zig b/src/config.zig
index a6f4113f..4fda2e5b 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -9,6 +9,7 @@ pub const Keybinds = Config.Keybinds;
 pub const MouseShiftCapture = Config.MouseShiftCapture;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;
 pub const OptionAsAlt = Config.OptionAsAlt;
+pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");

commit 06cdbc1a96b4737a368d0328e1422f39a75c16e4
Author: Gregory Anders <greg@gpanders.com>
Date:   Sat Nov 11 17:25:48 2023 -0500

    config: export ClipboardAccess

diff --git a/src/config.zig b/src/config.zig
index 4fda2e5b..6834291e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -10,6 +10,7 @@ pub const MouseShiftCapture = Config.MouseShiftCapture;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;
 pub const OptionAsAlt = Config.OptionAsAlt;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
+pub const ClipboardAccess = Config.ClipboardAccess;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");

commit 0e2970bdebcec18ee9b7603823425dcebbe83da3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 24 10:26:55 2023 -0800

    config: add string parse, tests

diff --git a/src/config.zig b/src/config.zig
index 6834291e..e639f9b8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -2,6 +2,7 @@ const builtin = @import("builtin");
 
 pub usingnamespace @import("config/key.zig");
 pub const Config = @import("config/Config.zig");
+pub const string = @import("config/string.zig");
 
 // Field types
 pub const CopyOnSelect = Config.CopyOnSelect;

commit 5db002cb12e876381a653789bb27dfea128ca2f1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Nov 26 12:51:25 2023 -0800

    renderer/metal: underline urls

diff --git a/src/config.zig b/src/config.zig
index e639f9b8..cd449fb3 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,6 +3,7 @@ const builtin = @import("builtin");
 pub usingnamespace @import("config/key.zig");
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
+pub const url = @import("config/url.zig");
 
 // Field types
 pub const CopyOnSelect = Config.CopyOnSelect;

commit 7600c761ef5f8415f0c8097eda3abde678c65368
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 18 08:00:40 2023 -0800

    fix callback struct ordering, use internal_os.open

diff --git a/src/config.zig b/src/config.zig
index cd449fb3..57c4bcd8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -3,6 +3,7 @@ const builtin = @import("builtin");
 pub usingnamespace @import("config/key.zig");
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
+pub const edit = @import("config/edit.zig");
 pub const url = @import("config/url.zig");
 
 // Field types

commit eb46161b5e70b0cb110e30d786b68d5ce78783e7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 22 08:19:17 2023 -0800

    config: generate vim configs at comptime

diff --git a/src/config.zig b/src/config.zig
index 57c4bcd8..398f5fa9 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -21,4 +21,7 @@ pub const Wasm = if (!builtin.target.isWasm()) struct {} else @import("config/Wa
 
 test {
     @import("std").testing.refAllDecls(@This());
+
+    // Vim syntax file, not used at runtime but we want to keep it tested.
+    _ = @import("config/vim.zig");
 }

commit 96d33fef20dbe2742ae718beccd6cc42719016ba
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Jan 9 09:21:15 2024 -0800

    custom shader animation can be set to "always" to always remain active
    
    Fixes #1225
    
    The `custom-shader-animation` configuration can now be set to "always"
    which keeps animation active even if the terminal is unfocused.

diff --git a/src/config.zig b/src/config.zig
index 398f5fa9..78e03336 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -10,6 +10,7 @@ pub const url = @import("config/url.zig");
 pub const CopyOnSelect = Config.CopyOnSelect;
 pub const Keybinds = Config.Keybinds;
 pub const MouseShiftCapture = Config.MouseShiftCapture;
+pub const CustomShaderAnimation = Config.CustomShaderAnimation;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;
 pub const OptionAsAlt = Config.OptionAsAlt;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;

commit 33c4c328b661a1c0ef85d75be9fcb7af0455cec3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 20 12:43:15 2024 -0800

    config: file formatter

diff --git a/src/config.zig b/src/config.zig
index 78e03336..73c014a0 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,6 +1,7 @@
 const builtin = @import("builtin");
 
 pub usingnamespace @import("config/key.zig");
+pub usingnamespace @import("config/formatter.zig");
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");

commit b9efd837982d83961c2d7a30fa1d45364d5796c2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Apr 6 10:37:26 2024 -0700

    font: SharedGridSet uses DerivedConfig

diff --git a/src/config.zig b/src/config.zig
index 73c014a0..ba87fb6d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -8,14 +8,18 @@ pub const edit = @import("config/edit.zig");
 pub const url = @import("config/url.zig");
 
 // Field types
+pub const ClipboardAccess = Config.ClipboardAccess;
 pub const CopyOnSelect = Config.CopyOnSelect;
+pub const CustomShaderAnimation = Config.CustomShaderAnimation;
+pub const FontStyle = Config.FontStyle;
 pub const Keybinds = Config.Keybinds;
 pub const MouseShiftCapture = Config.MouseShiftCapture;
-pub const CustomShaderAnimation = Config.CustomShaderAnimation;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;
 pub const OptionAsAlt = Config.OptionAsAlt;
+pub const RepeatableCodepointMap = Config.RepeatableCodepointMap;
+pub const RepeatableFontVariation = Config.RepeatableFontVariation;
+pub const RepeatableString = Config.RepeatableString;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
-pub const ClipboardAccess = Config.ClipboardAccess;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");

commit 55e8c421b51a6c998ea97e3d7edf275cdc23024d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 3 16:14:14 2024 -0700

    config: add window-padding-color

diff --git a/src/config.zig b/src/config.zig
index ba87fb6d..34b209c0 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -20,6 +20,7 @@ pub const RepeatableCodepointMap = Config.RepeatableCodepointMap;
 pub const RepeatableFontVariation = Config.RepeatableFontVariation;
 pub const RepeatableString = Config.RepeatableString;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
+pub const WindowPaddingColor = Config.WindowPaddingColor;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");

commit 29de3e80f1617b58bd9a00b61a783230fbeced1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 16 10:49:37 2024 -0700

    config: yeet usingns

diff --git a/src/config.zig b/src/config.zig
index 34b209c0..3be645cc 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,12 +1,15 @@
 const builtin = @import("builtin");
 
-pub usingnamespace @import("config/key.zig");
-pub usingnamespace @import("config/formatter.zig");
+const formatter = @import("config/formatter.zig");
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");
 pub const url = @import("config/url.zig");
 
+pub const FileFormatter = formatter.FileFormatter;
+pub const entryFormatter = formatter.entryFormatter;
+pub const formatEntry = formatter.formatEntry;
+
 // Field types
 pub const ClipboardAccess = Config.ClipboardAccess;
 pub const CopyOnSelect = Config.CopyOnSelect;

commit bdcc21942d0ab073248fbdfda79fc22cf69e0e9f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 26 20:46:14 2024 -0700

    config: font-synthetic-style to enable/disable synthetic styles
    
    This adds a new configuration "font-synthetic-style" to enable or
    disable synthetic styles. This is different from "font-style-*" which
    specifies a named style or disables a style completely.
    
    Instead, "font-synthetic-style" will disable only the creation of
    synthetic styles in the case a font does not support a given style.
    This is useful for users who want to obviously know when a font doesn't
    support a given style or a user who wants to explicitly only use the
    styles that were designed by the font designer.
    
    The default value is to enable all synthetic styles.

diff --git a/src/config.zig b/src/config.zig
index 3be645cc..082c842c 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -14,6 +14,7 @@ pub const formatEntry = formatter.formatEntry;
 pub const ClipboardAccess = Config.ClipboardAccess;
 pub const CopyOnSelect = Config.CopyOnSelect;
 pub const CustomShaderAnimation = Config.CustomShaderAnimation;
+pub const FontSyntheticStyle = Config.FontSyntheticStyle;
 pub const FontStyle = Config.FontStyle;
 pub const Keybinds = Config.Keybinds;
 pub const MouseShiftCapture = Config.MouseShiftCapture;

commit 64abbd0ea6e15a7af2001bed3e0c7e097df2bb68
Author: Gregory Anders <greg@gpanders.com>
Date:   Tue Sep 17 19:42:42 2024 -0500

    config: move optional path parsing into RepeatablePath
    
    This commit refactors RepeatablePath to contain a list of tagged unions
    containing "optional" and "required" variants. Both variants have a null
    terminated file path as their payload, but the tag dictates whether the
    path must exist or not. This implemenation is used to force consumers to
    handle the optional vs. required distinction.
    
    This also moves the parsing of optional file paths into RepeatablePath's
    parseCLI function. This allows the code to be better unit tested. Since
    RepeatablePath no longer contains a simple list of RepeatableStrings,
    many other of its methods needed to be reimplemented as well.
    
    Because all of this functionality is built into the RepeatablePath type,
    other config options which also use RepeatablePath gain the ability to
    specify optional paths as well. Right now this is only the
    "custom-shaders" option. The code paths in the renderer to load shader
    files has been updated accordingly.
    
    In the original optional config file parsing, the leading ? character
    was removed when paths were expanded. Thus, when config files were
    actually loaded recursively, they appeared to be regular (required)
    config files and an error occurred if the file did not exist. **This
    issue was not found during testing because the presence of the
    "theme" option masks the error**. I am not sure why the presence of
    "theme" does this, I did not dig into that.
    
    Now because the "optional" or "required" state of each path is tracked
    in the enum tag the "optional" status of the path is preserved after
    being expanded to an absolute path.
    
    Finally, this commit fixes a bug where missing "config-file" files were
    not included in the +show-config command (i.e. if a user had
    `config-file = foo.conf` and `foo.conf` did not exist, then `ghostty
    +show-config` would only display `config-file =`). This bug applied to
    `custom-shaders` too, where it has also been fixed.

diff --git a/src/config.zig b/src/config.zig
index 082c842c..b9f214fc 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -23,6 +23,7 @@ pub const OptionAsAlt = Config.OptionAsAlt;
 pub const RepeatableCodepointMap = Config.RepeatableCodepointMap;
 pub const RepeatableFontVariation = Config.RepeatableFontVariation;
 pub const RepeatableString = Config.RepeatableString;
+pub const RepeatablePath = Config.RepeatablePath;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
 pub const WindowPaddingColor = Config.WindowPaddingColor;
 

commit c0b24ee60d65bee135dea7c99ad9446e9649a574
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 01:35:39 2024 +0100

    refactor: make freetype flags void for non-freetype backend
    
    This is an attempt to use `void` as type for Freetype Load Flags when
    backend does not use these flags.

diff --git a/src/config.zig b/src/config.zig
index b9f214fc..f2d4876a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,6 +1,8 @@
 const builtin = @import("builtin");
 
 const formatter = @import("config/formatter.zig");
+const font = @import("font/main.zig");
+const options = font.options;
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");
@@ -9,6 +11,18 @@ pub const url = @import("config/url.zig");
 pub const FileFormatter = formatter.FileFormatter;
 pub const entryFormatter = formatter.entryFormatter;
 pub const formatEntry = formatter.formatEntry;
+pub const FreetypeLoadFlags = switch (options.backend) {
+    .freetype,
+    .fontconfig_freetype,
+    .coretext_freetype,
+    => Config.FreetypeLoadFlags,
+
+    .coretext,
+    .coretext_harfbuzz,
+    .coretext_noshape,
+    .web_canvas,
+    => void,
+};
 
 // Field types
 pub const ClipboardAccess = Config.ClipboardAccess;

commit 83c4d0077b7a06d487057fca3bddcc8a3685ed03
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 11:55:29 2024 +0100

    refactor: define `FreetypeLoadFlags` struct and default in `font.face`

diff --git a/src/config.zig b/src/config.zig
index f2d4876a..08d93a6a 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -11,18 +11,6 @@ pub const url = @import("config/url.zig");
 pub const FileFormatter = formatter.FileFormatter;
 pub const entryFormatter = formatter.entryFormatter;
 pub const formatEntry = formatter.formatEntry;
-pub const FreetypeLoadFlags = switch (options.backend) {
-    .freetype,
-    .fontconfig_freetype,
-    .coretext_freetype,
-    => Config.FreetypeLoadFlags,
-
-    .coretext,
-    .coretext_harfbuzz,
-    .coretext_noshape,
-    .web_canvas,
-    => void,
-};
 
 // Field types
 pub const ClipboardAccess = Config.ClipboardAccess;

commit 4c086882758f0e855e2cfecddea44a105d575b84
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 12:50:51 2024 +0100

    refactor: remove unused imports

diff --git a/src/config.zig b/src/config.zig
index 08d93a6a..b9f214fc 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -1,8 +1,6 @@
 const builtin = @import("builtin");
 
 const formatter = @import("config/formatter.zig");
-const font = @import("font/main.zig");
-const options = font.options;
 pub const Config = @import("config/Config.zig");
 pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");

commit 3ee6577154b8b78e4113dbaec4c153ee1535e073
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 9 09:37:03 2024 -0800

    some tweaks

diff --git a/src/config.zig b/src/config.zig
index b9f214fc..5af7832d 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -16,6 +16,7 @@ pub const CopyOnSelect = Config.CopyOnSelect;
 pub const CustomShaderAnimation = Config.CustomShaderAnimation;
 pub const FontSyntheticStyle = Config.FontSyntheticStyle;
 pub const FontStyle = Config.FontStyle;
+pub const FreetypeLoadFlags = Config.FreetypeLoadFlags;
 pub const Keybinds = Config.Keybinds;
 pub const MouseShiftCapture = Config.MouseShiftCapture;
 pub const NonNativeFullscreen = Config.NonNativeFullscreen;

commit 712da4288f214ff1267d34927025e923a884439f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 18 14:37:28 2024 -0800

    config: add basic conditional system core logic (no syntax yet)
    
    Note: this doesn't have any syntax the user can use in a configuration
    yet. This just implements a core, tested system.

diff --git a/src/config.zig b/src/config.zig
index 5af7832d..02268d4e 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -2,6 +2,7 @@ const builtin = @import("builtin");
 
 const formatter = @import("config/formatter.zig");
 pub const Config = @import("config/Config.zig");
+pub const conditional = @import("config/conditional.zig");
 pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");
 pub const url = @import("config/url.zig");

commit b7f1eaa14568bab988ea135dec98dc005b88ddbf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 19 15:35:42 2024 -0800

    apprt: action to change conditional state, implement for embedded

diff --git a/src/config.zig b/src/config.zig
index 02268d4e..b7e818f8 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -7,6 +7,7 @@ pub const string = @import("config/string.zig");
 pub const edit = @import("config/edit.zig");
 pub const url = @import("config/url.zig");
 
+pub const ConditionalState = conditional.State;
 pub const FileFormatter = formatter.FileFormatter;
 pub const entryFormatter = formatter.entryFormatter;
 pub const formatEntry = formatter.formatEntry;

commit 85fc49b22c2ff04811a6f49088ad755ea4289af3
Author: Mohammadi, Erfan <emohamadi8181@gmail.com>
Date:   Sat Dec 28 14:31:29 2024 +0330

    confirm-close-surface option can be set to always to always require confirmation
    Fixes #3648
    The confirm-close-surface configuration can now be set to always
    ensuring a confirmation dialog is shown before closing a surface, even
    if shell integration indicates no running processes.

diff --git a/src/config.zig b/src/config.zig
index b7e818f8..75dbaae0 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -14,6 +14,7 @@ pub const formatEntry = formatter.formatEntry;
 
 // Field types
 pub const ClipboardAccess = Config.ClipboardAccess;
+pub const ConfirmCloseSurface = Config.ConfirmCloseSurface;
 pub const CopyOnSelect = Config.CopyOnSelect;
 pub const CustomShaderAnimation = Config.CustomShaderAnimation;
 pub const FontSyntheticStyle = Config.FontSyntheticStyle;

commit c7971b562e03d53ba2ce7ed9f835b8fd4c46c2bc
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Wed Jan 22 16:41:41 2025 -0600

    core: add `env` config option
    
    Fixes #5257
    
    Specify environment variables to pass to commands launched in a terminal
    surface. The format is `env=KEY=VALUE`.
    
    `env = foo=bar`
    `env = bar=baz`
    
    Setting `env` to an empty string will reset the entire map to default
    (empty).
    
    `env =`
    
    Setting a key to an empty string will remove that particular key and
    corresponding value from the map.
    
    `env = foo=bar`
    `env = foo=`
    
    will result in `foo` not being passed to the launched commands.
    Setting a key multiple times will overwrite previous entries.
    
    `env = foo=bar`
    `env = foo=baz`
    
    will result in `foo=baz` being passed to the launched commands.
    
    These environment variables _will not_ be passed to commands run by Ghostty
    for other purposes, like `open` or `xdg-open` used to open URLs in your
    browser.

diff --git a/src/config.zig b/src/config.zig
index 75dbaae0..a8ffe2ec 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -27,6 +27,7 @@ pub const OptionAsAlt = Config.OptionAsAlt;
 pub const RepeatableCodepointMap = Config.RepeatableCodepointMap;
 pub const RepeatableFontVariation = Config.RepeatableFontVariation;
 pub const RepeatableString = Config.RepeatableString;
+pub const RepeatableStringMap = @import("config/RepeatableStringMap.zig");
 pub const RepeatablePath = Config.RepeatablePath;
 pub const ShellIntegrationFeatures = Config.ShellIntegrationFeatures;
 pub const WindowPaddingColor = Config.WindowPaddingColor;

commit 43467690f310e79629c43926cb13a3fb51b50394
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 12 10:04:13 2025 -0700

    test

diff --git a/src/config.zig b/src/config.zig
index a8ffe2ec..a06e1987 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -34,7 +34,7 @@ pub const WindowPaddingColor = Config.WindowPaddingColor;
 
 // Alternate APIs
 pub const CAPI = @import("config/CAPI.zig");
-pub const Wasm = if (!builtin.target.isWasm()) struct {} else @import("config/Wasm.zig");
+pub const Wasm = if (!builtin.target.cpu.arch.isWasm()) struct {} else @import("config/Wasm.zig");
 
 test {
     @import("std").testing.refAllDecls(@This());

commit 722d41a359d71f251efab9135d1bef5837512352
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Apr 5 11:45:40 2025 -0400

    config: allow commands to specify whether they shell expand or not
    
    This introduces a syntax for `command` and `initial-command` that allows
    the user to specify whether it should be run via `/bin/sh -c` or not.
    The syntax is a prefix `direct:` or `shell:` prior to the command,
    with no prefix implying a default behavior as documented.
    
    Previously, we unconditionally ran commands via `/bin/sh -c`, primarily
    to avoid having to do any shell expansion ourselves. We also leaned on
    it as a crutch for PATH-expansion but this is an easy problem compared
    to shell expansion.
    
    For the principle of least surprise, this worked well for configurations
    specified via the config file, and is still the default. However, these
    configurations are also set via the `-e` special flag to the CLI, and it
    is very much not the principle of least surprise to have the command run via
    `/bin/sh -c` in that scenario since a shell has already expanded all the
    arguments and given them to us in a nice separated format. But we had no
    way to toggle this behavior.
    
    This commit introduces the ability to do this, and changes the defaults
    so that `-e` doesn't shell expand. Further, we also do PATH lookups
    ourselves for the non-shell expanded case because thats easy (using
    execvpe style extensions but implemented as part of the Zig stdlib). We don't
    do path expansion (e.g. `~/`) because thats a shell expansion.
    
    So to be clear, there are no two polar opposite behavioes here with
    clear semantics:
    
      1. Direct commands are passed to `execvpe` directly, space separated.
         This will not handle quoted strings, environment variables, path
         expansion (e.g. `~/`), command expansion (e.g. `$()`), etc.
    
      2. Shell commands are passed to `/bin/sh -c` and will be shell expanded
         as per the shell's rules. This will handle everything that `sh`
         supports.
    
    In doing this work, I also stumbled upon a variety of smaller
    improvements that could be made:
    
      - A number of allocations have been removed from the startup path that
        only existed to add a null terminator to various strings. We now
        have null terminators from the beginning since we are almost always
        on a system that's going to need it anyways.
    
      - For bash shell integration, we no longer wrap the new bash command
        in a shell since we've formed a full parsed command line.
    
      - The process of creating the command to execute by termio is now unit
        tested, so we can test the various complex cases particularly on
        macOS of wrapping commands in the login command.
    
      - `xdg-terminal-exec` on Linux uses the `direct:` method by default
        since it is also assumed to be executed via a shell environment.

diff --git a/src/config.zig b/src/config.zig
index a06e1987..fb7359b3 100644
--- a/src/config.zig
+++ b/src/config.zig
@@ -14,6 +14,7 @@ pub const formatEntry = formatter.formatEntry;
 
 // Field types
 pub const ClipboardAccess = Config.ClipboardAccess;
+pub const Command = Config.Command;
 pub const ConfirmCloseSurface = Config.ConfirmCloseSurface;
 pub const CopyOnSelect = Config.CopyOnSelect;
 pub const CustomShaderAnimation = Config.CustomShaderAnimation;

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    