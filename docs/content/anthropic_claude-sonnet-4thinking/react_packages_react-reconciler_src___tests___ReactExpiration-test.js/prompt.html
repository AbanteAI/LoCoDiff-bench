<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/__tests__/ReactExpiration-test.js - Sonnet 4 Thinking</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/__tests__/ReactExpiration-test.js</h1>
        <h2>Model: Sonnet 4 Thinking</h2>
        <p><a href="../../../cases/anthropic_claude-sonnet-4thinking/react_packages_react-reconciler_src___tests___ReactExpiration-test.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/__tests__/ReactExpiration-test.js

commit d9c1dbd61772f8f8ab0cdf389e70463d704c480b
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Oct 19 00:22:21 2017 +0100

    Use Yarn Workspaces (#11252)
    
    * Enable Yarn workspaces for packages/*
    
    * Move src/isomorphic/* into packages/react/src/*
    
    * Create index.js stubs for all packages in packages/*
    
    This makes the test pass again, but breaks the build because npm/ folders aren't used yet.
    I'm not sure if we'll keep this structure--I'll just keep working and fix the build after it settles down.
    
    * Put FB entry point for react-dom into packages/*
    
    * Move src/renderers/testing/* into packages/react-test-renderer/src/*
    
    Note that this is currently broken because Jest ignores node_modules,
    and so Yarn linking makes Jest skip React source when transforming.
    
    * Remove src/node_modules
    
    It is now unnecessary. Some tests fail though.
    
    * Add a hacky workaround for Jest/Workspaces issue
    
    Jest sees node_modules and thinks it's third party code.
    
    This is a hacky way to teach Jest to still transform anything in node_modules/react*
    if it resolves outside of node_modules (such as to our packages/*) folder.
    
    I'm not very happy with this and we should revisit.
    
    * Add a fake react-native package
    
    * Move src/renderers/art/* into packages/react-art/src/*
    
    * Move src/renderers/noop/* into packages/react-noop-renderer/src/*
    
    * Move src/renderers/dom/* into packages/react-dom/src/*
    
    * Move src/renderers/shared/fiber/* into packages/react-reconciler/src/*
    
    * Move DOM/reconciler tests I previously forgot to move
    
    * Move src/renderers/native-*/* into packages/react-native-*/src/*
    
    * Move shared code into packages/shared
    
    It's not super clear how to organize this properly yet.
    
    * Add back files that somehow got lost
    
    * Fix the build
    
    * Prettier
    
    * Add missing license headers
    
    * Fix an issue that caused mocks to get included into build
    
    * Update other references to src/
    
    * Re-run Prettier
    
    * Fix lint
    
    * Fix weird Flow violation
    
    I didn't change this file but Flow started complaining.
    Caleb said this annotation was unnecessarily using $Abstract though so I removed it.
    
    * Update sizes
    
    * Fix stats script
    
    * Fix packaging fixtures
    
    Use file: instead of NODE_PATH since NODE_PATH.
    NODE_PATH trick only worked because we had no react/react-dom in root node_modules, but now we do.
    
    file: dependency only works as I expect in Yarn, so I moved the packaging fixtures to use Yarn and committed lockfiles.
    Verified that the page shows up.
    
    * Fix art fixture
    
    * Fix reconciler fixture
    
    * Fix SSR fixture
    
    * Rename native packages

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
new file mode 100644
index 0000000000..643606d7ee
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -0,0 +1,43 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+'use strict';
+
+var React;
+var ReactNoop;
+
+describe('ReactExpiration', () => {
+  beforeEach(() => {
+    jest.resetModules();
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop};
+  }
+
+  it('increases priority of updates as time progresses', () => {
+    ReactNoop.render(<span prop="done" />);
+
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Nothing has expired yet because time hasn't advanced.
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Advance by 300ms, not enough to expire the low pri update.
+    ReactNoop.expire(300);
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Advance by another second. Now the update should expire and flush.
+    ReactNoop.expire(1000);
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([span('done')]);
+  });
+});

commit 6074664f73c6b1ea1f774f2bc698224e3677cef0
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Thu Nov 30 21:59:05 2017 -0200

    react-reconciler: convert vars into let/const (#11729)

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 643606d7ee..1227237f7d 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -7,8 +7,8 @@
 
 'use strict';
 
-var React;
-var ReactNoop;
+let React;
+let ReactNoop;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {

commit 0deea326674077598e351803d7a204a1c744a578
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jan 2 18:42:18 2018 +0000

    Run some tests in Node environment (#11948)
    
    * Run some tests in Node environment
    
    * Separate SSR tests that require DOM
    
    This allow us to run others with Node environment.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 1227237f7d..ec6a133d6d 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -3,6 +3,8 @@
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
+ *
+ * @jest-environment node
  */
 
 'use strict';

commit 94518b068bf52196abea0c83f4c9926bfe2065c6
Author: Andrew Clark <acdlite@me.com>
Date:   Fri Feb 23 17:38:42 2018 -0800

    Add stack unwinding phase for handling errors (#12201)
    
    * Add stack unwinding phase for handling errors
    
    A rewrite of error handling, with semantics that more closely match
    stack unwinding.
    
    Errors that are thrown during the render phase unwind to the nearest
    error boundary, like before. But rather than synchronously unmount the
    children before retrying, we restart the failed subtree within the same
    render phase. The failed children are still unmounted (as if all their
    keys changed) but without an extra commit.
    
    Commit phase errors are different. They work by scheduling an error on
    the update queue of the error boundary. When we enter the render phase,
    the error is popped off the queue. The rest of the algorithm is
    the same.
    
    This approach is designed to work for throwing non-errors, too, though
    that feature is not implemented yet.
    
    * Add experimental getDerivedStateFromCatch lifecycle
    
    Fires during the render phase, so you can recover from an error within the same
    pass. This aligns error boundaries more closely with try-catch semantics.
    
    Let's keep this behind a feature flag until a future release. For now, the
    recommendation is to keep using componentDidCatch. Eventually, the advice will
    be to use getDerivedStateFromCatch for handling errors and componentDidCatch
    only for logging.
    
    * Reconcile twice to remount failed children, instead of using a boolean
    
    * Handle effect immediately after its thrown
    
    This way we don't have to store the thrown values on the effect list.
    
    * ReactFiberIncompleteWork -> ReactFiberUnwindWork
    
    * Remove startTime
    
    * Remove TypeOfException
    
    We don't need it yet. We'll reconsider once we add another exception type.
    
    * Move replay to outer catch block
    
    This moves it out of the hot path.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index ec6a133d6d..58d501cbfd 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -32,8 +32,8 @@ describe('ReactExpiration', () => {
     ReactNoop.flushExpired();
     expect(ReactNoop.getChildren()).toEqual([]);
 
-    // Advance by 300ms, not enough to expire the low pri update.
-    ReactNoop.expire(300);
+    // Advance time a bit, but not enough to expire the low pri update.
+    ReactNoop.expire(4500);
     ReactNoop.flushExpired();
     expect(ReactNoop.getChildren()).toEqual([]);
 

commit 4fe6eec15bc69737910e5c6c749ebc6187d67be0
Author: Andrew Clark <acdlite@me.com>
Date:   Tue Jun 19 10:34:19 2018 -0700

    Always batch updates of like priority within the same event (#13071)
    
    Expiration times are computed by adding to the current time (the start
    time). However, if two updates are scheduled within the same event, we
    should treat their start times as simultaneous, even if the actual clock
    time has advanced between the first and second call.
    
    In other words, because expiration times determine how updates are
    batched, we want all updates of like priority that occur within the same
    event to receive the same expiration time. Otherwise we get tearing.
    
    We keep track of two separate times: the current "renderer" time and the
    current "scheduler" time. The renderer time can be updated whenever; it
    only exists to minimize the calls performance.now.
    
    But the scheduler time can only be updated if there's no pending work,
    or if we know for certain that we're not in the middle of an event.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
deleted file mode 100644
index 58d501cbfd..0000000000
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @jest-environment node
- */
-
-'use strict';
-
-let React;
-let ReactNoop;
-
-describe('ReactExpiration', () => {
-  beforeEach(() => {
-    jest.resetModules();
-    React = require('react');
-    ReactNoop = require('react-noop-renderer');
-  });
-
-  function span(prop) {
-    return {type: 'span', children: [], prop};
-  }
-
-  it('increases priority of updates as time progresses', () => {
-    ReactNoop.render(<span prop="done" />);
-
-    expect(ReactNoop.getChildren()).toEqual([]);
-
-    // Nothing has expired yet because time hasn't advanced.
-    ReactNoop.flushExpired();
-    expect(ReactNoop.getChildren()).toEqual([]);
-
-    // Advance time a bit, but not enough to expire the low pri update.
-    ReactNoop.expire(4500);
-    ReactNoop.flushExpired();
-    expect(ReactNoop.getChildren()).toEqual([]);
-
-    // Advance by another second. Now the update should expire and flush.
-    ReactNoop.expire(1000);
-    ReactNoop.flushExpired();
-    expect(ReactNoop.getChildren()).toEqual([span('done')]);
-  });
-});

commit 147bdef11bbeb8f4aef18c56d53ec1591fce8653
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 8 20:54:54 2020 -0700

    Port more tests to the Scheduler.unstable_yieldValue pattern and drop internal.js (#18549)
    
    * Drop the .internal.js suffix on some files that don't need it anymore
    
    * Port some ops patterns to scheduler yield
    
    * Fix triangle test to avoid side-effects in constructor
    
    * Move replaying of setState updaters until after the effect
    
    Otherwise any warnings get silenced if they're deduped.
    
    * Drop .internal.js in more files
    
    * Don't check propTypes on a simple memo component unless it's lazy
    
    Comparing the elementType doesn't work for this because it will never be
    the same for a simple element.
    
    This caused us to double validate these. This was covered up because in
    internal tests this was deduped since they shared the prop types cache
    but since we now inline it, it doesn't get deduped.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
new file mode 100644
index 0000000000..7218aa9872
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -0,0 +1,294 @@
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @jest-environment node
+ */
+
+'use strict';
+
+let React;
+let ReactNoop;
+let Scheduler;
+
+describe('ReactExpiration', () => {
+  beforeEach(() => {
+    jest.resetModules();
+
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+    Scheduler = require('scheduler');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop, hidden: false};
+  }
+
+  it('increases priority of updates as time progresses', () => {
+    ReactNoop.render(<span prop="done" />);
+
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Nothing has expired yet because time hasn't advanced.
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Advance time a bit, but not enough to expire the low pri update.
+    ReactNoop.expire(4500);
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Advance by another second. Now the update should expire and flush.
+    ReactNoop.expire(1000);
+    ReactNoop.flushExpired();
+    expect(ReactNoop.getChildren()).toEqual([span('done')]);
+  });
+
+  it('two updates of like priority in the same event always flush within the same batch', () => {
+    class Text extends React.Component {
+      componentDidMount() {
+        Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+      }
+      componentDidUpdate() {
+        Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+      }
+      render() {
+        Scheduler.unstable_yieldValue(`${this.props.text} [render]`);
+        return <span prop={this.props.text} />;
+      }
+    }
+
+    function interrupt() {
+      ReactNoop.flushSync(() => {
+        ReactNoop.renderToRootWithID(null, 'other-root');
+      });
+    }
+
+    // First, show what happens for updates in two separate events.
+    // Schedule an update.
+    ReactNoop.render(<Text text="A" />);
+    // Advance the timer.
+    Scheduler.unstable_advanceTime(2000);
+    // Partially flush the first update, then interrupt it.
+    expect(Scheduler).toFlushAndYieldThrough(['A [render]']);
+    interrupt();
+
+    // Don't advance time by enough to expire the first update.
+    expect(Scheduler).toHaveYielded([]);
+    expect(ReactNoop.getChildren()).toEqual([]);
+
+    // Schedule another update.
+    ReactNoop.render(<Text text="B" />);
+    // The updates should flush in separate batches, since sufficient time
+    // passed in between them *and* they occurred in separate events.
+    // Note: This isn't necessarily the ideal behavior. It might be better to
+    // batch these two updates together. The fact that they aren't batched
+    // is an implementation detail. The important part of this unit test is that
+    // they are batched if it's possible that they happened in the same event.
+    expect(Scheduler).toFlushAndYield([
+      'A [render]',
+      'A [commit]',
+      'B [render]',
+      'B [commit]',
+    ]);
+    expect(ReactNoop.getChildren()).toEqual([span('B')]);
+
+    // Now do the same thing again, except this time don't flush any work in
+    // between the two updates.
+    ReactNoop.render(<Text text="A" />);
+    Scheduler.unstable_advanceTime(2000);
+    expect(Scheduler).toHaveYielded([]);
+    expect(ReactNoop.getChildren()).toEqual([span('B')]);
+    // Schedule another update.
+    ReactNoop.render(<Text text="B" />);
+    // The updates should flush in the same batch, since as far as the scheduler
+    // knows, they may have occurred inside the same event.
+    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+  });
+
+  it(
+    'two updates of like priority in the same event always flush within the ' +
+      "same batch, even if there's a sync update in between",
+    () => {
+      class Text extends React.Component {
+        componentDidMount() {
+          Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+        }
+        componentDidUpdate() {
+          Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+        }
+        render() {
+          Scheduler.unstable_yieldValue(`${this.props.text} [render]`);
+          return <span prop={this.props.text} />;
+        }
+      }
+
+      function interrupt() {
+        ReactNoop.flushSync(() => {
+          ReactNoop.renderToRootWithID(null, 'other-root');
+        });
+      }
+
+      // First, show what happens for updates in two separate events.
+      // Schedule an update.
+      ReactNoop.render(<Text text="A" />);
+      // Advance the timer.
+      Scheduler.unstable_advanceTime(2000);
+      // Partially flush the first update, then interrupt it.
+      expect(Scheduler).toFlushAndYieldThrough(['A [render]']);
+      interrupt();
+
+      // Don't advance time by enough to expire the first update.
+      expect(Scheduler).toHaveYielded([]);
+      expect(ReactNoop.getChildren()).toEqual([]);
+
+      // Schedule another update.
+      ReactNoop.render(<Text text="B" />);
+      // The updates should flush in separate batches, since sufficient time
+      // passed in between them *and* they occurred in separate events.
+      // Note: This isn't necessarily the ideal behavior. It might be better to
+      // batch these two updates together. The fact that they aren't batched
+      // is an implementation detail. The important part of this unit test is that
+      // they are batched if it's possible that they happened in the same event.
+      expect(Scheduler).toFlushAndYield([
+        'A [render]',
+        'A [commit]',
+        'B [render]',
+        'B [commit]',
+      ]);
+      expect(ReactNoop.getChildren()).toEqual([span('B')]);
+
+      // Now do the same thing again, except this time don't flush any work in
+      // between the two updates.
+      ReactNoop.render(<Text text="A" />);
+      Scheduler.unstable_advanceTime(2000);
+      expect(Scheduler).toHaveYielded([]);
+      expect(ReactNoop.getChildren()).toEqual([span('B')]);
+
+      // Perform some synchronous work. The scheduler must assume we're inside
+      // the same event.
+      interrupt();
+
+      // Schedule another update.
+      ReactNoop.render(<Text text="B" />);
+      // The updates should flush in the same batch, since as far as the scheduler
+      // knows, they may have occurred inside the same event.
+      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+    },
+  );
+
+  it('cannot update at the same expiration time that is already rendering', () => {
+    const store = {text: 'initial'};
+    const subscribers = [];
+    class Connected extends React.Component {
+      state = {text: store.text};
+      componentDidMount() {
+        subscribers.push(this);
+        Scheduler.unstable_yieldValue(
+          `${this.state.text} [${this.props.label}] [commit]`,
+        );
+      }
+      componentDidUpdate() {
+        Scheduler.unstable_yieldValue(
+          `${this.state.text} [${this.props.label}] [commit]`,
+        );
+      }
+      render() {
+        Scheduler.unstable_yieldValue(
+          `${this.state.text} [${this.props.label}] [render]`,
+        );
+        return <span prop={this.state.text} />;
+      }
+    }
+
+    function App() {
+      return (
+        <>
+          <Connected label="A" />
+          <Connected label="B" />
+          <Connected label="C" />
+          <Connected label="D" />
+        </>
+      );
+    }
+
+    // Initial mount
+    ReactNoop.render(<App />);
+    expect(Scheduler).toFlushAndYield([
+      'initial [A] [render]',
+      'initial [B] [render]',
+      'initial [C] [render]',
+      'initial [D] [render]',
+      'initial [A] [commit]',
+      'initial [B] [commit]',
+      'initial [C] [commit]',
+      'initial [D] [commit]',
+    ]);
+
+    // Partial update
+    subscribers.forEach(s => s.setState({text: '1'}));
+    expect(Scheduler).toFlushAndYieldThrough([
+      '1 [A] [render]',
+      '1 [B] [render]',
+    ]);
+
+    // Before the update can finish, update again. Even though no time has
+    // advanced, this update should be given a different expiration time than
+    // the currently rendering one. So, C and D should render with 1, not 2.
+    subscribers.forEach(s => s.setState({text: '2'}));
+    expect(Scheduler).toFlushAndYieldThrough([
+      '1 [C] [render]',
+      '1 [D] [render]',
+    ]);
+  });
+
+  it('should measure expiration times relative to module initialization', () => {
+    // Tests an implementation detail where expiration times are computed using
+    // bitwise operations.
+
+    jest.resetModules();
+    Scheduler = require('scheduler');
+    // Before importing the renderer, advance the current time by a number
+    // larger than the maximum allowed for bitwise operations.
+    const maxSigned31BitInt = 1073741823;
+    Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
+
+    // Now import the renderer. On module initialization, it will read the
+    // current time.
+    ReactNoop = require('react-noop-renderer');
+
+    ReactNoop.render('Hi');
+
+    // The update should not have expired yet.
+    expect(Scheduler).toFlushExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+
+    // Advance the time some more to expire the update.
+    Scheduler.unstable_advanceTime(10000);
+    expect(Scheduler).toFlushExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput('Hi');
+  });
+
+  it('should measure callback timeout relative to current time, not start-up time', () => {
+    // Corresponds to a bugfix: https://github.com/facebook/react/pull/15479
+    // The bug wasn't caught by other tests because we use virtual times that
+    // default to 0, and most tests don't advance time.
+
+    // Before scheduling an update, advance the current time.
+    Scheduler.unstable_advanceTime(10000);
+
+    ReactNoop.render('Hi');
+    expect(Scheduler).toFlushExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
+
+    // Advancing by ~5 seconds should be sufficient to expire the update. (I
+    // used a slightly larger number to allow for possible rounding.)
+    Scheduler.unstable_advanceTime(6000);
+
+    ReactNoop.render('Hi');
+    expect(Scheduler).toFlushExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput('Hi');
+  });
+});

commit db6513914f99c260090f26f0a547ee1432c934e6
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Apr 24 23:26:04 2020 -0700

    Make ExpirationTime an opaque type (#18732)
    
    * Add LanePriority type
    
    React's internal scheduler has more priority levels than the external
    Scheduler package. Let's use React as the source of truth for tracking
    the priority of updates so we have more control. We'll still fall back
    to Scheduler in the default case. In the future, we should consider
    removing `runWithPriority` from Scheduler and replacing the valid use
    cases with React-specific APIs.
    
    This commit adds a new type, called a LanePriority to disambiguate from
    the Scheduler one.
    
    ("Lane" refers to another type that I'm planning. It roughly translates
    to "thread." Each lane will have a priority associated with it.)
    
    I'm not actually using the lane anywhere, yet. Only setting stuff up.
    
    * Remove expiration times train model
    
    In the old reconciler, expiration times are computed by applying an
    offset to the current system time. This has the effect of increasing
    the priority of updates as time progresses. Because we also use
    expiration times as a kind of "thread" identifier, it turns out this
    is quite limiting because we can only flush work sequentially along
    the timeline.
    
    The new model will use a bitmask to represent parallel threads that
    can be worked on in any combination and in any order.
    
    In this commit, expiration times and the linear timeline are still in
    place, but they are no longer based on a timestamp. Effectively, they
    are constants based on their priority level.
    
    * Stop using ExpirationTime to represent timestamps
    
    Follow up to the previous commit. This converts the remaining places
    where we were using the ExpirationTime type to represent a timestamp,
    like Suspense timeouts.
    
    * Fork Dependencies and PendingInteractionMap types
    
    These contain expiration times
    
    * Make ExpirationTime an opaque type
    
    ExpirationTime is currently just an alias for the `number` type, for a
    few reasons. One is that it predates Flow's opaque type feature. Another
    is that making it opaque means we have to move all our comparisons and
    number math to the ExpirationTime module, and use utility functions
    everywhere else.
    
    However, this is actually what we want in the new system, because the
    Lanes type that will replace ExpirationTime is a bitmask with a
    particular layout, and performing operations on it will involve more
    than just number comparisions and artihmetic. I don't want this logic to
    spread ad hoc around the whole codebase.
    
    The utility functions get inlined by Closure so it doesn't matter
    performance-wise.
    
    I automated most of the changes with JSCodeshift, with only a few manual
    tweaks to stuff like imports. My goal was to port the logic exactly to
    prevent subtle mistakes, without trying to simplify anything in the
    process. I'll likely need to audit many of these sites again when I
    replace them with the new type, though, especially the ones
    in ReactFiberRoot.
    
    I added the codemods I used to the `scripts` directory. I won't merge
    these to master. I'll remove them in a subsequent commit. I'm only
    committing them here so they show up in the PR for future reference.
    
    I had a lot of trouble getting Flow to pass. Somehow it was not
    inferring the correct type of the constants exported from the
    ExpirationTime module, despite being annotated correctly.
    
    I tried converting them them to constructor functions — `NoWork`
    becomes `NoWork()` — and that made it work. I used that to unblock me,
    and fixed all the other type errors. Once there were no more type
    errors, I tried converting the constructors back to constants. Started
    getting errors again.
    
    Then I added a type constraint everywhere a constant was referenced.
    That fixed it. I also figured out that you only have to add a constraint
    when the constant is passed to another function, even if the function is
    annotated. So this indicates to me that it's probably a Flow bug. I'll
    file an issue with Flow.
    
    * Delete temporary codemods used in previous commit
    
    I only added these to the previous commit so that I can easily run it
    again when rebasing. When the stack is squashed, it will be as if they
    never existed.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 7218aa9872..bdb512d774 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -22,6 +22,11 @@ describe('ReactExpiration', () => {
     Scheduler = require('scheduler');
   });
 
+  function Text(props) {
+    Scheduler.unstable_yieldValue(props.text);
+    return props.text;
+  }
+
   function span(prop) {
     return {type: 'span', children: [], prop, hidden: false};
   }
@@ -47,7 +52,7 @@ describe('ReactExpiration', () => {
   });
 
   it('two updates of like priority in the same event always flush within the same batch', () => {
-    class Text extends React.Component {
+    class TextClass extends React.Component {
       componentDidMount() {
         Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
       }
@@ -68,7 +73,7 @@ describe('ReactExpiration', () => {
 
     // First, show what happens for updates in two separate events.
     // Schedule an update.
-    ReactNoop.render(<Text text="A" />);
+    ReactNoop.render(<TextClass text="A" />);
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
     // Partially flush the first update, then interrupt it.
@@ -80,29 +85,28 @@ describe('ReactExpiration', () => {
     expect(ReactNoop.getChildren()).toEqual([]);
 
     // Schedule another update.
-    ReactNoop.render(<Text text="B" />);
-    // The updates should flush in separate batches, since sufficient time
-    // passed in between them *and* they occurred in separate events.
-    // Note: This isn't necessarily the ideal behavior. It might be better to
-    // batch these two updates together. The fact that they aren't batched
-    // is an implementation detail. The important part of this unit test is that
-    // they are batched if it's possible that they happened in the same event.
-    expect(Scheduler).toFlushAndYield([
-      'A [render]',
-      'A [commit]',
-      'B [render]',
-      'B [commit]',
-    ]);
+    ReactNoop.render(<TextClass text="B" />);
+    expect(Scheduler).toFlushAndYield(
+      gate(flags =>
+        flags.new
+          ? // In the new reconciler, both updates are batched
+            ['B [render]', 'B [commit]']
+          : // In the old reconciler, they are flushed separately. That's not
+            // ideal, but for the purposes of this test it's fine since they
+            // didn't happen in the same event,
+            ['A [render]', 'A [commit]', 'B [render]', 'B [commit]'],
+      ),
+    );
     expect(ReactNoop.getChildren()).toEqual([span('B')]);
 
     // Now do the same thing again, except this time don't flush any work in
     // between the two updates.
-    ReactNoop.render(<Text text="A" />);
+    ReactNoop.render(<TextClass text="A" />);
     Scheduler.unstable_advanceTime(2000);
     expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop.getChildren()).toEqual([span('B')]);
     // Schedule another update.
-    ReactNoop.render(<Text text="B" />);
+    ReactNoop.render(<TextClass text="B" />);
     // The updates should flush in the same batch, since as far as the scheduler
     // knows, they may have occurred inside the same event.
     expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
@@ -112,7 +116,7 @@ describe('ReactExpiration', () => {
     'two updates of like priority in the same event always flush within the ' +
       "same batch, even if there's a sync update in between",
     () => {
-      class Text extends React.Component {
+      class TextClass extends React.Component {
         componentDidMount() {
           Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
         }
@@ -133,7 +137,7 @@ describe('ReactExpiration', () => {
 
       // First, show what happens for updates in two separate events.
       // Schedule an update.
-      ReactNoop.render(<Text text="A" />);
+      ReactNoop.render(<TextClass text="A" />);
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
       // Partially flush the first update, then interrupt it.
@@ -145,24 +149,23 @@ describe('ReactExpiration', () => {
       expect(ReactNoop.getChildren()).toEqual([]);
 
       // Schedule another update.
-      ReactNoop.render(<Text text="B" />);
-      // The updates should flush in separate batches, since sufficient time
-      // passed in between them *and* they occurred in separate events.
-      // Note: This isn't necessarily the ideal behavior. It might be better to
-      // batch these two updates together. The fact that they aren't batched
-      // is an implementation detail. The important part of this unit test is that
-      // they are batched if it's possible that they happened in the same event.
-      expect(Scheduler).toFlushAndYield([
-        'A [render]',
-        'A [commit]',
-        'B [render]',
-        'B [commit]',
-      ]);
+      ReactNoop.render(<TextClass text="B" />);
+      expect(Scheduler).toFlushAndYield(
+        gate(flags =>
+          flags.new
+            ? // In the new reconciler, both updates are batched
+              ['B [render]', 'B [commit]']
+            : // In the old reconciler, they are flushed separately. That's not
+              // ideal, but for the purposes of this test it's fine since they
+              // didn't happen in the same event,
+              ['A [render]', 'A [commit]', 'B [render]', 'B [commit]'],
+        ),
+      );
       expect(ReactNoop.getChildren()).toEqual([span('B')]);
 
       // Now do the same thing again, except this time don't flush any work in
       // between the two updates.
-      ReactNoop.render(<Text text="A" />);
+      ReactNoop.render(<TextClass text="A" />);
       Scheduler.unstable_advanceTime(2000);
       expect(Scheduler).toHaveYielded([]);
       expect(ReactNoop.getChildren()).toEqual([span('B')]);
@@ -172,7 +175,7 @@ describe('ReactExpiration', () => {
       interrupt();
 
       // Schedule another update.
-      ReactNoop.render(<Text text="B" />);
+      ReactNoop.render(<TextClass text="B" />);
       // The updates should flush in the same batch, since as far as the scheduler
       // knows, they may have occurred inside the same event.
       expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
@@ -244,6 +247,60 @@ describe('ReactExpiration', () => {
     ]);
   });
 
+  it('stops yielding if CPU-bound update takes too long to finish', () => {
+    const root = ReactNoop.createRoot();
+    function App() {
+      return (
+        <>
+          <Text text="A" />
+          <Text text="B" />
+          <Text text="C" />
+          <Text text="D" />
+          <Text text="E" />
+        </>
+      );
+    }
+
+    root.render(<App />);
+
+    expect(Scheduler).toFlushAndYieldThrough(['A']);
+    expect(Scheduler).toFlushAndYieldThrough(['B']);
+    expect(Scheduler).toFlushAndYieldThrough(['C']);
+
+    Scheduler.unstable_advanceTime(10000);
+
+    expect(Scheduler).toFlushExpired(['D', 'E']);
+    expect(root).toMatchRenderedOutput('ABCDE');
+  });
+
+  it('root expiration is measured from the time of the first update', () => {
+    Scheduler.unstable_advanceTime(10000);
+
+    const root = ReactNoop.createRoot();
+    function App() {
+      return (
+        <>
+          <Text text="A" />
+          <Text text="B" />
+          <Text text="C" />
+          <Text text="D" />
+          <Text text="E" />
+        </>
+      );
+    }
+
+    root.render(<App />);
+
+    expect(Scheduler).toFlushAndYieldThrough(['A']);
+    expect(Scheduler).toFlushAndYieldThrough(['B']);
+    expect(Scheduler).toFlushAndYieldThrough(['C']);
+
+    Scheduler.unstable_advanceTime(10000);
+
+    expect(Scheduler).toFlushExpired(['D', 'E']);
+    expect(root).toMatchRenderedOutput('ABCDE');
+  });
+
   it('should measure expiration times relative to module initialization', () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.

commit 6edaf6f764f23043f0cd1c2da355b42f641afd8b
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri May 8 12:47:51 2020 -0700

    Detect and prevent render starvation, per lane (#18864)
    
    * Detect and prevent render starvation, per lane
    
    If an update is CPU-bound for longer than expected according to its
    priority, we assume it's being starved by other work on the main thread.
    
    To detect this, we keep track of the elapsed time using a fixed-size
    array where each slot corresponds to a lane. What we actually store is
    the event time when the lane first became CPU-bound.
    
    Then, when receiving a new update or yielding to the main thread, we
    check how long each lane has been pending. If the time exceeds a
    threshold constant corresponding to its priority, we mark it as expired
    to force it to synchronously finish.
    
    We don't want to mistake time elapsed while an update is IO-bound
    (waiting for data to resolve) for time when it is CPU-bound. So when a
    lane suspends, we clear its associated event time from the array. When
    it receives a signal to try again, either a ping or an update, we assign
    a new event time to restart the clock.
    
    * Store as expiration time, not start time
    
    I originally stored the start time because I thought I could use this
    in the future to also measure Suspense timeouts. (Event times are
    currently stored on each update object for this purpose.) But that
    won't work because in the case of expiration times, we reset the clock
    whenever the update becomes IO-bound. So to replace the per-update
    field, I'm going to have to track those on the room separately from
    expiration times.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index bdb512d774..d19a14e58c 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -12,6 +12,8 @@
 let React;
 let ReactNoop;
 let Scheduler;
+let readText;
+let resolveText;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
@@ -20,6 +22,53 @@ describe('ReactExpiration', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+
+    const textCache = new Map();
+
+    readText = text => {
+      const record = textCache.get(text);
+      if (record !== undefined) {
+        switch (record.status) {
+          case 'pending':
+            throw record.promise;
+          case 'rejected':
+            throw Error('Failed to load: ' + text);
+          case 'resolved':
+            return text;
+        }
+      } else {
+        let ping;
+        const promise = new Promise(resolve => (ping = resolve));
+        const newRecord = {
+          status: 'pending',
+          ping: ping,
+          promise,
+        };
+        textCache.set(text, newRecord);
+        throw promise;
+      }
+    };
+
+    resolveText = text => {
+      const record = textCache.get(text);
+      if (record !== undefined) {
+        if (record.status === 'pending') {
+          Scheduler.unstable_yieldValue(`Promise resolved [${text}]`);
+          record.ping();
+          record.ping = null;
+          record.status = 'resolved';
+          clearTimeout(record.promise._timer);
+          record.promise = null;
+        }
+      } else {
+        const newRecord = {
+          ping: null,
+          status: 'resolved',
+          promise: null,
+        };
+        textCache.set(text, newRecord);
+      }
+    };
   });
 
   function Text(props) {
@@ -27,6 +76,27 @@ describe('ReactExpiration', () => {
     return props.text;
   }
 
+  function AsyncText(props) {
+    const text = props.text;
+    try {
+      readText(text);
+      Scheduler.unstable_yieldValue(text);
+      return text;
+    } catch (promise) {
+      if (typeof promise.then === 'function') {
+        Scheduler.unstable_yieldValue(`Suspend! [${text}]`);
+        if (typeof props.ms === 'number' && promise._timer === undefined) {
+          promise._timer = setTimeout(() => {
+            resolveText(text);
+          }, props.ms);
+        }
+      } else {
+        Scheduler.unstable_yieldValue(`Error! [${text}]`);
+      }
+      throw promise;
+    }
+  }
+
   function span(prop) {
     return {type: 'span', children: [], prop, hidden: false};
   }
@@ -348,4 +418,408 @@ describe('ReactExpiration', () => {
     expect(Scheduler).toFlushExpired([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
+
+  it('prevents starvation by high priority updates', async () => {
+    const {useState} = React;
+
+    let updateHighPri;
+    let updateNormalPri;
+    function App() {
+      const [highPri, setHighPri] = useState(0);
+      const [normalPri, setNormalPri] = useState(0);
+      updateHighPri = () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => setHighPri(n => n + 1),
+        );
+      updateNormalPri = () => setNormalPri(n => n + 1);
+      return (
+        <>
+          <Text text={'High pri: ' + highPri} />
+          {', '}
+          <Text text={'Normal pri: ' + normalPri} />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded(['High pri: 0', 'Normal pri: 0']);
+    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0');
+
+    // First demonstrate what happens when there's no starvation
+    await ReactNoop.act(async () => {
+      updateNormalPri();
+      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
+      updateHighPri();
+    });
+    expect(Scheduler).toHaveYielded([
+      // Interrupt high pri update to render sync update
+      'High pri: 1',
+      'Normal pri: 0',
+      // Now render normal pri
+      'High pri: 1',
+      'Normal pri: 1',
+    ]);
+    expect(root).toMatchRenderedOutput('High pri: 1, Normal pri: 1');
+
+    // Do the same thing, but starve the first update
+    await ReactNoop.act(async () => {
+      updateNormalPri();
+      expect(Scheduler).toFlushAndYieldThrough(['High pri: 1']);
+
+      // This time, a lot of time has elapsed since the normal pri update
+      // started rendering. (This should advance time by some number that's
+      // definitely bigger than the constant heuristic we use to detect
+      // starvation of normal priority updates.)
+      Scheduler.unstable_advanceTime(10000);
+
+      // So when we get a high pri update, we shouldn't interrupt
+      updateHighPri();
+    });
+    expect(Scheduler).toHaveYielded([
+      // Finish normal pri update
+      'Normal pri: 2',
+      // Then do high pri update
+      'High pri: 2',
+      'Normal pri: 2',
+    ]);
+    expect(root).toMatchRenderedOutput('High pri: 2, Normal pri: 2');
+  });
+
+  // @gate new
+  it('prevents starvation by sync updates', async () => {
+    const {useState} = React;
+
+    let updateSyncPri;
+    let updateHighPri;
+    function App() {
+      const [syncPri, setSyncPri] = useState(0);
+      const [highPri, setHighPri] = useState(0);
+      updateSyncPri = () => ReactNoop.flushSync(() => setSyncPri(n => n + 1));
+      updateHighPri = () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => setHighPri(n => n + 1),
+        );
+      return (
+        <>
+          <Text text={'Sync pri: ' + syncPri} />
+          {', '}
+          <Text text={'High pri: ' + highPri} />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'High pri: 0']);
+    expect(root).toMatchRenderedOutput('Sync pri: 0, High pri: 0');
+
+    // First demonstrate what happens when there's no starvation
+    await ReactNoop.act(async () => {
+      updateHighPri();
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
+      updateSyncPri();
+    });
+    expect(Scheduler).toHaveYielded([
+      // Interrupt high pri update to render sync update
+      'Sync pri: 1',
+      'High pri: 0',
+      // Now render high pri
+      'Sync pri: 1',
+      'High pri: 1',
+    ]);
+    expect(root).toMatchRenderedOutput('Sync pri: 1, High pri: 1');
+
+    // Do the same thing, but starve the first update
+    await ReactNoop.act(async () => {
+      updateHighPri();
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
+
+      // This time, a lot of time has elapsed since the high pri update started
+      // rendering. (This should advance time by some number that's definitely
+      // bigger than the constant heuristic we use to detect starvation of user
+      // interactions, but not as high as the onse used for normal pri updates.)
+      Scheduler.unstable_advanceTime(1500);
+
+      // So when we get a sync update, we shouldn't interrupt
+      updateSyncPri();
+    });
+    expect(Scheduler).toHaveYielded([
+      // Finish high pri update
+      'High pri: 2',
+      // Then do sync update
+      'Sync pri: 2',
+      'High pri: 2',
+    ]);
+    expect(root).toMatchRenderedOutput('Sync pri: 2, High pri: 2');
+  });
+
+  it('idle work never expires', async () => {
+    const {useState} = React;
+
+    let updateSyncPri;
+    let updateIdlePri;
+    function App() {
+      const [syncPri, setSyncPri] = useState(0);
+      const [highPri, setIdlePri] = useState(0);
+      updateSyncPri = () => ReactNoop.flushSync(() => setSyncPri(n => n + 1));
+      updateIdlePri = () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_IdlePriority,
+          () => setIdlePri(n => n + 1),
+        );
+      return (
+        <>
+          <Text text={'Sync pri: ' + syncPri} />
+          {', '}
+          <Text text={'Idle pri: ' + highPri} />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Idle pri: 0']);
+    expect(root).toMatchRenderedOutput('Sync pri: 0, Idle pri: 0');
+
+    // First demonstrate what happens when there's no starvation
+    await ReactNoop.act(async () => {
+      updateIdlePri();
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
+      updateSyncPri();
+    });
+    expect(Scheduler).toHaveYielded([
+      // Interrupt idle update to render sync update
+      'Sync pri: 1',
+      'Idle pri: 0',
+      // Now render idle
+      'Sync pri: 1',
+      'Idle pri: 1',
+    ]);
+    expect(root).toMatchRenderedOutput('Sync pri: 1, Idle pri: 1');
+
+    // Do the same thing, but starve the first update
+    await ReactNoop.act(async () => {
+      updateIdlePri();
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
+
+      // Advance a ridiculously large amount of time to demonstrate that the
+      // idle work never expires
+      Scheduler.unstable_advanceTime(100000);
+
+      updateSyncPri();
+    });
+    // Same thing should happen as last time
+    expect(Scheduler).toHaveYielded([
+      // Interrupt idle update to render sync update
+      'Sync pri: 2',
+      'Idle pri: 1',
+      // Now render idle
+      'Sync pri: 2',
+      'Idle pri: 2',
+    ]);
+    expect(root).toMatchRenderedOutput('Sync pri: 2, Idle pri: 2');
+  });
+
+  // @gate new
+  it('a single update can expire without forcing all other updates to expire', async () => {
+    const {useState} = React;
+
+    let updateHighPri;
+    let updateNormalPri;
+    function App() {
+      const [highPri, setHighPri] = useState(0);
+      const [normalPri, setNormalPri] = useState(0);
+      updateHighPri = () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => setHighPri(n => n + 1),
+        );
+      updateNormalPri = () => setNormalPri(n => n + 1);
+      return (
+        <>
+          <Text text={'High pri: ' + highPri} />
+          {', '}
+          <Text text={'Normal pri: ' + normalPri} />
+          {', '}
+          <Text text="Sibling" />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'High pri: 0',
+      'Normal pri: 0',
+      'Sibling',
+    ]);
+    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0, Sibling');
+
+    await ReactNoop.act(async () => {
+      // Partially render an update
+      updateNormalPri();
+      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
+      // Some time goes by. In an interleaved event, schedule another update.
+      // This will be placed into a separate batch.
+      Scheduler.unstable_advanceTime(4000);
+      updateNormalPri();
+      // Keep rendering the first update
+      expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
+      // More time goes by. Enough to expire the first batch, but not the
+      // second one.
+      Scheduler.unstable_advanceTime(1000);
+      // Attempt to interrupt with a high pri update.
+      updateHighPri();
+
+      // The first update expired, so first will finish it without interrupting.
+      // But not the second update, which hasn't expired yet.
+      expect(Scheduler).toFlushExpired(['Sibling']);
+    });
+    expect(Scheduler).toHaveYielded([
+      // Then render the high pri update
+      'High pri: 1',
+      'Normal pri: 1',
+      'Sibling',
+      // Then the second normal pri update
+      'High pri: 1',
+      'Normal pri: 2',
+      'Sibling',
+    ]);
+  });
+
+  it('detects starvation in multiple batches', async () => {
+    const {useState} = React;
+
+    let updateHighPri;
+    let updateNormalPri;
+    function App() {
+      const [highPri, setHighPri] = useState(0);
+      const [normalPri, setNormalPri] = useState(0);
+      updateHighPri = () =>
+        Scheduler.unstable_runWithPriority(
+          Scheduler.unstable_UserBlockingPriority,
+          () => setHighPri(n => n + 1),
+        );
+      updateNormalPri = () => setNormalPri(n => n + 1);
+      return (
+        <>
+          <Text text={'High pri: ' + highPri} />
+          {', '}
+          <Text text={'Normal pri: ' + normalPri} />
+          {', '}
+          <Text text="Sibling" />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App />);
+    });
+    expect(Scheduler).toHaveYielded([
+      'High pri: 0',
+      'Normal pri: 0',
+      'Sibling',
+    ]);
+    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0, Sibling');
+
+    await ReactNoop.act(async () => {
+      // Partially render an update
+      updateNormalPri();
+      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
+      // Some time goes by. In an interleaved event, schedule another update.
+      // This will be placed into a separate batch.
+      Scheduler.unstable_advanceTime(4000);
+      updateNormalPri();
+      // Keep rendering the first update
+      expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
+      // More time goes by. This expires both of the updates just scheduled.
+      Scheduler.unstable_advanceTime(10000);
+
+      // Attempt to interrupt with a high pri update.
+      updateHighPri();
+
+      // Both normal pri updates should have expired.
+      expect(Scheduler).toFlushExpired([
+        'Sibling',
+        // Note: we also flushed the high pri update here, because in the
+        // current implementation, once we pick the next lanes to work on, we
+        // entangle it with all pending at equal or higher priority. We could
+        // feasibly change this heuristic so that the high pri update doesn't
+        // render until after the expired updates have finished. But the
+        // important thing in this test is that the normal updates expired.
+        'High pri: 1',
+        'Normal pri: 2',
+        'Sibling',
+      ]);
+    });
+  });
+
+  // @gate new
+  it('updates do not expire while they are IO-bound', async () => {
+    const {Suspense} = React;
+
+    function App({text}) {
+      return (
+        <Suspense fallback={<Text text="Loading..." />}>
+          <AsyncText text={text} />
+          {', '}
+          <Text text="Sibling" />
+        </Suspense>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      await resolveText('A');
+      root.render(<App text="A" />);
+    });
+    expect(Scheduler).toHaveYielded(['A', 'Sibling']);
+    expect(root).toMatchRenderedOutput('A, Sibling');
+
+    await ReactNoop.act(async () => {
+      root.render(<App text="B" />);
+      expect(Scheduler).toFlushAndYield([
+        'Suspend! [B]',
+        'Sibling',
+        'Loading...',
+      ]);
+
+      // Lots of time elapses before the promise resolves
+      Scheduler.unstable_advanceTime(10000);
+      await resolveText('B');
+      expect(Scheduler).toHaveYielded(['Promise resolved [B]']);
+
+      // But the update doesn't expire, because it was IO bound. So we can
+      // partially rendering without finishing.
+      expect(Scheduler).toFlushAndYieldThrough(['B']);
+      expect(root).toMatchRenderedOutput('A, Sibling');
+
+      // Lots more time elapses. We're CPU-bound now, so we should treat this
+      // as starvation.
+      Scheduler.unstable_advanceTime(10000);
+
+      // Attempt to interrupt with a sync update.
+      ReactNoop.flushSync(() => root.render(<App text="A" />));
+      expect(Scheduler).toHaveYielded([
+        // Because the previous update had already expired, we don't interrupt
+        // it. Finish rendering it first.
+        'Sibling',
+        // Then do the sync update.
+        'A',
+        'Sibling',
+      ]);
+    });
+  });
 });

commit 8f05f2bd6d131a39835d468622e248b231ccbf8e
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Jun 11 20:05:15 2020 -0700

    Land Lanes implementation in old fork (#19108)
    
    * Add autofix to cross-fork lint rule
    
    * replace-fork: Replaces old fork contents with new
    
    For each file in the new fork, copies the contents into the
    corresponding file of the old fork, replacing what was already there.
    
    In contrast to merge-fork, which performs a three-way merge.
    
    * Replace old fork contents with new fork
    
    First I ran  `yarn replace-fork`.
    
    Then I ran `yarn lint` with autofix enabled. There's currently no way to
    do that from the command line (we should fix that), so I had to edit the
    lint script file.
    
    * Manual fix-ups
    
    Removes dead branches, removes prefixes from internal fields.  Stuff
    like that.
    
    * Fix DevTools tests
    
    DevTools tests only run against the old fork, which is why I didn't
    catch these earlier.
    
    There is one test that is still failing. I'm fairly certain it's related
    to the layout of the Suspense fiber: we no longer conditionally wrap the
    primary children. They are always wrapped in an extra fiber.
    
    Since this has been running in www for weeks without major issues, I'll
    defer fixing the remaining test to a follow up.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index d19a14e58c..1b44336709 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -156,17 +156,8 @@ describe('ReactExpiration', () => {
 
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
-    expect(Scheduler).toFlushAndYield(
-      gate(flags =>
-        flags.new
-          ? // In the new reconciler, both updates are batched
-            ['B [render]', 'B [commit]']
-          : // In the old reconciler, they are flushed separately. That's not
-            // ideal, but for the purposes of this test it's fine since they
-            // didn't happen in the same event,
-            ['A [render]', 'A [commit]', 'B [render]', 'B [commit]'],
-      ),
-    );
+    // Both updates are batched
+    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
     expect(ReactNoop.getChildren()).toEqual([span('B')]);
 
     // Now do the same thing again, except this time don't flush any work in
@@ -220,17 +211,8 @@ describe('ReactExpiration', () => {
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
-      expect(Scheduler).toFlushAndYield(
-        gate(flags =>
-          flags.new
-            ? // In the new reconciler, both updates are batched
-              ['B [render]', 'B [commit]']
-            : // In the old reconciler, they are flushed separately. That's not
-              // ideal, but for the purposes of this test it's fine since they
-              // didn't happen in the same event,
-              ['A [render]', 'A [commit]', 'B [render]', 'B [commit]'],
-        ),
-      );
+      // Both updates are batched
+      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
       expect(ReactNoop.getChildren()).toEqual([span('B')]);
 
       // Now do the same thing again, except this time don't flush any work in
@@ -489,7 +471,6 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('High pri: 2, Normal pri: 2');
   });
 
-  // @gate new
   it('prevents starvation by sync updates', async () => {
     const {useState} = React;
 
@@ -629,7 +610,6 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('Sync pri: 2, Idle pri: 2');
   });
 
-  // @gate new
   it('a single update can expire without forcing all other updates to expire', async () => {
     const {useState} = React;
 
@@ -766,7 +746,6 @@ describe('ReactExpiration', () => {
     });
   });
 
-  // @gate new
   it('updates do not expire while they are IO-bound', async () => {
     const {Suspense} = React;
 

commit d13f5b9538e48f74f7c571ef3cde652ca887cca0
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jan 26 14:23:34 2021 -0600

    Experiment: Unsuspend all lanes on update (#20660)
    
    Adds a feature flag to tweak the internal heuristic used to "unsuspend"
    lanes when a new update comes in.
    
    A lane is "suspended" if we couldn't finish rendering it because it was
    missing data, and we chose not to commit the fallback. (In this context,
    "suspended" does not include updates that finished with a fallback.)
    
    When we receive new data in the form of an update, we need to retry
    rendering the suspended lanes, since the new data may have unblocked the
    previously suspended work. For example, the new update could navigate
    back to an already loaded route.
    
    It's impractical to retry every combination of suspended lanes, so we
    need some heuristic that decides which lanes to retry and in
    which order.
    
    The existing heuristic roughly approximates the old Expiration Times
    model. It unsuspends all lower priority lanes, but leaves higher
    priority lanes suspended.
    
    Then when we start rendering, we choose the lanes that have the highest
    LanePriority and render those -- and then we add to that all the lanes
    that are highher priority.
    
    If this sounds terribly confusing, it's because it barely makes sense.
    (It made more sense in the Expiration Times world, I promise, but it
    was still confusing.) I don't think it's worth me trying to explain the
    old behavior too much because the point here is that we can replace it
    with something simpler.
    
    The new heurstic is to unsuspend all suspended lanes whenever there's
    an update.
    
    This is effectively what we already do except in a few very specific
    edge cases, ever since we removed the delayed suspense feature from
    everything that's not a refresh transition.
    
    We can optimize this in the future to only unsuspend lanes that are
    either 1) in the `lanes` or `subtreeLanes` of the node that was updated,
    or 2) in the `lanes` of the return path of the node that was updated.
    This would exclude lanes that are only located in unrelated sibling
    trees. But, this optimization wouldn't be useful currently because we
    assign the same transition lane to all transitions. It will become
    relevant again once we start assigning arbitrary lanes to transitions
    -- but that in turn requires us to implement entanglement of overlapping
    transitions, one of our planned projects.
    
    So to sum up: the goal here is to remove the weird edge cases and switch
    to a simpler model, on top of which we can make more substantial
    improvements.
    
    I put it behind a flag so I can run an A/B test and confirm it doesn't
    cause a regression.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 1b44336709..fd224b2a1f 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -733,13 +733,19 @@ describe('ReactExpiration', () => {
       // Both normal pri updates should have expired.
       expect(Scheduler).toFlushExpired([
         'Sibling',
-        // Note: we also flushed the high pri update here, because in the
-        // current implementation, once we pick the next lanes to work on, we
-        // entangle it with all pending at equal or higher priority. We could
-        // feasibly change this heuristic so that the high pri update doesn't
-        // render until after the expired updates have finished. But the
-        // important thing in this test is that the normal updates expired.
-        'High pri: 1',
+        gate(flags => flags.enableTransitionEntanglement)
+          ? // Notice that the high pri update didn't flush yet. Expiring one lane
+            // doesn't affect other lanes. (Unless they are intentionally
+            // entangled, like we do for overlapping transitions that affect the
+            // same state.)
+            'High pri: 0'
+          : // In the current implementation, once we pick the next lanes to work
+            // on, we entangle it with all pending at equal or higher priority.
+            // We could feasibly change this heuristic so that the high pri
+            // update doesn't render until after the expired updates have
+            // finished. But the important thing in this test is that the normal
+            // updates expired.
+            'High pri: 1',
         'Normal pri: 2',
         'Sibling',
       ]);

commit a014c915c77f908ba3be3de9e6a06d05c71d5b62
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 8 15:26:48 2021 -0600

    Parallel transitions: Assign different lanes to consecutive transitions (#20672)
    
    * Land enableTransitionEntanglement changes
    
    Leaving the flag though because I plan to reuse it for additional,
    similar changes.
    
    * Assign different lanes to consecutive transitions
    
    Currently we always assign the same lane to all transitions. This means
    if there are two pending transitions at the same time, neither
    transition can finish until both can finish, even if they affect
    completely separate parts of the UI.
    
    The new approach is to assign a different lane to each consecutive
    transition, by shifting the bit to the right each time. When we reach
    the end of the bit range, we cycle back to the first bit. In practice,
    this should mean that all transitions get their own dedicated lane,
    unless we have more pending transitions than lanes, which should
    be rare.
    
    We retain our existing behavior of assigning the same lane to all
    transitions within the same event. This is achieved by caching the first
    lane assigned to a transition, then re-using that one until the next
    React task, by which point the event must have finished. This preserves
    the guarantee that all transition updates that result from a single
    event will be consistent.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index fd224b2a1f..c416d24048 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -733,19 +733,10 @@ describe('ReactExpiration', () => {
       // Both normal pri updates should have expired.
       expect(Scheduler).toFlushExpired([
         'Sibling',
-        gate(flags => flags.enableTransitionEntanglement)
-          ? // Notice that the high pri update didn't flush yet. Expiring one lane
-            // doesn't affect other lanes. (Unless they are intentionally
-            // entangled, like we do for overlapping transitions that affect the
-            // same state.)
-            'High pri: 0'
-          : // In the current implementation, once we pick the next lanes to work
-            // on, we entangle it with all pending at equal or higher priority.
-            // We could feasibly change this heuristic so that the high pri
-            // update doesn't render until after the expired updates have
-            // finished. But the important thing in this test is that the normal
-            // updates expired.
-            'High pri: 1',
+        // Notice that the high pri update didn't flush yet. Expiring one lane
+        // doesn't affect other lanes. (Unless they are intentionally entangled,
+        // like we do for overlapping transitions that affect the same state.)
+        'High pri: 0',
         'Normal pri: 2',
         'Sibling',
       ]);

commit 6c526c5153bc350d2a62c7dcbc698be77d3f2439
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 9 02:03:07 2021 -0600

    Don't shift interleaved updates to separate lane (#20681)
    
    Now that interleaved updates are added to a special queue, we no longer
    need to shift them into their own lane. We can add to a lane that's
    already in the middle of rendering without risk of tearing.
    
    See #20615 for more background.
    
    I've only changed this in the new fork, and only behind the
    enableTransitionEntanglements flag.
    
    Most of this commit involves updating tests. The "shift-to-a-new" lane
    trick was intentionally used in a handful of tests where two or more
    updates need to be scheduled in different lanes. Most of these tests
    were written before `startTransition` existed, and all of them were
    written before transitions were assigned arbitrary lanes.
    
    So I ported these tests to use `startTransition` instead, which is the
    idiomatic way to mark an update as parallel.
    
    I didn't change the old fork at all. Writing these tests in such a way
    that they also pass in the old fork actually revealed a few flaws in the
    current implementation regarding interrupting a suspended refresh
    transition early, which is a good reminder that we should be writing our
    tests using idiomatic patterns as much as we possibly can.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index c416d24048..590761dbc8 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -14,6 +14,7 @@ let ReactNoop;
 let Scheduler;
 let readText;
 let resolveText;
+let startTransition;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
@@ -22,6 +23,7 @@ describe('ReactExpiration', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+    startTransition = React.unstable_startTransition;
 
     const textCache = new Map();
 
@@ -610,6 +612,7 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('Sync pri: 2, Idle pri: 2');
   });
 
+  // @gate experimental
   it('a single update can expire without forcing all other updates to expire', async () => {
     const {useState} = React;
 
@@ -648,12 +651,18 @@ describe('ReactExpiration', () => {
 
     await ReactNoop.act(async () => {
       // Partially render an update
-      updateNormalPri();
+      startTransition(() => {
+        updateNormalPri();
+      });
       expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
-      // Some time goes by. In an interleaved event, schedule another update.
+
+      // Some time goes by. Schedule another update.
       // This will be placed into a separate batch.
       Scheduler.unstable_advanceTime(4000);
-      updateNormalPri();
+
+      startTransition(() => {
+        updateNormalPri();
+      });
       // Keep rendering the first update
       expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
       // More time goes by. Enough to expire the first batch, but not the
@@ -662,20 +671,20 @@ describe('ReactExpiration', () => {
       // Attempt to interrupt with a high pri update.
       updateHighPri();
 
-      // The first update expired, so first will finish it without interrupting.
-      // But not the second update, which hasn't expired yet.
+      // The first update expired, so first will finish it without
+      // interrupting. But not the second update, which hasn't expired yet.
       expect(Scheduler).toFlushExpired(['Sibling']);
+      expect(Scheduler).toFlushAndYield([
+        // Then render the high pri update
+        'High pri: 1',
+        'Normal pri: 1',
+        'Sibling',
+        // Then the second normal pri update
+        'High pri: 1',
+        'Normal pri: 2',
+        'Sibling',
+      ]);
     });
-    expect(Scheduler).toHaveYielded([
-      // Then render the high pri update
-      'High pri: 1',
-      'Normal pri: 1',
-      'Sibling',
-      // Then the second normal pri update
-      'High pri: 1',
-      'Normal pri: 2',
-      'Sibling',
-    ]);
   });
 
   it('detects starvation in multiple batches', async () => {

commit 3499c343ab48968192aaefe295dcf4185b3a4f99
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Feb 10 01:21:46 2021 -0600

    Apply #20778 to new fork, too (#20782)
    
    * Apply #20778 to new fork, too
    
    * Fix tests that use runWithPriority
    
    Where possible, I tried to rewrite in terms of an idiomatic API.
    
    For DOM tests, we should be dispatching an event with the desired
    priority level.
    
    For Idle updates (very unstable feature), probably need an unstable
    API like ReactDOM.unstable_IdleUpdates.
    
    Some of these fixes are not great, but we can replace them once we've
    landed the more of our planned changes to the layering between
    Scheduler, the reconciler, and the renderer.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 590761dbc8..017c712bd8 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -403,23 +403,23 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
-  it('prevents starvation by high priority updates', async () => {
+  it('prevents starvation by sync updates', async () => {
     const {useState} = React;
 
-    let updateHighPri;
+    let updateSyncPri;
     let updateNormalPri;
     function App() {
       const [highPri, setHighPri] = useState(0);
       const [normalPri, setNormalPri] = useState(0);
-      updateHighPri = () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => setHighPri(n => n + 1),
-        );
+      updateSyncPri = () => {
+        ReactNoop.flushSync(() => {
+          setHighPri(n => n + 1);
+        });
+      };
       updateNormalPri = () => setNormalPri(n => n + 1);
       return (
         <>
-          <Text text={'High pri: ' + highPri} />
+          <Text text={'Sync pri: ' + highPri} />
           {', '}
           <Text text={'Normal pri: ' + normalPri} />
         </>
@@ -430,29 +430,29 @@ describe('ReactExpiration', () => {
     await ReactNoop.act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['High pri: 0', 'Normal pri: 0']);
-    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0');
+    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Normal pri: 0']);
+    expect(root).toMatchRenderedOutput('Sync pri: 0, Normal pri: 0');
 
     // First demonstrate what happens when there's no starvation
     await ReactNoop.act(async () => {
       updateNormalPri();
-      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
-      updateHighPri();
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
+      updateSyncPri();
     });
     expect(Scheduler).toHaveYielded([
       // Interrupt high pri update to render sync update
-      'High pri: 1',
+      'Sync pri: 1',
       'Normal pri: 0',
       // Now render normal pri
-      'High pri: 1',
+      'Sync pri: 1',
       'Normal pri: 1',
     ]);
-    expect(root).toMatchRenderedOutput('High pri: 1, Normal pri: 1');
+    expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');
 
     // Do the same thing, but starve the first update
     await ReactNoop.act(async () => {
       updateNormalPri();
-      expect(Scheduler).toFlushAndYieldThrough(['High pri: 1']);
+      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update
       // started rendering. (This should advance time by some number that's
@@ -461,86 +461,16 @@ describe('ReactExpiration', () => {
       Scheduler.unstable_advanceTime(10000);
 
       // So when we get a high pri update, we shouldn't interrupt
-      updateHighPri();
+      updateSyncPri();
     });
     expect(Scheduler).toHaveYielded([
       // Finish normal pri update
       'Normal pri: 2',
       // Then do high pri update
-      'High pri: 2',
-      'Normal pri: 2',
-    ]);
-    expect(root).toMatchRenderedOutput('High pri: 2, Normal pri: 2');
-  });
-
-  it('prevents starvation by sync updates', async () => {
-    const {useState} = React;
-
-    let updateSyncPri;
-    let updateHighPri;
-    function App() {
-      const [syncPri, setSyncPri] = useState(0);
-      const [highPri, setHighPri] = useState(0);
-      updateSyncPri = () => ReactNoop.flushSync(() => setSyncPri(n => n + 1));
-      updateHighPri = () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => setHighPri(n => n + 1),
-        );
-      return (
-        <>
-          <Text text={'Sync pri: ' + syncPri} />
-          {', '}
-          <Text text={'High pri: ' + highPri} />
-        </>
-      );
-    }
-
-    const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
-      root.render(<App />);
-    });
-    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'High pri: 0']);
-    expect(root).toMatchRenderedOutput('Sync pri: 0, High pri: 0');
-
-    // First demonstrate what happens when there's no starvation
-    await ReactNoop.act(async () => {
-      updateHighPri();
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
-      updateSyncPri();
-    });
-    expect(Scheduler).toHaveYielded([
-      // Interrupt high pri update to render sync update
-      'Sync pri: 1',
-      'High pri: 0',
-      // Now render high pri
-      'Sync pri: 1',
-      'High pri: 1',
-    ]);
-    expect(root).toMatchRenderedOutput('Sync pri: 1, High pri: 1');
-
-    // Do the same thing, but starve the first update
-    await ReactNoop.act(async () => {
-      updateHighPri();
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
-
-      // This time, a lot of time has elapsed since the high pri update started
-      // rendering. (This should advance time by some number that's definitely
-      // bigger than the constant heuristic we use to detect starvation of user
-      // interactions, but not as high as the onse used for normal pri updates.)
-      Scheduler.unstable_advanceTime(1500);
-
-      // So when we get a sync update, we shouldn't interrupt
-      updateSyncPri();
-    });
-    expect(Scheduler).toHaveYielded([
-      // Finish high pri update
-      'High pri: 2',
-      // Then do sync update
       'Sync pri: 2',
-      'High pri: 2',
+      'Normal pri: 2',
     ]);
-    expect(root).toMatchRenderedOutput('Sync pri: 2, High pri: 2');
+    expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');
   });
 
   it('idle work never expires', async () => {
@@ -553,10 +483,9 @@ describe('ReactExpiration', () => {
       const [highPri, setIdlePri] = useState(0);
       updateSyncPri = () => ReactNoop.flushSync(() => setSyncPri(n => n + 1));
       updateIdlePri = () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_IdlePriority,
-          () => setIdlePri(n => n + 1),
-        );
+        ReactNoop.idleUpdates(() => {
+          setIdlePri(n => n + 1);
+        });
       return (
         <>
           <Text text={'Sync pri: ' + syncPri} />
@@ -695,11 +624,11 @@ describe('ReactExpiration', () => {
     function App() {
       const [highPri, setHighPri] = useState(0);
       const [normalPri, setNormalPri] = useState(0);
-      updateHighPri = () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => setHighPri(n => n + 1),
-        );
+      updateHighPri = () => {
+        ReactNoop.flushSync(() => {
+          setHighPri(n => n + 1);
+        });
+      };
       updateNormalPri = () => setNormalPri(n => n + 1);
       return (
         <>
@@ -735,20 +664,34 @@ describe('ReactExpiration', () => {
       expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
       // More time goes by. This expires both of the updates just scheduled.
       Scheduler.unstable_advanceTime(10000);
+      expect(Scheduler).toHaveYielded([]);
 
       // Attempt to interrupt with a high pri update.
       updateHighPri();
 
       // Both normal pri updates should have expired.
-      expect(Scheduler).toFlushExpired([
-        'Sibling',
-        // Notice that the high pri update didn't flush yet. Expiring one lane
-        // doesn't affect other lanes. (Unless they are intentionally entangled,
-        // like we do for overlapping transitions that affect the same state.)
-        'High pri: 0',
-        'Normal pri: 2',
-        'Sibling',
-      ]);
+      if (gate(flags => flags.FIXME)) {
+        // The sync update and the expired normal pri updates render in a
+        // single batch.
+        expect(Scheduler).toHaveYielded([
+          'Sibling',
+          'High pri: 1',
+          'Normal pri: 2',
+          'Sibling',
+        ]);
+      } else {
+        expect(Scheduler).toHaveYielded([
+          'Sibling',
+          'High pri: 0',
+          'Normal pri: 2',
+          'Sibling',
+          // TODO: This is the sync update. We should have rendered it in the same
+          // batch as the expired update.
+          'High pri: 1',
+          'Normal pri: 2',
+          'Sibling',
+        ]);
+      }
     });
   });
 

commit c581cdd480f71af6ee87168c72ecabb87b6984c3
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Feb 25 17:25:25 2021 -0500

    Schedule sync updates in microtask (#20872)
    
    * Schedule sync updates in microtask
    
    * Updates from review
    
    * Fix comment

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 017c712bd8..48ff50880f 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -598,12 +598,13 @@ describe('ReactExpiration', () => {
       // second one.
       Scheduler.unstable_advanceTime(1000);
       // Attempt to interrupt with a high pri update.
-      updateHighPri();
+      await ReactNoop.act(async () => {
+        updateHighPri();
+      });
 
-      // The first update expired, so first will finish it without
-      // interrupting. But not the second update, which hasn't expired yet.
-      expect(Scheduler).toFlushExpired(['Sibling']);
-      expect(Scheduler).toFlushAndYield([
+      expect(Scheduler).toHaveYielded([
+        // The first update expired
+        'Sibling',
         // Then render the high pri update
         'High pri: 1',
         'Normal pri: 1',

commit 60182d64ca030ef28782c7e67be373eac81ae4c2
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Wed Mar 10 12:44:25 2021 -0500

    Cleanup tests using runWithPriority. (#20958)
    
    * Remove Scheduler.runWithPriority from some tests
    
    * Mark experimental test experimental

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 48ff50880f..ed49965318 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -550,11 +550,7 @@ describe('ReactExpiration', () => {
     function App() {
       const [highPri, setHighPri] = useState(0);
       const [normalPri, setNormalPri] = useState(0);
-      updateHighPri = () =>
-        Scheduler.unstable_runWithPriority(
-          Scheduler.unstable_UserBlockingPriority,
-          () => setHighPri(n => n + 1),
-        );
+      updateHighPri = () => ReactNoop.flushSync(() => setHighPri(n => n + 1));
       updateNormalPri = () => setNormalPri(n => n + 1);
       return (
         <>

commit be5a2e231ae27b2c64806c026a5b9921be5e7560
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 19 17:28:41 2021 -0500

    Land enableSyncMicrotasks (#20979)

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index ed49965318..cf8b539433 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -103,23 +103,32 @@ describe('ReactExpiration', () => {
     return {type: 'span', children: [], prop, hidden: false};
   }
 
+  function flushNextRenderIfExpired() {
+    // This will start rendering the next level of work. If the work hasn't
+    // expired yet, React will exit without doing anything. If it has expired,
+    // it will schedule a sync task.
+    Scheduler.unstable_flushExpired();
+    // Flush the sync task.
+    ReactNoop.flushSync();
+  }
+
   it('increases priority of updates as time progresses', () => {
     ReactNoop.render(<span prop="done" />);
 
     expect(ReactNoop.getChildren()).toEqual([]);
 
     // Nothing has expired yet because time hasn't advanced.
-    ReactNoop.flushExpired();
+    flushNextRenderIfExpired();
     expect(ReactNoop.getChildren()).toEqual([]);
 
     // Advance time a bit, but not enough to expire the low pri update.
     ReactNoop.expire(4500);
-    ReactNoop.flushExpired();
+    flushNextRenderIfExpired();
     expect(ReactNoop.getChildren()).toEqual([]);
 
     // Advance by another second. Now the update should expire and flush.
-    ReactNoop.expire(1000);
-    ReactNoop.flushExpired();
+    ReactNoop.expire(500);
+    flushNextRenderIfExpired();
     expect(ReactNoop.getChildren()).toEqual([span('done')]);
   });
 
@@ -323,7 +332,8 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    expect(Scheduler).toFlushExpired(['D', 'E']);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
@@ -351,7 +361,8 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    expect(Scheduler).toFlushExpired(['D', 'E']);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
@@ -373,12 +384,14 @@ describe('ReactExpiration', () => {
     ReactNoop.render('Hi');
 
     // The update should not have expired yet.
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
@@ -391,7 +404,8 @@ describe('ReactExpiration', () => {
     Scheduler.unstable_advanceTime(10000);
 
     ReactNoop.render('Hi');
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advancing by ~5 seconds should be sufficient to expire the update. (I
@@ -399,7 +413,8 @@ describe('ReactExpiration', () => {
     Scheduler.unstable_advanceTime(6000);
 
     ReactNoop.render('Hi');
-    expect(Scheduler).toFlushExpired([]);
+    flushNextRenderIfExpired();
+    expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 

commit 05ec0d7646b463dcbd64f3a2575f4bb992f7e423
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 25 11:24:49 2021 -0500

    Entangled expired lanes with SyncLane (#21083)
    
    Makes the implementation simpler. Expiration is now a special case of
    entanglement.
    
    Also fixes an issue where expired lanes weren't batched with normal
    sync updates. (See deleted TODO comment in test.)

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index cf8b539433..5fc98d980e 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -682,28 +682,14 @@ describe('ReactExpiration', () => {
       updateHighPri();
 
       // Both normal pri updates should have expired.
-      if (gate(flags => flags.FIXME)) {
-        // The sync update and the expired normal pri updates render in a
-        // single batch.
-        expect(Scheduler).toHaveYielded([
-          'Sibling',
-          'High pri: 1',
-          'Normal pri: 2',
-          'Sibling',
-        ]);
-      } else {
-        expect(Scheduler).toHaveYielded([
-          'Sibling',
-          'High pri: 0',
-          'Normal pri: 2',
-          'Sibling',
-          // TODO: This is the sync update. We should have rendered it in the same
-          // batch as the expired update.
-          'High pri: 1',
-          'Normal pri: 2',
-          'Sibling',
-        ]);
-      }
+      // The sync update and the expired normal pri updates render in a
+      // single batch.
+      expect(Scheduler).toHaveYielded([
+        'Sibling',
+        'High pri: 1',
+        'Normal pri: 2',
+        'Sibling',
+      ]);
     });
   });
 

commit 933880b4544a83ce54c8a47f348effe725a58843
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Fri Apr 9 19:50:09 2021 -0400

    Make time-slicing opt-in (#21072)
    
    * Add enableSyncDefaultUpdates feature flag
    
    * Add enableSyncDefaultUpdates implementation
    
    * Fix tests
    
    * Switch feature flag to true by default
    
    * Finish concurrent render whenever for non-sync lanes
    
    * Also return DefaultLane with eventLane
    
    * Gate interruption test
    
    * Add continuout native event test
    
    * Fix tests from rebasing main
    
    * Hardcode lanes, remove added export
    
    * Sync forks

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 5fc98d980e..d251bb04f1 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -111,9 +111,15 @@ describe('ReactExpiration', () => {
     // Flush the sync task.
     ReactNoop.flushSync();
   }
-
+  // @gate experimental || !enableSyncDefaultUpdates
   it('increases priority of updates as time progresses', () => {
-    ReactNoop.render(<span prop="done" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<span prop="done" />);
+      });
+    } else {
+      ReactNoop.render(<span prop="done" />);
+    }
 
     expect(ReactNoop.getChildren()).toEqual([]);
 
@@ -132,6 +138,7 @@ describe('ReactExpiration', () => {
     expect(ReactNoop.getChildren()).toEqual([span('done')]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('two updates of like priority in the same event always flush within the same batch', () => {
     class TextClass extends React.Component {
       componentDidMount() {
@@ -154,7 +161,13 @@ describe('ReactExpiration', () => {
 
     // First, show what happens for updates in two separate events.
     // Schedule an update.
-    ReactNoop.render(<TextClass text="A" />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<TextClass text="A" />);
+      });
+    } else {
+      ReactNoop.render(<TextClass text="A" />);
+    }
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
     // Partially flush the first update, then interrupt it.
@@ -184,6 +197,7 @@ describe('ReactExpiration', () => {
     expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it(
     'two updates of like priority in the same event always flush within the ' +
       "same batch, even if there's a sync update in between",
@@ -209,7 +223,13 @@ describe('ReactExpiration', () => {
 
       // First, show what happens for updates in two separate events.
       // Schedule an update.
-      ReactNoop.render(<TextClass text="A" />);
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          ReactNoop.render(<TextClass text="A" />);
+        });
+      } else {
+        ReactNoop.render(<TextClass text="A" />);
+      }
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
       // Partially flush the first update, then interrupt it.
@@ -245,6 +265,7 @@ describe('ReactExpiration', () => {
     },
   );
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('cannot update at the same expiration time that is already rendering', () => {
     const store = {text: 'initial'};
     const subscribers = [];
@@ -281,7 +302,13 @@ describe('ReactExpiration', () => {
     }
 
     // Initial mount
-    ReactNoop.render(<App />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render(<App />);
+      });
+    } else {
+      ReactNoop.render(<App />);
+    }
     expect(Scheduler).toFlushAndYield([
       'initial [A] [render]',
       'initial [B] [render]',
@@ -294,7 +321,13 @@ describe('ReactExpiration', () => {
     ]);
 
     // Partial update
-    subscribers.forEach(s => s.setState({text: '1'}));
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        subscribers.forEach(s => s.setState({text: '1'}));
+      });
+    } else {
+      subscribers.forEach(s => s.setState({text: '1'}));
+    }
     expect(Scheduler).toFlushAndYieldThrough([
       '1 [A] [render]',
       '1 [B] [render]',
@@ -310,6 +343,7 @@ describe('ReactExpiration', () => {
     ]);
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('stops yielding if CPU-bound update takes too long to finish', () => {
     const root = ReactNoop.createRoot();
     function App() {
@@ -324,7 +358,13 @@ describe('ReactExpiration', () => {
       );
     }
 
-    root.render(<App />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        root.render(<App />);
+      });
+    } else {
+      root.render(<App />);
+    }
 
     expect(Scheduler).toFlushAndYieldThrough(['A']);
     expect(Scheduler).toFlushAndYieldThrough(['B']);
@@ -337,6 +377,7 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('root expiration is measured from the time of the first update', () => {
     Scheduler.unstable_advanceTime(10000);
 
@@ -352,8 +393,13 @@ describe('ReactExpiration', () => {
         </>
       );
     }
-
-    root.render(<App />);
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        root.render(<App />);
+      });
+    } else {
+      root.render(<App />);
+    }
 
     expect(Scheduler).toFlushAndYieldThrough(['A']);
     expect(Scheduler).toFlushAndYieldThrough(['B']);
@@ -366,6 +412,7 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('should measure expiration times relative to module initialization', () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.
@@ -381,12 +428,24 @@ describe('ReactExpiration', () => {
     // current time.
     ReactNoop = require('react-noop-renderer');
 
-    ReactNoop.render('Hi');
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render('Hi');
+      });
+    } else {
+      ReactNoop.render('Hi');
+    }
 
     // The update should not have expired yet.
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
-    expect(ReactNoop).toMatchRenderedOutput(null);
+
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      // TODO: Why is this flushed?
+      expect(ReactNoop).toMatchRenderedOutput('Hi');
+    } else {
+      expect(ReactNoop).toMatchRenderedOutput(null);
+    }
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
@@ -395,6 +454,7 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('should measure callback timeout relative to current time, not start-up time', () => {
     // Corresponds to a bugfix: https://github.com/facebook/react/pull/15479
     // The bug wasn't caught by other tests because we use virtual times that
@@ -403,7 +463,13 @@ describe('ReactExpiration', () => {
     // Before scheduling an update, advance the current time.
     Scheduler.unstable_advanceTime(10000);
 
-    ReactNoop.render('Hi');
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.unstable_startTransition(() => {
+        ReactNoop.render('Hi');
+      });
+    } else {
+      ReactNoop.render('Hi');
+    }
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
@@ -418,6 +484,7 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('prevents starvation by sync updates', async () => {
     const {useState} = React;
 
@@ -450,7 +517,13 @@ describe('ReactExpiration', () => {
 
     // First demonstrate what happens when there's no starvation
     await ReactNoop.act(async () => {
-      updateNormalPri();
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          updateNormalPri();
+        });
+      } else {
+        updateNormalPri();
+      }
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
       updateSyncPri();
     });
@@ -466,7 +539,13 @@ describe('ReactExpiration', () => {
 
     // Do the same thing, but starve the first update
     await ReactNoop.act(async () => {
-      updateNormalPri();
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          updateNormalPri();
+        });
+      } else {
+        updateNormalPri();
+      }
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update
@@ -628,6 +707,7 @@ describe('ReactExpiration', () => {
     });
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('detects starvation in multiple batches', async () => {
     const {useState} = React;
 
@@ -666,7 +746,13 @@ describe('ReactExpiration', () => {
 
     await ReactNoop.act(async () => {
       // Partially render an update
-      updateNormalPri();
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          updateNormalPri();
+        });
+      } else {
+        updateNormalPri();
+      }
       expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
       // Some time goes by. In an interleaved event, schedule another update.
       // This will be placed into a separate batch.
@@ -693,6 +779,7 @@ describe('ReactExpiration', () => {
     });
   });
 
+  // @gate experimental || !enableSyncDefaultUpdates
   it('updates do not expire while they are IO-bound', async () => {
     const {Suspense} = React;
 
@@ -715,7 +802,13 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('A, Sibling');
 
     await ReactNoop.act(async () => {
-      root.render(<App text="B" />);
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.unstable_startTransition(() => {
+          root.render(<App text="B" />);
+        });
+      } else {
+        root.render(<App text="B" />);
+      }
       expect(Scheduler).toFlushAndYield([
         'Suspend! [B]',
         'Sibling',

commit ef37d55b68ddc45d465b84ea2ce30e8328297b2d
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Apr 21 10:29:31 2021 -0500

    Use performConcurrentWorkOnRoot for "sync default" (#21322)
    
    Instead of `performSyncWorkOnRoot`.
    
    The conceptual model is that the only difference between sync default
    updates (in React 18) and concurrent default updates (in a future major
    release) is time slicing. All other behavior should be the same
    (i.e. the stuff in `finishConcurrentRender`).
    
    Given this, I think it makes more sense to model the implementation this
    way, too. This exposed a quirk in the previous implementation where
    non-sync work was sometimes mistaken for sync work and flushed too
    early. In the new implementation, `performSyncWorkOnRoot` is only used
    for truly synchronous renders (i.e. `SyncLane`), which should make these
    mistakes less common.
    
    Fixes most of the tests marked with TODOs from #21072.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index d251bb04f1..4c89c341c6 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -440,12 +440,7 @@ describe('ReactExpiration', () => {
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      // TODO: Why is this flushed?
-      expect(ReactNoop).toMatchRenderedOutput('Hi');
-    } else {
-      expect(ReactNoop).toMatchRenderedOutput(null);
-    }
+    expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
@@ -477,8 +472,6 @@ describe('ReactExpiration', () => {
     // Advancing by ~5 seconds should be sufficient to expire the update. (I
     // used a slightly larger number to allow for possible rounding.)
     Scheduler.unstable_advanceTime(6000);
-
-    ReactNoop.render('Hi');
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');

commit 48740429b4a74e984193e4e2d364d461e4fdc3be
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Apr 24 18:32:48 2021 -0500

    Expiration: Do nothing except disable time slicing (#21345)
    
    We have a feature called "expiration" whose purpose is to prevent
    a concurrent update from being starved by higher priority events.
    If a lane is CPU-bound for too long, we finish the rest of the work
    synchronously without allowing further interruptions.
    
    In the current implementation, we do this in sort of a roundabout way:
    once a lane is determined to have expired, we entangle it with SyncLane
    and switch to the synchronous work loop.
    
    There are a few flaws with the approach. One is that SyncLane has a
    particular semantic meaning besides its non-yieldiness. For example,
    `flushSync` will force remaining Sync work to finish; currently, that
    also includes expired work, which isn't an intended behavior, but rather
    an artifact of the implementation.
    
    An event worse example is that passive effects triggered by a Sync
    update are flushed synchronously, before paint, so that its result
    is guaranteed to be observed by the next discrete event. But expired
    work has no such requirement: we're flushing expired effects before
    paint unnecessarily.
    
    Aside from the behaviorial implications, the current implementation has
    proven to be fragile: more than once, we've accidentally regressed
    performance due to a subtle change in how expiration is handled.
    
    This PR aims to radically simplify how we model starvation protection by
    scaling back the implementation as much as possible. In this new model,
    if a lane is expired, we disable time slicing. That's it. We don't
    entangle it with SyncLane. The only thing we do is skip the call to
    `shouldYield` in between each time slice. This is identical to how we
    model synchronous-by-default updates in React 18.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 4c89c341c6..885ee46e14 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -15,6 +15,8 @@ let Scheduler;
 let readText;
 let resolveText;
 let startTransition;
+let useState;
+let useEffect;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
@@ -24,6 +26,8 @@ describe('ReactExpiration', () => {
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
     startTransition = React.unstable_startTransition;
+    useState = React.useState;
+    useEffect = React.useEffect;
 
     const textCache = new Map();
 
@@ -478,9 +482,7 @@ describe('ReactExpiration', () => {
   });
 
   // @gate experimental || !enableSyncDefaultUpdates
-  it('prevents starvation by sync updates', async () => {
-    const {useState} = React;
-
+  it('prevents starvation by sync updates by disabling time slicing if too much time has elapsed', async () => {
     let updateSyncPri;
     let updateNormalPri;
     function App() {
@@ -519,15 +521,17 @@ describe('ReactExpiration', () => {
       }
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
       updateSyncPri();
+      expect(Scheduler).toHaveYielded(['Sync pri: 1', 'Normal pri: 0']);
+
+      // The remaining work hasn't expired, so the render phase is time sliced.
+      // In other words, we can flush just the first child without flushing
+      // the rest.
+      Scheduler.unstable_flushNumberOfYields(1);
+      // Yield right after first child.
+      expect(Scheduler).toHaveYielded(['Sync pri: 1']);
+      // Now do the rest.
+      expect(Scheduler).toFlushAndYield(['Normal pri: 1']);
     });
-    expect(Scheduler).toHaveYielded([
-      // Interrupt high pri update to render sync update
-      'Sync pri: 1',
-      'Normal pri: 0',
-      // Now render normal pri
-      'Sync pri: 1',
-      'Normal pri: 1',
-    ]);
     expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');
 
     // Do the same thing, but starve the first update
@@ -547,22 +551,18 @@ describe('ReactExpiration', () => {
       // starvation of normal priority updates.)
       Scheduler.unstable_advanceTime(10000);
 
-      // So when we get a high pri update, we shouldn't interrupt
       updateSyncPri();
+      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 1']);
+
+      // The remaining work _has_ expired, so the render phase is _not_ time
+      // sliced. Attempting to flush just the first child also flushes the rest.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 2']);
     });
-    expect(Scheduler).toHaveYielded([
-      // Finish normal pri update
-      'Normal pri: 2',
-      // Then do high pri update
-      'Sync pri: 2',
-      'Normal pri: 2',
-    ]);
     expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');
   });
 
   it('idle work never expires', async () => {
-    const {useState} = React;
-
     let updateSyncPri;
     let updateIdlePri;
     function App() {
@@ -629,23 +629,19 @@ describe('ReactExpiration', () => {
   });
 
   // @gate experimental
-  it('a single update can expire without forcing all other updates to expire', async () => {
-    const {useState} = React;
-
-    let updateHighPri;
-    let updateNormalPri;
+  it('when multiple lanes expire, we can finish the in-progress one without including the others', async () => {
+    let setA;
+    let setB;
     function App() {
-      const [highPri, setHighPri] = useState(0);
-      const [normalPri, setNormalPri] = useState(0);
-      updateHighPri = () => ReactNoop.flushSync(() => setHighPri(n => n + 1));
-      updateNormalPri = () => setNormalPri(n => n + 1);
+      const [a, _setA] = useState(0);
+      const [b, _setB] = useState(0);
+      setA = _setA;
+      setB = _setB;
       return (
         <>
-          <Text text={'High pri: ' + highPri} />
-          {', '}
-          <Text text={'Normal pri: ' + normalPri} />
-          {', '}
-          <Text text="Sibling" />
+          <Text text={'A' + a} />
+          <Text text={'B' + b} />
+          <Text text="C" />
         </>
       );
     }
@@ -654,184 +650,168 @@ describe('ReactExpiration', () => {
     await ReactNoop.act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded([
-      'High pri: 0',
-      'Normal pri: 0',
-      'Sibling',
-    ]);
-    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0, Sibling');
+    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C']);
+    expect(root).toMatchRenderedOutput('A0B0C');
 
     await ReactNoop.act(async () => {
-      // Partially render an update
       startTransition(() => {
-        updateNormalPri();
+        setA(1);
       });
-      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
-
-      // Some time goes by. Schedule another update.
-      // This will be placed into a separate batch.
-      Scheduler.unstable_advanceTime(4000);
-
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
       startTransition(() => {
-        updateNormalPri();
-      });
-      // Keep rendering the first update
-      expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
-      // More time goes by. Enough to expire the first batch, but not the
-      // second one.
-      Scheduler.unstable_advanceTime(1000);
-      // Attempt to interrupt with a high pri update.
-      await ReactNoop.act(async () => {
-        updateHighPri();
+        setB(1);
       });
-
-      expect(Scheduler).toHaveYielded([
-        // The first update expired
-        'Sibling',
-        // Then render the high pri update
-        'High pri: 1',
-        'Normal pri: 1',
-        'Sibling',
-        // Then the second normal pri update
-        'High pri: 1',
-        'Normal pri: 2',
-        'Sibling',
-      ]);
+      // Expire both the transitions
+      Scheduler.unstable_advanceTime(10000);
+      // Both transitions have expired, but since they aren't related
+      // (entangled), we should be able to finish the in-progress transition
+      // without also including the next one.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['B0', 'C']);
+      expect(root).toMatchRenderedOutput('A1B0C');
+
+      // The next transition also finishes without yielding.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C']);
+      expect(root).toMatchRenderedOutput('A1B1C');
     });
   });
 
   // @gate experimental || !enableSyncDefaultUpdates
-  it('detects starvation in multiple batches', async () => {
-    const {useState} = React;
+  it('updates do not expire while they are IO-bound', async () => {
+    const {Suspense} = React;
 
-    let updateHighPri;
-    let updateNormalPri;
-    function App() {
-      const [highPri, setHighPri] = useState(0);
-      const [normalPri, setNormalPri] = useState(0);
-      updateHighPri = () => {
-        ReactNoop.flushSync(() => {
-          setHighPri(n => n + 1);
-        });
-      };
-      updateNormalPri = () => setNormalPri(n => n + 1);
+    function App({step}) {
       return (
-        <>
-          <Text text={'High pri: ' + highPri} />
-          {', '}
-          <Text text={'Normal pri: ' + normalPri} />
-          {', '}
-          <Text text="Sibling" />
-        </>
+        <Suspense fallback={<Text text="Loading..." />}>
+          <AsyncText text={'A' + step} />
+          <Text text="B" />
+          <Text text="C" />
+        </Suspense>
       );
     }
 
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
-      root.render(<App />);
+      await resolveText('A0');
+      root.render(<App step={0} />);
     });
-    expect(Scheduler).toHaveYielded([
-      'High pri: 0',
-      'Normal pri: 0',
-      'Sibling',
-    ]);
-    expect(root).toMatchRenderedOutput('High pri: 0, Normal pri: 0, Sibling');
+    expect(Scheduler).toHaveYielded(['A0', 'B', 'C']);
+    expect(root).toMatchRenderedOutput('A0BC');
 
     await ReactNoop.act(async () => {
-      // Partially render an update
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.unstable_startTransition(() => {
-          updateNormalPri();
+          root.render(<App step={1} />);
         });
       } else {
-        updateNormalPri();
+        root.render(<App step={1} />);
       }
-      expect(Scheduler).toFlushAndYieldThrough(['High pri: 0']);
-      // Some time goes by. In an interleaved event, schedule another update.
-      // This will be placed into a separate batch.
-      Scheduler.unstable_advanceTime(4000);
-      updateNormalPri();
-      // Keep rendering the first update
-      expect(Scheduler).toFlushAndYieldThrough(['Normal pri: 1']);
-      // More time goes by. This expires both of the updates just scheduled.
+      expect(Scheduler).toFlushAndYield([
+        'Suspend! [A1]',
+        'B',
+        'C',
+        'Loading...',
+      ]);
+
+      // Lots of time elapses before the promise resolves
       Scheduler.unstable_advanceTime(10000);
-      expect(Scheduler).toHaveYielded([]);
+      await resolveText('A1');
+      expect(Scheduler).toHaveYielded(['Promise resolved [A1]']);
 
-      // Attempt to interrupt with a high pri update.
-      updateHighPri();
-
-      // Both normal pri updates should have expired.
-      // The sync update and the expired normal pri updates render in a
-      // single batch.
-      expect(Scheduler).toHaveYielded([
-        'Sibling',
-        'High pri: 1',
-        'Normal pri: 2',
-        'Sibling',
-      ]);
+      // But the update doesn't expire, because it was IO bound. So we can
+      // partially rendering without finishing.
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+      expect(root).toMatchRenderedOutput('A0BC');
+
+      // Lots more time elapses. We're CPU-bound now, so we should treat this
+      // as starvation.
+      Scheduler.unstable_advanceTime(10000);
+
+      // The rest of the update finishes without yielding.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['B', 'C']);
     });
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
-  it('updates do not expire while they are IO-bound', async () => {
-    const {Suspense} = React;
-
-    function App({text}) {
+  // @gate experimental
+  it('flushSync should not affect expired work', async () => {
+    let setA;
+    let setB;
+    function App() {
+      const [a, _setA] = useState(0);
+      const [b, _setB] = useState(0);
+      setA = _setA;
+      setB = _setB;
       return (
-        <Suspense fallback={<Text text="Loading..." />}>
-          <AsyncText text={text} />
-          {', '}
-          <Text text="Sibling" />
-        </Suspense>
+        <>
+          <Text text={'A' + a} />
+          <Text text={'B' + b} />
+        </>
       );
     }
 
     const root = ReactNoop.createRoot();
     await ReactNoop.act(async () => {
-      await resolveText('A');
-      root.render(<App text="A" />);
+      root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['A', 'Sibling']);
-    expect(root).toMatchRenderedOutput('A, Sibling');
+    expect(Scheduler).toHaveYielded(['A0', 'B0']);
 
     await ReactNoop.act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
-          root.render(<App text="B" />);
-        });
-      } else {
-        root.render(<App text="B" />);
-      }
-      expect(Scheduler).toFlushAndYield([
-        'Suspend! [B]',
-        'Sibling',
-        'Loading...',
-      ]);
+      startTransition(() => {
+        setA(1);
+      });
+      expect(Scheduler).toFlushAndYieldThrough(['A1']);
 
-      // Lots of time elapses before the promise resolves
+      // Expire the in-progress update
       Scheduler.unstable_advanceTime(10000);
-      await resolveText('B');
-      expect(Scheduler).toHaveYielded(['Promise resolved [B]']);
 
-      // But the update doesn't expire, because it was IO bound. So we can
-      // partially rendering without finishing.
-      expect(Scheduler).toFlushAndYieldThrough(['B']);
-      expect(root).toMatchRenderedOutput('A, Sibling');
+      ReactNoop.flushSync(() => {
+        setB(1);
+      });
+      expect(Scheduler).toHaveYielded(['A0', 'B1']);
 
-      // Lots more time elapses. We're CPU-bound now, so we should treat this
-      // as starvation.
+      // Now flush the original update. Because it expired, it should finish
+      // without yielding.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['A1', 'B1']);
+    });
+  });
+
+  // @gate experimental
+  it('passive effects of expired update flush after paint', async () => {
+    function App({step}) {
+      useEffect(() => {
+        Scheduler.unstable_yieldValue('Effect: ' + step);
+      }, [step]);
+      return (
+        <>
+          <Text text={'A' + step} />
+          <Text text={'B' + step} />
+          <Text text={'C' + step} />
+        </>
+      );
+    }
+
+    const root = ReactNoop.createRoot();
+    await ReactNoop.act(async () => {
+      root.render(<App step={0} />);
+    });
+    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C0', 'Effect: 0']);
+    expect(root).toMatchRenderedOutput('A0B0C0');
+
+    await ReactNoop.act(async () => {
+      startTransition(() => {
+        root.render(<App step={1} />);
+      });
+      // Expire the update
       Scheduler.unstable_advanceTime(10000);
 
-      // Attempt to interrupt with a sync update.
-      ReactNoop.flushSync(() => root.render(<App text="A" />));
-      expect(Scheduler).toHaveYielded([
-        // Because the previous update had already expired, we don't interrupt
-        // it. Finish rendering it first.
-        'Sibling',
-        // Then do the sync update.
-        'A',
-        'Sibling',
-      ]);
+      // The update finishes without yielding. But it does not flush the effect.
+      Scheduler.unstable_flushNumberOfYields(1);
+      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C1']);
     });
+    // The effect flushes after paint.
+    expect(Scheduler).toHaveYielded(['Effect: 1']);
   });
 });

commit 2bf4805e4bd63dab45cd7f5e1ad32ef8fed3f6ab
Author: Brian Vaughn <bvaughn@fb.com>
Date:   Wed May 12 11:28:14 2021 -0400

    Update entry point exports (#21488)
    
    The following APIs have been added to the `react` stable entry point:
    * `SuspenseList`
    * `startTransition`
    * `unstable_createMutableSource`
    * `unstable_useMutableSource`
    * `useDeferredValue`
    * `useTransition`
    
    The following APIs have been added or removed from the `react-dom` stable entry point:
    * `createRoot`
    * `unstable_createPortal` (removed)
    
    The following APIs have been added to the `react-is` stable entry point:
    * `SuspenseList`
    * `isSuspenseList`
    
    The following feature flags have been changed from experimental to true:
    * `enableLazyElements`
    * `enableSelectiveHydration`
    * `enableSuspenseServerRenderer`

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 885ee46e14..8497aa6c9e 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -25,7 +25,7 @@ describe('ReactExpiration', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
-    startTransition = React.unstable_startTransition;
+    startTransition = React.startTransition;
     useState = React.useState;
     useEffect = React.useEffect;
 
@@ -115,10 +115,10 @@ describe('ReactExpiration', () => {
     // Flush the sync task.
     ReactNoop.flushSync();
   }
-  // @gate experimental || !enableSyncDefaultUpdates
+
   it('increases priority of updates as time progresses', () => {
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<span prop="done" />);
       });
     } else {
@@ -142,7 +142,6 @@ describe('ReactExpiration', () => {
     expect(ReactNoop.getChildren()).toEqual([span('done')]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('two updates of like priority in the same event always flush within the same batch', () => {
     class TextClass extends React.Component {
       componentDidMount() {
@@ -166,7 +165,7 @@ describe('ReactExpiration', () => {
     // First, show what happens for updates in two separate events.
     // Schedule an update.
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<TextClass text="A" />);
       });
     } else {
@@ -201,7 +200,6 @@ describe('ReactExpiration', () => {
     expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it(
     'two updates of like priority in the same event always flush within the ' +
       "same batch, even if there's a sync update in between",
@@ -228,7 +226,7 @@ describe('ReactExpiration', () => {
       // First, show what happens for updates in two separate events.
       // Schedule an update.
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           ReactNoop.render(<TextClass text="A" />);
         });
       } else {
@@ -269,7 +267,6 @@ describe('ReactExpiration', () => {
     },
   );
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('cannot update at the same expiration time that is already rendering', () => {
     const store = {text: 'initial'};
     const subscribers = [];
@@ -307,7 +304,7 @@ describe('ReactExpiration', () => {
 
     // Initial mount
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render(<App />);
       });
     } else {
@@ -326,7 +323,7 @@ describe('ReactExpiration', () => {
 
     // Partial update
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         subscribers.forEach(s => s.setState({text: '1'}));
       });
     } else {
@@ -347,7 +344,6 @@ describe('ReactExpiration', () => {
     ]);
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('stops yielding if CPU-bound update takes too long to finish', () => {
     const root = ReactNoop.createRoot();
     function App() {
@@ -363,7 +359,7 @@ describe('ReactExpiration', () => {
     }
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         root.render(<App />);
       });
     } else {
@@ -381,7 +377,6 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('root expiration is measured from the time of the first update', () => {
     Scheduler.unstable_advanceTime(10000);
 
@@ -398,7 +393,7 @@ describe('ReactExpiration', () => {
       );
     }
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         root.render(<App />);
       });
     } else {
@@ -416,7 +411,6 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('should measure expiration times relative to module initialization', () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.
@@ -433,7 +427,7 @@ describe('ReactExpiration', () => {
     ReactNoop = require('react-noop-renderer');
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render('Hi');
       });
     } else {
@@ -453,7 +447,6 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('should measure callback timeout relative to current time, not start-up time', () => {
     // Corresponds to a bugfix: https://github.com/facebook/react/pull/15479
     // The bug wasn't caught by other tests because we use virtual times that
@@ -463,7 +456,7 @@ describe('ReactExpiration', () => {
     Scheduler.unstable_advanceTime(10000);
 
     if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.unstable_startTransition(() => {
+      React.startTransition(() => {
         ReactNoop.render('Hi');
       });
     } else {
@@ -481,7 +474,6 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('prevents starvation by sync updates by disabling time slicing if too much time has elapsed', async () => {
     let updateSyncPri;
     let updateNormalPri;
@@ -513,7 +505,7 @@ describe('ReactExpiration', () => {
     // First demonstrate what happens when there's no starvation
     await ReactNoop.act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           updateNormalPri();
         });
       } else {
@@ -537,7 +529,7 @@ describe('ReactExpiration', () => {
     // Do the same thing, but starve the first update
     await ReactNoop.act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           updateNormalPri();
         });
       } else {
@@ -628,7 +620,6 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('Sync pri: 2, Idle pri: 2');
   });
 
-  // @gate experimental
   it('when multiple lanes expire, we can finish the in-progress one without including the others', async () => {
     let setA;
     let setB;
@@ -677,7 +668,6 @@ describe('ReactExpiration', () => {
     });
   });
 
-  // @gate experimental || !enableSyncDefaultUpdates
   it('updates do not expire while they are IO-bound', async () => {
     const {Suspense} = React;
 
@@ -701,7 +691,7 @@ describe('ReactExpiration', () => {
 
     await ReactNoop.act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.unstable_startTransition(() => {
+        React.startTransition(() => {
           root.render(<App step={1} />);
         });
       } else {
@@ -734,7 +724,6 @@ describe('ReactExpiration', () => {
     });
   });
 
-  // @gate experimental
   it('flushSync should not affect expired work', async () => {
     let setA;
     let setB;
@@ -778,7 +767,6 @@ describe('ReactExpiration', () => {
     });
   });
 
-  // @gate experimental
   it('passive effects of expired update flush after paint', async () => {
     function App({step}) {
       useEffect(() => {

commit d7dce572c7453737a685e791e7afcbc7e2b2fe16
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Jun 22 17:29:35 2021 -0400

    Remove internal `act` builds from public modules (#21721)
    
    * Move internal version of act to shared module
    
    No reason to have three different copies of this anymore.
    
    I've left the the renderer-specific `act` entry points because legacy
    mode tests need to also be wrapped in `batchedUpdates`. Next, I'll update
    the tests to use `batchedUpdates` manually when needed.
    
    * Migrates tests to use internal module directly
    
    Instead of the `unstable_concurrentAct` exports. Now we can drop those
    from the public builds.
    
    I put it in the jest-react package since that's where we put our other
    testing utilities (like `toFlushAndYield`). Not so much so it can be
    consumed publicly (nobody uses that package except us), but so it works
    with our build tests.
    
    * Remove unused internal fields
    
    These were used by the old act implementation. No longer needed.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 8497aa6c9e..202348a21b 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -12,6 +12,7 @@
 let React;
 let ReactNoop;
 let Scheduler;
+let act;
 let readText;
 let resolveText;
 let startTransition;
@@ -25,6 +26,7 @@ describe('ReactExpiration', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+    act = require('jest-react').act;
     startTransition = React.startTransition;
     useState = React.useState;
     useEffect = React.useEffect;
@@ -496,14 +498,14 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Normal pri: 0']);
     expect(root).toMatchRenderedOutput('Sync pri: 0, Normal pri: 0');
 
     // First demonstrate what happens when there's no starvation
-    await ReactNoop.act(async () => {
+    await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           updateNormalPri();
@@ -527,7 +529,7 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');
 
     // Do the same thing, but starve the first update
-    await ReactNoop.act(async () => {
+    await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           updateNormalPri();
@@ -575,14 +577,14 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Idle pri: 0']);
     expect(root).toMatchRenderedOutput('Sync pri: 0, Idle pri: 0');
 
     // First demonstrate what happens when there's no starvation
-    await ReactNoop.act(async () => {
+    await act(async () => {
       updateIdlePri();
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
       updateSyncPri();
@@ -598,7 +600,7 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('Sync pri: 1, Idle pri: 1');
 
     // Do the same thing, but starve the first update
-    await ReactNoop.act(async () => {
+    await act(async () => {
       updateIdlePri();
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
 
@@ -638,13 +640,13 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['A0', 'B0', 'C']);
     expect(root).toMatchRenderedOutput('A0B0C');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         setA(1);
       });
@@ -682,14 +684,14 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       await resolveText('A0');
       root.render(<App step={0} />);
     });
     expect(Scheduler).toHaveYielded(['A0', 'B', 'C']);
     expect(root).toMatchRenderedOutput('A0BC');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       if (gate(flags => flags.enableSyncDefaultUpdates)) {
         React.startTransition(() => {
           root.render(<App step={1} />);
@@ -741,12 +743,12 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App />);
     });
     expect(Scheduler).toHaveYielded(['A0', 'B0']);
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         setA(1);
       });
@@ -782,13 +784,13 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await ReactNoop.act(async () => {
+    await act(async () => {
       root.render(<App step={0} />);
     });
     expect(Scheduler).toHaveYielded(['A0', 'B0', 'C0', 'Effect: 0']);
     expect(root).toMatchRenderedOutput('A0B0C0');
 
-    await ReactNoop.act(async () => {
+    await act(async () => {
       startTransition(() => {
         root.render(<App step={1} />);
       });

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 202348a21b..24127589df 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 5379b6123f171bb48cc8a9c435c11ccb9f8ff0e7
Author: Tianyu Yao <skyyao@fb.com>
Date:   Thu Jan 5 15:21:35 2023 -0800

    Batch sync, default and continuous lanes (#25700)
    
    <!--
      Thanks for submitting a pull request!
    We appreciate you spending the time to work on these changes. Please
    provide enough information so that others can review your pull request.
    The three fields below are mandatory.
    
    Before submitting a pull request, please make sure the following is
    done:
    
    1. Fork [the repository](https://github.com/facebook/react) and create
    your branch from `main`.
      2. Run `yarn` in the repository root.
    3. If you've fixed a bug or added code that should be tested, add tests!
    4. Ensure the test suite passes (`yarn test`). Tip: `yarn test --watch
    TestName` is helpful in development.
    5. Run `yarn test --prod` to test in the production environment. It
    supports the same options as `yarn test`.
    6. If you need a debugger, run `yarn debug-test --watch TestName`, open
    `chrome://inspect`, and press "Inspect".
    7. Format your code with
    [prettier](https://github.com/prettier/prettier) (`yarn prettier`).
    8. Make sure your code lints (`yarn lint`). Tip: `yarn linc` to only
    check changed files.
      9. Run the [Flow](https://flowtype.org/) type checks (`yarn flow`).
      10. If you haven't already, complete the CLA.
    
    Learn more about contributing:
    https://reactjs.org/docs/how-to-contribute.html
    -->
    
    ## Summary
    
    <!--
    Explain the **motivation** for making this change. What existing problem
    does the pull request solve?
    -->
    This is the other approach for unifying default and sync lane
    https://github.com/facebook/react/pull/25524.
    The approach in that PR is to merge default and continuous lane into the
    sync lane, and use a new field to track the priority. But there are a
    couple places that field will be needed, and it is difficult to
    correctly reset the field when there is no sync lane.
    
    In this PR we take the other approach that doesn't remove any lane, but
    batch them to get the behavior we want.
    
    
    ## How did you test this change?
    
    <!--
    Demonstrate the code is solid. Example: The exact commands you ran and
    their output, screenshots / videos if the pull request changes the user
    interface.
    How exactly did you verify that your PR solves the issue you wanted to
    solve?
      If you leave this empty, your PR will very likely be closed.
    -->
    yarn test
    
    Co-authored-by: Andrew Clark <hi@andrewclark.io>

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 24127589df..72ca257fef 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -339,7 +339,9 @@ describe('ReactExpiration', () => {
     // Before the update can finish, update again. Even though no time has
     // advanced, this update should be given a different expiration time than
     // the currently rendering one. So, C and D should render with 1, not 2.
-    subscribers.forEach(s => s.setState({text: '2'}));
+    React.startTransition(() => {
+      subscribers.forEach(s => s.setState({text: '2'}));
+    });
     expect(Scheduler).toFlushAndYieldThrough([
       '1 [C] [render]',
       '1 [D] [render]',

commit 3ff1540e9bbe30aae52e2c9ab61c843bd0c94237
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Feb 9 11:54:35 2023 +0100

    Prefer JSX in ReactNoop assertions (to combat out-of-memory test runs) (#26127)
    
    ## Summary
    
    Prefer `getChildrenAsJSX` or `toMatchRenderedOutput` over `getChildren`.
    Use `dangerouslyGetChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    Prefer `getPendingChildrenAsJSX` over `getPendingChildren`. Use
    `dangerouslyGetPendingChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    `ReactNoop.getChildren` contains the fibers as non-enumerable
    properties. If you pass the children to `toEqual` and have a mismatch,
    Jest performance is very poor (to the point of causing out-of-memory
    crashes e.g.
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624297/parallel-runs/5?filterBy=ALL&invite=true#step-106-27).
    Mismatches can sometimes be intended e.g. on gated tests.
    
    Instead, I converted almost all of the `toEqual` assertions to
    `toMatchRenderedOutput` assertions or compare the JSX instead. For
    ReactNoopPersistent we still use `getChildren` since we have assertions
    on referential equality. `toMatchRenderedOutput` is more accurate in
    some instances anyway. I highlighted some of those more accurate
    assertions in review-comments.
    
    ## How did you test this change?
    
    - [x] `CIRCLE_NODE_TOTAL=20 CIRCLE_NODE_INDEX=5 yarn test
    -r=experimental --env=development --ci`: Can take up to 350s (and use up
    to 7GB of memory) on `main` but 11s on this branch
    - [x] No more slow `yarn test` parallel runs of `yarn_test` jobs (the
    steps in these runs should take <1min but sometimes they take 3min and
    end with OOM like
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624258/parallel-runs/5?filterBy=ALL:
    Looks good with a sample size of 1
    https://app.circleci.com/pipelines/github/facebook/react/38110/workflows/745109a2-b86b-429f-8c01-9b23a245417a/jobs/624651

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 72ca257fef..7b96efc2b9 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -105,10 +105,6 @@ describe('ReactExpiration', () => {
     }
   }
 
-  function span(prop) {
-    return {type: 'span', children: [], prop, hidden: false};
-  }
-
   function flushNextRenderIfExpired() {
     // This will start rendering the next level of work. If the work hasn't
     // expired yet, React will exit without doing anything. If it has expired,
@@ -127,21 +123,21 @@ describe('ReactExpiration', () => {
       ReactNoop.render(<span prop="done" />);
     }
 
-    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Nothing has expired yet because time hasn't advanced.
     flushNextRenderIfExpired();
-    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advance time a bit, but not enough to expire the low pri update.
     ReactNoop.expire(4500);
     flushNextRenderIfExpired();
-    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advance by another second. Now the update should expire and flush.
     ReactNoop.expire(500);
     flushNextRenderIfExpired();
-    expect(ReactNoop.getChildren()).toEqual([span('done')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
   });
 
   it('two updates of like priority in the same event always flush within the same batch', () => {
@@ -181,20 +177,20 @@ describe('ReactExpiration', () => {
 
     // Don't advance time by enough to expire the first update.
     expect(Scheduler).toHaveYielded([]);
-    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
     // Both updates are batched
     expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
-    expect(ReactNoop.getChildren()).toEqual([span('B')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
     // Now do the same thing again, except this time don't flush any work in
     // between the two updates.
     ReactNoop.render(<TextClass text="A" />);
     Scheduler.unstable_advanceTime(2000);
     expect(Scheduler).toHaveYielded([]);
-    expect(ReactNoop.getChildren()).toEqual([span('B')]);
+    expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
     // The updates should flush in the same batch, since as far as the scheduler
@@ -242,20 +238,20 @@ describe('ReactExpiration', () => {
 
       // Don't advance time by enough to expire the first update.
       expect(Scheduler).toHaveYielded([]);
-      expect(ReactNoop.getChildren()).toEqual([]);
+      expect(ReactNoop).toMatchRenderedOutput(null);
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
       // Both updates are batched
       expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
-      expect(ReactNoop.getChildren()).toEqual([span('B')]);
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
       // Now do the same thing again, except this time don't flush any work in
       // between the two updates.
       ReactNoop.render(<TextClass text="A" />);
       Scheduler.unstable_advanceTime(2000);
       expect(Scheduler).toHaveYielded([]);
-      expect(ReactNoop.getChildren()).toEqual([span('B')]);
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
       // Perform some synchronous work. The scheduler must assume we're inside
       // the same event.

commit b2ae9ddb3b497d16a7c27c051da1827d08871138
Author: Jan Kassens <jkassens@meta.com>
Date:   Mon Feb 27 14:04:02 2023 -0500

    Cleanup enableSyncDefaultUpdate flag (#26236)
    
    This feature flag is enabled everywhere.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 7b96efc2b9..fb041f948f 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -115,13 +115,9 @@ describe('ReactExpiration', () => {
   }
 
   it('increases priority of updates as time progresses', () => {
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<span prop="done" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<span prop="done" />);
-    }
+    });
 
     expect(ReactNoop).toMatchRenderedOutput(null);
 
@@ -162,13 +158,9 @@ describe('ReactExpiration', () => {
 
     // First, show what happens for updates in two separate events.
     // Schedule an update.
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<TextClass text="A" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<TextClass text="A" />);
-    }
+    });
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
     // Partially flush the first update, then interrupt it.
@@ -223,13 +215,9 @@ describe('ReactExpiration', () => {
 
       // First, show what happens for updates in two separate events.
       // Schedule an update.
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          ReactNoop.render(<TextClass text="A" />);
-        });
-      } else {
+      React.startTransition(() => {
         ReactNoop.render(<TextClass text="A" />);
-      }
+      });
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
       // Partially flush the first update, then interrupt it.
@@ -301,13 +289,9 @@ describe('ReactExpiration', () => {
     }
 
     // Initial mount
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<App />);
-    }
+    });
     expect(Scheduler).toFlushAndYield([
       'initial [A] [render]',
       'initial [B] [render]',
@@ -320,13 +304,9 @@ describe('ReactExpiration', () => {
     ]);
 
     // Partial update
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        subscribers.forEach(s => s.setState({text: '1'}));
-      });
-    } else {
+    React.startTransition(() => {
       subscribers.forEach(s => s.setState({text: '1'}));
-    }
+    });
     expect(Scheduler).toFlushAndYieldThrough([
       '1 [A] [render]',
       '1 [B] [render]',
@@ -358,13 +338,9 @@ describe('ReactExpiration', () => {
       );
     }
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        root.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       root.render(<App />);
-    }
+    });
 
     expect(Scheduler).toFlushAndYieldThrough(['A']);
     expect(Scheduler).toFlushAndYieldThrough(['B']);
@@ -392,13 +368,9 @@ describe('ReactExpiration', () => {
         </>
       );
     }
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        root.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       root.render(<App />);
-    }
+    });
 
     expect(Scheduler).toFlushAndYieldThrough(['A']);
     expect(Scheduler).toFlushAndYieldThrough(['B']);
@@ -426,13 +398,9 @@ describe('ReactExpiration', () => {
     // current time.
     ReactNoop = require('react-noop-renderer');
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render('Hi');
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render('Hi');
-    }
+    });
 
     // The update should not have expired yet.
     flushNextRenderIfExpired();
@@ -455,13 +423,9 @@ describe('ReactExpiration', () => {
     // Before scheduling an update, advance the current time.
     Scheduler.unstable_advanceTime(10000);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render('Hi');
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render('Hi');
-    }
+    });
     flushNextRenderIfExpired();
     expect(Scheduler).toHaveYielded([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
@@ -504,13 +468,9 @@ describe('ReactExpiration', () => {
 
     // First demonstrate what happens when there's no starvation
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          updateNormalPri();
-        });
-      } else {
+      React.startTransition(() => {
         updateNormalPri();
-      }
+      });
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
       updateSyncPri();
       expect(Scheduler).toHaveYielded(['Sync pri: 1', 'Normal pri: 0']);
@@ -528,13 +488,9 @@ describe('ReactExpiration', () => {
 
     // Do the same thing, but starve the first update
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          updateNormalPri();
-        });
-      } else {
+      React.startTransition(() => {
         updateNormalPri();
-      }
+      });
       expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update
@@ -690,13 +646,9 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('A0BC');
 
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          root.render(<App step={1} />);
-        });
-      } else {
+      React.startTransition(() => {
         root.render(<App step={1} />);
-      }
+      });
       expect(Scheduler).toFlushAndYield([
         'Suspend! [A1]',
         'B',

commit 25a8b9735ce7c84210707d5eced7fe2c9abbd0e1
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 2 22:34:58 2023 -0500

    Codemod tests to waitFor pattern (1/?) (#26288)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index fb041f948f..2556a16ac3 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -18,6 +18,9 @@ let resolveText;
 let startTransition;
 let useState;
 let useEffect;
+let assertLog;
+let waitFor;
+let waitForAll;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
@@ -31,6 +34,11 @@ describe('ReactExpiration', () => {
     useState = React.useState;
     useEffect = React.useEffect;
 
+    const InternalTestUtils = require('internal-test-utils');
+    assertLog = InternalTestUtils.assertLog;
+    waitFor = InternalTestUtils.waitFor;
+    waitForAll = InternalTestUtils.waitForAll;
+
     const textCache = new Map();
 
     readText = text => {
@@ -136,7 +144,7 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
   });
 
-  it('two updates of like priority in the same event always flush within the same batch', () => {
+  it('two updates of like priority in the same event always flush within the same batch', async () => {
     class TextClass extends React.Component {
       componentDidMount() {
         Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
@@ -163,37 +171,32 @@ describe('ReactExpiration', () => {
     });
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
-    // Partially flush the first update, then interrupt it.
-    expect(Scheduler).toFlushAndYieldThrough(['A [render]']);
+    await waitFor(['A [render]']);
     interrupt();
 
-    // Don't advance time by enough to expire the first update.
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
-    // Both updates are batched
-    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+    await waitForAll(['B [render]', 'B [commit]']);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
     // Now do the same thing again, except this time don't flush any work in
     // between the two updates.
     ReactNoop.render(<TextClass text="A" />);
     Scheduler.unstable_advanceTime(2000);
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
-    // The updates should flush in the same batch, since as far as the scheduler
-    // knows, they may have occurred inside the same event.
-    expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+    await waitForAll(['B [render]', 'B [commit]']);
   });
 
   it(
     'two updates of like priority in the same event always flush within the ' +
       "same batch, even if there's a sync update in between",
-    () => {
+    async () => {
       class TextClass extends React.Component {
         componentDidMount() {
           Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
@@ -220,25 +223,22 @@ describe('ReactExpiration', () => {
       });
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
-      // Partially flush the first update, then interrupt it.
-      expect(Scheduler).toFlushAndYieldThrough(['A [render]']);
+      await waitFor(['A [render]']);
       interrupt();
 
-      // Don't advance time by enough to expire the first update.
-      expect(Scheduler).toHaveYielded([]);
+      assertLog([]);
       expect(ReactNoop).toMatchRenderedOutput(null);
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
-      // Both updates are batched
-      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+      await waitForAll(['B [render]', 'B [commit]']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
       // Now do the same thing again, except this time don't flush any work in
       // between the two updates.
       ReactNoop.render(<TextClass text="A" />);
       Scheduler.unstable_advanceTime(2000);
-      expect(Scheduler).toHaveYielded([]);
+      assertLog([]);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
       // Perform some synchronous work. The scheduler must assume we're inside
@@ -247,13 +247,11 @@ describe('ReactExpiration', () => {
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
-      // The updates should flush in the same batch, since as far as the scheduler
-      // knows, they may have occurred inside the same event.
-      expect(Scheduler).toFlushAndYield(['B [render]', 'B [commit]']);
+      await waitForAll(['B [render]', 'B [commit]']);
     },
   );
 
-  it('cannot update at the same expiration time that is already rendering', () => {
+  it('cannot update at the same expiration time that is already rendering', async () => {
     const store = {text: 'initial'};
     const subscribers = [];
     class Connected extends React.Component {
@@ -292,7 +290,7 @@ describe('ReactExpiration', () => {
     React.startTransition(() => {
       ReactNoop.render(<App />);
     });
-    expect(Scheduler).toFlushAndYield([
+    await waitForAll([
       'initial [A] [render]',
       'initial [B] [render]',
       'initial [C] [render]',
@@ -307,10 +305,7 @@ describe('ReactExpiration', () => {
     React.startTransition(() => {
       subscribers.forEach(s => s.setState({text: '1'}));
     });
-    expect(Scheduler).toFlushAndYieldThrough([
-      '1 [A] [render]',
-      '1 [B] [render]',
-    ]);
+    await waitFor(['1 [A] [render]', '1 [B] [render]']);
 
     // Before the update can finish, update again. Even though no time has
     // advanced, this update should be given a different expiration time than
@@ -318,13 +313,10 @@ describe('ReactExpiration', () => {
     React.startTransition(() => {
       subscribers.forEach(s => s.setState({text: '2'}));
     });
-    expect(Scheduler).toFlushAndYieldThrough([
-      '1 [C] [render]',
-      '1 [D] [render]',
-    ]);
+    await waitFor(['1 [C] [render]', '1 [D] [render]']);
   });
 
-  it('stops yielding if CPU-bound update takes too long to finish', () => {
+  it('stops yielding if CPU-bound update takes too long to finish', async () => {
     const root = ReactNoop.createRoot();
     function App() {
       return (
@@ -342,18 +334,18 @@ describe('ReactExpiration', () => {
       root.render(<App />);
     });
 
-    expect(Scheduler).toFlushAndYieldThrough(['A']);
-    expect(Scheduler).toFlushAndYieldThrough(['B']);
-    expect(Scheduler).toFlushAndYieldThrough(['C']);
+    await waitFor(['A']);
+    await waitFor(['B']);
+    await waitFor(['C']);
 
     Scheduler.unstable_advanceTime(10000);
 
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded(['D', 'E']);
+    assertLog(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
-  it('root expiration is measured from the time of the first update', () => {
+  it('root expiration is measured from the time of the first update', async () => {
     Scheduler.unstable_advanceTime(10000);
 
     const root = ReactNoop.createRoot();
@@ -372,14 +364,14 @@ describe('ReactExpiration', () => {
       root.render(<App />);
     });
 
-    expect(Scheduler).toFlushAndYieldThrough(['A']);
-    expect(Scheduler).toFlushAndYieldThrough(['B']);
-    expect(Scheduler).toFlushAndYieldThrough(['C']);
+    await waitFor(['A']);
+    await waitFor(['B']);
+    await waitFor(['C']);
 
     Scheduler.unstable_advanceTime(10000);
 
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded(['D', 'E']);
+    assertLog(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
@@ -404,14 +396,14 @@ describe('ReactExpiration', () => {
 
     // The update should not have expired yet.
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
 
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
@@ -427,14 +419,14 @@ describe('ReactExpiration', () => {
       ReactNoop.render('Hi');
     });
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advancing by ~5 seconds should be sufficient to expire the update. (I
     // used a slightly larger number to allow for possible rounding.)
     Scheduler.unstable_advanceTime(6000);
     flushNextRenderIfExpired();
-    expect(Scheduler).toHaveYielded([]);
+    assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
@@ -463,7 +455,7 @@ describe('ReactExpiration', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Normal pri: 0']);
+    assertLog(['Sync pri: 0', 'Normal pri: 0']);
     expect(root).toMatchRenderedOutput('Sync pri: 0, Normal pri: 0');
 
     // First demonstrate what happens when there's no starvation
@@ -471,18 +463,16 @@ describe('ReactExpiration', () => {
       React.startTransition(() => {
         updateNormalPri();
       });
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
+      await waitFor(['Sync pri: 0']);
       updateSyncPri();
-      expect(Scheduler).toHaveYielded(['Sync pri: 1', 'Normal pri: 0']);
+      assertLog(['Sync pri: 1', 'Normal pri: 0']);
 
       // The remaining work hasn't expired, so the render phase is time sliced.
       // In other words, we can flush just the first child without flushing
       // the rest.
       Scheduler.unstable_flushNumberOfYields(1);
-      // Yield right after first child.
-      expect(Scheduler).toHaveYielded(['Sync pri: 1']);
-      // Now do the rest.
-      expect(Scheduler).toFlushAndYield(['Normal pri: 1']);
+      assertLog(['Sync pri: 1']);
+      await waitForAll(['Normal pri: 1']);
     });
     expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');
 
@@ -491,7 +481,7 @@ describe('ReactExpiration', () => {
       React.startTransition(() => {
         updateNormalPri();
       });
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
+      await waitFor(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update
       // started rendering. (This should advance time by some number that's
@@ -500,12 +490,12 @@ describe('ReactExpiration', () => {
       Scheduler.unstable_advanceTime(10000);
 
       updateSyncPri();
-      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 1']);
+      assertLog(['Sync pri: 2', 'Normal pri: 1']);
 
       // The remaining work _has_ expired, so the render phase is _not_ time
       // sliced. Attempting to flush just the first child also flushes the rest.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['Sync pri: 2', 'Normal pri: 2']);
+      assertLog(['Sync pri: 2', 'Normal pri: 2']);
     });
     expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');
   });
@@ -534,16 +524,16 @@ describe('ReactExpiration', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['Sync pri: 0', 'Idle pri: 0']);
+    assertLog(['Sync pri: 0', 'Idle pri: 0']);
     expect(root).toMatchRenderedOutput('Sync pri: 0, Idle pri: 0');
 
     // First demonstrate what happens when there's no starvation
     await act(async () => {
       updateIdlePri();
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 0']);
+      await waitFor(['Sync pri: 0']);
       updateSyncPri();
     });
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // Interrupt idle update to render sync update
       'Sync pri: 1',
       'Idle pri: 0',
@@ -556,7 +546,7 @@ describe('ReactExpiration', () => {
     // Do the same thing, but starve the first update
     await act(async () => {
       updateIdlePri();
-      expect(Scheduler).toFlushAndYieldThrough(['Sync pri: 1']);
+      await waitFor(['Sync pri: 1']);
 
       // Advance a ridiculously large amount of time to demonstrate that the
       // idle work never expires
@@ -564,8 +554,7 @@ describe('ReactExpiration', () => {
 
       updateSyncPri();
     });
-    // Same thing should happen as last time
-    expect(Scheduler).toHaveYielded([
+    assertLog([
       // Interrupt idle update to render sync update
       'Sync pri: 2',
       'Idle pri: 1',
@@ -597,14 +586,14 @@ describe('ReactExpiration', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C']);
+    assertLog(['A0', 'B0', 'C']);
     expect(root).toMatchRenderedOutput('A0B0C');
 
     await act(async () => {
       startTransition(() => {
         setA(1);
       });
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+      await waitFor(['A1']);
       startTransition(() => {
         setB(1);
       });
@@ -614,12 +603,12 @@ describe('ReactExpiration', () => {
       // (entangled), we should be able to finish the in-progress transition
       // without also including the next one.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['B0', 'C']);
+      assertLog(['B0', 'C']);
       expect(root).toMatchRenderedOutput('A1B0C');
 
       // The next transition also finishes without yielding.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C']);
+      assertLog(['A1', 'B1', 'C']);
       expect(root).toMatchRenderedOutput('A1B1C');
     });
   });
@@ -642,28 +631,21 @@ describe('ReactExpiration', () => {
       await resolveText('A0');
       root.render(<App step={0} />);
     });
-    expect(Scheduler).toHaveYielded(['A0', 'B', 'C']);
+    assertLog(['A0', 'B', 'C']);
     expect(root).toMatchRenderedOutput('A0BC');
 
     await act(async () => {
       React.startTransition(() => {
         root.render(<App step={1} />);
       });
-      expect(Scheduler).toFlushAndYield([
-        'Suspend! [A1]',
-        'B',
-        'C',
-        'Loading...',
-      ]);
+      await waitForAll(['Suspend! [A1]', 'B', 'C', 'Loading...']);
 
       // Lots of time elapses before the promise resolves
       Scheduler.unstable_advanceTime(10000);
       await resolveText('A1');
-      expect(Scheduler).toHaveYielded(['Promise resolved [A1]']);
+      assertLog(['Promise resolved [A1]']);
 
-      // But the update doesn't expire, because it was IO bound. So we can
-      // partially rendering without finishing.
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+      await waitFor(['A1']);
       expect(root).toMatchRenderedOutput('A0BC');
 
       // Lots more time elapses. We're CPU-bound now, so we should treat this
@@ -672,7 +654,7 @@ describe('ReactExpiration', () => {
 
       // The rest of the update finishes without yielding.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['B', 'C']);
+      assertLog(['B', 'C']);
     });
   });
 
@@ -696,13 +678,13 @@ describe('ReactExpiration', () => {
     await act(async () => {
       root.render(<App />);
     });
-    expect(Scheduler).toHaveYielded(['A0', 'B0']);
+    assertLog(['A0', 'B0']);
 
     await act(async () => {
       startTransition(() => {
         setA(1);
       });
-      expect(Scheduler).toFlushAndYieldThrough(['A1']);
+      await waitFor(['A1']);
 
       // Expire the in-progress update
       Scheduler.unstable_advanceTime(10000);
@@ -710,12 +692,12 @@ describe('ReactExpiration', () => {
       ReactNoop.flushSync(() => {
         setB(1);
       });
-      expect(Scheduler).toHaveYielded(['A0', 'B1']);
+      assertLog(['A0', 'B1']);
 
       // Now flush the original update. Because it expired, it should finish
       // without yielding.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['A1', 'B1']);
+      assertLog(['A1', 'B1']);
     });
   });
 
@@ -737,7 +719,7 @@ describe('ReactExpiration', () => {
     await act(async () => {
       root.render(<App step={0} />);
     });
-    expect(Scheduler).toHaveYielded(['A0', 'B0', 'C0', 'Effect: 0']);
+    assertLog(['A0', 'B0', 'C0', 'Effect: 0']);
     expect(root).toMatchRenderedOutput('A0B0C0');
 
     await act(async () => {
@@ -749,9 +731,8 @@ describe('ReactExpiration', () => {
 
       // The update finishes without yielding. But it does not flush the effect.
       Scheduler.unstable_flushNumberOfYields(1);
-      expect(Scheduler).toHaveYielded(['A1', 'B1', 'C1']);
+      assertLog(['A1', 'B1', 'C1']);
     });
-    // The effect flushes after paint.
-    expect(Scheduler).toHaveYielded(['Effect: 1']);
+    assertLog(['Effect: 1']);
   });
 });

commit 5c633a48f9bdc212e27ae026c74148b42cc47efb
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 14:34:41 2023 -0500

    Add back accidentally deleted test comments (#26294)
    
    The codemod I used in #26288 accidentally caused some comments to be
    deleted. Because not all affected lines included comments, I didn't
    notice until after landing.
    
    This adds the comments back.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 2556a16ac3..1903ab2eee 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -171,14 +171,17 @@ describe('ReactExpiration', () => {
     });
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
+    // Partially flush the first update, then interrupt it.
     await waitFor(['A [render]']);
     interrupt();
 
+    // Don't advance time by enough to expire the first update.
     assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
+    // Both updates are batched
     await waitForAll(['B [render]', 'B [commit]']);
     expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
@@ -190,6 +193,8 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
     // Schedule another update.
     ReactNoop.render(<TextClass text="B" />);
+    // The updates should flush in the same batch, since as far as the scheduler
+    // knows, they may have occurred inside the same event.
     await waitForAll(['B [render]', 'B [commit]']);
   });
 
@@ -223,14 +228,17 @@ describe('ReactExpiration', () => {
       });
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
+      // Partially flush the first update, then interrupt it.
       await waitFor(['A [render]']);
       interrupt();
 
+      // Don't advance time by enough to expire the first update.
       assertLog([]);
       expect(ReactNoop).toMatchRenderedOutput(null);
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
+      // Both updates are batched
       await waitForAll(['B [render]', 'B [commit]']);
       expect(ReactNoop).toMatchRenderedOutput(<span prop="B" />);
 
@@ -247,6 +255,8 @@ describe('ReactExpiration', () => {
 
       // Schedule another update.
       ReactNoop.render(<TextClass text="B" />);
+      // The updates should flush in the same batch, since as far as the scheduler
+      // knows, they may have occurred inside the same event.
       await waitForAll(['B [render]', 'B [commit]']);
     },
   );
@@ -471,7 +481,9 @@ describe('ReactExpiration', () => {
       // In other words, we can flush just the first child without flushing
       // the rest.
       Scheduler.unstable_flushNumberOfYields(1);
+      // Yield right after first child.
       assertLog(['Sync pri: 1']);
+      // Now do the rest.
       await waitForAll(['Normal pri: 1']);
     });
     expect(root).toMatchRenderedOutput('Sync pri: 1, Normal pri: 1');
@@ -533,6 +545,7 @@ describe('ReactExpiration', () => {
       await waitFor(['Sync pri: 0']);
       updateSyncPri();
     });
+    // Same thing should happen as last time
     assertLog([
       // Interrupt idle update to render sync update
       'Sync pri: 1',
@@ -733,6 +746,7 @@ describe('ReactExpiration', () => {
       Scheduler.unstable_flushNumberOfYields(1);
       assertLog(['A1', 'B1', 'C1']);
     });
+    // The effect flushes after paint.
     assertLog(['Effect: 1']);
   });
 });

commit 1528c5ccdf5c61a08adab31116156df6503e26ce
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 6 11:09:07 2023 -0500

    SchedulerMock.unstable_yieldValue -> SchedulerMock.log (#26312)
    
    (This only affects our own internal repo; it's not a public API.)
    
    I think most of us agree this is a less confusing name. It's possible
    someone will confuse it with `console.log`. If that becomes a problem we
    can warn in dev or something.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 1903ab2eee..4e561ab2a5 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -69,7 +69,7 @@ describe('ReactExpiration', () => {
       const record = textCache.get(text);
       if (record !== undefined) {
         if (record.status === 'pending') {
-          Scheduler.unstable_yieldValue(`Promise resolved [${text}]`);
+          Scheduler.log(`Promise resolved [${text}]`);
           record.ping();
           record.ping = null;
           record.status = 'resolved';
@@ -88,7 +88,7 @@ describe('ReactExpiration', () => {
   });
 
   function Text(props) {
-    Scheduler.unstable_yieldValue(props.text);
+    Scheduler.log(props.text);
     return props.text;
   }
 
@@ -96,18 +96,18 @@ describe('ReactExpiration', () => {
     const text = props.text;
     try {
       readText(text);
-      Scheduler.unstable_yieldValue(text);
+      Scheduler.log(text);
       return text;
     } catch (promise) {
       if (typeof promise.then === 'function') {
-        Scheduler.unstable_yieldValue(`Suspend! [${text}]`);
+        Scheduler.log(`Suspend! [${text}]`);
         if (typeof props.ms === 'number' && promise._timer === undefined) {
           promise._timer = setTimeout(() => {
             resolveText(text);
           }, props.ms);
         }
       } else {
-        Scheduler.unstable_yieldValue(`Error! [${text}]`);
+        Scheduler.log(`Error! [${text}]`);
       }
       throw promise;
     }
@@ -147,13 +147,13 @@ describe('ReactExpiration', () => {
   it('two updates of like priority in the same event always flush within the same batch', async () => {
     class TextClass extends React.Component {
       componentDidMount() {
-        Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+        Scheduler.log(`${this.props.text} [commit]`);
       }
       componentDidUpdate() {
-        Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+        Scheduler.log(`${this.props.text} [commit]`);
       }
       render() {
-        Scheduler.unstable_yieldValue(`${this.props.text} [render]`);
+        Scheduler.log(`${this.props.text} [render]`);
         return <span prop={this.props.text} />;
       }
     }
@@ -204,13 +204,13 @@ describe('ReactExpiration', () => {
     async () => {
       class TextClass extends React.Component {
         componentDidMount() {
-          Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+          Scheduler.log(`${this.props.text} [commit]`);
         }
         componentDidUpdate() {
-          Scheduler.unstable_yieldValue(`${this.props.text} [commit]`);
+          Scheduler.log(`${this.props.text} [commit]`);
         }
         render() {
-          Scheduler.unstable_yieldValue(`${this.props.text} [render]`);
+          Scheduler.log(`${this.props.text} [render]`);
           return <span prop={this.props.text} />;
         }
       }
@@ -268,19 +268,13 @@ describe('ReactExpiration', () => {
       state = {text: store.text};
       componentDidMount() {
         subscribers.push(this);
-        Scheduler.unstable_yieldValue(
-          `${this.state.text} [${this.props.label}] [commit]`,
-        );
+        Scheduler.log(`${this.state.text} [${this.props.label}] [commit]`);
       }
       componentDidUpdate() {
-        Scheduler.unstable_yieldValue(
-          `${this.state.text} [${this.props.label}] [commit]`,
-        );
+        Scheduler.log(`${this.state.text} [${this.props.label}] [commit]`);
       }
       render() {
-        Scheduler.unstable_yieldValue(
-          `${this.state.text} [${this.props.label}] [render]`,
-        );
+        Scheduler.log(`${this.state.text} [${this.props.label}] [render]`);
         return <span prop={this.state.text} />;
       }
     }
@@ -717,7 +711,7 @@ describe('ReactExpiration', () => {
   it('passive effects of expired update flush after paint', async () => {
     function App({step}) {
       useEffect(() => {
-        Scheduler.unstable_yieldValue('Effect: ' + step);
+        Scheduler.log('Effect: ' + step);
       }, [step]);
       return (
         <>

commit 44d3807945700de8bb6bdbbf5c4d1ba513303747
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 12:58:31 2023 -0500

    Move internalAct to internal-test-utils package (#26344)
    
    This is not a public API. We only use it for our internal tests, the
    ones in this repo. Let's move it to this private package. Practically
    speaking this will also let us use async/await in the implementation.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 4e561ab2a5..61146e208f 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -29,7 +29,7 @@ describe('ReactExpiration', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
-    act = require('jest-react').act;
+    act = require('internal-test-utils').act;
     startTransition = React.startTransition;
     useState = React.useState;
     useEffect = React.useEffect;

commit 62cd5af08e2ac8b1d4691e75252487083cf7a4aa
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Mar 8 16:40:23 2023 -0500

    Codemod redundant async act scopes (#26350)
    
    Prior to #26347, our internal `act` API (not the public API) behaved
    differently depending on whether the scope function returned a promise
    (i.e. was an async function), for historical reasons that no longer
    apply. Now that this is fixed, I've codemodded all async act scopes that
    don't contain an await to be sync.
    
    No pressing motivation other than it looks nicer and the codemod was
    easy. Might help avoid confusion for new contributors who see async act
    scopes with nothing async inside and infer it must be like that for a
    reason.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 61146e208f..e1a8d08bcc 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -456,7 +456,7 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['Sync pri: 0', 'Normal pri: 0']);
@@ -527,7 +527,7 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['Sync pri: 0', 'Idle pri: 0']);
@@ -590,7 +590,7 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['A0', 'B0', 'C']);
@@ -682,7 +682,7 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App />);
     });
     assertLog(['A0', 'B0']);
@@ -723,13 +723,13 @@ describe('ReactExpiration', () => {
     }
 
     const root = ReactNoop.createRoot();
-    await act(async () => {
+    await act(() => {
       root.render(<App step={0} />);
     });
     assertLog(['A0', 'B0', 'C0', 'Effect: 0']);
     expect(root).toMatchRenderedOutput('A0B0C0');
 
-    await act(async () => {
+    await act(() => {
       startTransition(() => {
         root.render(<App step={1} />);
       });

commit a8875eab7f78a453d22370d1061a8bb3cd672b9d
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 10 11:06:28 2023 -0500

    Update more tests to not rely on sync queuing (#26358)
    
    This fixes a handful of tests that were accidentally relying on React
    synchronously queuing work in the Scheduler after a setState.
    
    Usually this is because they use a lower level SchedulerMock method
    instead of either `act` or one of the `waitFor` helpers. In some cases,
    the solution is to switch to those APIs. In other cases, if we're
    intentionally testing some lower level behavior, we might have to be a
    bit more clever.
    
    Co-authored-by: Tianyu Yao <skyyao@fb.com>

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index e1a8d08bcc..ae734e1971 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -113,35 +113,30 @@ describe('ReactExpiration', () => {
     }
   }
 
-  function flushNextRenderIfExpired() {
-    // This will start rendering the next level of work. If the work hasn't
-    // expired yet, React will exit without doing anything. If it has expired,
-    // it will schedule a sync task.
-    Scheduler.unstable_flushExpired();
-    // Flush the sync task.
-    ReactNoop.flushSync();
-  }
-
-  it('increases priority of updates as time progresses', () => {
+  it('increases priority of updates as time progresses', async () => {
+    ReactNoop.render(<Text text="Step 1" />);
     React.startTransition(() => {
-      ReactNoop.render(<span prop="done" />);
+      ReactNoop.render(<Text text="Step 2" />);
     });
 
-    expect(ReactNoop).toMatchRenderedOutput(null);
+    await waitFor(['Step 1']);
+
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Nothing has expired yet because time hasn't advanced.
-    flushNextRenderIfExpired();
-    expect(ReactNoop).toMatchRenderedOutput(null);
+    Scheduler.unstable_flushExpired();
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Advance time a bit, but not enough to expire the low pri update.
     ReactNoop.expire(4500);
-    flushNextRenderIfExpired();
-    expect(ReactNoop).toMatchRenderedOutput(null);
+    Scheduler.unstable_flushExpired();
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-    // Advance by another second. Now the update should expire and flush.
+    // Advance by a little bit more. Now the update should expire and flush.
     ReactNoop.expire(500);
-    flushNextRenderIfExpired();
-    expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
+    Scheduler.unstable_flushExpired();
+    assertLog(['Step 2']);
+    expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
   it('two updates of like priority in the same event always flush within the same batch', async () => {
@@ -344,7 +339,7 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    flushNextRenderIfExpired();
+    Scheduler.unstable_flushExpired();
     assertLog(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
@@ -374,17 +369,21 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    flushNextRenderIfExpired();
+    Scheduler.unstable_flushExpired();
     assertLog(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
-  it('should measure expiration times relative to module initialization', () => {
+  it('should measure expiration times relative to module initialization', async () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.
 
     jest.resetModules();
     Scheduler = require('scheduler');
+    const InternalTestUtils = require('internal-test-utils');
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
+
     // Before importing the renderer, advance the current time by a number
     // larger than the maximum allowed for bitwise operations.
     const maxSigned31BitInt = 1073741823;
@@ -393,22 +392,25 @@ describe('ReactExpiration', () => {
     // Now import the renderer. On module initialization, it will read the
     // current time.
     ReactNoop = require('react-noop-renderer');
+    React = require('react');
 
+    ReactNoop.render(<Text text="Step 1" />);
     React.startTransition(() => {
-      ReactNoop.render('Hi');
+      ReactNoop.render(<Text text="Step 2" />);
     });
+    await waitFor(['Step 1']);
 
     // The update should not have expired yet.
-    flushNextRenderIfExpired();
+    Scheduler.unstable_flushExpired();
     assertLog([]);
 
-    expect(ReactNoop).toMatchRenderedOutput(null);
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
-    flushNextRenderIfExpired();
-    assertLog([]);
-    expect(ReactNoop).toMatchRenderedOutput('Hi');
+    Scheduler.unstable_flushExpired();
+    assertLog(['Step 2']);
+    expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
   it('should measure callback timeout relative to current time, not start-up time', () => {
@@ -422,14 +424,14 @@ describe('ReactExpiration', () => {
     React.startTransition(() => {
       ReactNoop.render('Hi');
     });
-    flushNextRenderIfExpired();
+    Scheduler.unstable_flushExpired();
     assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advancing by ~5 seconds should be sufficient to expire the update. (I
     // used a slightly larger number to allow for possible rounding.)
     Scheduler.unstable_advanceTime(6000);
-    flushNextRenderIfExpired();
+    Scheduler.unstable_flushExpired();
     assertLog([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });

commit 12a1d140e366aa8d95338e4412117f16da79a078
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Mar 21 10:24:56 2023 -0400

    Don't prerender siblings of suspended component  (#26380)
    
    Today if something suspends, React will continue rendering the siblings
    of that component.
    
    Our original rationale for prerendering the siblings of a suspended
    component was to initiate any lazy fetches that they might contain. This
    was when we were more bullish about lazy fetching being a good idea some
    of the time (when combined with prefetching), as opposed to our latest
    thinking, which is that it's almost always a bad idea.
    
    Another rationale for the original behavior was that the render was I/O
    bound, anyway, so we might as do some extra work in the meantime. But
    this was before we had the concept of instant loading states: when
    navigating to a new screen, it's better to show a loading state as soon
    as you can (often a skeleton UI), rather than delay the transition.
    (There are still cases where we block the render, when a suitable
    loading state is not available; it's just not _all_ cases where
    something suspends.) So the biggest issue with our existing
    implementation is that the prerendering of the siblings happens within
    the same render pass as the one that suspended — _before_ the loading
    state appears.
    
    What we should do instead is immediately unwind the stack as soon as
    something suspends, to unblock the loading state.
    
    If we want to preserve the ability to prerender the siblings, what we
    could do is schedule special render pass immediately after the fallback
    is displayed. This is likely what we'll do in the future. However, in
    the new implementation of `use`, there's another reason we don't
    prerender siblings: so we can preserve the state of the stack when
    something suspends, and resume where we left of when the promise
    resolves without replaying the parents. The only way to do this
    currently is to suspend the entire work loop. Fiber does not currently
    support rendering multiple siblings in "parallel". Once you move onto
    the next sibling, the stack of the previous sibling is discarded and
    cannot be restored. We do plan to implement this feature, but it will
    require a not-insignificant refactor.
    
    Given that lazy data fetching is already bad for performance, the best
    trade off for now seems to be to disable prerendering of siblings. This
    gives us the best performance characteristics when you're following best
    practices (i.e. hoist data fetches to Server Components or route
    loaders), at the expense of making an already bad pattern a bit worse.
    
    Later, when we implement resumable context stacks, we can reenable
    sibling prerendering. Though even then the use case will mostly be to
    prerender the CPU-bound work, not lazy fetches.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index ae734e1971..159e17d934 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -647,7 +647,7 @@ describe('ReactExpiration', () => {
       React.startTransition(() => {
         root.render(<App step={1} />);
       });
-      await waitForAll(['Suspend! [A1]', 'B', 'C', 'Loading...']);
+      await waitForAll(['Suspend! [A1]', 'Loading...']);
 
       // Lots of time elapses before the promise resolves
       Scheduler.unstable_advanceTime(10000);

commit 8faf751937e9672fb69dac8143dbfb0929caf77e
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Mar 27 15:52:25 2023 -0400

    Codemod some expiration tests to waitForExpired (#26491)
    
    Continuing my journey to migrate all the Scheduler flush* methods to
    async versions of the same helpers.
    
    `unstable_flushExpired` is a rarely used helper that is only meant to be
    used to test a very particular implementation detail (update starvation
    prevention, or what we sometimes refer to as "expiration").
    
    I've prefixed the new helper with `unstable_`, too, to indicate that our
    tests should almost always prefer one of the other patterns instead.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 159e17d934..26a82e8be3 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -21,6 +21,7 @@ let useEffect;
 let assertLog;
 let waitFor;
 let waitForAll;
+let unstable_waitForExpired;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
@@ -38,6 +39,7 @@ describe('ReactExpiration', () => {
     assertLog = InternalTestUtils.assertLog;
     waitFor = InternalTestUtils.waitFor;
     waitForAll = InternalTestUtils.waitForAll;
+    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
 
     const textCache = new Map();
 
@@ -124,18 +126,17 @@ describe('ReactExpiration', () => {
     expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Nothing has expired yet because time hasn't advanced.
-    Scheduler.unstable_flushExpired();
+    await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Advance time a bit, but not enough to expire the low pri update.
     ReactNoop.expire(4500);
-    Scheduler.unstable_flushExpired();
+    await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Advance by a little bit more. Now the update should expire and flush.
     ReactNoop.expire(500);
-    Scheduler.unstable_flushExpired();
-    assertLog(['Step 2']);
+    await unstable_waitForExpired(['Step 2']);
     expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
@@ -339,8 +340,7 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    Scheduler.unstable_flushExpired();
-    assertLog(['D', 'E']);
+    await unstable_waitForExpired(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
@@ -369,8 +369,7 @@ describe('ReactExpiration', () => {
 
     Scheduler.unstable_advanceTime(10000);
 
-    Scheduler.unstable_flushExpired();
-    assertLog(['D', 'E']);
+    await unstable_waitForExpired(['D', 'E']);
     expect(root).toMatchRenderedOutput('ABCDE');
   });
 
@@ -383,6 +382,7 @@ describe('ReactExpiration', () => {
     const InternalTestUtils = require('internal-test-utils');
     waitFor = InternalTestUtils.waitFor;
     assertLog = InternalTestUtils.assertLog;
+    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
 
     // Before importing the renderer, advance the current time by a number
     // larger than the maximum allowed for bitwise operations.
@@ -401,19 +401,17 @@ describe('ReactExpiration', () => {
     await waitFor(['Step 1']);
 
     // The update should not have expired yet.
-    Scheduler.unstable_flushExpired();
-    assertLog([]);
+    await unstable_waitForExpired([]);
 
     expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
     // Advance the time some more to expire the update.
     Scheduler.unstable_advanceTime(10000);
-    Scheduler.unstable_flushExpired();
-    assertLog(['Step 2']);
+    await unstable_waitForExpired(['Step 2']);
     expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
-  it('should measure callback timeout relative to current time, not start-up time', () => {
+  it('should measure callback timeout relative to current time, not start-up time', async () => {
     // Corresponds to a bugfix: https://github.com/facebook/react/pull/15479
     // The bug wasn't caught by other tests because we use virtual times that
     // default to 0, and most tests don't advance time.
@@ -424,15 +422,13 @@ describe('ReactExpiration', () => {
     React.startTransition(() => {
       ReactNoop.render('Hi');
     });
-    Scheduler.unstable_flushExpired();
-    assertLog([]);
+    await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
     // Advancing by ~5 seconds should be sufficient to expire the update. (I
     // used a slightly larger number to allow for possible rounding.)
     Scheduler.unstable_advanceTime(6000);
-    Scheduler.unstable_flushExpired();
-    assertLog([]);
+    await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput('Hi');
   });
 
@@ -476,9 +472,9 @@ describe('ReactExpiration', () => {
       // The remaining work hasn't expired, so the render phase is time sliced.
       // In other words, we can flush just the first child without flushing
       // the rest.
-      Scheduler.unstable_flushNumberOfYields(1);
+      //
       // Yield right after first child.
-      assertLog(['Sync pri: 1']);
+      await waitFor(['Sync pri: 1']);
       // Now do the rest.
       await waitForAll(['Normal pri: 1']);
     });
@@ -502,8 +498,9 @@ describe('ReactExpiration', () => {
 
       // The remaining work _has_ expired, so the render phase is _not_ time
       // sliced. Attempting to flush just the first child also flushes the rest.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['Sync pri: 2', 'Normal pri: 2']);
+      await waitFor(['Sync pri: 2'], {
+        additionalLogsAfterAttemptingToYield: ['Normal pri: 2'],
+      });
     });
     expect(root).toMatchRenderedOutput('Sync pri: 2, Normal pri: 2');
   });
@@ -606,18 +603,22 @@ describe('ReactExpiration', () => {
       startTransition(() => {
         setB(1);
       });
+      await waitFor(['B0']);
+
       // Expire both the transitions
       Scheduler.unstable_advanceTime(10000);
       // Both transitions have expired, but since they aren't related
       // (entangled), we should be able to finish the in-progress transition
       // without also including the next one.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['B0', 'C']);
+      await waitFor([], {
+        additionalLogsAfterAttemptingToYield: ['C'],
+      });
       expect(root).toMatchRenderedOutput('A1B0C');
 
       // The next transition also finishes without yielding.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['A1', 'B1', 'C']);
+      await waitFor(['A1'], {
+        additionalLogsAfterAttemptingToYield: ['B1', 'C'],
+      });
       expect(root).toMatchRenderedOutput('A1B1C');
     });
   });
@@ -662,8 +663,9 @@ describe('ReactExpiration', () => {
       Scheduler.unstable_advanceTime(10000);
 
       // The rest of the update finishes without yielding.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['B', 'C']);
+      await waitFor([], {
+        additionalLogsAfterAttemptingToYield: ['B', 'C'],
+      });
     });
   });
 
@@ -705,8 +707,9 @@ describe('ReactExpiration', () => {
 
       // Now flush the original update. Because it expired, it should finish
       // without yielding.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['A1', 'B1']);
+      await waitFor(['A1'], {
+        additionalLogsAfterAttemptingToYield: ['B1'],
+      });
     });
   });
 
@@ -731,16 +734,19 @@ describe('ReactExpiration', () => {
     assertLog(['A0', 'B0', 'C0', 'Effect: 0']);
     expect(root).toMatchRenderedOutput('A0B0C0');
 
-    await act(() => {
+    await act(async () => {
       startTransition(() => {
         root.render(<App step={1} />);
       });
+      await waitFor(['A1']);
+
       // Expire the update
       Scheduler.unstable_advanceTime(10000);
 
       // The update finishes without yielding. But it does not flush the effect.
-      Scheduler.unstable_flushNumberOfYields(1);
-      assertLog(['A1', 'B1', 'C1']);
+      await waitFor(['B1'], {
+        additionalLogsAfterAttemptingToYield: ['C1'],
+      });
     });
     // The effect flushes after paint.
     assertLog(['Effect: 1']);

commit da94e8b24a3f31a3e805f9bf6bba73055aad9d41
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Apr 4 10:08:14 2023 -0400

    Revert "Cleanup enableSyncDefaultUpdate flag (#26236)" (#26528)
    
    This reverts commit b2ae9ddb3b497d16a7c27c051da1827d08871138.
    
    While the feature flag is fully rolled out, these tests are also testing
    behavior set with an unstable flag on root, which for now we want to
    preserve.
    
    Not sure if there's a better way then adding a dynamic feature flag to
    the www build?

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 26a82e8be3..2c38a05168 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -115,29 +115,54 @@ describe('ReactExpiration', () => {
     }
   }
 
+  function flushNextRenderIfExpired() {
+    // This will start rendering the next level of work. If the work hasn't
+    // expired yet, React will exit without doing anything. If it has expired,
+    // it will schedule a sync task.
+    Scheduler.unstable_flushExpired();
+    // Flush the sync task.
+    ReactNoop.flushSync();
+  }
+
   it('increases priority of updates as time progresses', async () => {
-    ReactNoop.render(<Text text="Step 1" />);
-    React.startTransition(() => {
-      ReactNoop.render(<Text text="Step 2" />);
-    });
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      ReactNoop.render(<Text text="Step 1" />);
+      React.startTransition(() => {
+        ReactNoop.render(<Text text="Step 2" />);
+      });
+      await waitFor(['Step 1']);
 
-    await waitFor(['Step 1']);
+      expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-    expect(ReactNoop).toMatchRenderedOutput('Step 1');
+      // Nothing has expired yet because time hasn't advanced.
+      await unstable_waitForExpired([]);
+      expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-    // Nothing has expired yet because time hasn't advanced.
-    await unstable_waitForExpired([]);
-    expect(ReactNoop).toMatchRenderedOutput('Step 1');
+      // Advance time a bit, but not enough to expire the low pri update.
+      ReactNoop.expire(4500);
+      await unstable_waitForExpired([]);
+      expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-    // Advance time a bit, but not enough to expire the low pri update.
-    ReactNoop.expire(4500);
-    await unstable_waitForExpired([]);
-    expect(ReactNoop).toMatchRenderedOutput('Step 1');
+      // Advance by a little bit more. Now the update should expire and flush.
+      ReactNoop.expire(500);
+      await unstable_waitForExpired(['Step 2']);
+      expect(ReactNoop).toMatchRenderedOutput('Step 2');
+    } else {
+      ReactNoop.render(<span prop="done" />);
+      expect(ReactNoop).toMatchRenderedOutput(null);
 
-    // Advance by a little bit more. Now the update should expire and flush.
-    ReactNoop.expire(500);
-    await unstable_waitForExpired(['Step 2']);
-    expect(ReactNoop).toMatchRenderedOutput('Step 2');
+      // Nothing has expired yet because time hasn't advanced.
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance time a bit, but not enough to expire the low pri update.
+      ReactNoop.expire(4500);
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance by another second. Now the update should expire and flush.
+      ReactNoop.expire(500);
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
+    }
   });
 
   it('two updates of like priority in the same event always flush within the same batch', async () => {
@@ -162,9 +187,13 @@ describe('ReactExpiration', () => {
 
     // First, show what happens for updates in two separate events.
     // Schedule an update.
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<TextClass text="A" />);
+      });
+    } else {
       ReactNoop.render(<TextClass text="A" />);
-    });
+    }
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
     // Partially flush the first update, then interrupt it.
@@ -219,9 +248,13 @@ describe('ReactExpiration', () => {
 
       // First, show what happens for updates in two separate events.
       // Schedule an update.
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          ReactNoop.render(<TextClass text="A" />);
+        });
+      } else {
         ReactNoop.render(<TextClass text="A" />);
-      });
+      }
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
       // Partially flush the first update, then interrupt it.
@@ -287,9 +320,13 @@ describe('ReactExpiration', () => {
     }
 
     // Initial mount
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render(<App />);
+      });
+    } else {
       ReactNoop.render(<App />);
-    });
+    }
     await waitForAll([
       'initial [A] [render]',
       'initial [B] [render]',
@@ -302,9 +339,13 @@ describe('ReactExpiration', () => {
     ]);
 
     // Partial update
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        subscribers.forEach(s => s.setState({text: '1'}));
+      });
+    } else {
       subscribers.forEach(s => s.setState({text: '1'}));
-    });
+    }
     await waitFor(['1 [A] [render]', '1 [B] [render]']);
 
     // Before the update can finish, update again. Even though no time has
@@ -330,9 +371,13 @@ describe('ReactExpiration', () => {
       );
     }
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        root.render(<App />);
+      });
+    } else {
       root.render(<App />);
-    });
+    }
 
     await waitFor(['A']);
     await waitFor(['B']);
@@ -359,9 +404,13 @@ describe('ReactExpiration', () => {
         </>
       );
     }
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        root.render(<App />);
+      });
+    } else {
       root.render(<App />);
-    });
+    }
 
     await waitFor(['A']);
     await waitFor(['B']);
@@ -379,36 +428,62 @@ describe('ReactExpiration', () => {
 
     jest.resetModules();
     Scheduler = require('scheduler');
-    const InternalTestUtils = require('internal-test-utils');
-    waitFor = InternalTestUtils.waitFor;
-    assertLog = InternalTestUtils.assertLog;
-    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
 
-    // Before importing the renderer, advance the current time by a number
-    // larger than the maximum allowed for bitwise operations.
-    const maxSigned31BitInt = 1073741823;
-    Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
-
-    // Now import the renderer. On module initialization, it will read the
-    // current time.
-    ReactNoop = require('react-noop-renderer');
-    React = require('react');
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      const InternalTestUtils = require('internal-test-utils');
+      waitFor = InternalTestUtils.waitFor;
+      assertLog = InternalTestUtils.assertLog;
+      unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
+
+      // Before importing the renderer, advance the current time by a number
+      // larger than the maximum allowed for bitwise operations.
+      const maxSigned31BitInt = 1073741823;
+      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
+
+      // Now import the renderer. On module initialization, it will read the
+      // current time.
+      ReactNoop = require('react-noop-renderer');
+      React = require('react');
+
+      ReactNoop.render(<Text text="Step 1" />);
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          ReactNoop.render(<Text text="Step 2" />);
+        });
+        await waitFor(['Step 1']);
+      } else {
+        ReactNoop.render('Hi');
+      }
 
-    ReactNoop.render(<Text text="Step 1" />);
-    React.startTransition(() => {
-      ReactNoop.render(<Text text="Step 2" />);
-    });
-    await waitFor(['Step 1']);
+      // The update should not have expired yet.
+      await unstable_waitForExpired([]);
 
-    // The update should not have expired yet.
-    await unstable_waitForExpired([]);
+      expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-    expect(ReactNoop).toMatchRenderedOutput('Step 1');
+      // Advance the time some more to expire the update.
+      Scheduler.unstable_advanceTime(10000);
+      await unstable_waitForExpired(['Step 2']);
+      expect(ReactNoop).toMatchRenderedOutput('Step 2');
+    } else {
+      // Before importing the renderer, advance the current time by a number
+      // larger than the maximum allowed for bitwise operations.
+      const maxSigned31BitInt = 1073741823;
+      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
+      // Now import the renderer. On module initialization, it will read the
+      // current time.
+      ReactNoop = require('react-noop-renderer');
+      ReactNoop.render('Hi');
 
-    // Advance the time some more to expire the update.
-    Scheduler.unstable_advanceTime(10000);
-    await unstable_waitForExpired(['Step 2']);
-    expect(ReactNoop).toMatchRenderedOutput('Step 2');
+      // The update should not have expired yet.
+      flushNextRenderIfExpired();
+      await waitFor([]);
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance the time some more to expire the update.
+      Scheduler.unstable_advanceTime(10000);
+      flushNextRenderIfExpired();
+      await waitFor([]);
+      expect(ReactNoop).toMatchRenderedOutput('Hi');
+    }
   });
 
   it('should measure callback timeout relative to current time, not start-up time', async () => {
@@ -419,9 +494,13 @@ describe('ReactExpiration', () => {
     // Before scheduling an update, advance the current time.
     Scheduler.unstable_advanceTime(10000);
 
-    React.startTransition(() => {
+    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+      React.startTransition(() => {
+        ReactNoop.render('Hi');
+      });
+    } else {
       ReactNoop.render('Hi');
-    });
+    }
     await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
@@ -462,9 +541,13 @@ describe('ReactExpiration', () => {
 
     // First demonstrate what happens when there's no starvation
     await act(async () => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          updateNormalPri();
+        });
+      } else {
         updateNormalPri();
-      });
+      }
       await waitFor(['Sync pri: 0']);
       updateSyncPri();
       assertLog(['Sync pri: 1', 'Normal pri: 0']);
@@ -482,9 +565,13 @@ describe('ReactExpiration', () => {
 
     // Do the same thing, but starve the first update
     await act(async () => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          updateNormalPri();
+        });
+      } else {
         updateNormalPri();
-      });
+      }
       await waitFor(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update
@@ -645,9 +732,13 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('A0BC');
 
     await act(async () => {
-      React.startTransition(() => {
+      if (gate(flags => flags.enableSyncDefaultUpdates)) {
+        React.startTransition(() => {
+          root.render(<App step={1} />);
+        });
+      } else {
         root.render(<App step={1} />);
-      });
+      }
       await waitForAll(['Suspend! [A1]', 'Loading...']);
 
       // Lots of time elapses before the promise resolves

commit 0b931f90e8964183f08ac328e7350d847abb08f9
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Apr 11 00:19:49 2023 -0400

    Remove JND delay for non-transition updates (#26597)
    
    Updates that are marked as part of a transition are allowed to block a
    render from committing. Generally, other updates cannot — however,
    there's one exception that's leftover from a previous iteration of our
    Suspense architecture. If an update is not the result of a known urgent
    event type — known as "Default" updates — then we allow it to suspend
    briefly, as long as the delay is short enough that the user won't
    notice. We refer to this delay as a "Just Noticable Difference" (JND)
    delay. To illustrate, if the user has already waited 400ms for an update
    to be reflected on the screen, the theory is that they won't notice if
    you wait an additional 100ms. So React can suspend for a bit longer in
    case more data comes in. The longer the user has already waited, the
    longer the JND.
    
    While we still believe this theory is sound from a UX perspective, we no
    longer think the implementation complexity is worth it. The main thing
    that's changed is how we handle Default updates. We used to render
    Default updates concurrently (i.e. they were time sliced, and were
    scheduled with postTask), but now they are blocking. Soon, they will
    also be scheduled with rAF, too, which means by the end of the next rAF,
    they will have either finished rendering or the main thread will be
    blocked until they do. There are various motivations for this but part
    of the rationale is that anything that can be made non-blocking should
    be marked as a Transition, anyway, so it's not worth adding
    implementation complexity to Default.
    
    This commit removes the JND delay for Default updates. They will now
    commit immediately once the render phase is complete, even if a
    component suspends.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 2c38a05168..653bc30460 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -732,13 +732,9 @@ describe('ReactExpiration', () => {
     expect(root).toMatchRenderedOutput('A0BC');
 
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          root.render(<App step={1} />);
-        });
-      } else {
+      React.startTransition(() => {
         root.render(<App step={1} />);
-      }
+      });
       await waitForAll(['Suspend! [A1]', 'Loading...']);
 
       // Lots of time elapses before the promise resolves

commit 018c58c9c65452cff25aaf1f38f78a9b90d8e5c1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Thu Jun 1 09:24:56 2023 -0400

    Clean up enableSyncDefaultUpdates flag a bit (#26858)
    
    ## Overview
    
    Does a few things:
    - Renames `enableSyncDefaultUpdates` to
    `forceConcurrentByDefaultForTesting`
    - Changes the way it's used so it's dead-code eliminated separate from
    `allowConcurrentByDefault`
    - Deletes a bunch of the gated code
    
    The gates that are deleted are unnecessary now. We were keeping them
    when we originally thought we would come back to being concurrent by
    default. But we've shifted and now sync-by default is the desired
    behavior long term, so there's no need to keep all these forked tests
    around.
    
    I'll follow up to delete more of the forked behavior if possible.
    Ideally we wouldn't need this flag even if we're still using
    `allowConcurrentByDefault`.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 653bc30460..cd09ca3478 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -125,7 +125,22 @@ describe('ReactExpiration', () => {
   }
 
   it('increases priority of updates as time progresses', async () => {
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+    if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {
+      ReactNoop.render(<span prop="done" />);
+      expect(ReactNoop).toMatchRenderedOutput(null);
+
+      // Nothing has expired yet because time hasn't advanced.
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance time a bit, but not enough to expire the low pri update.
+      ReactNoop.expire(4500);
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance by another second. Now the update should expire and flush.
+      ReactNoop.expire(500);
+      flushNextRenderIfExpired();
+      expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
+    } else {
       ReactNoop.render(<Text text="Step 1" />);
       React.startTransition(() => {
         ReactNoop.render(<Text text="Step 2" />);
@@ -147,21 +162,6 @@ describe('ReactExpiration', () => {
       ReactNoop.expire(500);
       await unstable_waitForExpired(['Step 2']);
       expect(ReactNoop).toMatchRenderedOutput('Step 2');
-    } else {
-      ReactNoop.render(<span prop="done" />);
-      expect(ReactNoop).toMatchRenderedOutput(null);
-
-      // Nothing has expired yet because time hasn't advanced.
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance time a bit, but not enough to expire the low pri update.
-      ReactNoop.expire(4500);
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance by another second. Now the update should expire and flush.
-      ReactNoop.expire(500);
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
     }
   });
 
@@ -187,13 +187,9 @@ describe('ReactExpiration', () => {
 
     // First, show what happens for updates in two separate events.
     // Schedule an update.
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<TextClass text="A" />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<TextClass text="A" />);
-    }
+    });
     // Advance the timer.
     Scheduler.unstable_advanceTime(2000);
     // Partially flush the first update, then interrupt it.
@@ -248,13 +244,10 @@ describe('ReactExpiration', () => {
 
       // First, show what happens for updates in two separate events.
       // Schedule an update.
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          ReactNoop.render(<TextClass text="A" />);
-        });
-      } else {
+      React.startTransition(() => {
         ReactNoop.render(<TextClass text="A" />);
-      }
+      });
+
       // Advance the timer.
       Scheduler.unstable_advanceTime(2000);
       // Partially flush the first update, then interrupt it.
@@ -320,13 +313,10 @@ describe('ReactExpiration', () => {
     }
 
     // Initial mount
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render(<App />);
-    }
+    });
+
     await waitForAll([
       'initial [A] [render]',
       'initial [B] [render]',
@@ -339,13 +329,10 @@ describe('ReactExpiration', () => {
     ]);
 
     // Partial update
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        subscribers.forEach(s => s.setState({text: '1'}));
-      });
-    } else {
+    React.startTransition(() => {
       subscribers.forEach(s => s.setState({text: '1'}));
-    }
+    });
+
     await waitFor(['1 [A] [render]', '1 [B] [render]']);
 
     // Before the update can finish, update again. Even though no time has
@@ -371,13 +358,9 @@ describe('ReactExpiration', () => {
       );
     }
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        root.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       root.render(<App />);
-    }
+    });
 
     await waitFor(['A']);
     await waitFor(['B']);
@@ -404,13 +387,9 @@ describe('ReactExpiration', () => {
         </>
       );
     }
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        root.render(<App />);
-      });
-    } else {
+    React.startTransition(() => {
       root.render(<App />);
-    }
+    });
 
     await waitFor(['A']);
     await waitFor(['B']);
@@ -429,7 +408,26 @@ describe('ReactExpiration', () => {
     jest.resetModules();
     Scheduler = require('scheduler');
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
+    if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {
+      // Before importing the renderer, advance the current time by a number
+      // larger than the maximum allowed for bitwise operations.
+      const maxSigned31BitInt = 1073741823;
+      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
+      // Now import the renderer. On module initialization, it will read the
+      // current time.
+      ReactNoop = require('react-noop-renderer');
+      ReactNoop.render('Hi');
+
+      // The update should not have expired yet.
+      flushNextRenderIfExpired();
+      await waitFor([]);
+      expect(ReactNoop).toMatchRenderedOutput(null);
+      // Advance the time some more to expire the update.
+      Scheduler.unstable_advanceTime(10000);
+      flushNextRenderIfExpired();
+      await waitFor([]);
+      expect(ReactNoop).toMatchRenderedOutput('Hi');
+    } else {
       const InternalTestUtils = require('internal-test-utils');
       waitFor = InternalTestUtils.waitFor;
       assertLog = InternalTestUtils.assertLog;
@@ -446,14 +444,10 @@ describe('ReactExpiration', () => {
       React = require('react');
 
       ReactNoop.render(<Text text="Step 1" />);
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          ReactNoop.render(<Text text="Step 2" />);
-        });
-        await waitFor(['Step 1']);
-      } else {
-        ReactNoop.render('Hi');
-      }
+      React.startTransition(() => {
+        ReactNoop.render(<Text text="Step 2" />);
+      });
+      await waitFor(['Step 1']);
 
       // The update should not have expired yet.
       await unstable_waitForExpired([]);
@@ -464,25 +458,6 @@ describe('ReactExpiration', () => {
       Scheduler.unstable_advanceTime(10000);
       await unstable_waitForExpired(['Step 2']);
       expect(ReactNoop).toMatchRenderedOutput('Step 2');
-    } else {
-      // Before importing the renderer, advance the current time by a number
-      // larger than the maximum allowed for bitwise operations.
-      const maxSigned31BitInt = 1073741823;
-      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
-      // Now import the renderer. On module initialization, it will read the
-      // current time.
-      ReactNoop = require('react-noop-renderer');
-      ReactNoop.render('Hi');
-
-      // The update should not have expired yet.
-      flushNextRenderIfExpired();
-      await waitFor([]);
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance the time some more to expire the update.
-      Scheduler.unstable_advanceTime(10000);
-      flushNextRenderIfExpired();
-      await waitFor([]);
-      expect(ReactNoop).toMatchRenderedOutput('Hi');
     }
   });
 
@@ -494,13 +469,10 @@ describe('ReactExpiration', () => {
     // Before scheduling an update, advance the current time.
     Scheduler.unstable_advanceTime(10000);
 
-    if (gate(flags => flags.enableSyncDefaultUpdates)) {
-      React.startTransition(() => {
-        ReactNoop.render('Hi');
-      });
-    } else {
+    React.startTransition(() => {
       ReactNoop.render('Hi');
-    }
+    });
+
     await unstable_waitForExpired([]);
     expect(ReactNoop).toMatchRenderedOutput(null);
 
@@ -541,13 +513,9 @@ describe('ReactExpiration', () => {
 
     // First demonstrate what happens when there's no starvation
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          updateNormalPri();
-        });
-      } else {
+      React.startTransition(() => {
         updateNormalPri();
-      }
+      });
       await waitFor(['Sync pri: 0']);
       updateSyncPri();
       assertLog(['Sync pri: 1', 'Normal pri: 0']);
@@ -565,13 +533,9 @@ describe('ReactExpiration', () => {
 
     // Do the same thing, but starve the first update
     await act(async () => {
-      if (gate(flags => flags.enableSyncDefaultUpdates)) {
-        React.startTransition(() => {
-          updateNormalPri();
-        });
-      } else {
+      React.startTransition(() => {
         updateNormalPri();
-      }
+      });
       await waitFor(['Sync pri: 1']);
 
       // This time, a lot of time has elapsed since the normal pri update

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index cd09ca3478..ef560f4ffe 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -25,8 +25,6 @@ let unstable_waitForExpired;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
-    jest.resetModules();
-
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
@@ -405,7 +403,6 @@ describe('ReactExpiration', () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.
 
-    jest.resetModules();
     Scheduler = require('scheduler');
 
     if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index ef560f4ffe..cd09ca3478 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -25,6 +25,8 @@ let unstable_waitForExpired;
 
 describe('ReactExpiration', () => {
   beforeEach(() => {
+    jest.resetModules();
+
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
@@ -403,6 +405,7 @@ describe('ReactExpiration', () => {
     // Tests an implementation detail where expiration times are computed using
     // bitwise operations.
 
+    jest.resetModules();
     Scheduler = require('scheduler');
 
     if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {

commit e902c45caf7ca67810d3e53748a549bdcc36063b
Author: Jack Pope <jackpope1@gmail.com>
Date:   Wed Jul 24 10:17:33 2024 -0400

    Remove forceConcurrentByDefaultForTesting flag (#30436)
    
    Concurrent by default has been unshipped! Let's clean it up.
    
    Here we remove `forceConcurrentByDefaultForTesting`, which allows us to
    run tests against both concurrent strategies. In the next PR, we'll
    remove the actual concurrent by default code path.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index cd09ca3478..1d659cae3c 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -115,54 +115,28 @@ describe('ReactExpiration', () => {
     }
   }
 
-  function flushNextRenderIfExpired() {
-    // This will start rendering the next level of work. If the work hasn't
-    // expired yet, React will exit without doing anything. If it has expired,
-    // it will schedule a sync task.
-    Scheduler.unstable_flushExpired();
-    // Flush the sync task.
-    ReactNoop.flushSync();
-  }
-
   it('increases priority of updates as time progresses', async () => {
-    if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {
-      ReactNoop.render(<span prop="done" />);
-      expect(ReactNoop).toMatchRenderedOutput(null);
-
-      // Nothing has expired yet because time hasn't advanced.
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance time a bit, but not enough to expire the low pri update.
-      ReactNoop.expire(4500);
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance by another second. Now the update should expire and flush.
-      ReactNoop.expire(500);
-      flushNextRenderIfExpired();
-      expect(ReactNoop).toMatchRenderedOutput(<span prop="done" />);
-    } else {
-      ReactNoop.render(<Text text="Step 1" />);
-      React.startTransition(() => {
-        ReactNoop.render(<Text text="Step 2" />);
-      });
-      await waitFor(['Step 1']);
+    ReactNoop.render(<Text text="Step 1" />);
+    React.startTransition(() => {
+      ReactNoop.render(<Text text="Step 2" />);
+    });
+    await waitFor(['Step 1']);
 
-      expect(ReactNoop).toMatchRenderedOutput('Step 1');
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-      // Nothing has expired yet because time hasn't advanced.
-      await unstable_waitForExpired([]);
-      expect(ReactNoop).toMatchRenderedOutput('Step 1');
+    // Nothing has expired yet because time hasn't advanced.
+    await unstable_waitForExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-      // Advance time a bit, but not enough to expire the low pri update.
-      ReactNoop.expire(4500);
-      await unstable_waitForExpired([]);
-      expect(ReactNoop).toMatchRenderedOutput('Step 1');
+    // Advance time a bit, but not enough to expire the low pri update.
+    ReactNoop.expire(4500);
+    await unstable_waitForExpired([]);
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-      // Advance by a little bit more. Now the update should expire and flush.
-      ReactNoop.expire(500);
-      await unstable_waitForExpired(['Step 2']);
-      expect(ReactNoop).toMatchRenderedOutput('Step 2');
-    }
+    // Advance by a little bit more. Now the update should expire and flush.
+    ReactNoop.expire(500);
+    await unstable_waitForExpired(['Step 2']);
+    expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
   it('two updates of like priority in the same event always flush within the same batch', async () => {
@@ -408,57 +382,36 @@ describe('ReactExpiration', () => {
     jest.resetModules();
     Scheduler = require('scheduler');
 
-    if (gate(flags => flags.forceConcurrentByDefaultForTesting)) {
-      // Before importing the renderer, advance the current time by a number
-      // larger than the maximum allowed for bitwise operations.
-      const maxSigned31BitInt = 1073741823;
-      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
-      // Now import the renderer. On module initialization, it will read the
-      // current time.
-      ReactNoop = require('react-noop-renderer');
-      ReactNoop.render('Hi');
+    const InternalTestUtils = require('internal-test-utils');
+    waitFor = InternalTestUtils.waitFor;
+    assertLog = InternalTestUtils.assertLog;
+    unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
 
-      // The update should not have expired yet.
-      flushNextRenderIfExpired();
-      await waitFor([]);
-      expect(ReactNoop).toMatchRenderedOutput(null);
-      // Advance the time some more to expire the update.
-      Scheduler.unstable_advanceTime(10000);
-      flushNextRenderIfExpired();
-      await waitFor([]);
-      expect(ReactNoop).toMatchRenderedOutput('Hi');
-    } else {
-      const InternalTestUtils = require('internal-test-utils');
-      waitFor = InternalTestUtils.waitFor;
-      assertLog = InternalTestUtils.assertLog;
-      unstable_waitForExpired = InternalTestUtils.unstable_waitForExpired;
-
-      // Before importing the renderer, advance the current time by a number
-      // larger than the maximum allowed for bitwise operations.
-      const maxSigned31BitInt = 1073741823;
-      Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
-
-      // Now import the renderer. On module initialization, it will read the
-      // current time.
-      ReactNoop = require('react-noop-renderer');
-      React = require('react');
-
-      ReactNoop.render(<Text text="Step 1" />);
-      React.startTransition(() => {
-        ReactNoop.render(<Text text="Step 2" />);
-      });
-      await waitFor(['Step 1']);
+    // Before importing the renderer, advance the current time by a number
+    // larger than the maximum allowed for bitwise operations.
+    const maxSigned31BitInt = 1073741823;
+    Scheduler.unstable_advanceTime(maxSigned31BitInt * 100);
+
+    // Now import the renderer. On module initialization, it will read the
+    // current time.
+    ReactNoop = require('react-noop-renderer');
+    React = require('react');
+
+    ReactNoop.render(<Text text="Step 1" />);
+    React.startTransition(() => {
+      ReactNoop.render(<Text text="Step 2" />);
+    });
+    await waitFor(['Step 1']);
 
-      // The update should not have expired yet.
-      await unstable_waitForExpired([]);
+    // The update should not have expired yet.
+    await unstable_waitForExpired([]);
 
-      expect(ReactNoop).toMatchRenderedOutput('Step 1');
+    expect(ReactNoop).toMatchRenderedOutput('Step 1');
 
-      // Advance the time some more to expire the update.
-      Scheduler.unstable_advanceTime(10000);
-      await unstable_waitForExpired(['Step 2']);
-      expect(ReactNoop).toMatchRenderedOutput('Step 2');
-    }
+    // Advance the time some more to expire the update.
+    Scheduler.unstable_advanceTime(10000);
+    await unstable_waitForExpired(['Step 2']);
+    expect(ReactNoop).toMatchRenderedOutput('Step 2');
   });
 
   it('should measure callback timeout relative to current time, not start-up time', async () => {

commit e10e8681824e56c10fdb14e0359d878bcd748937
Author: Andrew Clark <git@andrewclark.io>
Date:   Wed Sep 4 13:55:29 2024 -0400

    Schedule prerender after something suspends (#30800)
    
    Adds the concept of a "prerender". These special renders are spawned
    whenever something suspends (and we're not already prerendering).
    
    The purpose is to move speculative rendering work into a separate phase
    that does not block the UI from updating. For example, during a
    transition, if something suspends, we should not speculatively prerender
    siblings that will be replaced by a fallback in the UI until *after* the
    fallback has been shown to the user.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 1d659cae3c..50fc167709 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -652,7 +652,14 @@ describe('ReactExpiration', () => {
       React.startTransition(() => {
         root.render(<App step={1} />);
       });
-      await waitForAll(['Suspend! [A1]', 'Loading...']);
+      await waitForAll([
+        'Suspend! [A1]',
+        'Loading...',
+
+        ...(gate('enableSiblingPrerendering')
+          ? ['Suspend! [A1]', 'B', 'C', 'Loading...']
+          : []),
+      ]);
 
       // Lots of time elapses before the promise resolves
       Scheduler.unstable_advanceTime(10000);

commit 66cf2cfc8a8c4b09d2b783fd7302ae6b24150935
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Sep 10 13:23:32 2024 -0400

    Prerender during same pass if blocked anyway (#30879)
    
    If something suspends in the shell — i.e. we won't replace the suspended
    content with a fallback — we might as well prerender the siblings during
    the current render pass, instead of spawning a separate prerender pass.
    
    This is implemented by setting the "is prerendering" flag to true
    whenever we suspend in the shell. But only if we haven't already skipped
    over some siblings, because if so, then we need to schedule a separate
    prerender pass regardless.

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index 50fc167709..aef0628866 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -654,11 +654,10 @@ describe('ReactExpiration', () => {
       });
       await waitForAll([
         'Suspend! [A1]',
-        'Loading...',
 
-        ...(gate('enableSiblingPrerendering')
-          ? ['Suspend! [A1]', 'B', 'C', 'Loading...']
-          : []),
+        ...(gate('enableSiblingPrerendering') ? ['B', 'C'] : []),
+
+        'Loading...',
       ]);
 
       // Lots of time elapses before the promise resolves

commit facec3ee71fff8b23f1e91005fce730cc96e4021
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Tue Dec 17 17:01:31 2024 -0500

    [Fiber] Schedule passive effects using the regular ensureRootIsScheduled flow (#31785)
    
    This treats workInProgressRoot work and rootWithPendingPassiveEffects
    the same way. Basically as long as there's some work on the root, yield
    the current task. Including passive effects. This means that passive
    effects are now a continuation instead of a separate callback. This can
    mean they're earlier or later than before. Later for Idle in case
    there's other non-React work. Earlier for same Default if there's other
    Default priority work.
    
    This makes sense since increasing priority of the passive effects beyond
    Idle doesn't really make sense for an Idle render.
    
    However, for any given render at same priority it's more important to
    complete this work than start something new.
    
    Since we special case continuations to always yield to the browser, this
    has the same effect as #31784 without implementing `requestPaint`. At
    least assuming nothing else calls `requestPaint`.
    
    <img width="587" alt="Screenshot 2024-12-14 at 5 37 37 PM"
    src="https://github.com/user-attachments/assets/8641b172-8842-4191-8bf0-50cbe263a30c"
    />

diff --git a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
index aef0628866..5b09d7d0b8 100644
--- a/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactExpiration-test.js
@@ -755,10 +755,16 @@ describe('ReactExpiration', () => {
 
       // The update finishes without yielding. But it does not flush the effect.
       await waitFor(['B1'], {
-        additionalLogsAfterAttemptingToYield: ['C1'],
+        additionalLogsAfterAttemptingToYield: gate(
+          flags => flags.enableYieldingBeforePassive,
+        )
+          ? ['C1', 'Effect: 1']
+          : ['C1'],
       });
     });
-    // The effect flushes after paint.
-    assertLog(['Effect: 1']);
+    if (!gate(flags => flags.enableYieldingBeforePassive)) {
+      // The effect flushes after paint.
+      assertLog(['Effect: 1']);
+    }
   });
 });

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    