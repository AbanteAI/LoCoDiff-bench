<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs - Sonnet 4 Thinking</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs</h1>
        <h2>Model: Sonnet 4 Thinking</h2>
        <p><a href="../../../cases/anthropic_claude-sonnet-4thinking/qdrant_lib_segment_src_vector_storage_dense_memmap_dense_vector_storage.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
new file mode 100644
index 000000000..5fd49ab53
--- /dev/null
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -0,0 +1,761 @@
+use std::fs::{create_dir_all, File, OpenOptions};
+use std::io::{self, Write};
+use std::ops::Range;
+use std::path::{Path, PathBuf};
+use std::sync::atomic::AtomicBool;
+use std::sync::Arc;
+
+use atomic_refcell::AtomicRefCell;
+use bitvec::prelude::BitSlice;
+use common::types::PointOffsetType;
+use memory::mmap_ops;
+
+use crate::common::operation_error::{check_process_stopped, OperationResult};
+use crate::common::Flusher;
+use crate::data_types::named_vectors::CowVector;
+use crate::data_types::primitive::PrimitiveVectorElement;
+use crate::data_types::vectors::{VectorElementType, VectorRef};
+use crate::types::Distance;
+use crate::vector_storage::common::get_async_scorer;
+use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
+use crate::vector_storage::{DenseVectorStorage, VectorStorage, VectorStorageEnum};
+
+const VECTORS_PATH: &str = "matrix.dat";
+const DELETED_PATH: &str = "deleted.dat";
+
+/// Stores all dense vectors in mem-mapped file
+///
+/// It is not possible to insert new vectors into mem-mapped storage,
+/// but possible to mark some vectors as removed
+///
+/// Mem-mapped storage can only be constructed from another storage
+pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {
+    vectors_path: PathBuf,
+    deleted_path: PathBuf,
+    mmap_store: Option<MmapDenseVectors<T>>,
+    distance: Distance,
+}
+
+pub fn open_memmap_vector_storage(
+    path: &Path,
+    dim: usize,
+    distance: Distance,
+) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+    open_memmap_vector_storage_with_async_io(path, dim, distance, get_async_scorer())
+}
+
+pub fn open_memmap_vector_storage_with_async_io(
+    path: &Path,
+    dim: usize,
+    distance: Distance,
+    with_async_io: bool,
+) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+    create_dir_all(path)?;
+
+    let vectors_path = path.join(VECTORS_PATH);
+    let deleted_path = path.join(DELETED_PATH);
+    let mmap_store = MmapDenseVectors::open(&vectors_path, &deleted_path, dim, with_async_io)?;
+
+    Ok(Arc::new(AtomicRefCell::new(
+        VectorStorageEnum::DenseMemmap(Box::new(MemmapDenseVectorStorage {
+            vectors_path,
+            deleted_path,
+            mmap_store: Some(mmap_store),
+            distance,
+        })),
+    )))
+}
+
+impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
+    pub fn prefault_mmap_pages(&self) -> Option<mmap_ops::PrefaultMmapPages> {
+        Some(
+            self.mmap_store
+                .as_ref()?
+                .prefault_mmap_pages(&self.vectors_path),
+        )
+    }
+
+    pub fn get_mmap_vectors(&self) -> &MmapDenseVectors<T> {
+        self.mmap_store.as_ref().unwrap()
+    }
+
+    pub fn has_async_reader(&self) -> bool {
+        self.mmap_store
+            .as_ref()
+            .map(|x| x.has_async_reader())
+            .unwrap_or(false)
+    }
+}
+
+impl DenseVectorStorage<VectorElementType> for MemmapDenseVectorStorage<VectorElementType> {
+    fn get_dense(&self, key: PointOffsetType) -> &[VectorElementType] {
+        self.mmap_store.as_ref().unwrap().get_vector(key)
+    }
+}
+
+impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
+    fn vector_dim(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().dim
+    }
+
+    fn distance(&self) -> Distance {
+        self.distance
+    }
+
+    fn is_on_disk(&self) -> bool {
+        true
+    }
+
+    fn total_vector_count(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().num_vectors
+    }
+
+    fn get_vector(&self, key: PointOffsetType) -> CowVector {
+        T::vector_to_cow(self.mmap_store.as_ref().unwrap().get_vector(key))
+    }
+
+    fn insert_vector(&mut self, _key: PointOffsetType, _vector: VectorRef) -> OperationResult<()> {
+        panic!("Can't directly update vector in mmap storage")
+    }
+
+    fn update_from(
+        &mut self,
+        other: &VectorStorageEnum,
+        other_ids: &mut impl Iterator<Item = PointOffsetType>,
+        stopped: &AtomicBool,
+    ) -> OperationResult<Range<PointOffsetType>> {
+        let dim = self.vector_dim();
+        let start_index = self.mmap_store.as_ref().unwrap().num_vectors as PointOffsetType;
+        let mut end_index = start_index;
+
+        let with_async_io = self
+            .mmap_store
+            .take()
+            .map(|x| x.has_async_reader())
+            .unwrap_or(get_async_scorer());
+
+        // Extend vectors file, write other vectors into it
+        let mut vectors_file = open_append(&self.vectors_path)?;
+        let mut deleted_ids = vec![];
+        for id in other_ids {
+            check_process_stopped(stopped)?;
+            let other_vector = other.get_vector(id);
+            let vector = T::from_vector_ref(other_vector.as_vec_ref())?;
+            let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());
+            vectors_file.write_all(raw_bites)?;
+            end_index += 1;
+
+            // Remember deleted IDs so we can propagate deletions later
+            if other.is_deleted_vector(id) {
+                deleted_ids.push((start_index + id) as PointOffsetType);
+            }
+        }
+        vectors_file.flush()?;
+        drop(vectors_file);
+
+        // Load store with updated files
+        self.mmap_store.replace(MmapDenseVectors::open(
+            &self.vectors_path,
+            &self.deleted_path,
+            dim,
+            with_async_io,
+        )?);
+
+        // Flush deleted flags into store
+        // We must do that in the updated store, and cannot do it in the previous loop. That is
+        // because the file backing delete storage must be resized, and for that we'd need to know
+        // the exact number of vectors beforehand. When opening the store it is done automatically.
+        let store = self.mmap_store.as_mut().unwrap();
+        for id in deleted_ids {
+            check_process_stopped(stopped)?;
+            store.delete(id);
+        }
+
+        Ok(start_index..end_index)
+    }
+
+    fn flusher(&self) -> Flusher {
+        match &self.mmap_store {
+            Some(mmap_store) => mmap_store.flusher(),
+            None => Box::new(|| Ok(())),
+        }
+    }
+
+    fn files(&self) -> Vec<PathBuf> {
+        vec![self.vectors_path.clone(), self.deleted_path.clone()]
+    }
+
+    fn delete_vector(&mut self, key: PointOffsetType) -> OperationResult<bool> {
+        Ok(self.mmap_store.as_mut().unwrap().delete(key))
+    }
+
+    fn is_deleted_vector(&self, key: PointOffsetType) -> bool {
+        self.mmap_store.as_ref().unwrap().is_deleted_vector(key)
+    }
+
+    fn deleted_vector_count(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().deleted_count
+    }
+
+    fn deleted_vector_bitslice(&self) -> &BitSlice {
+        self.mmap_store.as_ref().unwrap().deleted_vector_bitslice()
+    }
+}
+
+/// Open a file shortly for appending
+fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
+    OpenOptions::new()
+        .read(false)
+        .write(false)
+        .append(true)
+        .create(false)
+        .open(path)
+}
+
+#[cfg(test)]
+mod tests {
+    use std::mem::transmute;
+
+    use common::types::ScoredPointOffset;
+    use memory::mmap_ops::transmute_to_u8_slice;
+    use tempfile::Builder;
+
+    use super::*;
+    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+    use crate::data_types::vectors::{DenseVector, QueryVector};
+    use crate::fixtures::payload_context_fixture::FixtureIdTracker;
+    use crate::id_tracker::IdTracker;
+    use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
+    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
+    use crate::vector_storage::new_raw_scorer;
+    use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+
+    #[test]
+    fn test_basic_persistence() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let points = [
+            vec![1.0, 0.0, 1.0, 1.0],
+            vec![1.0, 0.0, 1.0, 0.0],
+            vec![1.0, 1.0, 1.0, 1.0],
+            vec![1.0, 1.0, 0.0, 1.0],
+            vec![1.0, 0.0, 0.0, 0.0],
+        ];
+        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.borrow_mut();
+
+        // Assert this storage lists both the vector and deleted file
+        let files = borrowed_storage.files();
+        for file_name in [VECTORS_PATH, DELETED_PATH] {
+            files
+                .iter()
+                .find(|p| p.file_name().unwrap() == file_name)
+                .expect("storage is missing required file");
+        }
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                borrowed_storage2
+                    .insert_vector(0, points[0].as_slice().into())
+                    .unwrap();
+                borrowed_storage2
+                    .insert_vector(1, points[1].as_slice().into())
+                    .unwrap();
+                borrowed_storage2
+                    .insert_vector(2, points[2].as_slice().into())
+                    .unwrap();
+            }
+            borrowed_storage
+                .update_from(&storage2.borrow(), &mut Box::new(0..3), &Default::default())
+                .unwrap();
+        }
+
+        assert_eq!(borrowed_storage.total_vector_count(), 3);
+
+        let vector = borrowed_storage.get_vector(1).to_owned();
+        let vector: DenseVector = vector.try_into().unwrap();
+
+        assert_eq!(points[1], vector);
+
+        borrowed_id_tracker.drop(PointIdType::NumId(2)).unwrap();
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                borrowed_storage2
+                    .insert_vector(3, points[3].as_slice().into())
+                    .unwrap();
+                borrowed_storage2
+                    .insert_vector(4, points[4].as_slice().into())
+                    .unwrap();
+            }
+            borrowed_storage
+                .update_from(&storage2.borrow(), &mut Box::new(0..2), &Default::default())
+                .unwrap();
+        }
+
+        assert_eq!(borrowed_storage.total_vector_count(), 5);
+
+        let stored_ids: Vec<PointOffsetType> = borrowed_id_tracker.iter_ids().collect();
+
+        assert_eq!(stored_ids, [0, 1, 3, 4]);
+
+        let raw_scorer = new_raw_scorer(
+            points[2].as_slice().into(),
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap();
+        let res = raw_scorer.peek_top_all(2);
+
+        assert_eq!(res.len(), 2);
+
+        assert_ne!(res[0].idx, 2);
+
+        let res = raw_scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2);
+
+        assert_eq!(res.len(), 2);
+        assert_ne!(res[0].idx, 2);
+    }
+
+    #[test]
+    fn test_delete_points() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let points = [
+            vec![1.0, 0.0, 1.0, 1.0],
+            vec![1.0, 0.0, 1.0, 0.0],
+            vec![1.0, 1.0, 1.0, 1.0],
+            vec![1.0, 1.0, 0.0, 1.0],
+            vec![1.0, 0.0, 0.0, 0.0],
+        ];
+        let delete_mask = [false, false, true, true, false];
+        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.borrow_mut();
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                points.iter().enumerate().for_each(|(i, vec)| {
+                    borrowed_storage2
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .unwrap();
+                });
+            }
+            borrowed_storage
+                .update_from(
+                    &storage2.borrow(),
+                    &mut Box::new(0..points.len() as u32),
+                    &Default::default(),
+                )
+                .unwrap();
+        }
+
+        assert_eq!(borrowed_storage.total_vector_count(), 5);
+        assert_eq!(borrowed_storage.deleted_vector_count(), 0);
+
+        // Delete select number of points
+        delete_mask
+            .into_iter()
+            .enumerate()
+            .filter(|(_, d)| *d)
+            .for_each(|(i, _)| {
+                borrowed_storage
+                    .delete_vector(i as PointOffsetType)
+                    .unwrap();
+            });
+        assert_eq!(
+            borrowed_storage.deleted_vector_count(),
+            2,
+            "2 vectors must be deleted"
+        );
+
+        let vector = vec![0.0, 1.0, 1.1, 1.0];
+        let query = vector.as_slice().into();
+        let closest = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap()
+        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
+        assert_eq!(closest[0].idx, 0);
+        assert_eq!(closest[1].idx, 1);
+        assert_eq!(closest[2].idx, 4);
+
+        // Delete 1, redelete 2
+        borrowed_storage
+            .delete_vector(1 as PointOffsetType)
+            .unwrap();
+        borrowed_storage
+            .delete_vector(2 as PointOffsetType)
+            .unwrap();
+        assert_eq!(
+            borrowed_storage.deleted_vector_count(),
+            3,
+            "3 vectors must be deleted"
+        );
+
+        let vector = vec![1.0, 0.0, 0.0, 0.0];
+        let query = vector.as_slice().into();
+
+        let closest = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap()
+        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");
+        assert_eq!(closest[0].idx, 4);
+        assert_eq!(closest[1].idx, 0);
+
+        // Delete all
+        borrowed_storage
+            .delete_vector(0 as PointOffsetType)
+            .unwrap();
+        borrowed_storage
+            .delete_vector(4 as PointOffsetType)
+            .unwrap();
+        assert_eq!(
+            borrowed_storage.deleted_vector_count(),
+            5,
+            "all vectors must be deleted"
+        );
+
+        let vector = vec![1.0, 0.0, 0.0, 0.0];
+        let query = vector.as_slice().into();
+        let closest = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap()
+        .peek_top_all(5);
+        assert!(closest.is_empty(), "must have no results, all deleted");
+    }
+
+    /// Test that deleted points are properly transferred when updating from other storage.
+    #[test]
+    fn test_update_from_delete_points() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let points = [
+            vec![1.0, 0.0, 1.0, 1.0],
+            vec![1.0, 0.0, 1.0, 0.0],
+            vec![1.0, 1.0, 1.0, 1.0],
+            vec![1.0, 1.0, 0.0, 1.0],
+            vec![1.0, 0.0, 0.0, 0.0],
+        ];
+        let delete_mask = [false, false, true, true, false];
+        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.borrow_mut();
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                points.iter().enumerate().for_each(|(i, vec)| {
+                    borrowed_storage2
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .unwrap();
+                    if delete_mask[i] {
+                        borrowed_storage2
+                            .delete_vector(i as PointOffsetType)
+                            .unwrap();
+                    }
+                });
+            }
+            borrowed_storage
+                .update_from(
+                    &storage2.borrow(),
+                    &mut Box::new(0..points.len() as u32),
+                    &Default::default(),
+                )
+                .unwrap();
+        }
+
+        assert_eq!(
+            borrowed_storage.deleted_vector_count(),
+            2,
+            "2 vectors must be deleted from other storage"
+        );
+
+        let vector = vec![0.0, 1.0, 1.1, 1.0];
+        let query = vector.as_slice().into();
+        let closest = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap()
+        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
+        assert_eq!(closest[0].idx, 0);
+        assert_eq!(closest[1].idx, 1);
+        assert_eq!(closest[2].idx, 4);
+
+        // Delete all
+        borrowed_storage
+            .delete_vector(0 as PointOffsetType)
+            .unwrap();
+        borrowed_storage
+            .delete_vector(1 as PointOffsetType)
+            .unwrap();
+        borrowed_storage
+            .delete_vector(4 as PointOffsetType)
+            .unwrap();
+        assert_eq!(
+            borrowed_storage.deleted_vector_count(),
+            5,
+            "all vectors must be deleted"
+        );
+    }
+
+    #[test]
+    fn test_mmap_raw_scorer() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let points = [
+            vec![1.0, 0.0, 1.0, 1.0],
+            vec![1.0, 0.0, 1.0, 0.0],
+            vec![1.0, 1.0, 1.0, 1.0],
+            vec![1.0, 1.0, 0.0, 1.0],
+            vec![1.0, 0.0, 0.0, 0.0],
+        ];
+        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.borrow_mut();
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                for (i, vec) in points.iter().enumerate() {
+                    borrowed_storage2
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .unwrap();
+                }
+            }
+            borrowed_storage
+                .update_from(
+                    &storage2.borrow(),
+                    &mut Box::new(0..points.len() as PointOffsetType),
+                    &Default::default(),
+                )
+                .unwrap();
+        }
+
+        let vector = vec![-1.0, -1.0, -1.0, -1.0];
+        let query = vector.as_slice().into();
+        let query_points: Vec<PointOffsetType> = vec![0, 2, 4];
+
+        let scorer = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap();
+
+        let mut res = vec![ScoredPointOffset { idx: 0, score: 0. }; query_points.len()];
+        let res_count = scorer.score_points(&query_points, &mut res);
+        res.resize(res_count, ScoredPointOffset { idx: 0, score: 0. });
+
+        assert_eq!(res.len(), 3);
+        assert_eq!(res[0].idx, 0);
+        assert_eq!(res[1].idx, 2);
+        assert_eq!(res[2].idx, 4);
+
+        assert_eq!(res[2].score, -1.0);
+    }
+
+    #[test]
+    fn test_casts() {
+        let data: DenseVector = vec![0.42, 0.069, 333.1, 100500.];
+
+        let raw_data = transmute_to_u8_slice(&data);
+
+        eprintln!("raw_data.len() = {:#?}", raw_data.len());
+
+        let arr: &[VectorElementType] = unsafe { transmute(raw_data) };
+
+        let slice = &arr[0..data.len()];
+
+        eprintln!("slice.len() = {:#?}", slice.len());
+
+        for (idx, element) in slice.iter().enumerate() {
+            println!("slice[{idx}]  = {element:?}");
+        }
+    }
+
+    #[test]
+    fn test_mmap_quantization() {
+        let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+        let points = [
+            vec![1.0, 0.0, 1.0, 1.0],
+            vec![1.0, 0.0, 1.0, 0.0],
+            vec![1.0, 1.0, 1.0, 1.0],
+            vec![1.0, 1.0, 0.0, 1.0],
+            vec![1.0, 0.0, 0.0, 0.0],
+        ];
+        let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
+        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let borrowed_id_tracker = id_tracker.borrow_mut();
+        let mut borrowed_storage = storage.borrow_mut();
+
+        {
+            let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
+            let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
+            let storage2 = open_simple_vector_storage(
+                db,
+                DB_VECTOR_CF,
+                4,
+                Distance::Dot,
+                &AtomicBool::new(false),
+            )
+            .unwrap();
+            {
+                let mut borrowed_storage2 = storage2.borrow_mut();
+                for (i, vec) in points.iter().enumerate() {
+                    borrowed_storage2
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .unwrap();
+                }
+            }
+            borrowed_storage
+                .update_from(
+                    &storage2.borrow(),
+                    &mut Box::new(0..points.len() as PointOffsetType),
+                    &Default::default(),
+                )
+                .unwrap();
+        }
+
+        let config: QuantizationConfig = ScalarQuantizationConfig {
+            r#type: Default::default(),
+            quantile: None,
+            always_ram: None,
+        }
+        .into();
+
+        let stopped = Arc::new(AtomicBool::new(false));
+        let quantized_vectors =
+            QuantizedVectors::create(&borrowed_storage, &config, dir.path(), 1, &stopped).unwrap();
+
+        let query: QueryVector = [0.5, 0.5, 0.5, 0.5].into();
+
+        let scorer_quant = quantized_vectors
+            .raw_scorer(
+                query.clone(),
+                borrowed_id_tracker.deleted_point_bitslice(),
+                borrowed_storage.deleted_vector_bitslice(),
+                &stopped,
+            )
+            .unwrap();
+        let scorer_orig = new_raw_scorer(
+            query.clone(),
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap();
+        for i in 0..5 {
+            let quant = scorer_quant.score_point(i);
+            let orig = scorer_orig.score_point(i);
+            assert!((orig - quant).abs() < 0.15);
+
+            let quant = scorer_quant.score_internal(0, i);
+            let orig = scorer_orig.score_internal(0, i);
+            assert!((orig - quant).abs() < 0.15);
+        }
+        let files = borrowed_storage.files();
+        let quantization_files = quantized_vectors.files();
+
+        // test save-load
+        let quantized_vectors = QuantizedVectors::load(&borrowed_storage, dir.path()).unwrap();
+        assert_eq!(files, borrowed_storage.files());
+        assert_eq!(quantization_files, quantized_vectors.files());
+
+        let scorer_quant = quantized_vectors
+            .raw_scorer(
+                query.clone(),
+                borrowed_id_tracker.deleted_point_bitslice(),
+                borrowed_storage.deleted_vector_bitslice(),
+                &stopped,
+            )
+            .unwrap();
+        let scorer_orig = new_raw_scorer(
+            query,
+            &borrowed_storage,
+            borrowed_id_tracker.deleted_point_bitslice(),
+        )
+        .unwrap();
+
+        for i in 0..5 {
+            let quant = scorer_quant.score_point(i);
+            let orig = scorer_orig.score_point(i);
+            assert!((orig - quant).abs() < 0.15);
+
+            let quant = scorer_quant.score_internal(0, i);
+            let orig = scorer_orig.score_internal(0, i);
+            assert!((orig - quant).abs() < 0.15);
+        }
+    }
+}

commit a330542c8ac3b3228e0f06d1b9fd1c2ce36230f0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Apr 8 12:22:24 2024 +0200

    Integrate Multivector at segment level (#3973)
    
    * Integrate Multivector at segment level
    
    * more tests - green with lower accuracy
    
    * decrease expected accuracy to fix test
    
    * cleanup test
    
    * multivector can not be empty
    
    * vary number of vector per multivec point

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 5fd49ab53..f623cb4e3 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -226,7 +226,7 @@ mod tests {
     use crate::fixtures::payload_context_fixture::FixtureIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
-    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
+    use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
     use crate::vector_storage::new_raw_scorer;
     use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 
@@ -258,7 +258,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -295,7 +295,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -361,7 +361,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -492,7 +492,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -578,7 +578,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -664,7 +664,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_vector_storage(
+            let storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index f623cb4e3..7a9db3ab6 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -1,3 +1,4 @@
+use std::borrow::Cow;
 use std::fs::{create_dir_all, File, OpenOptions};
 use std::io::{self, Write};
 use std::ops::Range;
@@ -14,7 +15,7 @@ use crate::common::operation_error::{check_process_stopped, OperationResult};
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
-use crate::data_types::vectors::{VectorElementType, VectorRef};
+use crate::data_types::vectors::{VectorElementType, VectorElementTypeByte, VectorRef};
 use crate::types::Distance;
 use crate::vector_storage::common::get_async_scorer;
 use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
@@ -41,7 +42,31 @@ pub fn open_memmap_vector_storage(
     dim: usize,
     distance: Distance,
 ) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
-    open_memmap_vector_storage_with_async_io(path, dim, distance, get_async_scorer())
+    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
+        path,
+        dim,
+        distance,
+        get_async_scorer(),
+    )?;
+    Ok(Arc::new(AtomicRefCell::new(
+        VectorStorageEnum::DenseMemmap(storage),
+    )))
+}
+
+pub fn open_memmap_vector_storage_byte(
+    path: &Path,
+    dim: usize,
+    distance: Distance,
+) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementTypeByte>(
+        path,
+        dim,
+        distance,
+        get_async_scorer(),
+    )?;
+    Ok(Arc::new(AtomicRefCell::new(
+        VectorStorageEnum::DenseMemmapByte(storage),
+    )))
 }
 
 pub fn open_memmap_vector_storage_with_async_io(
@@ -50,20 +75,35 @@ pub fn open_memmap_vector_storage_with_async_io(
     distance: Distance,
     with_async_io: bool,
 ) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
+        path,
+        dim,
+        distance,
+        with_async_io,
+    )?;
+    Ok(Arc::new(AtomicRefCell::new(
+        VectorStorageEnum::DenseMemmap(storage),
+    )))
+}
+
+fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(
+    path: &Path,
+    dim: usize,
+    distance: Distance,
+    with_async_io: bool,
+) -> OperationResult<Box<MemmapDenseVectorStorage<T>>> {
     create_dir_all(path)?;
 
     let vectors_path = path.join(VECTORS_PATH);
     let deleted_path = path.join(DELETED_PATH);
     let mmap_store = MmapDenseVectors::open(&vectors_path, &deleted_path, dim, with_async_io)?;
 
-    Ok(Arc::new(AtomicRefCell::new(
-        VectorStorageEnum::DenseMemmap(Box::new(MemmapDenseVectorStorage {
-            vectors_path,
-            deleted_path,
-            mmap_store: Some(mmap_store),
-            distance,
-        })),
-    )))
+    Ok(Box::new(MemmapDenseVectorStorage {
+        vectors_path,
+        deleted_path,
+        mmap_store: Some(mmap_store),
+        distance,
+    }))
 }
 
 impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
@@ -87,8 +127,8 @@ impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
     }
 }
 
-impl DenseVectorStorage<VectorElementType> for MemmapDenseVectorStorage<VectorElementType> {
-    fn get_dense(&self, key: PointOffsetType) -> &[VectorElementType] {
+impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStorage<T> {
+    fn get_dense(&self, key: PointOffsetType) -> &[T] {
         self.mmap_store.as_ref().unwrap().get_vector(key)
     }
 }
@@ -111,7 +151,9 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
     }
 
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
-        T::vector_to_cow(self.mmap_store.as_ref().unwrap().get_vector(key))
+        CowVector::from(T::slice_to_float_cow(
+            self.mmap_store.as_ref().unwrap().get_vector(key).into(),
+        ))
     }
 
     fn insert_vector(&mut self, _key: PointOffsetType, _vector: VectorRef) -> OperationResult<()> {
@@ -140,7 +182,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         for id in other_ids {
             check_process_stopped(stopped)?;
             let other_vector = other.get_vector(id);
-            let vector = T::from_vector_ref(other_vector.as_vec_ref())?;
+            let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
             let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());
             vectors_file.write_all(raw_bites)?;
             end_index += 1;

commit fed7dadd641e5967da4a5413363ea57f08579bf4
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Apr 19 11:04:09 2024 +0200

    byte storage quantization fix and test (#4063)
    
    * byte storage quantization fix and test
    
    * apply quantization_preprocess in quantization scorers
    
    * exact true
    
    * exact true
    
    * calculate sames count
    
    * wrong distance getter
    
    * fix Manhattan distance getter
    
    * less acc check
    
    * fix build
    
    * update acc

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 7a9db3ab6..cca1ed173 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -16,7 +16,7 @@ use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{VectorElementType, VectorElementTypeByte, VectorRef};
-use crate::types::Distance;
+use crate::types::{Distance, VectorStorageDatatype};
 use crate::vector_storage::common::get_async_scorer;
 use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
 use crate::vector_storage::{DenseVectorStorage, VectorStorage, VectorStorageEnum};
@@ -142,6 +142,10 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         self.distance
     }
 
+    fn datatype(&self) -> VectorStorageDatatype {
+        T::datatype()
+    }
+
     fn is_on_disk(&self) -> bool {
         true
     }

commit 78b16a16a40919218339114bfc723048731ab4b3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed May 15 10:36:55 2024 +0200

    Float16 integration and API (#4234)
    
    * f16 integration
    
    tests
    
    api
    
    fix test
    
    are you happy clippy
    
    * fix build

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index cca1ed173..e2c84513c 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -15,7 +15,7 @@ use crate::common::operation_error::{check_process_stopped, OperationResult};
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
-use crate::data_types::vectors::{VectorElementType, VectorElementTypeByte, VectorRef};
+use crate::data_types::vectors::{VectorElementType, VectorRef};
 use crate::types::{Distance, VectorStorageDatatype};
 use crate::vector_storage::common::get_async_scorer;
 use crate::vector_storage::dense::mmap_dense_vectors::MmapDenseVectors;
@@ -58,17 +58,25 @@ pub fn open_memmap_vector_storage_byte(
     dim: usize,
     distance: Distance,
 ) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
-    let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementTypeByte>(
-        path,
-        dim,
-        distance,
-        get_async_scorer(),
-    )?;
+    let storage =
+        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
     Ok(Arc::new(AtomicRefCell::new(
         VectorStorageEnum::DenseMemmapByte(storage),
     )))
 }
 
+pub fn open_memmap_vector_storage_half(
+    path: &Path,
+    dim: usize,
+    distance: Distance,
+) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+    let storage =
+        open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
+    Ok(Arc::new(AtomicRefCell::new(
+        VectorStorageEnum::DenseMemmapHalf(storage),
+    )))
+}
+
 pub fn open_memmap_vector_storage_with_async_io(
     path: &Path,
     dim: usize,

commit 21a3fb5f38a796f37883017adc993d0322bbca8f
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue May 28 16:38:56 2024 +0200

    Use correct vector storage size (#4312)
    
    * use correct vector storage size
    
    * remove dim from segment entry
    
    * are you happy fmt
    
    * codespell and proportions
    
    * remove obsolete comment
    
    * remove `try_vector_dim`
    
    * are you happy fmt
    
    * remove todo
    
    * revert code of conduct
    
    * check div 0
    
    * Simplify a bit with max iterator
    
    * Update lib/segment/src/index/hnsw_index/hnsw.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * are you happy fmt
    
    * Update lib/segment/src/index/plain_payload_index.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * review fix
    
    * set full scan threshold 0 for test
    
    * use u128 also for multivector storages
    
    * fix sparse vector size calculation
    
    * Move size calculation into if-branch
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index e2c84513c..cba505b61 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -136,16 +136,16 @@ impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
 }
 
 impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStorage<T> {
+    fn vector_dim(&self) -> usize {
+        self.mmap_store.as_ref().unwrap().dim
+    }
+
     fn get_dense(&self, key: PointOffsetType) -> &[T] {
         self.mmap_store.as_ref().unwrap().get_vector(key)
     }
 }
 
 impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
-    fn vector_dim(&self) -> usize {
-        self.mmap_store.as_ref().unwrap().dim
-    }
-
     fn distance(&self) -> Distance {
         self.distance
     }
@@ -162,6 +162,10 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         self.mmap_store.as_ref().unwrap().num_vectors
     }
 
+    fn available_size_in_bytes(&self) -> usize {
+        self.available_vector_count() * self.vector_dim() * std::mem::size_of::<T>()
+    }
+
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         CowVector::from(T::slice_to_float_cow(
             self.mmap_store.as_ref().unwrap().get_vector(key).into(),

commit 96ecd2cca8ba311282b5d72c9e41ed71ddca036d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jun 4 11:16:11 2024 +0200

    Fix hnsw full scan threshold (#4369)
    
    * fix hnsw full scan threshold
    
    * add test
    
    * are you happy clippy
    
    * separate open_vector_storage
    
    * remove public fields from builder
    
    * wip: do not create segment in builder before build
    
    * avoid arc in storage test and low-level loading functions
    
    * WIP: remove internal segment from SegmentBuilder
    
    * fmt
    
    * finalize segment builder fixes
    
    * Revert "are you happy clippy"
    
    This reverts commit c04afa698995f75f8b589737c2a794aee03824d8.
    
    * Revert "add test"
    
    This reverts commit 8e7ad6207ed042f25dcd07a16fac7c109b9c5a9e.
    
    * Revert "fix hnsw full scan threshold"
    
    This reverts commit 8904443fcb849cca30885b0b6980b0113ed25c16.
    
    * remove _daatabse from builder
    
    * fix optimizer test
    
    * fix id tracker versions persistence
    
    * do flush for segment components on build
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index cba505b61..0c18517c6 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -4,9 +4,7 @@ use std::io::{self, Write};
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
-use std::sync::Arc;
 
-use atomic_refcell::AtomicRefCell;
 use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 use memory::mmap_ops;
@@ -41,40 +39,34 @@ pub fn open_memmap_vector_storage(
     path: &Path,
     dim: usize,
     distance: Distance,
-) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+) -> OperationResult<VectorStorageEnum> {
     let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
         path,
         dim,
         distance,
         get_async_scorer(),
     )?;
-    Ok(Arc::new(AtomicRefCell::new(
-        VectorStorageEnum::DenseMemmap(storage),
-    )))
+    Ok(VectorStorageEnum::DenseMemmap(storage))
 }
 
 pub fn open_memmap_vector_storage_byte(
     path: &Path,
     dim: usize,
     distance: Distance,
-) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+) -> OperationResult<VectorStorageEnum> {
     let storage =
         open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
-    Ok(Arc::new(AtomicRefCell::new(
-        VectorStorageEnum::DenseMemmapByte(storage),
-    )))
+    Ok(VectorStorageEnum::DenseMemmapByte(storage))
 }
 
 pub fn open_memmap_vector_storage_half(
     path: &Path,
     dim: usize,
     distance: Distance,
-) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+) -> OperationResult<VectorStorageEnum> {
     let storage =
         open_memmap_vector_storage_with_async_io_impl(path, dim, distance, get_async_scorer())?;
-    Ok(Arc::new(AtomicRefCell::new(
-        VectorStorageEnum::DenseMemmapHalf(storage),
-    )))
+    Ok(VectorStorageEnum::DenseMemmapHalf(storage))
 }
 
 pub fn open_memmap_vector_storage_with_async_io(
@@ -82,16 +74,14 @@ pub fn open_memmap_vector_storage_with_async_io(
     dim: usize,
     distance: Distance,
     with_async_io: bool,
-) -> OperationResult<Arc<AtomicRefCell<VectorStorageEnum>>> {
+) -> OperationResult<VectorStorageEnum> {
     let storage = open_memmap_vector_storage_with_async_io_impl::<VectorElementType>(
         path,
         dim,
         distance,
         with_async_io,
     )?;
-    Ok(Arc::new(AtomicRefCell::new(
-        VectorStorageEnum::DenseMemmap(storage),
-    )))
+    Ok(VectorStorageEnum::DenseMemmap(storage))
 }
 
 fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(
@@ -273,7 +263,9 @@ fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
 #[cfg(test)]
 mod tests {
     use std::mem::transmute;
+    use std::sync::Arc;
 
+    use atomic_refcell::AtomicRefCell;
     use common::types::ScoredPointOffset;
     use memory::mmap_ops::transmute_to_u8_slice;
     use tempfile::Builder;
@@ -282,7 +274,7 @@ mod tests {
     use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
     use crate::data_types::vectors::{DenseVector, QueryVector};
     use crate::fixtures::payload_context_fixture::FixtureIdTracker;
-    use crate::id_tracker::IdTracker;
+    use crate::id_tracker::id_tracker_base::IdTracker;
     use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
     use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
     use crate::vector_storage::new_raw_scorer;
@@ -300,12 +292,11 @@ mod tests {
             vec![1.0, 0.0, 0.0, 0.0],
         ];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let mut borrowed_id_tracker = id_tracker.borrow_mut();
-        let mut borrowed_storage = storage.borrow_mut();
 
         // Assert this storage lists both the vector and deleted file
-        let files = borrowed_storage.files();
+        let files = storage.files();
         for file_name in [VECTORS_PATH, DELETED_PATH] {
             files
                 .iter()
@@ -316,7 +307,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -325,25 +316,24 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
-                borrowed_storage2
+                storage2
                     .insert_vector(0, points[0].as_slice().into())
                     .unwrap();
-                borrowed_storage2
+                storage2
                     .insert_vector(1, points[1].as_slice().into())
                     .unwrap();
-                borrowed_storage2
+                storage2
                     .insert_vector(2, points[2].as_slice().into())
                     .unwrap();
             }
-            borrowed_storage
-                .update_from(&storage2.borrow(), &mut Box::new(0..3), &Default::default())
+            storage
+                .update_from(&storage2, &mut Box::new(0..3), &Default::default())
                 .unwrap();
         }
 
-        assert_eq!(borrowed_storage.total_vector_count(), 3);
+        assert_eq!(storage.total_vector_count(), 3);
 
-        let vector = borrowed_storage.get_vector(1).to_owned();
+        let vector = storage.get_vector(1).to_owned();
         let vector: DenseVector = vector.try_into().unwrap();
 
         assert_eq!(points[1], vector);
@@ -353,7 +343,7 @@ mod tests {
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -362,20 +352,19 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
-                borrowed_storage2
+                storage2
                     .insert_vector(3, points[3].as_slice().into())
                     .unwrap();
-                borrowed_storage2
+                storage2
                     .insert_vector(4, points[4].as_slice().into())
                     .unwrap();
             }
-            borrowed_storage
-                .update_from(&storage2.borrow(), &mut Box::new(0..2), &Default::default())
+            storage
+                .update_from(&storage2, &mut Box::new(0..2), &Default::default())
                 .unwrap();
         }
 
-        assert_eq!(borrowed_storage.total_vector_count(), 5);
+        assert_eq!(storage.total_vector_count(), 5);
 
         let stored_ids: Vec<PointOffsetType> = borrowed_id_tracker.iter_ids().collect();
 
@@ -383,7 +372,7 @@ mod tests {
 
         let raw_scorer = new_raw_scorer(
             points[2].as_slice().into(),
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
@@ -412,14 +401,13 @@ mod tests {
         ];
         let delete_mask = [false, false, true, true, false];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
-        let mut borrowed_storage = storage.borrow_mut();
 
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -428,24 +416,23 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
                 points.iter().enumerate().for_each(|(i, vec)| {
-                    borrowed_storage2
+                    storage2
                         .insert_vector(i as PointOffsetType, vec.as_slice().into())
                         .unwrap();
                 });
             }
-            borrowed_storage
+            storage
                 .update_from(
-                    &storage2.borrow(),
+                    &storage2,
                     &mut Box::new(0..points.len() as u32),
                     &Default::default(),
                 )
                 .unwrap();
         }
 
-        assert_eq!(borrowed_storage.total_vector_count(), 5);
-        assert_eq!(borrowed_storage.deleted_vector_count(), 0);
+        assert_eq!(storage.total_vector_count(), 5);
+        assert_eq!(storage.deleted_vector_count(), 0);
 
         // Delete select number of points
         delete_mask
@@ -453,12 +440,10 @@ mod tests {
             .enumerate()
             .filter(|(_, d)| *d)
             .for_each(|(i, _)| {
-                borrowed_storage
-                    .delete_vector(i as PointOffsetType)
-                    .unwrap();
+                storage.delete_vector(i as PointOffsetType).unwrap();
             });
         assert_eq!(
-            borrowed_storage.deleted_vector_count(),
+            storage.deleted_vector_count(),
             2,
             "2 vectors must be deleted"
         );
@@ -467,7 +452,7 @@ mod tests {
         let query = vector.as_slice().into();
         let closest = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap()
@@ -478,14 +463,10 @@ mod tests {
         assert_eq!(closest[2].idx, 4);
 
         // Delete 1, redelete 2
-        borrowed_storage
-            .delete_vector(1 as PointOffsetType)
-            .unwrap();
-        borrowed_storage
-            .delete_vector(2 as PointOffsetType)
-            .unwrap();
+        storage.delete_vector(1 as PointOffsetType).unwrap();
+        storage.delete_vector(2 as PointOffsetType).unwrap();
         assert_eq!(
-            borrowed_storage.deleted_vector_count(),
+            storage.deleted_vector_count(),
             3,
             "3 vectors must be deleted"
         );
@@ -495,7 +476,7 @@ mod tests {
 
         let closest = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap()
@@ -505,14 +486,10 @@ mod tests {
         assert_eq!(closest[1].idx, 0);
 
         // Delete all
-        borrowed_storage
-            .delete_vector(0 as PointOffsetType)
-            .unwrap();
-        borrowed_storage
-            .delete_vector(4 as PointOffsetType)
-            .unwrap();
+        storage.delete_vector(0 as PointOffsetType).unwrap();
+        storage.delete_vector(4 as PointOffsetType).unwrap();
         assert_eq!(
-            borrowed_storage.deleted_vector_count(),
+            storage.deleted_vector_count(),
             5,
             "all vectors must be deleted"
         );
@@ -521,7 +498,7 @@ mod tests {
         let query = vector.as_slice().into();
         let closest = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap()
@@ -543,14 +520,13 @@ mod tests {
         ];
         let delete_mask = [false, false, true, true, false];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
-        let mut borrowed_storage = storage.borrow_mut();
 
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -559,21 +535,18 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
                 points.iter().enumerate().for_each(|(i, vec)| {
-                    borrowed_storage2
+                    storage2
                         .insert_vector(i as PointOffsetType, vec.as_slice().into())
                         .unwrap();
                     if delete_mask[i] {
-                        borrowed_storage2
-                            .delete_vector(i as PointOffsetType)
-                            .unwrap();
+                        storage2.delete_vector(i as PointOffsetType).unwrap();
                     }
                 });
             }
-            borrowed_storage
+            storage
                 .update_from(
-                    &storage2.borrow(),
+                    &storage2,
                     &mut Box::new(0..points.len() as u32),
                     &Default::default(),
                 )
@@ -581,7 +554,7 @@ mod tests {
         }
 
         assert_eq!(
-            borrowed_storage.deleted_vector_count(),
+            storage.deleted_vector_count(),
             2,
             "2 vectors must be deleted from other storage"
         );
@@ -590,7 +563,7 @@ mod tests {
         let query = vector.as_slice().into();
         let closest = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap()
@@ -601,17 +574,11 @@ mod tests {
         assert_eq!(closest[2].idx, 4);
 
         // Delete all
-        borrowed_storage
-            .delete_vector(0 as PointOffsetType)
-            .unwrap();
-        borrowed_storage
-            .delete_vector(1 as PointOffsetType)
-            .unwrap();
-        borrowed_storage
-            .delete_vector(4 as PointOffsetType)
-            .unwrap();
+        storage.delete_vector(0 as PointOffsetType).unwrap();
+        storage.delete_vector(1 as PointOffsetType).unwrap();
+        storage.delete_vector(4 as PointOffsetType).unwrap();
         assert_eq!(
-            borrowed_storage.deleted_vector_count(),
+            storage.deleted_vector_count(),
             5,
             "all vectors must be deleted"
         );
@@ -629,14 +596,13 @@ mod tests {
             vec![1.0, 0.0, 0.0, 0.0],
         ];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
-        let mut borrowed_storage = storage.borrow_mut();
 
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -645,16 +611,15 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
                 for (i, vec) in points.iter().enumerate() {
-                    borrowed_storage2
+                    storage2
                         .insert_vector(i as PointOffsetType, vec.as_slice().into())
                         .unwrap();
                 }
             }
-            borrowed_storage
+            storage
                 .update_from(
-                    &storage2.borrow(),
+                    &storage2,
                     &mut Box::new(0..points.len() as PointOffsetType),
                     &Default::default(),
                 )
@@ -667,7 +632,7 @@ mod tests {
 
         let scorer = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
@@ -715,14 +680,13 @@ mod tests {
             vec![1.0, 0.0, 0.0, 0.0],
         ];
         let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(points.len())));
-        let storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
+        let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
-        let mut borrowed_storage = storage.borrow_mut();
 
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
-            let storage2 = open_simple_dense_vector_storage(
+            let mut storage2 = open_simple_dense_vector_storage(
                 db,
                 DB_VECTOR_CF,
                 4,
@@ -731,16 +695,15 @@ mod tests {
             )
             .unwrap();
             {
-                let mut borrowed_storage2 = storage2.borrow_mut();
                 for (i, vec) in points.iter().enumerate() {
-                    borrowed_storage2
+                    storage2
                         .insert_vector(i as PointOffsetType, vec.as_slice().into())
                         .unwrap();
                 }
             }
-            borrowed_storage
+            storage
                 .update_from(
-                    &storage2.borrow(),
+                    &storage2,
                     &mut Box::new(0..points.len() as PointOffsetType),
                     &Default::default(),
                 )
@@ -756,7 +719,7 @@ mod tests {
 
         let stopped = Arc::new(AtomicBool::new(false));
         let quantized_vectors =
-            QuantizedVectors::create(&borrowed_storage, &config, dir.path(), 1, &stopped).unwrap();
+            QuantizedVectors::create(&storage, &config, dir.path(), 1, &stopped).unwrap();
 
         let query: QueryVector = [0.5, 0.5, 0.5, 0.5].into();
 
@@ -764,13 +727,13 @@ mod tests {
             .raw_scorer(
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
-                borrowed_storage.deleted_vector_bitslice(),
+                storage.deleted_vector_bitslice(),
                 &stopped,
             )
             .unwrap();
         let scorer_orig = new_raw_scorer(
             query.clone(),
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
@@ -783,25 +746,25 @@ mod tests {
             let orig = scorer_orig.score_internal(0, i);
             assert!((orig - quant).abs() < 0.15);
         }
-        let files = borrowed_storage.files();
+        let files = storage.files();
         let quantization_files = quantized_vectors.files();
 
         // test save-load
-        let quantized_vectors = QuantizedVectors::load(&borrowed_storage, dir.path()).unwrap();
-        assert_eq!(files, borrowed_storage.files());
+        let quantized_vectors = QuantizedVectors::load(&storage, dir.path()).unwrap();
+        assert_eq!(files, storage.files());
         assert_eq!(quantization_files, quantized_vectors.files());
 
         let scorer_quant = quantized_vectors
             .raw_scorer(
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
-                borrowed_storage.deleted_vector_bitslice(),
+                storage.deleted_vector_bitslice(),
                 &stopped,
             )
             .unwrap();
         let scorer_orig = new_raw_scorer(
             query,
-            &borrowed_storage,
+            &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();

commit d448d28c6d23ace94556bdaa9a237ba24bd2eeee
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jun 6 18:07:06 2024 +0200

    Add get optional vector for all storages (#4368)
    
    * Add get optional vector for dense simple storage
    
    * more bound checks
    
    * remove storage get_opt blanket implementation
    
    * remove duplication
    
    * remove duplication
    
    * Update lib/segment/src/vector_storage/multi_dense/simple_multi_dense_vector_storage.rs
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 0c18517c6..e17fd46a9 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -157,9 +157,15 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
     }
 
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
-        CowVector::from(T::slice_to_float_cow(
-            self.mmap_store.as_ref().unwrap().get_vector(key).into(),
-        ))
+        self.get_vector_opt(key).expect("vector not found")
+    }
+
+    fn get_vector_opt(&self, key: PointOffsetType) -> Option<CowVector> {
+        self.mmap_store
+            .as_ref()
+            .unwrap()
+            .get_vector_opt(key)
+            .map(|vector| T::slice_to_float_cow(vector.into()).into())
     }
 
     fn insert_vector(&mut self, _key: PointOffsetType, _vector: VectorRef) -> OperationResult<()> {

commit 54c0d94f5ab76ca80a69b7d60dfedf7d7e2b32c2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Jul 9 14:19:42 2024 +0200

    Derive/implement `fmt::Debug` for `Segment` (#4632)

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index e17fd46a9..fb2f9e96b 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -28,6 +28,7 @@ const DELETED_PATH: &str = "deleted.dat";
 /// but possible to mark some vectors as removed
 ///
 /// Mem-mapped storage can only be constructed from another storage
+#[derive(Debug)]
 pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {
     vectors_path: PathBuf,
     deleted_path: PathBuf,

commit 38522784b76c5e27dce2e71e8b22defcac68da75
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jul 18 11:43:56 2024 +0200

    Basic defragmentation (#4610)
    
    * sorting
    
    * migrate tests and move logic into SegmentBuilder
    
    * add test and improve implementation
    
    * improve code
    
    * review
    
    * code review improvements
    
    * add index building to test
    
    * Do not clone ranges
    
    * Resolve clippy warnings due to recent PR on dev
    
    * review suggestions
    
    * Defragmentation in api (#4684)
    
    * add tenant config to api
    
    * deduplicate used defragmentation keys
    
    * rename is_tenant to is_primary
    
    * use all values to defrag key
    
    * rename is_primary -> is_tenant
    
    * update schema
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index fb2f9e96b..24a984bdc 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -173,10 +173,9 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         panic!("Can't directly update vector in mmap storage")
     }
 
-    fn update_from(
+    fn update_from<'a>(
         &mut self,
-        other: &VectorStorageEnum,
-        other_ids: &mut impl Iterator<Item = PointOffsetType>,
+        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         let dim = self.vector_dim();
@@ -192,16 +191,15 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         // Extend vectors file, write other vectors into it
         let mut vectors_file = open_append(&self.vectors_path)?;
         let mut deleted_ids = vec![];
-        for id in other_ids {
+        for (id, other_vector, other_deleted) in other_ids {
             check_process_stopped(stopped)?;
-            let other_vector = other.get_vector(id);
             let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
             let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());
             vectors_file.write_all(raw_bites)?;
             end_index += 1;
 
             // Remember deleted IDs so we can propagate deletions later
-            if other.is_deleted_vector(id) {
+            if other_deleted {
                 deleted_ids.push((start_index + id) as PointOffsetType);
             }
         }
@@ -333,9 +331,13 @@ mod tests {
                     .insert_vector(2, points[2].as_slice().into())
                     .unwrap();
             }
-            storage
-                .update_from(&storage2, &mut Box::new(0..3), &Default::default())
-                .unwrap();
+            let mut iter = (0..3).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         assert_eq!(storage.total_vector_count(), 3);
@@ -366,9 +368,13 @@ mod tests {
                     .insert_vector(4, points[4].as_slice().into())
                     .unwrap();
             }
-            storage
-                .update_from(&storage2, &mut Box::new(0..2), &Default::default())
-                .unwrap();
+            let mut iter = (0..2).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         assert_eq!(storage.total_vector_count(), 5);
@@ -429,13 +435,13 @@ mod tests {
                         .unwrap();
                 });
             }
-            storage
-                .update_from(
-                    &storage2,
-                    &mut Box::new(0..points.len() as u32),
-                    &Default::default(),
-                )
-                .unwrap();
+            let mut iter = (0..points.len()).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         assert_eq!(storage.total_vector_count(), 5);
@@ -551,13 +557,13 @@ mod tests {
                     }
                 });
             }
-            storage
-                .update_from(
-                    &storage2,
-                    &mut Box::new(0..points.len() as u32),
-                    &Default::default(),
-                )
-                .unwrap();
+            let mut iter = (0..points.len()).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         assert_eq!(
@@ -624,13 +630,13 @@ mod tests {
                         .unwrap();
                 }
             }
-            storage
-                .update_from(
-                    &storage2,
-                    &mut Box::new(0..points.len() as PointOffsetType),
-                    &Default::default(),
-                )
-                .unwrap();
+            let mut iter = (0..points.len()).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         let vector = vec![-1.0, -1.0, -1.0, -1.0];
@@ -708,13 +714,13 @@ mod tests {
                         .unwrap();
                 }
             }
-            storage
-                .update_from(
-                    &storage2,
-                    &mut Box::new(0..points.len() as PointOffsetType),
-                    &Default::default(),
-                )
-                .unwrap();
+            let mut iter = (0..points.len()).map(|i| {
+                let i = i as PointOffsetType;
+                let vector = storage2.get_vector(i);
+                let deleted = storage2.is_deleted_vector(i);
+                (i, vector, deleted)
+            });
+            storage.update_from(&mut iter, &Default::default()).unwrap();
         }
 
         let config: QuantizationConfig = ScalarQuantizationConfig {

commit 3be87b11ebd82b8ad65918babf54ebc3f253a13d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 14 11:04:56 2024 +0200

    Mmap subcrate refactoring (#4886)
    
    * make mmap_type independent from segment structures
    
    * make bitvec and thiserror workspace dependencies
    
    * move mmap_type into common/memory subcrate
    
    * fmt

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 24a984bdc..63aeacf60 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -9,7 +9,7 @@ use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 use memory::mmap_ops;
 
-use crate::common::operation_error::{check_process_stopped, OperationResult};
+use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::Flusher;
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
@@ -229,7 +229,10 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
 
     fn flusher(&self) -> Flusher {
         match &self.mmap_store {
-            Some(mmap_store) => mmap_store.flusher(),
+            Some(mmap_store) => {
+                let mmap_flusher = mmap_store.flusher();
+                Box::new(move || mmap_flusher().map_err(OperationError::from))
+            }
             None => Box::new(|| Ok(())),
         }
     }

commit 6e48f588a1de3090b2959e1589fc08984634ebe6
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Aug 26 20:02:08 2024 +0200

    Fix point deletions on mmap segment optimization (#4952)
    
    * Don't use ID but current point offset when optimizing dense mmap storage
    
    This change now matches the implementation in all other storage types.
    
    * Remove now obsolete point offsets in update_from point iterator
    
    * Fix test

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 63aeacf60..ed35d8287 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -175,7 +175,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (PointOffsetType, CowVector<'a>, bool)>,
+        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         let dim = self.vector_dim();
@@ -191,7 +191,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         // Extend vectors file, write other vectors into it
         let mut vectors_file = open_append(&self.vectors_path)?;
         let mut deleted_ids = vec![];
-        for (id, other_vector, other_deleted) in other_ids {
+        for (offset, (other_vector, other_deleted)) in other_ids.enumerate() {
             check_process_stopped(stopped)?;
             let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
             let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());
@@ -200,7 +200,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
 
             // Remember deleted IDs so we can propagate deletions later
             if other_deleted {
-                deleted_ids.push((start_index + id) as PointOffsetType);
+                deleted_ids.push(start_index as PointOffsetType + offset as PointOffsetType);
             }
         }
         vectors_file.flush()?;
@@ -338,7 +338,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }
@@ -375,7 +375,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }
@@ -442,7 +442,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }
@@ -564,7 +564,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }
@@ -637,7 +637,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }
@@ -721,7 +721,7 @@ mod tests {
                 let i = i as PointOffsetType;
                 let vector = storage2.get_vector(i);
                 let deleted = storage2.is_deleted_vector(i);
-                (i, vector, deleted)
+                (vector, deleted)
             });
             storage.update_from(&mut iter, &Default::default()).unwrap();
         }

commit cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Oct 25 09:52:18 2024 +0200

    Hw counter utilization checks (#5288)
    
    * Enforce usage of hardware counter values
    
    * improve comments
    
    * log a warning in release mode
    
    * some minor improvements
    
    * avoid cloning for hardware counter
    
    * fmt
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index ed35d8287..0cabea61d 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -400,6 +400,7 @@ mod tests {
 
         let res = raw_scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2);
 
+        raw_scorer.take_hardware_counter().discard_results();
         assert_eq!(res.len(), 2);
         assert_ne!(res[0].idx, 2);
     }
@@ -466,17 +467,20 @@ mod tests {
 
         let vector = vec![0.0, 1.0, 1.1, 1.0];
         let query = vector.as_slice().into();
-        let closest = new_raw_scorer(
+        let scorer = new_raw_scorer(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
-        .unwrap()
-        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        .unwrap();
+
+        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
         assert_eq!(closest[2].idx, 4);
+        scorer.take_hardware_counter().discard_results();
+        drop(scorer);
 
         // Delete 1, redelete 2
         storage.delete_vector(1 as PointOffsetType).unwrap();
@@ -490,16 +494,18 @@ mod tests {
         let vector = vec![1.0, 0.0, 0.0, 0.0];
         let query = vector.as_slice().into();
 
-        let closest = new_raw_scorer(
+        let scorer = new_raw_scorer(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
-        .unwrap()
-        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        .unwrap();
+        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
         assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");
         assert_eq!(closest[0].idx, 4);
         assert_eq!(closest[1].idx, 0);
+        scorer.take_hardware_counter().discard_results();
+        drop(scorer);
 
         // Delete all
         storage.delete_vector(0 as PointOffsetType).unwrap();
@@ -512,13 +518,14 @@ mod tests {
 
         let vector = vec![1.0, 0.0, 0.0, 0.0];
         let query = vector.as_slice().into();
-        let closest = new_raw_scorer(
+        let scorer = new_raw_scorer(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
-        .unwrap()
-        .peek_top_all(5);
+        .unwrap();
+        let closest = scorer.peek_top_all(5);
+        scorer.take_hardware_counter().discard_results();
         assert!(closest.is_empty(), "must have no results, all deleted");
     }
 
@@ -577,13 +584,18 @@ mod tests {
 
         let vector = vec![0.0, 1.0, 1.1, 1.0];
         let query = vector.as_slice().into();
-        let closest = new_raw_scorer(
+        let scorer = new_raw_scorer(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
-        .unwrap()
-        .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        .unwrap();
+        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+
+        scorer.take_hardware_counter().discard_results();
+
+        drop(scorer);
+
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
@@ -657,6 +669,8 @@ mod tests {
         let res_count = scorer.score_points(&query_points, &mut res);
         res.resize(res_count, ScoredPointOffset { idx: 0, score: 0. });
 
+        scorer.take_hardware_counter().discard_results();
+
         assert_eq!(res.len(), 3);
         assert_eq!(res[0].idx, 0);
         assert_eq!(res[1].idx, 2);
@@ -747,12 +761,14 @@ mod tests {
                 &stopped,
             )
             .unwrap();
+
         let scorer_orig = new_raw_scorer(
             query.clone(),
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
+
         for i in 0..5 {
             let quant = scorer_quant.score_point(i);
             let orig = scorer_orig.score_point(i);
@@ -762,6 +778,10 @@ mod tests {
             let orig = scorer_orig.score_internal(0, i);
             assert!((orig - quant).abs() < 0.15);
         }
+
+        scorer_orig.take_hardware_counter().discard_results();
+        scorer_quant.take_hardware_counter().discard_results();
+
         let files = storage.files();
         let quantization_files = quantized_vectors.files();
 
@@ -794,5 +814,8 @@ mod tests {
             let orig = scorer_orig.score_internal(0, i);
             assert!((orig - quant).abs() < 0.15);
         }
+
+        scorer_orig.take_hardware_counter().discard_results();
+        scorer_quant.take_hardware_counter().discard_results();
     }
 }

commit 390d4c45035739bc78cdeb0fe6eccda4fec09946
Author: Kumar Shivendu <kshivendu1@gmail.com>
Date:   Fri Oct 25 15:09:31 2024 +0530

    Track vector storage usage in bytes for each of the segments (#5292)
    
    * Track disk usage for each of the vectors and segments
    
    * Dont extend vector_data field
    
    * Remove comment and improve var name
    
    * Introduce vectors_size_bytes and rename available_size_in_bytes
    
    * Introduce vectors_size_bytes and rename available_size_in_bytes
    
    * fix linter
    
    * Avoid converting to u64
    
    * calculate vectors_size_bytes for proxy segments
    
    * Fix OpenAPI spec
    
    * fix typo

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 0cabea61d..e383e954e 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -153,7 +153,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         self.mmap_store.as_ref().unwrap().num_vectors
     }
 
-    fn available_size_in_bytes(&self) -> usize {
+    fn size_in_bytes(&self) -> usize {
         self.available_vector_count() * self.vector_dim() * std::mem::size_of::<T>()
     }
 

commit 28a89060d1d2464bb33c49891fd2397cd77a1bf2
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Nov 13 16:52:14 2024 +0100

    use more stable computation of vectors_size_bytes + refactoring (#5437)
    
    * use more stable computation of vectors_size_bytes + refactoring
    
    * sync openapi

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index e383e954e..d6092aa25 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -153,7 +153,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         self.mmap_store.as_ref().unwrap().num_vectors
     }
 
-    fn size_in_bytes(&self) -> usize {
+    fn size_of_available_vectors_in_bytes(&self) -> usize {
         self.available_vector_count() * self.vector_dim() * std::mem::size_of::<T>()
     }
 

commit d15ef49719c6d3ef3bc66da73d510e386553596b
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 15 17:14:37 2024 +0100

    Optimize mmap sequential access for large scoring (#5440)
    
    * Optimize mmap sequential access for large scoring
    
    * use it
    
    * make windows happy
    
    * add missing CPU counters
    
    * Will not need
    
    * more unix build
    
    * add benchmark
    
    * fix and bench cmp
    
    * larger batch size
    
    * start appendable mmap implem
    
    * reenable debug for bench
    
    * remove old impl for comparison
    
    * impl for chunk mmap
    
    * fix windows
    
    * debug assert
    
    * errare human est
    
    * windows cfg
    
    * generalize peek_top_iter
    
    * remove blanket implementation to force explicit decision
    
    * less TODO
    
    * account for size of T
    
    * fmr
    
    * simplify chunk impl
    
    * relax constraint on contiguous ids
    
    * remove madvice WILLNEED and clean batching infra
    
    * some premature optimizations
    
    * extra sequential mmap for MMapVectorStorage
    
    * add read-only typed mmap
    
    * add read-only typed mmap
    
    * fix comments
    
    * implement batch reads for chuncked mmap
    
    * fix is_read_with_prefetch_efficient
    
    * cleanup
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index d6092aa25..a41a918cc 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -132,7 +132,16 @@ impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStora
     }
 
     fn get_dense(&self, key: PointOffsetType) -> &[T] {
-        self.mmap_store.as_ref().unwrap().get_vector(key)
+        self.mmap_store
+            .as_ref()
+            .unwrap()
+            .get_vector_opt(key)
+            .unwrap_or_else(|| panic!("vector not found: {key}"))
+    }
+
+    fn get_dense_batch<'a>(&'a self, keys: &[PointOffsetType], vectors: &mut [&'a [T]]) {
+        let mmap_store = self.mmap_store.as_ref().unwrap();
+        mmap_store.get_vectors(keys, vectors);
     }
 }
 

commit 4abd77158aa514efb6284b1668e8f02a7b9418f1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Dec 10 00:13:03 2024 +0100

    use fsync instead of flush (#5629)

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index a41a918cc..b66046737 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -212,7 +212,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
                 deleted_ids.push(start_index as PointOffsetType + offset as PointOffsetType);
             }
         }
-        vectors_file.flush()?;
+        vectors_file.sync_all()?;
         drop(vectors_file);
 
         // Load store with updated files

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index b66046737..8457797cb 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -283,6 +283,7 @@ mod tests {
     use std::sync::Arc;
 
     use atomic_refcell::AtomicRefCell;
+    use common::counter::hardware_counter::HardwareCounterCell;
     use common::types::ScoredPointOffset;
     use memory::mmap_ops::transmute_to_u8_slice;
     use tempfile::Builder;
@@ -294,7 +295,7 @@ mod tests {
     use crate::id_tracker::id_tracker_base::IdTracker;
     use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
     use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-    use crate::vector_storage::new_raw_scorer;
+    use crate::vector_storage::new_raw_scorer_for_test;
     use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
 
     #[test]
@@ -395,7 +396,7 @@ mod tests {
 
         assert_eq!(stored_ids, [0, 1, 3, 4]);
 
-        let raw_scorer = new_raw_scorer(
+        let raw_scorer = new_raw_scorer_for_test(
             points[2].as_slice().into(),
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -409,7 +410,6 @@ mod tests {
 
         let res = raw_scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2);
 
-        raw_scorer.take_hardware_counter().discard_results();
         assert_eq!(res.len(), 2);
         assert_ne!(res[0].idx, 2);
     }
@@ -476,7 +476,7 @@ mod tests {
 
         let vector = vec![0.0, 1.0, 1.1, 1.0];
         let query = vector.as_slice().into();
-        let scorer = new_raw_scorer(
+        let scorer = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -488,7 +488,6 @@ mod tests {
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
         assert_eq!(closest[2].idx, 4);
-        scorer.take_hardware_counter().discard_results();
         drop(scorer);
 
         // Delete 1, redelete 2
@@ -503,7 +502,7 @@ mod tests {
         let vector = vec![1.0, 0.0, 0.0, 0.0];
         let query = vector.as_slice().into();
 
-        let scorer = new_raw_scorer(
+        let scorer = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -513,7 +512,6 @@ mod tests {
         assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");
         assert_eq!(closest[0].idx, 4);
         assert_eq!(closest[1].idx, 0);
-        scorer.take_hardware_counter().discard_results();
         drop(scorer);
 
         // Delete all
@@ -527,14 +525,13 @@ mod tests {
 
         let vector = vec![1.0, 0.0, 0.0, 0.0];
         let query = vector.as_slice().into();
-        let scorer = new_raw_scorer(
+        let scorer = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
         let closest = scorer.peek_top_all(5);
-        scorer.take_hardware_counter().discard_results();
         assert!(closest.is_empty(), "must have no results, all deleted");
     }
 
@@ -593,7 +590,7 @@ mod tests {
 
         let vector = vec![0.0, 1.0, 1.1, 1.0];
         let query = vector.as_slice().into();
-        let scorer = new_raw_scorer(
+        let scorer = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -601,8 +598,6 @@ mod tests {
         .unwrap();
         let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
 
-        scorer.take_hardware_counter().discard_results();
-
         drop(scorer);
 
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
@@ -667,7 +662,7 @@ mod tests {
         let query = vector.as_slice().into();
         let query_points: Vec<PointOffsetType> = vec![0, 2, 4];
 
-        let scorer = new_raw_scorer(
+        let scorer = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -678,8 +673,6 @@ mod tests {
         let res_count = scorer.score_points(&query_points, &mut res);
         res.resize(res_count, ScoredPointOffset { idx: 0, score: 0. });
 
-        scorer.take_hardware_counter().discard_results();
-
         assert_eq!(res.len(), 3);
         assert_eq!(res[0].idx, 0);
         assert_eq!(res[1].idx, 2);
@@ -757,6 +750,7 @@ mod tests {
         .into();
 
         let stopped = Arc::new(AtomicBool::new(false));
+        let hardware_counter = HardwareCounterCell::new();
         let quantized_vectors =
             QuantizedVectors::create(&storage, &config, dir.path(), 1, &stopped).unwrap();
 
@@ -768,10 +762,11 @@ mod tests {
                 borrowed_id_tracker.deleted_point_bitslice(),
                 storage.deleted_vector_bitslice(),
                 &stopped,
+                hardware_counter,
             )
             .unwrap();
 
-        let scorer_orig = new_raw_scorer(
+        let scorer_orig = new_raw_scorer_for_test(
             query.clone(),
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -788,9 +783,6 @@ mod tests {
             assert!((orig - quant).abs() < 0.15);
         }
 
-        scorer_orig.take_hardware_counter().discard_results();
-        scorer_quant.take_hardware_counter().discard_results();
-
         let files = storage.files();
         let quantization_files = quantized_vectors.files();
 
@@ -798,16 +790,17 @@ mod tests {
         let quantized_vectors = QuantizedVectors::load(&storage, dir.path()).unwrap();
         assert_eq!(files, storage.files());
         assert_eq!(quantization_files, quantized_vectors.files());
-
+        let hardware_counter = HardwareCounterCell::new();
         let scorer_quant = quantized_vectors
             .raw_scorer(
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
                 storage.deleted_vector_bitslice(),
                 &stopped,
+                hardware_counter,
             )
             .unwrap();
-        let scorer_orig = new_raw_scorer(
+        let scorer_orig = new_raw_scorer_for_test(
             query,
             &storage,
             borrowed_id_tracker.deleted_point_bitslice(),
@@ -823,8 +816,5 @@ mod tests {
             let orig = scorer_orig.score_internal(0, i);
             assert!((orig - quant).abs() < 0.15);
         }
-
-        scorer_orig.take_hardware_counter().discard_results();
-        scorer_quant.take_hardware_counter().discard_results();
     }
 }

commit 3725c7c72366eaa2873edd8201fc7b60f05979a1
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Dec 18 13:04:07 2024 -0300

    Prefer vector index for `size_of_available_vectors_in_bytes` (#5587)
    
    * get total sparse size from inverted index
    
    * populate on load if not present
    
    * use debug assertion
    
    * correct size calculation
    
    * r u happy clippy
    
    * fix total sparse size in immutable ram
    
    * don't use options. move size_of_available_vectors to other traits
    
    * adjust test
    
    * fix rebase

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 8457797cb..3a1c7cbb4 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -162,10 +162,6 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         self.mmap_store.as_ref().unwrap().num_vectors
     }
 
-    fn size_of_available_vectors_in_bytes(&self) -> usize {
-        self.available_vector_count() * self.vector_dim() * std::mem::size_of::<T>()
-    }
-
     fn get_vector(&self, key: PointOffsetType) -> CowVector {
         self.get_vector_opt(key).expect("vector not found")
     }

commit 7cb7b18a06c03864f231853c402a2e3e91d0149f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 21 11:57:37 2025 -0300

    Remove setting OpenOptions flags to false (#5840)

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 3a1c7cbb4..69e3934a8 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -265,12 +265,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
 
 /// Open a file shortly for appending
 fn open_append<P: AsRef<Path>>(path: P) -> io::Result<File> {
-    OpenOptions::new()
-        .read(false)
-        .write(false)
-        .append(true)
-        .create(false)
-        .open(path)
+    OpenOptions::new().append(true).open(path)
 }
 
 #[cfg(test)]

commit b4328bb7c5c5052ce68d31bb7c00055a3b33c5d6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Feb 3 19:25:22 2025 -0300

    [mmap sparse vector storage] return cancelled error if stopped (#5938)
    
    * return cancelled error if stopped
    
    * add doc comment and renames

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 69e3934a8..5fe998595 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -180,7 +180,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
 
     fn update_from<'a>(
         &mut self,
-        other_ids: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
+        other_vectors: &'a mut impl Iterator<Item = (CowVector<'a>, bool)>,
         stopped: &AtomicBool,
     ) -> OperationResult<Range<PointOffsetType>> {
         let dim = self.vector_dim();
@@ -196,7 +196,7 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
         // Extend vectors file, write other vectors into it
         let mut vectors_file = open_append(&self.vectors_path)?;
         let mut deleted_ids = vec![];
-        for (offset, (other_vector, other_deleted)) in other_ids.enumerate() {
+        for (offset, (other_vector, other_deleted)) in other_vectors.enumerate() {
             check_process_stopped(stopped)?;
             let vector = T::slice_from_float_cow(Cow::try_from(other_vector)?);
             let raw_bites = mmap_ops::transmute_to_u8_slice(vector.as_ref());

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 5fe998595..9a1b700c2 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -1,5 +1,5 @@
 use std::borrow::Cow;
-use std::fs::{create_dir_all, File, OpenOptions};
+use std::fs::{File, OpenOptions, create_dir_all};
 use std::io::{self, Write};
 use std::ops::Range;
 use std::path::{Path, PathBuf};
@@ -9,8 +9,8 @@ use bitvec::prelude::BitSlice;
 use common::types::PointOffsetType;
 use memory::mmap_ops;
 
-use crate::common::operation_error::{check_process_stopped, OperationError, OperationResult};
 use crate::common::Flusher;
+use crate::common::operation_error::{OperationError, OperationResult, check_process_stopped};
 use crate::data_types::named_vectors::CowVector;
 use crate::data_types::primitive::PrimitiveVectorElement;
 use crate::data_types::vectors::{VectorElementType, VectorRef};
@@ -280,7 +280,7 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
-    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
     use crate::data_types::vectors::{DenseVector, QueryVector};
     use crate::fixtures::payload_context_fixture::FixtureIdTracker;
     use crate::id_tracker::id_tracker_base::IdTracker;

commit a2d7947917ca8d58c85360d1f07a387289b67a1b
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 10 15:27:06 2025 +0100

    Measure io writes for vector upsertions (#5944)
    
    * Add counter to vector storage API
    
    * Measuring IO write for dense vectors
    
    * Tests, GPU and sparse
    
    * Measure multi vectors too
    
    * Fix comment

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 9a1b700c2..90318a71e 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -6,6 +6,7 @@ use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
 
 use bitvec::prelude::BitSlice;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use memory::mmap_ops;
 
@@ -174,7 +175,12 @@ impl<T: PrimitiveVectorElement> VectorStorage for MemmapDenseVectorStorage<T> {
             .map(|vector| T::slice_to_float_cow(vector.into()).into())
     }
 
-    fn insert_vector(&mut self, _key: PointOffsetType, _vector: VectorRef) -> OperationResult<()> {
+    fn insert_vector(
+        &mut self,
+        _key: PointOffsetType,
+        _vector: VectorRef,
+        _hw_counter: &HardwareCounterCell,
+    ) -> OperationResult<()> {
         panic!("Can't directly update vector in mmap storage")
     }
 
@@ -313,6 +319,8 @@ mod tests {
                 .expect("storage is missing required file");
         }
 
+        let hw_counter = HardwareCounterCell::new();
+
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
@@ -326,13 +334,13 @@ mod tests {
             .unwrap();
             {
                 storage2
-                    .insert_vector(0, points[0].as_slice().into())
+                    .insert_vector(0, points[0].as_slice().into(), &hw_counter)
                     .unwrap();
                 storage2
-                    .insert_vector(1, points[1].as_slice().into())
+                    .insert_vector(1, points[1].as_slice().into(), &hw_counter)
                     .unwrap();
                 storage2
-                    .insert_vector(2, points[2].as_slice().into())
+                    .insert_vector(2, points[2].as_slice().into(), &hw_counter)
                     .unwrap();
             }
             let mut iter = (0..3).map(|i| {
@@ -366,10 +374,10 @@ mod tests {
             .unwrap();
             {
                 storage2
-                    .insert_vector(3, points[3].as_slice().into())
+                    .insert_vector(3, points[3].as_slice().into(), &hw_counter)
                     .unwrap();
                 storage2
-                    .insert_vector(4, points[4].as_slice().into())
+                    .insert_vector(4, points[4].as_slice().into(), &hw_counter)
                     .unwrap();
             }
             let mut iter = (0..2).map(|i| {
@@ -421,6 +429,8 @@ mod tests {
         let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
 
+        let hw_counter = HardwareCounterCell::new();
+
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
@@ -435,7 +445,7 @@ mod tests {
             {
                 points.iter().enumerate().for_each(|(i, vec)| {
                     storage2
-                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)
                         .unwrap();
                 });
             }
@@ -543,6 +553,8 @@ mod tests {
         let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
 
+        let hw_counter = HardwareCounterCell::new();
+
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
@@ -557,7 +569,7 @@ mod tests {
             {
                 points.iter().enumerate().for_each(|(i, vec)| {
                     storage2
-                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)
                         .unwrap();
                     if delete_mask[i] {
                         storage2.delete_vector(i as PointOffsetType).unwrap();
@@ -622,6 +634,8 @@ mod tests {
         let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
 
+        let hw_counter = HardwareCounterCell::new();
+
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
@@ -636,7 +650,7 @@ mod tests {
             {
                 for (i, vec) in points.iter().enumerate() {
                     storage2
-                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)
                         .unwrap();
                 }
             }
@@ -706,6 +720,8 @@ mod tests {
         let mut storage = open_memmap_vector_storage(dir.path(), 4, Distance::Dot).unwrap();
         let borrowed_id_tracker = id_tracker.borrow_mut();
 
+        let hw_counter = HardwareCounterCell::new();
+
         {
             let dir2 = Builder::new().prefix("db_dir").tempdir().unwrap();
             let db = open_db(dir2.path(), &[DB_VECTOR_CF]).unwrap();
@@ -720,7 +736,7 @@ mod tests {
             {
                 for (i, vec) in points.iter().enumerate() {
                     storage2
-                        .insert_vector(i as PointOffsetType, vec.as_slice().into())
+                        .insert_vector(i as PointOffsetType, vec.as_slice().into(), &hw_counter)
                         .unwrap();
                 }
             }

commit ee7b7644290dff12e3dca616a105e6100588e802
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Apr 3 09:44:57 2025 +0000

    Use MaybeUninit in vector storages and query scorers (#6303)

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 90318a71e..9475bfc87 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -1,6 +1,7 @@
 use std::borrow::Cow;
 use std::fs::{File, OpenOptions, create_dir_all};
 use std::io::{self, Write};
+use std::mem::MaybeUninit;
 use std::ops::Range;
 use std::path::{Path, PathBuf};
 use std::sync::atomic::AtomicBool;
@@ -140,9 +141,13 @@ impl<T: PrimitiveVectorElement> DenseVectorStorage<T> for MemmapDenseVectorStora
             .unwrap_or_else(|| panic!("vector not found: {key}"))
     }
 
-    fn get_dense_batch<'a>(&'a self, keys: &[PointOffsetType], vectors: &mut [&'a [T]]) {
+    fn get_dense_batch<'a>(
+        &'a self,
+        keys: &[PointOffsetType],
+        vectors: &'a mut [MaybeUninit<&'a [T]>],
+    ) -> &'a [&'a [T]] {
         let mmap_store = self.mmap_store.as_ref().unwrap();
-        mmap_store.get_vectors(keys, vectors);
+        mmap_store.get_vectors(keys, vectors)
     }
 }
 

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 9475bfc87..88a537d9d 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -9,6 +9,7 @@ use std::sync::atomic::AtomicBool;
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
+use memory::madvise::clear_disk_cache;
 use memory::mmap_ops;
 
 use crate::common::Flusher;
@@ -38,6 +39,24 @@ pub struct MemmapDenseVectorStorage<T: PrimitiveVectorElement> {
     distance: Distance,
 }
 
+impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
+    /// Populate all pages in the mmap.
+    /// Block until all pages are populated.
+    pub fn populate(&self) -> OperationResult<()> {
+        if let Some(mmap_store) = &self.mmap_store {
+            mmap_store.populate()?;
+        }
+        Ok(())
+    }
+
+    /// Drop disk cache.
+    pub fn clear_cache(&self) -> OperationResult<()> {
+        clear_disk_cache(&self.vectors_path)?;
+        clear_disk_cache(&self.deleted_path)?;
+        Ok(())
+    }
+}
+
 pub fn open_memmap_vector_storage(
     path: &Path,
     dim: usize,
@@ -108,14 +127,6 @@ fn open_memmap_vector_storage_with_async_io_impl<T: PrimitiveVectorElement>(
 }
 
 impl<T: PrimitiveVectorElement> MemmapDenseVectorStorage<T> {
-    pub fn prefault_mmap_pages(&self) -> Option<mmap_ops::PrefaultMmapPages> {
-        Some(
-            self.mmap_store
-                .as_ref()?
-                .prefault_mmap_pages(&self.vectors_path),
-        )
-    }
-
     pub fn get_mmap_vectors(&self) -> &MmapDenseVectors<T> {
         self.mmap_store.as_ref().unwrap()
     }

commit 3d988e66c49c5edf7d3daceea801f30b01303afe
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 08:54:42 2025 +0000

    Remove is_stopped from RawScorer  (#6305)
    
    * Introduce CancelledError
    
    * Remove is_stopped from RawScorer

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 88a537d9d..871d78c26 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -308,8 +308,8 @@ mod tests {
     use crate::id_tracker::id_tracker_base::IdTracker;
     use crate::types::{PointIdType, QuantizationConfig, ScalarQuantizationConfig};
     use crate::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-    use crate::vector_storage::new_raw_scorer_for_test;
     use crate::vector_storage::quantized::quantized_vectors::QuantizedVectors;
+    use crate::vector_storage::{DEFAULT_STOPPED, new_raw_scorer_for_test};
 
     #[test]
     fn test_basic_persistence() {
@@ -417,13 +417,15 @@ mod tests {
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-        let res = raw_scorer.peek_top_all(2);
+        let res = raw_scorer.peek_top_all(2, &DEFAULT_STOPPED).unwrap();
 
         assert_eq!(res.len(), 2);
 
         assert_ne!(res[0].idx, 2);
 
-        let res = raw_scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2);
+        let res = raw_scorer
+            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 2, &DEFAULT_STOPPED)
+            .unwrap();
 
         assert_eq!(res.len(), 2);
         assert_ne!(res[0].idx, 2);
@@ -500,7 +502,9 @@ mod tests {
         )
         .unwrap();
 
-        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        let closest = scorer
+            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
+            .unwrap();
         assert_eq!(closest.len(), 3, "must have 3 vectors, 2 are deleted");
         assert_eq!(closest[0].idx, 0);
         assert_eq!(closest[1].idx, 1);
@@ -525,7 +529,9 @@ mod tests {
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        let closest = scorer
+            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
+            .unwrap();
         assert_eq!(closest.len(), 2, "must have 2 vectors, 3 are deleted");
         assert_eq!(closest[0].idx, 4);
         assert_eq!(closest[1].idx, 0);
@@ -548,7 +554,7 @@ mod tests {
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-        let closest = scorer.peek_top_all(5);
+        let closest = scorer.peek_top_all(5, &DEFAULT_STOPPED).unwrap();
         assert!(closest.is_empty(), "must have no results, all deleted");
     }
 
@@ -615,7 +621,9 @@ mod tests {
             borrowed_id_tracker.deleted_point_bitslice(),
         )
         .unwrap();
-        let closest = scorer.peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5);
+        let closest = scorer
+            .peek_top_iter(&mut [0, 1, 2, 3, 4].iter().cloned(), 5, &DEFAULT_STOPPED)
+            .unwrap();
 
         drop(scorer);
 
@@ -784,7 +792,6 @@ mod tests {
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
                 storage.deleted_vector_bitslice(),
-                &stopped,
                 hardware_counter,
             )
             .unwrap();
@@ -819,7 +826,6 @@ mod tests {
                 query.clone(),
                 borrowed_id_tracker.deleted_point_bitslice(),
                 storage.deleted_vector_bitslice(),
-                &stopped,
                 hardware_counter,
             )
             .unwrap();

commit 1f805b618ee62b3e8f934abee4e7c05a26174611
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Apr 17 08:57:47 2025 +0000

    Clear disk cache after read (#6396)
    
    * Move clear_disk_cache to memory::fadvise
    
    * Add memory::fadvise::OneshotFile
    
    * Use OneshotFile

diff --git a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
index 871d78c26..df4e9f7bc 100644
--- a/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
+++ b/lib/segment/src/vector_storage/dense/memmap_dense_vector_storage.rs
@@ -9,7 +9,7 @@ use std::sync::atomic::AtomicBool;
 use bitvec::prelude::BitSlice;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
-use memory::madvise::clear_disk_cache;
+use memory::fadvise::clear_disk_cache;
 use memory::mmap_ops;
 
 use crate::common::Flusher;

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    