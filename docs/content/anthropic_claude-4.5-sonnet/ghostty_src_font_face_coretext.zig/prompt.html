<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/font/face/coretext.zig - Sonnet 4.5</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/font/face/coretext.zig</h1>
        <h2>Model: Sonnet 4.5</h2>
        <p><a href="../../../cases/anthropic_claude-4.5-sonnet/ghostty_src_font_face_coretext.zig.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/face/coretext.zig

commit 71ec50993096eda18001f802e84a2c28ddfa044d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:19:21 2022 -0700

    Make font face a compile time interface, stub for coretext

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
new file mode 100644
index 00000000..7dad78b9
--- /dev/null
+++ b/src/font/face/coretext.zig
@@ -0,0 +1 @@
+// One day!

commit 90f3b9391caed29b0c36fbcab890dbd5d277d572
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:43:54 2022 -0700

    font: begin coretext Face

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7dad78b9..8bbcae35 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1 +1,47 @@
-// One day!
+const macos = @import("macos");
+const harfbuzz = @import("harfbuzz");
+const font = @import("../main.zig");
+
+pub const Face = struct {
+    /// Our font face
+    font: *macos.text.Font,
+
+    /// Harfbuzz font corresponding to this face.
+    hb_font: harfbuzz.Font,
+
+    /// Initialize a CoreText-based face from another initialized font face
+    /// but with a new size. This is often how CoreText fonts are initialized
+    /// because the font is loaded at a default size during discovery, and then
+    /// adjusted to the final size for final load.
+    pub fn initFontCopy(base: *macos.text.Font, size: font.face.DesiredSize) !Face {
+        // Create a copy
+        const ct_font = try base.copyWithAttributes(@intToFloat(f32, size.points), null);
+        errdefer ct_font.release();
+
+        const hb_font = try harfbuzz.coretext.createFont(ct_font);
+        errdefer hb_font.destroy();
+
+        return Face{
+            .font = ct_font,
+            .hb_font = hb_font,
+        };
+    }
+
+    pub fn deinit(self: *Face) void {
+        self.font.release();
+        self.hb_font.destroy();
+        self.* = undefined;
+    }
+};
+
+test {
+    const name = try macos.foundation.String.createWithBytes("Monaco", .utf8, false);
+    defer name.release();
+    const desc = try macos.text.FontDescriptor.createWithNameAndSize(name, 12);
+    defer desc.release();
+    const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
+    defer ct_font.release();
+
+    var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
+    defer face.deinit();
+}

commit 723db8be2f242f527a0d33891bbd21f8cbee239a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 09:55:22 2022 -0700

    font: coretext face presentation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 8bbcae35..3c73ce80 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1,3 +1,4 @@
+const std = @import("std");
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
@@ -9,6 +10,9 @@ pub const Face = struct {
     /// Harfbuzz font corresponding to this face.
     hb_font: harfbuzz.Font,
 
+    /// The presentation for this font.
+    presentation: font.Presentation,
+
     /// Initialize a CoreText-based face from another initialized font face
     /// but with a new size. This is often how CoreText fonts are initialized
     /// because the font is loaded at a default size during discovery, and then
@@ -21,9 +25,12 @@ pub const Face = struct {
         const hb_font = try harfbuzz.coretext.createFont(ct_font);
         errdefer hb_font.destroy();
 
+        const traits = ct_font.getSymbolicTraits();
+
         return Face{
             .font = ct_font,
             .hb_font = hb_font,
+            .presentation = if (traits.color_glyphs) .emoji else .text,
         };
     }
 
@@ -35,6 +42,8 @@ pub const Face = struct {
 };
 
 test {
+    const testing = std.testing;
+
     const name = try macos.foundation.String.createWithBytes("Monaco", .utf8, false);
     defer name.release();
     const desc = try macos.text.FontDescriptor.createWithNameAndSize(name, 12);
@@ -44,4 +53,22 @@ test {
 
     var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
     defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.text, face.presentation);
+}
+
+test "emoji" {
+    const testing = std.testing;
+
+    const name = try macos.foundation.String.createWithBytes("Apple Color Emoji", .utf8, false);
+    defer name.release();
+    const desc = try macos.text.FontDescriptor.createWithNameAndSize(name, 12);
+    defer desc.release();
+    const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
+    defer ct_font.release();
+
+    var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
+    defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.emoji, face.presentation);
 }

commit 0ff79a06237839350b2d6e86c8a939ce17fef7c6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 10:04:17 2022 -0700

    font: coretext glyphIndex

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 3c73ce80..04957069 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const assert = std.debug.assert;
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
@@ -39,6 +40,26 @@ pub const Face = struct {
         self.hb_font.destroy();
         self.* = undefined;
     }
+
+    /// Returns the glyph index for the given Unicode code point. If this
+    /// face doesn't support this glyph, null is returned.
+    pub fn glyphIndex(self: Face, cp: u32) ?u32 {
+        // Turn UTF-32 into UTF-16 for CT API
+        var unichars: [2]u16 = undefined;
+        const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
+        const len: usize = if (pair) 2 else 1;
+
+        // Get our glyphs
+        var glyphs = [2]macos.graphics.Glyph{ 0, 0 };
+        if (!self.font.getGlyphsForCharacters(unichars[0..len], glyphs[0..len]))
+            return null;
+
+        // We can have pairs due to chars like emoji but we expect all of them
+        // to decode down into exactly one glyph ID.
+        if (pair) assert(glyphs[1] == 0);
+
+        return @intCast(u32, glyphs[0]);
+    }
 };
 
 test {
@@ -55,6 +76,13 @@ test {
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
+
+    // Generate all visible ASCII
+    var i: u8 = 32;
+    while (i < 127) : (i += 1) {
+        try testing.expect(face.glyphIndex(i) != null);
+        //_ = try face.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+    }
 }
 
 test "emoji" {
@@ -70,5 +98,9 @@ test "emoji" {
     var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
     defer face.deinit();
 
+    // Presentation
     try testing.expectEqual(font.Presentation.emoji, face.presentation);
+
+    // Glyph index check
+    try testing.expect(face.glyphIndex('ðŸ¥¸') != null);
 }

commit 0e167ae24c5e1cfe3aa539fa3af99a84b81c2081
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 11:21:24 2022 -0700

    font: coretext initialize face from memory

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 04957069..584bff7a 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -14,6 +14,24 @@ pub const Face = struct {
     /// The presentation for this font.
     presentation: font.Presentation,
 
+    /// Initialize a CoreText-based font from a TTF/TTC in memory.
+    pub fn init(lib: font.Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
+        _ = lib;
+
+        const data = try macos.foundation.Data.createWithBytesNoCopy(source);
+        defer data.release();
+
+        const arr = macos.text.createFontDescriptorsFromData(data) orelse
+            return error.FontInitFailure;
+        defer arr.release();
+
+        const desc = arr.getValueAtIndex(macos.text.FontDescriptor, 0);
+        const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
+        defer ct_font.release();
+
+        return try initFontCopy(ct_font, size);
+    }
+
     /// Initialize a CoreText-based face from another initialized font face
     /// but with a new size. This is often how CoreText fonts are initialized
     /// because the font is loaded at a default size during discovery, and then
@@ -104,3 +122,23 @@ test "emoji" {
     // Glyph index check
     try testing.expect(face.glyphIndex('ðŸ¥¸') != null);
 }
+
+test "in-memory" {
+    const testing = std.testing;
+    const testFont = @import("../test.zig").fontRegular;
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.text, face.presentation);
+
+    // Generate all visible ASCII
+    var i: u8 = 32;
+    while (i < 127) : (i += 1) {
+        try testing.expect(face.glyphIndex(i) != null);
+        //_ = try face.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+    }
+}

commit 22f437aac638f9cadca6864e3bb2309eb2428598
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 11:49:23 2022 -0700

    font: coretext cell width calculation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 584bff7a..68fea272 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -14,6 +14,9 @@ pub const Face = struct {
     /// The presentation for this font.
     presentation: font.Presentation,
 
+    /// Metrics for this font face. These are useful for renderers.
+    metrics: font.face.Metrics,
+
     /// Initialize a CoreText-based font from a TTF/TTC in memory.
     pub fn init(lib: font.Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
         _ = lib;
@@ -50,6 +53,7 @@ pub const Face = struct {
             .font = ct_font,
             .hb_font = hb_font,
             .presentation = if (traits.color_glyphs) .emoji else .text,
+            .metrics = calcMetrics(ct_font),
         };
     }
 
@@ -78,6 +82,45 @@ pub const Face = struct {
 
         return @intCast(u32, glyphs[0]);
     }
+
+    fn calcMetrics(ct_font: *macos.text.Font) font.face.Metrics {
+        // Cell width is calculated by calculating the widest width of the
+        // visible ASCII characters. Usually 'M' is widest but we just take
+        // whatever is widest.
+        const cell_width: f32 = cell_width: {
+            // Build a comptime array of all the ASCII chars
+            const unichars = comptime unichars: {
+                const len = 127 - 32;
+                var result: [len]u16 = undefined;
+                var i: u16 = 32;
+                while (i < 127) : (i += 1) {
+                    result[i - 32] = i;
+                }
+
+                break :unichars result;
+            };
+
+            // Get our glyph IDs for the ASCII chars
+            var glyphs: [unichars.len]macos.graphics.Glyph = undefined;
+            _ = ct_font.getGlyphsForCharacters(&unichars, &glyphs);
+
+            // Get all our advances
+            var advances: [unichars.len]macos.graphics.Size = undefined;
+            _ = ct_font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
+
+            // Find the maximum advance
+            var max: f64 = 0;
+            var i: usize = 0;
+            while (i < advances.len) : (i += 1) {
+                max = @maximum(advances[i].width, max);
+            }
+
+            break :cell_width @floatCast(f32, max);
+        };
+
+        std.log.warn("width={}", .{cell_width});
+        return undefined;
+    }
 };
 
 test {

commit a97f997f9abfd8d7e2797825c91f063145fd5a8f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Oct 8 17:03:09 2022 -0700

    font: start working on core text cell height calcs

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 68fea272..85d2b6dd 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -118,7 +118,12 @@ pub const Face = struct {
             break :cell_width @floatCast(f32, max);
         };
 
-        std.log.warn("width={}", .{cell_width});
+        const cell_height: f32 = cell_height: {
+            const diff = ct_font.getAscent() + ct_font.getDescent() + ct_font.getLeading();
+            break :cell_height @floatCast(f32, diff);
+        };
+
+        std.log.warn("width={}, height={}", .{ cell_width, cell_height });
         return undefined;
     }
 };

commit 150b0a4d51f43373e6839e80812fae37c3932869
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 08:51:30 2022 -0700

    font: calculate cell height

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 85d2b6dd..7421c796 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -44,7 +44,7 @@ pub const Face = struct {
         const ct_font = try base.copyWithAttributes(@intToFloat(f32, size.points), null);
         errdefer ct_font.release();
 
-        const hb_font = try harfbuzz.coretext.createFont(ct_font);
+        var hb_font = try harfbuzz.coretext.createFont(ct_font);
         errdefer hb_font.destroy();
 
         const traits = ct_font.getSymbolicTraits();
@@ -53,7 +53,7 @@ pub const Face = struct {
             .font = ct_font,
             .hb_font = hb_font,
             .presentation = if (traits.color_glyphs) .emoji else .text,
-            .metrics = calcMetrics(ct_font),
+            .metrics = try calcMetrics(ct_font),
         };
     }
 
@@ -83,7 +83,7 @@ pub const Face = struct {
         return @intCast(u32, glyphs[0]);
     }
 
-    fn calcMetrics(ct_font: *macos.text.Font) font.face.Metrics {
+    fn calcMetrics(ct_font: *macos.text.Font) !font.face.Metrics {
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take
         // whatever is widest.
@@ -118,13 +118,63 @@ pub const Face = struct {
             break :cell_width @floatCast(f32, max);
         };
 
+        // Calculate the cell height by using CoreText's layout engine
+        // to tell us after laying out some text. This is inspired by Kitty's
+        // approach. Previously we were using descent/ascent math and it wasn't
+        // quite the same with CoreText and I never figured out why.
         const cell_height: f32 = cell_height: {
-            const diff = ct_font.getAscent() + ct_font.getDescent() + ct_font.getLeading();
-            break :cell_height @floatCast(f32, diff);
+            const unit = "AQWMH_gyl " ** 100;
+
+            // Setup our string we'll layout. We just stylize a string of
+            // ASCII characters to setup the letters.
+            const string = try macos.foundation.MutableAttributedString.create(unit.len);
+            defer string.release();
+            const rep = try macos.foundation.String.createWithBytes(unit, .utf8, false);
+            defer rep.release();
+            string.replaceString(macos.foundation.Range.init(0, 0), rep);
+            string.setAttribute(
+                macos.foundation.Range.init(0, unit.len),
+                macos.text.StringAttribute.font,
+                ct_font,
+            );
+
+            // Create our framesetter with our string. This is used to
+            // emit "frames" for the layout.
+            const fs = try macos.text.Framesetter.createWithAttributedString(
+                @ptrCast(*macos.foundation.AttributedString, string),
+            );
+            defer fs.release();
+
+            // Create a rectangle to fit all of this and create a frame of it.
+            const path = try macos.graphics.MutablePath.create();
+            path.addRect(null, macos.graphics.Rect.init(10, 10, 200, 200));
+            defer path.release();
+            const frame = try fs.createFrame(
+                macos.foundation.Range.init(0, 0),
+                @ptrCast(*macos.graphics.Path, path),
+                null,
+            );
+            defer frame.release();
+
+            // Get the two points where the lines start in order to determine
+            // the line height.
+            var points: [2]macos.graphics.Point = undefined;
+            frame.getLineOrigins(macos.foundation.Range.init(0, 1), points[0..]);
+            frame.getLineOrigins(macos.foundation.Range.init(1, 1), points[1..]);
+
+            break :cell_height @floatCast(f32, points[0].y - points[1].y);
         };
 
         std.log.warn("width={}, height={}", .{ cell_width, cell_height });
-        return undefined;
+        return font.face.Metrics{
+            .cell_width = cell_width,
+            .cell_height = cell_height,
+            .cell_baseline = 0,
+            .underline_position = 0,
+            .underline_thickness = 0,
+            .strikethrough_position = 0,
+            .strikethrough_thickness = 0,
+        };
     }
 };
 
@@ -176,10 +226,10 @@ test "in-memory" {
     const testFont = @import("../test.zig").fontRegular;
 
     var lib = try font.Library.init();
-    defer lib.deinit();
+    //defer lib.deinit();
 
     var face = try Face.init(lib, testFont, .{ .points = 12 });
-    defer face.deinit();
+    //defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
 

commit 1b7bc052d41793b196efce7e67d3830c3e5d7e95
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 10:57:19 2022 -0700

    font: coretext calculate cell metrics

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7421c796..083a3442 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -122,7 +122,10 @@ pub const Face = struct {
         // to tell us after laying out some text. This is inspired by Kitty's
         // approach. Previously we were using descent/ascent math and it wasn't
         // quite the same with CoreText and I never figured out why.
-        const cell_height: f32 = cell_height: {
+        const layout_metrics: struct {
+            height: f32,
+            ascent: f32,
+        } = metrics: {
             const unit = "AQWMH_gyl " ** 100;
 
             // Setup our string we'll layout. We just stylize a string of
@@ -156,24 +159,55 @@ pub const Face = struct {
             );
             defer frame.release();
 
-            // Get the two points where the lines start in order to determine
-            // the line height.
+            // Use our text layout from earlier to measure the difference
+            // between the lines.
             var points: [2]macos.graphics.Point = undefined;
             frame.getLineOrigins(macos.foundation.Range.init(0, 1), points[0..]);
             frame.getLineOrigins(macos.foundation.Range.init(1, 1), points[1..]);
 
-            break :cell_height @floatCast(f32, points[0].y - points[1].y);
+            const lines = frame.getLines();
+            const line = lines.getValueAtIndex(macos.text.Line, 0);
+
+            // NOTE(mitchellh): For some reason, CTLineGetBoundsWithOptions
+            // returns garbage and I can't figure out why... so we use the
+            // raw ascender.
+
+            var ascent: f64 = 0;
+            var descent: f64 = 0;
+            var leading: f64 = 0;
+            _ = line.getTypographicBounds(&ascent, &descent, &leading);
+            //std.log.warn("ascent={} descent={} leading={}", .{ ascent, descent, leading });
+
+            break :metrics .{
+                .height = @floatCast(f32, points[0].y - points[1].y),
+                .ascent = @floatCast(f32, ascent),
+            };
         };
 
-        std.log.warn("width={}, height={}", .{ cell_width, cell_height });
+        // All of these metrics are based on our layout above.
+        const cell_height = layout_metrics.height;
+        const cell_baseline = layout_metrics.ascent;
+        const underline_position = @ceil(layout_metrics.ascent -
+            @floatCast(f32, ct_font.getUnderlinePosition()));
+        const underline_thickness = @ceil(@floatCast(f32, ct_font.getUnderlineThickness()));
+        const strikethrough_position = cell_baseline * 0.6;
+        const strikethrough_thickness = underline_thickness;
+
+        // std.log.warn("width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
+        //     cell_width,
+        //     cell_height,
+        //     cell_baseline,
+        //     underline_position,
+        //     underline_thickness,
+        // });
         return font.face.Metrics{
             .cell_width = cell_width,
             .cell_height = cell_height,
-            .cell_baseline = 0,
-            .underline_position = 0,
-            .underline_thickness = 0,
-            .strikethrough_position = 0,
-            .strikethrough_thickness = 0,
+            .cell_baseline = cell_baseline,
+            .underline_position = underline_position,
+            .underline_thickness = underline_thickness,
+            .strikethrough_position = strikethrough_position,
+            .strikethrough_thickness = strikethrough_thickness,
         };
     }
 };
@@ -188,7 +222,7 @@ test {
     const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
     defer ct_font.release();
 
-    var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
+    var face = try Face.initFontCopy(ct_font, .{ .points = 12 });
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);

commit 97e989daa8351fcde927ffc66c35d9397003d5c9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 11:23:57 2022 -0700

    font: coretext initial render glyph

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 083a3442..97508006 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1,8 +1,10 @@
 const std = @import("std");
 const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
+const Atlas = @import("../../Atlas.zig");
 
 pub const Face = struct {
     /// Our font face
@@ -83,6 +85,78 @@ pub const Face = struct {
         return @intCast(u32, glyphs[0]);
     }
 
+    /// Render a glyph using the glyph index. The rendered glyph is stored in the
+    /// given texture atlas.
+    pub fn renderGlyph(self: Face, alloc: Allocator, atlas: *Atlas, glyph_index: u32) !font.Glyph {
+        var glyphs = [_]macos.graphics.Glyph{@intCast(macos.graphics.Glyph, glyph_index)};
+
+        // Get the bounding rect for this glyph to determine the width/height
+        // of the bitmap. We use the rounded up width/height of the bounding rect.
+        var bounding: [1]macos.graphics.Rect = undefined;
+        _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
+        const width = @floatToInt(u32, @ceil(bounding[0].size.width));
+        const height = @floatToInt(u32, @ceil(bounding[0].size.height));
+
+        // This bitmap is blank. I've seen it happen in a font, I don't know why.
+        // If it is empty, we just return a valid glyph struct that does nothing.
+        if (width == 0 or height == 0) return font.Glyph{
+            .width = 0,
+            .height = 0,
+            .offset_x = 0,
+            .offset_y = 0,
+            .atlas_x = 0,
+            .atlas_y = 0,
+            .advance_x = 0,
+        };
+
+        // Get the advance that we need for the glyph
+        var advances: [1]macos.graphics.Size = undefined;
+        _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
+
+        // Our buffer for rendering
+        // TODO(perf): cache this buffer
+        // TODO(mitchellh): color is going to require a depth here
+        var buf = try alloc.alloc(u8, width * height);
+        defer alloc.free(buf);
+
+        const space = try macos.graphics.ColorSpace.createDeviceGray();
+        defer space.release();
+
+        const ctx = try macos.graphics.BitmapContext.create(
+            buf,
+            width,
+            height,
+            8,
+            width,
+            space,
+        );
+        defer ctx.release();
+
+        ctx.setShouldAntialias(true);
+        ctx.setShouldSmoothFonts(false);
+        ctx.setGrayFillColor(1, 1);
+        ctx.setGrayStrokeColor(1, 1);
+        ctx.setTextDrawingMode(.fill_stroke);
+        ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
+        ctx.setTextPosition(0, self.metrics.cell_height - self.metrics.cell_baseline);
+
+        var pos = [_]macos.graphics.Point{.{ .x = 0, .y = 0 }};
+        self.font.drawGlyphs(&glyphs, &pos, ctx);
+
+        const region = try atlas.reserve(alloc, width, height);
+        atlas.set(region, buf);
+
+        return font.Glyph{
+            .width = width,
+            .height = height,
+            .offset_x = 0,
+            .offset_y = 0,
+            .atlas_x = region.x,
+            .atlas_y = region.y,
+            .advance_x = @floatCast(f32, advances[0].width),
+        };
+    }
+
     fn calcMetrics(ct_font: *macos.text.Font) !font.face.Metrics {
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take
@@ -214,6 +288,10 @@ pub const Face = struct {
 
 test {
     const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
 
     const name = try macos.foundation.String.createWithBytes("Monaco", .utf8, false);
     defer name.release();
@@ -231,7 +309,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        //_ = try face.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?);
     }
 }
 
@@ -257,13 +335,17 @@ test "emoji" {
 
 test "in-memory" {
     const testing = std.testing;
+    const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontRegular;
 
+    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
+
     var lib = try font.Library.init();
-    //defer lib.deinit();
+    defer lib.deinit();
 
     var face = try Face.init(lib, testFont, .{ .points = 12 });
-    //defer face.deinit();
+    defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
 
@@ -271,6 +353,6 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        //_ = try face.renderGlyph(alloc, &atlas, ft_font.glyphIndex(i).?);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?);
     }
 }

commit 276ae4f788e1cc49d8f78928c3a39fdda2e95756
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 11:45:02 2022 -0700

    font: fix some coretext rendering issues

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 97508006..f75a13d5 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -94,12 +94,13 @@ pub const Face = struct {
         // of the bitmap. We use the rounded up width/height of the bounding rect.
         var bounding: [1]macos.graphics.Rect = undefined;
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
-        const width = @floatToInt(u32, @ceil(bounding[0].size.width));
-        const height = @floatToInt(u32, @ceil(bounding[0].size.height));
+        const glyph_width = @floatToInt(u32, @ceil(bounding[0].size.width));
+        const width = @floatToInt(u32, self.metrics.cell_width);
+        const height = @floatToInt(u32, self.metrics.cell_height);
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        if (width == 0 or height == 0) return font.Glyph{
+        if (glyph_width == 0) return font.Glyph{
             .width = 0,
             .height = 0,
             .offset_x = 0,
@@ -138,7 +139,7 @@ pub const Face = struct {
         ctx.setGrayStrokeColor(1, 1);
         ctx.setTextDrawingMode(.fill_stroke);
         ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
-        ctx.setTextPosition(0, self.metrics.cell_height - self.metrics.cell_baseline);
+        ctx.setTextPosition(0, @intToFloat(f32, height) - self.metrics.cell_baseline);
 
         var pos = [_]macos.graphics.Point{.{ .x = 0, .y = 0 }};
         self.font.drawGlyphs(&glyphs, &pos, ctx);
@@ -150,7 +151,11 @@ pub const Face = struct {
             .width = width,
             .height = height,
             .offset_x = 0,
-            .offset_y = 0,
+
+            // Offset is full cell height because for CoreText we render
+            // an entire cell.
+            .offset_y = @floatToInt(i32, self.metrics.cell_height),
+
             .atlas_x = region.x,
             .atlas_y = region.y,
             .advance_x = @floatCast(f32, advances[0].width),

commit c75e54fca021a8af62aa27143ad5375efa30ba15
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 9 16:30:26 2022 -0700

    update to API

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index f75a13d5..756e3a54 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -95,6 +95,8 @@ pub const Face = struct {
         var bounding: [1]macos.graphics.Rect = undefined;
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
         const glyph_width = @floatToInt(u32, @ceil(bounding[0].size.width));
+        const glyph_height = @floatToInt(u32, @ceil(bounding[0].size.height));
+        _ = glyph_height;
         const width = @floatToInt(u32, self.metrics.cell_width);
         const height = @floatToInt(u32, self.metrics.cell_height);
 
@@ -110,6 +112,8 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
+        //std.log.warn("bound={}", .{bounding[0]});
+
         // Get the advance that we need for the glyph
         var advances: [1]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
@@ -130,10 +134,12 @@ pub const Face = struct {
             8,
             width,
             space,
+            @enumToInt(macos.graphics.BitmapInfo.alpha_mask) &
+                @enumToInt(macos.graphics.ImageAlphaInfo.none),
         );
         defer ctx.release();
 
-        ctx.setShouldAntialias(true);
+        ctx.setShouldAntialias(false);
         ctx.setShouldSmoothFonts(false);
         ctx.setGrayFillColor(1, 1);
         ctx.setGrayStrokeColor(1, 1);

commit 1e2377933759f6b15a80018760bfe45d67e93e40
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Oct 10 09:03:03 2022 -0700

    pkg/macos: more stuff

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 756e3a54..d3dd7b64 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -139,6 +139,7 @@ pub const Face = struct {
         );
         defer ctx.release();
 
+        ctx.setAllowsAntialiasing(false);
         ctx.setShouldAntialias(false);
         ctx.setShouldSmoothFonts(false);
         ctx.setGrayFillColor(1, 1);

commit 58c107dceb1596dc839067619c2e11aa2eb05a57
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Oct 17 19:04:39 2022 -0700

    freetype: resize glyphs that are too tall prior to storing in texture
    
    Most emoji fonts are massive glyphs (128x128, 256x256, etc.). This means
    the texture we need to store emoji is also massive. For a 128x128 emoji
    font (both Apple and Noto), we can only store 12 emoji before resizing
    prior to this commit.
    
    This commit now threads through a max height through to the font face
    and resizes the bitmap in memory before putting it in the atlas. This
    results in significant savings. The max height is the cell height. We
    allow the glyphs to be as wide as necessary due to double (and more)
    wide glyphs.
    
    For the unicode emoji test file, the atlas size before and after:
    
      Before: 262 MB
      After: 16 MB

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index d3dd7b64..5800789a 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -87,7 +87,15 @@ pub const Face = struct {
 
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
     /// given texture atlas.
-    pub fn renderGlyph(self: Face, alloc: Allocator, atlas: *Atlas, glyph_index: u32) !font.Glyph {
+    pub fn renderGlyph(
+        self: Face,
+        alloc: Allocator,
+        atlas: *Atlas,
+        glyph_index: u32,
+        max_height: ?u16,
+    ) !font.Glyph {
+        _ = max_height;
+
         var glyphs = [_]macos.graphics.Glyph{@intCast(macos.graphics.Glyph, glyph_index)};
 
         // Get the bounding rect for this glyph to determine the width/height
@@ -321,7 +329,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, null);
     }
 }
 
@@ -365,6 +373,6 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, null);
     }
 }

commit 4669032e56f4f44ecf6f9e49a50dbf575b2f7dc9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 18 12:52:37 2022 -0700

    face: coretext zero the bitmap before render

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 5800789a..86181f0d 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -107,6 +107,8 @@ pub const Face = struct {
         _ = glyph_height;
         const width = @floatToInt(u32, self.metrics.cell_width);
         const height = @floatToInt(u32, self.metrics.cell_height);
+        // const width = glyph_width;
+        // const height = glyph_height;
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
@@ -131,6 +133,7 @@ pub const Face = struct {
         // TODO(mitchellh): color is going to require a depth here
         var buf = try alloc.alloc(u8, width * height);
         defer alloc.free(buf);
+        std.mem.set(u8, buf, 0);
 
         const space = try macos.graphics.ColorSpace.createDeviceGray();
         defer space.release();
@@ -155,6 +158,7 @@ pub const Face = struct {
         ctx.setTextDrawingMode(.fill_stroke);
         ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
         ctx.setTextPosition(0, @intToFloat(f32, height) - self.metrics.cell_baseline);
+        //ctx.setTextPosition(0, 0);
 
         var pos = [_]macos.graphics.Point{.{ .x = 0, .y = 0 }};
         self.font.drawGlyphs(&glyphs, &pos, ctx);

commit 38e0c258d0954ed8ec2a82d9744666eea165a34e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 18 12:56:02 2022 -0700

    coretext: we do want to smooth and anti-alias glyphs

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 86181f0d..ebc005f5 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -150,9 +150,9 @@ pub const Face = struct {
         );
         defer ctx.release();
 
-        ctx.setAllowsAntialiasing(false);
-        ctx.setShouldAntialias(false);
-        ctx.setShouldSmoothFonts(false);
+        ctx.setAllowsAntialiasing(true);
+        ctx.setShouldAntialias(true);
+        ctx.setShouldSmoothFonts(true);
         ctx.setGrayFillColor(1, 1);
         ctx.setGrayStrokeColor(1, 1);
         ctx.setTextDrawingMode(.fill_stroke);

commit c00c8f52b5b7b8e59806d75b331d2055f58ca04a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 18 14:49:23 2022 -0700

    coretext: render glyph on its own bounding box, calculate bearings

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index ebc005f5..f5572097 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -104,11 +104,8 @@ pub const Face = struct {
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
         const glyph_width = @floatToInt(u32, @ceil(bounding[0].size.width));
         const glyph_height = @floatToInt(u32, @ceil(bounding[0].size.height));
-        _ = glyph_height;
-        const width = @floatToInt(u32, self.metrics.cell_width);
-        const height = @floatToInt(u32, self.metrics.cell_height);
-        // const width = glyph_width;
-        // const height = glyph_height;
+        const width = glyph_width;
+        const height = glyph_height;
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
@@ -122,8 +119,6 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
-        //std.log.warn("bound={}", .{bounding[0]});
-
         // Get the advance that we need for the glyph
         var advances: [1]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
@@ -157,24 +152,41 @@ pub const Face = struct {
         ctx.setGrayStrokeColor(1, 1);
         ctx.setTextDrawingMode(.fill_stroke);
         ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
-        ctx.setTextPosition(0, @intToFloat(f32, height) - self.metrics.cell_baseline);
-        //ctx.setTextPosition(0, 0);
-
-        var pos = [_]macos.graphics.Point{.{ .x = 0, .y = 0 }};
+        ctx.setTextPosition(0, 0);
+
+        // We want to render the glyphs at (0,0), but the glyphs themselves
+        // are offset by bearings, so we have to undo those bearings in order
+        // to get them to 0,0.
+        var pos = [_]macos.graphics.Point{.{
+            .x = -1 * bounding[0].origin.x,
+            .y = -1 * bounding[0].origin.y,
+        }};
         self.font.drawGlyphs(&glyphs, &pos, ctx);
 
         const region = try atlas.reserve(alloc, width, height);
         atlas.set(region, buf);
 
+        const offset_y = offset_y: {
+            // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
+            // We need to calculate our baseline from the bottom of a cell.
+            const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
+
+            // Next we offset our baseline by the bearing in the font. We
+            // ADD here because CoreText y is UP.
+            const baseline_with_offset = baseline_from_bottom + bounding[0].origin.y;
+
+            // Finally, since we're rendering at (0, 0), the glyph will render
+            // by default below the line. We have to add height (glyph height)
+            // so that we shift the glyph UP to be on the line, then we add our
+            // baseline offset to move the glyph further UP to match the baseline.
+            break :offset_y @intCast(i32, height) + @floatToInt(i32, @ceil(baseline_with_offset));
+        };
+
         return font.Glyph{
             .width = width,
             .height = height,
-            .offset_x = 0,
-
-            // Offset is full cell height because for CoreText we render
-            // an entire cell.
-            .offset_y = @floatToInt(i32, self.metrics.cell_height),
-
+            .offset_x = @floatToInt(i32, @ceil(bounding[0].origin.x)),
+            .offset_y = offset_y,
             .atlas_x = region.x,
             .atlas_y = region.y,
             .advance_x = @floatCast(f32, advances[0].width),

commit fa0028f104b33737d10d0766321e9d5e7f8d9571
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 18 14:57:44 2022 -0700

    coretext: rasterize glyph with a padding to prevent artifacting

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index f5572097..43cc26d1 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -94,6 +94,11 @@ pub const Face = struct {
         glyph_index: u32,
         max_height: ?u16,
     ) !font.Glyph {
+        // We add a small pixel padding around the edge of our glyph so that
+        // anti-aliasing and smoothing doesn't cause us to pick up the pixels
+        // of another glyph when packed into the atlas.
+        const padding = 1;
+
         _ = max_height;
 
         var glyphs = [_]macos.graphics.Glyph{@intCast(macos.graphics.Glyph, glyph_index)};
@@ -104,8 +109,11 @@ pub const Face = struct {
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
         const glyph_width = @floatToInt(u32, @ceil(bounding[0].size.width));
         const glyph_height = @floatToInt(u32, @ceil(bounding[0].size.height));
-        const width = glyph_width;
-        const height = glyph_height;
+
+        // Width and height. Note the padding doubling is because we want
+        // the padding on both sides (top/bottom, left/right).
+        const width = glyph_width + (padding * 2);
+        const height = glyph_height + (padding * 2);
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
@@ -158,8 +166,8 @@ pub const Face = struct {
         // are offset by bearings, so we have to undo those bearings in order
         // to get them to 0,0.
         var pos = [_]macos.graphics.Point{.{
-            .x = -1 * bounding[0].origin.x,
-            .y = -1 * bounding[0].origin.y,
+            .x = padding + (-1 * bounding[0].origin.x),
+            .y = padding + (-1 * bounding[0].origin.y),
         }};
         self.font.drawGlyphs(&glyphs, &pos, ctx);
 
@@ -183,12 +191,12 @@ pub const Face = struct {
         };
 
         return font.Glyph{
-            .width = width,
-            .height = height,
+            .width = glyph_width,
+            .height = glyph_height,
             .offset_x = @floatToInt(i32, @ceil(bounding[0].origin.x)),
             .offset_y = offset_y,
-            .atlas_x = region.x,
-            .atlas_y = region.y,
+            .atlas_x = region.x + padding,
+            .atlas_y = region.y + padding,
             .advance_x = @floatCast(f32, advances[0].width),
         };
     }

commit 79f69885cafe41dc04d36eb19fd99d9f17e74b84
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 19 10:42:31 2022 -0700

    update to latest zig which renames @min/@max

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 43cc26d1..bdb7338e 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -230,7 +230,7 @@ pub const Face = struct {
             var max: f64 = 0;
             var i: usize = 0;
             while (i < advances.len) : (i += 1) {
-                max = @maximum(advances[i].width, max);
+                max = @max(advances[i].width, max);
             }
 
             break :cell_width @floatCast(f32, max);

commit 371a7f79cb4b747d3363d958b857d97ac9ee3a33
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 15 20:29:58 2022 -0800

    coretext: implement resizing

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index bdb7338e..c95d8d72 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -65,6 +65,15 @@ pub const Face = struct {
         self.* = undefined;
     }
 
+    /// Resize the font in-place. If this succeeds, the caller is responsible
+    /// for clearing any glyph caches, font atlas data, etc.
+    pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {
+        // We just create a copy and replace ourself
+        const face = try initFontCopy(self.font, size);
+        self.deinit();
+        self.* = face;
+    }
+
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
     pub fn glyphIndex(self: Face, cp: u32) ?u32 {

commit f871630fa40e6dbe035d55376a90d33c4470e5f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Nov 28 10:35:46 2022 -0800

    move Atlas to font

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index c95d8d72..5452bcd6 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -4,7 +4,6 @@ const Allocator = std.mem.Allocator;
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
-const Atlas = @import("../../Atlas.zig");
 
 pub const Face = struct {
     /// Our font face
@@ -99,7 +98,7 @@ pub const Face = struct {
     pub fn renderGlyph(
         self: Face,
         alloc: Allocator,
-        atlas: *Atlas,
+        atlas: *font.Atlas,
         glyph_index: u32,
         max_height: ?u16,
     ) !font.Glyph {
@@ -343,7 +342,7 @@ test {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
     const name = try macos.foundation.String.createWithBytes("Monaco", .utf8, false);
@@ -391,7 +390,7 @@ test "in-memory" {
     const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontRegular;
 
-    var atlas = try Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
     defer atlas.deinit(alloc);
 
     var lib = try font.Library.init();

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 5452bcd6..2604c32e 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -42,7 +42,7 @@ pub const Face = struct {
     /// adjusted to the final size for final load.
     pub fn initFontCopy(base: *macos.text.Font, size: font.face.DesiredSize) !Face {
         // Create a copy
-        const ct_font = try base.copyWithAttributes(@intToFloat(f32, size.points), null);
+        const ct_font = try base.copyWithAttributes(@floatFromInt(f32, size.points), null);
         errdefer ct_font.release();
 
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
@@ -115,8 +115,8 @@ pub const Face = struct {
         // of the bitmap. We use the rounded up width/height of the bounding rect.
         var bounding: [1]macos.graphics.Rect = undefined;
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
-        const glyph_width = @floatToInt(u32, @ceil(bounding[0].size.width));
-        const glyph_height = @floatToInt(u32, @ceil(bounding[0].size.height));
+        const glyph_width = @intFromFloat(u32, @ceil(bounding[0].size.width));
+        const glyph_height = @intFromFloat(u32, @ceil(bounding[0].size.height));
 
         // Width and height. Note the padding doubling is because we want
         // the padding on both sides (top/bottom, left/right).
@@ -156,8 +156,8 @@ pub const Face = struct {
             8,
             width,
             space,
-            @enumToInt(macos.graphics.BitmapInfo.alpha_mask) &
-                @enumToInt(macos.graphics.ImageAlphaInfo.none),
+            @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
+                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
         );
         defer ctx.release();
 
@@ -195,13 +195,13 @@ pub const Face = struct {
             // by default below the line. We have to add height (glyph height)
             // so that we shift the glyph UP to be on the line, then we add our
             // baseline offset to move the glyph further UP to match the baseline.
-            break :offset_y @intCast(i32, height) + @floatToInt(i32, @ceil(baseline_with_offset));
+            break :offset_y @intCast(i32, height) + @intFromFloat(i32, @ceil(baseline_with_offset));
         };
 
         return font.Glyph{
             .width = glyph_width,
             .height = glyph_height,
-            .offset_x = @floatToInt(i32, @ceil(bounding[0].origin.x)),
+            .offset_x = @intFromFloat(i32, @ceil(bounding[0].origin.x)),
             .offset_y = offset_y,
             .atlas_x = region.x + padding,
             .atlas_y = region.y + padding,

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 2604c32e..a95fcb70 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -42,7 +42,7 @@ pub const Face = struct {
     /// adjusted to the final size for final load.
     pub fn initFontCopy(base: *macos.text.Font, size: font.face.DesiredSize) !Face {
         // Create a copy
-        const ct_font = try base.copyWithAttributes(@floatFromInt(f32, size.points), null);
+        const ct_font = try base.copyWithAttributes(@floatFromInt(size.points), null);
         errdefer ct_font.release();
 
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
@@ -90,7 +90,7 @@ pub const Face = struct {
         // to decode down into exactly one glyph ID.
         if (pair) assert(glyphs[1] == 0);
 
-        return @intCast(u32, glyphs[0]);
+        return @intCast(glyphs[0]);
     }
 
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
@@ -109,14 +109,14 @@ pub const Face = struct {
 
         _ = max_height;
 
-        var glyphs = [_]macos.graphics.Glyph{@intCast(macos.graphics.Glyph, glyph_index)};
+        var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
 
         // Get the bounding rect for this glyph to determine the width/height
         // of the bitmap. We use the rounded up width/height of the bounding rect.
         var bounding: [1]macos.graphics.Rect = undefined;
         _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
-        const glyph_width = @intFromFloat(u32, @ceil(bounding[0].size.width));
-        const glyph_height = @intFromFloat(u32, @ceil(bounding[0].size.height));
+        const glyph_width = @as(u32, @intFromFloat(@ceil(bounding[0].size.width)));
+        const glyph_height = @as(u32, @intFromFloat(@ceil(bounding[0].size.height)));
 
         // Width and height. Note the padding doubling is because we want
         // the padding on both sides (top/bottom, left/right).
@@ -195,17 +195,17 @@ pub const Face = struct {
             // by default below the line. We have to add height (glyph height)
             // so that we shift the glyph UP to be on the line, then we add our
             // baseline offset to move the glyph further UP to match the baseline.
-            break :offset_y @intCast(i32, height) + @intFromFloat(i32, @ceil(baseline_with_offset));
+            break :offset_y @as(i32, @intCast(height)) + @as(i32, @intFromFloat(@ceil(baseline_with_offset)));
         };
 
         return font.Glyph{
             .width = glyph_width,
             .height = glyph_height,
-            .offset_x = @intFromFloat(i32, @ceil(bounding[0].origin.x)),
+            .offset_x = @intFromFloat(@ceil(bounding[0].origin.x)),
             .offset_y = offset_y,
             .atlas_x = region.x + padding,
             .atlas_y = region.y + padding,
-            .advance_x = @floatCast(f32, advances[0].width),
+            .advance_x = @floatCast(advances[0].width),
         };
     }
 
@@ -241,7 +241,7 @@ pub const Face = struct {
                 max = @max(advances[i].width, max);
             }
 
-            break :cell_width @floatCast(f32, max);
+            break :cell_width @floatCast(max);
         };
 
         // Calculate the cell height by using CoreText's layout engine
@@ -269,9 +269,7 @@ pub const Face = struct {
 
             // Create our framesetter with our string. This is used to
             // emit "frames" for the layout.
-            const fs = try macos.text.Framesetter.createWithAttributedString(
-                @ptrCast(*macos.foundation.AttributedString, string),
-            );
+            const fs = try macos.text.Framesetter.createWithAttributedString(@ptrCast(string));
             defer fs.release();
 
             // Create a rectangle to fit all of this and create a frame of it.
@@ -280,7 +278,7 @@ pub const Face = struct {
             defer path.release();
             const frame = try fs.createFrame(
                 macos.foundation.Range.init(0, 0),
-                @ptrCast(*macos.graphics.Path, path),
+                @ptrCast(path),
                 null,
             );
             defer frame.release();
@@ -305,8 +303,8 @@ pub const Face = struct {
             //std.log.warn("ascent={} descent={} leading={}", .{ ascent, descent, leading });
 
             break :metrics .{
-                .height = @floatCast(f32, points[0].y - points[1].y),
-                .ascent = @floatCast(f32, ascent),
+                .height = @floatCast(points[0].y - points[1].y),
+                .ascent = @floatCast(ascent),
             };
         };
 
@@ -314,8 +312,8 @@ pub const Face = struct {
         const cell_height = layout_metrics.height;
         const cell_baseline = layout_metrics.ascent;
         const underline_position = @ceil(layout_metrics.ascent -
-            @floatCast(f32, ct_font.getUnderlinePosition()));
-        const underline_thickness = @ceil(@floatCast(f32, ct_font.getUnderlineThickness()));
+            @as(f32, @floatCast(ct_font.getUnderlinePosition())));
+        const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
         const strikethrough_position = cell_baseline * 0.6;
         const strikethrough_thickness = underline_thickness;
 

commit 2a1cbb4f21f133764cbeefef7b4e521717ca71b9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 4 11:29:40 2023 -0800

    coretext: calculate units per em/point

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index a95fcb70..c551e3bd 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -317,6 +317,10 @@ pub const Face = struct {
         const strikethrough_position = cell_baseline * 0.6;
         const strikethrough_thickness = underline_thickness;
 
+        // Note: is this useful?
+        // const units_per_em = ct_font.getUnitsPerEm();
+        // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();
+
         // std.log.warn("width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
         //     cell_width,
         //     cell_height,

commit ef5d86ffb09ab1688233f6e226ba2ea578615063
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 4 14:02:45 2023 -0800

    coretext: initially fill grey

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index c551e3bd..86bbca74 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -161,11 +161,23 @@ pub const Face = struct {
         );
         defer ctx.release();
 
+        // Perform an initial fill so that we're sure it starts as we want.
+        ctx.setGrayFillColor(0, 0);
+        ctx.fillRect(.{
+            .origin = .{ .x = 0, .y = 0 },
+            .size = .{
+                .width = @intToFloat(f64, width),
+                .height = @intToFloat(f64, height),
+            },
+        });
+
         ctx.setAllowsAntialiasing(true);
         ctx.setShouldAntialias(true);
         ctx.setShouldSmoothFonts(true);
         ctx.setGrayFillColor(1, 1);
-        ctx.setGrayStrokeColor(1, 1);
+        // With this set the text gets chunky. With it unset the text doesn't
+        // look right at small font sizes. Something isn't right.
+        // ctx.setGrayStrokeColor(1, 1);
         ctx.setTextDrawingMode(.fill_stroke);
         ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
         ctx.setTextPosition(0, 0);

commit 45da58188cab8d71ce956b3c567bce7d8984d78a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 13:53:05 2023 -0700

    fix up for new zig

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 86bbca74..58bbddac 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -144,7 +144,7 @@ pub const Face = struct {
         // TODO(mitchellh): color is going to require a depth here
         var buf = try alloc.alloc(u8, width * height);
         defer alloc.free(buf);
-        std.mem.set(u8, buf, 0);
+        @memset(buf, 0);
 
         const space = try macos.graphics.ColorSpace.createDeviceGray();
         defer space.release();
@@ -166,8 +166,8 @@ pub const Face = struct {
         ctx.fillRect(.{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
-                .width = @intToFloat(f64, width),
-                .height = @intToFloat(f64, height),
+                .width = @floatFromInt(width),
+                .height = @floatFromInt(height),
             },
         });
 

commit 4d7a2c9f05a9a823652d24b73329e482389a5025
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 13:54:13 2023 -0700

    font: remove the old comment about not doing the grey stroke

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 58bbddac..3de6f696 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -175,9 +175,7 @@ pub const Face = struct {
         ctx.setShouldAntialias(true);
         ctx.setShouldSmoothFonts(true);
         ctx.setGrayFillColor(1, 1);
-        // With this set the text gets chunky. With it unset the text doesn't
-        // look right at small font sizes. Something isn't right.
-        // ctx.setGrayStrokeColor(1, 1);
+        ctx.setGrayStrokeColor(1, 1);
         ctx.setTextDrawingMode(.fill_stroke);
         ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
         ctx.setTextPosition(0, 0);

commit 079fe7bc949b59646699c1053a589fc4f1fa2e63
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 14:13:40 2023 -0700

    coretext: the size needs to be in pixels! (see comment)

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 3de6f696..39d5987b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -41,8 +41,10 @@ pub const Face = struct {
     /// because the font is loaded at a default size during discovery, and then
     /// adjusted to the final size for final load.
     pub fn initFontCopy(base: *macos.text.Font, size: font.face.DesiredSize) !Face {
-        // Create a copy
-        const ct_font = try base.copyWithAttributes(@floatFromInt(size.points), null);
+        // Create a copy. The copyWithAttributes docs say the size is in points,
+        // but we need to scale the points by the DPI and to do that we use our
+        // function called "pixels".
+        const ct_font = try base.copyWithAttributes(@floatFromInt(size.pixels()), null);
         errdefer ct_font.release();
 
         var hb_font = try harfbuzz.coretext.createFont(ct_font);

commit 552a1b51d06a4e00a172082e1fdca0a834c762f7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 14:47:59 2023 -0700

    coretext: rasterization looking cleaner

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 39d5987b..b8d93c4e 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -95,6 +95,122 @@ pub const Face = struct {
         return @intCast(glyphs[0]);
     }
 
+    pub fn renderGlyph2(
+        self: Face,
+        alloc: Allocator,
+        atlas: *font.Atlas,
+        glyph_index: u32,
+        max_height: ?u16,
+    ) !font.Glyph {
+        _ = max_height;
+
+        var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
+
+        // Get the bounding rect for this glyph to determine the width/height
+        // of the bitmap. We use the rounded up width/height of the bounding rect.
+        var bounding: [1]macos.graphics.Rect = undefined;
+        const rect = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
+        const rasterized_left: i32 = @intFromFloat(@floor(rect.origin.x));
+        const rasterized_width: u32 = @intFromFloat(@ceil(
+            rect.origin.x - @floor(rect.origin.x) + rect.size.width,
+        ));
+        const rasterized_descent: i32 = @intFromFloat(@ceil(-rect.origin.y));
+        const rasterized_ascent: i32 = @intFromFloat(@ceil(rect.size.height + rect.origin.y));
+        const rasterized_height: u32 = @intCast(rasterized_descent + rasterized_ascent);
+
+        // This bitmap is blank. I've seen it happen in a font, I don't know why.
+        // If it is empty, we just return a valid glyph struct that does nothing.
+        if (rasterized_width == 0 or rasterized_height == 0) return font.Glyph{
+            .width = 0,
+            .height = 0,
+            .offset_x = 0,
+            .offset_y = 0,
+            .atlas_x = 0,
+            .atlas_y = 0,
+            .advance_x = 0,
+        };
+
+        // Our buffer for rendering
+        // TODO(perf): cache this buffer
+        // TODO(mitchellh): color is going to require a depth here
+        var buf = try alloc.alloc(u8, rasterized_width * rasterized_height);
+        defer alloc.free(buf);
+        @memset(buf, 0);
+
+        const space = try macos.graphics.ColorSpace.createDeviceGray();
+        defer space.release();
+
+        const ctx = try macos.graphics.BitmapContext.create(
+            buf,
+            rasterized_width,
+            rasterized_height,
+            8,
+            rasterized_width,
+            space,
+            @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
+                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
+        );
+        defer ctx.release();
+
+        // Perform an initial fill. This ensures that we don't have any
+        // uninitialized pixels in the bitmap.
+        ctx.setGrayFillColor(0, 0);
+        ctx.fillRect(.{
+            .origin = .{ .x = 0, .y = 0 },
+            .size = .{
+                .width = @floatFromInt(rasterized_width),
+                .height = @floatFromInt(rasterized_height),
+            },
+        });
+
+        ctx.setAllowsFontSmoothing(true);
+        ctx.setShouldSmoothFonts(true);
+        ctx.setAllowsFontSubpixelQuantization(true);
+        ctx.setShouldSubpixelQuantizeFonts(true);
+        ctx.setAllowsFontSubpixelPositioning(true);
+        ctx.setShouldSubpixelPositionFonts(true);
+        ctx.setAllowsAntialiasing(true);
+        ctx.setShouldAntialias(true);
+
+        // Set our color for drawing
+        ctx.setGrayFillColor(1, 1);
+        ctx.setGrayStrokeColor(1, 1);
+        // ctx.setTextDrawingMode(.fill_stroke);
+        // ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
+        // ctx.setTextPosition(0, 0);
+
+        // We want to render the glyphs at (0,0), but the glyphs themselves
+        // are offset by bearings, so we have to undo those bearings in order
+        // to get them to 0,0.
+        self.font.drawGlyphs(&glyphs, &.{
+            .{
+                .x = -1 * @as(f64, @floatFromInt(rasterized_left)),
+                .y = @as(f64, @floatFromInt(rasterized_descent)),
+            },
+        }, ctx);
+
+        const region = try atlas.reserve(alloc, rasterized_width, rasterized_height);
+        atlas.set(region, buf);
+
+        std.log.warn("FONT FONT FONT rasterized_left={} rasterized_width={} rasterized_descent={} rasterized_ascent={} rasterized_height={}", .{
+            rasterized_left,
+            rasterized_width,
+            rasterized_descent,
+            rasterized_ascent,
+            rasterized_height,
+        });
+
+        return .{
+            .width = @intCast(rasterized_width),
+            .height = @intCast(rasterized_height),
+            .advance_x = 0,
+            .offset_x = @intCast(rasterized_left),
+            .offset_y = @intCast(rasterized_ascent),
+            .atlas_x = @intCast(region.x),
+            .atlas_y = @intCast(region.y),
+        };
+    }
+
     /// Render a glyph using the glyph index. The rendered glyph is stored in the
     /// given texture atlas.
     pub fn renderGlyph(
@@ -125,6 +241,8 @@ pub const Face = struct {
         const width = glyph_width + (padding * 2);
         const height = glyph_height + (padding * 2);
 
+        if (true) return try self.renderGlyph2(alloc, atlas, glyph_index, 0);
+
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
         if (glyph_width == 0) return font.Glyph{
@@ -333,13 +451,14 @@ pub const Face = struct {
         // const units_per_em = ct_font.getUnitsPerEm();
         // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();
 
-        // std.log.warn("width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
-        //     cell_width,
-        //     cell_height,
-        //     cell_baseline,
-        //     underline_position,
-        //     underline_thickness,
-        // });
+        std.log.warn("font size size={d}", .{ct_font.getSize()});
+        std.log.warn("font metrics width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
+            cell_width,
+            cell_height,
+            cell_baseline,
+            underline_position,
+            underline_thickness,
+        });
         return font.face.Metrics{
             .cell_width = cell_width,
             .cell_height = cell_height,

commit 286944cd43e8d0bddd2431c0fa2f2781fbd3c2c3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 15:24:14 2023 -0700

    cleaning up rasterization, comments

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index b8d93c4e..7108d30b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -102,25 +102,41 @@ pub const Face = struct {
         glyph_index: u32,
         max_height: ?u16,
     ) !font.Glyph {
+        // We add a small pixel padding around the edge of our glyph so that
+        // anti-aliasing and smoothing doesn't cause us to pick up the pixels
+        // of another glyph when packed into the atlas.
+        const padding = 1;
+
         _ = max_height;
 
         var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
 
-        // Get the bounding rect for this glyph to determine the width/height
-        // of the bitmap. We use the rounded up width/height of the bounding rect.
-        var bounding: [1]macos.graphics.Rect = undefined;
-        const rect = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
-        const rasterized_left: i32 = @intFromFloat(@floor(rect.origin.x));
-        const rasterized_width: u32 = @intFromFloat(@ceil(
-            rect.origin.x - @floor(rect.origin.x) + rect.size.width,
-        ));
-        const rasterized_descent: i32 = @intFromFloat(@ceil(-rect.origin.y));
-        const rasterized_ascent: i32 = @intFromFloat(@ceil(rect.size.height + rect.origin.y));
-        const rasterized_height: u32 = @intCast(rasterized_descent + rasterized_ascent);
+        // Get the bounding rect for rendering this glyph.
+        const rect = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, null);
+
+        // The x/y that we render the glyph at. The Y value has to be flipped
+        // because our coordinates in 3D space are (0, 0) bottom left with
+        // +y being up.
+        const render_x = @floor(rect.origin.x);
+        const render_y = @ceil(-rect.origin.y);
+
+        // The ascent is the amount of pixels above the baseline this glyph
+        // is rendered. The ascent can be calculated by adding the full
+        // glyph height to the origin.
+        const glyph_ascent = @ceil(rect.size.height + rect.origin.y);
+
+        // The glyph height is basically rect.size.height but we do the
+        // ascent plus the descent because both are rounded elements that
+        // will make us more accurate.
+        const glyph_height: u32 = @intFromFloat(glyph_ascent + render_y);
+
+        // The glyph width is our advertised bounding with plus the rounding
+        // difference from our rendering X.
+        const glyph_width: u32 = @intFromFloat(@ceil(rect.size.width + (rect.origin.x - render_x)));
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        if (rasterized_width == 0 or rasterized_height == 0) return font.Glyph{
+        if (glyph_width == 0 or glyph_height == 0) return font.Glyph{
             .width = 0,
             .height = 0,
             .offset_x = 0,
@@ -130,10 +146,15 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
+        // Width and height. Note the padding doubling is because we want
+        // the padding on both sides (top/bottom, left/right).
+        const width = glyph_width + (padding * 2);
+        const height = glyph_height + (padding * 2);
+
         // Our buffer for rendering
         // TODO(perf): cache this buffer
         // TODO(mitchellh): color is going to require a depth here
-        var buf = try alloc.alloc(u8, rasterized_width * rasterized_height);
+        var buf = try alloc.alloc(u8, width * height);
         defer alloc.free(buf);
         @memset(buf, 0);
 
@@ -142,10 +163,10 @@ pub const Face = struct {
 
         const ctx = try macos.graphics.BitmapContext.create(
             buf,
-            rasterized_width,
-            rasterized_height,
+            width,
+            height,
             8,
-            rasterized_width,
+            width,
             space,
             @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
                 @intFromEnum(macos.graphics.ImageAlphaInfo.none),
@@ -158,8 +179,8 @@ pub const Face = struct {
         ctx.fillRect(.{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
-                .width = @floatFromInt(rasterized_width),
-                .height = @floatFromInt(rasterized_height),
+                .width = @floatFromInt(width),
+                .height = @floatFromInt(height),
             },
         });
 
@@ -175,39 +196,44 @@ pub const Face = struct {
         // Set our color for drawing
         ctx.setGrayFillColor(1, 1);
         ctx.setGrayStrokeColor(1, 1);
-        // ctx.setTextDrawingMode(.fill_stroke);
-        // ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
-        // ctx.setTextPosition(0, 0);
 
         // We want to render the glyphs at (0,0), but the glyphs themselves
         // are offset by bearings, so we have to undo those bearings in order
-        // to get them to 0,0.
+        // to get them to 0,0. We also add the padding so that they render
+        // slightly off the edge of the bitmap.
         self.font.drawGlyphs(&glyphs, &.{
             .{
-                .x = -1 * @as(f64, @floatFromInt(rasterized_left)),
-                .y = @as(f64, @floatFromInt(rasterized_descent)),
+                .x = padding + (-1 * render_x),
+                .y = padding + render_y,
             },
         }, ctx);
 
-        const region = try atlas.reserve(alloc, rasterized_width, rasterized_height);
+        const region = try atlas.reserve(alloc, width, height);
         atlas.set(region, buf);
 
-        std.log.warn("FONT FONT FONT rasterized_left={} rasterized_width={} rasterized_descent={} rasterized_ascent={} rasterized_height={}", .{
-            rasterized_left,
-            rasterized_width,
-            rasterized_descent,
-            rasterized_ascent,
-            rasterized_height,
-        });
+        const offset_y: i32 = offset_y: {
+            // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
+            // We need to calculate our baseline from the bottom of a cell.
+            const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
+
+            // Next we offset our baseline by the bearing in the font. We
+            // ADD here because CoreText y is UP.
+            const baseline_with_offset = baseline_from_bottom + glyph_ascent;
+
+            break :offset_y @intFromFloat(@ceil(baseline_with_offset));
+        };
 
         return .{
-            .width = @intCast(rasterized_width),
-            .height = @intCast(rasterized_height),
+            .width = glyph_width,
+            .height = glyph_height,
+            .offset_x = @intFromFloat(render_x),
+            .offset_y = offset_y,
+            .atlas_x = region.x + padding,
+            .atlas_y = region.y + padding,
+
+            // This is not used, so we don't bother calculating it. If we
+            // ever need it, we can calculate it using getAdvancesForGlyph.
             .advance_x = 0,
-            .offset_x = @intCast(rasterized_left),
-            .offset_y = @intCast(rasterized_ascent),
-            .atlas_x = @intCast(region.x),
-            .atlas_y = @intCast(region.y),
         };
     }
 

commit a74e49833b3fbbe82919302c7d9ab56dfaab8f3e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 15:57:59 2023 -0700

    coretext: colored glyph rendering

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7108d30b..87ccb467 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -151,31 +151,50 @@ pub const Face = struct {
         const width = glyph_width + (padding * 2);
         const height = glyph_height + (padding * 2);
 
+        // Settings that are specific to if we are rendering text or emoji.
+        const color: struct {
+            color: bool,
+            depth: u32,
+            space: *macos.graphics.ColorSpace,
+            context_opts: c_uint,
+        } = if (self.presentation == .text) .{
+            .color = false,
+            .depth = 1,
+            .space = try macos.graphics.ColorSpace.createDeviceGray(),
+            .context_opts = @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
+                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
+        } else .{
+            .color = true,
+            .depth = 4,
+            .space = try macos.graphics.ColorSpace.createDeviceRGB(),
+            .context_opts = @intFromEnum(macos.graphics.BitmapInfo.byte_order_32_little) |
+                @intFromEnum(macos.graphics.ImageAlphaInfo.premultiplied_first),
+        };
+        defer color.space.release();
+
         // Our buffer for rendering
         // TODO(perf): cache this buffer
-        // TODO(mitchellh): color is going to require a depth here
-        var buf = try alloc.alloc(u8, width * height);
+        var buf = try alloc.alloc(u8, width * height * color.depth);
         defer alloc.free(buf);
         @memset(buf, 0);
 
-        const space = try macos.graphics.ColorSpace.createDeviceGray();
-        defer space.release();
-
         const ctx = try macos.graphics.BitmapContext.create(
             buf,
             width,
             height,
             8,
-            width,
-            space,
-            @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
-                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
+            width * color.depth,
+            color.space,
+            color.context_opts,
         );
         defer ctx.release();
 
         // Perform an initial fill. This ensures that we don't have any
         // uninitialized pixels in the bitmap.
-        ctx.setGrayFillColor(0, 0);
+        if (color.color)
+            ctx.setRGBFillColor(1, 1, 1, 0)
+        else
+            ctx.setGrayFillColor(0, 0);
         ctx.fillRect(.{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
@@ -185,7 +204,7 @@ pub const Face = struct {
         });
 
         ctx.setAllowsFontSmoothing(true);
-        ctx.setShouldSmoothFonts(true);
+        ctx.setShouldSmoothFonts(true); // The amadeus "enthicken"
         ctx.setAllowsFontSubpixelQuantization(true);
         ctx.setShouldSubpixelQuantizeFonts(true);
         ctx.setAllowsFontSubpixelPositioning(true);
@@ -194,8 +213,13 @@ pub const Face = struct {
         ctx.setShouldAntialias(true);
 
         // Set our color for drawing
-        ctx.setGrayFillColor(1, 1);
-        ctx.setGrayStrokeColor(1, 1);
+        if (color.color) {
+            ctx.setRGBFillColor(1, 1, 1, 1);
+            ctx.setRGBStrokeColor(1, 1, 1, 1);
+        } else {
+            ctx.setGrayFillColor(1, 1);
+            ctx.setGrayStrokeColor(1, 1);
+        }
 
         // We want to render the glyphs at (0,0), but the glyphs themselves
         // are offset by bearings, so we have to undo those bearings in order

commit c52dc229f3f4bf4352bb6527b502267b5fd16523
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 16:59:17 2023 -0700

    coretext: validate atlas depth matches color depth

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 87ccb467..36e58553 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -5,6 +5,8 @@ const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
 
+const log = std.log.scoped(.font_face);
+
 pub const Face = struct {
     /// Our font face
     font: *macos.text.Font,
@@ -172,6 +174,15 @@ pub const Face = struct {
         };
         defer color.space.release();
 
+        // This is just a safety check.
+        if (atlas.format.depth() != color.depth) {
+            log.warn("font atlas color depth doesn't equal font color depth atlas={} font={}", .{
+                atlas.format.depth(),
+                color.depth,
+            });
+            return error.InvalidAtlasFormat;
+        }
+
         // Our buffer for rendering
         // TODO(perf): cache this buffer
         var buf = try alloc.alloc(u8, width * height * color.depth);

commit 55254acaad0c85660f1faf469151fa421fc671cc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 17:12:24 2023 -0700

    coretext: fix emoji placement

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 36e58553..029bfef1 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -215,7 +215,7 @@ pub const Face = struct {
         });
 
         ctx.setAllowsFontSmoothing(true);
-        ctx.setShouldSmoothFonts(true); // The amadeus "enthicken"
+        ctx.setShouldSmoothFonts(false); // The amadeus "enthicken"
         ctx.setAllowsFontSubpixelQuantization(true);
         ctx.setShouldSubpixelQuantizeFonts(true);
         ctx.setAllowsFontSubpixelPositioning(true);
@@ -247,6 +247,18 @@ pub const Face = struct {
         atlas.set(region, buf);
 
         const offset_y: i32 = offset_y: {
+            // For non-scalable colorized fonts, we assume they are pictographic
+            // and just center the glyph. So far this has only applied to emoji
+            // fonts. Emoji fonts don't always report a correct ascender/descender
+            // (mainly Apple Emoji) so we just center them. Also, since emoji font
+            // aren't scalable, cell_baseline is incorrect anyways.
+            //
+            // NOTE(mitchellh): I don't know if this is right, this doesn't
+            // _feel_ right, but it makes all my limited test cases work.
+            if (color.color) {
+                break :offset_y @intFromFloat(self.metrics.cell_height);
+            }
+
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
             const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
@@ -258,6 +270,17 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
+        log.warn("FONT FONT FONT width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+            glyph_width,
+            glyph_height,
+            render_x,
+            render_y,
+            offset_y,
+            glyph_ascent,
+            self.metrics.cell_height,
+            self.metrics.cell_baseline,
+        });
+
         return .{
             .width = glyph_width,
             .height = glyph_height,

commit 5706770c38e715e9180e2366563c15354409a35d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 21:02:10 2023 -0700

    coretext: handle glyph padding in region reservation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 029bfef1..0ff2eb6a 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -104,11 +104,6 @@ pub const Face = struct {
         glyph_index: u32,
         max_height: ?u16,
     ) !font.Glyph {
-        // We add a small pixel padding around the edge of our glyph so that
-        // anti-aliasing and smoothing doesn't cause us to pick up the pixels
-        // of another glyph when packed into the atlas.
-        const padding = 1;
-
         _ = max_height;
 
         var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
@@ -130,15 +125,15 @@ pub const Face = struct {
         // The glyph height is basically rect.size.height but we do the
         // ascent plus the descent because both are rounded elements that
         // will make us more accurate.
-        const glyph_height: u32 = @intFromFloat(glyph_ascent + render_y);
+        const height: u32 = @intFromFloat(glyph_ascent + render_y);
 
         // The glyph width is our advertised bounding with plus the rounding
         // difference from our rendering X.
-        const glyph_width: u32 = @intFromFloat(@ceil(rect.size.width + (rect.origin.x - render_x)));
+        const width: u32 = @intFromFloat(@ceil(rect.size.width + (rect.origin.x - render_x)));
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        if (glyph_width == 0 or glyph_height == 0) return font.Glyph{
+        if (width == 0 or height == 0) return font.Glyph{
             .width = 0,
             .height = 0,
             .offset_x = 0,
@@ -148,11 +143,6 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
-        // Width and height. Note the padding doubling is because we want
-        // the padding on both sides (top/bottom, left/right).
-        const width = glyph_width + (padding * 2);
-        const height = glyph_height + (padding * 2);
-
         // Settings that are specific to if we are rendering text or emoji.
         const color: struct {
             color: bool,
@@ -238,12 +228,33 @@ pub const Face = struct {
         // slightly off the edge of the bitmap.
         self.font.drawGlyphs(&glyphs, &.{
             .{
-                .x = padding + (-1 * render_x),
-                .y = padding + render_y,
+                .x = -1 * render_x,
+                .y = render_y,
             },
         }, ctx);
 
-        const region = try atlas.reserve(alloc, width, height);
+        const region = region: {
+            // We need to add a 1px padding to the font so that we don't
+            // get fuzzy issues when blending textures.
+            const padding = 1;
+
+            // Get the full padded region
+            var region = try atlas.reserve(
+                alloc,
+                width + (padding * 2), // * 2 because left+right
+                height + (padding * 2), // * 2 because top+bottom
+            );
+
+            // Modify the region so that we remove the padding so that
+            // we write to the non-zero location. The data in an Altlas
+            // is always initialized to zero (Atlas.clear) so we don't
+            // need to worry about zero-ing that.
+            region.x += padding;
+            region.y += padding;
+            region.width -= padding * 2;
+            region.height -= padding * 2;
+            break :region region;
+        };
         atlas.set(region, buf);
 
         const offset_y: i32 = offset_y: {
@@ -270,9 +281,10 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
-        log.warn("FONT FONT FONT width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
-            glyph_width,
-            glyph_height,
+        log.warn("FONT FONT FONT rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+            rect,
+            width,
+            height,
             render_x,
             render_y,
             offset_y,
@@ -282,12 +294,12 @@ pub const Face = struct {
         });
 
         return .{
-            .width = glyph_width,
-            .height = glyph_height,
+            .width = width,
+            .height = height,
             .offset_x = @intFromFloat(render_x),
             .offset_y = offset_y,
-            .atlas_x = region.x + padding,
-            .atlas_y = region.y + padding,
+            .atlas_x = region.x,
+            .atlas_y = region.y,
 
             // This is not used, so we don't bother calculating it. If we
             // ever need it, we can calculate it using getAdvancesForGlyph.

commit 69396b0853f11a0deac4f330a8034286685b52f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 21:48:55 2023 -0700

    coretext: layout rect must fit all chars

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 0ff2eb6a..308ac334 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -499,8 +499,32 @@ pub const Face = struct {
             defer fs.release();
 
             // Create a rectangle to fit all of this and create a frame of it.
+            // The rectangle needs to fit all of our text so we use some
+            // heuristics based on cell_width to calculate it. We are
+            // VERY generous with our rect here because the text must fit.
+            const path_rect = rect: {
+                // The cell width at this point is valid, so let's make it
+                // fit 50 characters wide.
+                const width = cell_width * 50;
+
+                // We are trying to calculate height so we don't know how
+                // high to make our frame. Well-behaved fonts will probably
+                // not have a height greater than 4x the width, so let's just
+                // generously use that metric to ensure we fit the frame.
+                const big_cell_height = cell_width * 4;
+
+                // If we are fitting about ~50 characters per row, we need
+                // unit.len / 50 rows to fit all of our text.
+                const rows = (unit.len / 50) * 2;
+
+                // Our final height is the number of rows times our generous height.
+                const height = rows * big_cell_height;
+
+                break :rect macos.graphics.Rect.init(10, 10, width, height);
+            };
+
             const path = try macos.graphics.MutablePath.create();
-            path.addRect(null, macos.graphics.Rect.init(10, 10, 200, 200));
+            path.addRect(null, path_rect);
             defer path.release();
             const frame = try fs.createFrame(
                 macos.foundation.Range.init(0, 0),

commit d39e3f542883c41104815b16f4fc55497d5b6843
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 21:59:52 2023 -0700

    coretext: improved baseline calculation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 308ac334..b04e35d0 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -545,16 +545,22 @@ pub const Face = struct {
             // NOTE(mitchellh): For some reason, CTLineGetBoundsWithOptions
             // returns garbage and I can't figure out why... so we use the
             // raw ascender.
-
-            var ascent: f64 = 0;
-            var descent: f64 = 0;
-            var leading: f64 = 0;
-            _ = line.getTypographicBounds(&ascent, &descent, &leading);
+            const bounds = line.getBoundsWithOptions(.{ .exclude_leading = true });
+            const bounds_ascent = bounds.size.height + bounds.origin.y;
+            const baseline = @floor(bounds_ascent + 0.5);
+
+            // This is an alternate approach to the above to calculate the
+            // baseline by simply using the ascender. Using this approach led
+            // to less accurate results, but I'm leaving it here for reference.
+            // var ascent: f64 = 0;
+            // var descent: f64 = 0;
+            // var leading: f64 = 0;
+            // _ = line.getTypographicBounds(&ascent, &descent, &leading);
             //std.log.warn("ascent={} descent={} leading={}", .{ ascent, descent, leading });
 
             break :metrics .{
                 .height = @floatCast(points[0].y - points[1].y),
-                .ascent = @floatCast(ascent),
+                .ascent = @floatCast(baseline),
             };
         };
 

commit 362eeac74b12c00c7def4e73b0b60ea70d65473f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:28:09 2023 -0700

    coretext: do not treat color diffs special for offset

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index b04e35d0..a61c74d6 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -258,18 +258,6 @@ pub const Face = struct {
         atlas.set(region, buf);
 
         const offset_y: i32 = offset_y: {
-            // For non-scalable colorized fonts, we assume they are pictographic
-            // and just center the glyph. So far this has only applied to emoji
-            // fonts. Emoji fonts don't always report a correct ascender/descender
-            // (mainly Apple Emoji) so we just center them. Also, since emoji font
-            // aren't scalable, cell_baseline is incorrect anyways.
-            //
-            // NOTE(mitchellh): I don't know if this is right, this doesn't
-            // _feel_ right, but it makes all my limited test cases work.
-            if (color.color) {
-                break :offset_y @intFromFloat(self.metrics.cell_height);
-            }
-
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
             const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
@@ -281,17 +269,17 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
-        log.warn("FONT FONT FONT rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
-            rect,
-            width,
-            height,
-            render_x,
-            render_y,
-            offset_y,
-            glyph_ascent,
-            self.metrics.cell_height,
-            self.metrics.cell_baseline,
-        });
+        // log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+        //     rect,
+        //     width,
+        //     height,
+        //     render_x,
+        //     render_y,
+        //     offset_y,
+        //     glyph_ascent,
+        //     self.metrics.cell_height,
+        //     self.metrics.cell_baseline,
+        // });
 
         return .{
             .width = width,

commit 42cc11e32c3bdfeae3a29e70cdca91a8cfcbe45d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:44:44 2023 -0700

    coretext: remove the old renderGlyph impl

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index a61c74d6..b44d9905 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -97,7 +97,7 @@ pub const Face = struct {
         return @intCast(glyphs[0]);
     }
 
-    pub fn renderGlyph2(
+    pub fn renderGlyph(
         self: Face,
         alloc: Allocator,
         atlas: *font.Atlas,
@@ -295,134 +295,6 @@ pub const Face = struct {
         };
     }
 
-    /// Render a glyph using the glyph index. The rendered glyph is stored in the
-    /// given texture atlas.
-    pub fn renderGlyph(
-        self: Face,
-        alloc: Allocator,
-        atlas: *font.Atlas,
-        glyph_index: u32,
-        max_height: ?u16,
-    ) !font.Glyph {
-        // We add a small pixel padding around the edge of our glyph so that
-        // anti-aliasing and smoothing doesn't cause us to pick up the pixels
-        // of another glyph when packed into the atlas.
-        const padding = 1;
-
-        _ = max_height;
-
-        var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
-
-        // Get the bounding rect for this glyph to determine the width/height
-        // of the bitmap. We use the rounded up width/height of the bounding rect.
-        var bounding: [1]macos.graphics.Rect = undefined;
-        _ = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, &bounding);
-        const glyph_width = @as(u32, @intFromFloat(@ceil(bounding[0].size.width)));
-        const glyph_height = @as(u32, @intFromFloat(@ceil(bounding[0].size.height)));
-
-        // Width and height. Note the padding doubling is because we want
-        // the padding on both sides (top/bottom, left/right).
-        const width = glyph_width + (padding * 2);
-        const height = glyph_height + (padding * 2);
-
-        if (true) return try self.renderGlyph2(alloc, atlas, glyph_index, 0);
-
-        // This bitmap is blank. I've seen it happen in a font, I don't know why.
-        // If it is empty, we just return a valid glyph struct that does nothing.
-        if (glyph_width == 0) return font.Glyph{
-            .width = 0,
-            .height = 0,
-            .offset_x = 0,
-            .offset_y = 0,
-            .atlas_x = 0,
-            .atlas_y = 0,
-            .advance_x = 0,
-        };
-
-        // Get the advance that we need for the glyph
-        var advances: [1]macos.graphics.Size = undefined;
-        _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
-
-        // Our buffer for rendering
-        // TODO(perf): cache this buffer
-        // TODO(mitchellh): color is going to require a depth here
-        var buf = try alloc.alloc(u8, width * height);
-        defer alloc.free(buf);
-        @memset(buf, 0);
-
-        const space = try macos.graphics.ColorSpace.createDeviceGray();
-        defer space.release();
-
-        const ctx = try macos.graphics.BitmapContext.create(
-            buf,
-            width,
-            height,
-            8,
-            width,
-            space,
-            @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
-                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
-        );
-        defer ctx.release();
-
-        // Perform an initial fill so that we're sure it starts as we want.
-        ctx.setGrayFillColor(0, 0);
-        ctx.fillRect(.{
-            .origin = .{ .x = 0, .y = 0 },
-            .size = .{
-                .width = @floatFromInt(width),
-                .height = @floatFromInt(height),
-            },
-        });
-
-        ctx.setAllowsAntialiasing(true);
-        ctx.setShouldAntialias(true);
-        ctx.setShouldSmoothFonts(true);
-        ctx.setGrayFillColor(1, 1);
-        ctx.setGrayStrokeColor(1, 1);
-        ctx.setTextDrawingMode(.fill_stroke);
-        ctx.setTextMatrix(macos.graphics.AffineTransform.identity());
-        ctx.setTextPosition(0, 0);
-
-        // We want to render the glyphs at (0,0), but the glyphs themselves
-        // are offset by bearings, so we have to undo those bearings in order
-        // to get them to 0,0.
-        var pos = [_]macos.graphics.Point{.{
-            .x = padding + (-1 * bounding[0].origin.x),
-            .y = padding + (-1 * bounding[0].origin.y),
-        }};
-        self.font.drawGlyphs(&glyphs, &pos, ctx);
-
-        const region = try atlas.reserve(alloc, width, height);
-        atlas.set(region, buf);
-
-        const offset_y = offset_y: {
-            // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
-            // We need to calculate our baseline from the bottom of a cell.
-            const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
-
-            // Next we offset our baseline by the bearing in the font. We
-            // ADD here because CoreText y is UP.
-            const baseline_with_offset = baseline_from_bottom + bounding[0].origin.y;
-
-            // Finally, since we're rendering at (0, 0), the glyph will render
-            // by default below the line. We have to add height (glyph height)
-            // so that we shift the glyph UP to be on the line, then we add our
-            // baseline offset to move the glyph further UP to match the baseline.
-            break :offset_y @as(i32, @intCast(height)) + @as(i32, @intFromFloat(@ceil(baseline_with_offset)));
-        };
-
-        return font.Glyph{
-            .width = glyph_width,
-            .height = glyph_height,
-            .offset_x = @intFromFloat(@ceil(bounding[0].origin.x)),
-            .offset_y = offset_y,
-            .atlas_x = region.x + padding,
-            .atlas_y = region.y + padding,
-            .advance_x = @floatCast(advances[0].width),
-        };
-    }
-
     fn calcMetrics(ct_font: *macos.text.Font) !font.face.Metrics {
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take

commit b5cc37e20c59b6617c41768db11a7b5febd8aa9c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:54:08 2023 -0700

    font: comment out debug logs

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index b44d9905..9fb0774d 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -437,14 +437,15 @@ pub const Face = struct {
         // const units_per_em = ct_font.getUnitsPerEm();
         // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();
 
-        std.log.warn("font size size={d}", .{ct_font.getSize()});
-        std.log.warn("font metrics width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
-            cell_width,
-            cell_height,
-            cell_baseline,
-            underline_position,
-            underline_thickness,
-        });
+        // std.log.warn("font size size={d}", .{ct_font.getSize()});
+        // std.log.warn("font metrics width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
+        //     cell_width,
+        //     cell_height,
+        //     cell_baseline,
+        //     underline_position,
+        //     underline_thickness,
+        // });
+
         return font.face.Metrics{
             .cell_width = cell_width,
             .cell_height = cell_height,

commit e99376cac14dc59b33c3272ca71aed960e3165b7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 22:55:41 2023 -0700

    font: update comment

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 9fb0774d..2380cc55 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -402,9 +402,7 @@ pub const Face = struct {
             const lines = frame.getLines();
             const line = lines.getValueAtIndex(macos.text.Line, 0);
 
-            // NOTE(mitchellh): For some reason, CTLineGetBoundsWithOptions
-            // returns garbage and I can't figure out why... so we use the
-            // raw ascender.
+            // Get the bounds of the line to determine the ascent.
             const bounds = line.getBoundsWithOptions(.{ .exclude_leading = true });
             const bounds_ascent = bounds.size.height + bounds.origin.y;
             const baseline = @floor(bounds_ascent + 0.5);

commit 3795cd6c2d8864e846c24a63f2f720244c79d783
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 09:55:19 2023 -0700

    font: turn rasterization options into a struct, add thicken

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 2380cc55..1b4ec214 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -102,10 +102,8 @@ pub const Face = struct {
         alloc: Allocator,
         atlas: *font.Atlas,
         glyph_index: u32,
-        max_height: ?u16,
+        opts: font.face.RenderOptions,
     ) !font.Glyph {
-        _ = max_height;
-
         var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
 
         // Get the bounding rect for rendering this glyph.
@@ -205,7 +203,7 @@ pub const Face = struct {
         });
 
         ctx.setAllowsFontSmoothing(true);
-        ctx.setShouldSmoothFonts(false); // The amadeus "enthicken"
+        ctx.setShouldSmoothFonts(opts.thicken); // The amadeus "enthicken"
         ctx.setAllowsFontSubpixelQuantization(true);
         ctx.setShouldSubpixelQuantizeFonts(true);
         ctx.setAllowsFontSubpixelPositioning(true);
@@ -479,7 +477,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, null);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -523,6 +521,6 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, null);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }

commit 126817cac282b76210f4276a26a0ed4f76833124
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 10:12:29 2023 -0700

    coretext: tweak underline position

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 1b4ec214..dc33cabc 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -423,12 +423,17 @@ pub const Face = struct {
         // All of these metrics are based on our layout above.
         const cell_height = layout_metrics.height;
         const cell_baseline = layout_metrics.ascent;
-        const underline_position = @ceil(layout_metrics.ascent -
-            @as(f32, @floatCast(ct_font.getUnderlinePosition())));
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
         const strikethrough_position = cell_baseline * 0.6;
         const strikethrough_thickness = underline_thickness;
 
+        // Underline position is based on our baseline because the font advertised
+        // underline position is based on a zero baseline. We add a small amount
+        // to the underline position to make it look better.
+        const underline_position = @ceil(cell_baseline -
+            @as(f32, @floatCast(ct_font.getUnderlinePosition())) +
+            1);
+
         // Note: is this useful?
         // const units_per_em = ct_font.getUnitsPerEm();
         // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();

commit 06f63288c8d7e74e09946d7f92a51b5ec271ba31
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 10:15:50 2023 -0700

    coretext: address TODO

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index dc33cabc..cdc4bd17 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -171,8 +171,10 @@ pub const Face = struct {
             return error.InvalidAtlasFormat;
         }
 
-        // Our buffer for rendering
-        // TODO(perf): cache this buffer
+        // Our buffer for rendering. We could cache this but glyph rasterization
+        // usually stabilizes pretty quickly and is very infrequent so I think
+        // the allocation overhead is acceptable compared to the cost of
+        // caching it forever or having to deal with a cache lifetime.
         var buf = try alloc.alloc(u8, width * height * color.depth);
         defer alloc.free(buf);
         @memset(buf, 0);

commit 1d1b86895826953768d047438cfb68344ddf4289
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 1 13:51:31 2023 -0700

    font: do not use Noto on macOS for tests, it doesn't work

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index cdc4bd17..3ed30cc2 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -30,6 +30,7 @@ pub const Face = struct {
         const arr = macos.text.createFontDescriptorsFromData(data) orelse
             return error.FontInitFailure;
         defer arr.release();
+        if (arr.getCount() == 0) return error.FontInitFailure;
 
         const desc = arr.getValueAtIndex(macos.text.FontDescriptor, 0);
         const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);

commit 0faf6097d069e097680fe4e5a74181d120431297
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 11:08:12 2023 -0700

    Change font metrics to all be integers, not floats.
    
    Font metrics realistically should be integral. Cell widths, cell
    heights, etc. do not make sense to be floats, since our grid is
    integral. There is no such thing as a "half cell" (or any point).
    
    The reason we historically had these all as f32 is simplicity mixed
    with history. OpenGL APIs and shaders all use f32 for their values, we
    originally only supported OpenGL, and all the font rendering used to be
    directly in the renderer code (like... a year+ ago).
    
    When we refactored the font metrics calculation to its own system and
    also added additional renderers like Metal (which use f64, not f32), we
    never updated anything. We just kept metrics as f32 and casted
    everywhere.
    
    With CoreText and #177 this finally reared its ugly head. By forgetting
    a simple rounding on cell metric calculation, our integral renderers
    (sprite fonts) were off by 1 pixel compared to the GPU renderers.
    Insidious.
    
    Let's represent font metrics with the types that actually make sense: a
    cell width/height, etc. is _integral_. When we get to the GPU, we now
    cast to floats. We also cast to floats whenever we're doing more precise
    math (i.e. mouse offset calculation). In this case, we're only
    converting to floats from a integral type which is going to be much
    safer and less prone to uncertain rounding than converting to an int
    from a float type.
    
    Fixes #177

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 3ed30cc2..339782c3 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -261,7 +261,7 @@ pub const Face = struct {
         const offset_y: i32 = offset_y: {
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
-            const baseline_from_bottom = self.metrics.cell_height - self.metrics.cell_baseline;
+            const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_height - self.metrics.cell_baseline);
 
             // Next we offset our baseline by the bearing in the font. We
             // ADD here because CoreText y is UP.
@@ -328,7 +328,7 @@ pub const Face = struct {
                 max = @max(advances[i].width, max);
             }
 
-            break :cell_width @floatCast(max);
+            break :cell_width @floatCast(@ceil(max));
         };
 
         // Calculate the cell height by using CoreText's layout engine
@@ -424,8 +424,8 @@ pub const Face = struct {
         };
 
         // All of these metrics are based on our layout above.
-        const cell_height = layout_metrics.height;
-        const cell_baseline = layout_metrics.ascent;
+        const cell_height = @ceil(layout_metrics.height);
+        const cell_baseline = @ceil(layout_metrics.ascent);
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
         const strikethrough_position = cell_baseline * 0.6;
         const strikethrough_thickness = underline_thickness;
@@ -441,24 +441,20 @@ pub const Face = struct {
         // const units_per_em = ct_font.getUnitsPerEm();
         // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();
 
+        const result = font.face.Metrics{
+            .cell_width = @intFromFloat(cell_width),
+            .cell_height = @intFromFloat(cell_height),
+            .cell_baseline = @intFromFloat(cell_baseline),
+            .underline_position = @intFromFloat(underline_position),
+            .underline_thickness = @intFromFloat(underline_thickness),
+            .strikethrough_position = @intFromFloat(strikethrough_position),
+            .strikethrough_thickness = @intFromFloat(strikethrough_thickness),
+        };
+
         // std.log.warn("font size size={d}", .{ct_font.getSize()});
-        // std.log.warn("font metrics width={d}, height={d} baseline={d} underline_pos={d} underline_thickness={d}", .{
-        //     cell_width,
-        //     cell_height,
-        //     cell_baseline,
-        //     underline_position,
-        //     underline_thickness,
-        // });
+        // std.log.warn("font metrics={}", .{result});
 
-        return font.face.Metrics{
-            .cell_width = cell_width,
-            .cell_height = cell_height,
-            .cell_baseline = cell_baseline,
-            .underline_position = underline_position,
-            .underline_thickness = underline_thickness,
-            .strikethrough_position = strikethrough_position,
-            .strikethrough_thickness = strikethrough_thickness,
-        };
+        return result;
     }
 };
 

commit 0e802b6118d0617f871e76e3bd9e692157d7dacf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 14:00:28 2023 -0700

    coretext: switch up positive/negative y axis values
    
    No functional change, just swapping the math around to match freetype.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 339782c3..76ffdc50 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -261,7 +261,7 @@ pub const Face = struct {
         const offset_y: i32 = offset_y: {
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
-            const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_height - self.metrics.cell_baseline);
+            const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_baseline);
 
             // Next we offset our baseline by the bearing in the font. We
             // ADD here because CoreText y is UP.
@@ -425,17 +425,19 @@ pub const Face = struct {
 
         // All of these metrics are based on our layout above.
         const cell_height = @ceil(layout_metrics.height);
-        const cell_baseline = @ceil(layout_metrics.ascent);
+        const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
-        const strikethrough_position = cell_baseline * 0.6;
+        const strikethrough_position = @ceil(layout_metrics.height - (layout_metrics.ascent * 0.6));
         const strikethrough_thickness = underline_thickness;
 
-        // Underline position is based on our baseline because the font advertised
-        // underline position is based on a zero baseline. We add a small amount
-        // to the underline position to make it look better.
-        const underline_position = @ceil(cell_baseline -
-            @as(f32, @floatCast(ct_font.getUnderlinePosition())) +
-            1);
+        // Underline position reported is usually something like "-1" to
+        // represent the amount under the baseline. We add this to our real
+        // baseline to get the actual value from the bottom (+y is up).
+        // The final underline position is +y from the TOP (confusing)
+        // so we have to substract from the cell height.
+        const underline_position = cell_height -
+            (cell_baseline + @ceil(@as(f32, @floatCast(ct_font.getUnderlinePosition())))) +
+            1;
 
         // Note: is this useful?
         // const units_per_em = ct_font.getUnitsPerEm();

commit 369a7dda4c573195a85d3bb44791bf0bef7fc60a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 14:26:06 2023 -0700

    coretext: use alternate approach to calcaulate cell height and ascent
    
    Fixes #174

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 76ffdc50..efb1ebab 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -270,7 +270,7 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
-        // log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+        // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
         //     rect,
         //     width,
         //     height,
@@ -331,95 +331,20 @@ pub const Face = struct {
             break :cell_width @floatCast(@ceil(max));
         };
 
-        // Calculate the cell height by using CoreText's layout engine
-        // to tell us after laying out some text. This is inspired by Kitty's
-        // approach. Previously we were using descent/ascent math and it wasn't
-        // quite the same with CoreText and I never figured out why.
+        // Calculate the layout metrics for height/ascent by just asking
+        // the font. I also tried Kitty's approach at one point which is to
+        // use the CoreText layout engine but this led to some glyphs being
+        // set incorrectly.
         const layout_metrics: struct {
             height: f32,
             ascent: f32,
         } = metrics: {
-            const unit = "AQWMH_gyl " ** 100;
-
-            // Setup our string we'll layout. We just stylize a string of
-            // ASCII characters to setup the letters.
-            const string = try macos.foundation.MutableAttributedString.create(unit.len);
-            defer string.release();
-            const rep = try macos.foundation.String.createWithBytes(unit, .utf8, false);
-            defer rep.release();
-            string.replaceString(macos.foundation.Range.init(0, 0), rep);
-            string.setAttribute(
-                macos.foundation.Range.init(0, unit.len),
-                macos.text.StringAttribute.font,
-                ct_font,
-            );
-
-            // Create our framesetter with our string. This is used to
-            // emit "frames" for the layout.
-            const fs = try macos.text.Framesetter.createWithAttributedString(@ptrCast(string));
-            defer fs.release();
-
-            // Create a rectangle to fit all of this and create a frame of it.
-            // The rectangle needs to fit all of our text so we use some
-            // heuristics based on cell_width to calculate it. We are
-            // VERY generous with our rect here because the text must fit.
-            const path_rect = rect: {
-                // The cell width at this point is valid, so let's make it
-                // fit 50 characters wide.
-                const width = cell_width * 50;
-
-                // We are trying to calculate height so we don't know how
-                // high to make our frame. Well-behaved fonts will probably
-                // not have a height greater than 4x the width, so let's just
-                // generously use that metric to ensure we fit the frame.
-                const big_cell_height = cell_width * 4;
-
-                // If we are fitting about ~50 characters per row, we need
-                // unit.len / 50 rows to fit all of our text.
-                const rows = (unit.len / 50) * 2;
-
-                // Our final height is the number of rows times our generous height.
-                const height = rows * big_cell_height;
-
-                break :rect macos.graphics.Rect.init(10, 10, width, height);
-            };
-
-            const path = try macos.graphics.MutablePath.create();
-            path.addRect(null, path_rect);
-            defer path.release();
-            const frame = try fs.createFrame(
-                macos.foundation.Range.init(0, 0),
-                @ptrCast(path),
-                null,
-            );
-            defer frame.release();
-
-            // Use our text layout from earlier to measure the difference
-            // between the lines.
-            var points: [2]macos.graphics.Point = undefined;
-            frame.getLineOrigins(macos.foundation.Range.init(0, 1), points[0..]);
-            frame.getLineOrigins(macos.foundation.Range.init(1, 1), points[1..]);
-
-            const lines = frame.getLines();
-            const line = lines.getValueAtIndex(macos.text.Line, 0);
-
-            // Get the bounds of the line to determine the ascent.
-            const bounds = line.getBoundsWithOptions(.{ .exclude_leading = true });
-            const bounds_ascent = bounds.size.height + bounds.origin.y;
-            const baseline = @floor(bounds_ascent + 0.5);
-
-            // This is an alternate approach to the above to calculate the
-            // baseline by simply using the ascender. Using this approach led
-            // to less accurate results, but I'm leaving it here for reference.
-            // var ascent: f64 = 0;
-            // var descent: f64 = 0;
-            // var leading: f64 = 0;
-            // _ = line.getTypographicBounds(&ascent, &descent, &leading);
-            //std.log.warn("ascent={} descent={} leading={}", .{ ascent, descent, leading });
-
+            const ascent = @round(ct_font.getAscent());
+            const descent = @round(ct_font.getDescent());
+            const leading = @round(ct_font.getLeading());
             break :metrics .{
-                .height = @floatCast(points[0].y - points[1].y),
-                .ascent = @floatCast(baseline),
+                .height = @floatCast(ascent + descent + leading),
+                .ascent = @floatCast(ascent),
             };
         };
 

commit 4bf8a0d1491ad1b31843e610b11dd908de0426dc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 15:48:42 2023 -0700

    font: support skew transform for auto-italics

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index efb1ebab..b4db4617 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -20,6 +20,16 @@ pub const Face = struct {
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
+    /// The matrix applied to a regular font to auto-italicize it.
+    pub const italic_skew = macos.graphics.AffineTransform{
+        .a = 1,
+        .b = 0,
+        .c = 0.267949, // approx. tan(15)
+        .d = 1,
+        .tx = 0,
+        .ty = 0,
+    };
+
     /// Initialize a CoreText-based font from a TTF/TTC in memory.
     pub fn init(lib: font.Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
         _ = lib;
@@ -47,7 +57,7 @@ pub const Face = struct {
         // Create a copy. The copyWithAttributes docs say the size is in points,
         // but we need to scale the points by the DPI and to do that we use our
         // function called "pixels".
-        const ct_font = try base.copyWithAttributes(@floatFromInt(size.pixels()), null);
+        const ct_font = try base.copyWithAttributes(@floatFromInt(size.pixels()), null, null);
         errdefer ct_font.release();
 
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
@@ -69,6 +79,14 @@ pub const Face = struct {
         self.* = undefined;
     }
 
+    /// Return a new face that is the same as this but has a transformation
+    /// matrix applied to italicize it.
+    pub fn italicize(self: *const Face) !Face {
+        const ct_font = try self.font.copyWithAttributes(0.0, &italic_skew, null);
+        defer ct_font.release();
+        return try initFontCopy(ct_font, .{ .points = 0 });
+    }
+
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {

commit 22b81731649bd1aca3e6fd33f215747d29ba1f72
Author: Kevin HovsÃ¤ter <kevin@hovsater.com>
Date:   Tue Aug 8 14:27:34 2023 +0200

    Fix typos

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index b4db4617..990fcb12 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -377,7 +377,7 @@ pub const Face = struct {
         // represent the amount under the baseline. We add this to our real
         // baseline to get the actual value from the bottom (+y is up).
         // The final underline position is +y from the TOP (confusing)
-        // so we have to substract from the cell height.
+        // so we have to subtract from the cell height.
         const underline_position = cell_height -
             (cell_baseline + @ceil(@as(f32, @floatCast(ct_font.getUnderlinePosition())))) +
             1;

commit ea3b957bc7166909fb270f1c9c663f304e36bdbf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 09:29:15 2023 -0700

    quirks: Menlo/Monaco should disable ligatures by default (#331)
    
    * font: disable default font features for Menlo and Monaco
    
    Both of these fonts have a default ligature on "fi" which makes terminal
    rendering super ugly. The easiest thing to do is special-case these
    fonts and disable ligatures. It appears other terminals do the same
    thing.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 990fcb12..e8fe1873 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -87,6 +87,19 @@ pub const Face = struct {
         return try initFontCopy(ct_font, .{ .points = 0 });
     }
 
+    /// Returns the font name. If allocation is required, buf will be used,
+    /// but sometimes allocation isn't required and a static string is
+    /// returned.
+    pub fn name(self: *const Face, buf: []u8) Allocator.Error![]const u8 {
+        const display_name = self.font.copyDisplayName();
+        if (display_name.cstringPtr(.utf8)) |str| return str;
+
+        // "NULL if the internal storage of theString does not allow
+        // this to be returned efficiently." In this case, we need
+        // to allocate.
+        return display_name.cstring(buf, .utf8) orelse error.OutOfMemory;
+    }
+
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
     pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {

commit f4738210e14e2f0c758376b06a4b3107f5594ba1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 25 14:44:16 2023 -0700

    font: determine quirks modes on font face load

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index e8fe1873..99d07445 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -4,6 +4,7 @@ const Allocator = std.mem.Allocator;
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
+const quirks = @import("../../quirks.zig");
 
 const log = std.log.scoped(.font_face);
 
@@ -20,6 +21,9 @@ pub const Face = struct {
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
+    /// Set quirks.disableDefaultFontFeatures
+    quirks_disable_default_font_features: bool = false,
+
     /// The matrix applied to a regular font to auto-italicize it.
     pub const italic_skew = macos.graphics.AffineTransform{
         .a = 1,
@@ -65,12 +69,14 @@ pub const Face = struct {
 
         const traits = ct_font.getSymbolicTraits();
 
-        return Face{
+        var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
             .presentation = if (traits.color_glyphs) .emoji else .text,
             .metrics = try calcMetrics(ct_font),
         };
+        result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
+        return result;
     }
 
     pub fn deinit(self: *Face) void {

commit 9d0729f17cb155f58dea04d4817411dce535e079
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 27 07:56:17 2023 -0700

    font/coretext: ability to set variation axes

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 99d07445..ac14aaef 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -64,11 +64,33 @@ pub const Face = struct {
         const ct_font = try base.copyWithAttributes(@floatFromInt(size.pixels()), null, null);
         errdefer ct_font.release();
 
+        return try initFont(ct_font);
+    }
+
+    /// Initialize a face with a CTFont. This will take ownership over
+    /// the CTFont. This does NOT copy or retain the CTFont.
+    pub fn initFont(ct_font: *macos.text.Font) !Face {
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
         errdefer hb_font.destroy();
 
         const traits = ct_font.getSymbolicTraits();
 
+        // Get variation axes
+        // if (ct_font.copyAttribute(.variation_axes)) |axes| {
+        //     defer axes.release();
+        //     const len = axes.getCount();
+        //     for (0..len) |i| {
+        //         const dict = axes.getValueAtIndex(macos.foundation.Dictionary, i);
+        //         const Key = macos.text.FontVariationAxisKey;
+        //         const name_ = dict.getValue(Key.name.Value(), Key.name.key());
+        //         if (name_) |name_val| {
+        //             var buf: [1024]u8 = undefined;
+        //             const namestr = name_val.cstring(&buf, .utf8) orelse "";
+        //             log.warn("AXES: {s}", .{namestr});
+        //         }
+        //     }
+        // }
+
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
@@ -89,8 +111,8 @@ pub const Face = struct {
     /// matrix applied to italicize it.
     pub fn italicize(self: *const Face) !Face {
         const ct_font = try self.font.copyWithAttributes(0.0, &italic_skew, null);
-        defer ct_font.release();
-        return try initFontCopy(ct_font, .{ .points = 0 });
+        errdefer ct_font.release();
+        return try initFont(ct_font);
     }
 
     /// Returns the font name. If allocation is required, buf will be used,
@@ -115,6 +137,31 @@ pub const Face = struct {
         self.* = face;
     }
 
+    /// Set the variation axes for this font. This will modify this font
+    /// in-place.
+    pub fn setVariations(
+        self: *Face,
+        vs: []const font.face.Variation,
+    ) !void {
+        // Create a new font descriptor with all the variations set.
+        var desc = self.font.copyDescriptor();
+        defer desc.release();
+        for (vs) |v| {
+            const id = try macos.foundation.Number.create(.int, @ptrCast(&v.id));
+            defer id.release();
+            const next = try desc.createCopyWithVariation(id, v.value);
+            desc.release();
+            desc = next;
+        }
+
+        // Initialize a font based on these attributes.
+        const ct_font = try self.font.copyWithAttributes(0, null, desc);
+        errdefer ct_font.release();
+        const face = try initFont(ct_font);
+        self.deinit();
+        self.* = face;
+    }
+
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
     pub fn glyphIndex(self: Face, cp: u32) ?u32 {
@@ -492,3 +539,55 @@ test "in-memory" {
         _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
+
+test "variable" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontVariable;
+
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.text, face.presentation);
+
+    // Generate all visible ASCII
+    var i: u8 = 32;
+    while (i < 127) : (i += 1) {
+        try testing.expect(face.glyphIndex(i) != null);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+    }
+}
+
+test "variable set variation" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontVariable;
+
+    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    defer atlas.deinit(alloc);
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.text, face.presentation);
+
+    try face.setVariations(&.{
+        .{ .id = font.face.Variation.Id.init("wght"), .value = 400 },
+    });
+
+    // Generate all visible ASCII
+    var i: u8 = 32;
+    while (i < 127) : (i += 1) {
+        try testing.expect(face.glyphIndex(i) != null);
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+    }
+}

commit 16808f2b350d02c966f354b9477175e72959e8ea
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 27 10:54:31 2023 -0700

    font/coretext: log the variation axes in debug mode

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index ac14aaef..7b738a32 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1,4 +1,5 @@
 const std = @import("std");
+const builtin = @import("builtin");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const macos = @import("macos");
@@ -75,22 +76,6 @@ pub const Face = struct {
 
         const traits = ct_font.getSymbolicTraits();
 
-        // Get variation axes
-        // if (ct_font.copyAttribute(.variation_axes)) |axes| {
-        //     defer axes.release();
-        //     const len = axes.getCount();
-        //     for (0..len) |i| {
-        //         const dict = axes.getValueAtIndex(macos.foundation.Dictionary, i);
-        //         const Key = macos.text.FontVariationAxisKey;
-        //         const name_ = dict.getValue(Key.name.Value(), Key.name.key());
-        //         if (name_) |name_val| {
-        //             var buf: [1024]u8 = undefined;
-        //             const namestr = name_val.cstring(&buf, .utf8) orelse "";
-        //             log.warn("AXES: {s}", .{namestr});
-        //         }
-        //     }
-        // }
-
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
@@ -98,6 +83,52 @@ pub const Face = struct {
             .metrics = try calcMetrics(ct_font),
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
+
+        // In debug mode, we output information about available variation axes,
+        // if they exist.
+        if (comptime builtin.mode == .Debug) {
+            if (ct_font.copyAttribute(.variation_axes)) |axes| {
+                defer axes.release();
+
+                var buf: [1024]u8 = undefined;
+                log.debug("variation axes font={s}", .{try result.name(&buf)});
+
+                const len = axes.getCount();
+                for (0..len) |i| {
+                    const dict = axes.getValueAtIndex(macos.foundation.Dictionary, i);
+                    const Key = macos.text.FontVariationAxisKey;
+                    const cf_name = dict.getValue(Key.name.Value(), Key.name.key()).?;
+                    const cf_id = dict.getValue(Key.identifier.Value(), Key.identifier.key()).?;
+                    const cf_min = dict.getValue(Key.minimum_value.Value(), Key.minimum_value.key()).?;
+                    const cf_max = dict.getValue(Key.maximum_value.Value(), Key.maximum_value.key()).?;
+                    const cf_def = dict.getValue(Key.default_value.Value(), Key.default_value.key()).?;
+
+                    const namestr = cf_name.cstring(&buf, .utf8) orelse "";
+
+                    var id_raw: c_int = 0;
+                    _ = cf_id.getValue(.int, &id_raw);
+                    const id: font.face.Variation.Id = @bitCast(id_raw);
+
+                    var min: f64 = 0;
+                    _ = cf_min.getValue(.double, &min);
+
+                    var max: f64 = 0;
+                    _ = cf_max.getValue(.double, &max);
+
+                    var def: f64 = 0;
+                    _ = cf_def.getValue(.double, &def);
+
+                    log.debug("variation axis: name={s} id={s} min={} max={} def={}", .{
+                        namestr,
+                        id.str(),
+                        min,
+                        max,
+                        def,
+                    });
+                }
+            }
+        }
+
         return result;
     }
 

commit 54b9b45a7fa61a47c6ae1480a95adb7d4755efc8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 17:23:57 2023 -0700

    font: rework font init to use a struct with modifiersets everywhere

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7b738a32..fbfda7d9 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -36,7 +36,7 @@ pub const Face = struct {
     };
 
     /// Initialize a CoreText-based font from a TTF/TTC in memory.
-    pub fn init(lib: font.Library, source: [:0]const u8, size: font.face.DesiredSize) !Face {
+    pub fn init(lib: font.Library, source: [:0]const u8, opts: font.face.Options) !Face {
         _ = lib;
 
         const data = try macos.foundation.Data.createWithBytesNoCopy(source);
@@ -51,18 +51,22 @@ pub const Face = struct {
         const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
         defer ct_font.release();
 
-        return try initFontCopy(ct_font, size);
+        return try initFontCopy(ct_font, opts);
     }
 
     /// Initialize a CoreText-based face from another initialized font face
     /// but with a new size. This is often how CoreText fonts are initialized
     /// because the font is loaded at a default size during discovery, and then
     /// adjusted to the final size for final load.
-    pub fn initFontCopy(base: *macos.text.Font, size: font.face.DesiredSize) !Face {
+    pub fn initFontCopy(base: *macos.text.Font, opts: font.face.Options) !Face {
         // Create a copy. The copyWithAttributes docs say the size is in points,
         // but we need to scale the points by the DPI and to do that we use our
         // function called "pixels".
-        const ct_font = try base.copyWithAttributes(@floatFromInt(size.pixels()), null, null);
+        const ct_font = try base.copyWithAttributes(
+            @floatFromInt(opts.size.pixels()),
+            null,
+            null,
+        );
         errdefer ct_font.release();
 
         return try initFont(ct_font);
@@ -161,9 +165,9 @@ pub const Face = struct {
 
     /// Resize the font in-place. If this succeeds, the caller is responsible
     /// for clearing any glyph caches, font atlas data, etc.
-    pub fn setSize(self: *Face, size: font.face.DesiredSize) !void {
+    pub fn setSize(self: *Face, opts: font.face.Options) !void {
         // We just create a copy and replace ourself
-        const face = try initFontCopy(self.font, size);
+        const face = try initFontCopy(self.font, opts);
         self.deinit();
         self.* = face;
     }
@@ -514,7 +518,7 @@ test {
     const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
     defer ct_font.release();
 
-    var face = try Face.initFontCopy(ct_font, .{ .points = 12 });
+    var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
@@ -537,7 +541,7 @@ test "emoji" {
     const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
     defer ct_font.release();
 
-    var face = try Face.initFontCopy(ct_font, .{ .points = 18 });
+    var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 18 } });
     defer face.deinit();
 
     // Presentation
@@ -558,7 +562,7 @@ test "in-memory" {
     var lib = try font.Library.init();
     defer lib.deinit();
 
-    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
@@ -582,7 +586,7 @@ test "variable" {
     var lib = try font.Library.init();
     defer lib.deinit();
 
-    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);
@@ -606,7 +610,7 @@ test "variable set variation" {
     var lib = try font.Library.init();
     defer lib.deinit();
 
-    var face = try Face.init(lib, testFont, .{ .points = 12 });
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
     try testing.expectEqual(font.Presentation.text, face.presentation);

commit 2563a195a15ec61fa50b797fd054f64c47b60515
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 4 21:42:03 2023 -0700

    font: wire up all the metric modifiers

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index fbfda7d9..803cb46b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -69,22 +69,27 @@ pub const Face = struct {
         );
         errdefer ct_font.release();
 
-        return try initFont(ct_font);
+        return try initFont(ct_font, opts);
     }
 
     /// Initialize a face with a CTFont. This will take ownership over
     /// the CTFont. This does NOT copy or retain the CTFont.
-    pub fn initFont(ct_font: *macos.text.Font) !Face {
+    pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
         errdefer hb_font.destroy();
 
         const traits = ct_font.getSymbolicTraits();
+        const metrics = metrics: {
+            var metrics = try calcMetrics(ct_font);
+            if (opts.metric_modifiers) |v| metrics.apply(v.*);
+            break :metrics metrics;
+        };
 
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
             .presentation = if (traits.color_glyphs) .emoji else .text,
-            .metrics = try calcMetrics(ct_font),
+            .metrics = metrics,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
@@ -144,10 +149,10 @@ pub const Face = struct {
 
     /// Return a new face that is the same as this but has a transformation
     /// matrix applied to italicize it.
-    pub fn italicize(self: *const Face) !Face {
+    pub fn italicize(self: *const Face, opts: font.face.Options) !Face {
         const ct_font = try self.font.copyWithAttributes(0.0, &italic_skew, null);
         errdefer ct_font.release();
-        return try initFont(ct_font);
+        return try initFont(ct_font, opts);
     }
 
     /// Returns the font name. If allocation is required, buf will be used,

commit 7a0b8a6781d7b0ce941b03a9b45b9b8f71f055e0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 5 08:08:04 2023 -0700

    font: fix failing macos tests

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 803cb46b..e4706b67 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -182,6 +182,7 @@ pub const Face = struct {
     pub fn setVariations(
         self: *Face,
         vs: []const font.face.Variation,
+        opts: font.face.Options,
     ) !void {
         // Create a new font descriptor with all the variations set.
         var desc = self.font.copyDescriptor();
@@ -197,7 +198,7 @@ pub const Face = struct {
         // Initialize a font based on these attributes.
         const ct_font = try self.font.copyWithAttributes(0, null, desc);
         errdefer ct_font.release();
-        const face = try initFont(ct_font);
+        const face = try initFont(ct_font, opts);
         self.deinit();
         self.* = face;
     }
@@ -622,7 +623,7 @@ test "variable set variation" {
 
     try face.setVariations(&.{
         .{ .id = font.face.Variation.Id.init("wght"), .value = 400 },
-    });
+    }, .{ .size = .{ .points = 12 } });
 
     // Generate all visible ASCII
     var i: u8 = 32;

commit 947ebc0697bb7ffc8fdfa592a042bdfcb64301fe
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 10 21:23:48 2023 -0800

    font/coretext: split typographic leading equally when calculating cell height
    
    This maybe is a robust way to get Monaspace fonts working.
    
    Previously, we used leading as part of the calculation in cell height. I
    don't remember why. It appears most popular monospace fonts (Fira Code,
    Berkeley Mono, JetBrains Mono, Monaco are the few I tested) have a value
    of 0 for leading, so this has no effect. But some fonts like Monaspace
    have a non-zero (positive) value, resulting in overly large cell
    heights.
    
    The issue is that we simply add leading to the height, without modifying
    ascent. Normally this is what you want (normal typesetting) but for
    terminals, we're trying to set text centered vertically in equally
    spaced grid cells. For this, we want to split the leading between the
    top and bottom.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index e4706b67..969207e9 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -466,10 +466,15 @@ pub const Face = struct {
         } = metrics: {
             const ascent = @round(ct_font.getAscent());
             const descent = @round(ct_font.getDescent());
-            const leading = @round(ct_font.getLeading());
+
+            // Leading is the value between lines at the TOP of a line.
+            // Because we are rendering a fixed size terminal grid, we
+            // want the leading to be split equally between the top and bottom.
+            const leading = ct_font.getLeading();
+
             break :metrics .{
-                .height = @floatCast(ascent + descent + leading),
-                .ascent = @floatCast(ascent),
+                .height = @floatCast(@round(ascent + descent + leading)),
+                .ascent = @floatCast(@round(ascent + (leading / 2))),
             };
         };
 

commit 44a48f62f1f3888d9f91f5592effdfeed9041f9a
Author: Krzysztof Wolicki <der.teufel.mail@gmail.com>
Date:   Fri Nov 17 15:40:59 2023 +0100

    change unmodified `var`s to `const`s in anticipation of zig changes

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 969207e9..eb83354b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -301,7 +301,7 @@ pub const Face = struct {
         // usually stabilizes pretty quickly and is very infrequent so I think
         // the allocation overhead is acceptable compared to the cost of
         // caching it forever or having to deal with a cache lifetime.
-        var buf = try alloc.alloc(u8, width * height * color.depth);
+        const buf = try alloc.alloc(u8, width * height * color.depth);
         defer alloc.free(buf);
         @memset(buf, 0);
 

commit 7f4088174718781727031d9b4d55f9c8fdd90e26
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Dec 2 09:39:45 2023 -0800

    font: faces use primary grid metrics to better line up glyphs
    
    Fixes #895
    
    Every loaded font face calculates metrics for itself. One of the
    important metrics is the baseline to "sit" the glyph on top of. Prior to
    this commit, each rasterized glyph would sit on its own calculated
    baseline. However, this leads to off-center rendering when the font
    being rasterized isn't the font that defines the terminal grid.
    
    This commit passes in the font metrics for the font defining the
    terminal grid to all font rasterization requests. This can then be used
    by non-primary fonts to sit the glyph according to the primary grid.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index eb83354b..0ce09d2c 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -386,7 +386,9 @@ pub const Face = struct {
         const offset_y: i32 = offset_y: {
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
-            const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_baseline);
+            //const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_baseline);
+            const metrics = opts.grid_metrics orelse self.metrics;
+            const baseline_from_bottom: f64 = @floatFromInt(metrics.cell_baseline);
 
             // Next we offset our baseline by the bearing in the font. We
             // ADD here because CoreText y is UP.

commit 3fdb6a496de60a198560dc0489ec8e64c57c6b64
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Dec 10 17:08:20 2023 -0800

    font/coretext: calculate advance_x properly

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 0ce09d2c..188a3bce 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -397,6 +397,10 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
+        // Get our advance
+        var advances: [glyphs.len]macos.graphics.Size = undefined;
+        _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
+
         // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
         //     rect,
         //     width,
@@ -416,10 +420,7 @@ pub const Face = struct {
             .offset_y = offset_y,
             .atlas_x = region.x,
             .atlas_y = region.y,
-
-            // This is not used, so we don't bother calculating it. If we
-            // ever need it, we can calculate it using getAdvancesForGlyph.
-            .advance_x = 0,
+            .advance_x = @floatCast(advances[0].width),
         };
     }
 

commit 489ed57e2f924e6993158427ad9317f21eede9eb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 11 21:41:13 2023 -0800

    font/harfbuzz: track x/y offsets

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 188a3bce..a57216df 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -77,6 +77,7 @@ pub const Face = struct {
     pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
         var hb_font = try harfbuzz.coretext.createFont(ct_font);
         errdefer hb_font.destroy();
+        hb_font.setScale(opts.size.pixels(), opts.size.pixels());
 
         const traits = ct_font.getSymbolicTraits();
         const metrics = metrics: {

commit 6403ef119885bcbf392f6d3204f72177a2ab71a9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Dec 12 19:58:57 2023 -0800

    font/coretext: ceil the cell height and ascent metrics
    
    Fixes #1068

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index a57216df..66c7ca97 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -468,17 +468,20 @@ pub const Face = struct {
             height: f32,
             ascent: f32,
         } = metrics: {
-            const ascent = @round(ct_font.getAscent());
-            const descent = @round(ct_font.getDescent());
+            const ascent = ct_font.getAscent();
+            const descent = ct_font.getDescent();
 
             // Leading is the value between lines at the TOP of a line.
             // Because we are rendering a fixed size terminal grid, we
             // want the leading to be split equally between the top and bottom.
             const leading = ct_font.getLeading();
 
+            // We ceil the metrics below because we don't want to cut off any
+            // potential used pixels. This tends to only make a one pixel
+            // difference but at small font sizes this can be noticeable.
             break :metrics .{
-                .height = @floatCast(@round(ascent + descent + leading)),
-                .ascent = @floatCast(@round(ascent + (leading / 2))),
+                .height = @floatCast(@ceil(ascent + descent + leading)),
+                .ascent = @floatCast(@ceil(ascent + (leading / 2))),
             };
         };
 

commit 22d631942c30dae1f3138ea08828325135c03d4f
Author: Kyaw <mail@kyswtn.com>
Date:   Fri Dec 15 02:26:47 2023 +0630

    font/coretext: use `CTFontCopyFamilyName`
    
    Use `CTFontCopyFamilyName` instead of `CTFontCopyDisplayName` to get
    the font name to match the behavior of how it's done on freetype
    backend.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 66c7ca97..2f6bd6d1 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -160,13 +160,13 @@ pub const Face = struct {
     /// but sometimes allocation isn't required and a static string is
     /// returned.
     pub fn name(self: *const Face, buf: []u8) Allocator.Error![]const u8 {
-        const display_name = self.font.copyDisplayName();
-        if (display_name.cstringPtr(.utf8)) |str| return str;
+        const family_name = self.font.copyFamilyName();
+        if (family_name.cstringPtr(.utf8)) |str| return str;
 
         // "NULL if the internal storage of theString does not allow
         // this to be returned efficiently." In this case, we need
         // to allocate.
-        return display_name.cstring(buf, .utf8) orelse error.OutOfMemory;
+        return family_name.cstring(buf, .utf8) orelse error.OutOfMemory;
     }
 
     /// Resize the font in-place. If this succeeds, the caller is responsible
@@ -549,6 +549,26 @@ test {
     }
 }
 
+test "name" {
+    const testing = std.testing;
+
+    const name = try macos.foundation.String.createWithBytes("Menlo", .utf8, false);
+    defer name.release();
+    const desc = try macos.text.FontDescriptor.createWithNameAndSize(name, 12);
+    defer desc.release();
+    const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
+    defer ct_font.release();
+
+    var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 12 } });
+    defer face.deinit();
+
+    try testing.expectEqual(font.Presentation.text, face.presentation);
+
+    var buf: [1024]u8 = undefined;
+    const font_name = try face.name(&buf);
+    try testing.expect(std.mem.eql(u8, font_name, "Menlo"));
+}
+
 test "emoji" {
     const testing = std.testing;
 

commit 481529393baee295b929f99c88fb83e58346102c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Dec 16 20:56:57 2023 -0800

    font: center text when adjust-cell-width is used
    
    Fixes #1086

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 2f6bd6d1..27455782 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -384,11 +384,11 @@ pub const Face = struct {
         };
         atlas.set(region, buf);
 
+        const metrics = opts.grid_metrics orelse self.metrics;
         const offset_y: i32 = offset_y: {
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
             //const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_baseline);
-            const metrics = opts.grid_metrics orelse self.metrics;
             const baseline_from_bottom: f64 = @floatFromInt(metrics.cell_baseline);
 
             // Next we offset our baseline by the bearing in the font. We
@@ -398,6 +398,21 @@ pub const Face = struct {
             break :offset_y @intFromFloat(@ceil(baseline_with_offset));
         };
 
+        const offset_x: i32 = offset_x: {
+            var result: i32 = @intFromFloat(render_x);
+
+            // If our cell was resized to be wider then we center our
+            // glyph in the cell.
+            if (metrics.original_cell_width) |original_width| {
+                if (original_width < metrics.cell_width) {
+                    const diff = (metrics.cell_width - original_width) / 2;
+                    result += @intCast(diff);
+                }
+            }
+
+            break :offset_x result;
+        };
+
         // Get our advance
         var advances: [glyphs.len]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
@@ -417,7 +432,7 @@ pub const Face = struct {
         return .{
             .width = width,
             .height = height,
-            .offset_x = @intFromFloat(render_x),
+            .offset_x = offset_x,
             .offset_y = offset_y,
             .atlas_x = region.x,
             .atlas_y = region.y,

commit e41e45e1ad85c9a96ae403447f2c48017f61dfeb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Apr 4 12:18:28 2024 -0700

    font/coretext: face doesn't need harfbuzz font if we're not using it

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 27455782..4e82432d 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -13,8 +13,9 @@ pub const Face = struct {
     /// Our font face
     font: *macos.text.Font,
 
-    /// Harfbuzz font corresponding to this face.
-    hb_font: harfbuzz.Font,
+    /// Harfbuzz font corresponding to this face. We only use this
+    /// if we're using Harfbuzz.
+    hb_font: if (harfbuzz_shaper) harfbuzz.Font else void,
 
     /// The presentation for this font.
     presentation: font.Presentation,
@@ -25,6 +26,10 @@ pub const Face = struct {
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
+    /// True if our build is using Harfbuzz. If we're not, we can avoid
+    /// some Harfbuzz-specific code paths.
+    const harfbuzz_shaper = font.Shaper == font.shape.harfbuzz.Shaper;
+
     /// The matrix applied to a regular font to auto-italicize it.
     pub const italic_skew = macos.graphics.AffineTransform{
         .a = 1,
@@ -75,10 +80,6 @@ pub const Face = struct {
     /// Initialize a face with a CTFont. This will take ownership over
     /// the CTFont. This does NOT copy or retain the CTFont.
     pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
-        var hb_font = try harfbuzz.coretext.createFont(ct_font);
-        errdefer hb_font.destroy();
-        hb_font.setScale(opts.size.pixels(), opts.size.pixels());
-
         const traits = ct_font.getSymbolicTraits();
         const metrics = metrics: {
             var metrics = try calcMetrics(ct_font);
@@ -86,6 +87,13 @@ pub const Face = struct {
             break :metrics metrics;
         };
 
+        var hb_font = if (comptime harfbuzz_shaper) font: {
+            var hb_font = try harfbuzz.coretext.createFont(ct_font);
+            hb_font.setScale(opts.size.pixels(), opts.size.pixels());
+            break :font hb_font;
+        } else {};
+        errdefer if (comptime harfbuzz_shaper) hb_font.destroy();
+
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
@@ -144,7 +152,7 @@ pub const Face = struct {
 
     pub fn deinit(self: *Face) void {
         self.font.release();
-        self.hb_font.destroy();
+        if (comptime harfbuzz_shaper) self.hb_font.destroy();
         self.* = undefined;
     }
 

commit fd4d2313d08663ce787f306e87bb80e9d4df60af
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Apr 4 12:22:35 2024 -0700

    build: do not build/link harfbuzz on macOS

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 4e82432d..e3177e88 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -28,7 +28,7 @@ pub const Face = struct {
 
     /// True if our build is using Harfbuzz. If we're not, we can avoid
     /// some Harfbuzz-specific code paths.
-    const harfbuzz_shaper = font.Shaper == font.shape.harfbuzz.Shaper;
+    const harfbuzz_shaper = font.options.backend.hasHarfbuzz();
 
     /// The matrix applied to a regular font to auto-italicize it.
     pub const italic_skew = macos.graphics.AffineTransform{

commit abd782a7aa45a06221b921746a240b32fe34fd54
Author: Gordon Cassie <gordoncassie@gmail.com>
Date:   Wed Apr 24 21:07:50 2024 -0700

    Fix typo.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index e3177e88..7e305f96 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -242,7 +242,7 @@ pub const Face = struct {
         var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
 
         // Get the bounding rect for rendering this glyph.
-        const rect = self.font.getBoundingRectForGlyphs(.horizontal, &glyphs, null);
+        const rect = self.font.getBoundingRectsForGlyphs(.horizontal, &glyphs, null);
 
         // The x/y that we render the glyph at. The Y value has to be flipped
         // because our coordinates in 3D space are (0, 0) bottom left with

commit b76f5976ee29aa0cf29b632b61be8db861c2f23a
Author: Gordon Cassie <gordoncassie@gmail.com>
Date:   Thu Apr 25 15:38:21 2024 -0700

    Remove unnecessary allocation.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7e305f96..affe7878 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -396,7 +396,6 @@ pub const Face = struct {
         const offset_y: i32 = offset_y: {
             // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
             // We need to calculate our baseline from the bottom of a cell.
-            //const baseline_from_bottom: f64 = @floatFromInt(self.metrics.cell_baseline);
             const baseline_from_bottom: f64 = @floatFromInt(metrics.cell_baseline);
 
             // Next we offset our baseline by the bearing in the font. We
@@ -425,18 +424,6 @@ pub const Face = struct {
         var advances: [glyphs.len]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
 
-        // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
-        //     rect,
-        //     width,
-        //     height,
-        //     render_x,
-        //     render_y,
-        //     offset_y,
-        //     glyph_ascent,
-        //     self.metrics.cell_height,
-        //     self.metrics.cell_baseline,
-        // });
-
         return .{
             .width = width,
             .height = height,
@@ -538,9 +525,6 @@ pub const Face = struct {
             .strikethrough_thickness = @intFromFloat(strikethrough_thickness),
         };
 
-        // std.log.warn("font size size={d}", .{ct_font.getSize()});
-        // std.log.warn("font metrics={}", .{result});
-
         return result;
     }
 };

commit e77f9962a82947957e280e50e065ba5f45b8519f
Author: Gordon Cassie <gordoncassie@gmail.com>
Date:   Thu Apr 25 19:27:51 2024 -0700

    revert on comment removal

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index affe7878..3178a813 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -424,6 +424,18 @@ pub const Face = struct {
         var advances: [glyphs.len]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
 
+        // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
+        //     rect,
+        //     width,
+        //     height,
+        //     render_x,
+        //     render_y,
+        //     offset_y,
+        //     glyph_ascent,
+        //     self.metrics.cell_height,
+        //     self.metrics.cell_baseline,
+        // });
+
         return .{
             .width = width,
             .height = height,
@@ -525,6 +537,9 @@ pub const Face = struct {
             .strikethrough_thickness = @intFromFloat(strikethrough_thickness),
         };
 
+        // std.log.warn("font size size={d}", .{ct_font.getSize()});
+        // std.log.warn("font metrics={}", .{result});
+
         return result;
     }
 };

commit bc99082242f3fdf70188b0fc63adf2038e394b5c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat May 25 15:16:31 2024 -0700

    font/coretext: adjust strikethrough position for fonts with leading
    
    Fixes #1795
    
    This only affected CoreText. When testing with Freetype the
    strikethroughs looked correct for fonts with and without leading
    metrics.
    
    This commit adjusts our strikethrough position for fonts that have a
    leading metric set to better center it. Previously, we centered the
    position _including_ the leading value. The leading value is blank, so
    we must center it excluding that value.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 3178a813..570ec7ca 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -489,6 +489,7 @@ pub const Face = struct {
         const layout_metrics: struct {
             height: f32,
             ascent: f32,
+            leading: f32,
         } = metrics: {
             const ascent = ct_font.getAscent();
             const descent = ct_font.getDescent();
@@ -504,6 +505,7 @@ pub const Face = struct {
             break :metrics .{
                 .height = @floatCast(@ceil(ascent + descent + leading)),
                 .ascent = @floatCast(@ceil(ascent + (leading / 2))),
+                .leading = @floatCast(leading),
             };
         };
 
@@ -511,7 +513,20 @@ pub const Face = struct {
         const cell_height = @ceil(layout_metrics.height);
         const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
-        const strikethrough_position = @ceil(layout_metrics.height - (layout_metrics.ascent * 0.6));
+        const strikethrough_position = strikethrough_position: {
+            // This is the height above baseline consumed by text. To get
+            // this, its cell height minus baseline. We must also take into
+            // account that our cell height splits the leading between two
+            // rows so we subtract leading space (blank space).
+            const above = cell_height - cell_baseline - (layout_metrics.leading / 2);
+
+            // We want to position the strikethrough at 65% of the height.
+            // This generally gives a nice visual appearance. The number 65%
+            // is somewhat arbitrary but is a common value across terminals.
+            const pos = above * 0.65;
+
+            break :strikethrough_position @ceil(pos);
+        };
         const strikethrough_thickness = underline_thickness;
 
         // Underline position reported is usually something like "-1" to

commit e56acef7754b733a203f8b20567f033b9413757e
Author: Peter Cardenas <16930781+PeterCardenas@users.noreply.github.com>
Date:   Sat May 25 18:06:11 2024 -0700

    ðŸ§¹ make strikethrough calculation slightly clearer
    
    followup to https://github.com/mitchellh/ghostty/pull/1796
    the sources of the strikethrough calculation are made more explicit
    here: the ascent and the subtraction of the leading

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 570ec7ca..8b98fc08 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -514,16 +514,15 @@ pub const Face = struct {
         const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
         const strikethrough_position = strikethrough_position: {
-            // This is the height above baseline consumed by text. To get
-            // this, its cell height minus baseline. We must also take into
-            // account that our cell height splits the leading between two
+            // This is the height above baseline consumed by text. We must take
+            // into account that our cell height splits the leading between two
             // rows so we subtract leading space (blank space).
-            const above = cell_height - cell_baseline - (layout_metrics.leading / 2);
+            const text_height_above_baseline = layout_metrics.ascent - (layout_metrics.leading / 2);
 
             // We want to position the strikethrough at 65% of the height.
             // This generally gives a nice visual appearance. The number 65%
             // is somewhat arbitrary but is a common value across terminals.
-            const pos = above * 0.65;
+            const pos = text_height_above_baseline * 0.65;
 
             break :strikethrough_position @ceil(pos);
         };

commit e427312282a70211207ea59ed6700b4a053daf83
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun May 26 09:28:16 2024 -0700

    modify var name

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 8b98fc08..c15c6823 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -517,12 +517,12 @@ pub const Face = struct {
             // This is the height above baseline consumed by text. We must take
             // into account that our cell height splits the leading between two
             // rows so we subtract leading space (blank space).
-            const text_height_above_baseline = layout_metrics.ascent - (layout_metrics.leading / 2);
+            const above_baseline = layout_metrics.ascent - (layout_metrics.leading / 2);
 
             // We want to position the strikethrough at 65% of the height.
             // This generally gives a nice visual appearance. The number 65%
             // is somewhat arbitrary but is a common value across terminals.
-            const pos = text_height_above_baseline * 0.65;
+            const pos = above_baseline * 0.65;
 
             break :strikethrough_position @ceil(pos);
         };

commit 9f4d4d3c61a83b4e6443c4fe9c9a581f1de17868
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun May 26 10:17:20 2024 -0700

    font: treated fonts with mixed color/non-color glyphs as text
    
    Related to #1768 but doesn't fix it properly.
    
    This is a temporary hack to avoid some issues with fonts that have mixed
    color/non-color glyphs. If there are mixed presentations and the font
    does not have emoji codepoints, then we assume it is text. This fixes
    the typical scenarios.
    
    This is not a long term solution. A proper long term solution is to
    detect this scenario and on a per-glyph basis handle colorization (or
    the lack thereof) correctly. It looks like to do this we'll have to
    parse some font tables which is considerably more work so I wanted to do
    this first.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index c15c6823..72c0a6d9 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -102,6 +102,20 @@ pub const Face = struct {
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
+        // If our presentation is emoji, we also check for the presence of
+        // emoji codepoints. This forces fonts with colorized glyphs that aren't
+        // emoji font to be treated as text. Long term, this isn't what we want
+        // but this fixes some bugs in the short term. See:
+        // https://github.com/mitchellh/ghostty/issues/1768
+        //
+        // Longer term, we'd like to detect mixed color/non-color fonts and
+        // handle them correctly by rendering the color glyphs as color and the
+        // non-color glyphs as text.
+        if (result.presentation == .emoji and result.glyphIndex('ðŸ¥¸') == null) {
+            log.warn("font has colorized glyphs but isn't emoji, treating as text", .{});
+            result.presentation = .text;
+        }
+
         // In debug mode, we output information about available variation axes,
         // if they exist.
         if (comptime builtin.mode == .Debug) {
@@ -700,3 +714,16 @@ test "variable set variation" {
         _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
+
+test "mixed color/non-color font treated as text" {
+    const testing = std.testing;
+    const testFont = @import("../test.zig").fontJuliaMono;
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    defer face.deinit();
+
+    try testing.expect(face.presentation == .text);
+}

commit 1a7cde9e3e61826cc863848d697079b8927aada0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon May 27 20:23:10 2024 -0700

    font/coretext: can read font tables

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 72c0a6d9..fdc063b1 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -570,6 +570,21 @@ pub const Face = struct {
 
         return result;
     }
+
+    /// Copy the font table data for the given tag.
+    pub fn copyTable(self: Face, alloc: Allocator, tag: *const [4]u8) !?[]u8 {
+        const data = self.font.copyTable(macos.text.FontTableTag.init(tag)) orelse
+            return null;
+        defer data.release();
+
+        const buf = try alloc.alloc(u8, data.getLength());
+        errdefer alloc.free(buf);
+
+        const ptr = data.getPointer();
+        @memcpy(buf, ptr[0..buf.len]);
+
+        return buf;
+    }
 };
 
 test {
@@ -727,3 +742,20 @@ test "mixed color/non-color font treated as text" {
 
     try testing.expect(face.presentation == .text);
 }
+
+test "svg font table" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("../test.zig").fontJuliaMono;
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    defer face.deinit();
+
+    const table = (try face.copyTable(alloc, "SVG ")).?;
+    defer alloc.free(table);
+
+    try testing.expect(table.len > 0);
+}

commit d22c645a0210a7392b3ba7086a412f1d609d6d83
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 13:04:55 2024 -0700

    font/coretext: determine glyph colorization

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index fdc063b1..9d2477b6 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -5,7 +5,9 @@ const Allocator = std.mem.Allocator;
 const macos = @import("macos");
 const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
+const opentype = @import("../opentype.zig");
 const quirks = @import("../../quirks.zig");
+const GlyphIndex = font.face.GlyphIndex;
 
 const log = std.log.scoped(.font_face);
 
@@ -26,6 +28,12 @@ pub const Face = struct {
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
+    /// If the face can possibly be colored, then this is the state
+    /// used to check for color information. This is null if the font
+    /// can't possibly be colored (i.e. doesn't have SVG, sbix, etc
+    /// tables).
+    color: ?ColorState = null,
+
     /// True if our build is using Harfbuzz. If we're not, we can avoid
     /// some Harfbuzz-specific code paths.
     const harfbuzz_shaper = font.options.backend.hasHarfbuzz();
@@ -94,11 +102,18 @@ pub const Face = struct {
         } else {};
         errdefer if (comptime harfbuzz_shaper) hb_font.destroy();
 
+        const color: ?ColorState = if (traits.color_glyphs)
+            try ColorState.init(ct_font)
+        else
+            null;
+        errdefer if (color) |v| v.deinit();
+
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
             .presentation = if (traits.color_glyphs) .emoji else .text,
             .metrics = metrics,
+            .color = color,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
@@ -167,6 +182,7 @@ pub const Face = struct {
     pub fn deinit(self: *Face) void {
         self.font.release();
         if (comptime harfbuzz_shaper) self.hb_font.destroy();
+        if (self.color) |v| v.deinit();
         self.* = undefined;
     }
 
@@ -228,7 +244,7 @@ pub const Face = struct {
 
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
-    pub fn glyphIndex(self: Face, cp: u32) ?u32 {
+    pub fn glyphIndex(self: Face, cp: u32) ?GlyphIndex {
         // Turn UTF-32 into UTF-16 for CT API
         var unichars: [2]u16 = undefined;
         const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
@@ -243,7 +259,13 @@ pub const Face = struct {
         // to decode down into exactly one glyph ID.
         if (pair) assert(glyphs[1] == 0);
 
-        return @intCast(glyphs[0]);
+        // If we have colorization information, then check if this
+        // glyph is colorized.
+
+        return .{
+            .index = @intCast(glyphs[0]),
+            .color = if (self.color) |v| v.isColored(glyphs[0]) else false,
+        };
     }
 
     pub fn renderGlyph(
@@ -587,6 +609,69 @@ pub const Face = struct {
     }
 };
 
+const ColorState = struct {
+    /// True if there is an sbix font table. For now, the mere presence
+    /// of an sbix font table causes us to assume the glyph is colored.
+    /// We can improve this later.
+    sbix: bool,
+
+    /// The SVG font table data (if any), which we can use to determine
+    /// if a glyph is present in the SVG table.
+    svg: ?opentype.SVG,
+    svg_data: ?*macos.foundation.Data,
+
+    pub fn init(f: *macos.text.Font) !ColorState {
+        // sbix is true if the table exists in the font data at all.
+        // In the future we probably want to actually parse it and
+        // check for glyphs.
+        const sbix: bool = sbix: {
+            const tag = macos.text.FontTableTag.init("sbix");
+            const data = f.copyTable(tag) orelse break :sbix false;
+            data.release();
+            break :sbix data.getLength() > 0;
+        };
+
+        // Read the SVG table out of the font data.
+        const svg: ?struct {
+            svg: opentype.SVG,
+            data: *macos.foundation.Data,
+        } = svg: {
+            const tag = macos.text.FontTableTag.init("SVG ");
+            const data = f.copyTable(tag) orelse break :svg null;
+            errdefer data.release();
+            const ptr = data.getPointer();
+            const len = data.getLength();
+            break :svg .{
+                .svg = try opentype.SVG.init(ptr[0..len]),
+                .data = data,
+            };
+        };
+
+        return .{
+            .sbix = sbix,
+            .svg = if (svg) |v| v.svg else null,
+            .svg_data = if (svg) |v| v.data else null,
+        };
+    }
+
+    pub fn deinit(self: *const ColorState) void {
+        if (self.svg_data) |v| v.release();
+    }
+
+    /// Returns true if the given glyph ID is colored.
+    pub fn isColored(self: *const ColorState, glyph_id: u16) bool {
+        // sbix is always true for now
+        if (self.sbix) return true;
+
+        // if we have svg data, check it
+        if (self.svg) |svg| {
+            if (svg.hasGlyph(glyph_id)) return true;
+        }
+
+        return false;
+    }
+};
+
 test {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -610,7 +695,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
     }
 }
 
@@ -651,7 +736,10 @@ test "emoji" {
     try testing.expectEqual(font.Presentation.emoji, face.presentation);
 
     // Glyph index check
-    try testing.expect(face.glyphIndex('ðŸ¥¸') != null);
+    {
+        const glyph = face.glyphIndex('ðŸ¥¸').?;
+        try testing.expect(glyph.color);
+    }
 }
 
 test "in-memory" {
@@ -674,7 +762,7 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
     }
 }
 
@@ -698,7 +786,7 @@ test "variable" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
     }
 }
 
@@ -726,7 +814,7 @@ test "variable set variation" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
     }
 }
 
@@ -759,3 +847,26 @@ test "svg font table" {
 
     try testing.expect(table.len > 0);
 }
+
+test "glyphIndex colored vs text" {
+    const testing = std.testing;
+    const testFont = @import("../test.zig").fontJuliaMono;
+
+    var lib = try font.Library.init();
+    defer lib.deinit();
+
+    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
+    defer face.deinit();
+
+    {
+        const glyph = face.glyphIndex('A').?;
+        try testing.expectEqual(4, glyph.index);
+        try testing.expectEqual(false, glyph.color);
+    }
+
+    {
+        const glyph = face.glyphIndex(0xE800).?;
+        try testing.expectEqual(11482, glyph.index);
+        try testing.expectEqual(true, glyph.color);
+    }
+}

commit dc6b1b0b7a6c3d3f92123b80bbe8bcda39a9757a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 13:20:37 2024 -0700

    font/coretext: hasColor/isColored

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 9d2477b6..306b6e5b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -242,9 +242,22 @@ pub const Face = struct {
         self.* = face;
     }
 
+    /// Returns true if the face has any glyphs that are colorized.
+    /// To determine if an individual glyph is colorized you must use
+    /// isColored.
+    pub fn hasColor(self: *const Face) bool {
+        return self.color != null;
+    }
+
+    /// Returns true if the given glyph ID is colorized.
+    pub fn isColored(self: *const Face, glyph_id: u16) bool {
+        const c = self.color orelse return false;
+        return c.isColored(glyph_id);
+    }
+
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
-    pub fn glyphIndex(self: Face, cp: u32) ?GlyphIndex {
+    pub fn glyphIndex(self: Face, cp: u32) ?u16 {
         // Turn UTF-32 into UTF-16 for CT API
         var unichars: [2]u16 = undefined;
         const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);
@@ -262,10 +275,7 @@ pub const Face = struct {
         // If we have colorization information, then check if this
         // glyph is colorized.
 
-        return .{
-            .index = @intCast(glyphs[0]),
-            .color = if (self.color) |v| v.isColored(glyphs[0]) else false,
-        };
+        return @intCast(glyphs[0]);
     }
 
     pub fn renderGlyph(
@@ -695,7 +705,7 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -737,8 +747,8 @@ test "emoji" {
 
     // Glyph index check
     {
-        const glyph = face.glyphIndex('ðŸ¥¸').?;
-        try testing.expect(glyph.color);
+        const id = face.glyphIndex('ðŸ¥¸').?;
+        try testing.expect(face.isColored(id));
     }
 }
 
@@ -762,7 +772,7 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -786,7 +796,7 @@ test "variable" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -814,7 +824,7 @@ test "variable set variation" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?.index, .{});
+        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
     }
 }
 
@@ -860,13 +870,13 @@ test "glyphIndex colored vs text" {
 
     {
         const glyph = face.glyphIndex('A').?;
-        try testing.expectEqual(4, glyph.index);
-        try testing.expectEqual(false, glyph.color);
+        try testing.expectEqual(4, glyph);
+        try testing.expect(!face.isColored(glyph));
     }
 
     {
         const glyph = face.glyphIndex(0xE800).?;
-        try testing.expectEqual(11482, glyph.index);
-        try testing.expectEqual(true, glyph.color);
+        try testing.expectEqual(11482, glyph);
+        try testing.expect(face.isColored(glyph));
     }
 }

commit 326659c522536e9215afbc64feb9e6015d5e7fa8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:09:05 2024 -0700

    font: handle presentation at glyph layer

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 306b6e5b..4618ad0b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -19,9 +19,6 @@ pub const Face = struct {
     /// if we're using Harfbuzz.
     hb_font: if (harfbuzz_shaper) harfbuzz.Font else void,
 
-    /// The presentation for this font.
-    presentation: font.Presentation,
-
     /// Metrics for this font face. These are useful for renderers.
     metrics: font.face.Metrics,
 
@@ -111,26 +108,11 @@ pub const Face = struct {
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
-            .presentation = if (traits.color_glyphs) .emoji else .text,
             .metrics = metrics,
             .color = color,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
 
-        // If our presentation is emoji, we also check for the presence of
-        // emoji codepoints. This forces fonts with colorized glyphs that aren't
-        // emoji font to be treated as text. Long term, this isn't what we want
-        // but this fixes some bugs in the short term. See:
-        // https://github.com/mitchellh/ghostty/issues/1768
-        //
-        // Longer term, we'd like to detect mixed color/non-color fonts and
-        // handle them correctly by rendering the color glyphs as color and the
-        // non-color glyphs as text.
-        if (result.presentation == .emoji and result.glyphIndex('ðŸ¥¸') == null) {
-            log.warn("font has colorized glyphs but isn't emoji, treating as text", .{});
-            result.presentation = .text;
-        }
-
         // In debug mode, we output information about available variation axes,
         // if they exist.
         if (comptime builtin.mode == .Debug) {
@@ -244,15 +226,15 @@ pub const Face = struct {
 
     /// Returns true if the face has any glyphs that are colorized.
     /// To determine if an individual glyph is colorized you must use
-    /// isColored.
+    /// isColorGlyph.
     pub fn hasColor(self: *const Face) bool {
         return self.color != null;
     }
 
     /// Returns true if the given glyph ID is colorized.
-    pub fn isColored(self: *const Face, glyph_id: u16) bool {
+    pub fn isColorGlyph(self: *const Face, glyph_id: u32) bool {
         const c = self.color orelse return false;
-        return c.isColored(glyph_id);
+        return c.isColorGlyph(glyph_id);
     }
 
     /// Returns the glyph index for the given Unicode code point. If this
@@ -328,7 +310,7 @@ pub const Face = struct {
             depth: u32,
             space: *macos.graphics.ColorSpace,
             context_opts: c_uint,
-        } = if (self.presentation == .text) .{
+        } = if (!self.isColorGlyph(glyph_index)) .{
             .color = false,
             .depth = 1,
             .space = try macos.graphics.ColorSpace.createDeviceGray(),
@@ -669,13 +651,18 @@ const ColorState = struct {
     }
 
     /// Returns true if the given glyph ID is colored.
-    pub fn isColored(self: *const ColorState, glyph_id: u16) bool {
+    pub fn isColorGlyph(self: *const ColorState, glyph_id: u32) bool {
+        // Our font system uses 32-bit glyph IDs for special values but
+        // actual fonts only contain 16-bit glyph IDs so if we can't cast
+        // into it it must be false.
+        const glyph_u16 = std.math.cast(u16, glyph_id) orelse return false;
+
         // sbix is always true for now
         if (self.sbix) return true;
 
         // if we have svg data, check it
         if (self.svg) |svg| {
-            if (svg.hasGlyph(glyph_id)) return true;
+            if (svg.hasGlyph(glyph_u16)) return true;
         }
 
         return false;
@@ -699,8 +686,6 @@ test {
     var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
-    try testing.expectEqual(font.Presentation.text, face.presentation);
-
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
@@ -722,8 +707,6 @@ test "name" {
     var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
-    try testing.expectEqual(font.Presentation.text, face.presentation);
-
     var buf: [1024]u8 = undefined;
     const font_name = try face.name(&buf);
     try testing.expect(std.mem.eql(u8, font_name, "Menlo"));
@@ -742,13 +725,10 @@ test "emoji" {
     var face = try Face.initFontCopy(ct_font, .{ .size = .{ .points = 18 } });
     defer face.deinit();
 
-    // Presentation
-    try testing.expectEqual(font.Presentation.emoji, face.presentation);
-
     // Glyph index check
     {
         const id = face.glyphIndex('ðŸ¥¸').?;
-        try testing.expect(face.isColored(id));
+        try testing.expect(face.isColorGlyph(id));
     }
 }
 
@@ -766,8 +746,6 @@ test "in-memory" {
     var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
-    try testing.expectEqual(font.Presentation.text, face.presentation);
-
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
@@ -790,8 +768,6 @@ test "variable" {
     var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
-    try testing.expectEqual(font.Presentation.text, face.presentation);
-
     // Generate all visible ASCII
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
@@ -814,8 +790,6 @@ test "variable set variation" {
     var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
     defer face.deinit();
 
-    try testing.expectEqual(font.Presentation.text, face.presentation);
-
     try face.setVariations(&.{
         .{ .id = font.face.Variation.Id.init("wght"), .value = 400 },
     }, .{ .size = .{ .points = 12 } });
@@ -828,19 +802,6 @@ test "variable set variation" {
     }
 }
 
-test "mixed color/non-color font treated as text" {
-    const testing = std.testing;
-    const testFont = @import("../test.zig").fontJuliaMono;
-
-    var lib = try font.Library.init();
-    defer lib.deinit();
-
-    var face = try Face.init(lib, testFont, .{ .size = .{ .points = 12 } });
-    defer face.deinit();
-
-    try testing.expect(face.presentation == .text);
-}
-
 test "svg font table" {
     const testing = std.testing;
     const alloc = testing.allocator;
@@ -871,12 +832,12 @@ test "glyphIndex colored vs text" {
     {
         const glyph = face.glyphIndex('A').?;
         try testing.expectEqual(4, glyph);
-        try testing.expect(!face.isColored(glyph));
+        try testing.expect(!face.isColorGlyph(glyph));
     }
 
     {
         const glyph = face.glyphIndex(0xE800).?;
         try testing.expectEqual(11482, glyph);
-        try testing.expect(face.isColored(glyph));
+        try testing.expect(face.isColorGlyph(glyph));
     }
 }

commit 9a628d8a8e385b3210464992d19ce371b60c897e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:56:47 2024 -0700

    font: remove unused structs

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 4618ad0b..0abf614c 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -7,7 +7,6 @@ const harfbuzz = @import("harfbuzz");
 const font = @import("../main.zig");
 const opentype = @import("../opentype.zig");
 const quirks = @import("../../quirks.zig");
-const GlyphIndex = font.face.GlyphIndex;
 
 const log = std.log.scoped(.font_face);
 

commit f6e708c0fb04d89b9705bc6e20131e5637a5723f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:58:06 2024 -0700

    font/coretext: cleanup unused comments

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 0abf614c..ceb2e40f 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -253,9 +253,6 @@ pub const Face = struct {
         // to decode down into exactly one glyph ID.
         if (pair) assert(glyphs[1] == 0);
 
-        // If we have colorization information, then check if this
-        // glyph is colorized.
-
         return @intCast(glyphs[0]);
     }
 
@@ -600,6 +597,8 @@ pub const Face = struct {
     }
 };
 
+/// The state associated with a font face that may have colorized glyphs.
+/// This is used to determine if a specific glyph ID is colorized.
 const ColorState = struct {
     /// True if there is an sbix font table. For now, the mere presence
     /// of an sbix font table causes us to assume the glyph is colored.

commit d978d05d7ec628d2190b6b39f1a092c75384db1a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 21:05:32 2024 -0700

    font/coretext: glyphIndex must return u32 for noop shaper

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index ceb2e40f..6d07f1fa 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -238,7 +238,7 @@ pub const Face = struct {
 
     /// Returns the glyph index for the given Unicode code point. If this
     /// face doesn't support this glyph, null is returned.
-    pub fn glyphIndex(self: Face, cp: u32) ?u16 {
+    pub fn glyphIndex(self: Face, cp: u32) ?u32 {
         // Turn UTF-32 into UTF-16 for CT API
         var unichars: [2]u16 = undefined;
         const pair = macos.foundation.stringGetSurrogatePairForLongCharacter(cp, &unichars);

commit 10b8ca3c694aa5e0b5cf7eaaae79a4990e3774c3
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Aug 11 18:02:12 2024 -0400

    spelling: normalize grey -> gray

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 6d07f1fa..7b0e1e9b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -671,7 +671,7 @@ test {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     const name = try macos.foundation.String.createWithBytes("Monaco", .utf8, false);
@@ -735,7 +735,7 @@ test "in-memory" {
     const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontRegular;
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     var lib = try font.Library.init();
@@ -757,7 +757,7 @@ test "variable" {
     const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontVariable;
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     var lib = try font.Library.init();
@@ -779,7 +779,7 @@ test "variable set variation" {
     const alloc = testing.allocator;
     const testFont = @import("../test.zig").fontVariable;
 
-    var atlas = try font.Atlas.init(alloc, 512, .greyscale);
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
 
     var lib = try font.Library.init();

commit 318dc85c0260ea72e2021186609424b742b7b5ce
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 16 16:50:41 2024 -0700

    pkg/macos: yeet more usingns

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 7b0e1e9b..2bc550a9 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -338,6 +338,7 @@ pub const Face = struct {
         defer alloc.free(buf);
         @memset(buf, 0);
 
+        const context = macos.graphics.BitmapContext.context;
         const ctx = try macos.graphics.BitmapContext.create(
             buf,
             width,
@@ -347,15 +348,15 @@ pub const Face = struct {
             color.space,
             color.context_opts,
         );
-        defer ctx.release();
+        defer context.release(ctx);
 
         // Perform an initial fill. This ensures that we don't have any
         // uninitialized pixels in the bitmap.
         if (color.color)
-            ctx.setRGBFillColor(1, 1, 1, 0)
+            context.setRGBFillColor(ctx, 1, 1, 1, 0)
         else
-            ctx.setGrayFillColor(0, 0);
-        ctx.fillRect(.{
+            context.setGrayFillColor(ctx, 0, 0);
+        context.fillRect(ctx, .{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
                 .width = @floatFromInt(width),
@@ -363,22 +364,22 @@ pub const Face = struct {
             },
         });
 
-        ctx.setAllowsFontSmoothing(true);
-        ctx.setShouldSmoothFonts(opts.thicken); // The amadeus "enthicken"
-        ctx.setAllowsFontSubpixelQuantization(true);
-        ctx.setShouldSubpixelQuantizeFonts(true);
-        ctx.setAllowsFontSubpixelPositioning(true);
-        ctx.setShouldSubpixelPositionFonts(true);
-        ctx.setAllowsAntialiasing(true);
-        ctx.setShouldAntialias(true);
+        context.setAllowsFontSmoothing(ctx, true);
+        context.setShouldSmoothFonts(ctx, opts.thicken); // The amadeus "enthicken"
+        context.setAllowsFontSubpixelQuantization(ctx, true);
+        context.setShouldSubpixelQuantizeFonts(ctx, true);
+        context.setAllowsFontSubpixelPositioning(ctx, true);
+        context.setShouldSubpixelPositionFonts(ctx, true);
+        context.setAllowsAntialiasing(ctx, true);
+        context.setShouldAntialias(ctx, true);
 
         // Set our color for drawing
         if (color.color) {
-            ctx.setRGBFillColor(1, 1, 1, 1);
-            ctx.setRGBStrokeColor(1, 1, 1, 1);
+            context.setRGBFillColor(ctx, 1, 1, 1, 1);
+            context.setRGBStrokeColor(ctx, 1, 1, 1, 1);
         } else {
-            ctx.setGrayFillColor(1, 1);
-            ctx.setGrayStrokeColor(1, 1);
+            context.setGrayFillColor(ctx, 1, 1);
+            context.setGrayStrokeColor(ctx, 1, 1);
         }
 
         // We want to render the glyphs at (0,0), but the glyphs themselves

commit a3247366fb0a6ae1f8b5bb21729f499d2b22c10f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 19 20:29:36 2024 -0700

    font/coretext: font-thicken renders with additional padding on context
    
    At certain font sizes, this avoids clipping the text. This is due to a
    limitation of the CoreText API, which does not provide a way to measure
    the exact size of the text that will be rendered when antialiasing is
    enabled.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 2bc550a9..adafd93d 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -300,6 +300,14 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
+        // If we're doing thicken, then getBoundsForGlyphs does not take
+        // into account the anti-aliasing that will be added to the glyph.
+        // We need to add some padding to allow that to happen. A padding of
+        // 2 is usually enough for anti-aliasing.
+        const padding_ctx: u32 = if (opts.thicken) 2 else 0;
+        const padded_width: u32 = width + (padding_ctx * 2);
+        const padded_height: u32 = height + (padding_ctx * 2);
+
         // Settings that are specific to if we are rendering text or emoji.
         const color: struct {
             color: bool,
@@ -334,17 +342,17 @@ pub const Face = struct {
         // usually stabilizes pretty quickly and is very infrequent so I think
         // the allocation overhead is acceptable compared to the cost of
         // caching it forever or having to deal with a cache lifetime.
-        const buf = try alloc.alloc(u8, width * height * color.depth);
+        const buf = try alloc.alloc(u8, padded_width * padded_height * color.depth);
         defer alloc.free(buf);
         @memset(buf, 0);
 
         const context = macos.graphics.BitmapContext.context;
         const ctx = try macos.graphics.BitmapContext.create(
             buf,
-            width,
-            height,
+            padded_width,
+            padded_height,
             8,
-            width * color.depth,
+            padded_width * color.depth,
             color.space,
             color.context_opts,
         );
@@ -359,8 +367,8 @@ pub const Face = struct {
         context.fillRect(ctx, .{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
-                .width = @floatFromInt(width),
-                .height = @floatFromInt(height),
+                .width = @floatFromInt(padded_width),
+                .height = @floatFromInt(padded_height),
             },
         });
 
@@ -386,10 +394,11 @@ pub const Face = struct {
         // are offset by bearings, so we have to undo those bearings in order
         // to get them to 0,0. We also add the padding so that they render
         // slightly off the edge of the bitmap.
+        const padding_ctx_f64: f64 = @floatFromInt(padding_ctx);
         self.font.drawGlyphs(&glyphs, &.{
             .{
-                .x = -1 * render_x,
-                .y = render_y,
+                .x = -1 * (render_x - padding_ctx_f64),
+                .y = render_y + padding_ctx_f64,
             },
         }, ctx);
 
@@ -401,8 +410,8 @@ pub const Face = struct {
             // Get the full padded region
             var region = try atlas.reserve(
                 alloc,
-                width + (padding * 2), // * 2 because left+right
-                height + (padding * 2), // * 2 because top+bottom
+                padded_width + (padding * 2), // * 2 because left+right
+                padded_height + (padding * 2), // * 2 because top+bottom
             );
 
             // Modify the region so that we remove the padding so that
@@ -427,11 +436,15 @@ pub const Face = struct {
             // ADD here because CoreText y is UP.
             const baseline_with_offset = baseline_from_bottom + glyph_ascent;
 
-            break :offset_y @intFromFloat(@ceil(baseline_with_offset));
+            // Add our context padding we may have created.
+            const baseline_with_padding = baseline_with_offset + padding_ctx_f64;
+
+            break :offset_y @intFromFloat(@ceil(baseline_with_padding));
         };
 
         const offset_x: i32 = offset_x: {
-            var result: i32 = @intFromFloat(render_x);
+            // Don't forget to apply our context padding if we have one
+            var result: i32 = @intFromFloat(render_x - padding_ctx_f64);
 
             // If our cell was resized to be wider then we center our
             // glyph in the cell.
@@ -462,8 +475,8 @@ pub const Face = struct {
         // });
 
         return .{
-            .width = width,
-            .height = height,
+            .width = padded_width,
+            .height = padded_height,
             .offset_x = offset_x,
             .offset_y = offset_y,
             .atlas_x = region.x,

commit 74291793db0437d2c5d201f7f38d15dfcaf0ba83
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 20:34:19 2024 -0700

    font: rename auto-italicize to synthetic italic

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index adafd93d..55d6dffd 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -169,7 +169,7 @@ pub const Face = struct {
 
     /// Return a new face that is the same as this but has a transformation
     /// matrix applied to italicize it.
-    pub fn italicize(self: *const Face, opts: font.face.Options) !Face {
+    pub fn syntheticItalic(self: *const Face, opts: font.face.Options) !Face {
         const ct_font = try self.font.copyWithAttributes(0.0, &italic_skew, null);
         errdefer ct_font.release();
         return try initFont(ct_font, opts);

commit d22551cd31b76a4d25d5f9cdbc08451d5d35d3b1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 20:52:13 2024 -0700

    font/coretext: support synthetic bold

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 55d6dffd..83599454 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -24,6 +24,10 @@ pub const Face = struct {
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
+    /// True if this font face should be rasterized with a synthetic bold
+    /// effect. This is used for fonts that don't have a bold variant.
+    synthetic_bold: ?f64 = null,
+
     /// If the face can possibly be colored, then this is the state
     /// used to check for color information. This is null if the font
     /// can't possibly be colored (i.e. doesn't have SVG, sbix, etc
@@ -175,6 +179,25 @@ pub const Face = struct {
         return try initFont(ct_font, opts);
     }
 
+    /// Return a new face that is the same as this but applies a synthetic
+    /// bold effect to it. This is useful for fonts that don't have a bold
+    /// variant.
+    pub fn syntheticBold(self: *const Face, opts: font.face.Options) !Face {
+        const ct_font = try self.font.copyWithAttributes(0.0, null, null);
+        errdefer ct_font.release();
+        var face = try initFont(ct_font, opts);
+
+        // TO determine our synthetic bold line width we get a multiplier
+        // from the font size in points. This is a heuristic that is based
+        // on the fact that a line width of 1 looks good to me at 12 points
+        // and we want to scale that up roughly linearly with the font size.
+        const points_f64: f64 = @floatCast(opts.size.points);
+        const line_width = @max(points_f64 / 12.0, 1);
+        face.synthetic_bold = line_width;
+
+        return face;
+    }
+
     /// Returns the font name. If allocation is required, buf will be used,
     /// but sometimes allocation isn't required and a static string is
     /// returned.
@@ -300,11 +323,23 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
-        // If we're doing thicken, then getBoundsForGlyphs does not take
-        // into account the anti-aliasing that will be added to the glyph.
-        // We need to add some padding to allow that to happen. A padding of
-        // 2 is usually enough for anti-aliasing.
-        const padding_ctx: u32 = if (opts.thicken) 2 else 0;
+        // Additional padding we need to add to the bitmap context itself
+        // due to the glyph being larger than standard.
+        const padding_ctx: u32 = padding_ctx: {
+            // If we're doing thicken, then getBoundsForGlyphs does not take
+            // into account the anti-aliasing that will be added to the glyph.
+            // We need to add some padding to allow that to happen. A padding of
+            // 2 is usually enough for anti-aliasing.
+            var result: u32 = if (opts.thicken) 2 else 0;
+
+            // If we have a synthetic bold, add padding for the stroke width
+            if (self.synthetic_bold) |line_width| {
+                // x2 for top and bottom padding
+                result += @intFromFloat(@ceil(line_width) * 2);
+            }
+
+            break :padding_ctx result;
+        };
         const padded_width: u32 = width + (padding_ctx * 2);
         const padded_height: u32 = height + (padding_ctx * 2);
 
@@ -390,6 +425,13 @@ pub const Face = struct {
             context.setGrayStrokeColor(ctx, 1, 1);
         }
 
+        // If we are drawing with synthetic bold then use a fill stroke
+        // which strokes the outlines of the glyph making a more bold look.
+        if (self.synthetic_bold) |line_width| {
+            context.setTextDrawingMode(ctx, .fill_stroke);
+            context.setLineWidth(ctx, line_width);
+        }
+
         // We want to render the glyphs at (0,0), but the glyphs themselves
         // are offset by bearings, so we have to undo those bearings in order
         // to get them to 0,0. We also add the padding so that they render

commit ac3e2163f342ae89c8c683b19833c52dfff6cc4c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 21:19:20 2024 -0700

    typos

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 83599454..202230d5 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -187,7 +187,7 @@ pub const Face = struct {
         errdefer ct_font.release();
         var face = try initFont(ct_font, opts);
 
-        // TO determine our synthetic bold line width we get a multiplier
+        // To determine our synthetic bold line width we get a multiplier
         // from the font size in points. This is a heuristic that is based
         // on the fact that a line width of 1 looks good to me at 12 points
         // and we want to scale that up roughly linearly with the font size.

commit c1e978e33dd8656499fee2940918c5024f7a67b9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 26 09:36:21 2024 -0700

    font/coretext: tweak synthetic bold amount to be slightly lighter

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 202230d5..5e141e05 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -189,10 +189,12 @@ pub const Face = struct {
 
         // To determine our synthetic bold line width we get a multiplier
         // from the font size in points. This is a heuristic that is based
-        // on the fact that a line width of 1 looks good to me at 12 points
-        // and we want to scale that up roughly linearly with the font size.
+        // on the fact that a line width of 1 looks good to me at a certain
+        // point size. We want to scale that up roughly linearly with the
+        // font size.
         const points_f64: f64 = @floatCast(opts.size.points);
-        const line_width = @max(points_f64 / 12.0, 1);
+        const line_width = @max(points_f64 / 14.0, 1);
+        // log.debug("synthetic bold line width={}", .{line_width});
         face.synthetic_bold = line_width;
 
         return face;

commit 3ec36e4d239d71b52ef7820e179367f9e2b97c28
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 19:01:15 2024 -0600

    coretext: improve strikethrough position calculation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 5e141e05..3a69ef95 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -596,15 +596,19 @@ pub const Face = struct {
         const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
         const strikethrough_position = strikethrough_position: {
-            // This is the height above baseline consumed by text. We must take
-            // into account that our cell height splits the leading between two
-            // rows so we subtract leading space (blank space).
-            const above_baseline = layout_metrics.ascent - (layout_metrics.leading / 2);
-
-            // We want to position the strikethrough at 65% of the height.
-            // This generally gives a nice visual appearance. The number 65%
-            // is somewhat arbitrary but is a common value across terminals.
-            const pos = above_baseline * 0.65;
+            // This is the height of lower case letters in our font.
+            const ex_height = ct_font.getXHeight();
+
+            // We want to position the strikethrough so that it's
+            // vertically centered on any lower case text. This is
+            // a fairly standard choice for strikethrough positioning.
+            //
+            // Because our `strikethrough_position` is relative to the
+            // top of the cell we start with the ascent metric, which
+            // is the distance from the top down to the baseline, then
+            // we subtract half of the ex height to go back up to the
+            // correct height that should evenly split lowercase text.
+            const pos = layout_metrics.ascent - ex_height * 0.5 + 1;
 
             break :strikethrough_position @ceil(pos);
         };

commit 7a1d304fa91ddd6961c0973be3a6ea2d99fb6538
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Sep 23 22:10:43 2024 -0600

    font: further improve ul/st position calculations

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 3a69ef95..ee246057 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -594,7 +594,10 @@ pub const Face = struct {
         // All of these metrics are based on our layout above.
         const cell_height = @ceil(layout_metrics.height);
         const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
+
         const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
+        const strikethrough_thickness = underline_thickness;
+
         const strikethrough_position = strikethrough_position: {
             // This is the height of lower case letters in our font.
             const ex_height = ct_font.getXHeight();
@@ -608,20 +611,21 @@ pub const Face = struct {
             // is the distance from the top down to the baseline, then
             // we subtract half of the ex height to go back up to the
             // correct height that should evenly split lowercase text.
-            const pos = layout_metrics.ascent - ex_height * 0.5 + 1;
+            const pos = layout_metrics.ascent -
+                ex_height * 0.5 +
+                strikethrough_thickness * 0.5 +
+                1;
 
             break :strikethrough_position @ceil(pos);
         };
-        const strikethrough_thickness = underline_thickness;
 
         // Underline position reported is usually something like "-1" to
         // represent the amount under the baseline. We add this to our real
         // baseline to get the actual value from the bottom (+y is up).
         // The final underline position is +y from the TOP (confusing)
         // so we have to subtract from the cell height.
-        const underline_position = cell_height -
-            (cell_baseline + @ceil(@as(f32, @floatCast(ct_font.getUnderlinePosition())))) +
-            1;
+        const underline_position = @ceil(layout_metrics.ascent -
+            @as(f32, @floatCast(ct_font.getUnderlinePosition())) + 1);
 
         // Note: is this useful?
         // const units_per_em = ct_font.getUnitsPerEm();

commit 003b100707a7125f1e84ce44b42e0b1bd8b3484d
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Sep 25 12:01:24 2024 -0600

    font: remove fudge factors in ul and st position calculations
    
    These were present because of an incorrect calculation in the underline
    sprite renderer, and are no longer necessary.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index ee246057..dacb7947 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -612,9 +612,8 @@ pub const Face = struct {
             // we subtract half of the ex height to go back up to the
             // correct height that should evenly split lowercase text.
             const pos = layout_metrics.ascent -
-                ex_height * 0.5 +
-                strikethrough_thickness * 0.5 +
-                1;
+                ex_height * 0.5 -
+                strikethrough_thickness * 0.5;
 
             break :strikethrough_position @ceil(pos);
         };
@@ -625,7 +624,7 @@ pub const Face = struct {
         // The final underline position is +y from the TOP (confusing)
         // so we have to subtract from the cell height.
         const underline_position = @ceil(layout_metrics.ascent -
-            @as(f32, @floatCast(ct_font.getUnderlinePosition())) + 1);
+            @as(f32, @floatCast(ct_font.getUnderlinePosition())));
 
         // Note: is this useful?
         // const units_per_em = ct_font.getUnitsPerEm();

commit be3ae56bc8cdd8c6b15c3bcd885d572300b28953
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 2 14:45:34 2024 -0700

    font: add stylistic variants for built-in font, fix naming convention
    
    Fixes #2364
    
    This adds the bold, italic, and bold italic variants of JB Mono so it is
    built-in. This also fixes up the naming convention for the embedded font
    files across tests and removes redundant embedded font files.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index dacb7947..2403b390 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -798,7 +798,7 @@ test "emoji" {
 test "in-memory" {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
@@ -820,7 +820,7 @@ test "in-memory" {
 test "variable" {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontVariable;
+    const testFont = font.embedded.variable;
 
     var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
@@ -842,7 +842,7 @@ test "variable" {
 test "variable set variation" {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontVariable;
+    const testFont = font.embedded.variable;
 
     var atlas = try font.Atlas.init(alloc, 512, .grayscale);
     defer atlas.deinit(alloc);
@@ -868,7 +868,7 @@ test "variable set variation" {
 test "svg font table" {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("../test.zig").fontJuliaMono;
+    const testFont = font.embedded.julia_mono;
 
     var lib = try font.Library.init();
     defer lib.deinit();
@@ -884,7 +884,7 @@ test "svg font table" {
 
 test "glyphIndex colored vs text" {
     const testing = std.testing;
-    const testFont = @import("../test.zig").fontJuliaMono;
+    const testFont = font.embedded.julia_mono;
 
     var lib = try font.Library.init();
     defer lib.deinit();

commit e08eeb2b2ad810c4db22530a181858caee834b22
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 5 16:13:53 2024 -0800

    coretext: set variations on deferred face load
    
    This commit makes CoreText behave a lot like FreeType where we set the
    variation axes on the deferred face load. This fixes a bug where the
    `slnt` variation axis could not be set with CoreText with the Monaspace
    Argon Variable font.
    
    This was a bug found in Discord. Specifically, with the Monaspace Argon
    Variable font, the `slnt` variation axis could not be set with CoreText.
    I'm not sure _exactly_ what causes this but I suspect it has to do with
    the `slnt` axis being a negative value. I'm not sure if this is a bug
    with CoreText or not.
    
    What was happening was that with CoreText, we set the variation axes
    during discovery and expect them to be preserved in the resulting
    discovered faces. That seems to be true with the `wght` axis but not the
    `slnt` axis for whatever reason.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 2403b390..363dbacd 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -229,6 +229,9 @@ pub const Face = struct {
         vs: []const font.face.Variation,
         opts: font.face.Options,
     ) !void {
+        // If we have no variations, we don't need to do anything.
+        if (vs.len == 0) return;
+
         // Create a new font descriptor with all the variations set.
         var desc = self.font.copyDescriptor();
         defer desc.release();

commit bd1845231011d2b445a78bef07a5b54f0b077479
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Dec 11 16:30:40 2024 -0500

    font: unify metrics calculations & separate sprite metrics
    
    Unify grid metrics calculations by relying on shared logic mostly based
    on values directly from the font tables, this deduplicates a lot of code
    and gives us more control over how we interpret various metrics.
    
    Also separate metrics for underlined, strikethrough, and overline
    thickness and position, and box drawing thickness, so that they can
    individually be adjusted as the user desires.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 363dbacd..6a77ee15 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -533,10 +533,91 @@ pub const Face = struct {
     }
 
     fn calcMetrics(ct_font: *macos.text.Font) !font.face.Metrics {
+        // Read the 'head' table out of the font data.
+        const head: opentype.Head = head: {
+            const tag = macos.text.FontTableTag.init("head");
+            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            defer data.release();
+            const ptr = data.getPointer();
+            const len = data.getLength();
+            break :head try opentype.Head.init(ptr[0..len]);
+        };
+
+        // Read the 'post' table out of the font data.
+        const post: opentype.Post = post: {
+            const tag = macos.text.FontTableTag.init("post");
+            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            defer data.release();
+            const ptr = data.getPointer();
+            const len = data.getLength();
+            break :post try opentype.Post.init(ptr[0..len]);
+        };
+
+        // Read the 'OS/2' table out of the font data.
+        const os2: opentype.OS2 = os2: {
+            const tag = macos.text.FontTableTag.init("OS/2");
+            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            defer data.release();
+            const ptr = data.getPointer();
+            const len = data.getLength();
+            break :os2 try opentype.OS2.init(ptr[0..len]);
+        };
+
+        const units_per_em = head.unitsPerEm;
+        const px_per_em = ct_font.getSize();
+        const px_per_unit = px_per_em / @as(f64, @floatFromInt(units_per_em));
+
+        const ascent = @as(f64, @floatFromInt(os2.sTypoAscender)) * px_per_unit;
+        const descent = @as(f64, @floatFromInt(os2.sTypoDescender)) * px_per_unit;
+        const line_gap = @as(f64, @floatFromInt(os2.sTypoLineGap)) * px_per_unit;
+
+        // Some fonts have degenerate 'post' tables where the underline
+        // thickness (and often position) are 0. We consider them null
+        // if this is the case and use our own fallbacks when we calculate.
+        const has_broken_underline = post.underlineThickness == 0;
+
+        // If the underline position isn't 0 then we do use it,
+        // even if the thickness is't properly specified.
+        const underline_position = if (has_broken_underline and post.underlinePosition == 0)
+            null
+        else
+            @as(f64, @floatFromInt(post.underlinePosition)) * px_per_unit;
+
+        const underline_thickness = if (has_broken_underline)
+            null
+        else
+            @as(f64, @floatFromInt(post.underlineThickness)) * px_per_unit;
+
+        // Similar logic to the underline above.
+        const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+
+        const strikethrough_position = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+            null
+        else
+            @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+
+        const strikethrough_thickness = if (has_broken_strikethrough)
+            null
+        else
+            @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+
+        // We fall back to whatever CoreText does if
+        // the OS/2 table doesn't specify a cap height.
+        const cap_height = if (os2.sCapHeight) |sCapHeight|
+            @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
+        else
+            ct_font.getCapHeight();
+
+        // Ditto for ex height.
+        const ex_height = if (os2.sxHeight) |sxHeight|
+            @as(f64, @floatFromInt(sxHeight)) * px_per_unit
+        else
+            ct_font.getXHeight();
+
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take
         // whatever is widest.
-        const cell_width: f32 = cell_width: {
+        const cell_width: f64 = cell_width: {
             // Build a comptime array of all the ASCII chars
             const unichars = comptime unichars: {
                 const len = 127 - 32;
@@ -564,89 +645,25 @@ pub const Face = struct {
                 max = @max(advances[i].width, max);
             }
 
-            break :cell_width @floatCast(@ceil(max));
+            break :cell_width max;
         };
 
-        // Calculate the layout metrics for height/ascent by just asking
-        // the font. I also tried Kitty's approach at one point which is to
-        // use the CoreText layout engine but this led to some glyphs being
-        // set incorrectly.
-        const layout_metrics: struct {
-            height: f32,
-            ascent: f32,
-            leading: f32,
-        } = metrics: {
-            const ascent = ct_font.getAscent();
-            const descent = ct_font.getDescent();
-
-            // Leading is the value between lines at the TOP of a line.
-            // Because we are rendering a fixed size terminal grid, we
-            // want the leading to be split equally between the top and bottom.
-            const leading = ct_font.getLeading();
-
-            // We ceil the metrics below because we don't want to cut off any
-            // potential used pixels. This tends to only make a one pixel
-            // difference but at small font sizes this can be noticeable.
-            break :metrics .{
-                .height = @floatCast(@ceil(ascent + descent + leading)),
-                .ascent = @floatCast(@ceil(ascent + (leading / 2))),
-                .leading = @floatCast(leading),
-            };
-        };
+        return font.face.Metrics.calc(.{
+            .cell_width = cell_width,
 
-        // All of these metrics are based on our layout above.
-        const cell_height = @ceil(layout_metrics.height);
-        const cell_baseline = @ceil(layout_metrics.height - layout_metrics.ascent);
-
-        const underline_thickness = @ceil(@as(f32, @floatCast(ct_font.getUnderlineThickness())));
-        const strikethrough_thickness = underline_thickness;
-
-        const strikethrough_position = strikethrough_position: {
-            // This is the height of lower case letters in our font.
-            const ex_height = ct_font.getXHeight();
-
-            // We want to position the strikethrough so that it's
-            // vertically centered on any lower case text. This is
-            // a fairly standard choice for strikethrough positioning.
-            //
-            // Because our `strikethrough_position` is relative to the
-            // top of the cell we start with the ascent metric, which
-            // is the distance from the top down to the baseline, then
-            // we subtract half of the ex height to go back up to the
-            // correct height that should evenly split lowercase text.
-            const pos = layout_metrics.ascent -
-                ex_height * 0.5 -
-                strikethrough_thickness * 0.5;
-
-            break :strikethrough_position @ceil(pos);
-        };
+            .ascent = ascent,
+            .descent = descent,
+            .line_gap = line_gap,
 
-        // Underline position reported is usually something like "-1" to
-        // represent the amount under the baseline. We add this to our real
-        // baseline to get the actual value from the bottom (+y is up).
-        // The final underline position is +y from the TOP (confusing)
-        // so we have to subtract from the cell height.
-        const underline_position = @ceil(layout_metrics.ascent -
-            @as(f32, @floatCast(ct_font.getUnderlinePosition())));
-
-        // Note: is this useful?
-        // const units_per_em = ct_font.getUnitsPerEm();
-        // const units_per_point = @intToFloat(f64, units_per_em) / ct_font.getSize();
-
-        const result = font.face.Metrics{
-            .cell_width = @intFromFloat(cell_width),
-            .cell_height = @intFromFloat(cell_height),
-            .cell_baseline = @intFromFloat(cell_baseline),
-            .underline_position = @intFromFloat(underline_position),
-            .underline_thickness = @intFromFloat(underline_thickness),
-            .strikethrough_position = @intFromFloat(strikethrough_position),
-            .strikethrough_thickness = @intFromFloat(strikethrough_thickness),
-        };
+            .underline_position = underline_position,
+            .underline_thickness = underline_thickness,
 
-        // std.log.warn("font size size={d}", .{ct_font.getSize()});
-        // std.log.warn("font metrics={}", .{result});
+            .strikethrough_position = strikethrough_position,
+            .strikethrough_thickness = strikethrough_thickness,
 
-        return result;
+            .cap_height = cap_height,
+            .ex_height = ex_height,
+        });
     }
 
     /// Copy the font table data for the given tag.

commit fb50143cec9bfec1f86d1fbfda87799519a87829
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Wed Dec 11 21:14:21 2024 -0500

    font(coretext): add metrics test case for CT, fix variable font init
    
    Variable font init used to just select the first available predefined
    instance, if there were any, which is often not desirable- using
    createFontDescriptorFromData instead of createFontDescritorsFromData
    ensures that the default variation config is selected. In the future we
    should probably allow selection of predefined instances, but for now
    this is the correct behavior.
    
    I found this bug when adding the metrics calculation test case for
    CoreText, hence why fixing it is part of the same commit.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 6a77ee15..263a5f91 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -55,12 +55,10 @@ pub const Face = struct {
         const data = try macos.foundation.Data.createWithBytesNoCopy(source);
         defer data.release();
 
-        const arr = macos.text.createFontDescriptorsFromData(data) orelse
+        const desc = macos.text.createFontDescriptorFromData(data) orelse
             return error.FontInitFailure;
-        defer arr.release();
-        if (arr.getCount() == 0) return error.FontInitFailure;
+        defer desc.release();
 
-        const desc = arr.getValueAtIndex(macos.text.FontDescriptor, 0);
         const ct_font = try macos.text.Font.createWithFontDescriptor(desc, 12);
         defer ct_font.release();
 
@@ -924,3 +922,58 @@ test "glyphIndex colored vs text" {
         try testing.expect(face.isColorGlyph(glyph));
     }
 }
+
+test "coretext: metrics" {
+    const testFont = font.embedded.inconsolata;
+    const alloc = std.testing.allocator;
+
+    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
+    defer atlas.deinit(alloc);
+
+    var ct_font = try Face.init(
+        undefined,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    );
+    defer ct_font.deinit();
+
+    try std.testing.expectEqual(font.face.Metrics{
+        .cell_width = 8,
+        // The cell height is 17 px because the calculation is
+        //
+        //  ascender - descender + gap
+        //
+        // which, for inconsolata is
+        //
+        //  859 - -190 + 0
+        //
+        // font units, at 1000 units per em that works out to 1.049 em,
+        // and 1em should be the point size * dpi scale, so 12 * (96/72)
+        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
+        // to 17.
+        .cell_height = 17,
+        .cell_baseline = 3,
+        .underline_position = 17,
+        .underline_thickness = 1,
+        .strikethrough_position = 10,
+        .strikethrough_thickness = 1,
+        .overline_position = 0,
+        .overline_thickness = 1,
+        .box_thickness = 1,
+    }, ct_font.metrics);
+
+    // Resize should change metrics
+    try ct_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
+    try std.testing.expectEqual(font.face.Metrics{
+        .cell_width = 16,
+        .cell_height = 34,
+        .cell_baseline = 6,
+        .underline_position = 34,
+        .underline_thickness = 2,
+        .strikethrough_position = 19,
+        .strikethrough_thickness = 2,
+        .overline_position = 0,
+        .overline_thickness = 2,
+        .box_thickness = 2,
+    }, ct_font.metrics);
+}

commit b7dc7672376bc2ade8ab9235ba895a826ea40c12
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Dec 12 19:42:35 2024 -0800

    face: add more RLS types and explicit error sets

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 263a5f91..8749f909 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -530,7 +530,15 @@ pub const Face = struct {
         };
     }
 
-    fn calcMetrics(ct_font: *macos.text.Font) !font.face.Metrics {
+    const CalcMetricsError = error{
+        CopyTableError,
+        InvalidHeadTable,
+        InvalidPostTable,
+        InvalidOS2Table,
+        OS2VersionNotSupported,
+    };
+
+    fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.face.Metrics {
         // Read the 'head' table out of the font data.
         const head: opentype.Head = head: {
             const tag = macos.text.FontTableTag.init("head");
@@ -538,7 +546,12 @@ pub const Face = struct {
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
-            break :head try opentype.Head.init(ptr[0..len]);
+            break :head opentype.Head.init(ptr[0..len]) catch |err| {
+                return switch (err) {
+                    error.EndOfStream,
+                    => error.InvalidHeadTable,
+                };
+            };
         };
 
         // Read the 'post' table out of the font data.
@@ -548,7 +561,11 @@ pub const Face = struct {
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
-            break :post try opentype.Post.init(ptr[0..len]);
+            break :post opentype.Post.init(ptr[0..len]) catch |err| {
+                return switch (err) {
+                    error.EndOfStream => error.InvalidOS2Table,
+                };
+            };
         };
 
         // Read the 'OS/2' table out of the font data.
@@ -558,12 +575,17 @@ pub const Face = struct {
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
-            break :os2 try opentype.OS2.init(ptr[0..len]);
+            break :os2 opentype.OS2.init(ptr[0..len]) catch |err| {
+                return switch (err) {
+                    error.EndOfStream => error.InvalidOS2Table,
+                    error.OS2VersionNotSupported => error.OS2VersionNotSupported,
+                };
+            };
         };
 
-        const units_per_em = head.unitsPerEm;
-        const px_per_em = ct_font.getSize();
-        const px_per_unit = px_per_em / @as(f64, @floatFromInt(units_per_em));
+        const units_per_em: f64 = @floatFromInt(head.unitsPerEm);
+        const px_per_em: f64 = ct_font.getSize();
+        const px_per_unit: f64 = px_per_em / units_per_em;
 
         const ascent = @as(f64, @floatFromInt(os2.sTypoAscender)) * px_per_unit;
         const descent = @as(f64, @floatFromInt(os2.sTypoDescender)) * px_per_unit;
@@ -576,7 +598,7 @@ pub const Face = struct {
 
         // If the underline position isn't 0 then we do use it,
         // even if the thickness is't properly specified.
-        const underline_position = if (has_broken_underline and post.underlinePosition == 0)
+        const underline_position: ?f64 = if (has_broken_underline and post.underlinePosition == 0)
             null
         else
             @as(f64, @floatFromInt(post.underlinePosition)) * px_per_unit;
@@ -589,25 +611,25 @@ pub const Face = struct {
         // Similar logic to the underline above.
         const has_broken_strikethrough = os2.yStrikeoutSize == 0;
 
-        const strikethrough_position = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+        const strikethrough_position: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
             null
         else
             @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
 
-        const strikethrough_thickness = if (has_broken_strikethrough)
+        const strikethrough_thickness: ?f64 = if (has_broken_strikethrough)
             null
         else
             @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
 
         // We fall back to whatever CoreText does if
         // the OS/2 table doesn't specify a cap height.
-        const cap_height = if (os2.sCapHeight) |sCapHeight|
+        const cap_height: f64 = if (os2.sCapHeight) |sCapHeight|
             @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
         else
             ct_font.getCapHeight();
 
         // Ditto for ex height.
-        const ex_height = if (os2.sxHeight) |sxHeight|
+        const ex_height: f64 = if (os2.sxHeight) |sxHeight|
             @as(f64, @floatFromInt(sxHeight)) * px_per_unit
         else
             ct_font.getXHeight();
@@ -648,24 +670,24 @@ pub const Face = struct {
 
         return font.face.Metrics.calc(.{
             .cell_width = cell_width,
-
             .ascent = ascent,
             .descent = descent,
             .line_gap = line_gap,
-
             .underline_position = underline_position,
             .underline_thickness = underline_thickness,
-
             .strikethrough_position = strikethrough_position,
             .strikethrough_thickness = strikethrough_thickness,
-
             .cap_height = cap_height,
             .ex_height = ex_height,
         });
     }
 
     /// Copy the font table data for the given tag.
-    pub fn copyTable(self: Face, alloc: Allocator, tag: *const [4]u8) !?[]u8 {
+    pub fn copyTable(
+        self: Face,
+        alloc: Allocator,
+        tag: *const [4]u8,
+    ) Allocator.Error!?[]u8 {
         const data = self.font.copyTable(macos.text.FontTableTag.init(tag)) orelse
             return null;
         defer data.release();
@@ -693,7 +715,9 @@ const ColorState = struct {
     svg: ?opentype.SVG,
     svg_data: ?*macos.foundation.Data,
 
-    pub fn init(f: *macos.text.Font) !ColorState {
+    pub const Error = error{InvalidSVGTable};
+
+    pub fn init(f: *macos.text.Font) Error!ColorState {
         // sbix is true if the table exists in the font data at all.
         // In the future we probably want to actually parse it and
         // check for glyphs.
@@ -714,8 +738,16 @@ const ColorState = struct {
             errdefer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
+            const svg = opentype.SVG.init(ptr[0..len]) catch |err| {
+                return switch (err) {
+                    error.EndOfStream,
+                    error.SVGVersionNotSupported,
+                    => error.InvalidSVGTable,
+                };
+            };
+
             break :svg .{
-                .svg = try opentype.SVG.init(ptr[0..len]),
+                .svg = svg,
                 .data = data,
             };
         };

commit 8a5d4847297549823c3f7d2e0fc6ea145d3e2061
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Dec 13 12:46:36 2024 -0500

    font: more robust extraction of vertical metrics from tables
    
    Previously always assuming the typo metrics were good caused some fonts
    to have abnormally short cell heights.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 8749f909..756d1ae6 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -536,6 +536,7 @@ pub const Face = struct {
         InvalidPostTable,
         InvalidOS2Table,
         OS2VersionNotSupported,
+        InvalidHheaTable,
     };
 
     fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.face.Metrics {
@@ -563,7 +564,7 @@ pub const Face = struct {
             const len = data.getLength();
             break :post opentype.Post.init(ptr[0..len]) catch |err| {
                 return switch (err) {
-                    error.EndOfStream => error.InvalidOS2Table,
+                    error.EndOfStream => error.InvalidPostTable,
                 };
             };
         };
@@ -583,13 +584,73 @@ pub const Face = struct {
             };
         };
 
+        // Read the 'hhea' table out of the font data.
+        const hhea: opentype.Hhea = hhea: {
+            const tag = macos.text.FontTableTag.init("hhea");
+            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            defer data.release();
+            const ptr = data.getPointer();
+            const len = data.getLength();
+            break :hhea opentype.Hhea.init(ptr[0..len]) catch |err| {
+                return switch (err) {
+                    error.EndOfStream => error.InvalidHheaTable,
+                };
+            };
+        };
+
         const units_per_em: f64 = @floatFromInt(head.unitsPerEm);
         const px_per_em: f64 = ct_font.getSize();
         const px_per_unit: f64 = px_per_em / units_per_em;
 
-        const ascent = @as(f64, @floatFromInt(os2.sTypoAscender)) * px_per_unit;
-        const descent = @as(f64, @floatFromInt(os2.sTypoDescender)) * px_per_unit;
-        const line_gap = @as(f64, @floatFromInt(os2.sTypoLineGap)) * px_per_unit;
+        const ascent: f64, const descent: f64, const line_gap: f64 = vertical_metrics: {
+            const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
+            const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
+            const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+
+            // If the font says to use typo metrics, trust it.
+            if (os2.fsSelection.use_typo_metrics) {
+                break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
+            }
+
+            // Otherwise we prefer the height metrics from 'hhea' if they
+            // are available, or else OS/2 sTypo* metrics, and if all else
+            // fails then we use OS/2 usWin* metrics.
+            //
+            // This is not "standard" behavior, but it's our best bet to
+            // account for fonts being... just weird. It's pretty much what
+            // FreeType does to get its generic ascent and descent metrics.
+
+            if (hhea.ascender != 0 or hhea.descender != 0) {
+                const hhea_ascent: f64 = @floatFromInt(hhea.ascender);
+                const hhea_descent: f64 = @floatFromInt(hhea.descender);
+                const hhea_line_gap: f64 = @floatFromInt(hhea.lineGap);
+                break :vertical_metrics .{
+                    hhea_ascent * px_per_unit,
+                    hhea_descent * px_per_unit,
+                    hhea_line_gap * px_per_unit,
+                };
+            }
+
+            if (os2_ascent != 0 or os2_descent != 0) {
+                break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
+            }
+
+            const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
+            const win_descent: f64 = @floatFromInt(os2.usWinDescent);
+            break :vertical_metrics .{
+                win_ascent * px_per_unit,
+                win_descent * px_per_unit,
+                0.0,
+            };
+        };
 
         // Some fonts have degenerate 'post' tables where the underline
         // thickness (and often position) are 0. We consider them null

commit 4573890f22d52ea1f47f2a664f7db4aeb3de7543
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Dec 13 13:14:49 2024 -0500

    font: fix sign of usWinDescent interpretation

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 756d1ae6..09fdd7ad 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -647,7 +647,9 @@ pub const Face = struct {
             const win_descent: f64 = @floatFromInt(os2.usWinDescent);
             break :vertical_metrics .{
                 win_ascent * px_per_unit,
-                win_descent * px_per_unit,
+                // usWinDescent is *positive* -> down unlike sTypoDescender
+                // and hhea.Descender, so we flip its sign to fix this.
+                -win_descent * px_per_unit,
                 0.0,
             };
         };

commit 5cd214066d83e5f49d3eb8b7c8399b5f9e7d62aa
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Dec 16 14:32:04 2024 -0500

    font(coretext): tolerate fonts without OS/2 tables
    
    This creates big problems if we don't, since a lot of symbols end up
    falling back to Apple Gothic, which doesn't have an OS/2 table.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 09fdd7ad..6389ba67 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -534,8 +534,6 @@ pub const Face = struct {
         CopyTableError,
         InvalidHeadTable,
         InvalidPostTable,
-        InvalidOS2Table,
-        OS2VersionNotSupported,
         InvalidHheaTable,
     };
 
@@ -569,18 +567,16 @@ pub const Face = struct {
             };
         };
 
-        // Read the 'OS/2' table out of the font data.
-        const os2: opentype.OS2 = os2: {
+        // Read the 'OS/2' table out of the font data if it's available.
+        const maybe_os2: ?opentype.OS2 = os2: {
             const tag = macos.text.FontTableTag.init("OS/2");
-            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            const data = ct_font.copyTable(tag) orelse break :os2 null;
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
             break :os2 opentype.OS2.init(ptr[0..len]) catch |err| {
-                return switch (err) {
-                    error.EndOfStream => error.InvalidOS2Table,
-                    error.OS2VersionNotSupported => error.OS2VersionNotSupported,
-                };
+                log.warn("Error parsing OS/2 table: {any}", .{err});
+                break :os2 null;
             };
         };
 
@@ -603,54 +599,65 @@ pub const Face = struct {
         const px_per_unit: f64 = px_per_em / units_per_em;
 
         const ascent: f64, const descent: f64, const line_gap: f64 = vertical_metrics: {
-            const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
-            const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
-            const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+            const hhea_ascent: f64 = @floatFromInt(hhea.ascender);
+            const hhea_descent: f64 = @floatFromInt(hhea.descender);
+            const hhea_line_gap: f64 = @floatFromInt(hhea.lineGap);
+
+            if (maybe_os2) |os2| {
+                const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
+                const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
+                const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
+
+                // If the font says to use typo metrics, trust it.
+                if (os2.fsSelection.use_typo_metrics) {
+                    break :vertical_metrics .{
+                        os2_ascent * px_per_unit,
+                        os2_descent * px_per_unit,
+                        os2_line_gap * px_per_unit,
+                    };
+                }
 
-            // If the font says to use typo metrics, trust it.
-            if (os2.fsSelection.use_typo_metrics) {
-                break :vertical_metrics .{
-                    os2_ascent * px_per_unit,
-                    os2_descent * px_per_unit,
-                    os2_line_gap * px_per_unit,
-                };
-            }
+                // Otherwise we prefer the height metrics from 'hhea' if they
+                // are available, or else OS/2 sTypo* metrics, and if all else
+                // fails then we use OS/2 usWin* metrics.
+                //
+                // This is not "standard" behavior, but it's our best bet to
+                // account for fonts being... just weird. It's pretty much what
+                // FreeType does to get its generic ascent and descent metrics.
+
+                if (hhea.ascender != 0 or hhea.descender != 0) {
+                    break :vertical_metrics .{
+                        hhea_ascent * px_per_unit,
+                        hhea_descent * px_per_unit,
+                        hhea_line_gap * px_per_unit,
+                    };
+                }
 
-            // Otherwise we prefer the height metrics from 'hhea' if they
-            // are available, or else OS/2 sTypo* metrics, and if all else
-            // fails then we use OS/2 usWin* metrics.
-            //
-            // This is not "standard" behavior, but it's our best bet to
-            // account for fonts being... just weird. It's pretty much what
-            // FreeType does to get its generic ascent and descent metrics.
-
-            if (hhea.ascender != 0 or hhea.descender != 0) {
-                const hhea_ascent: f64 = @floatFromInt(hhea.ascender);
-                const hhea_descent: f64 = @floatFromInt(hhea.descender);
-                const hhea_line_gap: f64 = @floatFromInt(hhea.lineGap);
-                break :vertical_metrics .{
-                    hhea_ascent * px_per_unit,
-                    hhea_descent * px_per_unit,
-                    hhea_line_gap * px_per_unit,
-                };
-            }
+                if (os2_ascent != 0 or os2_descent != 0) {
+                    break :vertical_metrics .{
+                        os2_ascent * px_per_unit,
+                        os2_descent * px_per_unit,
+                        os2_line_gap * px_per_unit,
+                    };
+                }
 
-            if (os2_ascent != 0 or os2_descent != 0) {
+                const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
+                const win_descent: f64 = @floatFromInt(os2.usWinDescent);
                 break :vertical_metrics .{
-                    os2_ascent * px_per_unit,
-                    os2_descent * px_per_unit,
-                    os2_line_gap * px_per_unit,
+                    win_ascent * px_per_unit,
+                    // usWinDescent is *positive* -> down unlike sTypoDescender
+                    // and hhea.Descender, so we flip its sign to fix this.
+                    -win_descent * px_per_unit,
+                    0.0,
                 };
             }
 
-            const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
-            const win_descent: f64 = @floatFromInt(os2.usWinDescent);
+            // If our font has no OS/2 table, then we just
+            // blindly use the metrics from the hhea table.
             break :vertical_metrics .{
-                win_ascent * px_per_unit,
-                // usWinDescent is *positive* -> down unlike sTypoDescender
-                // and hhea.Descender, so we flip its sign to fix this.
-                -win_descent * px_per_unit,
-                0.0,
+                hhea_ascent * px_per_unit,
+                hhea_descent * px_per_unit,
+                hhea_line_gap * px_per_unit,
             };
         };
 
@@ -672,30 +679,46 @@ pub const Face = struct {
             @as(f64, @floatFromInt(post.underlineThickness)) * px_per_unit;
 
         // Similar logic to the underline above.
-        const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+        const strikethrough_position, const strikethrough_thickness = st: {
+            if (maybe_os2) |os2| {
+                const has_broken_strikethrough = os2.yStrikeoutSize == 0;
 
-        const strikethrough_position: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
-            null
-        else
-            @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+                const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+                    null
+                else
+                    @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
 
-        const strikethrough_thickness: ?f64 = if (has_broken_strikethrough)
-            null
-        else
-            @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+                const thick: ?f64 = if (has_broken_strikethrough)
+                    null
+                else
+                    @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
 
-        // We fall back to whatever CoreText does if
-        // the OS/2 table doesn't specify a cap height.
-        const cap_height: f64 = if (os2.sCapHeight) |sCapHeight|
-            @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
-        else
-            ct_font.getCapHeight();
+                break :st .{ pos, thick };
+            }
 
-        // Ditto for ex height.
-        const ex_height: f64 = if (os2.sxHeight) |sxHeight|
-            @as(f64, @floatFromInt(sxHeight)) * px_per_unit
-        else
-            ct_font.getXHeight();
+            break :st .{ null, null };
+        };
+
+        // We fall back to whatever CoreText does if the
+        // OS/2 table doesn't specify a cap or ex height.
+        const cap_height: f64, const ex_height: f64 = heights: {
+            if (maybe_os2) |os2| {
+                break :heights .{
+                    if (os2.sCapHeight) |sCapHeight|
+                        @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
+                    else
+                        ct_font.getCapHeight(),
+                    if (os2.sxHeight) |sxHeight|
+                        @as(f64, @floatFromInt(sxHeight)) * px_per_unit
+                    else
+                        ct_font.getXHeight(),
+                };
+            }
+            break :heights .{
+                ct_font.getCapHeight(),
+                ct_font.getXHeight(),
+            };
+        };
 
         // Cell width is calculated by calculating the widest width of the
         // visible ASCII characters. Usually 'M' is widest but we just take

commit 2b78ac4382c12686fa4aed7871db18256b48934c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 16 12:29:10 2024 -0800

    font: style edits for #2985

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 6389ba67..e1fd7429 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -568,14 +568,14 @@ pub const Face = struct {
         };
 
         // Read the 'OS/2' table out of the font data if it's available.
-        const maybe_os2: ?opentype.OS2 = os2: {
+        const os2_: ?opentype.OS2 = os2: {
             const tag = macos.text.FontTableTag.init("OS/2");
             const data = ct_font.copyTable(tag) orelse break :os2 null;
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();
             break :os2 opentype.OS2.init(ptr[0..len]) catch |err| {
-                log.warn("Error parsing OS/2 table: {any}", .{err});
+                log.warn("error parsing OS/2 table: {}", .{err});
                 break :os2 null;
             };
         };
@@ -603,19 +603,17 @@ pub const Face = struct {
             const hhea_descent: f64 = @floatFromInt(hhea.descender);
             const hhea_line_gap: f64 = @floatFromInt(hhea.lineGap);
 
-            if (maybe_os2) |os2| {
+            if (os2_) |os2| {
                 const os2_ascent: f64 = @floatFromInt(os2.sTypoAscender);
                 const os2_descent: f64 = @floatFromInt(os2.sTypoDescender);
                 const os2_line_gap: f64 = @floatFromInt(os2.sTypoLineGap);
 
                 // If the font says to use typo metrics, trust it.
-                if (os2.fsSelection.use_typo_metrics) {
-                    break :vertical_metrics .{
-                        os2_ascent * px_per_unit,
-                        os2_descent * px_per_unit,
-                        os2_line_gap * px_per_unit,
-                    };
-                }
+                if (os2.fsSelection.use_typo_metrics) break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
 
                 // Otherwise we prefer the height metrics from 'hhea' if they
                 // are available, or else OS/2 sTypo* metrics, and if all else
@@ -625,21 +623,17 @@ pub const Face = struct {
                 // account for fonts being... just weird. It's pretty much what
                 // FreeType does to get its generic ascent and descent metrics.
 
-                if (hhea.ascender != 0 or hhea.descender != 0) {
-                    break :vertical_metrics .{
-                        hhea_ascent * px_per_unit,
-                        hhea_descent * px_per_unit,
-                        hhea_line_gap * px_per_unit,
-                    };
-                }
+                if (hhea.ascender != 0 or hhea.descender != 0) break :vertical_metrics .{
+                    hhea_ascent * px_per_unit,
+                    hhea_descent * px_per_unit,
+                    hhea_line_gap * px_per_unit,
+                };
 
-                if (os2_ascent != 0 or os2_descent != 0) {
-                    break :vertical_metrics .{
-                        os2_ascent * px_per_unit,
-                        os2_descent * px_per_unit,
-                        os2_line_gap * px_per_unit,
-                    };
-                }
+                if (os2_ascent != 0 or os2_descent != 0) break :vertical_metrics .{
+                    os2_ascent * px_per_unit,
+                    os2_descent * px_per_unit,
+                    os2_line_gap * px_per_unit,
+                };
 
                 const win_ascent: f64 = @floatFromInt(os2.usWinAscent);
                 const win_descent: f64 = @floatFromInt(os2.usWinDescent);
@@ -680,44 +674,42 @@ pub const Face = struct {
 
         // Similar logic to the underline above.
         const strikethrough_position, const strikethrough_thickness = st: {
-            if (maybe_os2) |os2| {
-                const has_broken_strikethrough = os2.yStrikeoutSize == 0;
+            const os2 = os2_ orelse break :st .{ null, null };
 
-                const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
-                    null
-                else
-                    @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
+            const has_broken_strikethrough = os2.yStrikeoutSize == 0;
 
-                const thick: ?f64 = if (has_broken_strikethrough)
-                    null
-                else
-                    @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
+            const pos: ?f64 = if (has_broken_strikethrough and os2.yStrikeoutPosition == 0)
+                null
+            else
+                @as(f64, @floatFromInt(os2.yStrikeoutPosition)) * px_per_unit;
 
-                break :st .{ pos, thick };
-            }
+            const thick: ?f64 = if (has_broken_strikethrough)
+                null
+            else
+                @as(f64, @floatFromInt(os2.yStrikeoutSize)) * px_per_unit;
 
-            break :st .{ null, null };
+            break :st .{ pos, thick };
         };
 
         // We fall back to whatever CoreText does if the
         // OS/2 table doesn't specify a cap or ex height.
         const cap_height: f64, const ex_height: f64 = heights: {
-            if (maybe_os2) |os2| {
-                break :heights .{
-                    if (os2.sCapHeight) |sCapHeight|
-                        @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
-                    else
-                        ct_font.getCapHeight(),
-                    if (os2.sxHeight) |sxHeight|
-                        @as(f64, @floatFromInt(sxHeight)) * px_per_unit
-                    else
-                        ct_font.getXHeight(),
-                };
-            }
-            break :heights .{
+            const os2 = os2_ orelse break :heights .{
                 ct_font.getCapHeight(),
                 ct_font.getXHeight(),
             };
+
+            break :heights .{
+                if (os2.sCapHeight) |sCapHeight|
+                    @as(f64, @floatFromInt(sCapHeight)) * px_per_unit
+                else
+                    ct_font.getCapHeight(),
+
+                if (os2.sxHeight) |sxHeight|
+                    @as(f64, @floatFromInt(sxHeight)) * px_per_unit
+                else
+                    ct_font.getXHeight(),
+            };
         };
 
         // Cell width is calculated by calculating the widest width of the

commit 0e21293d43b345e0e9a1b950d35f86fa269bc5f6
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Thu Dec 19 13:44:30 2024 -0500

    font(coretext): improve atlas padding calculations
    
    - Simplifies and clarifies the math for how the bounding box for
    rendered glyphs is computed
    - Reduces margin from 2px between glyphs to 1px by only padding the
    bottom and right side of each glyph
    - Avoids excessive padding to glyph box when font thicken is enabled or
    when using a synthetic bold (it was previously 4x as much padding as
    necessary in some cases)

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index e1fd7429..885ea277 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -292,31 +292,45 @@ pub const Face = struct {
         var glyphs = [_]macos.graphics.Glyph{@intCast(glyph_index)};
 
         // Get the bounding rect for rendering this glyph.
-        const rect = self.font.getBoundingRectsForGlyphs(.horizontal, &glyphs, null);
-
-        // The x/y that we render the glyph at. The Y value has to be flipped
-        // because our coordinates in 3D space are (0, 0) bottom left with
-        // +y being up.
-        const render_x = @floor(rect.origin.x);
-        const render_y = @ceil(-rect.origin.y);
-
-        // The ascent is the amount of pixels above the baseline this glyph
-        // is rendered. The ascent can be calculated by adding the full
-        // glyph height to the origin.
-        const glyph_ascent = @ceil(rect.size.height + rect.origin.y);
+        // This is in a coordinate space with (0.0, 0.0)
+        // in the bottom left and +Y pointing up.
+        var rect = self.font.getBoundingRectsForGlyphs(.horizontal, &glyphs, null);
+
+        // If we're rendering a synthetic bold then we will gain 50% of
+        // the line width on every edge, which means we should increase
+        // our width and height by the line width and subtract half from
+        // our origin points.
+        if (self.synthetic_bold) |line_width| {
+            rect.size.width += line_width;
+            rect.size.height += line_width;
+            rect.origin.x -= line_width / 2;
+            rect.origin.y -= line_width / 2;
+        }
 
-        // The glyph height is basically rect.size.height but we do the
-        // ascent plus the descent because both are rounded elements that
-        // will make us more accurate.
-        const height: u32 = @intFromFloat(glyph_ascent + render_y);
+        // We make an assumption that font smoothing ("thicken")
+        // adds no more than 1 extra pixel to any edge. We don't
+        // add extra size if it's a sbix color font though, since
+        // bitmaps aren't affected by smoothing.
+        const sbix = self.color != null and self.color.?.sbix;
+        if (opts.thicken and !sbix) {
+            rect.size.width += 2.0;
+            rect.size.height += 2.0;
+            rect.origin.x -= 1.0;
+            rect.origin.y -= 1.0;
+        }
 
-        // The glyph width is our advertised bounding with plus the rounding
-        // difference from our rendering X.
-        const width: u32 = @intFromFloat(@ceil(rect.size.width + (rect.origin.x - render_x)));
+        // We compute the minimum and maximum x and y values.
+        // We round our min points down and max points up.
+        const x0: i32, const x1: i32, const y0: i32, const y1: i32 = .{
+            @intFromFloat(@floor(rect.origin.x)),
+            @intFromFloat(@ceil(rect.origin.x) + @ceil(rect.size.width)),
+            @intFromFloat(@floor(rect.origin.y)),
+            @intFromFloat(@ceil(rect.origin.y) + @ceil(rect.size.height)),
+        };
 
         // This bitmap is blank. I've seen it happen in a font, I don't know why.
         // If it is empty, we just return a valid glyph struct that does nothing.
-        if (width == 0 or height == 0) return font.Glyph{
+        if (x1 <= x0 or y1 <= y0) return font.Glyph{
             .width = 0,
             .height = 0,
             .offset_x = 0,
@@ -326,25 +340,8 @@ pub const Face = struct {
             .advance_x = 0,
         };
 
-        // Additional padding we need to add to the bitmap context itself
-        // due to the glyph being larger than standard.
-        const padding_ctx: u32 = padding_ctx: {
-            // If we're doing thicken, then getBoundsForGlyphs does not take
-            // into account the anti-aliasing that will be added to the glyph.
-            // We need to add some padding to allow that to happen. A padding of
-            // 2 is usually enough for anti-aliasing.
-            var result: u32 = if (opts.thicken) 2 else 0;
-
-            // If we have a synthetic bold, add padding for the stroke width
-            if (self.synthetic_bold) |line_width| {
-                // x2 for top and bottom padding
-                result += @intFromFloat(@ceil(line_width) * 2);
-            }
-
-            break :padding_ctx result;
-        };
-        const padded_width: u32 = width + (padding_ctx * 2);
-        const padded_height: u32 = height + (padding_ctx * 2);
+        const width: u32 = @intCast(x1 - x0);
+        const height: u32 = @intCast(y1 - y0);
 
         // Settings that are specific to if we are rendering text or emoji.
         const color: struct {
@@ -380,17 +377,17 @@ pub const Face = struct {
         // usually stabilizes pretty quickly and is very infrequent so I think
         // the allocation overhead is acceptable compared to the cost of
         // caching it forever or having to deal with a cache lifetime.
-        const buf = try alloc.alloc(u8, padded_width * padded_height * color.depth);
+        const buf = try alloc.alloc(u8, width * height * color.depth);
         defer alloc.free(buf);
         @memset(buf, 0);
 
         const context = macos.graphics.BitmapContext.context;
         const ctx = try macos.graphics.BitmapContext.create(
             buf,
-            padded_width,
-            padded_height,
+            width,
+            height,
             8,
-            padded_width * color.depth,
+            width * color.depth,
             color.space,
             color.context_opts,
         );
@@ -405,8 +402,8 @@ pub const Face = struct {
         context.fillRect(ctx, .{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
-                .width = @floatFromInt(padded_width),
-                .height = @floatFromInt(padded_height),
+                .width = @floatFromInt(width),
+                .height = @floatFromInt(height),
             },
         });
 
@@ -437,67 +434,57 @@ pub const Face = struct {
 
         // We want to render the glyphs at (0,0), but the glyphs themselves
         // are offset by bearings, so we have to undo those bearings in order
-        // to get them to 0,0. We also add the padding so that they render
-        // slightly off the edge of the bitmap.
-        const padding_ctx_f64: f64 = @floatFromInt(padding_ctx);
+        // to get them to 0,0.
         self.font.drawGlyphs(&glyphs, &.{
             .{
-                .x = -1 * (render_x - padding_ctx_f64),
-                .y = render_y + padding_ctx_f64,
+                .x = @floatFromInt(-x0),
+                .y = @floatFromInt(-y0),
             },
         }, ctx);
 
         const region = region: {
-            // We need to add a 1px padding to the font so that we don't
-            // get fuzzy issues when blending textures.
-            const padding = 1;
-
-            // Get the full padded region
+            // We reserve a region that's 1px wider and taller than we need
+            // in order to create a 1px separation between adjacent glyphs
+            // to prevent interpolation with adjacent glyphs while sampling
+            // from the atlas.
             var region = try atlas.reserve(
                 alloc,
-                padded_width + (padding * 2), // * 2 because left+right
-                padded_height + (padding * 2), // * 2 because top+bottom
+                width + 1,
+                height + 1,
             );
 
-            // Modify the region so that we remove the padding so that
-            // we write to the non-zero location. The data in an Altlas
-            // is always initialized to zero (Atlas.clear) so we don't
-            // need to worry about zero-ing that.
-            region.x += padding;
-            region.y += padding;
-            region.width -= padding * 2;
-            region.height -= padding * 2;
+            // We adjust the region width and height back down since we
+            // don't need the extra pixel, we just needed to reserve it
+            // so that it isn't used for other glyphs in the future.
+            region.width -= 1;
+            region.height -= 1;
             break :region region;
         };
         atlas.set(region, buf);
 
         const metrics = opts.grid_metrics orelse self.metrics;
-        const offset_y: i32 = offset_y: {
-            // Our Y coordinate in 3D is (0, 0) bottom left, +y is UP.
-            // We need to calculate our baseline from the bottom of a cell.
-            const baseline_from_bottom: f64 = @floatFromInt(metrics.cell_baseline);
-
-            // Next we offset our baseline by the bearing in the font. We
-            // ADD here because CoreText y is UP.
-            const baseline_with_offset = baseline_from_bottom + glyph_ascent;
-
-            // Add our context padding we may have created.
-            const baseline_with_padding = baseline_with_offset + padding_ctx_f64;
 
-            break :offset_y @intFromFloat(@ceil(baseline_with_padding));
-        };
+        // This should be the distance from the bottom of
+        // the cell to the top of the glyph's bounding box.
+        //
+        // The calculation is distance from bottom of cell to
+        // baseline plus distance from baseline to top of glyph.
+        const offset_y: i32 = @as(i32, @intCast(metrics.cell_baseline)) + y1;
 
+        // This should be the distance from the left of
+        // the cell to the left of the glyph's bounding box.
         const offset_x: i32 = offset_x: {
-            // Don't forget to apply our context padding if we have one
-            var result: i32 = @intFromFloat(render_x - padding_ctx_f64);
+            var result: i32 = x0;
 
-            // If our cell was resized to be wider then we center our
-            // glyph in the cell.
+            // If our cell was resized then we adjust our glyph's
+            // position relative to the new center. This keeps glyphs
+            // centered in the cell whether it was made wider or narrower.
             if (metrics.original_cell_width) |original_width| {
-                if (original_width < metrics.cell_width) {
-                    const diff = (metrics.cell_width - original_width) / 2;
-                    result += @intCast(diff);
-                }
+                const before: i32 = @intCast(original_width);
+                const after: i32 = @intCast(metrics.cell_width);
+                // Increase the offset by half of the difference
+                // between the widths to keep things centered.
+                result += @divTrunc(after - before, 2);
             }
 
             break :offset_x result;
@@ -507,21 +494,9 @@ pub const Face = struct {
         var advances: [glyphs.len]macos.graphics.Size = undefined;
         _ = self.font.getAdvancesForGlyphs(.horizontal, &glyphs, &advances);
 
-        // std.log.warn("renderGlyph rect={} width={} height={} render_x={} render_y={} offset_y={} ascent={} cell_height={} cell_baseline={}", .{
-        //     rect,
-        //     width,
-        //     height,
-        //     render_x,
-        //     render_y,
-        //     offset_y,
-        //     glyph_ascent,
-        //     self.metrics.cell_height,
-        //     self.metrics.cell_baseline,
-        // });
-
         return .{
-            .width = padded_width,
-            .height = padded_height,
+            .width = width,
+            .height = height,
             .offset_x = offset_x,
             .offset_y = offset_y,
             .atlas_x = region.x,

commit 3b6d8f3175badf13cdeb52cfe7509f58b96e5fbc
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Sun Dec 22 12:52:04 2024 -0500

    fix tests for coretext to include cursor_height

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 885ea277..92ab4d39 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -1045,6 +1045,7 @@ test "coretext: metrics" {
         .overline_position = 0,
         .overline_thickness = 1,
         .box_thickness = 1,
+        .cursor_height = 17,
     }, ct_font.metrics);
 
     // Resize should change metrics
@@ -1060,5 +1061,6 @@ test "coretext: metrics" {
         .overline_position = 0,
         .overline_thickness = 2,
         .box_thickness = 2,
+        .cursor_height = 34,
     }, ct_font.metrics);
 }

commit 7a4215abd7fff703a122e2f2f5afd270ed7b988a
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Dec 30 14:44:30 2024 -0500

    font/coretext: properly resolve metrics for bitmap-only fonts
    
    macOS bitmap-only fonts are a poorly documented format, which are often
    distributed as `.dfont` or `.dfon` files. They use a 'bhed' table in
    place of the usual 'head', but the table format is byte-identical, so
    enabling the use of bitmap-only fonts only requires us to properly fetch
    this table while calculating metrics.
    
    ref: https://fontforge.org/docs/techref/bitmaponlysfnt.html

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 92ab4d39..dd4f6432 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -515,8 +515,17 @@ pub const Face = struct {
     fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.face.Metrics {
         // Read the 'head' table out of the font data.
         const head: opentype.Head = head: {
-            const tag = macos.text.FontTableTag.init("head");
-            const data = ct_font.copyTable(tag) orelse return error.CopyTableError;
+            // macOS bitmap-only fonts use a 'bhed' tag rather than 'head', but
+            // the table format is byte-identical to the 'head' table, so if we
+            // can't find 'head' we try 'bhed' instead before failing.
+            //
+            // ref: https://fontforge.org/docs/techref/bitmaponlysfnt.html
+            const head_tag = macos.text.FontTableTag.init("head");
+            const bhed_tag = macos.text.FontTableTag.init("bhed");
+            const data =
+                ct_font.copyTable(head_tag) orelse
+                ct_font.copyTable(bhed_tag) orelse
+                return error.CopyTableError;
             defer data.release();
             const ptr = data.getPointer();
             const len = data.getLength();

commit 25a112469c7dabea552b33165868206d3caeeb5a
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Jan 3 14:19:19 2025 -0500

    font(coretext): add config to adjust strength of `font-thicken`.
    
    This is achieved by rendering to an alpha-only context rather than a
    normal single-channel context, and adjusting the brightness at which
    coretext thinks it's drawing the glyph, which affects how it applies
    font smoothing (which is what `font-thicken` enables).

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index dd4f6432..8da2b6a5 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -354,7 +354,7 @@ pub const Face = struct {
             .depth = 1,
             .space = try macos.graphics.ColorSpace.createDeviceGray(),
             .context_opts = @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
-                @intFromEnum(macos.graphics.ImageAlphaInfo.none),
+                @intFromEnum(macos.graphics.ImageAlphaInfo.only),
         } else .{
             .color = true,
             .depth = 4,
@@ -398,7 +398,7 @@ pub const Face = struct {
         if (color.color)
             context.setRGBFillColor(ctx, 1, 1, 1, 0)
         else
-            context.setGrayFillColor(ctx, 0, 0);
+            context.setGrayFillColor(ctx, 1, 0);
         context.fillRect(ctx, .{
             .origin = .{ .x = 0, .y = 0 },
             .size = .{
@@ -421,8 +421,9 @@ pub const Face = struct {
             context.setRGBFillColor(ctx, 1, 1, 1, 1);
             context.setRGBStrokeColor(ctx, 1, 1, 1, 1);
         } else {
-            context.setGrayFillColor(ctx, 1, 1);
-            context.setGrayStrokeColor(ctx, 1, 1);
+            const strength: f64 = @floatFromInt(opts.thicken_strength);
+            context.setGrayFillColor(ctx, strength / 255.0, 1);
+            context.setGrayStrokeColor(ctx, strength / 255.0, 1);
         }
 
         // If we are drawing with synthetic bold then use a fill stroke

commit 540fcc0b690901f185ca00465dafed2e9423b479
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 17:39:53 2025 -0500

    refactor(font): move `Metrics` out of `face`
    
    in preparation to move ownership of metrics from faces to collections

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 8da2b6a5..32077b8b 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -19,7 +19,7 @@ pub const Face = struct {
     hb_font: if (harfbuzz_shaper) harfbuzz.Font else void,
 
     /// Metrics for this font face. These are useful for renderers.
-    metrics: font.face.Metrics,
+    metrics: font.Metrics,
 
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
@@ -513,7 +513,7 @@ pub const Face = struct {
         InvalidHheaTable,
     };
 
-    fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.face.Metrics {
+    pub fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.Metrics {
         // Read the 'head' table out of the font data.
         const head: opentype.Head = head: {
             // macOS bitmap-only fonts use a 'bhed' tag rather than 'head', but
@@ -731,7 +731,7 @@ pub const Face = struct {
             break :cell_width max;
         };
 
-        return font.face.Metrics.calc(.{
+        return font.Metrics.calc(.{
             .cell_width = cell_width,
             .ascent = ascent,
             .descent = descent,
@@ -1032,7 +1032,7 @@ test "coretext: metrics" {
     );
     defer ct_font.deinit();
 
-    try std.testing.expectEqual(font.face.Metrics{
+    try std.testing.expectEqual(font.Metrics{
         .cell_width = 8,
         // The cell height is 17 px because the calculation is
         //
@@ -1060,7 +1060,7 @@ test "coretext: metrics" {
 
     // Resize should change metrics
     try ct_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
-    try std.testing.expectEqual(font.face.Metrics{
+    try std.testing.expectEqual(font.Metrics{
         .cell_width = 16,
         .cell_height = 34,
         .cell_baseline = 6,

commit 298aeb7536d69b8aef236569ee86ecfddd45d991
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 19:00:13 2025 -0500

    refactor(font): move ownership of `Metrics` to `Collection`
    
    This sets the stage for dynamically adjusting the sizes of fallback
    fonts based on the primary font's face metrics. It also removes a lot of
    unnecessary work when loading fallback fonts, since we only actually use
    the metrics based on the parimary font.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 32077b8b..6661295f 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -18,9 +18,6 @@ pub const Face = struct {
     /// if we're using Harfbuzz.
     hb_font: if (harfbuzz_shaper) harfbuzz.Font else void,
 
-    /// Metrics for this font face. These are useful for renderers.
-    metrics: font.Metrics,
-
     /// Set quirks.disableDefaultFontFeatures
     quirks_disable_default_font_features: bool = false,
 
@@ -87,11 +84,6 @@ pub const Face = struct {
     /// the CTFont. This does NOT copy or retain the CTFont.
     pub fn initFont(ct_font: *macos.text.Font, opts: font.face.Options) !Face {
         const traits = ct_font.getSymbolicTraits();
-        const metrics = metrics: {
-            var metrics = try calcMetrics(ct_font);
-            if (opts.metric_modifiers) |v| metrics.apply(v.*);
-            break :metrics metrics;
-        };
 
         var hb_font = if (comptime harfbuzz_shaper) font: {
             var hb_font = try harfbuzz.coretext.createFont(ct_font);
@@ -109,7 +101,6 @@ pub const Face = struct {
         var result: Face = .{
             .font = ct_font,
             .hb_font = hb_font,
-            .metrics = metrics,
             .color = color,
         };
         result.quirks_disable_default_font_features = quirks.disableDefaultFontFeatures(&result);
@@ -463,7 +454,7 @@ pub const Face = struct {
         };
         atlas.set(region, buf);
 
-        const metrics = opts.grid_metrics orelse self.metrics;
+        const metrics = opts.grid_metrics;
 
         // This should be the distance from the bottom of
         // the cell to the top of the glyph's bounding box.
@@ -506,14 +497,17 @@ pub const Face = struct {
         };
     }
 
-    const CalcMetricsError = error{
+    pub const GetMetricsError = error{
         CopyTableError,
         InvalidHeadTable,
         InvalidPostTable,
         InvalidHheaTable,
     };
 
-    pub fn calcMetrics(ct_font: *macos.text.Font) CalcMetricsError!font.Metrics {
+    /// Get the `FaceMetrics` for this face.
+    pub fn getMetrics(self: *Face) GetMetricsError!font.Metrics.FaceMetrics {
+        const ct_font = self.font;
+
         // Read the 'head' table out of the font data.
         const head: opentype.Head = head: {
             // macOS bitmap-only fonts use a 'bhed' tag rather than 'head', but
@@ -731,7 +725,7 @@ pub const Face = struct {
             break :cell_width max;
         };
 
-        return font.Metrics.calc(.{
+        return .{
             .cell_width = cell_width,
             .ascent = ascent,
             .descent = descent,
@@ -742,7 +736,7 @@ pub const Face = struct {
             .strikethrough_thickness = strikethrough_thickness,
             .cap_height = cap_height,
             .ex_height = ex_height,
-        });
+        };
     }
 
     /// Copy the font table data for the given tag.
@@ -866,7 +860,12 @@ test {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(
+            alloc,
+            &atlas,
+            face.glyphIndex(i).?,
+            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
+        );
     }
 }
 
@@ -926,7 +925,12 @@ test "in-memory" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(
+            alloc,
+            &atlas,
+            face.glyphIndex(i).?,
+            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
+        );
     }
 }
 
@@ -948,7 +952,12 @@ test "variable" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(
+            alloc,
+            &atlas,
+            face.glyphIndex(i).?,
+            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
+        );
     }
 }
 
@@ -974,7 +983,12 @@ test "variable set variation" {
     var i: u8 = 32;
     while (i < 127) : (i += 1) {
         try testing.expect(face.glyphIndex(i) != null);
-        _ = try face.renderGlyph(alloc, &atlas, face.glyphIndex(i).?, .{});
+        _ = try face.renderGlyph(
+            alloc,
+            &atlas,
+            face.glyphIndex(i).?,
+            .{ .grid_metrics = font.Metrics.calc(try face.getMetrics()) },
+        );
     }
 }
 
@@ -1017,60 +1031,3 @@ test "glyphIndex colored vs text" {
         try testing.expect(face.isColorGlyph(glyph));
     }
 }
-
-test "coretext: metrics" {
-    const testFont = font.embedded.inconsolata;
-    const alloc = std.testing.allocator;
-
-    var atlas = try font.Atlas.init(alloc, 512, .grayscale);
-    defer atlas.deinit(alloc);
-
-    var ct_font = try Face.init(
-        undefined,
-        testFont,
-        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
-    );
-    defer ct_font.deinit();
-
-    try std.testing.expectEqual(font.Metrics{
-        .cell_width = 8,
-        // The cell height is 17 px because the calculation is
-        //
-        //  ascender - descender + gap
-        //
-        // which, for inconsolata is
-        //
-        //  859 - -190 + 0
-        //
-        // font units, at 1000 units per em that works out to 1.049 em,
-        // and 1em should be the point size * dpi scale, so 12 * (96/72)
-        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
-        // to 17.
-        .cell_height = 17,
-        .cell_baseline = 3,
-        .underline_position = 17,
-        .underline_thickness = 1,
-        .strikethrough_position = 10,
-        .strikethrough_thickness = 1,
-        .overline_position = 0,
-        .overline_thickness = 1,
-        .box_thickness = 1,
-        .cursor_height = 17,
-    }, ct_font.metrics);
-
-    // Resize should change metrics
-    try ct_font.setSize(.{ .size = .{ .points = 24, .xdpi = 96, .ydpi = 96 } });
-    try std.testing.expectEqual(font.Metrics{
-        .cell_width = 16,
-        .cell_height = 34,
-        .cell_baseline = 6,
-        .underline_position = 34,
-        .underline_thickness = 2,
-        .strikethrough_position = 19,
-        .strikethrough_thickness = 2,
-        .overline_position = 0,
-        .overline_thickness = 2,
-        .box_thickness = 2,
-        .cursor_height = 34,
-    }, ct_font.metrics);
-}

commit fca336c32d6e6659b04803c7e3a1f1ad1378b840
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Fri Jan 10 13:43:02 2025 -0500

    Metal: blend in Display P3 color space, add option for linear blending
    
    This commit is quite large because it's fairly interconnected and can't
    be split up in a logical way. The main part of this commit is that alpha
    blending is now always done in the Display P3 color space, and depending
    on the configured `window-colorspace` colors will be converted from sRGB
    or assumed to already be Display P3 colors. In addition, a config option
    `text-blending` has been added which allows the user to configure linear
    blending (AKA "gamma correction"). Linear alpha blending also applies to
    images and makes custom shaders receive linear colors rather than sRGB.
    
    In addition, an experimental option has been added which corrects linear
    blending's tendency to make dark text look too thin and bright text look
    too thick. Essentially it's a correction curve on the alpha channel that
    depends on the luminance of the glyph being drawn.

diff --git a/src/font/face/coretext.zig b/src/font/face/coretext.zig
index 6661295f..3749b482 100644
--- a/src/font/face/coretext.zig
+++ b/src/font/face/coretext.zig
@@ -343,13 +343,12 @@ pub const Face = struct {
         } = if (!self.isColorGlyph(glyph_index)) .{
             .color = false,
             .depth = 1,
-            .space = try macos.graphics.ColorSpace.createDeviceGray(),
-            .context_opts = @intFromEnum(macos.graphics.BitmapInfo.alpha_mask) &
-                @intFromEnum(macos.graphics.ImageAlphaInfo.only),
+            .space = try macos.graphics.ColorSpace.createNamed(.linearGray),
+            .context_opts = @intFromEnum(macos.graphics.ImageAlphaInfo.only),
         } else .{
             .color = true,
             .depth = 4,
-            .space = try macos.graphics.ColorSpace.createDeviceRGB(),
+            .space = try macos.graphics.ColorSpace.createNamed(.displayP3),
             .context_opts = @intFromEnum(macos.graphics.BitmapInfo.byte_order_32_little) |
                 @intFromEnum(macos.graphics.ImageAlphaInfo.premultiplied_first),
         };

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    