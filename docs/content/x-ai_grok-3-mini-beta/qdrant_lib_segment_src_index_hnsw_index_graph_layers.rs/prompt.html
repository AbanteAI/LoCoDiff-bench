<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/index/hnsw_index/graph_layers.rs - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/index/hnsw_index/graph_layers.rs</h1>
        <p><a href="../../../cases/x-ai_grok-3-mini-beta/qdrant_lib_segment_src_index_hnsw_index_graph_layers.rs.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/index/hnsw_index/graph_layers.rs

commit 3616631300ab6d2b2a2cefb002ff567448710e06
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun May 30 17:14:42 2021 +0200

    Filtrable hnsw (#26)
    
    * raw points scorer
    
    * raw point scorer for memmap storage
    
    * search interface prepare
    
    * graph binary saving + store PointOffsetId as u32
    
    * WIP: entry points
    
    * connect new link method
    
    * update libs + search layer method + visited list + search context + update rust
    
    * implement Euclid metric + always use MinHeap for priority queue
    
    * small refactor
    
    * search for 0 level entry
    
    * update visited pool to be lock free and thread safe
    
    * use ef_construct from graph layer struct + limit visited links to M
    
    * add metric pre-processing before on vector upsert
    
    * old hnsw heuristic
    
    * save hnsw graph for export
    
    * search method + tests
    
    * small fixes
    
    * add benchmark and profiler
    
    * build time optimizations
    
    * use SeaHash
    
    * remove unsed benchmark
    
    * merge hnsw graph function
    
    * WIP:HNSW index build function
    
    * HNSW build_index with additional indexing
    
    * refactor fixtures
    
    * graph save and load test
    
    * test and fixes for filterable HNSW
    
    * enable hnsw index for query planning
    
    * fix cardinality estimation tests + remove query planner as class
    
    * small refactor
    
    * store full copy of collection settings with collection + allow partial override on creation #16
    
    * API for updating collection parameters #16
    
    * refactor: move collection error -> types
    
    * report collection status in info API #17
    
    * update OpenAPI Schema

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
new file mode 100644
index 000000000..fa516706e
--- /dev/null
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -0,0 +1,665 @@
+use serde::{Deserialize, Serialize};
+use crate::types::{PointOffsetType, ScoreType};
+use crate::spaces::tools::FixedLengthPriorityQueue;
+use std::cmp::{max, min};
+use std::path::{Path, PathBuf};
+use crate::entry::entry_point::OperationResult;
+use crate::common::file_operations::{read_bin, atomic_save_bin};
+use crate::index::hnsw_index::point_scorer::FilteredScorer;
+use crate::index::hnsw_index::entry_points::EntryPoints;
+use crate::vector_storage::vector_storage::ScoredPointOffset;
+use crate::index::visited_pool::{VisitedList, VisitedPool};
+use crate::index::hnsw_index::search_context::SearchContext;
+use crate::common::utils::rev_range;
+use rand::distributions::Uniform;
+use rand::prelude::ThreadRng;
+use rand::Rng;
+use std::collections::BinaryHeap;
+use itertools::Itertools;
+
+
+pub type LinkContainer = Vec<PointOffsetType>;
+pub type LayersContainer = Vec<LinkContainer>;
+
+pub const HNSW_GRAPH_FILE: &str = "graph.bin";
+
+#[derive(Deserialize, Serialize, Debug)]
+pub struct GraphLayers {
+    max_level: usize,
+    m: usize,
+    m0: usize,
+    ef_construct: usize,
+    level_factor: f64,
+    // Exclude points according to "not closer than base" heuristic?
+    use_heuristic: bool,
+    // Factor of level probability
+    links_layers: Vec<LayersContainer>,
+    entry_points: EntryPoints,
+
+    // Fields used on construction phase only
+    #[serde(skip)]
+    visited_pool: VisitedPool,
+}
+
+/// Object contains links between nodes for HNSW search
+///
+/// Assume all scores are similarities. Larger score = closer points
+impl GraphLayers {
+    pub fn new_with_params(
+        num_vectors: usize, // Initial number of points in index
+        m: usize, // Expected M for non-first layer
+        m0: usize, // Expected M for first layer
+        ef_construct: usize,
+        entry_points_num: usize, // Depends on number of points
+        use_heuristic: bool,
+        reserve: bool
+    ) -> Self {
+        let mut links_layers: Vec<LayersContainer> = vec![];
+
+        for _i in 0..num_vectors {
+            let mut links: LinkContainer = Vec::new();
+            if reserve {
+                links.reserve(m0);
+            }
+            links_layers.push(vec![links]);
+        }
+
+        GraphLayers {
+            max_level: 0,
+            m,
+            m0,
+            ef_construct,
+            level_factor: 1.0 / (m as f64).ln(),
+            use_heuristic,
+            links_layers,
+            entry_points: EntryPoints::new(entry_points_num),
+            visited_pool: VisitedPool::new(),
+        }
+    }
+
+    pub fn new(
+        num_vectors: usize, // Initial number of points in index
+        m: usize, // Expected M for non-first layer
+        m0: usize, // Expected M for first layer
+        ef_construct: usize,
+        entry_points_num: usize, // Depends on number of points
+        use_heuristic: bool,
+    ) -> Self {
+        Self::new_with_params(num_vectors, m, m0, ef_construct, entry_points_num, use_heuristic, true)
+    }
+
+    fn num_points(&self) -> usize { self.links_layers.len() }
+
+    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
+        self.links_layers[point_id as usize].len() - 1
+    }
+
+    /// Get links of current point
+    fn links(&self, point_id: PointOffsetType, level: usize) -> &LinkContainer {
+        &self.links_layers[point_id as usize][level]
+    }
+
+    /// Get M based on current level
+    fn get_m(&self, level: usize) -> usize {
+        return if level == 0 { self.m0 } else { self.m };
+    }
+
+    /// Generate random level for a new point, according to geometric distribution
+    pub fn get_random_layer(&self, thread_rng: &mut ThreadRng) -> usize {
+        let distribution = Uniform::new(0.0, 1.0);
+        let sample: f64 = thread_rng.sample(distribution);
+        let picked_level = -sample.ln() * self.level_factor;
+        return picked_level.round() as usize;
+    }
+
+    fn set_levels(&mut self, point_id: PointOffsetType, level: usize) {
+        if self.links_layers.len() <= point_id as usize {
+            self.links_layers.resize(point_id as usize, vec![]);
+        }
+        let point_layers = &mut self.links_layers[point_id as usize];
+        while point_layers.len() <= level {
+            let mut links = vec![];
+            links.reserve(self.m);
+            point_layers.push(links)
+        }
+        self.max_level = max(level, self.max_level);
+    }
+
+
+    /// Greedy search for closest points within a single graph layer
+    fn _search_on_level(&self, searcher: &mut SearchContext, level: usize, visited_list: &mut VisitedList, points_scorer: &FilteredScorer) {
+        while let Some(index) = searcher.candidates.pop() {
+            let mut links_iter = self.links(index, level)
+                .iter()
+                .cloned()
+                .filter(|point_id| !visited_list.check_and_update_visited(*point_id));
+
+            points_scorer.score_iterable_points(
+                &mut links_iter,
+                self.get_m(level),
+                |score_point| searcher.process_candidate(score_point),
+            );
+        }
+    }
+
+    fn search_on_level(&self, level_entry: ScoredPointOffset, level: usize, ef: usize, points_scorer: &FilteredScorer) -> FixedLengthPriorityQueue<ScoredPointOffset> {
+        let mut visited_list = self.visited_pool.get(self.num_points());
+        visited_list.check_and_update_visited(level_entry.idx);
+        let mut search_context = SearchContext::new(level_entry, ef);
+
+        self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
+
+        self.visited_pool.return_back(visited_list);
+        search_context.nearest
+    }
+
+
+    /// Greedy searches for entry point of level `target_level`.
+    /// Beam size is 1.
+    fn search_entry(&self, entry_point: PointOffsetType, top_level: usize, target_level: usize, points_scorer: &FilteredScorer) -> ScoredPointOffset {
+        let mut current_point = ScoredPointOffset {
+            idx: entry_point,
+            score: points_scorer.score_point(entry_point),
+        };
+        for level in rev_range(top_level, target_level) {
+            let mut changed = true;
+            while changed {
+                changed = false;
+                let mut links = self.links(current_point.idx, level).iter().cloned();
+                points_scorer.score_iterable_points(
+                    &mut links,
+                    self.get_m(level),
+                    |score_point| {
+                        if score_point.score > current_point.score {
+                            changed = true;
+                            current_point = score_point;
+                        }
+                    },
+                );
+            }
+        }
+        current_point
+    }
+
+    /// Connect new point to links, so that links contains only closest points
+    fn connect_new_point<F>(
+        links: &mut LinkContainer,
+        new_point_id: PointOffsetType,
+        target_point_id: PointOffsetType,
+        level_m: usize,
+        mut score_internal: F,
+    )
+        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType
+    {
+        // ToDo: binary search here ? (most likely does not worth it)
+        let new_to_target = score_internal(target_point_id, new_point_id);
+
+        let mut id_to_insert = links.len();
+        for i in 0..links.len() {
+            let target_to_link = score_internal(target_point_id, links[i]);
+            if target_to_link < new_to_target {
+                id_to_insert = i;
+                break;
+            }
+        }
+
+        if links.len() < level_m {
+            links.insert(id_to_insert, new_point_id)
+        } else {
+            if id_to_insert != links.len() {
+                links.pop();
+                links.insert(id_to_insert, new_point_id)
+            }
+        }
+    }
+
+    /// https://github.com/nmslib/hnswlib/issues/99
+    fn select_candidate_with_heuristic_from_sorted<F>(
+        candidates: impl Iterator<Item=ScoredPointOffset>,
+        m: usize,
+        mut score_internal: F,
+    ) -> Vec<PointOffsetType>
+        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType
+    {
+        let mut result_list = vec![];
+        result_list.reserve(m);
+        for current_closest in candidates {
+            if result_list.len() >= m { break; }
+            let mut is_good = true;
+            for selected_point in result_list.iter().cloned() {
+                let dist_to_already_selected = score_internal(current_closest.idx, selected_point);
+                if dist_to_already_selected > current_closest.score {
+                    is_good = false;
+                    break;
+                }
+            }
+            if is_good { result_list.push(current_closest.idx) }
+        }
+
+        result_list
+    }
+
+    /// https://github.com/nmslib/hnswlib/issues/99
+    fn select_candidates_with_heuristic<F>(
+        candidates: FixedLengthPriorityQueue<ScoredPointOffset>,
+        m: usize,
+        score_internal: F,
+    ) -> Vec<PointOffsetType>
+        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType {
+        let closest_iter = candidates.into_iter();
+        return Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal);
+    }
+
+    pub fn link_new_point(&mut self, point_id: PointOffsetType, level: usize, points_scorer: &FilteredScorer) {
+        // Check if there is an suitable entry point
+        //   - entry point level if higher or equal
+        //   - it satisfies filters
+
+        self.set_levels(point_id, level);
+
+        let entry_point_opt = self.entry_points.new_point(
+            point_id,
+            level,
+            |point_id| points_scorer.check_point(point_id),
+        );
+        match entry_point_opt {
+            // New point is a new empty entry (for this filter, at least)
+            // We can't do much here, so just quit
+            None => {}
+
+            // Entry point found.
+            Some(entry_point) => {
+                let mut level_entry = if entry_point.level > level {
+                    // The entry point is higher than a new point
+                    // Let's find closest one on same level
+
+                    // greedy search for a single closest point
+                    self.search_entry(
+                        entry_point.point_id,
+                        entry_point.level,
+                        level,
+                        points_scorer,
+                    )
+                } else {
+                    ScoredPointOffset {
+                        idx: entry_point.point_id,
+                        score: points_scorer.score_internal(point_id, entry_point.point_id),
+                    }
+                };
+                // minimal common level for entry points
+                let linking_level = min(level, entry_point.level);
+
+                let scorer = |a, b| points_scorer.score_internal(a, b);
+
+                for curr_level in (0..=linking_level).rev() {
+                    let level_m = self.get_m(curr_level);
+                    let nearest_points = self.search_on_level(
+                        level_entry, curr_level, self.ef_construct, points_scorer,
+                    );
+
+                    if self.use_heuristic {
+
+                        let selected_nearest = Self::select_candidates_with_heuristic(
+                            nearest_points, level_m, scorer);
+                        self.links_layers[point_id as usize][curr_level].clone_from(&selected_nearest);
+
+
+                        for other_point in selected_nearest.iter().cloned() {
+                            let other_point_links = &mut self.links_layers[other_point as usize][curr_level];
+                            if other_point_links.len() < level_m {
+                                // If linked point is lack of neighbours
+                                other_point_links.push(point_id);
+                            } else {
+                                let mut candidates = BinaryHeap::with_capacity(level_m + 1);
+                                candidates.push(ScoredPointOffset {
+                                    idx: point_id,
+                                    score: scorer(point_id, other_point),
+                                });
+                                for other_point_link in other_point_links.iter().take(level_m).cloned() {
+                                    candidates.push(ScoredPointOffset {
+                                        idx: other_point_link,
+                                        score: scorer(other_point_link, other_point),
+                                    });
+                                }
+                                let selected_candidates = Self::select_candidate_with_heuristic_from_sorted(
+                                    candidates.into_sorted_vec().into_iter().rev(),
+                                    level_m,
+                                    scorer,
+                                );
+                                for (idx, selected) in selected_candidates.iter().cloned().enumerate() {
+                                    other_point_links[idx] = selected;
+                                }
+                            }
+                        }
+                    } else {
+                        for nearest_point in nearest_points.iter() {
+                            Self::connect_new_point(
+                                &mut self.links_layers[point_id as usize][curr_level],
+                                nearest_point.idx,
+                                point_id,
+                                level_m,
+                                scorer,
+                            );
+
+                            Self::connect_new_point(
+                                &mut self.links_layers[nearest_point.idx as usize][curr_level],
+                                point_id,
+                                nearest_point.idx,
+                                level_m,
+                                scorer,
+                            );
+                            if nearest_point.score > level_entry.score {
+                                level_entry = nearest_point.clone()
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    pub fn merge_from_other(&mut self, other: GraphLayers) {
+        let mut visited_list = self.visited_pool.get(self.num_points());
+        if other.links_layers.len() > self.links_layers.len() {
+            self.links_layers.resize(other.links_layers.len(), vec![])
+        }
+        for (point_id, layers) in other.links_layers.into_iter().enumerate() {
+            let current_layers = &mut self.links_layers[point_id];
+            for (level, other_links) in layers.into_iter().enumerate() {
+                if current_layers.len() <= level {
+                    current_layers.push(other_links)
+                } else {
+                    visited_list.next_iteration();
+                    let current_links = &mut current_layers[level];
+                    current_links.iter().cloned().for_each(|x| {visited_list.check_and_update_visited(x);});
+                    for other_link in other_links.into_iter().filter(|x| !visited_list.check_and_update_visited(*x)) {
+                        current_links.push(other_link)
+                    }
+                }
+            }
+        }
+        self.entry_points.merge_from_other(other.entry_points);
+
+        self.visited_pool.return_back(visited_list);
+    }
+
+    pub fn search(&self, top: usize, ef: usize, points_scorer: &FilteredScorer) -> Vec<ScoredPointOffset> {
+        let entry_point = match self.entry_points.get_entry_point(|point_id| points_scorer.check_point(point_id)) {
+            None => return vec![],
+            Some(ep) => ep
+        };
+
+        let zero_level_entry = self.search_entry(
+            entry_point.point_id,
+            entry_point.level,
+            0,
+            points_scorer,
+        );
+
+        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer);
+        nearest.into_iter().take(top).collect_vec()
+    }
+
+    pub fn get_path(path: &Path) -> PathBuf {
+        path.join(HNSW_GRAPH_FILE)
+    }
+
+    pub fn load(path: &Path) -> OperationResult<Self> {
+        read_bin(path)
+    }
+
+    pub fn save(&self, path: &Path) -> OperationResult<()> {
+        atomic_save_bin(path, self)
+    }
+}
+
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::types::{VectorElementType, Distance};
+    use itertools::Itertools;
+    use rand::seq::SliceRandom;
+    use rand::thread_rng;
+    use crate::fixtures::index_fixtures::{TestRawScorerProducer, FakeConditionChecker, random_vector};
+    use std::fs::File;
+    use std::io::Write;
+    use ndarray::Array;
+    use tempdir::TempDir;
+
+    #[test]
+    fn test_connect_new_point() {
+        let num_points = 10;
+        let m = 6;
+        let ef_construct = 32;
+
+        // See illustration in docs
+        let points: Vec<Vec<VectorElementType>> = vec![
+            vec![21.79, 7.18],  // Target
+            vec![20.58, 5.46],  // 1  B - yes
+            vec![21.19, 4.51],  // 2  C
+            vec![24.73, 8.24],  // 3  D - yes
+            vec![24.55, 9.98],  // 4  E
+            vec![26.11, 6.85],  // 5  F
+            vec![17.64, 11.14], // 6  G - yes
+            vec![14.97, 11.52], // 7  I
+            vec![14.97, 9.60],  // 8  J
+            vec![16.23, 14.32], // 9  H
+            vec![12.69, 19.13], // 10 K
+        ];
+
+        let scorer = |a: PointOffsetType, b: PointOffsetType| {
+            -(
+                (points[a as usize][0] - points[b as usize][0]).powi(2) +
+                    (points[a as usize][1] - points[b as usize][1]).powi(2)
+            ).sqrt()
+        };
+
+        let mut insert_ids = (1..points.len() as PointOffsetType).collect_vec();
+
+        let mut candidates = FixedLengthPriorityQueue::new(insert_ids.len());
+        for id in insert_ids.iter().cloned() {
+            candidates.push(ScoredPointOffset {
+                idx: id,
+                score: scorer(0, id),
+            });
+        }
+
+        let res = GraphLayers::select_candidates_with_heuristic(
+            candidates, m, scorer,
+        );
+
+        assert_eq!(&res, &vec![1, 3, 6]);
+
+        let mut graph_layers = GraphLayers::new(num_points, m, m, ef_construct, 1, true);
+        insert_ids.shuffle(&mut thread_rng());
+        for id in insert_ids.iter().cloned() {
+            let level_m = graph_layers.get_m(0);
+            GraphLayers::connect_new_point(
+                &mut graph_layers.links_layers[0][0],
+                id,
+                0,
+                level_m,
+                scorer,
+            )
+        }
+        assert_eq!(graph_layers.links(0, 0), &vec![1, 2, 3, 4, 5, 6]);
+    }
+
+    fn search_in_graph(query: &Vec<VectorElementType>, top: usize, vector_storage: &TestRawScorerProducer, graph: &GraphLayers) -> Vec<ScoredPointOffset> {
+        let fake_condition_checker = FakeConditionChecker {};
+        let raw_scorer = vector_storage.get_raw_scorer(query.clone());
+        let scorer = FilteredScorer {
+            raw_scorer: &raw_scorer,
+            condition_checker: &fake_condition_checker,
+            filter: None,
+        };
+        let ef = 16;
+        graph.search(top, ef, &scorer)
+    }
+
+    const M: usize = 8;
+
+    fn create_graph_layer(num_vectors: usize, dim: usize, use_heuristic: bool) -> (TestRawScorerProducer, GraphLayers) {
+        let m = M;
+        let ef_construct = 16;
+        let entry_points_num = 10;
+
+        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Cosine);
+
+        let mut graph_layers = GraphLayers::new(
+            num_vectors, m, m * 2, ef_construct, entry_points_num, use_heuristic,
+        );
+
+        let mut rng = thread_rng();
+
+        for idx in 0..(num_vectors as PointOffsetType) {
+            let fake_condition_checker = FakeConditionChecker {};
+            let added_vector = vector_holder.vectors[idx as usize].to_vec();
+            let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
+            let scorer = FilteredScorer {
+                raw_scorer: &raw_scorer,
+                condition_checker: &fake_condition_checker,
+                filter: None,
+            };
+            let level = graph_layers.get_random_layer(&mut rng);
+            graph_layers.link_new_point(idx, level, &scorer);
+        }
+
+        (vector_holder, graph_layers)
+    }
+
+    #[test]
+    fn test_search_on_level() {
+        let dim = 8;
+        let m = 8;
+        let ef_construct = 32;
+        let entry_points_num = 10;
+        let num_vectors = 10;
+
+        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Dot);
+
+        let mut graph_layers = GraphLayers::new(
+            num_vectors, m, m * 2, ef_construct, entry_points_num, false,
+        );
+
+        graph_layers.links_layers[0][0] = vec![1, 2, 3, 4, 5, 6];
+
+        let linking_idx: PointOffsetType = 7;
+
+        let fake_condition_checker = FakeConditionChecker {};
+        let added_vector = vector_holder.vectors[linking_idx as usize].to_vec();
+        let raw_scorer = vector_holder.get_raw_scorer(added_vector);
+        let scorer = FilteredScorer {
+            raw_scorer: &raw_scorer,
+            condition_checker: &fake_condition_checker,
+            filter: None,
+        };
+
+        let nearest_on_level = graph_layers.search_on_level(
+            ScoredPointOffset {
+                idx: 0,
+                score: scorer.score_point(0),
+            },
+            0,
+            32,
+            &scorer,
+        );
+
+        assert_eq!(nearest_on_level.len(), graph_layers.links_layers[0][0].len() + 1);
+
+        for nearest in nearest_on_level.iter() {
+            // eprintln!("nearest = {:#?}", nearest);
+            assert_eq!(nearest.score, scorer.score_internal(linking_idx, nearest.idx))
+        }
+
+    }
+
+    #[test]
+    fn test_save_and_load() {
+        let num_vectors = 100;
+        let dim = 8;
+        let top = 5;
+
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false);
+
+        let mut rng = thread_rng();
+        let query = random_vector(&mut rng, dim);
+
+        let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
+
+        let dir = TempDir::new("graph_dir").unwrap();
+
+        let path = GraphLayers::get_path(dir.path());
+        graph_layers.save(&path).unwrap();
+
+        let graph2 = GraphLayers::load(&path).unwrap();
+
+        let res2 = search_in_graph(&query, top, &vector_holder, &graph2);
+
+        assert_eq!(res1, res2)
+    }
+
+    #[test]
+    fn test_add_points() {
+        let num_vectors = 1000;
+        let dim = 8;
+
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false);
+
+        let mut rng = thread_rng();
+
+        let main_entry = graph_layers.entry_points.get_entry_point(|_x| true)
+            .expect("Expect entry point to exists");
+
+        assert!(main_entry.level > 0);
+
+        let num_levels = graph_layers.links_layers
+            .iter()
+            .map(|x| x.len())
+            .max().unwrap();
+        assert_eq!(main_entry.level + 1, num_levels);
+
+        let total_links_0: usize = graph_layers.links_layers
+            .iter()
+            .map(|x| x[0].len()).sum();
+
+        assert!(total_links_0 > 0);
+
+        assert!(total_links_0 as f64 / num_vectors as f64 > M as f64);
+
+        let top = 5;
+        let query = random_vector(&mut rng, dim);
+        let processed_query = Array::from(vector_holder.metric.preprocess(query.clone()));
+        let mut reference_top = FixedLengthPriorityQueue::new(top);
+        for (idx, vec) in vector_holder.vectors.iter().enumerate() {
+            reference_top.push(
+                ScoredPointOffset {
+                    idx: idx as PointOffsetType,
+                    score: vector_holder.metric.blas_similarity(vec, &processed_query),
+                }
+            );
+        }
+
+        let graph_search = search_in_graph(&query, top, &vector_holder, &graph_layers);
+
+        assert_eq!(reference_top.into_vec(), graph_search);
+
+    }
+
+    #[test]
+    #[ignore]
+    fn test_draw_hnsw_graph() {
+        let dim = 2;
+        let num_vectors = 500;
+
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, true);
+
+        let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
+
+        let vectors_json = serde_json::to_string_pretty(&vector_holder.vectors.iter().map(|x| x.to_vec()).collect_vec()).unwrap();
+
+        let mut file = File::create("graph.json").unwrap();
+        file.write_all(format!("{{ \"graph\": {}, \n \"vectors\": {} }}", graph_json, vectors_json).as_bytes()).unwrap();
+    }
+}

commit e5cb4ee9fe646b0a3001b93a45d68fcdf1f0a508
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 6 22:20:45 2021 +0200

    fix slow HNSW search + fix looping in mmap optimizer + make segment removal atomic

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index fa516706e..8abd25f5a 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -128,8 +128,11 @@ impl GraphLayers {
 
     /// Greedy search for closest points within a single graph layer
     fn _search_on_level(&self, searcher: &mut SearchContext, level: usize, visited_list: &mut VisitedList, points_scorer: &FilteredScorer) {
-        while let Some(index) = searcher.candidates.pop() {
-            let mut links_iter = self.links(index, level)
+        while let Some(candidate) = searcher.candidates.pop() {
+            if candidate.score < searcher.lower_bound() {
+                break;
+            }
+            let mut links_iter = self.links(candidate.idx, level)
                 .iter()
                 .cloned()
                 .filter(|point_id| !visited_list.check_and_update_visited(*point_id));

commit cfc5beeac72aa041b8775b8cd425f8f7935105db
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jun 13 22:31:09 2021 +0200

    add payload schema to collection info + indexing fixes

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 8abd25f5a..f91d49ba3 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -52,7 +52,7 @@ impl GraphLayers {
         ef_construct: usize,
         entry_points_num: usize, // Depends on number of points
         use_heuristic: bool,
-        reserve: bool
+        reserve: bool,
     ) -> Self {
         let mut links_layers: Vec<LayersContainer> = vec![];
 
@@ -145,13 +145,29 @@ impl GraphLayers {
         }
     }
 
-    fn search_on_level(&self, level_entry: ScoredPointOffset, level: usize, ef: usize, points_scorer: &FilteredScorer) -> FixedLengthPriorityQueue<ScoredPointOffset> {
+    fn search_on_level(
+        &self,
+        level_entry: ScoredPointOffset,
+        level: usize,
+        ef: usize,
+        points_scorer: &FilteredScorer,
+        existing_links: &LinkContainer,
+    ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
         let mut visited_list = self.visited_pool.get(self.num_points());
         visited_list.check_and_update_visited(level_entry.idx);
         let mut search_context = SearchContext::new(level_entry, ef);
 
         self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
 
+        for existing_link in existing_links.iter().cloned() {
+            if !visited_list.check(existing_link) {
+                search_context.process_candidate(ScoredPointOffset {
+                    idx: existing_link,
+                    score: points_scorer.score_point(existing_link),
+                })
+            }
+        }
+
         self.visited_pool.return_back(visited_list);
         search_context.nearest
     }
@@ -296,12 +312,13 @@ impl GraphLayers {
 
                 for curr_level in (0..=linking_level).rev() {
                     let level_m = self.get_m(curr_level);
+                    let existing_links = &self.links_layers[point_id as usize][curr_level];
+
                     let nearest_points = self.search_on_level(
-                        level_entry, curr_level, self.ef_construct, points_scorer,
+                        level_entry, curr_level, self.ef_construct, points_scorer, existing_links,
                     );
 
                     if self.use_heuristic {
-
                         let selected_nearest = Self::select_candidates_with_heuristic(
                             nearest_points, level_m, scorer);
                         self.links_layers[point_id as usize][curr_level].clone_from(&selected_nearest);
@@ -374,7 +391,7 @@ impl GraphLayers {
                 } else {
                     visited_list.next_iteration();
                     let current_links = &mut current_layers[level];
-                    current_links.iter().cloned().for_each(|x| {visited_list.check_and_update_visited(x);});
+                    current_links.iter().cloned().for_each(|x| { visited_list.check_and_update_visited(x); });
                     for other_link in other_links.into_iter().filter(|x| !visited_list.check_and_update_visited(*x)) {
                         current_links.push(other_link)
                     }
@@ -399,7 +416,13 @@ impl GraphLayers {
             points_scorer,
         );
 
-        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer);
+        let nearest = self.search_on_level(
+            zero_level_entry,
+            0,
+            max(top, ef),
+            points_scorer,
+            &vec![],
+        );
         nearest.into_iter().take(top).collect_vec()
     }
 
@@ -567,6 +590,7 @@ mod tests {
             0,
             32,
             &scorer,
+            &vec![]
         );
 
         assert_eq!(nearest_on_level.len(), graph_layers.links_layers[0][0].len() + 1);
@@ -575,7 +599,6 @@ mod tests {
             // eprintln!("nearest = {:#?}", nearest);
             assert_eq!(nearest.score, scorer.score_internal(linking_idx, nearest.idx))
         }
-
     }
 
     #[test]
@@ -647,7 +670,6 @@ mod tests {
         let graph_search = search_in_graph(&query, top, &vector_holder, &graph_layers);
 
         assert_eq!(reference_top.into_vec(), graph_search);
-
     }
 
     #[test]

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index f91d49ba3..95e144342 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -1,22 +1,21 @@
-use serde::{Deserialize, Serialize};
-use crate::types::{PointOffsetType, ScoreType};
-use crate::spaces::tools::FixedLengthPriorityQueue;
-use std::cmp::{max, min};
-use std::path::{Path, PathBuf};
+use crate::common::file_operations::{atomic_save_bin, read_bin};
+use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
-use crate::common::file_operations::{read_bin, atomic_save_bin};
-use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::entry_points::EntryPoints;
-use crate::vector_storage::vector_storage::ScoredPointOffset;
-use crate::index::visited_pool::{VisitedList, VisitedPool};
+use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
-use crate::common::utils::rev_range;
+use crate::index::visited_pool::{VisitedList, VisitedPool};
+use crate::spaces::tools::FixedLengthPriorityQueue;
+use crate::types::{PointOffsetType, ScoreType};
+use crate::vector_storage::vector_storage::ScoredPointOffset;
+use itertools::Itertools;
 use rand::distributions::Uniform;
 use rand::prelude::ThreadRng;
 use rand::Rng;
+use serde::{Deserialize, Serialize};
+use std::cmp::{max, min};
 use std::collections::BinaryHeap;
-use itertools::Itertools;
-
+use std::path::{Path, PathBuf};
 
 pub type LinkContainer = Vec<PointOffsetType>;
 pub type LayersContainer = Vec<LinkContainer>;
@@ -47,8 +46,8 @@ pub struct GraphLayers {
 impl GraphLayers {
     pub fn new_with_params(
         num_vectors: usize, // Initial number of points in index
-        m: usize, // Expected M for non-first layer
-        m0: usize, // Expected M for first layer
+        m: usize,           // Expected M for non-first layer
+        m0: usize,          // Expected M for first layer
         ef_construct: usize,
         entry_points_num: usize, // Depends on number of points
         use_heuristic: bool,
@@ -79,16 +78,26 @@ impl GraphLayers {
 
     pub fn new(
         num_vectors: usize, // Initial number of points in index
-        m: usize, // Expected M for non-first layer
-        m0: usize, // Expected M for first layer
+        m: usize,           // Expected M for non-first layer
+        m0: usize,          // Expected M for first layer
         ef_construct: usize,
         entry_points_num: usize, // Depends on number of points
         use_heuristic: bool,
     ) -> Self {
-        Self::new_with_params(num_vectors, m, m0, ef_construct, entry_points_num, use_heuristic, true)
+        Self::new_with_params(
+            num_vectors,
+            m,
+            m0,
+            ef_construct,
+            entry_points_num,
+            use_heuristic,
+            true,
+        )
     }
 
-    fn num_points(&self) -> usize { self.links_layers.len() }
+    fn num_points(&self) -> usize {
+        self.links_layers.len()
+    }
 
     pub fn point_level(&self, point_id: PointOffsetType) -> usize {
         self.links_layers[point_id as usize].len() - 1
@@ -125,14 +134,20 @@ impl GraphLayers {
         self.max_level = max(level, self.max_level);
     }
 
-
     /// Greedy search for closest points within a single graph layer
-    fn _search_on_level(&self, searcher: &mut SearchContext, level: usize, visited_list: &mut VisitedList, points_scorer: &FilteredScorer) {
+    fn _search_on_level(
+        &self,
+        searcher: &mut SearchContext,
+        level: usize,
+        visited_list: &mut VisitedList,
+        points_scorer: &FilteredScorer,
+    ) {
         while let Some(candidate) = searcher.candidates.pop() {
             if candidate.score < searcher.lower_bound() {
                 break;
             }
-            let mut links_iter = self.links(candidate.idx, level)
+            let mut links_iter = self
+                .links(candidate.idx, level)
                 .iter()
                 .cloned()
                 .filter(|point_id| !visited_list.check_and_update_visited(*point_id));
@@ -172,10 +187,15 @@ impl GraphLayers {
         search_context.nearest
     }
 
-
     /// Greedy searches for entry point of level `target_level`.
     /// Beam size is 1.
-    fn search_entry(&self, entry_point: PointOffsetType, top_level: usize, target_level: usize, points_scorer: &FilteredScorer) -> ScoredPointOffset {
+    fn search_entry(
+        &self,
+        entry_point: PointOffsetType,
+        top_level: usize,
+        target_level: usize,
+        points_scorer: &FilteredScorer,
+    ) -> ScoredPointOffset {
         let mut current_point = ScoredPointOffset {
             idx: entry_point,
             score: points_scorer.score_point(entry_point),
@@ -185,16 +205,12 @@ impl GraphLayers {
             while changed {
                 changed = false;
                 let mut links = self.links(current_point.idx, level).iter().cloned();
-                points_scorer.score_iterable_points(
-                    &mut links,
-                    self.get_m(level),
-                    |score_point| {
-                        if score_point.score > current_point.score {
-                            changed = true;
-                            current_point = score_point;
-                        }
-                    },
-                );
+                points_scorer.score_iterable_points(&mut links, self.get_m(level), |score_point| {
+                    if score_point.score > current_point.score {
+                        changed = true;
+                        current_point = score_point;
+                    }
+                });
             }
         }
         current_point
@@ -207,8 +223,8 @@ impl GraphLayers {
         target_point_id: PointOffsetType,
         level_m: usize,
         mut score_internal: F,
-    )
-        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType
+    ) where
+        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
     {
         // ToDo: binary search here ? (most likely does not worth it)
         let new_to_target = score_internal(target_point_id, new_point_id);
@@ -234,16 +250,19 @@ impl GraphLayers {
 
     /// https://github.com/nmslib/hnswlib/issues/99
     fn select_candidate_with_heuristic_from_sorted<F>(
-        candidates: impl Iterator<Item=ScoredPointOffset>,
+        candidates: impl Iterator<Item = ScoredPointOffset>,
         m: usize,
         mut score_internal: F,
     ) -> Vec<PointOffsetType>
-        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType
+    where
+        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
     {
         let mut result_list = vec![];
         result_list.reserve(m);
         for current_closest in candidates {
-            if result_list.len() >= m { break; }
+            if result_list.len() >= m {
+                break;
+            }
             let mut is_good = true;
             for selected_point in result_list.iter().cloned() {
                 let dist_to_already_selected = score_internal(current_closest.idx, selected_point);
@@ -252,7 +271,9 @@ impl GraphLayers {
                     break;
                 }
             }
-            if is_good { result_list.push(current_closest.idx) }
+            if is_good {
+                result_list.push(current_closest.idx)
+            }
         }
 
         result_list
@@ -264,23 +285,28 @@ impl GraphLayers {
         m: usize,
         score_internal: F,
     ) -> Vec<PointOffsetType>
-        where F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType {
+    where
+        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
+    {
         let closest_iter = candidates.into_iter();
         return Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal);
     }
 
-    pub fn link_new_point(&mut self, point_id: PointOffsetType, level: usize, points_scorer: &FilteredScorer) {
+    pub fn link_new_point(
+        &mut self,
+        point_id: PointOffsetType,
+        level: usize,
+        points_scorer: &FilteredScorer,
+    ) {
         // Check if there is an suitable entry point
         //   - entry point level if higher or equal
         //   - it satisfies filters
 
         self.set_levels(point_id, level);
 
-        let entry_point_opt = self.entry_points.new_point(
-            point_id,
-            level,
-            |point_id| points_scorer.check_point(point_id),
-        );
+        let entry_point_opt = self.entry_points.new_point(point_id, level, |point_id| {
+            points_scorer.check_point(point_id)
+        });
         match entry_point_opt {
             // New point is a new empty entry (for this filter, at least)
             // We can't do much here, so just quit
@@ -315,17 +341,22 @@ impl GraphLayers {
                     let existing_links = &self.links_layers[point_id as usize][curr_level];
 
                     let nearest_points = self.search_on_level(
-                        level_entry, curr_level, self.ef_construct, points_scorer, existing_links,
+                        level_entry,
+                        curr_level,
+                        self.ef_construct,
+                        points_scorer,
+                        existing_links,
                     );
 
                     if self.use_heuristic {
-                        let selected_nearest = Self::select_candidates_with_heuristic(
-                            nearest_points, level_m, scorer);
-                        self.links_layers[point_id as usize][curr_level].clone_from(&selected_nearest);
-
+                        let selected_nearest =
+                            Self::select_candidates_with_heuristic(nearest_points, level_m, scorer);
+                        self.links_layers[point_id as usize][curr_level]
+                            .clone_from(&selected_nearest);
 
                         for other_point in selected_nearest.iter().cloned() {
-                            let other_point_links = &mut self.links_layers[other_point as usize][curr_level];
+                            let other_point_links =
+                                &mut self.links_layers[other_point as usize][curr_level];
                             if other_point_links.len() < level_m {
                                 // If linked point is lack of neighbours
                                 other_point_links.push(point_id);
@@ -335,18 +366,23 @@ impl GraphLayers {
                                     idx: point_id,
                                     score: scorer(point_id, other_point),
                                 });
-                                for other_point_link in other_point_links.iter().take(level_m).cloned() {
+                                for other_point_link in
+                                    other_point_links.iter().take(level_m).cloned()
+                                {
                                     candidates.push(ScoredPointOffset {
                                         idx: other_point_link,
                                         score: scorer(other_point_link, other_point),
                                     });
                                 }
-                                let selected_candidates = Self::select_candidate_with_heuristic_from_sorted(
-                                    candidates.into_sorted_vec().into_iter().rev(),
-                                    level_m,
-                                    scorer,
-                                );
-                                for (idx, selected) in selected_candidates.iter().cloned().enumerate() {
+                                let selected_candidates =
+                                    Self::select_candidate_with_heuristic_from_sorted(
+                                        candidates.into_sorted_vec().into_iter().rev(),
+                                        level_m,
+                                        scorer,
+                                    );
+                                for (idx, selected) in
+                                    selected_candidates.iter().cloned().enumerate()
+                                {
                                     other_point_links[idx] = selected;
                                 }
                             }
@@ -391,8 +427,13 @@ impl GraphLayers {
                 } else {
                     visited_list.next_iteration();
                     let current_links = &mut current_layers[level];
-                    current_links.iter().cloned().for_each(|x| { visited_list.check_and_update_visited(x); });
-                    for other_link in other_links.into_iter().filter(|x| !visited_list.check_and_update_visited(*x)) {
+                    current_links.iter().cloned().for_each(|x| {
+                        visited_list.check_and_update_visited(x);
+                    });
+                    for other_link in other_links
+                        .into_iter()
+                        .filter(|x| !visited_list.check_and_update_visited(*x))
+                    {
                         current_links.push(other_link)
                     }
                 }
@@ -403,26 +444,25 @@ impl GraphLayers {
         self.visited_pool.return_back(visited_list);
     }
 
-    pub fn search(&self, top: usize, ef: usize, points_scorer: &FilteredScorer) -> Vec<ScoredPointOffset> {
-        let entry_point = match self.entry_points.get_entry_point(|point_id| points_scorer.check_point(point_id)) {
+    pub fn search(
+        &self,
+        top: usize,
+        ef: usize,
+        points_scorer: &FilteredScorer,
+    ) -> Vec<ScoredPointOffset> {
+        let entry_point = match self
+            .entry_points
+            .get_entry_point(|point_id| points_scorer.check_point(point_id))
+        {
             None => return vec![],
-            Some(ep) => ep
+            Some(ep) => ep,
         };
 
-        let zero_level_entry = self.search_entry(
-            entry_point.point_id,
-            entry_point.level,
-            0,
-            points_scorer,
-        );
+        let zero_level_entry =
+            self.search_entry(entry_point.point_id, entry_point.level, 0, points_scorer);
 
-        let nearest = self.search_on_level(
-            zero_level_entry,
-            0,
-            max(top, ef),
-            points_scorer,
-            &vec![],
-        );
+        let nearest =
+            self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer, &vec![]);
         nearest.into_iter().take(top).collect_vec()
     }
 
@@ -439,18 +479,19 @@ impl GraphLayers {
     }
 }
 
-
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::types::{VectorElementType, Distance};
+    use crate::fixtures::index_fixtures::{
+        random_vector, FakeConditionChecker, TestRawScorerProducer,
+    };
+    use crate::types::{Distance, VectorElementType};
     use itertools::Itertools;
+    use ndarray::Array;
     use rand::seq::SliceRandom;
     use rand::thread_rng;
-    use crate::fixtures::index_fixtures::{TestRawScorerProducer, FakeConditionChecker, random_vector};
     use std::fs::File;
     use std::io::Write;
-    use ndarray::Array;
     use tempdir::TempDir;
 
     #[test]
@@ -475,10 +516,9 @@ mod tests {
         ];
 
         let scorer = |a: PointOffsetType, b: PointOffsetType| {
-            -(
-                (points[a as usize][0] - points[b as usize][0]).powi(2) +
-                    (points[a as usize][1] - points[b as usize][1]).powi(2)
-            ).sqrt()
+            -((points[a as usize][0] - points[b as usize][0]).powi(2)
+                + (points[a as usize][1] - points[b as usize][1]).powi(2))
+            .sqrt()
         };
 
         let mut insert_ids = (1..points.len() as PointOffsetType).collect_vec();
@@ -491,9 +531,7 @@ mod tests {
             });
         }
 
-        let res = GraphLayers::select_candidates_with_heuristic(
-            candidates, m, scorer,
-        );
+        let res = GraphLayers::select_candidates_with_heuristic(candidates, m, scorer);
 
         assert_eq!(&res, &vec![1, 3, 6]);
 
@@ -512,7 +550,12 @@ mod tests {
         assert_eq!(graph_layers.links(0, 0), &vec![1, 2, 3, 4, 5, 6]);
     }
 
-    fn search_in_graph(query: &Vec<VectorElementType>, top: usize, vector_storage: &TestRawScorerProducer, graph: &GraphLayers) -> Vec<ScoredPointOffset> {
+    fn search_in_graph(
+        query: &Vec<VectorElementType>,
+        top: usize,
+        vector_storage: &TestRawScorerProducer,
+        graph: &GraphLayers,
+    ) -> Vec<ScoredPointOffset> {
         let fake_condition_checker = FakeConditionChecker {};
         let raw_scorer = vector_storage.get_raw_scorer(query.clone());
         let scorer = FilteredScorer {
@@ -526,7 +569,11 @@ mod tests {
 
     const M: usize = 8;
 
-    fn create_graph_layer(num_vectors: usize, dim: usize, use_heuristic: bool) -> (TestRawScorerProducer, GraphLayers) {
+    fn create_graph_layer(
+        num_vectors: usize,
+        dim: usize,
+        use_heuristic: bool,
+    ) -> (TestRawScorerProducer, GraphLayers) {
         let m = M;
         let ef_construct = 16;
         let entry_points_num = 10;
@@ -534,7 +581,12 @@ mod tests {
         let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Cosine);
 
         let mut graph_layers = GraphLayers::new(
-            num_vectors, m, m * 2, ef_construct, entry_points_num, use_heuristic,
+            num_vectors,
+            m,
+            m * 2,
+            ef_construct,
+            entry_points_num,
+            use_heuristic,
         );
 
         let mut rng = thread_rng();
@@ -565,9 +617,8 @@ mod tests {
 
         let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Dot);
 
-        let mut graph_layers = GraphLayers::new(
-            num_vectors, m, m * 2, ef_construct, entry_points_num, false,
-        );
+        let mut graph_layers =
+            GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num, false);
 
         graph_layers.links_layers[0][0] = vec![1, 2, 3, 4, 5, 6];
 
@@ -590,14 +641,20 @@ mod tests {
             0,
             32,
             &scorer,
-            &vec![]
+            &vec![],
         );
 
-        assert_eq!(nearest_on_level.len(), graph_layers.links_layers[0][0].len() + 1);
+        assert_eq!(
+            nearest_on_level.len(),
+            graph_layers.links_layers[0][0].len() + 1
+        );
 
         for nearest in nearest_on_level.iter() {
             // eprintln!("nearest = {:#?}", nearest);
-            assert_eq!(nearest.score, scorer.score_internal(linking_idx, nearest.idx))
+            assert_eq!(
+                nearest.score,
+                scorer.score_internal(linking_idx, nearest.idx)
+            )
         }
     }
 
@@ -635,20 +692,22 @@ mod tests {
 
         let mut rng = thread_rng();
 
-        let main_entry = graph_layers.entry_points.get_entry_point(|_x| true)
+        let main_entry = graph_layers
+            .entry_points
+            .get_entry_point(|_x| true)
             .expect("Expect entry point to exists");
 
         assert!(main_entry.level > 0);
 
-        let num_levels = graph_layers.links_layers
+        let num_levels = graph_layers
+            .links_layers
             .iter()
             .map(|x| x.len())
-            .max().unwrap();
+            .max()
+            .unwrap();
         assert_eq!(main_entry.level + 1, num_levels);
 
-        let total_links_0: usize = graph_layers.links_layers
-            .iter()
-            .map(|x| x[0].len()).sum();
+        let total_links_0: usize = graph_layers.links_layers.iter().map(|x| x[0].len()).sum();
 
         assert!(total_links_0 > 0);
 
@@ -659,12 +718,10 @@ mod tests {
         let processed_query = Array::from(vector_holder.metric.preprocess(query.clone()));
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
-            reference_top.push(
-                ScoredPointOffset {
-                    idx: idx as PointOffsetType,
-                    score: vector_holder.metric.blas_similarity(vec, &processed_query),
-                }
-            );
+            reference_top.push(ScoredPointOffset {
+                idx: idx as PointOffsetType,
+                score: vector_holder.metric.blas_similarity(vec, &processed_query),
+            });
         }
 
         let graph_search = search_in_graph(&query, top, &vector_holder, &graph_layers);
@@ -682,9 +739,23 @@ mod tests {
 
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 
-        let vectors_json = serde_json::to_string_pretty(&vector_holder.vectors.iter().map(|x| x.to_vec()).collect_vec()).unwrap();
+        let vectors_json = serde_json::to_string_pretty(
+            &vector_holder
+                .vectors
+                .iter()
+                .map(|x| x.to_vec())
+                .collect_vec(),
+        )
+        .unwrap();
 
         let mut file = File::create("graph.json").unwrap();
-        file.write_all(format!("{{ \"graph\": {}, \n \"vectors\": {} }}", graph_json, vectors_json).as_bytes()).unwrap();
+        file.write_all(
+            format!(
+                "{{ \"graph\": {}, \n \"vectors\": {} }}",
+                graph_json, vectors_json
+            )
+            .as_bytes(),
+        )
+        .unwrap();
     }
 }

commit d796c9da42377f11ae15b6941baa53963bda27ab
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 14:17:04 2021 +0100

    Avoid useless vector copy during scoring (#51)
    
    * Avoid vector copy during scoring
    
    * Fixing ptr_arg clippy rules for &[VectorElementType]

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 95e144342..d8e842cdd 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -551,13 +551,13 @@ mod tests {
     }
 
     fn search_in_graph(
-        query: &Vec<VectorElementType>,
+        query: &[VectorElementType],
         top: usize,
         vector_storage: &TestRawScorerProducer,
         graph: &GraphLayers,
     ) -> Vec<ScoredPointOffset> {
         let fake_condition_checker = FakeConditionChecker {};
-        let raw_scorer = vector_storage.get_raw_scorer(query.clone());
+        let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
         let scorer = FilteredScorer {
             raw_scorer: &raw_scorer,
             condition_checker: &fake_condition_checker,
@@ -715,7 +715,12 @@ mod tests {
 
         let top = 5;
         let query = random_vector(&mut rng, dim);
-        let processed_query = Array::from(vector_holder.metric.preprocess(query.clone()));
+        let processed_query = Array::from(
+            vector_holder
+                .metric
+                .preprocess(&query)
+                .unwrap_or_else(|| query.clone()),
+        );
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
             reference_top.push(ScoredPointOffset {

commit 0e1a6e17507d56e7f6a7f764e7fa56a494753d4d
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 16:51:54 2021 +0100

    [Clippy] Fix a range of warnings (#52)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d8e842cdd..03d0b4020 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -110,7 +110,11 @@ impl GraphLayers {
 
     /// Get M based on current level
     fn get_m(&self, level: usize) -> usize {
-        return if level == 0 { self.m0 } else { self.m };
+        if level == 0 {
+            self.m0
+        } else {
+            self.m
+        }
     }
 
     /// Generate random level for a new point, according to geometric distribution
@@ -118,7 +122,7 @@ impl GraphLayers {
         let distribution = Uniform::new(0.0, 1.0);
         let sample: f64 = thread_rng.sample(distribution);
         let picked_level = -sample.ln() * self.level_factor;
-        return picked_level.round() as usize;
+        picked_level.round() as usize
     }
 
     fn set_levels(&mut self, point_id: PointOffsetType, level: usize) {
@@ -230,8 +234,8 @@ impl GraphLayers {
         let new_to_target = score_internal(target_point_id, new_point_id);
 
         let mut id_to_insert = links.len();
-        for i in 0..links.len() {
-            let target_to_link = score_internal(target_point_id, links[i]);
+        for (i, &item) in links.iter().enumerate() {
+            let target_to_link = score_internal(target_point_id, item);
             if target_to_link < new_to_target {
                 id_to_insert = i;
                 break;
@@ -240,11 +244,9 @@ impl GraphLayers {
 
         if links.len() < level_m {
             links.insert(id_to_insert, new_point_id)
-        } else {
-            if id_to_insert != links.len() {
-                links.pop();
-                links.insert(id_to_insert, new_point_id)
-            }
+        } else if id_to_insert != links.len() {
+            links.pop();
+            links.insert(id_to_insert, new_point_id)
         }
     }
 
@@ -289,7 +291,7 @@ impl GraphLayers {
         F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
     {
         let closest_iter = candidates.into_iter();
-        return Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal);
+        Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal)
     }
 
     pub fn link_new_point(
@@ -405,7 +407,7 @@ impl GraphLayers {
                                 scorer,
                             );
                             if nearest_point.score > level_entry.score {
-                                level_entry = nearest_point.clone()
+                                level_entry = *nearest_point
                             }
                         }
                     }

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 03d0b4020..bbbd3e5ea 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -7,7 +7,7 @@ use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedList, VisitedPool};
 use crate::spaces::tools::FixedLengthPriorityQueue;
 use crate::types::{PointOffsetType, ScoreType};
-use crate::vector_storage::vector_storage::ScoredPointOffset;
+use crate::vector_storage::ScoredPointOffset;
 use itertools::Itertools;
 use rand::distributions::Uniform;
 use rand::prelude::ThreadRng;
@@ -18,6 +18,7 @@ use std::collections::BinaryHeap;
 use std::path::{Path, PathBuf};
 
 pub type LinkContainer = Vec<PointOffsetType>;
+pub type LinkContainerRef<'a> = &'a [PointOffsetType];
 pub type LayersContainer = Vec<LinkContainer>;
 
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";
@@ -104,7 +105,7 @@ impl GraphLayers {
     }
 
     /// Get links of current point
-    fn links(&self, point_id: PointOffsetType, level: usize) -> &LinkContainer {
+    fn links(&self, point_id: PointOffsetType, level: usize) -> LinkContainerRef {
         &self.links_layers[point_id as usize][level]
     }
 
@@ -170,7 +171,7 @@ impl GraphLayers {
         level: usize,
         ef: usize,
         points_scorer: &FilteredScorer,
-        existing_links: &LinkContainer,
+        existing_links: LinkContainerRef,
     ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
         let mut visited_list = self.visited_pool.get(self.num_points());
         visited_list.check_and_update_visited(level_entry.idx);
@@ -290,7 +291,7 @@ impl GraphLayers {
     where
         F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
     {
-        let closest_iter = candidates.into_iter();
+        let closest_iter = candidates.into_iterator();
         Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal)
     }
 
@@ -463,9 +464,8 @@ impl GraphLayers {
         let zero_level_entry =
             self.search_entry(entry_point.point_id, entry_point.level, 0, points_scorer);
 
-        let nearest =
-            self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer, &vec![]);
-        nearest.into_iter().take(top).collect_vec()
+        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer, &[]);
+        nearest.into_iterator().take(top).collect_vec()
     }
 
     pub fn get_path(path: &Path) -> PathBuf {

commit 370d16d8787e25b06cb3464c7e0c1e132cb5f8c1
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Oct 11 20:41:04 2021 +0200

    use seeded random number generator in search graph tests

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index bbbd3e5ea..7fbeecce1 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -10,7 +10,6 @@ use crate::types::{PointOffsetType, ScoreType};
 use crate::vector_storage::ScoredPointOffset;
 use itertools::Itertools;
 use rand::distributions::Uniform;
-use rand::prelude::ThreadRng;
 use rand::Rng;
 use serde::{Deserialize, Serialize};
 use std::cmp::{max, min};
@@ -119,9 +118,12 @@ impl GraphLayers {
     }
 
     /// Generate random level for a new point, according to geometric distribution
-    pub fn get_random_layer(&self, thread_rng: &mut ThreadRng) -> usize {
+    pub fn get_random_layer<R>(&self, rng: &mut R) -> usize
+    where
+        R: Rng + ?Sized,
+    {
         let distribution = Uniform::new(0.0, 1.0);
-        let sample: f64 = thread_rng.sample(distribution);
+        let sample: f64 = rng.sample(distribution);
         let picked_level = -sample.ln() * self.level_factor;
         picked_level.round() as usize
     }
@@ -490,8 +492,9 @@ mod tests {
     use crate::types::{Distance, VectorElementType};
     use itertools::Itertools;
     use ndarray::Array;
+    use rand::rngs::StdRng;
     use rand::seq::SliceRandom;
-    use rand::thread_rng;
+    use rand::SeedableRng;
     use std::fs::File;
     use std::io::Write;
     use tempdir::TempDir;
@@ -537,8 +540,10 @@ mod tests {
 
         assert_eq!(&res, &vec![1, 3, 6]);
 
+        let mut rng = StdRng::seed_from_u64(42);
+
         let mut graph_layers = GraphLayers::new(num_points, m, m, ef_construct, 1, true);
-        insert_ids.shuffle(&mut thread_rng());
+        insert_ids.shuffle(&mut rng);
         for id in insert_ids.iter().cloned() {
             let level_m = graph_layers.get_m(0);
             GraphLayers::connect_new_point(
@@ -571,11 +576,15 @@ mod tests {
 
     const M: usize = 8;
 
-    fn create_graph_layer(
+    fn create_graph_layer<R>(
         num_vectors: usize,
         dim: usize,
         use_heuristic: bool,
-    ) -> (TestRawScorerProducer, GraphLayers) {
+        rng: &mut R,
+    ) -> (TestRawScorerProducer, GraphLayers)
+    where
+        R: Rng + ?Sized,
+    {
         let m = M;
         let ef_construct = 16;
         let entry_points_num = 10;
@@ -591,8 +600,6 @@ mod tests {
             use_heuristic,
         );
 
-        let mut rng = thread_rng();
-
         for idx in 0..(num_vectors as PointOffsetType) {
             let fake_condition_checker = FakeConditionChecker {};
             let added_vector = vector_holder.vectors[idx as usize].to_vec();
@@ -602,7 +609,7 @@ mod tests {
                 condition_checker: &fake_condition_checker,
                 filter: None,
             };
-            let level = graph_layers.get_random_layer(&mut rng);
+            let level = graph_layers.get_random_layer(rng);
             graph_layers.link_new_point(idx, level, &scorer);
         }
 
@@ -666,9 +673,10 @@ mod tests {
         let dim = 8;
         let top = 5;
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false);
+        let mut rng = StdRng::seed_from_u64(42);
+
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false, &mut rng);
 
-        let mut rng = thread_rng();
         let query = random_vector(&mut rng, dim);
 
         let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
@@ -690,9 +698,9 @@ mod tests {
         let num_vectors = 1000;
         let dim = 8;
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false);
+        let mut rng = StdRng::seed_from_u64(42);
 
-        let mut rng = thread_rng();
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false, &mut rng);
 
         let main_entry = graph_layers
             .entry_points
@@ -742,7 +750,9 @@ mod tests {
         let dim = 2;
         let num_vectors = 500;
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, true);
+        let mut rng = StdRng::seed_from_u64(42);
+
+        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, true, &mut rng);
 
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 

commit ab58a41a1128bd2d124c454850d22749d516ba7c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Oct 12 22:05:16 2021 +0200

    fix seeded rng in caused blinking test

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 7fbeecce1..bdaf0c0e4 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -589,7 +589,7 @@ mod tests {
         let ef_construct = 16;
         let entry_points_num = 10;
 
-        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Cosine);
+        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Cosine, rng);
 
         let mut graph_layers = GraphLayers::new(
             num_vectors,
@@ -624,7 +624,9 @@ mod tests {
         let entry_points_num = 10;
         let num_vectors = 10;
 
-        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Dot);
+        let mut rng = StdRng::seed_from_u64(42);
+
+        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Dot, &mut rng);
 
         let mut graph_layers =
             GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num, false);

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index bdaf0c0e4..befb54cbf 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -181,7 +181,7 @@ impl GraphLayers {
 
         self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
 
-        for existing_link in existing_links.iter().cloned() {
+        for &existing_link in existing_links {
             if !visited_list.check(existing_link) {
                 search_context.process_candidate(ScoredPointOffset {
                     idx: existing_link,
@@ -269,7 +269,7 @@ impl GraphLayers {
                 break;
             }
             let mut is_good = true;
-            for selected_point in result_list.iter().cloned() {
+            for &selected_point in &result_list {
                 let dist_to_already_selected = score_internal(current_closest.idx, selected_point);
                 if dist_to_already_selected > current_closest.score {
                     is_good = false;
@@ -293,7 +293,7 @@ impl GraphLayers {
     where
         F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
     {
-        let closest_iter = candidates.into_iterator();
+        let closest_iter = candidates.into_iter();
         Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal)
     }
 
@@ -359,7 +359,7 @@ impl GraphLayers {
                         self.links_layers[point_id as usize][curr_level]
                             .clone_from(&selected_nearest);
 
-                        for other_point in selected_nearest.iter().cloned() {
+                        for &other_point in &selected_nearest {
                             let other_point_links =
                                 &mut self.links_layers[other_point as usize][curr_level];
                             if other_point_links.len() < level_m {
@@ -393,7 +393,7 @@ impl GraphLayers {
                             }
                         }
                     } else {
-                        for nearest_point in nearest_points.iter() {
+                        for nearest_point in &nearest_points {
                             Self::connect_new_point(
                                 &mut self.links_layers[point_id as usize][curr_level],
                                 nearest_point.idx,
@@ -467,7 +467,7 @@ impl GraphLayers {
             self.search_entry(entry_point.point_id, entry_point.level, 0, points_scorer);
 
         let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer, &[]);
-        nearest.into_iterator().take(top).collect_vec()
+        nearest.into_iter().take(top).collect_vec()
     }
 
     pub fn get_path(path: &Path) -> PathBuf {
@@ -529,7 +529,7 @@ mod tests {
         let mut insert_ids = (1..points.len() as PointOffsetType).collect_vec();
 
         let mut candidates = FixedLengthPriorityQueue::new(insert_ids.len());
-        for id in insert_ids.iter().cloned() {
+        for &id in &insert_ids {
             candidates.push(ScoredPointOffset {
                 idx: id,
                 score: scorer(0, id),
@@ -544,7 +544,7 @@ mod tests {
 
         let mut graph_layers = GraphLayers::new(num_points, m, m, ef_construct, 1, true);
         insert_ids.shuffle(&mut rng);
-        for id in insert_ids.iter().cloned() {
+        for &id in &insert_ids {
             let level_m = graph_layers.get_m(0);
             GraphLayers::connect_new_point(
                 &mut graph_layers.links_layers[0][0],
@@ -652,7 +652,7 @@ mod tests {
             0,
             32,
             &scorer,
-            &vec![],
+            &[],
         );
 
         assert_eq!(
@@ -660,7 +660,7 @@ mod tests {
             graph_layers.links_layers[0][0].len() + 1
         );
 
-        for nearest in nearest_on_level.iter() {
+        for nearest in &nearest_on_level {
             // eprintln!("nearest = {:#?}", nearest);
             assert_eq!(
                 nearest.score,

commit bcaa160ad8658fa4052aae4a854686379b1e35d7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 31 11:38:33 2021 +0300

    Remove dyn Metric from vector storage and use generics (#163)
    
    * Remove dyn Metric from vector storage and use generics
    
    * upd benchmark code
    
    * fix benchmark usage
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index befb54cbf..d8f47bcb2 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -489,7 +489,9 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeConditionChecker, TestRawScorerProducer,
     };
-    use crate::types::{Distance, VectorElementType};
+    use crate::spaces::metric::Metric;
+    use crate::spaces::simple::{CosineMetric, DotProductMetric};
+    use crate::types::VectorElementType;
     use itertools::Itertools;
     use ndarray::Array;
     use rand::rngs::StdRng;
@@ -560,7 +562,7 @@ mod tests {
     fn search_in_graph(
         query: &[VectorElementType],
         top: usize,
-        vector_storage: &TestRawScorerProducer,
+        vector_storage: &TestRawScorerProducer<CosineMetric>,
         graph: &GraphLayers,
     ) -> Vec<ScoredPointOffset> {
         let fake_condition_checker = FakeConditionChecker {};
@@ -581,7 +583,7 @@ mod tests {
         dim: usize,
         use_heuristic: bool,
         rng: &mut R,
-    ) -> (TestRawScorerProducer, GraphLayers)
+    ) -> (TestRawScorerProducer<CosineMetric>, GraphLayers)
     where
         R: Rng + ?Sized,
     {
@@ -589,7 +591,7 @@ mod tests {
         let ef_construct = 16;
         let entry_points_num = 10;
 
-        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Cosine, rng);
+        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, CosineMetric {}, rng);
 
         let mut graph_layers = GraphLayers::new(
             num_vectors,
@@ -626,7 +628,8 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, Distance::Dot, &mut rng);
+        let vector_holder =
+            TestRawScorerProducer::new(dim, num_vectors, DotProductMetric {}, &mut rng);
 
         let mut graph_layers =
             GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num, false);

commit 297f54141d82fe4923847715a6253bb804f28022
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Jan 3 22:16:27 2022 +0300

    remove blas

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d8f47bcb2..4151850ba 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -740,7 +740,7 @@ mod tests {
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
             reference_top.push(ScoredPointOffset {
                 idx: idx as PointOffsetType,
-                score: vector_holder.metric.blas_similarity(vec, &processed_query),
+                score: vector_holder.metric.similarity(vec, &processed_query),
             });
         }
 

commit 70e376bf5e1513cdca5f3e66a255d13925347427
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 00:32:13 2022 +0300

    add avx2 implementation

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 4151850ba..eca387e88 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -493,7 +493,6 @@ mod tests {
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
     use crate::types::VectorElementType;
     use itertools::Itertools;
-    use ndarray::Array;
     use rand::rngs::StdRng;
     use rand::seq::SliceRandom;
     use rand::SeedableRng;
@@ -730,17 +729,15 @@ mod tests {
 
         let top = 5;
         let query = random_vector(&mut rng, dim);
-        let processed_query = Array::from(
-            vector_holder
+        let processed_query = vector_holder
                 .metric
                 .preprocess(&query)
-                .unwrap_or_else(|| query.clone()),
-        );
+                .unwrap_or_else(|| query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
             reference_top.push(ScoredPointOffset {
                 idx: idx as PointOffsetType,
-                score: vector_holder.metric.similarity(vec, &processed_query),
+                score: vector_holder.metric.similarity(&vec, &processed_query),
             });
         }
 

commit e196ce025bcbb1aad04c892205fe07deaa519f7a
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:21 2022 +0400

    fix clippy warnings (#175)
    
    * fix clippy warnings
    
    - doc links
    - explicit deref
    - if instead of match for single bool condition
    - combine similar match branches
    
    * revert removal of transmute
    
    * return Some when vec is not empty

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d8f47bcb2..36536d560 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -253,7 +253,7 @@ impl GraphLayers {
         }
     }
 
-    /// https://github.com/nmslib/hnswlib/issues/99
+    /// <https://github.com/nmslib/hnswlib/issues/99>
     fn select_candidate_with_heuristic_from_sorted<F>(
         candidates: impl Iterator<Item = ScoredPointOffset>,
         m: usize,
@@ -277,14 +277,14 @@ impl GraphLayers {
                 }
             }
             if is_good {
-                result_list.push(current_closest.idx)
+                result_list.push(current_closest.idx);
             }
         }
 
         result_list
     }
 
-    /// https://github.com/nmslib/hnswlib/issues/99
+    /// <https://github.com/nmslib/hnswlib/issues/99>
     fn select_candidates_with_heuristic<F>(
         candidates: FixedLengthPriorityQueue<ScoredPointOffset>,
         m: usize,

commit 57fa65072f0b742662a9be5ef7f6840cddf5c6e1
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:36 2022 +0400

    use copied instead of cloned (#174)
    
    * use copied instead of cloned
    
    https://rust-lang.github.io/rust-clippy/master/index.html#cloned_instead_of_copied
    
    * use copied instead of cloned

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 36536d560..48352ebcb 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -156,7 +156,7 @@ impl GraphLayers {
             let mut links_iter = self
                 .links(candidate.idx, level)
                 .iter()
-                .cloned()
+                .copied()
                 .filter(|point_id| !visited_list.check_and_update_visited(*point_id));
 
             points_scorer.score_iterable_points(
@@ -211,7 +211,7 @@ impl GraphLayers {
             let mut changed = true;
             while changed {
                 changed = false;
-                let mut links = self.links(current_point.idx, level).iter().cloned();
+                let mut links = self.links(current_point.idx, level).iter().copied();
                 points_scorer.score_iterable_points(&mut links, self.get_m(level), |score_point| {
                     if score_point.score > current_point.score {
                         changed = true;
@@ -246,10 +246,10 @@ impl GraphLayers {
         }
 
         if links.len() < level_m {
-            links.insert(id_to_insert, new_point_id)
+            links.insert(id_to_insert, new_point_id);
         } else if id_to_insert != links.len() {
             links.pop();
-            links.insert(id_to_insert, new_point_id)
+            links.insert(id_to_insert, new_point_id);
         }
     }
 
@@ -372,7 +372,7 @@ impl GraphLayers {
                                     score: scorer(point_id, other_point),
                                 });
                                 for other_point_link in
-                                    other_point_links.iter().take(level_m).cloned()
+                                    other_point_links.iter().take(level_m).copied()
                                 {
                                     candidates.push(ScoredPointOffset {
                                         idx: other_point_link,
@@ -386,7 +386,7 @@ impl GraphLayers {
                                         scorer,
                                     );
                                 for (idx, selected) in
-                                    selected_candidates.iter().cloned().enumerate()
+                                    selected_candidates.iter().copied().enumerate()
                                 {
                                     other_point_links[idx] = selected;
                                 }
@@ -432,7 +432,7 @@ impl GraphLayers {
                 } else {
                     visited_list.next_iteration();
                     let current_links = &mut current_layers[level];
-                    current_links.iter().cloned().for_each(|x| {
+                    current_links.iter().copied().for_each(|x| {
                         visited_list.check_and_update_visited(x);
                     });
                     for other_link in other_links

commit 298685102c3979b47793ac2c57f0e263a5697346
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:46 2022 +0400

    add missing commas (#173)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 48352ebcb..918051a73 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -136,7 +136,7 @@ impl GraphLayers {
         while point_layers.len() <= level {
             let mut links = vec![];
             links.reserve(self.m);
-            point_layers.push(links)
+            point_layers.push(links);
         }
         self.max_level = max(level, self.max_level);
     }
@@ -186,7 +186,7 @@ impl GraphLayers {
                 search_context.process_candidate(ScoredPointOffset {
                     idx: existing_link,
                     score: points_scorer.score_point(existing_link),
-                })
+                });
             }
         }
 
@@ -410,7 +410,7 @@ impl GraphLayers {
                                 scorer,
                             );
                             if nearest_point.score > level_entry.score {
-                                level_entry = *nearest_point
+                                level_entry = *nearest_point;
                             }
                         }
                     }
@@ -422,13 +422,13 @@ impl GraphLayers {
     pub fn merge_from_other(&mut self, other: GraphLayers) {
         let mut visited_list = self.visited_pool.get(self.num_points());
         if other.links_layers.len() > self.links_layers.len() {
-            self.links_layers.resize(other.links_layers.len(), vec![])
+            self.links_layers.resize(other.links_layers.len(), vec![]);
         }
         for (point_id, layers) in other.links_layers.into_iter().enumerate() {
             let current_layers = &mut self.links_layers[point_id];
             for (level, other_links) in layers.into_iter().enumerate() {
                 if current_layers.len() <= level {
-                    current_layers.push(other_links)
+                    current_layers.push(other_links);
                 } else {
                     visited_list.next_iteration();
                     let current_links = &mut current_layers[level];
@@ -439,7 +439,7 @@ impl GraphLayers {
                         .into_iter()
                         .filter(|x| !visited_list.check_and_update_visited(*x))
                     {
-                        current_links.push(other_link)
+                        current_links.push(other_link);
                     }
                 }
             }

commit 1e5670399fb9ca645026a2613886f9e530f60e43
Merge: 88ff45d53 3b2b1bbf9
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 18:05:39 2022 +0300

    Merge branch 'master' into remove-blas


commit 8daacbd160e7e5d1174bd9e2bb6b47afe4ce6c0a
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jan 4 18:19:34 2022 +0300

    are you happy fmt?

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 3256237e4..793d2cbea 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -730,9 +730,9 @@ mod tests {
         let top = 5;
         let query = random_vector(&mut rng, dim);
         let processed_query = vector_holder
-                .metric
-                .preprocess(&query)
-                .unwrap_or_else(|| query.clone());
+            .metric
+            .preprocess(&query)
+            .unwrap_or_else(|| query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
             reference_top.push(ScoredPointOffset {

commit 898b692f39fe45f88623f01e2c57a4369030463b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jan 18 15:49:35 2022 +0100

    [WIP] Limit segment size #135 (#195)
    
    * add parameters to optimizer config
    
    * benchmark search speed in different segment sizes
    
    * use constructor for FilteredScorer
    
    * * Implement benchmarks for HNSW index search with different number of
      stored points
    * Fix minor issue in HNSW graph edge assignment
    * Update profiler with call-graph report generation
    * Add profiling guide
    * Add HNSW graph statistics test function (debug inly)
    
    * limit resulting segment size in merge optimizer
    
    * fix clippy
    
    * stop the music
    
    * fix clippy once again
    
    * fmt once again

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 918051a73..d350a7cbe 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -385,10 +385,9 @@ impl GraphLayers {
                                         level_m,
                                         scorer,
                                     );
-                                for (idx, selected) in
-                                    selected_candidates.iter().copied().enumerate()
-                                {
-                                    other_point_links[idx] = selected;
+                                other_point_links.clear(); // this do not free memory, which is good
+                                for selected in selected_candidates.iter().copied() {
+                                    other_point_links.push(selected);
                                 }
                             }
                         }
@@ -490,8 +489,9 @@ mod tests {
         random_vector, FakeConditionChecker, TestRawScorerProducer,
     };
     use crate::spaces::metric::Metric;
-    use crate::spaces::simple::{CosineMetric, DotProductMetric};
+    use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
     use crate::types::VectorElementType;
+    use crate::vector_storage::RawScorer;
     use itertools::Itertools;
     use ndarray::Array;
     use rand::rngs::StdRng;
@@ -567,11 +567,7 @@ mod tests {
     ) -> Vec<ScoredPointOffset> {
         let fake_condition_checker = FakeConditionChecker {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
-        let scorer = FilteredScorer {
-            raw_scorer: &raw_scorer,
-            condition_checker: &fake_condition_checker,
-            filter: None,
-        };
+        let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
         let ef = 16;
         graph.search(top, ef, &scorer)
     }
@@ -606,11 +602,7 @@ mod tests {
             let fake_condition_checker = FakeConditionChecker {};
             let added_vector = vector_holder.vectors[idx as usize].to_vec();
             let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
-            let scorer = FilteredScorer {
-                raw_scorer: &raw_scorer,
-                condition_checker: &fake_condition_checker,
-                filter: None,
-            };
+            let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
             let level = graph_layers.get_random_layer(rng);
             graph_layers.link_new_point(idx, level, &scorer);
         }
@@ -641,11 +633,7 @@ mod tests {
         let fake_condition_checker = FakeConditionChecker {};
         let added_vector = vector_holder.vectors[linking_idx as usize].to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-        let scorer = FilteredScorer {
-            raw_scorer: &raw_scorer,
-            condition_checker: &fake_condition_checker,
-            filter: None,
-        };
+        let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
 
         let nearest_on_level = graph_layers.search_on_level(
             ScoredPointOffset {
@@ -749,6 +737,87 @@ mod tests {
         assert_eq!(reference_top.into_vec(), graph_search);
     }
 
+    #[test]
+    #[ignore]
+    fn test_hnsw_graph_properties() {
+        const NUM_VECTORS: usize = 5_000;
+        const DIM: usize = 16;
+        const M: usize = 16;
+        const EF_CONSTRUCT: usize = 64;
+        const USE_HEURISTIC: bool = true;
+
+        let mut rng = StdRng::seed_from_u64(42);
+
+        let vector_holder = TestRawScorerProducer::new(DIM, NUM_VECTORS, CosineMetric {}, &mut rng);
+        let mut graph_layers =
+            GraphLayers::new(NUM_VECTORS, M, M * 2, EF_CONSTRUCT, 10, USE_HEURISTIC);
+        let fake_condition_checker = FakeConditionChecker {};
+        for idx in 0..(NUM_VECTORS as PointOffsetType) {
+            let added_vector = vector_holder.vectors[idx as usize].to_vec();
+            let raw_scorer = vector_holder.get_raw_scorer(added_vector);
+            let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
+            let level = graph_layers.get_random_layer(&mut rng);
+            graph_layers.link_new_point(idx, level, &scorer);
+        }
+
+        let number_layers = graph_layers.links_layers.len();
+        eprintln!("number_layers = {:#?}", number_layers);
+
+        let max_layers = graph_layers.links_layers.iter().map(|x| x.len()).max();
+        eprintln!("max_layers = {:#?}", max_layers);
+
+        eprintln!(
+            "graph_layers.links_layers[910] = {:#?}",
+            graph_layers.links_layers[910]
+        );
+
+        let total_edges: usize = graph_layers.links_layers.iter().map(|x| x[0].len()).sum();
+        let avg_connectivity = total_edges as f64 / NUM_VECTORS as f64;
+        eprintln!("avg_connectivity = {:#?}", avg_connectivity);
+    }
+
+    #[test]
+    #[ignore]
+    fn test_candidate_selection_heuristics() {
+        const NUM_VECTORS: usize = 100;
+        const DIM: usize = 16;
+        const M: usize = 16;
+
+        let mut rng = StdRng::seed_from_u64(42);
+
+        let vector_holder = TestRawScorerProducer::new(DIM, NUM_VECTORS, EuclidMetric {}, &mut rng);
+
+        let mut candidates: FixedLengthPriorityQueue<ScoredPointOffset> =
+            FixedLengthPriorityQueue::new(NUM_VECTORS);
+
+        let new_vector_to_insert = random_vector(&mut rng, DIM);
+
+        let scorer = vector_holder.get_raw_scorer(new_vector_to_insert);
+
+        for i in 0..NUM_VECTORS {
+            candidates.push(ScoredPointOffset {
+                idx: i as PointOffsetType,
+                score: scorer.score_point(i as PointOffsetType),
+            });
+        }
+
+        let sorted_candidates = candidates.into_vec();
+
+        for x in sorted_candidates.iter().take(M) {
+            eprintln!("sorted_candidates = ({}, {})", x.idx, x.score);
+        }
+
+        let selected_candidates = GraphLayers::select_candidate_with_heuristic_from_sorted(
+            sorted_candidates.into_iter(),
+            M,
+            |a, b| scorer.score_internal(a, b),
+        );
+
+        for x in selected_candidates.iter() {
+            eprintln!("selected_candidates = {}", x);
+        }
+    }
+
     #[test]
     #[ignore]
     fn test_draw_hnsw_graph() {

commit 2c4fd0a2059bc3d03e8cd0116bec23792c03ad87
Merge: 063d0abe8 bb8dba39b
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 15:48:25 2022 +0000

    Merge branch 'master' into remove-blas

diff --cc lib/segment/src/index/hnsw_index/graph_layers.rs
index 793d2cbea,d350a7cbe..775f476fe
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@@ -490,9 -489,11 +489,10 @@@ mod tests 
          random_vector, FakeConditionChecker, TestRawScorerProducer,
      };
      use crate::spaces::metric::Metric;
-     use crate::spaces::simple::{CosineMetric, DotProductMetric};
+     use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
      use crate::types::VectorElementType;
+     use crate::vector_storage::RawScorer;
      use itertools::Itertools;
 -    use ndarray::Array;
      use rand::rngs::StdRng;
      use rand::seq::SliceRandom;
      use rand::SeedableRng;

commit eb6885b75a918438c93d32559df6c76bc21538aa
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 16 13:15:14 2022 +0400

    are you happy clippy

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 775f476fe..2b5a23f3b 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -725,7 +725,7 @@ mod tests {
         for (idx, vec) in vector_holder.vectors.iter().enumerate() {
             reference_top.push(ScoredPointOffset {
                 idx: idx as PointOffsetType,
-                score: vector_holder.metric.similarity(&vec, &processed_query),
+                score: vector_holder.metric.similarity(vec, &processed_query),
             });
         }
 

commit 2a81fc91421b7815854d86903c29f8f05b362d66
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Mar 23 14:21:04 2022 +0100

    Remove sled for alias mappings (#402)
    
    * improve alias tests
    
    * introduce new alias persistence and remove Sled
    
    * introduce FileStorageError
    
    * use new error in AliasMapping
    
    * aliases are kept in memory and saved to disk when modified
    
    * better naming
    
    * make alias renaming atomic
    
    * fmt
    
    * use correct alias and docs
    
    * code review: cleaner error conversion

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 2b5a23f3b..6bf06e67b 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -474,11 +474,11 @@ impl GraphLayers {
     }
 
     pub fn load(path: &Path) -> OperationResult<Self> {
-        read_bin(path)
+        Ok(read_bin(path)?)
     }
 
     pub fn save(&self, path: &Path) -> OperationResult<()> {
-        atomic_save_bin(path, self)
+        Ok(atomic_save_bin(path, self)?)
     }
 }
 

commit c29c9a46d46c22d3210e61cc3a111747ace31fb1
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Thu Mar 31 08:57:18 2022 -0300

    [json storage] Filtering context (#413)
    
    * [WIP] add a basic filtering context scaffold
    
    * add PlainFilterContext and StructFilterContext

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 6bf06e67b..85c2f3207 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -486,7 +486,7 @@ impl GraphLayers {
 mod tests {
     use super::*;
     use crate::fixtures::index_fixtures::{
-        random_vector, FakeConditionChecker, TestRawScorerProducer,
+        random_vector, FakeFilterContext, TestRawScorerProducer,
     };
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
@@ -564,9 +564,9 @@ mod tests {
         vector_storage: &TestRawScorerProducer<CosineMetric>,
         graph: &GraphLayers,
     ) -> Vec<ScoredPointOffset> {
-        let fake_condition_checker = FakeConditionChecker {};
+        let fake_filter_context = FakeFilterContext {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
-        let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
+        let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
         let ef = 16;
         graph.search(top, ef, &scorer)
     }
@@ -598,10 +598,10 @@ mod tests {
         );
 
         for idx in 0..(num_vectors as PointOffsetType) {
-            let fake_condition_checker = FakeConditionChecker {};
+            let fake_filter_context = FakeFilterContext {};
             let added_vector = vector_holder.vectors[idx as usize].to_vec();
             let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
-            let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
+            let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(rng);
             graph_layers.link_new_point(idx, level, &scorer);
         }
@@ -629,10 +629,10 @@ mod tests {
 
         let linking_idx: PointOffsetType = 7;
 
-        let fake_condition_checker = FakeConditionChecker {};
+        let fake_filter_context = FakeFilterContext {};
         let added_vector = vector_holder.vectors[linking_idx as usize].to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-        let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
+        let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
 
         let nearest_on_level = graph_layers.search_on_level(
             ScoredPointOffset {
@@ -748,11 +748,11 @@ mod tests {
         let vector_holder = TestRawScorerProducer::new(DIM, NUM_VECTORS, CosineMetric {}, &mut rng);
         let mut graph_layers =
             GraphLayers::new(NUM_VECTORS, M, M * 2, EF_CONSTRUCT, 10, USE_HEURISTIC);
-        let fake_condition_checker = FakeConditionChecker {};
+        let fake_filter_context = FakeFilterContext {};
         for idx in 0..(NUM_VECTORS as PointOffsetType) {
             let added_vector = vector_holder.vectors[idx as usize].to_vec();
             let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-            let scorer = FilteredScorer::new(&raw_scorer, &fake_condition_checker, None);
+            let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(&mut rng);
             graph_layers.link_new_point(idx, level, &scorer);
         }

commit ff21a1308325a99d30639cee5bc5d49354280116
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Apr 8 18:04:59 2022 +0400

    Remove overcomplicated iterator (#409)
    
    remove dyn iterator from filtered scorer
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 85c2f3207..5c10fa3c3 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -147,23 +147,28 @@ impl GraphLayers {
         searcher: &mut SearchContext,
         level: usize,
         visited_list: &mut VisitedList,
-        points_scorer: &FilteredScorer,
+        points_scorer: &mut FilteredScorer,
     ) {
+        let limit = self.get_m(level);
+        let mut points_ids: Vec<PointOffsetType> = Vec::with_capacity(2 * limit);
+
         while let Some(candidate) = searcher.candidates.pop() {
             if candidate.score < searcher.lower_bound() {
                 break;
             }
-            let mut links_iter = self
-                .links(candidate.idx, level)
+
+            points_ids.clear();
+            for link in self.links(candidate.idx, level) {
+                if !visited_list.check_and_update_visited(*link) {
+                    points_ids.push(*link);
+                }
+            }
+
+            let scores = points_scorer.score_points(&mut points_ids, limit);
+            scores
                 .iter()
                 .copied()
-                .filter(|point_id| !visited_list.check_and_update_visited(*point_id));
-
-            points_scorer.score_iterable_points(
-                &mut links_iter,
-                self.get_m(level),
-                |score_point| searcher.process_candidate(score_point),
-            );
+                .for_each(|score_point| searcher.process_candidate(score_point));
         }
     }
 
@@ -172,7 +177,7 @@ impl GraphLayers {
         level_entry: ScoredPointOffset,
         level: usize,
         ef: usize,
-        points_scorer: &FilteredScorer,
+        points_scorer: &mut FilteredScorer,
         existing_links: LinkContainerRef,
     ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
         let mut visited_list = self.visited_pool.get(self.num_points());
@@ -201,18 +206,26 @@ impl GraphLayers {
         entry_point: PointOffsetType,
         top_level: usize,
         target_level: usize,
-        points_scorer: &FilteredScorer,
+        points_scorer: &mut FilteredScorer,
     ) -> ScoredPointOffset {
+        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
+
         let mut current_point = ScoredPointOffset {
             idx: entry_point,
             score: points_scorer.score_point(entry_point),
         };
         for level in rev_range(top_level, target_level) {
+            let limit = self.get_m(level);
+
             let mut changed = true;
             while changed {
                 changed = false;
-                let mut links = self.links(current_point.idx, level).iter().copied();
-                points_scorer.score_iterable_points(&mut links, self.get_m(level), |score_point| {
+
+                links.clear();
+                links.extend_from_slice(self.links(current_point.idx, level));
+
+                let scores = points_scorer.score_points(&mut links, limit);
+                scores.iter().copied().for_each(|score_point| {
                     if score_point.score > current_point.score {
                         changed = true;
                         current_point = score_point;
@@ -301,7 +314,7 @@ impl GraphLayers {
         &mut self,
         point_id: PointOffsetType,
         level: usize,
-        points_scorer: &FilteredScorer,
+        mut points_scorer: FilteredScorer,
     ) {
         // Check if there is an suitable entry point
         //   - entry point level if higher or equal
@@ -328,7 +341,7 @@ impl GraphLayers {
                         entry_point.point_id,
                         entry_point.level,
                         level,
-                        points_scorer,
+                        &mut points_scorer,
                     )
                 } else {
                     ScoredPointOffset {
@@ -339,8 +352,6 @@ impl GraphLayers {
                 // minimal common level for entry points
                 let linking_level = min(level, entry_point.level);
 
-                let scorer = |a, b| points_scorer.score_internal(a, b);
-
                 for curr_level in (0..=linking_level).rev() {
                     let level_m = self.get_m(curr_level);
                     let existing_links = &self.links_layers[point_id as usize][curr_level];
@@ -349,10 +360,12 @@ impl GraphLayers {
                         level_entry,
                         curr_level,
                         self.ef_construct,
-                        points_scorer,
+                        &mut points_scorer,
                         existing_links,
                     );
 
+                    let scorer = |a, b| points_scorer.score_internal(a, b);
+
                     if self.use_heuristic {
                         let selected_nearest =
                             Self::select_candidates_with_heuristic(nearest_points, level_m, scorer);
@@ -452,7 +465,7 @@ impl GraphLayers {
         &self,
         top: usize,
         ef: usize,
-        points_scorer: &FilteredScorer,
+        mut points_scorer: FilteredScorer,
     ) -> Vec<ScoredPointOffset> {
         let entry_point = match self
             .entry_points
@@ -462,10 +475,15 @@ impl GraphLayers {
             Some(ep) => ep,
         };
 
-        let zero_level_entry =
-            self.search_entry(entry_point.point_id, entry_point.level, 0, points_scorer);
+        let zero_level_entry = self.search_entry(
+            entry_point.point_id,
+            entry_point.level,
+            0,
+            &mut points_scorer,
+        );
 
-        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), points_scorer, &[]);
+        let nearest =
+            self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer, &[]);
         nearest.into_iter().take(top).collect_vec()
     }
 
@@ -568,7 +586,7 @@ mod tests {
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
         let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
         let ef = 16;
-        graph.search(top, ef, &scorer)
+        graph.search(top, ef, scorer)
     }
 
     const M: usize = 8;
@@ -603,7 +621,7 @@ mod tests {
             let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
             let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(rng);
-            graph_layers.link_new_point(idx, level, &scorer);
+            graph_layers.link_new_point(idx, level, scorer);
         }
 
         (vector_holder, graph_layers)
@@ -632,7 +650,7 @@ mod tests {
         let fake_filter_context = FakeFilterContext {};
         let added_vector = vector_holder.vectors[linking_idx as usize].to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-        let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
+        let mut scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
 
         let nearest_on_level = graph_layers.search_on_level(
             ScoredPointOffset {
@@ -641,7 +659,7 @@ mod tests {
             },
             0,
             32,
-            &scorer,
+            &mut scorer,
             &[],
         );
 
@@ -754,7 +772,7 @@ mod tests {
             let raw_scorer = vector_holder.get_raw_scorer(added_vector);
             let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(&mut rng);
-            graph_layers.link_new_point(idx, level, &scorer);
+            graph_layers.link_new_point(idx, level, scorer);
         }
 
         let number_layers = graph_layers.links_layers.len();

commit 757652c59e579b31ade9a10ff5878bcc586f6314
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Apr 9 20:47:11 2022 +0400

    Use chunked vec in vector storage (#457)
    
    avoid vec of vec in simple storage
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 5c10fa3c3..1fb00c8dc 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -617,7 +617,7 @@ mod tests {
 
         for idx in 0..(num_vectors as PointOffsetType) {
             let fake_filter_context = FakeFilterContext {};
-            let added_vector = vector_holder.vectors[idx as usize].to_vec();
+            let added_vector = vector_holder.vectors.get(idx).to_vec();
             let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
             let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(rng);
@@ -648,7 +648,7 @@ mod tests {
         let linking_idx: PointOffsetType = 7;
 
         let fake_filter_context = FakeFilterContext {};
-        let added_vector = vector_holder.vectors[linking_idx as usize].to_vec();
+        let added_vector = vector_holder.vectors.get(linking_idx).to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector);
         let mut scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
 
@@ -740,9 +740,10 @@ mod tests {
             .preprocess(&query)
             .unwrap_or_else(|| query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
-        for (idx, vec) in vector_holder.vectors.iter().enumerate() {
+        for idx in 0..vector_holder.vectors.len() as PointOffsetType {
+            let vec = &vector_holder.vectors.get(idx);
             reference_top.push(ScoredPointOffset {
-                idx: idx as PointOffsetType,
+                idx,
                 score: vector_holder.metric.similarity(vec, &processed_query),
             });
         }
@@ -768,7 +769,7 @@ mod tests {
             GraphLayers::new(NUM_VECTORS, M, M * 2, EF_CONSTRUCT, 10, USE_HEURISTIC);
         let fake_filter_context = FakeFilterContext {};
         for idx in 0..(NUM_VECTORS as PointOffsetType) {
-            let added_vector = vector_holder.vectors[idx as usize].to_vec();
+            let added_vector = vector_holder.vectors.get(idx).to_vec();
             let raw_scorer = vector_holder.get_raw_scorer(added_vector);
             let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
             let level = graph_layers.get_random_layer(&mut rng);
@@ -846,10 +847,8 @@ mod tests {
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 
         let vectors_json = serde_json::to_string_pretty(
-            &vector_holder
-                .vectors
-                .iter()
-                .map(|x| x.to_vec())
+            &(0..vector_holder.vectors.len() as PointOffsetType)
+                .map(|point_id| vector_holder.vectors.get(point_id).to_vec())
                 .collect_vec(),
         )
         .unwrap();

commit 5800319edb20b56cd02add55b011e7ca7db2a0f3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 9 17:32:48 2022 +0200

    refactor distances + add score_threshold + fix negative euclid distance (#569)
    
    * refactor distances + add score_threshold + fix negative euclid distance
    
    * generate docs
    
    * fix clippy
    
    * Update lib/segment/src/spaces/tools.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 1fb00c8dc..946e3e240 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -591,12 +591,12 @@ mod tests {
 
     const M: usize = 8;
 
-    fn create_graph_layer<R>(
+    fn create_graph_layer<TMetric: Metric, R>(
         num_vectors: usize,
         dim: usize,
         use_heuristic: bool,
         rng: &mut R,
-    ) -> (TestRawScorerProducer<CosineMetric>, GraphLayers)
+    ) -> (TestRawScorerProducer<TMetric>, GraphLayers)
     where
         R: Rng + ?Sized,
     {
@@ -604,7 +604,7 @@ mod tests {
         let ef_construct = 16;
         let entry_points_num = 10;
 
-        let vector_holder = TestRawScorerProducer::new(dim, num_vectors, CosineMetric {}, rng);
+        let vector_holder = TestRawScorerProducer::<TMetric>::new(dim, num_vectors, rng);
 
         let mut graph_layers = GraphLayers::new(
             num_vectors,
@@ -638,7 +638,7 @@ mod tests {
         let mut rng = StdRng::seed_from_u64(42);
 
         let vector_holder =
-            TestRawScorerProducer::new(dim, num_vectors, DotProductMetric {}, &mut rng);
+            TestRawScorerProducer::<DotProductMetric>::new(dim, num_vectors, &mut rng);
 
         let mut graph_layers =
             GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num, false);
@@ -685,7 +685,8 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false, &mut rng);
+        let (vector_holder, graph_layers) =
+            create_graph_layer::<CosineMetric, _>(num_vectors, dim, false, &mut rng);
 
         let query = random_vector(&mut rng, dim);
 
@@ -710,7 +711,10 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, false, &mut rng);
+        type M = CosineMetric;
+
+        let (vector_holder, graph_layers) =
+            create_graph_layer::<M, _>(num_vectors, dim, false, &mut rng);
 
         let main_entry = graph_layers
             .entry_points
@@ -735,16 +739,13 @@ mod tests {
 
         let top = 5;
         let query = random_vector(&mut rng, dim);
-        let processed_query = vector_holder
-            .metric
-            .preprocess(&query)
-            .unwrap_or_else(|| query.clone());
+        let processed_query = M::preprocess(&query).unwrap_or_else(|| query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for idx in 0..vector_holder.vectors.len() as PointOffsetType {
             let vec = &vector_holder.vectors.get(idx);
             reference_top.push(ScoredPointOffset {
                 idx,
-                score: vector_holder.metric.similarity(vec, &processed_query),
+                score: M::similarity(vec, &processed_query),
             });
         }
 
@@ -764,7 +765,7 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let vector_holder = TestRawScorerProducer::new(DIM, NUM_VECTORS, CosineMetric {}, &mut rng);
+        let vector_holder = TestRawScorerProducer::<CosineMetric>::new(DIM, NUM_VECTORS, &mut rng);
         let mut graph_layers =
             GraphLayers::new(NUM_VECTORS, M, M * 2, EF_CONSTRUCT, 10, USE_HEURISTIC);
         let fake_filter_context = FakeFilterContext {};
@@ -801,7 +802,7 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let vector_holder = TestRawScorerProducer::new(DIM, NUM_VECTORS, EuclidMetric {}, &mut rng);
+        let vector_holder = TestRawScorerProducer::<EuclidMetric>::new(DIM, NUM_VECTORS, &mut rng);
 
         let mut candidates: FixedLengthPriorityQueue<ScoredPointOffset> =
             FixedLengthPriorityQueue::new(NUM_VECTORS);
@@ -842,7 +843,8 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let (vector_holder, graph_layers) = create_graph_layer(num_vectors, dim, true, &mut rng);
+        let (vector_holder, graph_layers) =
+            create_graph_layer::<CosineMetric, _>(num_vectors, dim, true, &mut rng);
 
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 

commit e983b07a1521cd47771b63006defe54f74d181ce
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jul 3 01:14:05 2022 +0200

    Parallel hnsw building (#773)
    
    * parallel hnsw building
    
    * improve hnsw payload blocks condition
    
    * update indexing optimizer condition
    
    * fmt

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 946e3e240..dc7990e78 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -24,20 +24,20 @@ pub const HNSW_GRAPH_FILE: &str = "graph.bin";
 
 #[derive(Deserialize, Serialize, Debug)]
 pub struct GraphLayers {
-    max_level: usize,
-    m: usize,
-    m0: usize,
-    ef_construct: usize,
-    level_factor: f64,
+    pub(super) max_level: usize,
+    pub(super) m: usize,
+    pub(super) m0: usize,
+    pub(super) ef_construct: usize,
+    pub(super) level_factor: f64,
     // Exclude points according to "not closer than base" heuristic?
-    use_heuristic: bool,
+    pub(super) use_heuristic: bool,
     // Factor of level probability
-    links_layers: Vec<LayersContainer>,
-    entry_points: EntryPoints,
+    pub(super) links_layers: Vec<LayersContainer>,
+    pub(super) entry_points: EntryPoints,
 
     // Fields used on construction phase only
     #[serde(skip)]
-    visited_pool: VisitedPool,
+    pub(super) visited_pool: VisitedPool,
 }
 
 /// Object contains links between nodes for HNSW search
@@ -506,6 +506,7 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
+    use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
     use crate::types::VectorElementType;
@@ -591,42 +592,6 @@ mod tests {
 
     const M: usize = 8;
 
-    fn create_graph_layer<TMetric: Metric, R>(
-        num_vectors: usize,
-        dim: usize,
-        use_heuristic: bool,
-        rng: &mut R,
-    ) -> (TestRawScorerProducer<TMetric>, GraphLayers)
-    where
-        R: Rng + ?Sized,
-    {
-        let m = M;
-        let ef_construct = 16;
-        let entry_points_num = 10;
-
-        let vector_holder = TestRawScorerProducer::<TMetric>::new(dim, num_vectors, rng);
-
-        let mut graph_layers = GraphLayers::new(
-            num_vectors,
-            m,
-            m * 2,
-            ef_construct,
-            entry_points_num,
-            use_heuristic,
-        );
-
-        for idx in 0..(num_vectors as PointOffsetType) {
-            let fake_filter_context = FakeFilterContext {};
-            let added_vector = vector_holder.vectors.get(idx).to_vec();
-            let raw_scorer = vector_holder.get_raw_scorer(added_vector.clone());
-            let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
-            let level = graph_layers.get_random_layer(rng);
-            graph_layers.link_new_point(idx, level, scorer);
-        }
-
-        (vector_holder, graph_layers)
-    }
-
     #[test]
     fn test_search_on_level() {
         let dim = 8;
@@ -686,7 +651,7 @@ mod tests {
         let mut rng = StdRng::seed_from_u64(42);
 
         let (vector_holder, graph_layers) =
-            create_graph_layer::<CosineMetric, _>(num_vectors, dim, false, &mut rng);
+            create_graph_layer_fixture::<CosineMetric, _>(num_vectors, M, dim, false, &mut rng);
 
         let query = random_vector(&mut rng, dim);
 
@@ -714,7 +679,7 @@ mod tests {
         type M = CosineMetric;
 
         let (vector_holder, graph_layers) =
-            create_graph_layer::<M, _>(num_vectors, dim, false, &mut rng);
+            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, false, &mut rng);
 
         let main_entry = graph_layers
             .entry_points
@@ -733,8 +698,9 @@ mod tests {
 
         let total_links_0: usize = graph_layers.links_layers.iter().map(|x| x[0].len()).sum();
 
+        eprintln!("total_links_0 = {:#?}", total_links_0);
+        eprintln!("num_vectors = {:#?}", num_vectors);
         assert!(total_links_0 > 0);
-
         assert!(total_links_0 as f64 / num_vectors as f64 > M as f64);
 
         let top = 5;
@@ -844,7 +810,7 @@ mod tests {
         let mut rng = StdRng::seed_from_u64(42);
 
         let (vector_holder, graph_layers) =
-            create_graph_layer::<CosineMetric, _>(num_vectors, dim, true, &mut rng);
+            create_graph_layer_fixture::<CosineMetric, _>(num_vectors, M, dim, true, &mut rng);
 
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 

commit ff236410df6558ceb060c2915472de69af81ccd0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Jul 11 18:29:34 2022 +0400

    Graph layers remove code duplications (#796)
    
    * remove add link points
    
    * remove level factor
    
    * remove use heuristic
    
    * remove code duplications in graph layers
    
    * are you happy fmt
    
    * restore unit tests
    
    * remove obsolete comment

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index dc7990e78..845c7fd59 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -6,14 +6,11 @@ use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedList, VisitedPool};
 use crate::spaces::tools::FixedLengthPriorityQueue;
-use crate::types::{PointOffsetType, ScoreType};
+use crate::types::PointOffsetType;
 use crate::vector_storage::ScoredPointOffset;
 use itertools::Itertools;
-use rand::distributions::Uniform;
-use rand::Rng;
 use serde::{Deserialize, Serialize};
-use std::cmp::{max, min};
-use std::collections::BinaryHeap;
+use std::cmp::max;
 use std::path::{Path, PathBuf};
 
 pub type LinkContainer = Vec<PointOffsetType>;
@@ -28,118 +25,24 @@ pub struct GraphLayers {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-    pub(super) level_factor: f64,
-    // Exclude points according to "not closer than base" heuristic?
-    pub(super) use_heuristic: bool,
-    // Factor of level probability
     pub(super) links_layers: Vec<LayersContainer>,
     pub(super) entry_points: EntryPoints,
 
-    // Fields used on construction phase only
     #[serde(skip)]
     pub(super) visited_pool: VisitedPool,
 }
 
-/// Object contains links between nodes for HNSW search
-///
-/// Assume all scores are similarities. Larger score = closer points
-impl GraphLayers {
-    pub fn new_with_params(
-        num_vectors: usize, // Initial number of points in index
-        m: usize,           // Expected M for non-first layer
-        m0: usize,          // Expected M for first layer
-        ef_construct: usize,
-        entry_points_num: usize, // Depends on number of points
-        use_heuristic: bool,
-        reserve: bool,
-    ) -> Self {
-        let mut links_layers: Vec<LayersContainer> = vec![];
-
-        for _i in 0..num_vectors {
-            let mut links: LinkContainer = Vec::new();
-            if reserve {
-                links.reserve(m0);
-            }
-            links_layers.push(vec![links]);
-        }
-
-        GraphLayers {
-            max_level: 0,
-            m,
-            m0,
-            ef_construct,
-            level_factor: 1.0 / (m as f64).ln(),
-            use_heuristic,
-            links_layers,
-            entry_points: EntryPoints::new(entry_points_num),
-            visited_pool: VisitedPool::new(),
-        }
-    }
+pub trait GraphLayersBase {
+    fn get_visited_list_from_pool(&self) -> VisitedList;
 
-    pub fn new(
-        num_vectors: usize, // Initial number of points in index
-        m: usize,           // Expected M for non-first layer
-        m0: usize,          // Expected M for first layer
-        ef_construct: usize,
-        entry_points_num: usize, // Depends on number of points
-        use_heuristic: bool,
-    ) -> Self {
-        Self::new_with_params(
-            num_vectors,
-            m,
-            m0,
-            ef_construct,
-            entry_points_num,
-            use_heuristic,
-            true,
-        )
-    }
-
-    fn num_points(&self) -> usize {
-        self.links_layers.len()
-    }
+    fn return_visited_list_to_pool(&self, visited_list: VisitedList);
 
-    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
-        self.links_layers[point_id as usize].len() - 1
-    }
-
-    /// Get links of current point
-    fn links(&self, point_id: PointOffsetType, level: usize) -> LinkContainerRef {
-        &self.links_layers[point_id as usize][level]
-    }
-
-    /// Get M based on current level
-    fn get_m(&self, level: usize) -> usize {
-        if level == 0 {
-            self.m0
-        } else {
-            self.m
-        }
-    }
-
-    /// Generate random level for a new point, according to geometric distribution
-    pub fn get_random_layer<R>(&self, rng: &mut R) -> usize
+    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, f: F)
     where
-        R: Rng + ?Sized,
-    {
-        let distribution = Uniform::new(0.0, 1.0);
-        let sample: f64 = rng.sample(distribution);
-        let picked_level = -sample.ln() * self.level_factor;
-        picked_level.round() as usize
-    }
+        F: FnMut(PointOffsetType);
 
-    fn set_levels(&mut self, point_id: PointOffsetType, level: usize) {
-        if self.links_layers.len() <= point_id as usize {
-            self.links_layers.resize(point_id as usize, vec![]);
-        }
-        let point_layers = &mut self.links_layers[point_id as usize];
-        while point_layers.len() <= level {
-            let mut links = vec![];
-            links.reserve(self.m);
-            point_layers.push(links);
-        }
-        self.max_level = max(level, self.max_level);
-    }
+    /// Get M based on current level
+    fn get_m(&self, level: usize) -> usize;
 
     /// Greedy search for closest points within a single graph layer
     fn _search_on_level(
@@ -158,11 +61,11 @@ impl GraphLayers {
             }
 
             points_ids.clear();
-            for link in self.links(candidate.idx, level) {
-                if !visited_list.check_and_update_visited(*link) {
-                    points_ids.push(*link);
+            self.links_map(candidate.idx, level, |link| {
+                if !visited_list.check_and_update_visited(link) {
+                    points_ids.push(link);
                 }
-            }
+            });
 
             let scores = points_scorer.score_points(&mut points_ids, limit);
             scores
@@ -178,9 +81,9 @@ impl GraphLayers {
         level: usize,
         ef: usize,
         points_scorer: &mut FilteredScorer,
-        existing_links: LinkContainerRef,
+        existing_links: &[PointOffsetType],
     ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
-        let mut visited_list = self.visited_pool.get(self.num_points());
+        let mut visited_list = self.get_visited_list_from_pool();
         visited_list.check_and_update_visited(level_entry.idx);
         let mut search_context = SearchContext::new(level_entry, ef);
 
@@ -195,7 +98,7 @@ impl GraphLayers {
             }
         }
 
-        self.visited_pool.return_back(visited_list);
+        self.return_visited_list_to_pool(visited_list);
         search_context.nearest
     }
 
@@ -222,7 +125,9 @@ impl GraphLayers {
                 changed = false;
 
                 links.clear();
-                links.extend_from_slice(self.links(current_point.idx, level));
+                self.links_map(current_point.idx, level, |link| {
+                    links.push(link);
+                });
 
                 let scores = points_scorer.score_points(&mut links, limit);
                 scores.iter().copied().for_each(|score_point| {
@@ -235,200 +140,84 @@ impl GraphLayers {
         }
         current_point
     }
+}
 
-    /// Connect new point to links, so that links contains only closest points
-    fn connect_new_point<F>(
-        links: &mut LinkContainer,
-        new_point_id: PointOffsetType,
-        target_point_id: PointOffsetType,
-        level_m: usize,
-        mut score_internal: F,
-    ) where
-        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
+impl GraphLayersBase for GraphLayers {
+    fn get_visited_list_from_pool(&self) -> VisitedList {
+        self.visited_pool.get(self.num_points())
+    }
+
+    fn return_visited_list_to_pool(&self, visited_list: VisitedList) {
+        self.visited_pool.return_back(visited_list);
+    }
+
+    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, mut f: F)
+    where
+        F: FnMut(PointOffsetType),
     {
-        // ToDo: binary search here ? (most likely does not worth it)
-        let new_to_target = score_internal(target_point_id, new_point_id);
-
-        let mut id_to_insert = links.len();
-        for (i, &item) in links.iter().enumerate() {
-            let target_to_link = score_internal(target_point_id, item);
-            if target_to_link < new_to_target {
-                id_to_insert = i;
-                break;
-            }
+        for link in &self.links_layers[point_id as usize][level] {
+            f(*link);
         }
+    }
 
-        if links.len() < level_m {
-            links.insert(id_to_insert, new_point_id);
-        } else if id_to_insert != links.len() {
-            links.pop();
-            links.insert(id_to_insert, new_point_id);
+    fn get_m(&self, level: usize) -> usize {
+        if level == 0 {
+            self.m0
+        } else {
+            self.m
         }
     }
+}
 
-    /// <https://github.com/nmslib/hnswlib/issues/99>
-    fn select_candidate_with_heuristic_from_sorted<F>(
-        candidates: impl Iterator<Item = ScoredPointOffset>,
-        m: usize,
-        mut score_internal: F,
-    ) -> Vec<PointOffsetType>
-    where
-        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
-    {
-        let mut result_list = vec![];
-        result_list.reserve(m);
-        for current_closest in candidates {
-            if result_list.len() >= m {
-                break;
-            }
-            let mut is_good = true;
-            for &selected_point in &result_list {
-                let dist_to_already_selected = score_internal(current_closest.idx, selected_point);
-                if dist_to_already_selected > current_closest.score {
-                    is_good = false;
-                    break;
-                }
-            }
-            if is_good {
-                result_list.push(current_closest.idx);
+/// Object contains links between nodes for HNSW search
+///
+/// Assume all scores are similarities. Larger score = closer points
+impl GraphLayers {
+    fn new_with_params(
+        num_vectors: usize, // Initial number of points in index
+        m: usize,           // Expected M for non-first layer
+        m0: usize,          // Expected M for first layer
+        ef_construct: usize,
+        entry_points_num: usize, // Depends on number of points
+        reserve: bool,
+    ) -> Self {
+        let mut links_layers: Vec<LayersContainer> = vec![];
+
+        for _i in 0..num_vectors {
+            let mut links: LinkContainer = Vec::new();
+            if reserve {
+                links.reserve(m0);
             }
+            links_layers.push(vec![links]);
         }
 
-        result_list
+        GraphLayers {
+            max_level: 0,
+            m,
+            m0,
+            ef_construct,
+            links_layers,
+            entry_points: EntryPoints::new(entry_points_num),
+            visited_pool: VisitedPool::new(),
+        }
     }
 
-    /// <https://github.com/nmslib/hnswlib/issues/99>
-    fn select_candidates_with_heuristic<F>(
-        candidates: FixedLengthPriorityQueue<ScoredPointOffset>,
-        m: usize,
-        score_internal: F,
-    ) -> Vec<PointOffsetType>
-    where
-        F: FnMut(PointOffsetType, PointOffsetType) -> ScoreType,
-    {
-        let closest_iter = candidates.into_iter();
-        Self::select_candidate_with_heuristic_from_sorted(closest_iter, m, score_internal)
+    pub fn new(
+        num_vectors: usize, // Initial number of points in index
+        m: usize,           // Expected M for non-first layer
+        m0: usize,          // Expected M for first layer
+        ef_construct: usize,
+        entry_points_num: usize, // Depends on number of points
+    ) -> Self {
+        Self::new_with_params(num_vectors, m, m0, ef_construct, entry_points_num, true)
     }
 
-    pub fn link_new_point(
-        &mut self,
-        point_id: PointOffsetType,
-        level: usize,
-        mut points_scorer: FilteredScorer,
-    ) {
-        // Check if there is an suitable entry point
-        //   - entry point level if higher or equal
-        //   - it satisfies filters
-
-        self.set_levels(point_id, level);
-
-        let entry_point_opt = self.entry_points.new_point(point_id, level, |point_id| {
-            points_scorer.check_point(point_id)
-        });
-        match entry_point_opt {
-            // New point is a new empty entry (for this filter, at least)
-            // We can't do much here, so just quit
-            None => {}
-
-            // Entry point found.
-            Some(entry_point) => {
-                let mut level_entry = if entry_point.level > level {
-                    // The entry point is higher than a new point
-                    // Let's find closest one on same level
-
-                    // greedy search for a single closest point
-                    self.search_entry(
-                        entry_point.point_id,
-                        entry_point.level,
-                        level,
-                        &mut points_scorer,
-                    )
-                } else {
-                    ScoredPointOffset {
-                        idx: entry_point.point_id,
-                        score: points_scorer.score_internal(point_id, entry_point.point_id),
-                    }
-                };
-                // minimal common level for entry points
-                let linking_level = min(level, entry_point.level);
-
-                for curr_level in (0..=linking_level).rev() {
-                    let level_m = self.get_m(curr_level);
-                    let existing_links = &self.links_layers[point_id as usize][curr_level];
-
-                    let nearest_points = self.search_on_level(
-                        level_entry,
-                        curr_level,
-                        self.ef_construct,
-                        &mut points_scorer,
-                        existing_links,
-                    );
-
-                    let scorer = |a, b| points_scorer.score_internal(a, b);
-
-                    if self.use_heuristic {
-                        let selected_nearest =
-                            Self::select_candidates_with_heuristic(nearest_points, level_m, scorer);
-                        self.links_layers[point_id as usize][curr_level]
-                            .clone_from(&selected_nearest);
-
-                        for &other_point in &selected_nearest {
-                            let other_point_links =
-                                &mut self.links_layers[other_point as usize][curr_level];
-                            if other_point_links.len() < level_m {
-                                // If linked point is lack of neighbours
-                                other_point_links.push(point_id);
-                            } else {
-                                let mut candidates = BinaryHeap::with_capacity(level_m + 1);
-                                candidates.push(ScoredPointOffset {
-                                    idx: point_id,
-                                    score: scorer(point_id, other_point),
-                                });
-                                for other_point_link in
-                                    other_point_links.iter().take(level_m).copied()
-                                {
-                                    candidates.push(ScoredPointOffset {
-                                        idx: other_point_link,
-                                        score: scorer(other_point_link, other_point),
-                                    });
-                                }
-                                let selected_candidates =
-                                    Self::select_candidate_with_heuristic_from_sorted(
-                                        candidates.into_sorted_vec().into_iter().rev(),
-                                        level_m,
-                                        scorer,
-                                    );
-                                other_point_links.clear(); // this do not free memory, which is good
-                                for selected in selected_candidates.iter().copied() {
-                                    other_point_links.push(selected);
-                                }
-                            }
-                        }
-                    } else {
-                        for nearest_point in &nearest_points {
-                            Self::connect_new_point(
-                                &mut self.links_layers[point_id as usize][curr_level],
-                                nearest_point.idx,
-                                point_id,
-                                level_m,
-                                scorer,
-                            );
-
-                            Self::connect_new_point(
-                                &mut self.links_layers[nearest_point.idx as usize][curr_level],
-                                point_id,
-                                nearest_point.idx,
-                                level_m,
-                                scorer,
-                            );
-                            if nearest_point.score > level_entry.score {
-                                level_entry = *nearest_point;
-                            }
-                        }
-                    }
-                }
-            }
-        }
+    fn num_points(&self) -> usize {
+        self.links_layers.len()
+    }
+
+    pub fn point_level(&self, point_id: PointOffsetType) -> usize {
+        self.links_layers[point_id as usize].len() - 1
     }
 
     pub fn merge_from_other(&mut self, other: GraphLayers) {
@@ -508,75 +297,15 @@ mod tests {
     };
     use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
-    use crate::spaces::simple::{CosineMetric, DotProductMetric, EuclidMetric};
+    use crate::spaces::simple::{CosineMetric, DotProductMetric};
     use crate::types::VectorElementType;
-    use crate::vector_storage::RawScorer;
     use itertools::Itertools;
     use rand::rngs::StdRng;
-    use rand::seq::SliceRandom;
     use rand::SeedableRng;
     use std::fs::File;
     use std::io::Write;
     use tempdir::TempDir;
 
-    #[test]
-    fn test_connect_new_point() {
-        let num_points = 10;
-        let m = 6;
-        let ef_construct = 32;
-
-        // See illustration in docs
-        let points: Vec<Vec<VectorElementType>> = vec![
-            vec![21.79, 7.18],  // Target
-            vec![20.58, 5.46],  // 1  B - yes
-            vec![21.19, 4.51],  // 2  C
-            vec![24.73, 8.24],  // 3  D - yes
-            vec![24.55, 9.98],  // 4  E
-            vec![26.11, 6.85],  // 5  F
-            vec![17.64, 11.14], // 6  G - yes
-            vec![14.97, 11.52], // 7  I
-            vec![14.97, 9.60],  // 8  J
-            vec![16.23, 14.32], // 9  H
-            vec![12.69, 19.13], // 10 K
-        ];
-
-        let scorer = |a: PointOffsetType, b: PointOffsetType| {
-            -((points[a as usize][0] - points[b as usize][0]).powi(2)
-                + (points[a as usize][1] - points[b as usize][1]).powi(2))
-            .sqrt()
-        };
-
-        let mut insert_ids = (1..points.len() as PointOffsetType).collect_vec();
-
-        let mut candidates = FixedLengthPriorityQueue::new(insert_ids.len());
-        for &id in &insert_ids {
-            candidates.push(ScoredPointOffset {
-                idx: id,
-                score: scorer(0, id),
-            });
-        }
-
-        let res = GraphLayers::select_candidates_with_heuristic(candidates, m, scorer);
-
-        assert_eq!(&res, &vec![1, 3, 6]);
-
-        let mut rng = StdRng::seed_from_u64(42);
-
-        let mut graph_layers = GraphLayers::new(num_points, m, m, ef_construct, 1, true);
-        insert_ids.shuffle(&mut rng);
-        for &id in &insert_ids {
-            let level_m = graph_layers.get_m(0);
-            GraphLayers::connect_new_point(
-                &mut graph_layers.links_layers[0][0],
-                id,
-                0,
-                level_m,
-                scorer,
-            )
-        }
-        assert_eq!(graph_layers.links(0, 0), &vec![1, 2, 3, 4, 5, 6]);
-    }
-
     fn search_in_graph(
         query: &[VectorElementType],
         top: usize,
@@ -606,7 +335,7 @@ mod tests {
             TestRawScorerProducer::<DotProductMetric>::new(dim, num_vectors, &mut rng);
 
         let mut graph_layers =
-            GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num, false);
+            GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num);
 
         graph_layers.links_layers[0][0] = vec![1, 2, 3, 4, 5, 6];
 
@@ -720,87 +449,6 @@ mod tests {
         assert_eq!(reference_top.into_vec(), graph_search);
     }
 
-    #[test]
-    #[ignore]
-    fn test_hnsw_graph_properties() {
-        const NUM_VECTORS: usize = 5_000;
-        const DIM: usize = 16;
-        const M: usize = 16;
-        const EF_CONSTRUCT: usize = 64;
-        const USE_HEURISTIC: bool = true;
-
-        let mut rng = StdRng::seed_from_u64(42);
-
-        let vector_holder = TestRawScorerProducer::<CosineMetric>::new(DIM, NUM_VECTORS, &mut rng);
-        let mut graph_layers =
-            GraphLayers::new(NUM_VECTORS, M, M * 2, EF_CONSTRUCT, 10, USE_HEURISTIC);
-        let fake_filter_context = FakeFilterContext {};
-        for idx in 0..(NUM_VECTORS as PointOffsetType) {
-            let added_vector = vector_holder.vectors.get(idx).to_vec();
-            let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-            let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
-            let level = graph_layers.get_random_layer(&mut rng);
-            graph_layers.link_new_point(idx, level, scorer);
-        }
-
-        let number_layers = graph_layers.links_layers.len();
-        eprintln!("number_layers = {:#?}", number_layers);
-
-        let max_layers = graph_layers.links_layers.iter().map(|x| x.len()).max();
-        eprintln!("max_layers = {:#?}", max_layers);
-
-        eprintln!(
-            "graph_layers.links_layers[910] = {:#?}",
-            graph_layers.links_layers[910]
-        );
-
-        let total_edges: usize = graph_layers.links_layers.iter().map(|x| x[0].len()).sum();
-        let avg_connectivity = total_edges as f64 / NUM_VECTORS as f64;
-        eprintln!("avg_connectivity = {:#?}", avg_connectivity);
-    }
-
-    #[test]
-    #[ignore]
-    fn test_candidate_selection_heuristics() {
-        const NUM_VECTORS: usize = 100;
-        const DIM: usize = 16;
-        const M: usize = 16;
-
-        let mut rng = StdRng::seed_from_u64(42);
-
-        let vector_holder = TestRawScorerProducer::<EuclidMetric>::new(DIM, NUM_VECTORS, &mut rng);
-
-        let mut candidates: FixedLengthPriorityQueue<ScoredPointOffset> =
-            FixedLengthPriorityQueue::new(NUM_VECTORS);
-
-        let new_vector_to_insert = random_vector(&mut rng, DIM);
-
-        let scorer = vector_holder.get_raw_scorer(new_vector_to_insert);
-
-        for i in 0..NUM_VECTORS {
-            candidates.push(ScoredPointOffset {
-                idx: i as PointOffsetType,
-                score: scorer.score_point(i as PointOffsetType),
-            });
-        }
-
-        let sorted_candidates = candidates.into_vec();
-
-        for x in sorted_candidates.iter().take(M) {
-            eprintln!("sorted_candidates = ({}, {})", x.idx, x.score);
-        }
-
-        let selected_candidates = GraphLayers::select_candidate_with_heuristic_from_sorted(
-            sorted_candidates.into_iter(),
-            M,
-            |a, b| scorer.score_internal(a, b),
-        );
-
-        for x in selected_candidates.iter() {
-            eprintln!("selected_candidates = {}", x);
-        }
-    }
-
     #[test]
     #[ignore]
     fn test_draw_hnsw_graph() {

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 845c7fd59..dbdb6e752 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -1,3 +1,9 @@
+use std::cmp::max;
+use std::path::{Path, PathBuf};
+
+use itertools::Itertools;
+use serde::{Deserialize, Serialize};
+
 use crate::common::file_operations::{atomic_save_bin, read_bin};
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
@@ -8,10 +14,6 @@ use crate::index::visited_pool::{VisitedList, VisitedPool};
 use crate::spaces::tools::FixedLengthPriorityQueue;
 use crate::types::PointOffsetType;
 use crate::vector_storage::ScoredPointOffset;
-use itertools::Itertools;
-use serde::{Deserialize, Serialize};
-use std::cmp::max;
-use std::path::{Path, PathBuf};
 
 pub type LinkContainer = Vec<PointOffsetType>;
 pub type LinkContainerRef<'a> = &'a [PointOffsetType];
@@ -291,6 +293,14 @@ impl GraphLayers {
 
 #[cfg(test)]
 mod tests {
+    use std::fs::File;
+    use std::io::Write;
+
+    use itertools::Itertools;
+    use rand::rngs::StdRng;
+    use rand::SeedableRng;
+    use tempdir::TempDir;
+
     use super::*;
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
@@ -299,12 +309,6 @@ mod tests {
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
     use crate::types::VectorElementType;
-    use itertools::Itertools;
-    use rand::rngs::StdRng;
-    use rand::SeedableRng;
-    use std::fs::File;
-    use std::io::Write;
-    use tempdir::TempDir;
 
     fn search_in_graph(
         query: &[VectorElementType],

commit 52e0c53e367844b867a3d0a3134d6cd3c6037f5a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jul 26 19:14:50 2022 +0200

    Fix hnsw graph backward compatibility for 0 8 5 (#865)
    
    * try to load legacy graph format if primary failed
    
    * fmt

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index dbdb6e752..b232d1156 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -21,6 +21,32 @@ pub type LayersContainer = Vec<LinkContainer>;
 
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";
 
+#[derive(Deserialize, Serialize, Debug)]
+pub struct GraphLayersBackwardCompatibility {
+    pub(super) max_level: usize,
+    pub(super) m: usize,
+    pub(super) m0: usize,
+    pub(super) ef_construct: usize,
+    pub(super) level_factor: f64,   // Deprecated
+    pub(super) use_heuristic: bool, // Deprecated
+    pub(super) links_layers: Vec<LayersContainer>,
+    pub(super) entry_points: EntryPoints,
+}
+
+impl From<GraphLayersBackwardCompatibility> for GraphLayers {
+    fn from(gl: GraphLayersBackwardCompatibility) -> Self {
+        GraphLayers {
+            max_level: gl.max_level,
+            m: gl.m,
+            m0: gl.m0,
+            ef_construct: gl.ef_construct,
+            links_layers: gl.links_layers,
+            entry_points: gl.entry_points,
+            visited_pool: VisitedPool::new(),
+        }
+    }
+}
+
 #[derive(Deserialize, Serialize, Debug)]
 pub struct GraphLayers {
     pub(super) max_level: usize,
@@ -283,7 +309,22 @@ impl GraphLayers {
     }
 
     pub fn load(path: &Path) -> OperationResult<Self> {
-        Ok(read_bin(path)?)
+        let try_self: Result<Self, _> = read_bin(path);
+
+        match try_self {
+            Ok(slf) => Ok(slf),
+            Err(err) => {
+                let try_legacy: Result<GraphLayersBackwardCompatibility, _> = read_bin(path);
+                if let Ok(legacy) = try_legacy {
+                    let slf: Self = legacy.into();
+                    log::debug!("Converting legacy graph to new format");
+                    slf.save(path)?;
+                    Ok(slf)
+                } else {
+                    Err(err)?
+                }
+            }
+        }
     }
 
     pub fn save(&self, path: &Path) -> OperationResult<()> {

commit 8e1f2ca35322cc699232ec8d8177fe05baae3f98
Author: Russ Cam <russ.cam@forloop.co.uk>
Date:   Wed Aug 10 17:39:21 2022 +1000

    Use tempfile (#922)
    
    This commit replaces tempdir with tempfile.
    tempdir is archived.
    
    Closes #544

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index b232d1156..82bb17d1d 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -340,7 +340,7 @@ mod tests {
     use itertools::Itertools;
     use rand::rngs::StdRng;
     use rand::SeedableRng;
-    use tempdir::TempDir;
+    use tempfile::Builder;
 
     use super::*;
     use crate::fixtures::index_fixtures::{
@@ -431,7 +431,7 @@ mod tests {
 
         let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
 
-        let dir = TempDir::new("graph_dir").unwrap();
+        let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
 
         let path = GraphLayers::get_path(dir.path());
         graph_layers.save(&path).unwrap();

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 82bb17d1d..007e3220c 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -343,13 +343,13 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
+    use crate::data_types::vectors::VectorElementType;
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
     use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
-    use crate::types::VectorElementType;
 
     fn search_in_graph(
         query: &[VectorElementType],

commit a465679fb8235659492a22685e98bce6e95622b1
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Nov 8 13:42:50 2022 +0400

    Hnsw links storage (#1171)
    
    * hnsw compact links storage
    
    * dump links memsize
    
    * are you happy fmt
    
    * fix build
    
    * calculate capacity and add shrink
    
    * fmt
    
    * remove garbage
    
    * fix unit tests
    
    * default values for graph layers
    
    * remove obsolete fields
    
    * add comments
    
    * more comments
    
    * use one flattened links structure
    
    * refactor and add unit tests
    
    * move merge into graph builder
    
    * fix messages in test_hnsw_graph_properties

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 007e3220c..d37f5e571 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -4,6 +4,7 @@ use std::path::{Path, PathBuf};
 use itertools::Itertools;
 use serde::{Deserialize, Serialize};
 
+use super::graph_links::GraphLinks;
 use crate::common::file_operations::{atomic_save_bin, read_bin};
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
@@ -27,8 +28,6 @@ pub struct GraphLayersBackwardCompatibility {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-    pub(super) level_factor: f64,   // Deprecated
-    pub(super) use_heuristic: bool, // Deprecated
     pub(super) links_layers: Vec<LayersContainer>,
     pub(super) entry_points: EntryPoints,
 }
@@ -40,7 +39,7 @@ impl From<GraphLayersBackwardCompatibility> for GraphLayers {
             m: gl.m,
             m0: gl.m0,
             ef_construct: gl.ef_construct,
-            links_layers: gl.links_layers,
+            links: GraphLinks::from_vec(&gl.links_layers),
             entry_points: gl.entry_points,
             visited_pool: VisitedPool::new(),
         }
@@ -53,7 +52,7 @@ pub struct GraphLayers {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-    pub(super) links_layers: Vec<LayersContainer>,
+    pub(super) links: GraphLinks,
     pub(super) entry_points: EntryPoints,
 
     #[serde(skip)]
@@ -183,7 +182,7 @@ impl GraphLayersBase for GraphLayers {
     where
         F: FnMut(PointOffsetType),
     {
-        for link in &self.links_layers[point_id as usize][level] {
+        for link in self.links.links(point_id, level) {
             f(*link);
         }
     }
@@ -224,7 +223,7 @@ impl GraphLayers {
             m,
             m0,
             ef_construct,
-            links_layers,
+            links: Default::default(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),
         }
@@ -241,41 +240,11 @@ impl GraphLayers {
     }
 
     fn num_points(&self) -> usize {
-        self.links_layers.len()
+        self.links.num_points()
     }
 
     pub fn point_level(&self, point_id: PointOffsetType) -> usize {
-        self.links_layers[point_id as usize].len() - 1
-    }
-
-    pub fn merge_from_other(&mut self, other: GraphLayers) {
-        let mut visited_list = self.visited_pool.get(self.num_points());
-        if other.links_layers.len() > self.links_layers.len() {
-            self.links_layers.resize(other.links_layers.len(), vec![]);
-        }
-        for (point_id, layers) in other.links_layers.into_iter().enumerate() {
-            let current_layers = &mut self.links_layers[point_id];
-            for (level, other_links) in layers.into_iter().enumerate() {
-                if current_layers.len() <= level {
-                    current_layers.push(other_links);
-                } else {
-                    visited_list.next_iteration();
-                    let current_links = &mut current_layers[level];
-                    current_links.iter().copied().for_each(|x| {
-                        visited_list.check_and_update_visited(x);
-                    });
-                    for other_link in other_links
-                        .into_iter()
-                        .filter(|x| !visited_list.check_and_update_visited(*x))
-                    {
-                        current_links.push(other_link);
-                    }
-                }
-            }
-        }
-        self.entry_points.merge_from_other(other.entry_points);
-
-        self.visited_pool.return_back(visited_list);
+        self.links.point_level(point_id)
     }
 
     pub fn search(
@@ -382,7 +351,9 @@ mod tests {
         let mut graph_layers =
             GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num);
 
-        graph_layers.links_layers[0][0] = vec![1, 2, 3, 4, 5, 6];
+        let mut graph_links = vec![vec![Vec::new()]; num_vectors];
+        graph_links[0][0] = vec![1, 2, 3, 4, 5, 6];
+        graph_layers.links = GraphLinks::from_vec(&graph_links);
 
         let linking_idx: PointOffsetType = 7;
 
@@ -402,10 +373,7 @@ mod tests {
             &[],
         );
 
-        assert_eq!(
-            nearest_on_level.len(),
-            graph_layers.links_layers[0][0].len() + 1
-        );
+        assert_eq!(nearest_on_level.len(), graph_links[0][0].len() + 1);
 
         for nearest in &nearest_on_level {
             // eprintln!("nearest = {:#?}", nearest);
@@ -462,15 +430,15 @@ mod tests {
 
         assert!(main_entry.level > 0);
 
-        let num_levels = graph_layers
-            .links_layers
-            .iter()
-            .map(|x| x.len())
+        let num_levels = (0..num_vectors)
+            .map(|i| graph_layers.links.point_level(i as PointOffsetType))
             .max()
             .unwrap();
-        assert_eq!(main_entry.level + 1, num_levels);
+        assert_eq!(main_entry.level, num_levels);
 
-        let total_links_0: usize = graph_layers.links_layers.iter().map(|x| x[0].len()).sum();
+        let total_links_0 = (0..num_vectors)
+            .map(|i| graph_layers.links.links(i as PointOffsetType, 0).len())
+            .sum::<usize>();
 
         eprintln!("total_links_0 = {:#?}", total_links_0);
         eprintln!("num_vectors = {:#?}", num_vectors);

commit 5e3416e2cef6d0a6af14407a057f84b175c15f77
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Nov 25 14:47:52 2022 +0400

    Hnsw links memmap (#1211)
    
    * add on disk key
    
    * remove obsolete graph initialization
    
    * remove obsolete max level
    
    * update openapi
    
    * graph links trait
    
    * use mmap option
    
    * same format for ram and mmap
    
    * fix segment unit tests
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix ci and add mmap test
    
    * review fixes
    
    * remove unused try-from
    
    * fix version compatibility
    
    * avoid loading from disk during conversion
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d37f5e571..d2615c7b3 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -5,10 +5,11 @@ use itertools::Itertools;
 use serde::{Deserialize, Serialize};
 
 use super::graph_links::GraphLinks;
-use crate::common::file_operations::{atomic_save_bin, read_bin};
+use crate::common::file_operations::{atomic_save_bin, read_bin, FileStorageError};
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
 use crate::index::hnsw_index::entry_points::EntryPoints;
+use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedList, VisitedPool};
@@ -21,6 +22,7 @@ pub type LinkContainerRef<'a> = &'a [PointOffsetType];
 pub type LayersContainer = Vec<LinkContainer>;
 
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";
+pub const HNSW_LINKS_FILE: &str = "links.bin";
 
 #[derive(Deserialize, Serialize, Debug)]
 pub struct GraphLayersBackwardCompatibility {
@@ -32,27 +34,14 @@ pub struct GraphLayersBackwardCompatibility {
     pub(super) entry_points: EntryPoints,
 }
 
-impl From<GraphLayersBackwardCompatibility> for GraphLayers {
-    fn from(gl: GraphLayersBackwardCompatibility) -> Self {
-        GraphLayers {
-            max_level: gl.max_level,
-            m: gl.m,
-            m0: gl.m0,
-            ef_construct: gl.ef_construct,
-            links: GraphLinks::from_vec(&gl.links_layers),
-            entry_points: gl.entry_points,
-            visited_pool: VisitedPool::new(),
-        }
-    }
-}
-
 #[derive(Deserialize, Serialize, Debug)]
-pub struct GraphLayers {
-    pub(super) max_level: usize,
+pub struct GraphLayers<TGraphLinks: GraphLinks> {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-    pub(super) links: GraphLinks,
+
+    #[serde(skip)]
+    pub(super) links: TGraphLinks,
     pub(super) entry_points: EntryPoints,
 
     #[serde(skip)]
@@ -169,9 +158,9 @@ pub trait GraphLayersBase {
     }
 }
 
-impl GraphLayersBase for GraphLayers {
+impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
     fn get_visited_list_from_pool(&self) -> VisitedList {
-        self.visited_pool.get(self.num_points())
+        self.visited_pool.get(self.links.num_points())
     }
 
     fn return_visited_list_to_pool(&self, visited_list: VisitedList) {
@@ -199,50 +188,7 @@ impl GraphLayersBase for GraphLayers {
 /// Object contains links between nodes for HNSW search
 ///
 /// Assume all scores are similarities. Larger score = closer points
-impl GraphLayers {
-    fn new_with_params(
-        num_vectors: usize, // Initial number of points in index
-        m: usize,           // Expected M for non-first layer
-        m0: usize,          // Expected M for first layer
-        ef_construct: usize,
-        entry_points_num: usize, // Depends on number of points
-        reserve: bool,
-    ) -> Self {
-        let mut links_layers: Vec<LayersContainer> = vec![];
-
-        for _i in 0..num_vectors {
-            let mut links: LinkContainer = Vec::new();
-            if reserve {
-                links.reserve(m0);
-            }
-            links_layers.push(vec![links]);
-        }
-
-        GraphLayers {
-            max_level: 0,
-            m,
-            m0,
-            ef_construct,
-            links: Default::default(),
-            entry_points: EntryPoints::new(entry_points_num),
-            visited_pool: VisitedPool::new(),
-        }
-    }
-
-    pub fn new(
-        num_vectors: usize, // Initial number of points in index
-        m: usize,           // Expected M for non-first layer
-        m0: usize,          // Expected M for first layer
-        ef_construct: usize,
-        entry_points_num: usize, // Depends on number of points
-    ) -> Self {
-        Self::new_with_params(num_vectors, m, m0, ef_construct, entry_points_num, true)
-    }
-
-    fn num_points(&self) -> usize {
-        self.links.num_points()
-    }
-
+impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
     pub fn point_level(&self, point_id: PointOffsetType) -> usize {
         self.links.point_level(point_id)
     }
@@ -277,17 +223,49 @@ impl GraphLayers {
         path.join(HNSW_GRAPH_FILE)
     }
 
-    pub fn load(path: &Path) -> OperationResult<Self> {
-        let try_self: Result<Self, _> = read_bin(path);
+    pub fn get_links_path(path: &Path) -> PathBuf {
+        path.join(HNSW_LINKS_FILE)
+    }
+}
+
+impl<TGraphLinks> GraphLayers<TGraphLinks>
+where
+    TGraphLinks: GraphLinks,
+{
+    pub fn load(graph_path: &Path, links_path: &Path) -> OperationResult<Self> {
+        let try_self: Result<Self, FileStorageError> = if links_path.exists() {
+            read_bin(graph_path)
+        } else {
+            Err(FileStorageError::generic_error(&format!(
+                "Links file does not exists: {:?}",
+                links_path
+            )))
+        };
 
         match try_self {
-            Ok(slf) => Ok(slf),
+            Ok(mut slf) => {
+                let links = TGraphLinks::load_from_file(links_path)?;
+                slf.links = links;
+                Ok(slf)
+            }
             Err(err) => {
-                let try_legacy: Result<GraphLayersBackwardCompatibility, _> = read_bin(path);
+                let try_legacy: Result<GraphLayersBackwardCompatibility, _> = read_bin(graph_path);
                 if let Ok(legacy) = try_legacy {
-                    let slf: Self = legacy.into();
                     log::debug!("Converting legacy graph to new format");
-                    slf.save(path)?;
+
+                    let mut converter = GraphLinksConverter::new(legacy.links_layers);
+                    converter.save_as(links_path)?;
+
+                    let links = TGraphLinks::from_converter(converter)?;
+                    let slf = Self {
+                        m: legacy.m,
+                        m0: legacy.m0,
+                        ef_construct: legacy.ef_construct,
+                        links,
+                        entry_points: legacy.entry_points,
+                        visited_pool: VisitedPool::new(),
+                    };
+                    slf.save(graph_path)?;
                     Ok(slf)
                 } else {
                     Err(err)?
@@ -316,15 +294,16 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
+    use crate::index::hnsw_index::graph_links::GraphLinksRam;
     use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
 
-    fn search_in_graph(
+    fn search_in_graph<TGraphLinks: GraphLinks>(
         query: &[VectorElementType],
         top: usize,
         vector_storage: &TestRawScorerProducer<CosineMetric>,
-        graph: &GraphLayers,
+        graph: &GraphLayers<TGraphLinks>,
     ) -> Vec<ScoredPointOffset> {
         let fake_filter_context = FakeFilterContext {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
@@ -348,12 +327,20 @@ mod tests {
         let vector_holder =
             TestRawScorerProducer::<DotProductMetric>::new(dim, num_vectors, &mut rng);
 
-        let mut graph_layers =
-            GraphLayers::new(num_vectors, m, m * 2, ef_construct, entry_points_num);
+        let mut graph_layers = GraphLayers {
+            m,
+            m0: 2 * m,
+            ef_construct,
+            links: GraphLinksRam::default(),
+            entry_points: EntryPoints::new(entry_points_num),
+            visited_pool: VisitedPool::new(),
+        };
 
         let mut graph_links = vec![vec![Vec::new()]; num_vectors];
         graph_links[0][0] = vec![1, 2, 3, 4, 5, 6];
-        graph_layers.links = GraphLinks::from_vec(&graph_links);
+
+        graph_layers.links =
+            GraphLinksRam::from_converter(GraphLinksConverter::new(graph_links.clone())).unwrap();
 
         let linking_idx: PointOffsetType = 7;
 
@@ -392,19 +379,25 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let (vector_holder, graph_layers) =
-            create_graph_layer_fixture::<CosineMetric, _>(num_vectors, M, dim, false, &mut rng);
+        let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
+        let links_path = GraphLayers::<GraphLinksRam>::get_links_path(dir.path());
+        let (vector_holder, graph_layers) = create_graph_layer_fixture::<CosineMetric, _>(
+            num_vectors,
+            M,
+            dim,
+            false,
+            &mut rng,
+            Some(&links_path),
+        );
 
         let query = random_vector(&mut rng, dim);
 
         let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
 
-        let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
-
-        let path = GraphLayers::get_path(dir.path());
+        let path = GraphLayers::<GraphLinksRam>::get_path(dir.path());
         graph_layers.save(&path).unwrap();
 
-        let graph2 = GraphLayers::load(&path).unwrap();
+        let graph2 = GraphLayers::<GraphLinksRam>::load(&path, &links_path).unwrap();
 
         let res2 = search_in_graph(&query, top, &vector_holder, &graph2);
 
@@ -421,7 +414,7 @@ mod tests {
         type M = CosineMetric;
 
         let (vector_holder, graph_layers) =
-            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, false, &mut rng);
+            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, false, &mut rng, None);
 
         let main_entry = graph_layers
             .entry_points
@@ -470,8 +463,14 @@ mod tests {
 
         let mut rng = StdRng::seed_from_u64(42);
 
-        let (vector_holder, graph_layers) =
-            create_graph_layer_fixture::<CosineMetric, _>(num_vectors, M, dim, true, &mut rng);
+        let (vector_holder, graph_layers) = create_graph_layer_fixture::<CosineMetric, _>(
+            num_vectors,
+            M,
+            dim,
+            true,
+            &mut rng,
+            None,
+        );
 
         let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
 

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d2615c7b3..8ebf94c50 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -237,8 +237,7 @@ where
             read_bin(graph_path)
         } else {
             Err(FileStorageError::generic_error(&format!(
-                "Links file does not exists: {:?}",
-                links_path
+                "Links file does not exists: {links_path:?}"
             )))
         };
 
@@ -433,8 +432,8 @@ mod tests {
             .map(|i| graph_layers.links.links(i as PointOffsetType, 0).len())
             .sum::<usize>();
 
-        eprintln!("total_links_0 = {:#?}", total_links_0);
-        eprintln!("num_vectors = {:#?}", num_vectors);
+        eprintln!("total_links_0 = {total_links_0:#?}");
+        eprintln!("num_vectors = {num_vectors:#?}");
         assert!(total_links_0 > 0);
         assert!(total_links_0 as f64 / num_vectors as f64 > M as f64);
 
@@ -483,11 +482,7 @@ mod tests {
 
         let mut file = File::create("graph.json").unwrap();
         file.write_all(
-            format!(
-                "{{ \"graph\": {}, \n \"vectors\": {} }}",
-                graph_json, vectors_json
-            )
-            .as_bytes(),
+            format!("{{ \"graph\": {graph_json}, \n \"vectors\": {vectors_json} }}").as_bytes(),
         )
         .unwrap();
     }

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 8ebf94c50..cce6beff7 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -306,7 +306,7 @@ mod tests {
     ) -> Vec<ScoredPointOffset> {
         let fake_filter_context = FakeFilterContext {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
-        let scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
+        let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
         graph.search(top, ef, scorer)
     }
@@ -346,7 +346,7 @@ mod tests {
         let fake_filter_context = FakeFilterContext {};
         let added_vector = vector_holder.vectors.get(linking_idx).to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector);
-        let mut scorer = FilteredScorer::new(&raw_scorer, Some(&fake_filter_context));
+        let mut scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
 
         let nearest_on_level = graph_layers.search_on_level(
             ScoredPointOffset {

commit 511704d88d8f915eb142e5873edbf20d249c3132
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Thu Apr 20 12:06:29 2023 +0200

    Add support for deleted vectors in segments (#1724)
    
    * Use resize rather than while-push loop
    
    * Add deleted flags to simple vector storage
    
    * Add deleted flag to memmap vector storage
    
    * Map BitSlice on mmap file for deleted flags
    
    * Use vector specific deletion BitSlice in RawScorer
    
    * Use BitSlice for deleted points, fix check point logic, clarify names
    
    * Extract div_ceil function to shared module
    
    * We can use unchecked set and replace because we just checked the length
    
    * Add deleted count function to vector storage
    
    * Add vector storage point deletion tests
    
    * Keep deleted state in simple vector storage with update_from, add test
    
    * Keep deleted state in memmap vector storage with update_from, add test
    
    * Simplify div_ceil
    
    * Improve deletion handling in update_from in mmap vector storage
    
    * Improve performance, use trickery to get BitSlice view over deleted mmap
    
    * Use BitSlice where possible, construct BitVec more efficiently
    
    * Incorporate vector specific delete flags in quantized raw scorer
    
    * Don't pin MmapMut, it is not required
    
    * With quantization, keep mmap deleted flags in RAM for better performance
    
    * Advice the kernel to prepare deleted flags mmap for faster future access
    
    * Simplify deleted bitslice access, add bound check, remove unused function
    
    * Fix compilation on Windows
    
    * Cleanup
    
    * Rename delete functions to delete_{point,vec} to prevent confusion
    
    * Use then_some rather than match a boolean
    
    * Lock deleted flags in memory only when quantization is available
    
    * Add docs and stabilize issue link to dev_ceil
    
    * Flush deleted mmap when closing segment
    
    This requires us to to wrap the memory map struct in an Arc and Mutex.
    Though this may look inefficient, it doesn't have a negative side effect
    on deleted flag performance, because the flags are accessed through a
    BitSlice that is separate and doesn't use locking.
    
    * Rename some point functions to vec because that makes more sense
    
    * Simplify delete flag fetching option, use deref func instead of asterisk
    
    * Do not calculate slice size manually, use size_of_val
    
    * remove test raw scorer
    
    * use deref in check
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index cce6beff7..dc43a8643 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -201,7 +201,7 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
     ) -> Vec<ScoredPointOffset> {
         let entry_point = match self
             .entry_points
-            .get_entry_point(|point_id| points_scorer.check_point(point_id))
+            .get_entry_point(|point_id| points_scorer.check_vec(point_id))
         {
             None => return vec![],
             Some(ep) => ep,

commit ecfeefdaa8d1a74358960842a99b96dee8147dd3
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Apr 24 13:02:29 2023 +0200

    Improve handling of out-of-disk-space errors during Qdrant startup (#1755)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index dc43a8643..f5aacca65 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -236,7 +236,7 @@ where
         let try_self: Result<Self, FileStorageError> = if links_path.exists() {
             read_bin(graph_path)
         } else {
-            Err(FileStorageError::generic_error(&format!(
+            Err(FileStorageError::generic(format!(
                 "Links file does not exists: {links_path:?}"
             )))
         };

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index f5aacca65..ec26c8fc4 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -201,7 +201,7 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
     ) -> Vec<ScoredPointOffset> {
         let entry_point = match self
             .entry_points
-            .get_entry_point(|point_id| points_scorer.check_vec(point_id))
+            .get_entry_point(|point_id| points_scorer.check_vector(point_id))
         {
             None => return vec![],
             Some(ep) => ep,
@@ -226,6 +226,10 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
     pub fn get_links_path(path: &Path) -> PathBuf {
         path.join(HNSW_LINKS_FILE)
     }
+
+    pub fn num_points(&self) -> usize {
+        self.links.num_points()
+    }
 }
 
 impl<TGraphLinks> GraphLayers<TGraphLinks>

commit 324274866bb930af78cebf18d072da003e41a7e2
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Jun 5 11:28:46 2023 +0200

    Add `prefault_mmap_pages` method to the `GraphLinksMmap` (#1791) (#2012)
    
    * Add `prefault_mmap_pages` method to the `HNSWIndex`
    
    * Add name to the thread spawned by `Segment::prefault_mmap_pages`

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index ec26c8fc4..92106a276 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -4,8 +4,9 @@ use std::path::{Path, PathBuf};
 use itertools::Itertools;
 use serde::{Deserialize, Serialize};
 
-use super::graph_links::GraphLinks;
+use super::graph_links::{GraphLinks, GraphLinksMmap};
 use crate::common::file_operations::{atomic_save_bin, read_bin, FileStorageError};
+use crate::common::mmap_ops;
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
 use crate::index::hnsw_index::entry_points::EntryPoints;
@@ -282,6 +283,12 @@ where
     }
 }
 
+impl GraphLayers<GraphLinksMmap> {
+    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
+        self.links.prefault_mmap_pages(path)
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use std::fs::File;

commit 2b28fa3df0a228748501fbfa00e0cf138b80ab1a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 28 18:11:21 2023 +0200

    split search_existing_point_on_level and regular search_on_level functions (#2167)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 92106a276..53c0e83ee 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -98,7 +98,6 @@ pub trait GraphLayersBase {
         level: usize,
         ef: usize,
         points_scorer: &mut FilteredScorer,
-        existing_links: &[PointOffsetType],
     ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
         let mut visited_list = self.get_visited_list_from_pool();
         visited_list.check_and_update_visited(level_entry.idx);
@@ -106,15 +105,6 @@ pub trait GraphLayersBase {
 
         self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
 
-        for &existing_link in existing_links {
-            if !visited_list.check(existing_link) {
-                search_context.process_candidate(ScoredPointOffset {
-                    idx: existing_link,
-                    score: points_scorer.score_point(existing_link),
-                });
-            }
-        }
-
         self.return_visited_list_to_pool(visited_list);
         search_context.nearest
     }
@@ -215,8 +205,7 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
             &mut points_scorer,
         );
 
-        let nearest =
-            self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer, &[]);
+        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer);
         nearest.into_iter().take(top).collect_vec()
     }
 
@@ -367,7 +356,6 @@ mod tests {
             0,
             32,
             &mut scorer,
-            &[],
         );
 
         assert_eq!(nearest_on_level.len(), graph_links[0][0].len() + 1);

commit 52a8fb3a75bfab1dddfd040dad44577daa68f079
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jul 24 15:06:15 2023 +0200

    move priority queue to new common crate (#2304)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 53c0e83ee..9e19307c7 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -1,6 +1,7 @@
 use std::cmp::max;
 use std::path::{Path, PathBuf};
 
+use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use itertools::Itertools;
 use serde::{Deserialize, Serialize};
 
@@ -14,7 +15,6 @@ use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedList, VisitedPool};
-use crate::spaces::tools::FixedLengthPriorityQueue;
 use crate::types::PointOffsetType;
 use crate::vector_storage::ScoredPointOffset;
 

commit b9ad046d51ffa7870d00a5707d68d9e8c32e346b
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Fri Sep 1 02:55:22 2023 -0400

    refactor: Make `preprocess()` own its vector argument (#2553)
    
    * make preprocess own its vector argument
    
    * update doc comment

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 9e19307c7..623de083b 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -438,7 +438,7 @@ mod tests {
 
         let top = 5;
         let query = random_vector(&mut rng, dim);
-        let processed_query = M::preprocess(&query).unwrap_or_else(|| query.clone());
+        let processed_query = M::preprocess(query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for idx in 0..vector_holder.vectors.len() as PointOffsetType {
             let vec = &vector_holder.vectors.get(idx);

commit b35177d16c36cebe097299bf363f3dcee38531e8
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 21 09:13:19 2023 +0200

    introduce IO common module (#2704)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 623de083b..0d94a71dd 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -2,11 +2,11 @@ use std::cmp::max;
 use std::path::{Path, PathBuf};
 
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
+use io::file_operations::{atomic_save_bin, read_bin, FileStorageError};
 use itertools::Itertools;
 use serde::{Deserialize, Serialize};
 
 use super::graph_links::{GraphLinks, GraphLinksMmap};
-use crate::common::file_operations::{atomic_save_bin, read_bin, FileStorageError};
 use crate::common::mmap_ops;
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;

commit abd0d57d5d73e5530f5f356a86c7c4b478be9561
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 25 11:30:50 2023 +0200

    Introduce Memory common module (#2712)
    
    * Introduce Memory common module
    
    * fix Windaube build
    
    * move mmap_ops as well

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0d94a71dd..390b60b03 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -4,10 +4,10 @@ use std::path::{Path, PathBuf};
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use io::file_operations::{atomic_save_bin, read_bin, FileStorageError};
 use itertools::Itertools;
+use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::graph_links::{GraphLinks, GraphLinksMmap};
-use crate::common::mmap_ops;
 use crate::common::utils::rev_range;
 use crate::entry::entry_point::OperationResult;
 use crate::index::hnsw_index::entry_points::EntryPoints;

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 390b60b03..0e4ad42f2 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -2,6 +2,7 @@ use std::cmp::max;
 use std::path::{Path, PathBuf};
 
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
+use common::types::{PointOffsetType, ScoredPointOffset};
 use io::file_operations::{atomic_save_bin, read_bin, FileStorageError};
 use itertools::Itertools;
 use memory::mmap_ops;
@@ -15,8 +16,6 @@ use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedList, VisitedPool};
-use crate::types::PointOffsetType;
-use crate::vector_storage::ScoredPointOffset;
 
 pub type LinkContainer = Vec<PointOffsetType>;
 pub type LinkContainerRef<'a> = &'a [PointOffsetType];

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0e4ad42f2..40325c272 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -9,8 +9,8 @@ use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::graph_links::{GraphLinks, GraphLinksMmap};
+use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
-use crate::entry::entry_point::OperationResult;
 use crate::index::hnsw_index::entry_points::EntryPoints;
 use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;

commit 31d6bc80444f7385b4d02d8faf0cde4021d4cd72
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Wed Oct 18 09:14:32 2023 -0300

    Allow selecting custom entry points at segment level (#2834)
    
    * allow selecting custom entry points at segment level
    
    * empty commit
    
    * fix ci build
    
    * restrict refactor up to search_with_graph

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 40325c272..61cefabff 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -8,6 +8,7 @@ use itertools::Itertools;
 use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
+use super::entry_points::EntryPoint;
 use super::graph_links::{GraphLinks, GraphLinksMmap};
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
@@ -179,22 +180,44 @@ impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
 ///
 /// Assume all scores are similarities. Larger score = closer points
 impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
+    /// Returns the highest level this point is included in
     pub fn point_level(&self, point_id: PointOffsetType) -> usize {
         self.links.point_level(point_id)
     }
 
+    fn get_entry_point(
+        &self,
+        points_scorer: &FilteredScorer,
+        custom_entry_points: Option<&[PointOffsetType]>,
+    ) -> Option<EntryPoint> {
+        // Try to get it from custom entry points
+        custom_entry_points
+            .and_then(|custom_entry_points| {
+                custom_entry_points
+                    .iter()
+                    .filter(|&&point_id| points_scorer.check_vector(point_id))
+                    .map(|&point_id| {
+                        let level = self.point_level(point_id);
+                        EntryPoint { point_id, level }
+                    })
+                    .max_by_key(|ep| ep.level)
+            })
+            .or_else(|| {
+                // Otherwise use normal entry points
+                self.entry_points
+                    .get_entry_point(|point_id| points_scorer.check_vector(point_id))
+            })
+    }
+
     pub fn search(
         &self,
         top: usize,
         ef: usize,
         mut points_scorer: FilteredScorer,
+        custom_entry_points: Option<&[PointOffsetType]>,
     ) -> Vec<ScoredPointOffset> {
-        let entry_point = match self
-            .entry_points
-            .get_entry_point(|point_id| points_scorer.check_vector(point_id))
-        {
-            None => return vec![],
-            Some(ep) => ep,
+        let Some(entry_point) = self.get_entry_point(&points_scorer, custom_entry_points) else {
+            return Vec::default();
         };
 
         let zero_level_entry = self.search_entry(
@@ -307,7 +330,7 @@ mod tests {
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
         let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
-        graph.search(top, ef, scorer)
+        graph.search(top, ef, scorer, None)
     }
 
     const M: usize = 8;

commit b88e187bdba81a75e1ec59125fcd21590c43c24e
Author: Apostolos Matsagkas <Apmats@users.noreply.github.com>
Date:   Wed Oct 25 12:56:18 2023 +0300

    Fix overeager marking of visited points during search (#2864)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 61cefabff..83f480541 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -79,16 +79,16 @@ pub trait GraphLayersBase {
 
             points_ids.clear();
             self.links_map(candidate.idx, level, |link| {
-                if !visited_list.check_and_update_visited(link) {
+                if !visited_list.check(link) {
                     points_ids.push(link);
                 }
             });
 
             let scores = points_scorer.score_points(&mut points_ids, limit);
-            scores
-                .iter()
-                .copied()
-                .for_each(|score_point| searcher.process_candidate(score_point));
+            scores.iter().copied().for_each(|score_point| {
+                searcher.process_candidate(score_point);
+                visited_list.check_and_update_visited(score_point.idx);
+            });
         }
     }
 

commit be1244db565c92c6fc4c5cbe03869e96d18dd37b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Oct 25 16:12:36 2023 +0200

    Hnsw parallel build accuracy (#2869)
    
    * fixes for parallel HNSW graph building
    
    * mft
    
    * fix the bug by introducing ready_list, do not use unready point in parallel building
    
    * fmt
    
    * rm debug code
    
    * clippy fix
    
    * fix test
    
    * fmt
    
    * review fixes
    
    * clippy fix
    
    * fix filtered hnsw build

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 83f480541..1b68107e0 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -226,7 +226,6 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
             0,
             &mut points_scorer,
         );
-
         let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer);
         nearest.into_iter().take(top).collect_vec()
     }

commit 2421624c1764a68d47a097c6384a878383b79537
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Oct 30 18:02:52 2023 +0100

    Return visited list by drop (#2801)
    
    * return visited list by drop
    
    * review remarks

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 1b68107e0..20c9f1e31 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -16,7 +16,7 @@ use crate::index::hnsw_index::entry_points::EntryPoints;
 use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
-use crate::index::visited_pool::{VisitedList, VisitedPool};
+use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
 
 pub type LinkContainer = Vec<PointOffsetType>;
 pub type LinkContainerRef<'a> = &'a [PointOffsetType];
@@ -50,9 +50,7 @@ pub struct GraphLayers<TGraphLinks: GraphLinks> {
 }
 
 pub trait GraphLayersBase {
-    fn get_visited_list_from_pool(&self) -> VisitedList;
-
-    fn return_visited_list_to_pool(&self, visited_list: VisitedList);
+    fn get_visited_list_from_pool(&self) -> VisitedListHandle;
 
     fn links_map<F>(&self, point_id: PointOffsetType, level: usize, f: F)
     where
@@ -66,7 +64,7 @@ pub trait GraphLayersBase {
         &self,
         searcher: &mut SearchContext,
         level: usize,
-        visited_list: &mut VisitedList,
+        visited_list: &mut VisitedListHandle,
         points_scorer: &mut FilteredScorer,
     ) {
         let limit = self.get_m(level);
@@ -104,8 +102,6 @@ pub trait GraphLayersBase {
         let mut search_context = SearchContext::new(level_entry, ef);
 
         self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
-
-        self.return_visited_list_to_pool(visited_list);
         search_context.nearest
     }
 
@@ -150,14 +146,10 @@ pub trait GraphLayersBase {
 }
 
 impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
-    fn get_visited_list_from_pool(&self) -> VisitedList {
+    fn get_visited_list_from_pool(&self) -> VisitedListHandle {
         self.visited_pool.get(self.links.num_points())
     }
 
-    fn return_visited_list_to_pool(&self, visited_list: VisitedList) {
-        self.visited_pool.return_back(visited_list);
-    }
-
     fn links_map<F>(&self, point_id: PointOffsetType, level: usize, mut f: F)
     where
         F: FnMut(PointOffsetType),

commit 7134ba7dc25ad7a2dccbbf9c3bd4f3072e46f6c5
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Oct 31 23:44:20 2023 +0100

    raw scorer with operation result (#2897)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 20c9f1e31..ef1c1d13a 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -318,7 +318,7 @@ mod tests {
         graph: &GraphLayers<TGraphLinks>,
     ) -> Vec<ScoredPointOffset> {
         let fake_filter_context = FakeFilterContext {};
-        let raw_scorer = vector_storage.get_raw_scorer(query.to_owned());
+        let raw_scorer = vector_storage.get_raw_scorer(query.to_owned()).unwrap();
         let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
         graph.search(top, ef, scorer, None)
@@ -358,7 +358,7 @@ mod tests {
 
         let fake_filter_context = FakeFilterContext {};
         let added_vector = vector_holder.vectors.get(linking_idx).to_vec();
-        let raw_scorer = vector_holder.get_raw_scorer(added_vector);
+        let raw_scorer = vector_holder.get_raw_scorer(added_vector).unwrap();
         let mut scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
 
         let nearest_on_level = graph_layers.search_on_level(

commit 19cda34e073b92cb0d4052ff8269b710b11cc51c
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Apr 18 00:42:17 2024 +0200

    Byte storage integration into segment (#4049)
    
    * byte storage with quantization
    
    raw scorer integration
    
    config and test
    
    are you happy fmt
    
    fn renamings
    
    cow refactor
    
    use quantization branch
    
    quantization update
    
    * are you happy clippy
    
    * don't use distance in quantized scorers
    
    * fix build
    
    * add fn quantization_preprocess
    
    * apply preprocessing for only cosine float metric
    
    * fix sparse vectors tests
    
    * update openapi
    
    * more complicated integration test
    
    * update openapi comment
    
    * mmap byte storages support
    
    * fix async test
    
    * move .unwrap closer to the actual check of the vector presence
    
    * fmt
    
    * remove distance similarity function
    
    * avoid copying data while working with cow
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index ef1c1d13a..4d01e90e2 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -451,7 +451,7 @@ mod tests {
 
         let top = 5;
         let query = random_vector(&mut rng, dim);
-        let processed_query = M::preprocess(query.clone());
+        let processed_query = <M as Metric<VectorElementType>>::preprocess(query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for idx in 0..vector_holder.vectors.len() as PointOffsetType {
             let vec = &vector_holder.vectors.get(idx);

commit a06d20fb58a70f369c3a3b40178b726a291e6423
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 8 07:51:59 2024 +0000

    Remove dead code (#4623)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 4d01e90e2..0388cc042 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -19,7 +19,6 @@ use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
 
 pub type LinkContainer = Vec<PointOffsetType>;
-pub type LinkContainerRef<'a> = &'a [PointOffsetType];
 pub type LayersContainer = Vec<LinkContainer>;
 
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";

commit 649560fefd0cce811d8ada7d5c280991bfbb233f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Aug 7 16:34:58 2024 +0200

    Use mmap lock as default vector storage (#4828)
    
    * add force_ram parameter to chuncked mmap vector storage
    
    * enable mlocked mmap vector storage on unix by default
    
    * regen openapi
    
    * add mlock on creation of chunck
    
    * minor unrelated renaming
    
    * rollback changes in LockedChunkedMmap
    
    * fmt
    
    * make AppendableMmapDenseVectorStorage generic of storage type
    
    * make AppendableMmapMultiDenseVectorStorage generic of storage type
    
    * implement initialization of InRamChunkedMmap
    
    * implement MultiDenseAppendableInRam and variations
    
    * enable InRamChunkedMmap for multivectors
    
    * use same CHUNK_SIZE for mmap and regular chuncked vectors
    
    * enable InRamChunkedMmap by default
    
    * fix tests
    
    * rollback usage of InRamChunkedMmap by default
    
    * review changes
    
    * add assertion on chunk_capacity [skip-ci]

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0388cc042..dd2b3e2d1 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -309,6 +309,7 @@ mod tests {
     use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
+    use crate::vector_storage::chunked_vector_storage::VectorOffsetType;
 
     fn search_in_graph<TGraphLinks: GraphLinks>(
         query: &[VectorElementType],
@@ -356,7 +357,10 @@ mod tests {
         let linking_idx: PointOffsetType = 7;
 
         let fake_filter_context = FakeFilterContext {};
-        let added_vector = vector_holder.vectors.get(linking_idx).to_vec();
+        let added_vector = vector_holder
+            .vectors
+            .get(linking_idx as VectorOffsetType)
+            .to_vec();
         let raw_scorer = vector_holder.get_raw_scorer(added_vector).unwrap();
         let mut scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
 
@@ -453,7 +457,7 @@ mod tests {
         let processed_query = <M as Metric<VectorElementType>>::preprocess(query.clone());
         let mut reference_top = FixedLengthPriorityQueue::new(top);
         for idx in 0..vector_holder.vectors.len() as PointOffsetType {
-            let vec = &vector_holder.vectors.get(idx);
+            let vec = &vector_holder.vectors.get(idx as VectorOffsetType);
             reference_top.push(ScoredPointOffset {
                 idx,
                 score: M::similarity(vec, &processed_query),
@@ -486,7 +490,12 @@ mod tests {
 
         let vectors_json = serde_json::to_string_pretty(
             &(0..vector_holder.vectors.len() as PointOffsetType)
-                .map(|point_id| vector_holder.vectors.get(point_id).to_vec())
+                .map(|point_id| {
+                    vector_holder
+                        .vectors
+                        .get(point_id as VectorOffsetType)
+                        .to_vec()
+                })
                 .collect_vec(),
         )
         .unwrap();

commit cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Oct 25 09:52:18 2024 +0200

    Hw counter utilization checks (#5288)
    
    * Enforce usage of hardware counter values
    
    * improve comments
    
    * log a warning in release mode
    
    * some minor improvements
    
    * avoid cloning for hardware counter
    
    * fmt
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index dd2b3e2d1..7b7d30ffe 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -319,9 +319,12 @@ mod tests {
     ) -> Vec<ScoredPointOffset> {
         let fake_filter_context = FakeFilterContext {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned()).unwrap();
+
         let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
-        graph.search(top, ef, scorer, None)
+        let res = graph.search(top, ef, scorer, None);
+        raw_scorer.take_hardware_counter().discard_results();
+        res
     }
 
     const M: usize = 8;
@@ -383,6 +386,8 @@ mod tests {
                 scorer.score_internal(linking_idx, nearest.idx)
             )
         }
+
+        raw_scorer.take_hardware_counter().discard_results();
     }
 
     #[test]

commit fdec05f99a0c728e4661105e9769c42ba887fa24
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Nov 7 10:54:14 2024 +0000

    GraphLinksMmap: remove Option (#5374)
    
    * Introduce GraphLayerData
    
    * trait GraphLinks: do not require Default

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 7b7d30ffe..d7435bbb1 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -1,3 +1,4 @@
+use std::borrow::Cow;
 use std::cmp::max;
 use std::path::{Path, PathBuf};
 
@@ -24,27 +25,33 @@ pub type LayersContainer = Vec<LinkContainer>;
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";
 pub const HNSW_LINKS_FILE: &str = "links.bin";
 
+/// Contents of the `graph.bin` file.
 #[derive(Deserialize, Serialize, Debug)]
-pub struct GraphLayersBackwardCompatibility {
-    pub(super) max_level: usize,
-    pub(super) m: usize,
-    pub(super) m0: usize,
-    pub(super) ef_construct: usize,
-    pub(super) links_layers: Vec<LayersContainer>,
-    pub(super) entry_points: EntryPoints,
+struct GraphLayerData<'a> {
+    m: usize,
+    m0: usize,
+    ef_construct: usize,
+    entry_points: Cow<'a, EntryPoints>,
 }
 
+/// Contents of the `graph.bin` file (Qdrant 0.8.4).
 #[derive(Deserialize, Serialize, Debug)]
+struct GraphLayersBackwardCompatibility {
+    max_level: usize,
+    m: usize,
+    m0: usize,
+    ef_construct: usize,
+    links_layers: Vec<LayersContainer>,
+    entry_points: EntryPoints,
+}
+
+#[derive(Debug)]
 pub struct GraphLayers<TGraphLinks: GraphLinks> {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-
-    #[serde(skip)]
     pub(super) links: TGraphLinks,
     pub(super) entry_points: EntryPoints,
-
-    #[serde(skip)]
     pub(super) visited_pool: VisitedPool,
 }
 
@@ -239,7 +246,7 @@ where
     TGraphLinks: GraphLinks,
 {
     pub fn load(graph_path: &Path, links_path: &Path) -> OperationResult<Self> {
-        let try_self: Result<Self, FileStorageError> = if links_path.exists() {
+        let try_data: Result<GraphLayerData, FileStorageError> = if links_path.exists() {
             read_bin(graph_path)
         } else {
             Err(FileStorageError::generic(format!(
@@ -247,11 +254,17 @@ where
             )))
         };
 
-        match try_self {
-            Ok(mut slf) => {
+        match try_data {
+            Ok(data) => {
                 let links = TGraphLinks::load_from_file(links_path)?;
-                slf.links = links;
-                Ok(slf)
+                Ok(Self {
+                    m: data.m,
+                    m0: data.m0,
+                    ef_construct: data.ef_construct,
+                    links,
+                    entry_points: data.entry_points.into_owned(),
+                    visited_pool: VisitedPool::new(),
+                })
             }
             Err(err) => {
                 let try_legacy: Result<GraphLayersBackwardCompatibility, _> = read_bin(graph_path);
@@ -280,12 +293,21 @@ where
     }
 
     pub fn save(&self, path: &Path) -> OperationResult<()> {
-        Ok(atomic_save_bin(path, self)?)
+        Ok(atomic_save_bin(path, &self.data())?)
+    }
+
+    fn data(&self) -> GraphLayerData {
+        GraphLayerData {
+            m: self.m,
+            m0: self.m0,
+            ef_construct: self.ef_construct,
+            entry_points: Cow::Borrowed(&self.entry_points),
+        }
     }
 }
 
 impl GraphLayers<GraphLinksMmap> {
-    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
+    pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
         self.links.prefault_mmap_pages(path)
     }
 }
@@ -342,21 +364,19 @@ mod tests {
         let vector_holder =
             TestRawScorerProducer::<DotProductMetric>::new(dim, num_vectors, &mut rng);
 
-        let mut graph_layers = GraphLayers {
+        let mut graph_links = vec![vec![Vec::new()]; num_vectors];
+        graph_links[0][0] = vec![1, 2, 3, 4, 5, 6];
+
+        let graph_layers = GraphLayers {
             m,
             m0: 2 * m,
             ef_construct,
-            links: GraphLinksRam::default(),
+            links: GraphLinksRam::from_converter(GraphLinksConverter::new(graph_links.clone()))
+                .unwrap(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),
         };
 
-        let mut graph_links = vec![vec![Vec::new()]; num_vectors];
-        graph_links[0][0] = vec![1, 2, 3, 4, 5, 6];
-
-        graph_layers.links =
-            GraphLinksRam::from_converter(GraphLinksConverter::new(graph_links.clone())).unwrap();
-
         let linking_idx: PointOffsetType = 7;
 
         let fake_filter_context = FakeFilterContext {};
@@ -491,7 +511,7 @@ mod tests {
             None,
         );
 
-        let graph_json = serde_json::to_string_pretty(&graph_layers).unwrap();
+        let graph_json = serde_json::to_string_pretty(&graph_layers.data()).unwrap();
 
         let vectors_json = serde_json::to_string_pretty(
             &(0..vector_holder.vectors.len() as PointOffsetType)

commit 2fb5f12ea7455cf5a70d41813f2e56f7b4617e78
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Nov 15 05:19:55 2024 +0000

    Introduce GraphLinksRef (#5377)
    
    * GraphLinksView
    
    * GraphLinks::links: return iterator instead of slice

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index d7435bbb1..42c075178 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -161,7 +161,7 @@ impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
         F: FnMut(PointOffsetType),
     {
         for link in self.links.links(point_id, level) {
-            f(*link);
+            f(link);
         }
     }
 
@@ -469,7 +469,7 @@ mod tests {
         assert_eq!(main_entry.level, num_levels);
 
         let total_links_0 = (0..num_vectors)
-            .map(|i| graph_layers.links.links(i as PointOffsetType, 0).len())
+            .map(|i| graph_layers.links.links(i as PointOffsetType, 0).count())
             .sum::<usize>();
 
         eprintln!("total_links_0 = {total_links_0:#?}");

commit 1637ee490aa14d7d80265d6a0bb4d60a677113ea
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Nov 26 19:17:04 2024 +0000

    Drop GraphLayersBackwardCompatibility (#5486)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 42c075178..32c3bc222 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -4,7 +4,7 @@ use std::path::{Path, PathBuf};
 
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoredPointOffset};
-use io::file_operations::{atomic_save_bin, read_bin, FileStorageError};
+use io::file_operations::{atomic_save_bin, read_bin};
 use itertools::Itertools;
 use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
@@ -14,7 +14,6 @@ use super::graph_links::{GraphLinks, GraphLinksMmap};
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
-use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
@@ -34,17 +33,6 @@ struct GraphLayerData<'a> {
     entry_points: Cow<'a, EntryPoints>,
 }
 
-/// Contents of the `graph.bin` file (Qdrant 0.8.4).
-#[derive(Deserialize, Serialize, Debug)]
-struct GraphLayersBackwardCompatibility {
-    max_level: usize,
-    m: usize,
-    m0: usize,
-    ef_construct: usize,
-    links_layers: Vec<LayersContainer>,
-    entry_points: EntryPoints,
-}
-
 #[derive(Debug)]
 pub struct GraphLayers<TGraphLinks: GraphLinks> {
     pub(super) m: usize,
@@ -246,50 +234,15 @@ where
     TGraphLinks: GraphLinks,
 {
     pub fn load(graph_path: &Path, links_path: &Path) -> OperationResult<Self> {
-        let try_data: Result<GraphLayerData, FileStorageError> = if links_path.exists() {
-            read_bin(graph_path)
-        } else {
-            Err(FileStorageError::generic(format!(
-                "Links file does not exists: {links_path:?}"
-            )))
-        };
-
-        match try_data {
-            Ok(data) => {
-                let links = TGraphLinks::load_from_file(links_path)?;
-                Ok(Self {
-                    m: data.m,
-                    m0: data.m0,
-                    ef_construct: data.ef_construct,
-                    links,
-                    entry_points: data.entry_points.into_owned(),
-                    visited_pool: VisitedPool::new(),
-                })
-            }
-            Err(err) => {
-                let try_legacy: Result<GraphLayersBackwardCompatibility, _> = read_bin(graph_path);
-                if let Ok(legacy) = try_legacy {
-                    log::debug!("Converting legacy graph to new format");
-
-                    let mut converter = GraphLinksConverter::new(legacy.links_layers);
-                    converter.save_as(links_path)?;
-
-                    let links = TGraphLinks::from_converter(converter)?;
-                    let slf = Self {
-                        m: legacy.m,
-                        m0: legacy.m0,
-                        ef_construct: legacy.ef_construct,
-                        links,
-                        entry_points: legacy.entry_points,
-                        visited_pool: VisitedPool::new(),
-                    };
-                    slf.save(graph_path)?;
-                    Ok(slf)
-                } else {
-                    Err(err)?
-                }
-            }
-        }
+        let graph_data: GraphLayerData = read_bin(graph_path)?;
+        Ok(Self {
+            m: graph_data.m,
+            m0: graph_data.m0,
+            ef_construct: graph_data.ef_construct,
+            links: TGraphLinks::load_from_file(links_path)?,
+            entry_points: graph_data.entry_points.into_owned(),
+            visited_pool: VisitedPool::new(),
+        })
     }
 
     pub fn save(&self, path: &Path) -> OperationResult<()> {
@@ -327,7 +280,7 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
-    use crate::index::hnsw_index::graph_links::GraphLinksRam;
+    use crate::index::hnsw_index::graph_links::{GraphLinksConverter, GraphLinksRam};
     use crate::index::hnsw_index::tests::create_graph_layer_fixture;
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};

commit 1db3cfaa36820c6a9ff7a7fa33b61019d08134ec
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Nov 26 21:35:26 2024 +0000

    GraphLinks::for_each_link (#5490)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 32c3bc222..4d654379b 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -148,9 +148,7 @@ impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
     where
         F: FnMut(PointOffsetType),
     {
-        for link in self.links.links(point_id, level) {
-            f(link);
-        }
+        self.links.for_each_link(point_id, level, &mut f);
     }
 
     fn get_m(&self, level: usize) -> usize {
@@ -422,7 +420,7 @@ mod tests {
         assert_eq!(main_entry.level, num_levels);
 
         let total_links_0 = (0..num_vectors)
-            .map(|i| graph_layers.links.links(i as PointOffsetType, 0).count())
+            .map(|i| graph_layers.links.links_vec(i as PointOffsetType, 0).len())
             .sum::<usize>();
 
         eprintln!("total_links_0 = {total_links_0:#?}");

commit 362a721d084993585b39da2d7f46562bbfb143c4
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Nov 28 09:15:54 2024 +0100

    Gpu hnsw construction (#5529)
    
    * gpu hnsw construction
    
    * fix build
    
    * are you happy clippy
    
    * are you happy clippy
    
    * review remarks
    
    * more comments
    
    * external gpu vector storage
    
    * decompose gpu inserter
    
    * are you happy codespell
    
    * are you happy clippy

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 4d654379b..712db155f 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -137,6 +137,41 @@ pub trait GraphLayersBase {
         }
         current_point
     }
+
+    #[cfg(test)]
+    #[cfg(feature = "gpu")]
+    fn search_entry_on_level(
+        &self,
+        entry_point: PointOffsetType,
+        level: usize,
+        points_scorer: &mut FilteredScorer,
+    ) -> ScoredPointOffset {
+        let limit = self.get_m(level);
+        let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
+        let mut current_point = ScoredPointOffset {
+            idx: entry_point,
+            score: points_scorer.score_point(entry_point),
+        };
+
+        let mut changed = true;
+        while changed {
+            changed = false;
+
+            links.clear();
+            self.links_map(current_point.idx, level, |link| {
+                links.push(link);
+            });
+
+            let scores = points_scorer.score_points(&mut links, limit);
+            scores.iter().copied().for_each(|score_point| {
+                if score_point.score > current_point.score {
+                    changed = true;
+                    current_point = score_point;
+                }
+            });
+        }
+        current_point
+    }
 }
 
 impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {

commit f8f9af04474321e6c7b4fc4a292766021c5078d6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Dec 10 00:23:44 2024 +0000

    GraphLinksConverter: take `m` and `compressed` arguments (#5489)
    
    * GraphLinksConverter: take `m` and `compressed` arguments
    
    * Add m0 parameter
    
    * Fixup
    
    * LinkCompressionExperimentalSetting

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 712db155f..be0ab4778 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -266,8 +266,13 @@ impl<TGraphLinks> GraphLayers<TGraphLinks>
 where
     TGraphLinks: GraphLinks,
 {
-    pub fn load(graph_path: &Path, links_path: &Path) -> OperationResult<Self> {
+    pub fn load(graph_path: &Path, links_path: &Path, convert: bool) -> OperationResult<Self> {
         let graph_data: GraphLayerData = read_bin(graph_path)?;
+
+        if convert {
+            // TODO: Implement conversion
+        }
+
         Ok(Self {
             m: graph_data.m,
             m0: graph_data.m0,
@@ -306,6 +311,7 @@ mod tests {
     use itertools::Itertools;
     use rand::rngs::StdRng;
     use rand::SeedableRng;
+    use rstest::rstest;
     use tempfile::Builder;
 
     use super::*;
@@ -337,8 +343,10 @@ mod tests {
 
     const M: usize = 8;
 
-    #[test]
-    fn test_search_on_level() {
+    #[rstest]
+    #[case::uncompressed(false)]
+    #[case::compressed(true)]
+    fn test_search_on_level(#[case] compressed: bool) {
         let dim = 8;
         let m = 8;
         let ef_construct = 32;
@@ -357,8 +365,13 @@ mod tests {
             m,
             m0: 2 * m,
             ef_construct,
-            links: GraphLinksRam::from_converter(GraphLinksConverter::new(graph_links.clone()))
-                .unwrap(),
+            links: GraphLinksRam::from_converter(GraphLinksConverter::new(
+                graph_links.clone(),
+                compressed,
+                m,
+                2 * m,
+            ))
+            .unwrap(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),
         };
@@ -396,8 +409,11 @@ mod tests {
         raw_scorer.take_hardware_counter().discard_results();
     }
 
-    #[test]
-    fn test_save_and_load() {
+    #[rstest]
+    #[case::uncompressed((false, false))]
+    #[case::converted((false, true))]
+    #[case::compressed((true, false))]
+    fn test_save_and_load(#[case] (compressed, converted): (bool, bool)) {
         let num_vectors = 100;
         let dim = 8;
         let top = 5;
@@ -410,6 +426,7 @@ mod tests {
             num_vectors,
             M,
             dim,
+            compressed,
             false,
             &mut rng,
             Some(&links_path),
@@ -422,15 +439,17 @@ mod tests {
         let path = GraphLayers::<GraphLinksRam>::get_path(dir.path());
         graph_layers.save(&path).unwrap();
 
-        let graph2 = GraphLayers::<GraphLinksRam>::load(&path, &links_path).unwrap();
+        let graph2 = GraphLayers::<GraphLinksRam>::load(&path, &links_path, converted).unwrap();
 
         let res2 = search_in_graph(&query, top, &vector_holder, &graph2);
 
         assert_eq!(res1, res2)
     }
 
-    #[test]
-    fn test_add_points() {
+    #[rstest]
+    #[case::uncompressed(false)]
+    #[case::compressed(true)]
+    fn test_add_points(#[case] compressed: bool) {
         let num_vectors = 1000;
         let dim = 8;
 
@@ -438,8 +457,15 @@ mod tests {
 
         type M = CosineMetric;
 
-        let (vector_holder, graph_layers) =
-            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, false, &mut rng, None);
+        let (vector_holder, graph_layers) = create_graph_layer_fixture::<M, _>(
+            num_vectors,
+            M,
+            dim,
+            compressed,
+            false,
+            &mut rng,
+            None,
+        );
 
         let main_entry = graph_layers
             .entry_points
@@ -493,6 +519,7 @@ mod tests {
             M,
             dim,
             true,
+            true,
             &mut rng,
             None,
         );

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index be0ab4778..0d35de196 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -336,9 +336,7 @@ mod tests {
 
         let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
-        let res = graph.search(top, ef, scorer, None);
-        raw_scorer.take_hardware_counter().discard_results();
-        res
+        graph.search(top, ef, scorer, None)
     }
 
     const M: usize = 8;
@@ -405,8 +403,6 @@ mod tests {
                 scorer.score_internal(linking_idx, nearest.idx)
             )
         }
-
-        raw_scorer.take_hardware_counter().discard_results();
     }
 
     #[rstest]

commit 5c072a2d2609c595e4bb60b50964b62bf79f6c03
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Dec 18 11:29:34 2024 +0000

    Implement links compression (#5492)
    
    * common::bitpacking::packed_bits
    
    * BitWriter::new(): append, don't clear the buffer
    
    * common::bitpacking_links
    
    * Implement links compression
    
    * Update

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0d35de196..76f32a497 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -10,7 +10,7 @@ use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
-use super::graph_links::{GraphLinks, GraphLinksMmap};
+use super::graph_links::{convert_to_compressed, GraphLinks, GraphLinksMmap};
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
@@ -270,7 +270,7 @@ where
         let graph_data: GraphLayerData = read_bin(graph_path)?;
 
         if convert {
-            // TODO: Implement conversion
+            convert_to_compressed(links_path, graph_data.m, graph_data.m0)?;
         }
 
         Ok(Self {

commit 9fca663adb00140e0e5a80b2d21dfeafeb274d37
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Dec 18 21:02:27 2024 +0000

    Update hnsw_search_graph benchmark (#5666)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 76f32a497..0e0af57c5 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -10,7 +10,9 @@ use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
-use super::graph_links::{convert_to_compressed, GraphLinks, GraphLinksMmap};
+use super::graph_links::{
+    convert_to_compressed, GraphLinks, GraphLinksConverter, GraphLinksMmap, GraphLinksRam,
+};
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
@@ -297,6 +299,21 @@ where
     }
 }
 
+impl GraphLayers<GraphLinksRam> {
+    pub fn compress(&mut self) {
+        if !self.links.compressed() {
+            let dummy = GraphLinksRam::from_bytes(
+                GraphLinksConverter::new(Vec::new(), false, 0, 0).serialize_to_vec(),
+            );
+            let links = std::mem::replace(&mut self.links, dummy);
+            self.links = GraphLinksRam::from_bytes(
+                GraphLinksConverter::new(links.into_edges(), true, self.m, self.m0)
+                    .serialize_to_vec(),
+            )
+        }
+    }
+}
+
 impl GraphLayers<GraphLinksMmap> {
     pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
         self.links.prefault_mmap_pages(path)

commit 01326480419e31926c1a6c3223c5a4dc54ea748f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Dec 23 18:59:53 2024 +0000

    GraphLinks: replace trait with enum (#5651)
    
    * GraphLinks: replace trait with enum
    
    * Vec::with_capacity

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0e0af57c5..ffc1718f2 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -10,9 +10,7 @@ use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
-use super::graph_links::{
-    convert_to_compressed, GraphLinks, GraphLinksConverter, GraphLinksMmap, GraphLinksRam,
-};
+use super::graph_links::{convert_to_compressed, GraphLinks};
 use crate::common::operation_error::OperationResult;
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
@@ -36,11 +34,11 @@ struct GraphLayerData<'a> {
 }
 
 #[derive(Debug)]
-pub struct GraphLayers<TGraphLinks: GraphLinks> {
+pub struct GraphLayers {
     pub(super) m: usize,
     pub(super) m0: usize,
     pub(super) ef_construct: usize,
-    pub(super) links: TGraphLinks,
+    pub(super) links: GraphLinks,
     pub(super) entry_points: EntryPoints,
     pub(super) visited_pool: VisitedPool,
 }
@@ -176,7 +174,7 @@ pub trait GraphLayersBase {
     }
 }
 
-impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
+impl GraphLayersBase for GraphLayers {
     fn get_visited_list_from_pool(&self) -> VisitedListHandle {
         self.visited_pool.get(self.links.num_points())
     }
@@ -200,7 +198,7 @@ impl<TGraphLinks: GraphLinks> GraphLayersBase for GraphLayers<TGraphLinks> {
 /// Object contains links between nodes for HNSW search
 ///
 /// Assume all scores are similarities. Larger score = closer points
-impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
+impl GraphLayers {
     /// Returns the highest level this point is included in
     pub fn point_level(&self, point_id: PointOffsetType) -> usize {
         self.links.point_level(point_id)
@@ -264,11 +262,13 @@ impl<TGraphLinks: GraphLinks> GraphLayers<TGraphLinks> {
     }
 }
 
-impl<TGraphLinks> GraphLayers<TGraphLinks>
-where
-    TGraphLinks: GraphLinks,
-{
-    pub fn load(graph_path: &Path, links_path: &Path, convert: bool) -> OperationResult<Self> {
+impl GraphLayers {
+    pub fn load(
+        graph_path: &Path,
+        links_path: &Path,
+        convert: bool,
+        on_disk: bool,
+    ) -> OperationResult<Self> {
         let graph_data: GraphLayerData = read_bin(graph_path)?;
 
         if convert {
@@ -279,7 +279,7 @@ where
             m: graph_data.m,
             m0: graph_data.m0,
             ef_construct: graph_data.ef_construct,
-            links: TGraphLinks::load_from_file(links_path)?,
+            links: GraphLinks::load_from_file(links_path, on_disk)?,
             entry_points: graph_data.entry_points.into_owned(),
             visited_pool: VisitedPool::new(),
         })
@@ -297,25 +297,18 @@ where
             entry_points: Cow::Borrowed(&self.entry_points),
         }
     }
-}
 
-impl GraphLayers<GraphLinksRam> {
-    pub fn compress(&mut self) {
-        if !self.links.compressed() {
-            let dummy = GraphLinksRam::from_bytes(
-                GraphLinksConverter::new(Vec::new(), false, 0, 0).serialize_to_vec(),
-            );
-            let links = std::mem::replace(&mut self.links, dummy);
-            self.links = GraphLinksRam::from_bytes(
-                GraphLinksConverter::new(links.into_edges(), true, self.m, self.m0)
-                    .serialize_to_vec(),
-            )
-        }
+    #[cfg(feature = "testing")]
+    pub fn compress_ram(&mut self) {
+        use crate::index::hnsw_index::graph_links::GraphLinksConverter;
+        assert!(!self.links.compressed() && !self.links.on_disk());
+        let dummy = GraphLinksConverter::new(Vec::new(), false, 0, 0).to_graph_links_ram();
+        let links = std::mem::replace(&mut self.links, dummy);
+        self.links = GraphLinksConverter::new(links.into_edges(), true, self.m, self.m0)
+            .to_graph_links_ram();
     }
-}
 
-impl GraphLayers<GraphLinksMmap> {
-    pub fn prefault_mmap_pages(&self, path: &Path) -> mmap_ops::PrefaultMmapPages {
+    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
         self.links.prefault_mmap_pages(path)
     }
 }
@@ -336,17 +329,19 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
-    use crate::index::hnsw_index::graph_links::{GraphLinksConverter, GraphLinksRam};
-    use crate::index::hnsw_index::tests::create_graph_layer_fixture;
+    use crate::index::hnsw_index::graph_links::GraphLinksConverter;
+    use crate::index::hnsw_index::tests::{
+        create_graph_layer_builder_fixture, create_graph_layer_fixture,
+    };
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
     use crate::vector_storage::chunked_vector_storage::VectorOffsetType;
 
-    fn search_in_graph<TGraphLinks: GraphLinks>(
+    fn search_in_graph(
         query: &[VectorElementType],
         top: usize,
         vector_storage: &TestRawScorerProducer<CosineMetric>,
-        graph: &GraphLayers<TGraphLinks>,
+        graph: &GraphLayers,
     ) -> Vec<ScoredPointOffset> {
         let fake_filter_context = FakeFilterContext {};
         let raw_scorer = vector_storage.get_raw_scorer(query.to_owned()).unwrap();
@@ -380,13 +375,8 @@ mod tests {
             m,
             m0: 2 * m,
             ef_construct,
-            links: GraphLinksRam::from_converter(GraphLinksConverter::new(
-                graph_links.clone(),
-                compressed,
-                m,
-                2 * m,
-            ))
-            .unwrap(),
+            links: GraphLinksConverter::new(graph_links.clone(), compressed, m, 2 * m)
+                .to_graph_links_ram(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),
         };
@@ -434,25 +424,21 @@ mod tests {
         let mut rng = StdRng::seed_from_u64(42);
 
         let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
-        let links_path = GraphLayers::<GraphLinksRam>::get_links_path(dir.path());
-        let (vector_holder, graph_layers) = create_graph_layer_fixture::<CosineMetric, _>(
-            num_vectors,
-            M,
-            dim,
-            compressed,
-            false,
-            &mut rng,
-            Some(&links_path),
-        );
+        let links_path = GraphLayers::get_links_path(dir.path());
+        let (vector_holder, graph_layers_builder) =
+            create_graph_layer_builder_fixture(num_vectors, M, dim, false, &mut rng);
+        let graph_layers = graph_layers_builder
+            .into_graph_layers(&links_path, compressed, true)
+            .unwrap();
 
         let query = random_vector(&mut rng, dim);
 
         let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
 
-        let path = GraphLayers::<GraphLinksRam>::get_path(dir.path());
+        let path = GraphLayers::get_path(dir.path());
         graph_layers.save(&path).unwrap();
 
-        let graph2 = GraphLayers::<GraphLinksRam>::load(&path, &links_path, converted).unwrap();
+        let graph2 = GraphLayers::load(&path, &links_path, converted, false).unwrap();
 
         let res2 = search_in_graph(&query, top, &vector_holder, &graph2);
 
@@ -470,15 +456,8 @@ mod tests {
 
         type M = CosineMetric;
 
-        let (vector_holder, graph_layers) = create_graph_layer_fixture::<M, _>(
-            num_vectors,
-            M,
-            dim,
-            compressed,
-            false,
-            &mut rng,
-            None,
-        );
+        let (vector_holder, graph_layers) =
+            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, compressed, false, &mut rng);
 
         let main_entry = graph_layers
             .entry_points
@@ -534,7 +513,6 @@ mod tests {
             true,
             true,
             &mut rng,
-            None,
         );
 
         let graph_json = serde_json::to_string_pretty(&graph_layers.data()).unwrap();

commit 8b5667d57bf6268240f61e50c459f4a4af3aa43e
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jan 7 13:17:20 2025 +0000

    Separate file for compressed links; variant 2 (#5749)
    
    * fix load of the graph links mmap
    
    * decide compression based on filename rather than bit hacking
    
    * fix test
    
    * fix conversion: always create a new file for compressed links
    
    * fix conversion: adjust compressed flag after conversion
    
    * fix test (again)
    
    * Fixes
    
    * let GraphLayers manage its own files
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index ffc1718f2..e43af2040 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -4,16 +4,17 @@ use std::path::{Path, PathBuf};
 
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoredPointOffset};
-use io::file_operations::{atomic_save_bin, read_bin};
+use io::file_operations::read_bin;
 use itertools::Itertools;
 use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
-use super::graph_links::{convert_to_compressed, GraphLinks};
-use crate::common::operation_error::OperationResult;
+use super::graph_links::{GraphLinks, GraphLinksFormat};
+use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
+use crate::index::hnsw_index::graph_links::GraphLinksConverter;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
@@ -23,21 +24,21 @@ pub type LayersContainer = Vec<LinkContainer>;
 
 pub const HNSW_GRAPH_FILE: &str = "graph.bin";
 pub const HNSW_LINKS_FILE: &str = "links.bin";
+pub const COMPRESSED_HNSW_LINKS_FILE: &str = "links_compressed.bin";
 
 /// Contents of the `graph.bin` file.
 #[derive(Deserialize, Serialize, Debug)]
-struct GraphLayerData<'a> {
-    m: usize,
-    m0: usize,
-    ef_construct: usize,
-    entry_points: Cow<'a, EntryPoints>,
+pub(super) struct GraphLayerData<'a> {
+    pub(super) m: usize,
+    pub(super) m0: usize,
+    pub(super) ef_construct: usize,
+    pub(super) entry_points: Cow<'a, EntryPoints>,
 }
 
 #[derive(Debug)]
 pub struct GraphLayers {
     pub(super) m: usize,
     pub(super) m0: usize,
-    pub(super) ef_construct: usize,
     pub(super) links: GraphLinks,
     pub(super) entry_points: EntryPoints,
     pub(super) visited_pool: VisitedPool,
@@ -253,8 +254,18 @@ impl GraphLayers {
         path.join(HNSW_GRAPH_FILE)
     }
 
-    pub fn get_links_path(path: &Path) -> PathBuf {
-        path.join(HNSW_LINKS_FILE)
+    pub fn get_links_path(path: &Path, format: GraphLinksFormat) -> PathBuf {
+        match format {
+            GraphLinksFormat::Plain => path.join(HNSW_LINKS_FILE),
+            GraphLinksFormat::Compressed => path.join(COMPRESSED_HNSW_LINKS_FILE),
+        }
+    }
+
+    pub fn files(&self, path: &Path) -> Vec<PathBuf> {
+        vec![
+            GraphLayers::get_path(path),
+            GraphLayers::get_links_path(path, self.links.format()),
+        ]
     }
 
     pub fn num_points(&self) -> usize {
@@ -263,49 +274,76 @@ impl GraphLayers {
 }
 
 impl GraphLayers {
-    pub fn load(
-        graph_path: &Path,
-        links_path: &Path,
-        convert: bool,
-        on_disk: bool,
-    ) -> OperationResult<Self> {
-        let graph_data: GraphLayerData = read_bin(graph_path)?;
-
-        if convert {
-            convert_to_compressed(links_path, graph_data.m, graph_data.m0)?;
+    pub fn load(dir: &Path, on_disk: bool, compress: bool) -> OperationResult<Self> {
+        let graph_data: GraphLayerData = read_bin(&GraphLayers::get_path(dir))?;
+
+        if compress {
+            Self::convert_to_compressed(dir, graph_data.m, graph_data.m0)?;
         }
 
         Ok(Self {
             m: graph_data.m,
             m0: graph_data.m0,
-            ef_construct: graph_data.ef_construct,
-            links: GraphLinks::load_from_file(links_path, on_disk)?,
+            links: Self::load_links(dir, on_disk)?,
             entry_points: graph_data.entry_points.into_owned(),
             visited_pool: VisitedPool::new(),
         })
     }
 
-    pub fn save(&self, path: &Path) -> OperationResult<()> {
-        Ok(atomic_save_bin(path, &self.data())?)
+    fn load_links(dir: &Path, on_disk: bool) -> OperationResult<GraphLinks> {
+        for format in [GraphLinksFormat::Compressed, GraphLinksFormat::Plain] {
+            let path = GraphLayers::get_links_path(dir, format);
+            if path.exists() {
+                return GraphLinks::load_from_file(&path, on_disk, format);
+            }
+        }
+        Err(OperationError::service_error("No links file found"))
     }
 
-    fn data(&self) -> GraphLayerData {
-        GraphLayerData {
-            m: self.m,
-            m0: self.m0,
-            ef_construct: self.ef_construct,
-            entry_points: Cow::Borrowed(&self.entry_points),
+    fn convert_to_compressed(dir: &Path, m: usize, m0: usize) -> OperationResult<()> {
+        let plain_path = Self::get_links_path(dir, GraphLinksFormat::Plain);
+        let compressed_path = Self::get_links_path(dir, GraphLinksFormat::Compressed);
+
+        if compressed_path.exists() {
+            return Ok(());
         }
+
+        let start = std::time::Instant::now();
+
+        let links = GraphLinks::load_from_file(&plain_path, true, GraphLinksFormat::Plain)?;
+        let original_size = plain_path.metadata()?.len();
+        GraphLinksConverter::new(links.into_edges(), GraphLinksFormat::Compressed, m, m0)
+            .save_as(&compressed_path)?;
+        let new_size = compressed_path.metadata()?.len();
+
+        // Remove the original file
+        std::fs::remove_file(plain_path)?;
+
+        log::debug!(
+            "Compressed HNSW graph links in {:.1?}: {:.1}MB -> {:.1}MB ({:.1}%)",
+            start.elapsed(),
+            original_size as f64 / 1024.0 / 1024.0,
+            new_size as f64 / 1024.0 / 1024.0,
+            new_size as f64 / original_size as f64 * 100.0,
+        );
+
+        Ok(())
     }
 
     #[cfg(feature = "testing")]
     pub fn compress_ram(&mut self) {
         use crate::index::hnsw_index::graph_links::GraphLinksConverter;
-        assert!(!self.links.compressed() && !self.links.on_disk());
-        let dummy = GraphLinksConverter::new(Vec::new(), false, 0, 0).to_graph_links_ram();
-        let links = std::mem::replace(&mut self.links, dummy);
-        self.links = GraphLinksConverter::new(links.into_edges(), true, self.m, self.m0)
+        assert!(self.links.format() == GraphLinksFormat::Plain);
+        let dummy = GraphLinksConverter::new(Vec::new(), GraphLinksFormat::Plain, 0, 0)
             .to_graph_links_ram();
+        let links = std::mem::replace(&mut self.links, dummy);
+        self.links = GraphLinksConverter::new(
+            links.into_edges(),
+            GraphLinksFormat::Compressed,
+            self.m,
+            self.m0,
+        )
+        .to_graph_links_ram();
     }
 
     pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
@@ -315,10 +353,6 @@ impl GraphLayers {
 
 #[cfg(test)]
 mod tests {
-    use std::fs::File;
-    use std::io::Write;
-
-    use itertools::Itertools;
     use rand::rngs::StdRng;
     use rand::SeedableRng;
     use rstest::rstest;
@@ -354,12 +388,11 @@ mod tests {
     const M: usize = 8;
 
     #[rstest]
-    #[case::uncompressed(false)]
-    #[case::compressed(true)]
-    fn test_search_on_level(#[case] compressed: bool) {
+    #[case::uncompressed(GraphLinksFormat::Plain)]
+    #[case::compressed(GraphLinksFormat::Compressed)]
+    fn test_search_on_level(#[case] format: GraphLinksFormat) {
         let dim = 8;
         let m = 8;
-        let ef_construct = 32;
         let entry_points_num = 10;
         let num_vectors = 10;
 
@@ -374,8 +407,7 @@ mod tests {
         let graph_layers = GraphLayers {
             m,
             m0: 2 * m,
-            ef_construct,
-            links: GraphLinksConverter::new(graph_links.clone(), compressed, m, 2 * m)
+            links: GraphLinksConverter::new(graph_links.clone(), format, m, 2 * m)
                 .to_graph_links_ram(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),
@@ -413,10 +445,11 @@ mod tests {
     }
 
     #[rstest]
-    #[case::uncompressed((false, false))]
-    #[case::converted((false, true))]
-    #[case::compressed((true, false))]
-    fn test_save_and_load(#[case] (compressed, converted): (bool, bool)) {
+    #[case::uncompressed((GraphLinksFormat::Plain, false))]
+    #[case::converted((GraphLinksFormat::Plain, true))]
+    #[case::compressed((GraphLinksFormat::Compressed, false))]
+    #[case::recompressed((GraphLinksFormat::Compressed, true))]
+    fn test_save_and_load(#[case] (initial_format, compress): (GraphLinksFormat, bool)) {
         let num_vectors = 100;
         let dim = 8;
         let top = 5;
@@ -424,31 +457,33 @@ mod tests {
         let mut rng = StdRng::seed_from_u64(42);
 
         let dir = Builder::new().prefix("graph_dir").tempdir().unwrap();
-        let links_path = GraphLayers::get_links_path(dir.path());
-        let (vector_holder, graph_layers_builder) =
-            create_graph_layer_builder_fixture(num_vectors, M, dim, false, &mut rng);
-        let graph_layers = graph_layers_builder
-            .into_graph_layers(&links_path, compressed, true)
-            .unwrap();
 
         let query = random_vector(&mut rng, dim);
 
-        let res1 = search_in_graph(&query, top, &vector_holder, &graph_layers);
-
-        let path = GraphLayers::get_path(dir.path());
-        graph_layers.save(&path).unwrap();
-
-        let graph2 = GraphLayers::load(&path, &links_path, converted, false).unwrap();
+        let (vector_holder, graph_layers_builder) =
+            create_graph_layer_builder_fixture(num_vectors, M, dim, false, &mut rng);
+        let graph1 = graph_layers_builder
+            .into_graph_layers(dir.path(), initial_format, true)
+            .unwrap();
+        assert_eq!(graph1.links.format(), initial_format);
+        let res1 = search_in_graph(&query, top, &vector_holder, &graph1);
+        drop(graph1);
 
+        let graph2 = GraphLayers::load(dir.path(), false, compress).unwrap();
+        if compress {
+            assert_eq!(graph2.links.format(), GraphLinksFormat::Compressed);
+        } else {
+            assert_eq!(graph2.links.format(), initial_format);
+        }
         let res2 = search_in_graph(&query, top, &vector_holder, &graph2);
 
         assert_eq!(res1, res2)
     }
 
     #[rstest]
-    #[case::uncompressed(false)]
-    #[case::compressed(true)]
-    fn test_add_points(#[case] compressed: bool) {
+    #[case::uncompressed(GraphLinksFormat::Plain)]
+    #[case::compressed(GraphLinksFormat::Compressed)]
+    fn test_add_points(#[case] format: GraphLinksFormat) {
         let num_vectors = 1000;
         let dim = 8;
 
@@ -457,7 +492,7 @@ mod tests {
         type M = CosineMetric;
 
         let (vector_holder, graph_layers) =
-            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, compressed, false, &mut rng);
+            create_graph_layer_fixture::<M, _>(num_vectors, M, dim, format, false, &mut rng);
 
         let main_entry = graph_layers
             .entry_points
@@ -497,42 +532,4 @@ mod tests {
 
         assert_eq!(reference_top.into_vec(), graph_search);
     }
-
-    #[test]
-    #[ignore]
-    fn test_draw_hnsw_graph() {
-        let dim = 2;
-        let num_vectors = 500;
-
-        let mut rng = StdRng::seed_from_u64(42);
-
-        let (vector_holder, graph_layers) = create_graph_layer_fixture::<CosineMetric, _>(
-            num_vectors,
-            M,
-            dim,
-            true,
-            true,
-            &mut rng,
-        );
-
-        let graph_json = serde_json::to_string_pretty(&graph_layers.data()).unwrap();
-
-        let vectors_json = serde_json::to_string_pretty(
-            &(0..vector_holder.vectors.len() as PointOffsetType)
-                .map(|point_id| {
-                    vector_holder
-                        .vectors
-                        .get(point_id as VectorOffsetType)
-                        .to_vec()
-                })
-                .collect_vec(),
-        )
-        .unwrap();
-
-        let mut file = File::create("graph.json").unwrap();
-        file.write_all(
-            format!("{{ \"graph\": {graph_json}, \n \"vectors\": {vectors_json} }}").as_bytes(),
-        )
-        .unwrap();
-    }
 }

commit 3af89000a03f782e7c7dce55c9f6c670558dcfda
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 17 11:21:21 2025 +0000

    Rearrange graph_links.rs (#5788)
    
    - Rename `GraphLinksConverter` to `GraphLinksSerializer`.
    - Extract some structs from `graph_links.rs` into additional files:
      - `graph_links/header.rs`: `HeaderPlain` and `HeaderCompressed`.
      - `graph_links/serializer.rs`: for `GraphLinksSerializer`.
      - `graph_links/view.rs`: `GraphLinksView`.
    - In `header.rs`, remove `HeaderCompressed::version` doc comment about
      `HEADER_VERSION_COMPRESSED` as being outdated after merging #5749.
    - Add doc comment to `GraphLinksView`.
    - In `view.rs`/`GraphLinksView`, move some associated functions to the
      module level:
      - `read_level_offsets`
      - `get_slice`
      - `error_unsufficent_size`

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index e43af2040..e09e49daf 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -14,7 +14,7 @@ use super::graph_links::{GraphLinks, GraphLinksFormat};
 use crate::common::operation_error::{OperationError, OperationResult};
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
-use crate::index::hnsw_index::graph_links::GraphLinksConverter;
+use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
 use crate::index::hnsw_index::point_scorer::FilteredScorer;
 use crate::index::hnsw_index::search_context::SearchContext;
 use crate::index::visited_pool::{VisitedListHandle, VisitedPool};
@@ -312,7 +312,7 @@ impl GraphLayers {
 
         let links = GraphLinks::load_from_file(&plain_path, true, GraphLinksFormat::Plain)?;
         let original_size = plain_path.metadata()?.len();
-        GraphLinksConverter::new(links.into_edges(), GraphLinksFormat::Compressed, m, m0)
+        GraphLinksSerializer::new(links.into_edges(), GraphLinksFormat::Compressed, m, m0)
             .save_as(&compressed_path)?;
         let new_size = compressed_path.metadata()?.len();
 
@@ -332,12 +332,12 @@ impl GraphLayers {
 
     #[cfg(feature = "testing")]
     pub fn compress_ram(&mut self) {
-        use crate::index::hnsw_index::graph_links::GraphLinksConverter;
+        use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
         assert!(self.links.format() == GraphLinksFormat::Plain);
-        let dummy = GraphLinksConverter::new(Vec::new(), GraphLinksFormat::Plain, 0, 0)
+        let dummy = GraphLinksSerializer::new(Vec::new(), GraphLinksFormat::Plain, 0, 0)
             .to_graph_links_ram();
         let links = std::mem::replace(&mut self.links, dummy);
-        self.links = GraphLinksConverter::new(
+        self.links = GraphLinksSerializer::new(
             links.into_edges(),
             GraphLinksFormat::Compressed,
             self.m,
@@ -363,7 +363,7 @@ mod tests {
     use crate::fixtures::index_fixtures::{
         random_vector, FakeFilterContext, TestRawScorerProducer,
     };
-    use crate::index::hnsw_index::graph_links::GraphLinksConverter;
+    use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
     use crate::index::hnsw_index::tests::{
         create_graph_layer_builder_fixture, create_graph_layer_fixture,
     };
@@ -407,7 +407,7 @@ mod tests {
         let graph_layers = GraphLayers {
             m,
             m0: 2 * m,
-            links: GraphLinksConverter::new(graph_links.clone(), format, m, 2 * m)
+            links: GraphLinksSerializer::new(graph_links.clone(), format, m, 2 * m)
                 .to_graph_links_ram(),
             entry_points: EntryPoints::new(entry_points_num),
             visited_pool: VisitedPool::new(),

commit 012e293e04bc2b8cbe0dbc21d51d4de8e1376144
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 22 14:21:11 2025 +0000

    FixedLengthPriorityQueue: explicit sorted/unsorted methods (#5837)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index e09e49daf..0afce2b34 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -247,7 +247,7 @@ impl GraphLayers {
             &mut points_scorer,
         );
         let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer);
-        nearest.into_iter().take(top).collect_vec()
+        nearest.into_iter_sorted().take(top).collect_vec()
     }
 
     pub fn get_path(path: &Path) -> PathBuf {
@@ -435,7 +435,7 @@ mod tests {
 
         assert_eq!(nearest_on_level.len(), graph_links[0][0].len() + 1);
 
-        for nearest in &nearest_on_level {
+        for nearest in nearest_on_level.iter_unsorted() {
             // eprintln!("nearest = {:#?}", nearest);
             assert_eq!(
                 nearest.score,
@@ -530,6 +530,6 @@ mod tests {
 
         let graph_search = search_in_graph(&query, top, &vector_holder, &graph_layers);
 
-        assert_eq!(reference_top.into_vec(), graph_search);
+        assert_eq!(reference_top.into_sorted_vec(), graph_search);
     }
 }

commit c164adcb820233d0592af31cdf748c8e08b98948
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 31 12:10:16 2025 +0000

    Turn for_each_packed_link into iterator (#5897)
    
    * More cases for `bitpacking_links::tests`
    
    * Turn `for_each_packed_link` into iterator
    
    * Test `check_iterator_fold` and `check_exact_size_iterator_len`
    
    * Drop `for_each_packed_link` and use `iterate_packed_links`
    
    * Introduce `LinksIterator` for `segment`

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 0afce2b34..76e76e337 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -180,11 +180,11 @@ impl GraphLayersBase for GraphLayers {
         self.visited_pool.get(self.links.num_points())
     }
 
-    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, mut f: F)
+    fn links_map<F>(&self, point_id: PointOffsetType, level: usize, f: F)
     where
         F: FnMut(PointOffsetType),
     {
-        self.links.for_each_link(point_id, level, &mut f);
+        self.links.links(point_id, level).for_each(f);
     }
 
     fn get_m(&self, level: usize) -> usize {
@@ -508,7 +508,7 @@ mod tests {
         assert_eq!(main_entry.level, num_levels);
 
         let total_links_0 = (0..num_vectors)
-            .map(|i| graph_layers.links.links_vec(i as PointOffsetType, 0).len())
+            .map(|i| graph_layers.links.links(i as PointOffsetType, 0).len())
             .sum::<usize>();
 
         eprintln!("total_links_0 = {total_links_0:#?}");

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 76e76e337..4940849b2 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -188,11 +188,7 @@ impl GraphLayersBase for GraphLayers {
     }
 
     fn get_m(&self, level: usize) -> usize {
-        if level == 0 {
-            self.m0
-        } else {
-            self.m
-        }
+        if level == 0 { self.m0 } else { self.m }
     }
 }
 
@@ -353,15 +349,15 @@ impl GraphLayers {
 
 #[cfg(test)]
 mod tests {
-    use rand::rngs::StdRng;
     use rand::SeedableRng;
+    use rand::rngs::StdRng;
     use rstest::rstest;
     use tempfile::Builder;
 
     use super::*;
     use crate::data_types::vectors::VectorElementType;
     use crate::fixtures::index_fixtures::{
-        random_vector, FakeFilterContext, TestRawScorerProducer,
+        FakeFilterContext, TestRawScorerProducer, random_vector,
     };
     use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
     use crate::index::hnsw_index::tests::{

commit 89667860dd1c27ade1a99393c9c6387131af9dc3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Apr 1 13:01:10 2025 +0200

    Minor cleanups (#6291)

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 4940849b2..b37b64cef 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -329,7 +329,7 @@ impl GraphLayers {
     #[cfg(feature = "testing")]
     pub fn compress_ram(&mut self) {
         use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
-        assert!(self.links.format() == GraphLinksFormat::Plain);
+        assert_eq!(self.links.format(), GraphLinksFormat::Plain);
         let dummy = GraphLinksSerializer::new(Vec::new(), GraphLinksFormat::Plain, 0, 0)
             .to_graph_links_ram();
         let links = std::mem::replace(&mut self.links, dummy);

commit 6e0ddbafa950250daff35ebe44fb3ec6afad944f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 9 10:54:30 2025 +0200

    disk cache hygiene (#6323)
    
    * wip: implement explicit populate and clear_cache functions for all components
    
    * fmt
    
    * implement clear and populate for vector storages
    
    * fmt
    
    * implement clear and populate for payload storage
    
    * wip: implement explicit populate and clear_cache functions payload indexes
    
    * implement explicit populate and clear_cache functions payload indexes
    
    * fix clippy on CI
    
    * only compile posix_fadvise on linux
    
    * only compile posix_fadvise on linux
    
    * implement explicit populate and clear_cache functions for quantized vectors
    
    * fmt
    
    * remove post-load prefault
    
    * fix typo
    
    * implement is-on-disk for payload indexes, implement clear on drop for segment, implement clear after segment build
    
    * fmt
    
    * also evict quantized vectors after optimization
    
    * re-use and replace advise_dontneed

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index b37b64cef..959d0932c 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -6,7 +6,6 @@ use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoredPointOffset};
 use io::file_operations::read_bin;
 use itertools::Itertools;
-use memory::mmap_ops;
 use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
@@ -342,8 +341,9 @@ impl GraphLayers {
         .to_graph_links_ram();
     }
 
-    pub fn prefault_mmap_pages(&self, path: &Path) -> Option<mmap_ops::PrefaultMmapPages> {
-        self.links.prefault_mmap_pages(path)
+    pub fn populate(&self) -> OperationResult<()> {
+        self.links.populate()?;
+        Ok(())
     }
 }
 

commit 3d988e66c49c5edf7d3daceea801f30b01303afe
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 08:54:42 2025 +0000

    Remove is_stopped from RawScorer  (#6305)
    
    * Introduce CancelledError
    
    * Remove is_stopped from RawScorer

diff --git a/lib/segment/src/index/hnsw_index/graph_layers.rs b/lib/segment/src/index/hnsw_index/graph_layers.rs
index 959d0932c..2412adffb 100644
--- a/lib/segment/src/index/hnsw_index/graph_layers.rs
+++ b/lib/segment/src/index/hnsw_index/graph_layers.rs
@@ -1,6 +1,7 @@
 use std::borrow::Cow;
 use std::cmp::max;
 use std::path::{Path, PathBuf};
+use std::sync::atomic::AtomicBool;
 
 use common::fixed_length_priority_queue::FixedLengthPriorityQueue;
 use common::types::{PointOffsetType, ScoredPointOffset};
@@ -10,7 +11,9 @@ use serde::{Deserialize, Serialize};
 
 use super::entry_points::EntryPoint;
 use super::graph_links::{GraphLinks, GraphLinksFormat};
-use crate::common::operation_error::{OperationError, OperationResult};
+use crate::common::operation_error::{
+    CancellableResult, OperationError, OperationResult, check_process_stopped,
+};
 use crate::common::utils::rev_range;
 use crate::index::hnsw_index::entry_points::EntryPoints;
 use crate::index::hnsw_index::graph_links::GraphLinksSerializer;
@@ -60,11 +63,14 @@ pub trait GraphLayersBase {
         level: usize,
         visited_list: &mut VisitedListHandle,
         points_scorer: &mut FilteredScorer,
-    ) {
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<()> {
         let limit = self.get_m(level);
         let mut points_ids: Vec<PointOffsetType> = Vec::with_capacity(2 * limit);
 
         while let Some(candidate) = searcher.candidates.pop() {
+            check_process_stopped(is_stopped)?;
+
             if candidate.score < searcher.lower_bound() {
                 break;
             }
@@ -82,6 +88,8 @@ pub trait GraphLayersBase {
                 visited_list.check_and_update_visited(score_point.idx);
             });
         }
+
+        Ok(())
     }
 
     fn search_on_level(
@@ -90,13 +98,20 @@ pub trait GraphLayersBase {
         level: usize,
         ef: usize,
         points_scorer: &mut FilteredScorer,
-    ) -> FixedLengthPriorityQueue<ScoredPointOffset> {
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<FixedLengthPriorityQueue<ScoredPointOffset>> {
         let mut visited_list = self.get_visited_list_from_pool();
         visited_list.check_and_update_visited(level_entry.idx);
         let mut search_context = SearchContext::new(level_entry, ef);
 
-        self._search_on_level(&mut search_context, level, &mut visited_list, points_scorer);
-        search_context.nearest
+        self._search_on_level(
+            &mut search_context,
+            level,
+            &mut visited_list,
+            points_scorer,
+            is_stopped,
+        )?;
+        Ok(search_context.nearest)
     }
 
     /// Greedy searches for entry point of level `target_level`.
@@ -107,7 +122,8 @@ pub trait GraphLayersBase {
         top_level: usize,
         target_level: usize,
         points_scorer: &mut FilteredScorer,
-    ) -> ScoredPointOffset {
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<ScoredPointOffset> {
         let mut links: Vec<PointOffsetType> = Vec::with_capacity(2 * self.get_m(0));
 
         let mut current_point = ScoredPointOffset {
@@ -115,6 +131,8 @@ pub trait GraphLayersBase {
             score: points_scorer.score_point(entry_point),
         };
         for level in rev_range(top_level, target_level) {
+            check_process_stopped(is_stopped)?;
+
             let limit = self.get_m(level);
 
             let mut changed = true;
@@ -135,7 +153,7 @@ pub trait GraphLayersBase {
                 });
             }
         }
-        current_point
+        Ok(current_point)
     }
 
     #[cfg(test)]
@@ -230,9 +248,10 @@ impl GraphLayers {
         ef: usize,
         mut points_scorer: FilteredScorer,
         custom_entry_points: Option<&[PointOffsetType]>,
-    ) -> Vec<ScoredPointOffset> {
+        is_stopped: &AtomicBool,
+    ) -> CancellableResult<Vec<ScoredPointOffset>> {
         let Some(entry_point) = self.get_entry_point(&points_scorer, custom_entry_points) else {
-            return Vec::default();
+            return Ok(Vec::default());
         };
 
         let zero_level_entry = self.search_entry(
@@ -240,9 +259,16 @@ impl GraphLayers {
             entry_point.level,
             0,
             &mut points_scorer,
-        );
-        let nearest = self.search_on_level(zero_level_entry, 0, max(top, ef), &mut points_scorer);
-        nearest.into_iter_sorted().take(top).collect_vec()
+            is_stopped,
+        )?;
+        let nearest = self.search_on_level(
+            zero_level_entry,
+            0,
+            max(top, ef),
+            &mut points_scorer,
+            is_stopped,
+        )?;
+        Ok(nearest.into_iter_sorted().take(top).collect_vec())
     }
 
     pub fn get_path(path: &Path) -> PathBuf {
@@ -365,6 +391,7 @@ mod tests {
     };
     use crate::spaces::metric::Metric;
     use crate::spaces::simple::{CosineMetric, DotProductMetric};
+    use crate::vector_storage::DEFAULT_STOPPED;
     use crate::vector_storage::chunked_vector_storage::VectorOffsetType;
 
     fn search_in_graph(
@@ -378,7 +405,9 @@ mod tests {
 
         let scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
         let ef = 16;
-        graph.search(top, ef, scorer, None)
+        graph
+            .search(top, ef, scorer, None, &DEFAULT_STOPPED)
+            .unwrap()
     }
 
     const M: usize = 8;
@@ -419,15 +448,18 @@ mod tests {
         let raw_scorer = vector_holder.get_raw_scorer(added_vector).unwrap();
         let mut scorer = FilteredScorer::new(raw_scorer.as_ref(), Some(&fake_filter_context));
 
-        let nearest_on_level = graph_layers.search_on_level(
-            ScoredPointOffset {
-                idx: 0,
-                score: scorer.score_point(0),
-            },
-            0,
-            32,
-            &mut scorer,
-        );
+        let nearest_on_level = graph_layers
+            .search_on_level(
+                ScoredPointOffset {
+                    idx: 0,
+                    score: scorer.score_point(0),
+                },
+                0,
+                32,
+                &mut scorer,
+                &DEFAULT_STOPPED,
+            )
+            .unwrap();
 
         assert_eq!(nearest_on_level.len(), graph_links[0][0].len() + 1);
 

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    