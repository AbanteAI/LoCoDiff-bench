<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: apps/dotcom/sync-worker/src/TLPostgresReplicator.ts - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: apps/dotcom/sync-worker/src/TLPostgresReplicator.ts</h1>
        <p><a href="../../../cases/x-ai_grok-3-mini-beta/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts.html">← Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- apps/dotcom/sync-worker/src/TLPostgresReplicator.ts

commit 51310c28a1933528586ca540c039289c3e7de496
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:10:41 2024 +0000

    [wip] custom botcom backend (#4879)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug with…
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
new file mode 100644
index 000000000..982f03143
--- /dev/null
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -0,0 +1,327 @@
+import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
+import { assert, compact, uniq } from '@tldraw/utils'
+import { createSentry } from '@tldraw/worker-shared'
+import { DurableObject } from 'cloudflare:workers'
+import postgres from 'postgres'
+import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
+import type { TLUserDurableObject } from './TLUserDurableObject'
+import { Environment } from './types'
+
+const seed = `
+DROP TABLE IF EXISTS file_state;
+DROP TABLE IF EXISTS file;
+DROP TABLE IF EXISTS user;
+
+CREATE TABLE user (
+	id TEXT PRIMARY KEY,
+	json TEXT NOT NULL
+);
+
+CREATE TABLE file (
+	id TEXT PRIMARY KEY,
+	ownerId TEXT NOT NULL,
+	json TEXT NOT NULL,
+	FOREIGN KEY (ownerId) REFERENCES user (id) ON DELETE CASCADE
+);
+
+CREATE TABLE file_state (
+	userId TEXT NOT NULL,
+	fileId TEXT NOT NULL,
+	json TEXT NOT NULL,
+	PRIMARY KEY (userId, fileId),
+	FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE,
+	FOREIGN KEY (fileId) REFERENCES file (id) ON DELETE CASCADE
+);
+`
+
+export class TLPostgresReplicator extends DurableObject<Environment> {
+	sql: SqlStorage
+	db: ReturnType<typeof postgres>
+	sentry
+	captureException(exception: unknown, eventHint?: EventHint) {
+		// eslint-disable-next-line @typescript-eslint/no-deprecated
+		this.sentry?.captureException(exception, eventHint) as any
+		if (!this.sentry) {
+			console.error(exception)
+		}
+	}
+	constructor(ctx: DurableObjectState, env: Environment) {
+		super(ctx, env)
+		this.sentry = createSentry(ctx, env)
+
+		this.db = postgres(env.BOTCOM_POSTGRES_CONNECTION_STRING, {
+			types: {
+				bigint: {
+					from: [20], // PostgreSQL OID for BIGINT
+					parse: (value: string) => Number(value), // Convert string to number
+					to: 20,
+					serialize: (value: number) => String(value), // Convert number to string
+				},
+			},
+		})
+
+		this.ctx.blockConcurrencyWhile(async () => {
+			let didFetchInitialData = false
+			// TODO: time how long this takes
+			await new Promise((resolve, reject) => {
+				this.db
+					.subscribe(
+						'*',
+						async (row, info) => {
+							if (!didFetchInitialData) {
+								return
+							}
+							try {
+								await this.handleEvent(row, info)
+							} catch (e) {
+								this.captureException(e)
+							}
+						},
+						async () => {
+							try {
+								const users = await this.db`SELECT * FROM public.user`
+								const files = await this.db`SELECT * FROM file`
+								const fileStates = await this.db`SELECT * FROM file_state`
+								this.ctx.storage.sql.exec(seed)
+								users.forEach((user) => this.insertRow(user, 'user'))
+								files.forEach((file) => this.insertRow(file, 'file'))
+								fileStates.forEach((fileState) => this.insertRow(fileState, 'file_state'))
+							} catch (e) {
+								this.captureException(e)
+								reject(e)
+							}
+							didFetchInitialData = true
+							resolve(null)
+						},
+						() => {
+							// TODO: ping team if this fails
+							this.captureException(new Error('replication start failed'))
+							reject(null)
+						}
+					)
+					.catch((err) => {
+						// TODO: ping team if this fails
+						this.captureException(new Error('replication start failed (catch)'))
+						this.captureException(err)
+					})
+			})
+		})
+		this.sql = this.ctx.storage.sql
+	}
+
+	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		if (event.relation.table === 'user_mutation_number') {
+			if (!row) throw new Error('Row is required for delete event')
+			const stub = this.env.TL_USER.get(
+				this.env.TL_USER.idFromName(row.userId)
+			) as any as TLUserDurableObject
+			stub.commitMutation(row.mutationNumber)
+			return
+		}
+		if (
+			event.relation.table !== 'user' &&
+			event.relation.table !== 'file' &&
+			event.relation.table !== 'file_state'
+		) {
+			console.error(`Unhandled table: ${event.relation.table}`)
+			return
+		}
+
+		let userIds: string[] = []
+		if (row) {
+			userIds = this.getImpactedUserIds(row, event)
+		}
+		switch (event.command) {
+			case 'delete':
+				if (!row) throw new Error('Row is required for delete event')
+				this.deleteRow(row, event)
+				break
+			case 'insert':
+				if (!row) throw new Error('Row is required for delete event')
+				this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
+				break
+			case 'update':
+				if (!row) throw new Error('Row is required for delete event')
+				this.updateRow(row, event)
+				break
+			default:
+				console.error(`Unhandled event: ${event}`)
+		}
+		if (row) {
+			for (const userId of userIds) {
+				// get user DO and send update message
+				const stub = this.env.TL_USER.get(
+					this.env.TL_USER.idFromName(userId)
+				) as any as TLUserDurableObject
+				stub.onRowChange(row, event.relation.table as 'user' | 'file' | 'file_state', event.command)
+			}
+		}
+	}
+
+	deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
+		switch (event.relation.table) {
+			case 'user':
+				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)
+				break
+			case 'file':
+				this.sql.exec(`DELETE FROM file WHERE id = ?`, row.id)
+				break
+			case 'file_state': {
+				this.sql.exec(
+					`DELETE FROM file_state WHERE userId = ? AND fileId = ?`,
+					row.userId,
+					row.fileId
+				)
+
+				const files = this.sql
+					.exec(`SELECT * FROM file WHERE id = ? LIMIT 1`, row.fileId)
+					.toArray() as any as TlaFile[]
+				if (!files.length) break
+				const file = files[0] as any
+				if (row.userId !== file.ownerId) {
+					const stub = this.env.TL_USER.get(
+						this.env.TL_USER.idFromName(row.userId)
+					) as any as TLUserDurableObject
+					stub.onRowChange(JSON.parse(file.json), 'file', 'delete')
+				}
+
+				break
+			}
+		}
+	}
+
+	insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
+		switch (table) {
+			case 'user': {
+				const row = _row as TlaUser
+				this.sql.exec(`INSERT INTO user VALUES (?, ?)`, row.id, JSON.stringify(row))
+				break
+			}
+			case 'file': {
+				const row = _row as TlaFile
+				this.sql.exec(`INSERT INTO file VALUES (?, ?, ?)`, row.id, row.ownerId, JSON.stringify(row))
+				break
+			}
+			case 'file_state': {
+				const row = _row as TlaFileState
+				this.sql.exec(
+					`INSERT INTO file_state VALUES (?, ?, ?)`,
+					row.userId,
+					row.fileId,
+					JSON.stringify(row)
+				)
+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.fileId).toArray()[0] as {
+					json: string
+					ownerId: string
+				} | null
+				if (!file) break
+				if (file.ownerId !== row.userId) {
+					const stub = this.env.TL_USER.get(
+						this.env.TL_USER.idFromName(row.userId)
+					) as any as TLUserDurableObject
+					stub.onRowChange(JSON.parse(file.json), 'file', 'insert')
+				}
+				break
+			}
+		}
+	}
+
+	getImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
+		switch (event.relation.table) {
+			case 'user':
+				assert(row.id, 'row id is required')
+				return [row.id as string]
+			case 'file': {
+				assert(row.id, 'row id is required')
+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]
+				return compact(
+					uniq([
+						...(this.sql
+							.exec(
+								`SELECT id FROM user WHERE EXISTS(select 1 from file_state where fileId = ?)`,
+								row.id
+							)
+							.toArray()
+							.map((x) => x.id) as string[]),
+						row.ownerId as string,
+						file?.ownerId as string,
+					])
+				)
+			}
+
+			case 'file_state':
+				assert(row.userId, 'user id is required')
+				assert(row.fileId, 'file id is required')
+				return [row.userId as string]
+		}
+		return []
+	}
+
+	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
+		switch (event.relation.table) {
+			case 'user': {
+				const row = _row as TlaUser
+				this.sql.exec(`UPDATE user SET json = ? WHERE id = ?`, JSON.stringify(row), row.id)
+				break
+			}
+			case 'file': {
+				const row = _row as TlaFile
+				this.sql.exec(
+					`UPDATE file SET json = ?, ownerId = ? WHERE id = ?`,
+					JSON.stringify(row),
+					row.ownerId,
+					row.id
+				)
+
+				const room = this.env.TLDR_DOC.get(
+					this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${row.id}`)
+				)
+				room.appFileRecordDidUpdate(row).catch(console.error)
+				break
+			}
+			case 'file_state': {
+				const row = _row as TlaFileState
+				this.sql.exec(
+					`UPDATE file_state SET json = ? WHERE userId = ? AND fileId = ?`,
+					JSON.stringify(row),
+					row.userId,
+					row.fileId
+				)
+				break
+			}
+		}
+	}
+
+	async fetchDataForUser(userId: string) {
+		const files = this.sql
+			.exec(
+				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,
+				userId,
+				userId
+			)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))
+		const fileStates = this.sql
+			.exec(`SELECT json FROM file_state WHERE userId = ?`, userId)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))
+		const user = this.sql
+			.exec(`SELECT json FROM user WHERE id = ?`, userId)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))[0]
+		return {
+			files: files as TlaFile[],
+			fileStates: fileStates as TlaFileState[],
+			user: user as TlaUser,
+		}
+	}
+
+	async getFileRecord(fileId: string) {
+		try {
+			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()
+			return JSON.parse(json as string) as TlaFile
+		} catch (_e) {
+			return null
+		}
+	}
+}

commit 2e534b6f70c2950a1b754e12359bd786a62890f3
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:39:22 2024 +0000

    Revert "[wip] custom botcom backend" (#4883)
    
    Reverts tldraw/tldraw#487
    
    - [x] other

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
deleted file mode 100644
index 982f03143..000000000
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ /dev/null
@@ -1,327 +0,0 @@
-import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
-import { assert, compact, uniq } from '@tldraw/utils'
-import { createSentry } from '@tldraw/worker-shared'
-import { DurableObject } from 'cloudflare:workers'
-import postgres from 'postgres'
-import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
-import type { TLUserDurableObject } from './TLUserDurableObject'
-import { Environment } from './types'
-
-const seed = `
-DROP TABLE IF EXISTS file_state;
-DROP TABLE IF EXISTS file;
-DROP TABLE IF EXISTS user;
-
-CREATE TABLE user (
-	id TEXT PRIMARY KEY,
-	json TEXT NOT NULL
-);
-
-CREATE TABLE file (
-	id TEXT PRIMARY KEY,
-	ownerId TEXT NOT NULL,
-	json TEXT NOT NULL,
-	FOREIGN KEY (ownerId) REFERENCES user (id) ON DELETE CASCADE
-);
-
-CREATE TABLE file_state (
-	userId TEXT NOT NULL,
-	fileId TEXT NOT NULL,
-	json TEXT NOT NULL,
-	PRIMARY KEY (userId, fileId),
-	FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE,
-	FOREIGN KEY (fileId) REFERENCES file (id) ON DELETE CASCADE
-);
-`
-
-export class TLPostgresReplicator extends DurableObject<Environment> {
-	sql: SqlStorage
-	db: ReturnType<typeof postgres>
-	sentry
-	captureException(exception: unknown, eventHint?: EventHint) {
-		// eslint-disable-next-line @typescript-eslint/no-deprecated
-		this.sentry?.captureException(exception, eventHint) as any
-		if (!this.sentry) {
-			console.error(exception)
-		}
-	}
-	constructor(ctx: DurableObjectState, env: Environment) {
-		super(ctx, env)
-		this.sentry = createSentry(ctx, env)
-
-		this.db = postgres(env.BOTCOM_POSTGRES_CONNECTION_STRING, {
-			types: {
-				bigint: {
-					from: [20], // PostgreSQL OID for BIGINT
-					parse: (value: string) => Number(value), // Convert string to number
-					to: 20,
-					serialize: (value: number) => String(value), // Convert number to string
-				},
-			},
-		})
-
-		this.ctx.blockConcurrencyWhile(async () => {
-			let didFetchInitialData = false
-			// TODO: time how long this takes
-			await new Promise((resolve, reject) => {
-				this.db
-					.subscribe(
-						'*',
-						async (row, info) => {
-							if (!didFetchInitialData) {
-								return
-							}
-							try {
-								await this.handleEvent(row, info)
-							} catch (e) {
-								this.captureException(e)
-							}
-						},
-						async () => {
-							try {
-								const users = await this.db`SELECT * FROM public.user`
-								const files = await this.db`SELECT * FROM file`
-								const fileStates = await this.db`SELECT * FROM file_state`
-								this.ctx.storage.sql.exec(seed)
-								users.forEach((user) => this.insertRow(user, 'user'))
-								files.forEach((file) => this.insertRow(file, 'file'))
-								fileStates.forEach((fileState) => this.insertRow(fileState, 'file_state'))
-							} catch (e) {
-								this.captureException(e)
-								reject(e)
-							}
-							didFetchInitialData = true
-							resolve(null)
-						},
-						() => {
-							// TODO: ping team if this fails
-							this.captureException(new Error('replication start failed'))
-							reject(null)
-						}
-					)
-					.catch((err) => {
-						// TODO: ping team if this fails
-						this.captureException(new Error('replication start failed (catch)'))
-						this.captureException(err)
-					})
-			})
-		})
-		this.sql = this.ctx.storage.sql
-	}
-
-	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		if (event.relation.table === 'user_mutation_number') {
-			if (!row) throw new Error('Row is required for delete event')
-			const stub = this.env.TL_USER.get(
-				this.env.TL_USER.idFromName(row.userId)
-			) as any as TLUserDurableObject
-			stub.commitMutation(row.mutationNumber)
-			return
-		}
-		if (
-			event.relation.table !== 'user' &&
-			event.relation.table !== 'file' &&
-			event.relation.table !== 'file_state'
-		) {
-			console.error(`Unhandled table: ${event.relation.table}`)
-			return
-		}
-
-		let userIds: string[] = []
-		if (row) {
-			userIds = this.getImpactedUserIds(row, event)
-		}
-		switch (event.command) {
-			case 'delete':
-				if (!row) throw new Error('Row is required for delete event')
-				this.deleteRow(row, event)
-				break
-			case 'insert':
-				if (!row) throw new Error('Row is required for delete event')
-				this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
-				break
-			case 'update':
-				if (!row) throw new Error('Row is required for delete event')
-				this.updateRow(row, event)
-				break
-			default:
-				console.error(`Unhandled event: ${event}`)
-		}
-		if (row) {
-			for (const userId of userIds) {
-				// get user DO and send update message
-				const stub = this.env.TL_USER.get(
-					this.env.TL_USER.idFromName(userId)
-				) as any as TLUserDurableObject
-				stub.onRowChange(row, event.relation.table as 'user' | 'file' | 'file_state', event.command)
-			}
-		}
-	}
-
-	deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
-		switch (event.relation.table) {
-			case 'user':
-				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)
-				break
-			case 'file':
-				this.sql.exec(`DELETE FROM file WHERE id = ?`, row.id)
-				break
-			case 'file_state': {
-				this.sql.exec(
-					`DELETE FROM file_state WHERE userId = ? AND fileId = ?`,
-					row.userId,
-					row.fileId
-				)
-
-				const files = this.sql
-					.exec(`SELECT * FROM file WHERE id = ? LIMIT 1`, row.fileId)
-					.toArray() as any as TlaFile[]
-				if (!files.length) break
-				const file = files[0] as any
-				if (row.userId !== file.ownerId) {
-					const stub = this.env.TL_USER.get(
-						this.env.TL_USER.idFromName(row.userId)
-					) as any as TLUserDurableObject
-					stub.onRowChange(JSON.parse(file.json), 'file', 'delete')
-				}
-
-				break
-			}
-		}
-	}
-
-	insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
-		switch (table) {
-			case 'user': {
-				const row = _row as TlaUser
-				this.sql.exec(`INSERT INTO user VALUES (?, ?)`, row.id, JSON.stringify(row))
-				break
-			}
-			case 'file': {
-				const row = _row as TlaFile
-				this.sql.exec(`INSERT INTO file VALUES (?, ?, ?)`, row.id, row.ownerId, JSON.stringify(row))
-				break
-			}
-			case 'file_state': {
-				const row = _row as TlaFileState
-				this.sql.exec(
-					`INSERT INTO file_state VALUES (?, ?, ?)`,
-					row.userId,
-					row.fileId,
-					JSON.stringify(row)
-				)
-				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.fileId).toArray()[0] as {
-					json: string
-					ownerId: string
-				} | null
-				if (!file) break
-				if (file.ownerId !== row.userId) {
-					const stub = this.env.TL_USER.get(
-						this.env.TL_USER.idFromName(row.userId)
-					) as any as TLUserDurableObject
-					stub.onRowChange(JSON.parse(file.json), 'file', 'insert')
-				}
-				break
-			}
-		}
-	}
-
-	getImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
-		switch (event.relation.table) {
-			case 'user':
-				assert(row.id, 'row id is required')
-				return [row.id as string]
-			case 'file': {
-				assert(row.id, 'row id is required')
-				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]
-				return compact(
-					uniq([
-						...(this.sql
-							.exec(
-								`SELECT id FROM user WHERE EXISTS(select 1 from file_state where fileId = ?)`,
-								row.id
-							)
-							.toArray()
-							.map((x) => x.id) as string[]),
-						row.ownerId as string,
-						file?.ownerId as string,
-					])
-				)
-			}
-
-			case 'file_state':
-				assert(row.userId, 'user id is required')
-				assert(row.fileId, 'file id is required')
-				return [row.userId as string]
-		}
-		return []
-	}
-
-	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
-		switch (event.relation.table) {
-			case 'user': {
-				const row = _row as TlaUser
-				this.sql.exec(`UPDATE user SET json = ? WHERE id = ?`, JSON.stringify(row), row.id)
-				break
-			}
-			case 'file': {
-				const row = _row as TlaFile
-				this.sql.exec(
-					`UPDATE file SET json = ?, ownerId = ? WHERE id = ?`,
-					JSON.stringify(row),
-					row.ownerId,
-					row.id
-				)
-
-				const room = this.env.TLDR_DOC.get(
-					this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${row.id}`)
-				)
-				room.appFileRecordDidUpdate(row).catch(console.error)
-				break
-			}
-			case 'file_state': {
-				const row = _row as TlaFileState
-				this.sql.exec(
-					`UPDATE file_state SET json = ? WHERE userId = ? AND fileId = ?`,
-					JSON.stringify(row),
-					row.userId,
-					row.fileId
-				)
-				break
-			}
-		}
-	}
-
-	async fetchDataForUser(userId: string) {
-		const files = this.sql
-			.exec(
-				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,
-				userId,
-				userId
-			)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))
-		const fileStates = this.sql
-			.exec(`SELECT json FROM file_state WHERE userId = ?`, userId)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))
-		const user = this.sql
-			.exec(`SELECT json FROM user WHERE id = ?`, userId)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))[0]
-		return {
-			files: files as TlaFile[],
-			fileStates: fileStates as TlaFileState[],
-			user: user as TlaUser,
-		}
-	}
-
-	async getFileRecord(fileId: string) {
-		try {
-			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()
-			return JSON.parse(json as string) as TlaFile
-		} catch (_e) {
-			return null
-		}
-	}
-}

commit 8d8471f530a48377b3223b8cb64647ef3e590a36
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 11 11:49:21 2024 +0000

    [botcom] New backend (again) (#4884)
    
    re-attempt at #4879
    So it turns out you have to delete a durable object class in two
    deploys:
    
    1. stop using it
    2. add the 'delete' migration in wrangler.toml
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
new file mode 100644
index 000000000..982f03143
--- /dev/null
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -0,0 +1,327 @@
+import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
+import { assert, compact, uniq } from '@tldraw/utils'
+import { createSentry } from '@tldraw/worker-shared'
+import { DurableObject } from 'cloudflare:workers'
+import postgres from 'postgres'
+import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
+import type { TLUserDurableObject } from './TLUserDurableObject'
+import { Environment } from './types'
+
+const seed = `
+DROP TABLE IF EXISTS file_state;
+DROP TABLE IF EXISTS file;
+DROP TABLE IF EXISTS user;
+
+CREATE TABLE user (
+	id TEXT PRIMARY KEY,
+	json TEXT NOT NULL
+);
+
+CREATE TABLE file (
+	id TEXT PRIMARY KEY,
+	ownerId TEXT NOT NULL,
+	json TEXT NOT NULL,
+	FOREIGN KEY (ownerId) REFERENCES user (id) ON DELETE CASCADE
+);
+
+CREATE TABLE file_state (
+	userId TEXT NOT NULL,
+	fileId TEXT NOT NULL,
+	json TEXT NOT NULL,
+	PRIMARY KEY (userId, fileId),
+	FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE,
+	FOREIGN KEY (fileId) REFERENCES file (id) ON DELETE CASCADE
+);
+`
+
+export class TLPostgresReplicator extends DurableObject<Environment> {
+	sql: SqlStorage
+	db: ReturnType<typeof postgres>
+	sentry
+	captureException(exception: unknown, eventHint?: EventHint) {
+		// eslint-disable-next-line @typescript-eslint/no-deprecated
+		this.sentry?.captureException(exception, eventHint) as any
+		if (!this.sentry) {
+			console.error(exception)
+		}
+	}
+	constructor(ctx: DurableObjectState, env: Environment) {
+		super(ctx, env)
+		this.sentry = createSentry(ctx, env)
+
+		this.db = postgres(env.BOTCOM_POSTGRES_CONNECTION_STRING, {
+			types: {
+				bigint: {
+					from: [20], // PostgreSQL OID for BIGINT
+					parse: (value: string) => Number(value), // Convert string to number
+					to: 20,
+					serialize: (value: number) => String(value), // Convert number to string
+				},
+			},
+		})
+
+		this.ctx.blockConcurrencyWhile(async () => {
+			let didFetchInitialData = false
+			// TODO: time how long this takes
+			await new Promise((resolve, reject) => {
+				this.db
+					.subscribe(
+						'*',
+						async (row, info) => {
+							if (!didFetchInitialData) {
+								return
+							}
+							try {
+								await this.handleEvent(row, info)
+							} catch (e) {
+								this.captureException(e)
+							}
+						},
+						async () => {
+							try {
+								const users = await this.db`SELECT * FROM public.user`
+								const files = await this.db`SELECT * FROM file`
+								const fileStates = await this.db`SELECT * FROM file_state`
+								this.ctx.storage.sql.exec(seed)
+								users.forEach((user) => this.insertRow(user, 'user'))
+								files.forEach((file) => this.insertRow(file, 'file'))
+								fileStates.forEach((fileState) => this.insertRow(fileState, 'file_state'))
+							} catch (e) {
+								this.captureException(e)
+								reject(e)
+							}
+							didFetchInitialData = true
+							resolve(null)
+						},
+						() => {
+							// TODO: ping team if this fails
+							this.captureException(new Error('replication start failed'))
+							reject(null)
+						}
+					)
+					.catch((err) => {
+						// TODO: ping team if this fails
+						this.captureException(new Error('replication start failed (catch)'))
+						this.captureException(err)
+					})
+			})
+		})
+		this.sql = this.ctx.storage.sql
+	}
+
+	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		if (event.relation.table === 'user_mutation_number') {
+			if (!row) throw new Error('Row is required for delete event')
+			const stub = this.env.TL_USER.get(
+				this.env.TL_USER.idFromName(row.userId)
+			) as any as TLUserDurableObject
+			stub.commitMutation(row.mutationNumber)
+			return
+		}
+		if (
+			event.relation.table !== 'user' &&
+			event.relation.table !== 'file' &&
+			event.relation.table !== 'file_state'
+		) {
+			console.error(`Unhandled table: ${event.relation.table}`)
+			return
+		}
+
+		let userIds: string[] = []
+		if (row) {
+			userIds = this.getImpactedUserIds(row, event)
+		}
+		switch (event.command) {
+			case 'delete':
+				if (!row) throw new Error('Row is required for delete event')
+				this.deleteRow(row, event)
+				break
+			case 'insert':
+				if (!row) throw new Error('Row is required for delete event')
+				this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
+				break
+			case 'update':
+				if (!row) throw new Error('Row is required for delete event')
+				this.updateRow(row, event)
+				break
+			default:
+				console.error(`Unhandled event: ${event}`)
+		}
+		if (row) {
+			for (const userId of userIds) {
+				// get user DO and send update message
+				const stub = this.env.TL_USER.get(
+					this.env.TL_USER.idFromName(userId)
+				) as any as TLUserDurableObject
+				stub.onRowChange(row, event.relation.table as 'user' | 'file' | 'file_state', event.command)
+			}
+		}
+	}
+
+	deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
+		switch (event.relation.table) {
+			case 'user':
+				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)
+				break
+			case 'file':
+				this.sql.exec(`DELETE FROM file WHERE id = ?`, row.id)
+				break
+			case 'file_state': {
+				this.sql.exec(
+					`DELETE FROM file_state WHERE userId = ? AND fileId = ?`,
+					row.userId,
+					row.fileId
+				)
+
+				const files = this.sql
+					.exec(`SELECT * FROM file WHERE id = ? LIMIT 1`, row.fileId)
+					.toArray() as any as TlaFile[]
+				if (!files.length) break
+				const file = files[0] as any
+				if (row.userId !== file.ownerId) {
+					const stub = this.env.TL_USER.get(
+						this.env.TL_USER.idFromName(row.userId)
+					) as any as TLUserDurableObject
+					stub.onRowChange(JSON.parse(file.json), 'file', 'delete')
+				}
+
+				break
+			}
+		}
+	}
+
+	insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
+		switch (table) {
+			case 'user': {
+				const row = _row as TlaUser
+				this.sql.exec(`INSERT INTO user VALUES (?, ?)`, row.id, JSON.stringify(row))
+				break
+			}
+			case 'file': {
+				const row = _row as TlaFile
+				this.sql.exec(`INSERT INTO file VALUES (?, ?, ?)`, row.id, row.ownerId, JSON.stringify(row))
+				break
+			}
+			case 'file_state': {
+				const row = _row as TlaFileState
+				this.sql.exec(
+					`INSERT INTO file_state VALUES (?, ?, ?)`,
+					row.userId,
+					row.fileId,
+					JSON.stringify(row)
+				)
+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.fileId).toArray()[0] as {
+					json: string
+					ownerId: string
+				} | null
+				if (!file) break
+				if (file.ownerId !== row.userId) {
+					const stub = this.env.TL_USER.get(
+						this.env.TL_USER.idFromName(row.userId)
+					) as any as TLUserDurableObject
+					stub.onRowChange(JSON.parse(file.json), 'file', 'insert')
+				}
+				break
+			}
+		}
+	}
+
+	getImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
+		switch (event.relation.table) {
+			case 'user':
+				assert(row.id, 'row id is required')
+				return [row.id as string]
+			case 'file': {
+				assert(row.id, 'row id is required')
+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]
+				return compact(
+					uniq([
+						...(this.sql
+							.exec(
+								`SELECT id FROM user WHERE EXISTS(select 1 from file_state where fileId = ?)`,
+								row.id
+							)
+							.toArray()
+							.map((x) => x.id) as string[]),
+						row.ownerId as string,
+						file?.ownerId as string,
+					])
+				)
+			}
+
+			case 'file_state':
+				assert(row.userId, 'user id is required')
+				assert(row.fileId, 'file id is required')
+				return [row.userId as string]
+		}
+		return []
+	}
+
+	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
+		switch (event.relation.table) {
+			case 'user': {
+				const row = _row as TlaUser
+				this.sql.exec(`UPDATE user SET json = ? WHERE id = ?`, JSON.stringify(row), row.id)
+				break
+			}
+			case 'file': {
+				const row = _row as TlaFile
+				this.sql.exec(
+					`UPDATE file SET json = ?, ownerId = ? WHERE id = ?`,
+					JSON.stringify(row),
+					row.ownerId,
+					row.id
+				)
+
+				const room = this.env.TLDR_DOC.get(
+					this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${row.id}`)
+				)
+				room.appFileRecordDidUpdate(row).catch(console.error)
+				break
+			}
+			case 'file_state': {
+				const row = _row as TlaFileState
+				this.sql.exec(
+					`UPDATE file_state SET json = ? WHERE userId = ? AND fileId = ?`,
+					JSON.stringify(row),
+					row.userId,
+					row.fileId
+				)
+				break
+			}
+		}
+	}
+
+	async fetchDataForUser(userId: string) {
+		const files = this.sql
+			.exec(
+				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,
+				userId,
+				userId
+			)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))
+		const fileStates = this.sql
+			.exec(`SELECT json FROM file_state WHERE userId = ?`, userId)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))
+		const user = this.sql
+			.exec(`SELECT json FROM user WHERE id = ?`, userId)
+			.toArray()
+			.map((x) => JSON.parse(x.json as string))[0]
+		return {
+			files: files as TlaFile[],
+			fileStates: fileStates as TlaFileState[],
+			user: user as TlaUser,
+		}
+	}
+
+	async getFileRecord(fileId: string) {
+		try {
+			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()
+			return JSON.parse(json as string) as TlaFile
+		} catch (_e) {
+			return null
+		}
+	}
+}

commit db326b2b05a21e86ef8731f7a2337387a82a33ea
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Nov 12 09:22:40 2024 +0100

    Pin DO and a small refactor (#4889)
    
    If I understood Sunil correctly even a simple read should pin the DO. If
    I'm not mistaken then doing it in `fetch` should mean it comes from the
    user and not from another DO
    
    Fixes INT-457
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Pin the DO to the user's location.

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 982f03143..e6d0bd712 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -112,10 +112,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		if (event.relation.table === 'user_mutation_number') {
 			if (!row) throw new Error('Row is required for delete event')
-			const stub = this.env.TL_USER.get(
-				this.env.TL_USER.idFromName(row.userId)
-			) as any as TLUserDurableObject
-			stub.commitMutation(row.mutationNumber)
+			this.getStubForUser(row.userId).commitMutation(row.mutationNumber)
 			return
 		}
 		if (
@@ -150,10 +147,11 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		if (row) {
 			for (const userId of userIds) {
 				// get user DO and send update message
-				const stub = this.env.TL_USER.get(
-					this.env.TL_USER.idFromName(userId)
-				) as any as TLUserDurableObject
-				stub.onRowChange(row, event.relation.table as 'user' | 'file' | 'file_state', event.command)
+				this.getStubForUser(userId).onRowChange(
+					row,
+					event.relation.table as 'user' | 'file' | 'file_state',
+					event.command
+				)
 			}
 		}
 	}
@@ -179,10 +177,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				if (!files.length) break
 				const file = files[0] as any
 				if (row.userId !== file.ownerId) {
-					const stub = this.env.TL_USER.get(
-						this.env.TL_USER.idFromName(row.userId)
-					) as any as TLUserDurableObject
-					stub.onRowChange(JSON.parse(file.json), 'file', 'delete')
+					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'delete')
 				}
 
 				break
@@ -216,10 +211,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				} | null
 				if (!file) break
 				if (file.ownerId !== row.userId) {
-					const stub = this.env.TL_USER.get(
-						this.env.TL_USER.idFromName(row.userId)
-					) as any as TLUserDurableObject
-					stub.onRowChange(JSON.parse(file.json), 'file', 'insert')
+					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'insert')
 				}
 				break
 			}
@@ -324,4 +316,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			return null
 		}
 	}
+
+	private getStubForUser(userId: string) {
+		const id = this.env.TL_USER.idFromName(userId)
+		return this.env.TL_USER.get(id) as any as TLUserDurableObject
+	}
 }

commit b504ba4891d2dc545c5fb2771b8d2ea3dd835769
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 12 08:26:54 2024 +0000

    Robustify replicator bootup (#4888)
    
    - read the initial data in a transaction, at the same time write a
    unique id for the boot sequence to the db
    - wait for the boot id update to come through before handling messages
    on the subscription queue.
    - stream the initial data into sqlite, rather than loading it all into
    memory (which caps out at 130mb)
    - use the zero schema format to define data types, and to provide
    runtime info to generate the initial load sql query.
    - added a postgres config that you can opt in to, to log out the queries
    that are being executed.
    
    TODO:
    
    - [ ] load test the db up to 1gb of data, figure out how to measure the
    data size, get a sense of how many users we can theoretically support
    with this setup.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index e6d0bd712..f3875c7e2 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,10 +1,17 @@
 import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
-import { assert, compact, uniq } from '@tldraw/utils'
+import { assert, compact, uniq, uniqueId } from '@tldraw/utils'
 import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
 import type { TLUserDurableObject } from './TLUserDurableObject'
+import {
+	fileKeys,
+	fileStateKeys,
+	getFetchEverythingSql,
+	parseResultRow,
+	userKeys,
+} from './getFetchEverythingSql'
 import { Environment } from './types'
 
 const seed = `
@@ -20,17 +27,14 @@ CREATE TABLE user (
 CREATE TABLE file (
 	id TEXT PRIMARY KEY,
 	ownerId TEXT NOT NULL,
-	json TEXT NOT NULL,
-	FOREIGN KEY (ownerId) REFERENCES user (id) ON DELETE CASCADE
+	json TEXT NOT NULL
 );
 
 CREATE TABLE file_state (
 	userId TEXT NOT NULL,
 	fileId TEXT NOT NULL,
 	json TEXT NOT NULL,
-	PRIMARY KEY (userId, fileId),
-	FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE,
-	FOREIGN KEY (fileId) REFERENCES file (id) ON DELETE CASCADE
+	PRIMARY KEY (userId, fileId)
 );
 `
 
@@ -61,36 +65,83 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		})
 
 		this.ctx.blockConcurrencyWhile(async () => {
+			/**
+			 * BOOTUP SEQUENCE
+			 * 1. Generate a unique boot id
+			 * 2. Subscribe to all changes
+			 * 3. Fetch all data and write the boot id in a transaction
+			 * 4. If we receive events before the boot id update comes through, ignore them
+			 * 5. If we receive events after the boot id comes through but before we've finished
+			 *    fetching all data, buffer them and apply them after we've finished fetching all data.
+			 *    (not sure this is possible, but just in case)
+			 * 6. Once we've finished fetching all data, apply any buffered events
+			 */
 			let didFetchInitialData = false
+			let didGetBootIdInSubscription = false
+			const myId = this.ctx.id.toString()
+			const bootId = uniqueId()
 			// TODO: time how long this takes
 			await new Promise((resolve, reject) => {
+				const initialUpdateBuffer: Array<{
+					row: postgres.Row | null
+					info: postgres.ReplicationEvent
+				}> = []
 				this.db
 					.subscribe(
 						'*',
 						async (row, info) => {
-							if (!didFetchInitialData) {
-								return
-							}
-							try {
-								await this.handleEvent(row, info)
-							} catch (e) {
-								this.captureException(e)
+							if (didGetBootIdInSubscription) {
+								if (!didFetchInitialData) {
+									initialUpdateBuffer.push({ row, info })
+								} else {
+									try {
+										this.handleEvent(row, info)
+									} catch (e) {
+										this.captureException(e)
+									}
+								}
+							} else if (
+								info.relation.table === 'replicator_boot_id' &&
+								(row as any)?.bootId === bootId
+							) {
+								didGetBootIdInSubscription = true
+							} else {
+								// ignore events until we get the boot id
 							}
 						},
 						async () => {
 							try {
-								const users = await this.db`SELECT * FROM public.user`
-								const files = await this.db`SELECT * FROM file`
-								const fileStates = await this.db`SELECT * FROM file_state`
+								const sql = getFetchEverythingSql(myId, bootId)
 								this.ctx.storage.sql.exec(seed)
-								users.forEach((user) => this.insertRow(user, 'user'))
-								files.forEach((file) => this.insertRow(file, 'file'))
-								fileStates.forEach((fileState) => this.insertRow(fileState, 'file_state'))
+								// ok
+								await this.db.begin(async (db) => {
+									return db
+										.unsafe(sql, [], { prepare: false })
+										.simple()
+										.forEach((row: any) => {
+											this.insertRow(
+												parseResultRow(
+													row.table === 'user'
+														? userKeys
+														: row.table === 'file'
+															? fileKeys
+															: fileStateKeys,
+													row
+												),
+												row.table
+											)
+										})
+								})
+								while (initialUpdateBuffer.length) {
+									const { row, info } = initialUpdateBuffer.shift()!
+									this.handleEvent(row, info)
+								}
+								// this will prevent more events from being added to the buffer
+								didFetchInitialData = true
 							} catch (e) {
 								this.captureException(e)
 								reject(e)
 							}
-							didFetchInitialData = true
 							resolve(null)
 						},
 						() => {
@@ -109,7 +160,18 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		this.sql = this.ctx.storage.sql
 	}
 
-	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+	// It is important that this method is synchronous!!!!
+	// We need to make sure that events are handled in-order.
+	// If we make this asynchronous for whatever reason we should
+	// make sure to uphold this invariant.
+	handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		if (event.relation.table === 'replicator_boot_id') {
+			assert(
+				(row as any)?.replicatorId && (row as any)?.replicatorId !== this.ctx.id.toString(),
+				'we should only get boot id events for other replicators: ' + (row as any)?.replicatorId
+			)
+			return
+		}
 		if (event.relation.table === 'user_mutation_number') {
 			if (!row) throw new Error('Row is required for delete event')
 			this.getStubForUser(row.userId).commitMutation(row.mutationNumber)

commit cb3d14da778b3949f6690fe75871b1ccf2917b25
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Nov 12 13:56:01 2024 +0100

    Only send updates to active users (#4894)
    
    This adds user durable object registration so that we can track which
    users are active and only send updates to them.
    
    The way it works:
    1. When the user first connects we register register the user with the
    replicator.
    2. The replicator stores the data about active users in a new
    `active_user` table.
    3. When replicator receives postgres changes it now also looks into the
    `active_user` table to get active impacted user ids.
    4. It then forwards these updates to user DO. These forwards succeed
    even if the user's DO was not active before. We can use the user DO's
    state to check for whether it has active users connected. If it doesn't
    then we unsubscribe it. This means that any further updates won't be
    sent to it.
    
    Resolves INT-459
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Only send updates to active users.
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index f3875c7e2..f2fb2d915 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -18,6 +18,7 @@ const seed = `
 DROP TABLE IF EXISTS file_state;
 DROP TABLE IF EXISTS file;
 DROP TABLE IF EXISTS user;
+DROP TABLE IF EXISTS active_user;
 
 CREATE TABLE user (
 	id TEXT PRIMARY KEY,
@@ -36,6 +37,10 @@ CREATE TABLE file_state (
 	json TEXT NOT NULL,
 	PRIMARY KEY (userId, fileId)
 );
+
+CREATE TABLE active_user (
+	id TEXT PRIMARY KEY
+);
 `
 
 export class TLPostgresReplicator extends DurableObject<Environment> {
@@ -174,7 +179,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 		if (event.relation.table === 'user_mutation_number') {
 			if (!row) throw new Error('Row is required for delete event')
-			this.getStubForUser(row.userId).commitMutation(row.mutationNumber)
+			this.getStubForUser(row.userId).commitMutation(row.mutationNumber, row.userId)
 			return
 		}
 		if (
@@ -188,7 +193,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 		let userIds: string[] = []
 		if (row) {
-			userIds = this.getImpactedUserIds(row, event)
+			userIds = this.getActiveImpactedUserIds(row, event)
 		}
 		switch (event.command) {
 			case 'delete':
@@ -212,7 +217,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				this.getStubForUser(userId).onRowChange(
 					row,
 					event.relation.table as 'user' | 'file' | 'file_state',
-					event.command
+					event.command,
+					userId
 				)
 			}
 		}
@@ -239,7 +245,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				if (!files.length) break
 				const file = files[0] as any
 				if (row.userId !== file.ownerId) {
-					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'delete')
+					this.getStubForUser(row.userId).onRowChange(
+						JSON.parse(file.json),
+						'file',
+						'delete',
+						row.userId
+					)
 				}
 
 				break
@@ -273,22 +284,30 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				} | null
 				if (!file) break
 				if (file.ownerId !== row.userId) {
-					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'insert')
+					this.getStubForUser(row.userId).onRowChange(
+						JSON.parse(file.json),
+						'file',
+						'insert',
+						row.userId
+					)
 				}
 				break
 			}
 		}
 	}
 
-	getImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
+	getActiveImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
+		let result: string[] = []
+
 		switch (event.relation.table) {
 			case 'user':
 				assert(row.id, 'row id is required')
-				return [row.id as string]
+				result = [row.id as string]
+				break
 			case 'file': {
 				assert(row.id, 'row id is required')
 				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]
-				return compact(
+				result = compact(
 					uniq([
 						...(this.sql
 							.exec(
@@ -301,14 +320,22 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 						file?.ownerId as string,
 					])
 				)
+				break
 			}
 
 			case 'file_state':
 				assert(row.userId, 'user id is required')
 				assert(row.fileId, 'file id is required')
-				return [row.userId as string]
+				result = [row.userId as string]
+				break
 		}
-		return []
+		if (result.length === 0) return []
+
+		const placeholders = result.map(() => '?').join(', ')
+		return this.sql
+			.exec(`SELECT * FROM active_users WHERE id IN (${placeholders})`, ...result)
+			.toArray()
+			.map((x) => x.id as string)
 	}
 
 	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
@@ -383,4 +410,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		const id = this.env.TL_USER.idFromName(userId)
 		return this.env.TL_USER.get(id) as any as TLUserDurableObject
 	}
+
+	registerUser(userId: string) {
+		this.sql.exec(`INSERT INTO active_users (id) VALUES (?) ON CONFLICT (id) DO NOTHING`, userId)
+	}
+
+	unregisterUser(userId: string) {
+		this.sql.exec(`DELETE FROM active_users WHERE id = ?`, userId)
+	}
 }

commit a811c46953805c69ffe74ae7f4f3ecabf62c1e95
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Nov 13 12:55:41 2024 +0100

    Fix issue. (#4910)
    
    I renamed the table name, but did not correctly update the name
    everywhere 😓
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fix an issue with references a non existing table.

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index f2fb2d915..c27b85c14 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -333,7 +333,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 		const placeholders = result.map(() => '?').join(', ')
 		return this.sql
-			.exec(`SELECT * FROM active_users WHERE id IN (${placeholders})`, ...result)
+			.exec(`SELECT * FROM active_user WHERE id IN (${placeholders})`, ...result)
 			.toArray()
 			.map((x) => x.id as string)
 	}
@@ -412,10 +412,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	registerUser(userId: string) {
-		this.sql.exec(`INSERT INTO active_users (id) VALUES (?) ON CONFLICT (id) DO NOTHING`, userId)
+		this.sql.exec(`INSERT INTO active_user (id) VALUES (?) ON CONFLICT (id) DO NOTHING`, userId)
 	}
 
 	unregisterUser(userId: string) {
-		this.sql.exec(`DELETE FROM active_users WHERE id = ?`, userId)
+		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 	}
 }

commit 28ffe3448065e85cacd4c20fe4ccb98918ce9b40
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Nov 13 14:17:00 2024 +0000

    handle postgres failures in replicator (#4912)
    
    - each time the replicator reboots it gets a new random `bootId`
    - each time the replicator sends a row update message to a user DO it
    includes the boot id.
    - if the boot id doesn't match the previous one, the user DO resets its
    state and makes the sockets reconnect to ensure consistent data.
    - each time the replicator's postgres subscription fails it tries to
    reboot iself
    - active user DOs ping the replicator every 10 seconds to make sure it
    wakes up if it was put to sleep for whatever reason (I think this is
    unlikely to happen, but cloudflare is technically allowed to stop DOs
    for whatever reason and they won't start up again unless we perform a
    fetch or RPC on them. Better safe than sorry)
    - no longer using blockConcurrencyWhile in replicator init. Instead we
    have a mechanism for the replicator RPCs (fetchDataForUser et al) to
    wait for a 'connected' state to be achieved.
    - gonna add a ticket to add timeouts for these so that we can handle
    situations of low/zero availability more gracefully for end users.
    
    also
    
    - don't throw away the active_user table on sqlite init. This could lead
    to zombie user DOs that are active but don't receive updates.
    
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index c27b85c14..a2df0b4f0 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,6 +1,6 @@
 import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
-import { assert, compact, uniq, uniqueId } from '@tldraw/utils'
-import { createSentry } from '@tldraw/worker-shared'
+import { assert, compact, promiseWithResolve, sleep, uniq, uniqueId } from '@tldraw/utils'
+import { ExecutionQueue, createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
@@ -18,7 +18,6 @@ const seed = `
 DROP TABLE IF EXISTS file_state;
 DROP TABLE IF EXISTS file;
 DROP TABLE IF EXISTS user;
-DROP TABLE IF EXISTS active_user;
 
 CREATE TABLE user (
 	id TEXT PRIMARY KEY,
@@ -38,131 +37,254 @@ CREATE TABLE file_state (
 	PRIMARY KEY (userId, fileId)
 );
 
-CREATE TABLE active_user (
+-- we keep the active_user data between reboots to 
+-- make sure users don't miss updates.
+CREATE TABLE IF NOT EXISTS active_user (
 	id TEXT PRIMARY KEY
 );
 `
 
+type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
+
+type BootState =
+	| {
+			type: 'init'
+			promise: PromiseWithResolve
+	  }
+	| {
+			type: 'connecting'
+			db: postgres.Sql
+			bootId: string
+			promise: PromiseWithResolve
+	  }
+	| {
+			type: 'connected'
+			db: postgres.Sql
+			bootId: string
+			subscription: postgres.SubscriptionHandle
+	  }
+
 export class TLPostgresReplicator extends DurableObject<Environment> {
 	sql: SqlStorage
-	db: ReturnType<typeof postgres>
+	state: BootState = {
+		type: 'init',
+		promise: promiseWithResolve(),
+	}
+
 	sentry
-	captureException(exception: unknown, eventHint?: EventHint) {
+	// eslint-disable-next-line local/prefer-class-methods
+	private captureException = (exception: unknown, eventHint?: EventHint) => {
 		// eslint-disable-next-line @typescript-eslint/no-deprecated
 		this.sentry?.captureException(exception, eventHint) as any
 		if (!this.sentry) {
 			console.error(exception)
 		}
 	}
+
 	constructor(ctx: DurableObjectState, env: Environment) {
 		super(ctx, env)
 		this.sentry = createSentry(ctx, env)
+		this.sql = this.ctx.storage.sql
+		this.reboot(false)
+	}
+	private debug(...args: any[]) {
+		// uncomment for dev time debugging
+		// console.log(...args)
+		if (this.sentry) {
+			// eslint-disable-next-line @typescript-eslint/no-deprecated
+			this.sentry.addBreadcrumb({
+				message: args.join(' '),
+			})
+		}
+	}
 
-		this.db = postgres(env.BOTCOM_POSTGRES_CONNECTION_STRING, {
-			types: {
-				bigint: {
-					from: [20], // PostgreSQL OID for BIGINT
-					parse: (value: string) => Number(value), // Convert string to number
-					to: 20,
-					serialize: (value: number) => String(value), // Convert number to string
-				},
-			},
+	private queue = new ExecutionQueue()
+
+	private async reboot(delay = true) {
+		// TODO: set up analytics and alerts for this
+		this.debug('rebooting')
+		await this.queue.push(async () => {
+			if (delay) {
+				await sleep(1000)
+			}
+			await this.boot()
 		})
+	}
+
+	private async boot() {
+		this.debug('booting')
+		// clean up old resources if necessary
+		if (this.state.type === 'connected') {
+			this.state.subscription.unsubscribe()
+			this.state.db.end().catch(this.captureException)
+		} else if (this.state.type === 'connecting') {
+			this.state.db.end().catch(this.captureException)
+		}
+		this.state = {
+			type: 'connecting',
+			// preserve the promise so any awaiters do eventually get resolved
+			// TODO: set a timeout on the promise?
+			promise: 'promise' in this.state ? this.state.promise : promiseWithResolve(),
+			db: postgres(this.env.BOTCOM_POSTGRES_CONNECTION_STRING, {
+				types: {
+					bigint: {
+						from: [20], // PostgreSQL OID for BIGINT
+						parse: (value: string) => Number(value), // Convert string to number
+						to: 20,
+						serialize: (value: number) => String(value), // Convert number to string
+					},
+				},
+			}),
+			bootId: uniqueId(),
+		}
+		/**
+		 * BOOTUP SEQUENCE
+		 * 1. Generate a unique boot id
+		 * 2. Subscribe to all changes
+		 * 3. Fetch all data and write the boot id in a transaction
+		 * 4. If we receive events before the boot id update comes through, ignore them
+		 * 5. If we receive events after the boot id comes through but before we've finished
+		 *    fetching all data, buffer them and apply them after we've finished fetching all data.
+		 *    (not sure this is possible, but just in case)
+		 * 6. Once we've finished fetching all data, apply any buffered events
+		 */
+
+		const myId = this.ctx.id.toString()
+		// if the bootId changes during the boot process, we should stop silently
+		const bootId = this.state.bootId
 
-		this.ctx.blockConcurrencyWhile(async () => {
-			/**
-			 * BOOTUP SEQUENCE
-			 * 1. Generate a unique boot id
-			 * 2. Subscribe to all changes
-			 * 3. Fetch all data and write the boot id in a transaction
-			 * 4. If we receive events before the boot id update comes through, ignore them
-			 * 5. If we receive events after the boot id comes through but before we've finished
-			 *    fetching all data, buffer them and apply them after we've finished fetching all data.
-			 *    (not sure this is possible, but just in case)
-			 * 6. Once we've finished fetching all data, apply any buffered events
-			 */
+		const promise = this.state.promise
+
+		const start = Date.now()
+		const result = await new Promise<'error' | 'success'>((resolve) => {
 			let didFetchInitialData = false
 			let didGetBootIdInSubscription = false
-			const myId = this.ctx.id.toString()
-			const bootId = uniqueId()
-			// TODO: time how long this takes
-			await new Promise((resolve, reject) => {
-				const initialUpdateBuffer: Array<{
-					row: postgres.Row | null
-					info: postgres.ReplicationEvent
-				}> = []
-				this.db
-					.subscribe(
-						'*',
-						async (row, info) => {
-							if (didGetBootIdInSubscription) {
-								if (!didFetchInitialData) {
-									initialUpdateBuffer.push({ row, info })
-								} else {
-									try {
-										this.handleEvent(row, info)
-									} catch (e) {
-										this.captureException(e)
-									}
-								}
-							} else if (
-								info.relation.table === 'replicator_boot_id' &&
-								(row as any)?.bootId === bootId
-							) {
-								didGetBootIdInSubscription = true
-							} else {
-								// ignore events until we get the boot id
-							}
-						},
-						async () => {
-							try {
-								const sql = getFetchEverythingSql(myId, bootId)
-								this.ctx.storage.sql.exec(seed)
-								// ok
-								await this.db.begin(async (db) => {
-									return db
-										.unsafe(sql, [], { prepare: false })
-										.simple()
-										.forEach((row: any) => {
-											this.insertRow(
-												parseResultRow(
-													row.table === 'user'
-														? userKeys
-														: row.table === 'file'
-															? fileKeys
-															: fileStateKeys,
-													row
-												),
-												row.table
-											)
-										})
-								})
-								while (initialUpdateBuffer.length) {
-									const { row, info } = initialUpdateBuffer.shift()!
-									this.handleEvent(row, info)
-								}
-								// this will prevent more events from being added to the buffer
-								didFetchInitialData = true
-							} catch (e) {
-								this.captureException(e)
-								reject(e)
-							}
-							resolve(null)
-						},
-						() => {
-							// TODO: ping team if this fails
-							this.captureException(new Error('replication start failed'))
-							reject(null)
+			let subscription: postgres.SubscriptionHandle | undefined
+
+			const initialUpdateBuffer: Array<{
+				row: postgres.Row | null
+				info: postgres.ReplicationEvent
+			}> = []
+
+			const updateState = () => {
+				if (didFetchInitialData && didGetBootIdInSubscription && subscription) {
+					// we got everything, so we can set the state to connected and apply any buffered events
+					assert(this.state.type === 'connecting', 'state should be connecting')
+					this.state = {
+						type: 'connected',
+						db: this.state.db,
+						bootId: this.state.bootId,
+						subscription,
+					}
+					this.debug('num updates pending after pg sync:', initialUpdateBuffer.length)
+					if (initialUpdateBuffer.length) {
+						while (initialUpdateBuffer.length) {
+							const { row, info } = initialUpdateBuffer.shift()!
+							this.handleEvent(row, info)
 						}
-					)
-					.catch((err) => {
-						// TODO: ping team if this fails
-						this.captureException(new Error('replication start failed (catch)'))
-						this.captureException(err)
-					})
-			})
+					}
+					resolve('success')
+				}
+			}
+
+			assert(this.state.type === 'connecting', 'state should be connecting')
+			this.debug('subscribing')
+			this.state.db
+				.subscribe(
+					'*',
+					// on message
+					async (row, info) => {
+						if (this.state.type === 'connected') {
+							this.handleEvent(row, info)
+							return
+						}
+						if (this.state.type !== 'connecting') return
+
+						if (didGetBootIdInSubscription) {
+							// we've already got the boot id, so just shove things into
+							// a buffer until the state is set to 'connecting'
+							initialUpdateBuffer.push({ row, info })
+						} else if (
+							info.relation.table === 'replicator_boot_id' &&
+							(row as any)?.bootId === this.state.bootId
+						) {
+							didGetBootIdInSubscription = true
+							updateState()
+						}
+						// ignore other events until we get the boot id
+					},
+					// on connect
+					async () => {
+						this.debug('on connect')
+						try {
+							assert(this.state.type === 'connecting', 'state should be connecting')
+							const sql = getFetchEverythingSql(myId, bootId)
+							this.sql.exec(seed)
+							// ok
+							await this.state.db.begin(async (db) => {
+								return db
+									.unsafe(sql, [], { prepare: false })
+									.simple()
+									.forEach((row: any) => {
+										this._insertRow(
+											parseResultRow(
+												row.table === 'user'
+													? userKeys
+													: row.table === 'file'
+														? fileKeys
+														: fileStateKeys,
+												row
+											),
+											row.table
+										)
+									})
+							})
+							this.debug('database size (mb)', (this.sql.databaseSize / 1024 / 1024).toFixed(2))
+							// this will prevent more events from being added to the buffer
+							didFetchInitialData = true
+							updateState()
+						} catch (e) {
+							this.debug('init failed')
+							this.captureException(e)
+							resolve('error')
+							return
+						}
+					},
+					// on error
+					() => {
+						this.debug('on error')
+						const e = new Error('replication start failed')
+						this.captureException(e)
+						if (this.state.type === 'connecting') {
+							resolve('error')
+						} else {
+							// This happens when the connection is lost, e.g. when the database is restarted
+							// or network conditions get weird.
+							this.reboot()
+						}
+					}
+				)
+				.then((handle) => {
+					this.debug('got handle')
+					subscription = handle
+					updateState()
+				})
+				.catch((err) => {
+					this.debug('caught error')
+					this.captureException(new Error('replication start failed (catch)'))
+					this.captureException(err)
+					resolve('error')
+				})
 		})
-		this.sql = this.ctx.storage.sql
+
+		const end = Date.now()
+		this.debug('boot time', end - start, 'ms')
+
+		if (result === 'error') {
+			this.reboot()
+		} else {
+			promise.resolve(null)
+		}
 	}
 
 	// It is important that this method is synchronous!!!!
@@ -170,61 +292,68 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	// If we make this asynchronous for whatever reason we should
 	// make sure to uphold this invariant.
 	handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		if (event.relation.table === 'replicator_boot_id') {
-			assert(
-				(row as any)?.replicatorId && (row as any)?.replicatorId !== this.ctx.id.toString(),
-				'we should only get boot id events for other replicators: ' + (row as any)?.replicatorId
-			)
-			return
-		}
-		if (event.relation.table === 'user_mutation_number') {
-			if (!row) throw new Error('Row is required for delete event')
-			this.getStubForUser(row.userId).commitMutation(row.mutationNumber, row.userId)
-			return
-		}
-		if (
-			event.relation.table !== 'user' &&
-			event.relation.table !== 'file' &&
-			event.relation.table !== 'file_state'
-		) {
-			console.error(`Unhandled table: ${event.relation.table}`)
-			return
-		}
-
-		let userIds: string[] = []
-		if (row) {
-			userIds = this.getActiveImpactedUserIds(row, event)
-		}
-		switch (event.command) {
-			case 'delete':
-				if (!row) throw new Error('Row is required for delete event')
-				this.deleteRow(row, event)
-				break
-			case 'insert':
-				if (!row) throw new Error('Row is required for delete event')
-				this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
-				break
-			case 'update':
-				if (!row) throw new Error('Row is required for delete event')
-				this.updateRow(row, event)
-				break
-			default:
-				console.error(`Unhandled event: ${event}`)
-		}
-		if (row) {
-			for (const userId of userIds) {
-				// get user DO and send update message
-				this.getStubForUser(userId).onRowChange(
-					row,
-					event.relation.table as 'user' | 'file' | 'file_state',
-					event.command,
-					userId
+		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
+		try {
+			if (event.relation.table === 'replicator_boot_id') {
+				assert(
+					(row as any)?.replicatorId && (row as any)?.replicatorId !== this.ctx.id.toString(),
+					'we should only get boot id events for other replicators: ' + (row as any)?.replicatorId
 				)
+				return
+			}
+			if (event.relation.table === 'user_mutation_number') {
+				if (!row) throw new Error('Row is required for delete event')
+				this.getStubForUser(row.userId).commitMutation(row.mutationNumber, row.userId)
+				return
+			}
+			if (
+				event.relation.table !== 'user' &&
+				event.relation.table !== 'file' &&
+				event.relation.table !== 'file_state'
+			) {
+				console.error(`Unhandled table: ${event.relation.table}`)
+				return
 			}
+
+			let userIds: string[] = []
+			if (row) {
+				userIds = this.getActiveImpactedUserIds(row, event)
+			}
+			switch (event.command) {
+				case 'delete':
+					if (!row) throw new Error('Row is required for delete event')
+					this.deleteRow(row, event)
+					break
+				case 'insert':
+					if (!row) throw new Error('Row is required for delete event')
+					this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
+					break
+				case 'update':
+					if (!row) throw new Error('Row is required for delete event')
+					this.updateRow(row, event)
+					break
+				default:
+					console.error(`Unhandled event: ${event}`)
+			}
+			if (row) {
+				for (const userId of userIds) {
+					// get user DO and send update message
+					this.getStubForUser(userId).onRowChange(
+						this.state.bootId,
+						row,
+						event.relation.table as 'user' | 'file' | 'file_state',
+						event.command,
+						userId
+					)
+				}
+			}
+		} catch (e) {
+			this.captureException(e)
 		}
 	}
 
-	deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
+	private deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
+		assert(this.state.type === 'connected', 'state should be connected in deleteRow')
 		switch (event.relation.table) {
 			case 'user':
 				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)
@@ -246,6 +375,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				const file = files[0] as any
 				if (row.userId !== file.ownerId) {
 					this.getStubForUser(row.userId).onRowChange(
+						this.state.bootId,
 						JSON.parse(file.json),
 						'file',
 						'delete',
@@ -257,8 +387,35 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			}
 		}
 	}
+	private insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
+		assert(this.state.type === 'connected', 'state should be connected in insertRow')
+		this._insertRow(_row, table)
+
+		// If a user just added a file state for a shared file for the first time, they won't
+		// have access to the file. We need to send them the file.
+		if (table !== 'file_state') return
+		const fileState = _row as TlaFileState
+		const fileRow = this.sql
+			.exec(`SELECT * FROM file WHERE id = ?`, fileState.fileId)
+			.toArray()[0] as {
+			json: string
+		} | null
+		if (!fileRow) return
+		const file = JSON.parse(fileRow.json) as TlaFile
+		if (file.shared && file.ownerId !== fileState.userId) {
+			this.getStubForUser(fileState.userId).onRowChange(
+				this.state.bootId,
+				file,
+				'file',
+				'insert',
+				fileState.userId
+			)
+		}
+		// todo: if the file is no longer shared (i.e. it was unshared between the time that the mutation was validated and now)
+		// then we should probably remove the fileState somehow?
+	}
 
-	insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
+	private _insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
 		switch (table) {
 			case 'user': {
 				const row = _row as TlaUser
@@ -278,25 +435,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					row.fileId,
 					JSON.stringify(row)
 				)
-				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.fileId).toArray()[0] as {
-					json: string
-					ownerId: string
-				} | null
-				if (!file) break
-				if (file.ownerId !== row.userId) {
-					this.getStubForUser(row.userId).onRowChange(
-						JSON.parse(file.json),
-						'file',
-						'insert',
-						row.userId
-					)
-				}
 				break
 			}
 		}
 	}
 
-	getActiveImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
+	private getActiveImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
 		let result: string[] = []
 
 		switch (event.relation.table) {
@@ -338,7 +482,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			.map((x) => x.id as string)
 	}
 
-	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
+	private updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
+		assert(this.state.type === 'connected', 'state should be connected in updateRow')
 		switch (event.relation.table) {
 			case 'user': {
 				const row = _row as TlaUser
@@ -373,7 +518,20 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	async ping() {
+		return 'pong'
+	}
+
+	async waitUntilConnected() {
+		while (this.state.type !== 'connected') {
+			await this.state.promise
+		}
+	}
+
 	async fetchDataForUser(userId: string) {
+		await this.waitUntilConnected()
+		assert(this.state.type === 'connected', 'state should be connected in fetchDataForUser')
+
 		const files = this.sql
 			.exec(
 				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,
@@ -390,14 +548,19 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			.exec(`SELECT json FROM user WHERE id = ?`, userId)
 			.toArray()
 			.map((x) => JSON.parse(x.json as string))[0]
+
 		return {
-			files: files as TlaFile[],
-			fileStates: fileStates as TlaFileState[],
-			user: user as TlaUser,
+			bootId: this.state.bootId,
+			data: {
+				files: files as TlaFile[],
+				fileStates: fileStates as TlaFileState[],
+				user: user as TlaUser,
+			},
 		}
 	}
 
 	async getFileRecord(fileId: string) {
+		await this.waitUntilConnected()
 		try {
 			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()
 			return JSON.parse(json as string) as TlaFile

commit 314d4eab1f9aa2040e20843172af0cb9cfd3aa14
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Nov 20 09:22:59 2024 +0000

    Lazy replicator (#4926)
    
    - the pg replicator only stores data for the users who are currently
    active
    - even then it only stores the users' ids, along with any guest file ids
    they have access to.
    - each user DO fetches their replica directly from postgres, and syncs
    via messages from the pg replicator
    - user DOs keep their replica in memory rather than sqlite, since they
    are so small.
    
    still need to debug and stress test this, but it should be a lot more
    scalable than the current thing.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug with…

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index a2df0b4f0..ff0736b7f 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,47 +1,28 @@
-import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'
-import { assert, compact, promiseWithResolve, sleep, uniq, uniqueId } from '@tldraw/utils'
+import { ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
+import { assert, promiseWithResolve, sleep, uniqueId } from '@tldraw/utils'
 import { ExecutionQueue, createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
-import type { TLUserDurableObject } from './TLUserDurableObject'
-import {
-	fileKeys,
-	fileStateKeys,
-	getFetchEverythingSql,
-	parseResultRow,
-	userKeys,
-} from './getFetchEverythingSql'
+import type { TLDrawDurableObject } from './TLDrawDurableObject'
+import { ZReplicationEvent } from './UserDataSyncer'
+import { getPostgres } from './getPostgres'
 import { Environment } from './types'
+import { getUserDurableObject } from './utils/durableObjects'
 
 const seed = `
-DROP TABLE IF EXISTS file_state;
-DROP TABLE IF EXISTS file;
-DROP TABLE IF EXISTS user;
-
-CREATE TABLE user (
-	id TEXT PRIMARY KEY,
-	json TEXT NOT NULL
-);
-
-CREATE TABLE file (
-	id TEXT PRIMARY KEY,
-	ownerId TEXT NOT NULL,
-	json TEXT NOT NULL
-);
-
-CREATE TABLE file_state (
-	userId TEXT NOT NULL,
-	fileId TEXT NOT NULL,
-	json TEXT NOT NULL,
-	PRIMARY KEY (userId, fileId)
-);
-
 -- we keep the active_user data between reboots to 
 -- make sure users don't miss updates.
 CREATE TABLE IF NOT EXISTS active_user (
 	id TEXT PRIMARY KEY
 );
+DROP TABLE IF EXISTS user_file_subscriptions;
+CREATE TABLE user_file_subscriptions (
+	userId TEXT,
+	fileId TEXT,
+	PRIMARY KEY (userId, fileId),
+	FOREIGN KEY (userId) REFERENCES active_user(id) ON DELETE CASCADE
+);
 `
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
@@ -50,17 +31,18 @@ type BootState =
 	| {
 			type: 'init'
 			promise: PromiseWithResolve
+			sequenceId: string
 	  }
 	| {
 			type: 'connecting'
 			db: postgres.Sql
-			bootId: string
+			sequenceId: string
 			promise: PromiseWithResolve
 	  }
 	| {
 			type: 'connected'
 			db: postgres.Sql
-			bootId: string
+			sequenceId: string
 			subscription: postgres.SubscriptionHandle
 	  }
 
@@ -69,6 +51,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	state: BootState = {
 		type: 'init',
 		promise: promiseWithResolve(),
+		sequenceId: uniqueId(),
 	}
 
 	sentry
@@ -77,7 +60,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		// eslint-disable-next-line @typescript-eslint/no-deprecated
 		this.sentry?.captureException(exception, eventHint) as any
 		if (!this.sentry) {
-			console.error(exception)
+			console.error(`[TLPostgresReplicator]: `, exception)
 		}
 	}
 
@@ -85,29 +68,53 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		super(ctx, env)
 		this.sentry = createSentry(ctx, env)
 		this.sql = this.ctx.storage.sql
+		this.sql.exec(seed)
 		this.reboot(false)
+		this.alarm()
 	}
+
+	__test__forceReboot() {
+		this.reboot()
+	}
+	__test__panic() {
+		this.ctx.abort()
+	}
+
 	private debug(...args: any[]) {
 		// uncomment for dev time debugging
-		// console.log(...args)
+		// console.log('[TLPostgresReplicator]:', ...args)
 		if (this.sentry) {
 			// eslint-disable-next-line @typescript-eslint/no-deprecated
 			this.sentry.addBreadcrumb({
-				message: args.join(' '),
+				message: `[TLPostgresReplicator]: ${args.join(' ')}`,
 			})
 		}
 	}
+	override async alarm() {
+		this.ctx.storage.setAlarm(Date.now() + 1000)
+	}
 
 	private queue = new ExecutionQueue()
 
 	private async reboot(delay = true) {
 		// TODO: set up analytics and alerts for this
-		this.debug('rebooting')
+		this.debug('reboot push')
 		await this.queue.push(async () => {
 			if (delay) {
 				await sleep(1000)
 			}
-			await this.boot()
+			this.debug('rebooting')
+			const res = await Promise.race([
+				this.boot().then(() => 'ok'),
+				sleep(3000).then(() => 'timeout'),
+			]).catch((e) => {
+				this.captureException(e)
+				return 'error'
+			})
+			this.debug('rebooted', res)
+			if (res !== 'ok') {
+				this.reboot()
+			}
 		})
 	}
 
@@ -120,190 +127,86 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		} else if (this.state.type === 'connecting') {
 			this.state.db.end().catch(this.captureException)
 		}
+		const promise = 'promise' in this.state ? this.state.promise : promiseWithResolve()
 		this.state = {
 			type: 'connecting',
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
-			promise: 'promise' in this.state ? this.state.promise : promiseWithResolve(),
-			db: postgres(this.env.BOTCOM_POSTGRES_CONNECTION_STRING, {
-				types: {
-					bigint: {
-						from: [20], // PostgreSQL OID for BIGINT
-						parse: (value: string) => Number(value), // Convert string to number
-						to: 20,
-						serialize: (value: number) => String(value), // Convert number to string
-					},
-				},
-			}),
-			bootId: uniqueId(),
+			promise,
+			db: getPostgres(this.env),
+			sequenceId: uniqueId(),
 		}
-		/**
-		 * BOOTUP SEQUENCE
-		 * 1. Generate a unique boot id
-		 * 2. Subscribe to all changes
-		 * 3. Fetch all data and write the boot id in a transaction
-		 * 4. If we receive events before the boot id update comes through, ignore them
-		 * 5. If we receive events after the boot id comes through but before we've finished
-		 *    fetching all data, buffer them and apply them after we've finished fetching all data.
-		 *    (not sure this is possible, but just in case)
-		 * 6. Once we've finished fetching all data, apply any buffered events
-		 */
-
-		const myId = this.ctx.id.toString()
-		// if the bootId changes during the boot process, we should stop silently
-		const bootId = this.state.bootId
-
-		const promise = this.state.promise
-
-		const start = Date.now()
-		const result = await new Promise<'error' | 'success'>((resolve) => {
-			let didFetchInitialData = false
-			let didGetBootIdInSubscription = false
-			let subscription: postgres.SubscriptionHandle | undefined
-
-			const initialUpdateBuffer: Array<{
-				row: postgres.Row | null
-				info: postgres.ReplicationEvent
-			}> = []
-
-			const updateState = () => {
-				if (didFetchInitialData && didGetBootIdInSubscription && subscription) {
-					// we got everything, so we can set the state to connected and apply any buffered events
-					assert(this.state.type === 'connecting', 'state should be connecting')
-					this.state = {
-						type: 'connected',
-						db: this.state.db,
-						bootId: this.state.bootId,
-						subscription,
-					}
-					this.debug('num updates pending after pg sync:', initialUpdateBuffer.length)
-					if (initialUpdateBuffer.length) {
-						while (initialUpdateBuffer.length) {
-							const { row, info } = initialUpdateBuffer.shift()!
-							this.handleEvent(row, info)
-						}
-					}
-					resolve('success')
-				}
+		const subscription = await this.state.db.subscribe(
+			'*',
+			this.handleEvent.bind(this),
+			() => {
+				this.onDidBoot()
+			},
+			() => {
+				// this is invoked if the subscription is closed unexpectedly
+				this.captureException(new Error('Subscription error'))
+				this.reboot()
 			}
+		)
 
-			assert(this.state.type === 'connecting', 'state should be connecting')
-			this.debug('subscribing')
-			this.state.db
-				.subscribe(
-					'*',
-					// on message
-					async (row, info) => {
-						if (this.state.type === 'connected') {
-							this.handleEvent(row, info)
-							return
-						}
-						if (this.state.type !== 'connecting') return
-
-						if (didGetBootIdInSubscription) {
-							// we've already got the boot id, so just shove things into
-							// a buffer until the state is set to 'connecting'
-							initialUpdateBuffer.push({ row, info })
-						} else if (
-							info.relation.table === 'replicator_boot_id' &&
-							(row as any)?.bootId === this.state.bootId
-						) {
-							didGetBootIdInSubscription = true
-							updateState()
-						}
-						// ignore other events until we get the boot id
-					},
-					// on connect
-					async () => {
-						this.debug('on connect')
-						try {
-							assert(this.state.type === 'connecting', 'state should be connecting')
-							const sql = getFetchEverythingSql(myId, bootId)
-							this.sql.exec(seed)
-							// ok
-							await this.state.db.begin(async (db) => {
-								return db
-									.unsafe(sql, [], { prepare: false })
-									.simple()
-									.forEach((row: any) => {
-										this._insertRow(
-											parseResultRow(
-												row.table === 'user'
-													? userKeys
-													: row.table === 'file'
-														? fileKeys
-														: fileStateKeys,
-												row
-											),
-											row.table
-										)
-									})
-							})
-							this.debug('database size (mb)', (this.sql.databaseSize / 1024 / 1024).toFixed(2))
-							// this will prevent more events from being added to the buffer
-							didFetchInitialData = true
-							updateState()
-						} catch (e) {
-							this.debug('init failed')
-							this.captureException(e)
-							resolve('error')
-							return
-						}
-					},
-					// on error
-					() => {
-						this.debug('on error')
-						const e = new Error('replication start failed')
-						this.captureException(e)
-						if (this.state.type === 'connecting') {
-							resolve('error')
-						} else {
-							// This happens when the connection is lost, e.g. when the database is restarted
-							// or network conditions get weird.
-							this.reboot()
-						}
-					}
-				)
-				.then((handle) => {
-					this.debug('got handle')
-					subscription = handle
-					updateState()
-				})
-				.catch((err) => {
-					this.debug('caught error')
-					this.captureException(new Error('replication start failed (catch)'))
-					this.captureException(err)
-					resolve('error')
-				})
-		})
-
-		const end = Date.now()
-		this.debug('boot time', end - start, 'ms')
+		this.state = {
+			type: 'connected',
+			subscription,
+			sequenceId: this.state.sequenceId,
+			db: this.state.db,
+		}
+		promise.resolve(null)
+	}
 
-		if (result === 'error') {
-			this.reboot()
-		} else {
-			promise.resolve(null)
+	private onDidBoot() {
+		// re-register all active users to get their latest guest info
+		// do this in small batches to avoid overwhelming the system
+		const users = this.sql.exec('SELECT id FROM active_user').toArray()
+		const sequenceId = this.state.sequenceId
+		const BATCH_SIZE = 5
+		const tick = () => {
+			if (this.state.sequenceId !== sequenceId) return
+			if (users.length === 0) return
+			const batch = users.splice(0, BATCH_SIZE)
+			for (const user of batch) {
+				this.messageUser(user.id as string, { type: 'force_reboot', sequenceId })
+			}
+			setTimeout(tick, 10)
 		}
+		tick()
+	}
+
+	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		this.debug('handleEvent', event)
+		this.queue.push(() => this._handleEvent(row, event))
 	}
 
-	// It is important that this method is synchronous!!!!
-	// We need to make sure that events are handled in-order.
-	// If we make this asynchronous for whatever reason we should
-	// make sure to uphold this invariant.
-	handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+	private async _handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
+		if (event.command === 'delete' && event.relation.table === 'file') {
+			const userId = row?.ownerId
+			this.debug("deleting user's file", row, 'isActive', this.userIsActive(userId))
+		}
+		// this.debug('handleEvent', event)
 		try {
-			if (event.relation.table === 'replicator_boot_id') {
-				assert(
-					(row as any)?.replicatorId && (row as any)?.replicatorId !== this.ctx.id.toString(),
-					'we should only get boot id events for other replicators: ' + (row as any)?.replicatorId
-				)
+			if (event.relation.table === 'user_boot_id' && event.command !== 'delete') {
+				assert(row, 'Row is required for insert/update event')
+				this.messageUser(row.userId, {
+					type: 'boot_complete',
+					userId: row.userId,
+					bootId: row.bootId,
+					sequenceId: this.state.sequenceId,
+				})
 				return
 			}
 			if (event.relation.table === 'user_mutation_number') {
 				if (!row) throw new Error('Row is required for delete event')
-				this.getStubForUser(row.userId).commitMutation(row.mutationNumber, row.userId)
+				this.messageUser(row.userId, {
+					type: 'mutation_commit',
+					mutationNumber: row.mutationNumber,
+					userId: row.userId,
+					sequenceId: this.state.sequenceId,
+				})
 				return
 			}
 			if (
@@ -314,37 +217,89 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				console.error(`Unhandled table: ${event.relation.table}`)
 				return
 			}
+			assert(row, 'Row is required for insert/update/delete event')
+
+			if (
+				event.relation.table === 'file_state' &&
+				event.command === 'insert' &&
+				this.userIsActive(row.userId)
+			) {
+				const file = await this.getFileRecord(row.fileId)
+				if (
+					file &&
+					(file.ownerId === row.userId ||
+						(file?.ownerId !== row.userId &&
+							// mitigate a potential race condition where the file is unshared between the time this
+							// event was dispatched and the time it was processed
+							file.shared))
+				) {
+					this.sql.exec(
+						`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
+						row.userId,
+						row.fileId
+					)
+					this.messageUser(row.userId, {
+						type: 'row_update',
+						row: file,
+						table: 'file',
+						event: 'insert',
+						sequenceId: this.state.sequenceId,
+						userId: row.userId,
+					})
+				} else if (!file) {
+					this.captureException(new Error(`File not found: ${row.fileId}`))
+				}
+			} else if (
+				event.relation.table === 'file_state' &&
+				event.command === 'delete' &&
+				this.userIsActive(row.userId)
+			) {
+				const didHaveSubscription =
+					this.sql
+						.exec(
+							'SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?',
+							row.userId,
+							row.fileId
+						)
+						.toArray().length > 0
+				if (didHaveSubscription) {
+					this.sql.exec(
+						`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
+						row.userId,
+						row
+					)
+					this.messageUser(row.userId, {
+						type: 'row_update',
+						row: { id: row.fileId } as any,
+						table: 'file',
+						event: 'delete',
+						sequenceId: this.state.sequenceId,
+						userId: row.userId,
+					})
+				}
+			}
+			if (event.relation.table === 'file' && event.command === 'delete') {
+				this.getStubForFile(row.id).appFileRecordDidDelete()
+			}
+			if (event.relation.table === 'file' && event.command === 'update') {
+				this.getStubForFile(row.id).appFileRecordDidUpdate(row as TlaFile)
+			}
 
 			let userIds: string[] = []
 			if (row) {
 				userIds = this.getActiveImpactedUserIds(row, event)
 			}
-			switch (event.command) {
-				case 'delete':
-					if (!row) throw new Error('Row is required for delete event')
-					this.deleteRow(row, event)
-					break
-				case 'insert':
-					if (!row) throw new Error('Row is required for delete event')
-					this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')
-					break
-				case 'update':
-					if (!row) throw new Error('Row is required for delete event')
-					this.updateRow(row, event)
-					break
-				default:
-					console.error(`Unhandled event: ${event}`)
-			}
 			if (row) {
 				for (const userId of userIds) {
 					// get user DO and send update message
-					this.getStubForUser(userId).onRowChange(
-						this.state.bootId,
-						row,
-						event.relation.table as 'user' | 'file' | 'file_state',
-						event.command,
-						userId
-					)
+					this.messageUser(userId, {
+						type: 'row_update',
+						row: row as any,
+						table: event.relation.table as ZTable,
+						event: event.command,
+						sequenceId: this.state.sequenceId,
+						userId,
+					})
 				}
 			}
 		} catch (e) {
@@ -352,233 +307,92 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	private deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {
-		assert(this.state.type === 'connected', 'state should be connected in deleteRow')
-		switch (event.relation.table) {
-			case 'user':
-				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)
-				break
-			case 'file':
-				this.sql.exec(`DELETE FROM file WHERE id = ?`, row.id)
-				break
-			case 'file_state': {
-				this.sql.exec(
-					`DELETE FROM file_state WHERE userId = ? AND fileId = ?`,
-					row.userId,
-					row.fileId
-				)
-
-				const files = this.sql
-					.exec(`SELECT * FROM file WHERE id = ? LIMIT 1`, row.fileId)
-					.toArray() as any as TlaFile[]
-				if (!files.length) break
-				const file = files[0] as any
-				if (row.userId !== file.ownerId) {
-					this.getStubForUser(row.userId).onRowChange(
-						this.state.bootId,
-						JSON.parse(file.json),
-						'file',
-						'delete',
-						row.userId
-					)
-				}
-
-				break
-			}
-		}
-	}
-	private insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
-		assert(this.state.type === 'connected', 'state should be connected in insertRow')
-		this._insertRow(_row, table)
-
-		// If a user just added a file state for a shared file for the first time, they won't
-		// have access to the file. We need to send them the file.
-		if (table !== 'file_state') return
-		const fileState = _row as TlaFileState
-		const fileRow = this.sql
-			.exec(`SELECT * FROM file WHERE id = ?`, fileState.fileId)
-			.toArray()[0] as {
-			json: string
-		} | null
-		if (!fileRow) return
-		const file = JSON.parse(fileRow.json) as TlaFile
-		if (file.shared && file.ownerId !== fileState.userId) {
-			this.getStubForUser(fileState.userId).onRowChange(
-				this.state.bootId,
-				file,
-				'file',
-				'insert',
-				fileState.userId
-			)
-		}
-		// todo: if the file is no longer shared (i.e. it was unshared between the time that the mutation was validated and now)
-		// then we should probably remove the fileState somehow?
-	}
-
-	private _insertRow(_row: object, table: 'user' | 'file' | 'file_state') {
-		switch (table) {
-			case 'user': {
-				const row = _row as TlaUser
-				this.sql.exec(`INSERT INTO user VALUES (?, ?)`, row.id, JSON.stringify(row))
-				break
-			}
-			case 'file': {
-				const row = _row as TlaFile
-				this.sql.exec(`INSERT INTO file VALUES (?, ?, ?)`, row.id, row.ownerId, JSON.stringify(row))
-				break
-			}
-			case 'file_state': {
-				const row = _row as TlaFileState
-				this.sql.exec(
-					`INSERT INTO file_state VALUES (?, ?, ?)`,
-					row.userId,
-					row.fileId,
-					JSON.stringify(row)
-				)
-				break
-			}
-		}
+	private userIsActive(userId: string) {
+		return this.sql.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0
 	}
 
 	private getActiveImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
-		let result: string[] = []
-
 		switch (event.relation.table) {
 			case 'user':
 				assert(row.id, 'row id is required')
-				result = [row.id as string]
-				break
+				return this.userIsActive(row.id) ? [row.id as string] : []
 			case 'file': {
-				assert(row.id, 'row id is required')
-				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]
-				result = compact(
-					uniq([
-						...(this.sql
-							.exec(
-								`SELECT id FROM user WHERE EXISTS(select 1 from file_state where fileId = ?)`,
-								row.id
-							)
-							.toArray()
-							.map((x) => x.id) as string[]),
-						row.ownerId as string,
-						file?.ownerId as string,
-					])
-				)
-				break
+				return this.sql
+					.exec(`SELECT "userId" FROM user_file_subscriptions WHERE "fileId" = ?`, row.id)
+					.toArray()
+					.map((x) => x.userId as string)
 			}
-
 			case 'file_state':
 				assert(row.userId, 'user id is required')
 				assert(row.fileId, 'file id is required')
-				result = [row.userId as string]
-				break
-		}
-		if (result.length === 0) return []
-
-		const placeholders = result.map(() => '?').join(', ')
-		return this.sql
-			.exec(`SELECT * FROM active_user WHERE id IN (${placeholders})`, ...result)
-			.toArray()
-			.map((x) => x.id as string)
-	}
-
-	private updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {
-		assert(this.state.type === 'connected', 'state should be connected in updateRow')
-		switch (event.relation.table) {
-			case 'user': {
-				const row = _row as TlaUser
-				this.sql.exec(`UPDATE user SET json = ? WHERE id = ?`, JSON.stringify(row), row.id)
+				return this.userIsActive(row.userId) ? [row.userId as string] : []
 				break
-			}
-			case 'file': {
-				const row = _row as TlaFile
-				this.sql.exec(
-					`UPDATE file SET json = ?, ownerId = ? WHERE id = ?`,
-					JSON.stringify(row),
-					row.ownerId,
-					row.id
+			default:
+				this.captureException(
+					new Error(`[getActiveImpactedUserIds] Unhandled table: ${event.relation.table}`)
 				)
-
-				const room = this.env.TLDR_DOC.get(
-					this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${row.id}`)
-				)
-				room.appFileRecordDidUpdate(row).catch(console.error)
-				break
-			}
-			case 'file_state': {
-				const row = _row as TlaFileState
-				this.sql.exec(
-					`UPDATE file_state SET json = ? WHERE userId = ? AND fileId = ?`,
-					JSON.stringify(row),
-					row.userId,
-					row.fileId
-				)
-				break
-			}
 		}
+		return []
 	}
 
 	async ping() {
-		return 'pong'
+		this.debug('ping')
+		return { sequenceId: this.state.sequenceId }
 	}
 
-	async waitUntilConnected() {
+	private async waitUntilConnected() {
 		while (this.state.type !== 'connected') {
 			await this.state.promise
 		}
 	}
 
-	async fetchDataForUser(userId: string) {
-		await this.waitUntilConnected()
-		assert(this.state.type === 'connected', 'state should be connected in fetchDataForUser')
-
-		const files = this.sql
-			.exec(
-				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,
-				userId,
-				userId
-			)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))
-		const fileStates = this.sql
-			.exec(`SELECT json FROM file_state WHERE userId = ?`, userId)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))
-		const user = this.sql
-			.exec(`SELECT json FROM user WHERE id = ?`, userId)
-			.toArray()
-			.map((x) => JSON.parse(x.json as string))[0]
-
-		return {
-			bootId: this.state.bootId,
-			data: {
-				files: files as TlaFile[],
-				fileStates: fileStates as TlaFileState[],
-				user: user as TlaUser,
-			},
-		}
-	}
-
 	async getFileRecord(fileId: string) {
 		await this.waitUntilConnected()
+		assert(this.state.type === 'connected', 'state should be connected in getFileRecord')
 		try {
-			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()
-			return JSON.parse(json as string) as TlaFile
+			const res = await this.state.db`select * from public.file where id = ${fileId}`
+			if (res.length === 0) return null
+			return res[0] as TlaFile
 		} catch (_e) {
 			return null
 		}
 	}
 
-	private getStubForUser(userId: string) {
-		const id = this.env.TL_USER.idFromName(userId)
-		return this.env.TL_USER.get(id) as any as TLUserDurableObject
+	private async messageUser(userId: string, event: ZReplicationEvent) {
+		const user = getUserDurableObject(this.env, userId)
+		const res = await user.handleReplicationEvent(event)
+		if (res === 'unregister') {
+			this.debug('unregistering user', userId, event)
+			this.unregisterUser(userId)
+		}
+	}
+
+	private getStubForFile(fileId: string) {
+		const id = this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${fileId}`)
+		return this.env.TLDR_DOC.get(id) as any as TLDrawDurableObject
 	}
 
-	registerUser(userId: string) {
-		this.sql.exec(`INSERT INTO active_user (id) VALUES (?) ON CONFLICT (id) DO NOTHING`, userId)
+	async registerUser(userId: string) {
+		this.debug('registering user', userId)
+		await this.waitUntilConnected()
+		assert(this.state.type === 'connected', 'state should be connected in registerUser')
+		const guestFiles = await this.state
+			.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`
+
+		// clear user and subscriptions
+		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+		this.sql.exec(`INSERT INTO active_user (id) VALUES (?)`, userId)
+		for (const file of guestFiles) {
+			this.sql.exec(
+				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
+				userId,
+				file.id
+			)
+		}
+		return this.state.sequenceId
 	}
 
-	unregisterUser(userId: string) {
+	async unregisterUser(userId: string) {
 		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 	}
 }

commit bcec83df43974b4084e63289048fe526a6619991
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 25 09:28:16 2024 +0000

    [botcom] simplify replicator dispatch logic (#4965)
    
    This stuff was a little bit of a mess. I made it synchronous again and
    hopefully caught an extra edge case or two.
    
    - added a `isFileOwner` field to file_state, populated by triggers on
    both the file table and the file_state table.
    - used `isFileOwner` to avoid checking ownership while dispatching
    events in the replicator
    - simplified the event dispatching logic by moving it out into separate
    methods for each table, so it's easier to follow what's happening.
    - fixed the 'file deleting isn't working in prod' bug, that was to do
    with r2 complaining about things it doesn't complain about in dev mode.
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index ff0736b7f..28dc82b06 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -178,161 +178,185 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		this.debug('handleEvent', event)
-		this.queue.push(() => this._handleEvent(row, event))
-	}
-
-	private async _handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
-		if (event.command === 'delete' && event.relation.table === 'file') {
-			const userId = row?.ownerId
-			this.debug("deleting user's file", row, 'isActive', this.userIsActive(userId))
-		}
-		// this.debug('handleEvent', event)
 		try {
-			if (event.relation.table === 'user_boot_id' && event.command !== 'delete') {
-				assert(row, 'Row is required for insert/update event')
-				this.messageUser(row.userId, {
-					type: 'boot_complete',
-					userId: row.userId,
-					bootId: row.bootId,
-					sequenceId: this.state.sequenceId,
-				})
-				return
+			switch (event.relation.table) {
+				case 'user_boot_id':
+					this.handleBootEvent(row, event)
+					return
+				case 'user_mutation_number':
+					this.handleMutationConfirmationEvent(row, event)
+					return
+				case 'file_state':
+					this.handleFileStateEvent(row, event)
+					return
+				case 'file':
+					this.handleFileEvent(row, event)
+					return
+				case 'user':
+					this.handleUserEvent(row, event)
+					return
+				default:
+					this.captureException(new Error(`Unhandled table: ${event.relation.table}`))
+					return
 			}
-			if (event.relation.table === 'user_mutation_number') {
-				if (!row) throw new Error('Row is required for delete event')
-				this.messageUser(row.userId, {
-					type: 'mutation_commit',
-					mutationNumber: row.mutationNumber,
-					userId: row.userId,
-					sequenceId: this.state.sequenceId,
-				})
-				return
-			}
-			if (
-				event.relation.table !== 'user' &&
-				event.relation.table !== 'file' &&
-				event.relation.table !== 'file_state'
-			) {
-				console.error(`Unhandled table: ${event.relation.table}`)
-				return
-			}
-			assert(row, 'Row is required for insert/update/delete event')
+		} catch (e) {
+			this.captureException(e)
+		}
+	}
 
-			if (
-				event.relation.table === 'file_state' &&
-				event.command === 'insert' &&
-				this.userIsActive(row.userId)
-			) {
-				const file = await this.getFileRecord(row.fileId)
-				if (
-					file &&
-					(file.ownerId === row.userId ||
-						(file?.ownerId !== row.userId &&
-							// mitigate a potential race condition where the file is unshared between the time this
-							// event was dispatched and the time it was processed
-							file.shared))
-				) {
-					this.sql.exec(
-						`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
-						row.userId,
-						row.fileId
-					)
-					this.messageUser(row.userId, {
-						type: 'row_update',
-						row: file,
-						table: 'file',
-						event: 'insert',
-						sequenceId: this.state.sequenceId,
-						userId: row.userId,
-					})
-				} else if (!file) {
-					this.captureException(new Error(`File not found: ${row.fileId}`))
-				}
-			} else if (
-				event.relation.table === 'file_state' &&
-				event.command === 'delete' &&
-				this.userIsActive(row.userId)
-			) {
-				const didHaveSubscription =
-					this.sql
+	private handleBootEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		if (event.command === 'delete') return
+		assert(row?.bootId, 'bootId is required')
+		this.messageUser(row.userId, {
+			type: 'boot_complete',
+			userId: row.userId,
+			bootId: row.bootId,
+			sequenceId: this.state.sequenceId,
+		})
+	}
+
+	private handleMutationConfirmationEvent(
+		row: postgres.Row | null,
+		event: postgres.ReplicationEvent
+	) {
+		if (event.command === 'delete') return
+		assert(typeof row?.mutationNumber === 'number', 'mutationNumber is required')
+		this.messageUser(row.userId, {
+			type: 'mutation_commit',
+			mutationNumber: row.mutationNumber,
+			userId: row.userId,
+			sequenceId: this.state.sequenceId,
+		})
+	}
+
+	private handleFileStateEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		assert(row?.userId, 'userId is required')
+		if (!this.userIsActive(row.userId)) return
+		if (event.command === 'insert') {
+			this.sql.exec(
+				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?)`,
+				row.userId,
+				row.fileId
+			)
+			assert(typeof row.isFileOwner === 'boolean', 'isFileOwner is required')
+			if (!row.isFileOwner) {
+				// need to dispatch a file creation event to the user
+				const sequenceId = this.state.sequenceId
+				this.getFileRecord(row.fileId).then((file) => {
+					// mitigate a couple of race conditions
+
+					// check that we didn't reboot (in which case the user do will fetch the file record on its own)
+					if (this.state.sequenceId !== sequenceId) return
+					// check that the subscription wasn't deleted before we managed to fetch the file record
+					const sub = this.sql
 						.exec(
-							'SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?',
+							`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
 							row.userId,
 							row.fileId
 						)
-						.toArray().length > 0
-				if (didHaveSubscription) {
-					this.sql.exec(
-						`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
-						row.userId,
-						row
-					)
+						.toArray()[0]
+					if (!sub) return
+
+					// alright we're good to go
 					this.messageUser(row.userId, {
 						type: 'row_update',
-						row: { id: row.fileId } as any,
+						row: file as any,
 						table: 'file',
-						event: 'delete',
+						event: 'insert',
 						sequenceId: this.state.sequenceId,
 						userId: row.userId,
 					})
-				}
-			}
-			if (event.relation.table === 'file' && event.command === 'delete') {
-				this.getStubForFile(row.id).appFileRecordDidDelete()
+				})
 			}
-			if (event.relation.table === 'file' && event.command === 'update') {
-				this.getStubForFile(row.id).appFileRecordDidUpdate(row as TlaFile)
+		} else if (event.command === 'delete') {
+			// If the file state being deleted does not belong to the file owner,
+			// we need to send a delete event for the file to the user
+			const sub = this.sql
+				.exec(
+					`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
+					row.userId,
+					row.fileId
+				)
+				.toArray()[0]
+			if (!sub) {
+				// the file was deleted before the file state
+				this.debug('file state deleted before file', row)
+			} else {
+				this.sql.exec(
+					`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
+					row.userId,
+					row.fileId
+				)
+				// We forward a file delete event to the user
+				// even if they are the file owner. This is because the file_state
+				// deletion might happen before the file deletion and we don't get the
+				// ownerId on file delete events
+				this.messageUser(row.userId, {
+					type: 'row_update',
+					row: { id: row.fileId } as any,
+					table: 'file',
+					event: 'delete',
+					sequenceId: this.state.sequenceId,
+					userId: row.userId,
+				})
 			}
+		}
+		this.messageUser(row.userId, {
+			type: 'row_update',
+			row: row as any,
+			table: event.relation.table as ZTable,
+			event: event.command,
+			sequenceId: this.state.sequenceId,
+			userId: row.userId,
+		})
+	}
 
-			let userIds: string[] = []
-			if (row) {
-				userIds = this.getActiveImpactedUserIds(row, event)
+	private handleFileEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		assert(row?.id, 'row id is required')
+		const impactedUserIds = this.sql
+			.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)
+			.toArray()
+			.map((x) => x.userId as string)
+		// if the file state was deleted before the file, we might not have any impacted users
+		if (event.command === 'delete') {
+			this.getStubForFile(row.id).appFileRecordDidDelete()
+			this.sql.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
+		} else if (event.command === 'update') {
+			assert(row.ownerId, 'ownerId is required when updating file')
+			this.getStubForFile(row.id).appFileRecordDidUpdate(row as TlaFile)
+		} else if (event.command === 'insert') {
+			assert(row.ownerId, 'ownerId is required when inserting file')
+			if (!impactedUserIds.includes(row.ownerId)) {
+				impactedUserIds.push(row.ownerId)
 			}
-			if (row) {
-				for (const userId of userIds) {
-					// get user DO and send update message
-					this.messageUser(userId, {
-						type: 'row_update',
-						row: row as any,
-						table: event.relation.table as ZTable,
-						event: event.command,
-						sequenceId: this.state.sequenceId,
-						userId,
-					})
-				}
-			}
-		} catch (e) {
-			this.captureException(e)
+		}
+		for (const userId of impactedUserIds) {
+			this.messageUser(userId, {
+				type: 'row_update',
+				row: row as any,
+				table: event.relation.table as ZTable,
+				event: event.command,
+				sequenceId: this.state.sequenceId,
+				userId,
+			})
 		}
 	}
 
-	private userIsActive(userId: string) {
-		return this.sql.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0
+	private handleUserEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		assert(row?.id, 'user id is required')
+		this.messageUser(row.id, {
+			type: 'row_update',
+			row: row as any,
+			table: event.relation.table as ZTable,
+			event: event.command,
+			sequenceId: this.state.sequenceId,
+			userId: row.id,
+		})
 	}
 
-	private getActiveImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {
-		switch (event.relation.table) {
-			case 'user':
-				assert(row.id, 'row id is required')
-				return this.userIsActive(row.id) ? [row.id as string] : []
-			case 'file': {
-				return this.sql
-					.exec(`SELECT "userId" FROM user_file_subscriptions WHERE "fileId" = ?`, row.id)
-					.toArray()
-					.map((x) => x.userId as string)
-			}
-			case 'file_state':
-				assert(row.userId, 'user id is required')
-				assert(row.fileId, 'file id is required')
-				return this.userIsActive(row.userId) ? [row.userId as string] : []
-				break
-			default:
-				this.captureException(
-					new Error(`[getActiveImpactedUserIds] Unhandled table: ${event.relation.table}`)
-				)
-		}
-		return []
+	private userIsActive(userId: string) {
+		return this.sql.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0
 	}
 
 	async ping() {

commit 8329c84b1049d98fd94d1ff46e29901205394fea
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Nov 28 10:17:27 2024 +0000

    [botcom] auto migrations again (#5014)
    
    redoing #5005 with pooled postgres connections
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 28dc82b06..f9acc1159 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -133,7 +133,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
 			promise,
-			db: getPostgres(this.env),
+			db: getPostgres(this.env, { pooled: false }),
 			sequenceId: uniqueId(),
 		}
 		const subscription = await this.state.db.subscribe(

commit ca54db7c3c7a7c89f38b688254f69740893ec857
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Dec 5 17:47:37 2024 +0100

    Add gecko analytics (#5028)
    
    Adds basic analytics for our newly introduced durable objects.
    
    I also created a few more visualizations in our on our Events grafana
    dashboard. You can now also choose which environment you want to look at
    using the filter on the top left of the dashboard.
    
    Link to [check the
    events](https://tldraw.grafana.net/d/adgumkhou3chsd/events?orgId=1&from=now-2d&to=now&timezone=browser&var-environment=pr-5028)
    for this PR. Data is quite sparse now.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index f9acc1159..c44b009aa 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,5 +1,5 @@
 import { ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
-import { assert, promiseWithResolve, sleep, uniqueId } from '@tldraw/utils'
+import { assert, exhaustiveSwitchError, promiseWithResolve, sleep, uniqueId } from '@tldraw/utils'
 import { ExecutionQueue, createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
@@ -7,7 +7,8 @@ import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
 import type { TLDrawDurableObject } from './TLDrawDurableObject'
 import { ZReplicationEvent } from './UserDataSyncer'
 import { getPostgres } from './getPostgres'
-import { Environment } from './types'
+import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
+import { EventData, writeDataPoint } from './utils/analytics'
 import { getUserDurableObject } from './utils/durableObjects'
 
 const seed = `
@@ -25,6 +26,8 @@ CREATE TABLE user_file_subscriptions (
 );
 `
 
+const ONE_MINUTE = 60 * 1000
+
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
 type BootState =
@@ -53,6 +56,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		promise: promiseWithResolve(),
 		sequenceId: uniqueId(),
 	}
+	measure: Analytics | undefined
+	postgresUpdates = 0
+	lastRpmLogTime = Date.now()
 
 	sentry
 	// eslint-disable-next-line local/prefer-class-methods
@@ -71,6 +77,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		this.sql.exec(seed)
 		this.reboot(false)
 		this.alarm()
+		this.measure = env.MEASURE
 	}
 
 	__test__forceReboot() {
@@ -92,27 +99,44 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 	override async alarm() {
 		this.ctx.storage.setAlarm(Date.now() + 1000)
+		this.maybeLogRpm()
+	}
+
+	private maybeLogRpm() {
+		const now = Date.now()
+		if (this.postgresUpdates > 0 && now - this.lastRpmLogTime > ONE_MINUTE) {
+			this.logEvent({
+				type: 'rpm',
+				rpm: this.postgresUpdates,
+			})
+			this.postgresUpdates = 0
+			this.lastRpmLogTime = now
+		}
 	}
 
 	private queue = new ExecutionQueue()
 
 	private async reboot(delay = true) {
-		// TODO: set up analytics and alerts for this
+		this.logEvent({ type: 'reboot' })
 		this.debug('reboot push')
 		await this.queue.push(async () => {
 			if (delay) {
 				await sleep(1000)
 			}
+			const start = Date.now()
 			this.debug('rebooting')
 			const res = await Promise.race([
 				this.boot().then(() => 'ok'),
 				sleep(3000).then(() => 'timeout'),
 			]).catch((e) => {
+				this.logEvent({ type: 'reboot_error' })
 				this.captureException(e)
 				return 'error'
 			})
 			this.debug('rebooted', res)
-			if (res !== 'ok') {
+			if (res === 'ok') {
+				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })
+			} else {
 				this.reboot()
 			}
 		})
@@ -177,6 +201,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		this.postgresUpdates++
 		this.debug('handleEvent', event)
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
 		try {
@@ -371,6 +396,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	async getFileRecord(fileId: string) {
+		this.logEvent({ type: 'get_file_record' })
 		await this.waitUntilConnected()
 		assert(this.state.type === 'connected', 'state should be connected in getFileRecord')
 		try {
@@ -398,6 +424,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	async registerUser(userId: string) {
 		this.debug('registering user', userId)
+		this.logEvent({ type: 'register_user' })
 		await this.waitUntilConnected()
 		assert(this.state.type === 'connected', 'state should be connected in registerUser')
 		const guestFiles = await this.state
@@ -417,6 +444,40 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	async unregisterUser(userId: string) {
+		this.logEvent({ type: 'unregister_user' })
 		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 	}
+
+	private writeEvent(eventData: EventData) {
+		writeDataPoint(this.measure, this.env, 'replicator', eventData)
+	}
+
+	logEvent(event: TLPostgresReplicatorEvent) {
+		switch (event.type) {
+			case 'reboot':
+			case 'reboot_error':
+			case 'register_user':
+			case 'unregister_user':
+			case 'get_file_record':
+				this.writeEvent({
+					blobs: [event.type],
+				})
+				break
+
+			case 'reboot_duration':
+				this.writeEvent({
+					blobs: [event.type],
+					doubles: [event.duration],
+				})
+				break
+			case 'rpm':
+				this.writeEvent({
+					blobs: [event.type],
+					doubles: [event.rpm],
+				})
+				break
+			default:
+				exhaustiveSwitchError(event)
+		}
+	}
 }

commit 4ecbef54a7fe82634fe682ed148165bc496b7b56
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Dec 6 13:52:44 2024 +0000

    [botcom] slurp local files on sign in (#5059)
    
    This PR replaces the temporary multiplayer room from the logged out root
    page with the previous local editor, and 'slurps' the data into a new
    room during the sign in flow.
    
    If something goes wrong the user sees this:
    <img width="541" alt="image"
    src="https://github.com/user-attachments/assets/92413d9a-a90c-43b6-b05d-4e0acdc7db30">
    
    follow up work:
    
    - [ ] e2e tests
    - [ ] add Terms and conditions checkbox to sign in
    
    I'll create tickets for these upon merging.
    
    
    ### Change type
    
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index c44b009aa..ff138fdd9 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,6 +1,13 @@
 import { ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
-import { assert, exhaustiveSwitchError, promiseWithResolve, sleep, uniqueId } from '@tldraw/utils'
-import { ExecutionQueue, createSentry } from '@tldraw/worker-shared'
+import {
+	ExecutionQueue,
+	assert,
+	exhaustiveSwitchError,
+	promiseWithResolve,
+	sleep,
+	uniqueId,
+} from '@tldraw/utils'
+import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'

commit 13ac3b31f5ab51e215e3cde7e92b809d87ec77be
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Dec 17 09:03:42 2024 +0000

    [botcom] stress test fixes (#5126)
    
    This PR fixes two consistency issues we ran into while stress testing
    
    1. Send the messages to the user DOs in guaranteed order, using one
    ExecutionQueue per user.
    2. Update the mutation number in a transaction, to make sure the mutated
    data is synced before the mutation number gets back.
    
    this involved doing a few extra bits
    
    - set up migrations for sqlite in the replicator
    - add a per-user sequence id and sequence number, so that user DOs can
    reboot if there's any weird issues that prevent things from arriving in
    order despite the execution queues.
    
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index ff138fdd9..dec0d9ae5 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -12,26 +12,44 @@ import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
 import type { TLDrawDurableObject } from './TLDrawDurableObject'
-import { ZReplicationEvent } from './UserDataSyncer'
+import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { getPostgres } from './getPostgres'
 import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
 import { getUserDurableObject } from './utils/durableObjects'
 
-const seed = `
--- we keep the active_user data between reboots to 
--- make sure users don't miss updates.
-CREATE TABLE IF NOT EXISTS active_user (
-	id TEXT PRIMARY KEY
-);
-DROP TABLE IF EXISTS user_file_subscriptions;
-CREATE TABLE user_file_subscriptions (
-	userId TEXT,
-	fileId TEXT,
-	PRIMARY KEY (userId, fileId),
-	FOREIGN KEY (userId) REFERENCES active_user(id) ON DELETE CASCADE
-);
-`
+interface Migration {
+	id: string
+	code: string
+}
+
+const migrations: Migration[] = [
+	{
+		id: '000_seed',
+		code: `
+			CREATE TABLE IF NOT EXISTS active_user (
+				id TEXT PRIMARY KEY
+			);
+			CREATE TABLE IF NOT EXISTS user_file_subscriptions (
+				userId TEXT,
+				fileId TEXT,
+				PRIMARY KEY (userId, fileId),
+				FOREIGN KEY (userId) REFERENCES active_user(id) ON DELETE CASCADE
+			);
+			CREATE TABLE migrations (
+				id TEXT PRIMARY KEY,
+				code TEXT NOT NULL
+			);
+		`,
+	},
+	{
+		id: '001_add_sequence_number',
+		code: `
+			ALTER TABLE active_user ADD COLUMN sequenceNumber INTEGER NOT NULL DEFAULT 0;
+			ALTER TABLE active_user ADD COLUMN sequenceIdSuffix TEXT NOT NULL DEFAULT '';
+		`,
+	},
+]
 
 const ONE_MINUTE = 60 * 1000
 
@@ -57,15 +75,20 @@ type BootState =
 	  }
 
 export class TLPostgresReplicator extends DurableObject<Environment> {
-	sql: SqlStorage
-	state: BootState = {
+	private sql: SqlStorage
+	private state: BootState = {
 		type: 'init',
 		promise: promiseWithResolve(),
 		sequenceId: uniqueId(),
 	}
-	measure: Analytics | undefined
-	postgresUpdates = 0
-	lastRpmLogTime = Date.now()
+	private measure: Analytics | undefined
+	private postgresUpdates = 0
+	private lastRpmLogTime = Date.now()
+
+	// we need to guarantee in-order delivery of messages to users
+	// but DO RPC calls are not guaranteed to happen in order, so we need to
+	// use a queue per user
+	private userDispatchQueues: Map<string, ExecutionQueue> = new Map()
 
 	sentry
 	// eslint-disable-next-line local/prefer-class-methods
@@ -81,12 +104,53 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		super(ctx, env)
 		this.sentry = createSentry(ctx, env)
 		this.sql = this.ctx.storage.sql
-		this.sql.exec(seed)
+
+		this.ctx.blockConcurrencyWhile(async () =>
+			this._migrate().catch((e) => {
+				this.captureException(e)
+				throw e
+			})
+		)
+
 		this.reboot(false)
 		this.alarm()
 		this.measure = env.MEASURE
 	}
 
+	private _applyMigration(index: number) {
+		this.sql.exec(migrations[index].code)
+		this.sql.exec(
+			'insert into migrations (id, code) values (?, ?)',
+			migrations[index].id,
+			migrations[index].code
+		)
+	}
+
+	private async _migrate() {
+		let appliedMigrations: Migration[]
+		try {
+			appliedMigrations = this.sql
+				.exec('select code, id from migrations order by id asc')
+				.toArray() as any
+		} catch (_e) {
+			// no migrations table, run initial migration
+			this._applyMigration(0)
+			appliedMigrations = [migrations[0]]
+		}
+
+		for (let i = 0; i < appliedMigrations.length; i++) {
+			if (appliedMigrations[i].id !== migrations[i].id) {
+				throw new Error(
+					'TLPostgresReplicator migrations have changed!! this is an append-only array!!'
+				)
+			}
+		}
+
+		for (let i = appliedMigrations.length; i < migrations.length; i++) {
+			this._applyMigration(i)
+		}
+	}
+
 	__test__forceReboot() {
 		this.reboot()
 	}
@@ -200,7 +264,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			if (users.length === 0) return
 			const batch = users.splice(0, BATCH_SIZE)
 			for (const user of batch) {
-				this.messageUser(user.id as string, { type: 'force_reboot', sequenceId })
+				this.messageUser(user.id as string, { type: 'force_reboot' })
 			}
 			setTimeout(tick, 10)
 		}
@@ -244,7 +308,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			type: 'boot_complete',
 			userId: row.userId,
 			bootId: row.bootId,
-			sequenceId: this.state.sequenceId,
 		})
 	}
 
@@ -258,7 +321,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			type: 'mutation_commit',
 			mutationNumber: row.mutationNumber,
 			userId: row.userId,
-			sequenceId: this.state.sequenceId,
 		})
 	}
 
@@ -296,7 +358,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 						row: file as any,
 						table: 'file',
 						event: 'insert',
-						sequenceId: this.state.sequenceId,
 						userId: row.userId,
 					})
 				})
@@ -329,7 +390,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					row: { id: row.fileId } as any,
 					table: 'file',
 					event: 'delete',
-					sequenceId: this.state.sequenceId,
 					userId: row.userId,
 				})
 			}
@@ -339,7 +399,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			row: row as any,
 			table: event.relation.table as ZTable,
 			event: event.command,
-			sequenceId: this.state.sequenceId,
 			userId: row.userId,
 		})
 	}
@@ -369,7 +428,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				row: row as any,
 				table: event.relation.table as ZTable,
 				event: event.command,
-				sequenceId: this.state.sequenceId,
 				userId,
 			})
 		}
@@ -377,12 +435,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private handleUserEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		assert(row?.id, 'user id is required')
+		this.debug('USER EVENT', event.command, row.id)
 		this.messageUser(row.id, {
 			type: 'row_update',
 			row: row as any,
 			table: event.relation.table as ZTable,
 			event: event.command,
-			sequenceId: this.state.sequenceId,
 			userId: row.id,
 		})
 	}
@@ -415,12 +473,38 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	private async messageUser(userId: string, event: ZReplicationEvent) {
-		const user = getUserDurableObject(this.env, userId)
-		const res = await user.handleReplicationEvent(event)
-		if (res === 'unregister') {
-			this.debug('unregistering user', userId, event)
-			this.unregisterUser(userId)
+	private async messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
+		try {
+			let q = this.userDispatchQueues.get(userId)
+			if (!q) {
+				q = new ExecutionQueue()
+				this.userDispatchQueues.set(userId, q)
+			}
+			await q.push(async () => {
+				const { sequenceNumber, sequenceIdSuffix } = this.sql
+					.exec(
+						'UPDATE active_user SET sequenceNumber = sequenceNumber + 1 WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
+						userId
+					)
+					.one()
+
+				const user = getUserDurableObject(this.env, userId)
+
+				assert(typeof sequenceNumber === 'number', 'sequenceNumber should be a number')
+				assert(typeof sequenceIdSuffix === 'string', 'sequenceIdSuffix should be a string')
+
+				const res = await user.handleReplicationEvent({
+					...event,
+					sequenceNumber,
+					sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
+				})
+				if (res === 'unregister') {
+					this.debug('unregistering user', userId, event)
+					this.unregisterUser(userId)
+				}
+			})
+		} catch (e) {
+			console.error('Error in messageUser', e)
 		}
 	}
 
@@ -437,9 +521,15 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		const guestFiles = await this.state
 			.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`
 
+		const sequenceIdSuffix = uniqueId()
+
 		// clear user and subscriptions
 		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
-		this.sql.exec(`INSERT INTO active_user (id) VALUES (?)`, userId)
+		this.sql.exec(
+			`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix) VALUES (?, 0, ?)`,
+			userId,
+			sequenceIdSuffix
+		)
 		for (const file of guestFiles) {
 			this.sql.exec(
 				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
@@ -447,12 +537,20 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				file.id
 			)
 		}
-		return this.state.sequenceId
+		return {
+			sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
+			sequenceNumber: 0,
+		}
 	}
 
 	async unregisterUser(userId: string) {
 		this.logEvent({ type: 'unregister_user' })
 		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+		const queue = this.userDispatchQueues.get(userId)
+		if (queue) {
+			queue.close()
+			this.userDispatchQueues.delete(userId)
+		}
 	}
 
 	private writeEvent(eventData: EventData) {

commit de9694fbb08e31bc97f51721be5a8b0f8fb53ade
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Dec 17 13:26:31 2024 +0100

    Add name and timeout params. (#5129)
    
    Improve `getPostgres` helper.:
    - We can now pass in a name, which allows us to see the who is holding
    an open connection in `pg_stat_activity`. See `application_name` column
    below.
    ![CleanShot 2024-12-16 at 15 47
    58@2x](https://github.com/user-attachments/assets/a9f62e5c-4198-478d-9020-12a74841c48e)
    - `idleTimeout` option with a default of 30.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index dec0d9ae5..fcffe5edd 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -228,7 +228,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
 			promise,
-			db: getPostgres(this.env, { pooled: false }),
+			db: getPostgres(this.env, { pooled: false, name: 'TLPostgresReplicator' }),
 			sequenceId: uniqueId(),
 		}
 		const subscription = await this.state.db.subscribe(

commit ae594c621212de1d5694b8ce17b2585f1dae1983
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Jan 8 10:22:26 2025 +0100

    Move to kysely (#5140)
    
    Switches from using postgres js to kysely. We still use postgres js for
    subscription to the db.
    
    During stress tests we noticed that postgres js was not good at managing
    the connection pool. Kysely performed much better.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index fcffe5edd..3fa35694a 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -13,7 +13,7 @@ import postgres from 'postgres'
 import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
 import type { TLDrawDurableObject } from './TLDrawDurableObject'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
-import { getPostgres } from './getPostgres'
+import { createPostgresConnection } from './postgres'
 import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
 import { getUserDurableObject } from './utils/durableObjects'
@@ -228,7 +228,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
 			promise,
-			db: getPostgres(this.env, { pooled: false, name: 'TLPostgresReplicator' }),
+			db: createPostgresConnection(this.env, { name: 'TLPostgresReplicator' }),
 			sequenceId: uniqueId(),
 		}
 		const subscription = await this.state.db.subscribe(

commit c44d4fee2684859bda323208ffc9a053256aa6de
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Jan 15 09:42:49 2025 +0000

    send extra data to sentry properly (#5216)
    
    We were not doing this properly
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 3fa35694a..d49f96f21 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -10,7 +10,6 @@ import {
 import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import postgres from 'postgres'
-import type { EventHint } from 'toucan-js/node_modules/@sentry/types'
 import type { TLDrawDurableObject } from './TLDrawDurableObject'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnection } from './postgres'
@@ -92,9 +91,13 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	sentry
 	// eslint-disable-next-line local/prefer-class-methods
-	private captureException = (exception: unknown, eventHint?: EventHint) => {
+	private captureException = (exception: unknown, extras?: Record<string, unknown>) => {
 		// eslint-disable-next-line @typescript-eslint/no-deprecated
-		this.sentry?.captureException(exception, eventHint) as any
+		this.sentry?.withScope((scope) => {
+			if (extras) scope.setExtras(extras)
+			// eslint-disable-next-line @typescript-eslint/no-deprecated
+			this.sentry?.captureException(exception) as any
+		})
 		if (!this.sentry) {
 			console.error(`[TLPostgresReplicator]: `, exception)
 		}
@@ -239,7 +242,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			},
 			() => {
 				// this is invoked if the subscription is closed unexpectedly
-				this.captureException(new Error('Subscription error'))
+				this.captureException(new Error('Subscription error (we can tolerate this)'))
 				this.reboot()
 			}
 		)
@@ -293,7 +296,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					this.handleUserEvent(row, event)
 					return
 				default:
-					this.captureException(new Error(`Unhandled table: ${event.relation.table}`))
+					this.captureException(new Error(`Unhandled table: ${event.relation.table}`), {
+						event,
+						row,
+					})
 					return
 			}
 		} catch (e) {

commit 7f52c1464bc4852837a8bccb1f4ad70117db32c9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Jan 17 11:02:11 2025 +0000

    worker debug logging (#5219)
    
    This PR begins to address some pains we've felt with regard to logging
    on cloudflare workers:
    
    1. a console.log invocation is only flushed to the console (or cf
    dashboard) once a request completes. so if a request hangs for some
    reason you never see the log output.
    2. logs are very eagerly sampled, which makes it hard to rely on them
    for debugging because you never know whether a log statement wasn't
    reached or whether it was just dropped.
    
    so this PR
    
    - adds a Logger durable object that you can connect to via a websocket
    to get an instant stream of every log statement, no waiting for requests
    to finish.
    - wraps the Logger durable object with a Logger class to consolidate
    code.
    
    The logger durable object is on in dev and preview envs, but is not
    available in staging or production yet because that would require auth
    and filtering user DO events by user.
    
    You can try it on this PR by going to
    https://pr-5219-preview-deploy.tldraw.com/__debug-tail and then opening
    the app in another tab
    
    also tackles
    https://linear.app/tldraw/issue/INT-648/investigate-flaky-preview-deploys
    somewhat
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index d49f96f21..37f21d3c1 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,4 +1,4 @@
-import { ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
+import { DB, ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
 import {
 	ExecutionQueue,
 	assert,
@@ -9,10 +9,12 @@ import {
 } from '@tldraw/utils'
 import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
+import { Kysely, sql } from 'kysely'
 import postgres from 'postgres'
+import { Logger } from './Logger'
 import type { TLDrawDurableObject } from './TLDrawDurableObject'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
-import { createPostgresConnection } from './postgres'
+import { createPostgresConnection, createPostgresConnectionPool } from './postgres'
 import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
 import { getUserDurableObject } from './utils/durableObjects'
@@ -82,6 +84,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 	private measure: Analytics | undefined
 	private postgresUpdates = 0
+	private lastPostgresMessageTime = Date.now()
 	private lastRpmLogTime = Date.now()
 
 	// we need to guarantee in-order delivery of messages to users
@@ -103,6 +106,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	private log
+
+	private readonly db: Kysely<DB>
 	constructor(ctx: DurableObjectState, env: Environment) {
 		super(ctx, env)
 		this.sentry = createSentry(ctx, env)
@@ -115,8 +121,15 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			})
 		)
 
-		this.reboot(false)
+		// debug logging in preview envs by default
+		this.log = new Logger(env, 'TLPostgresReplicator', this.sentry)
+		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator')
+
 		this.alarm()
+		this.reboot(false).catch((e) => {
+			this.captureException(e)
+			this.__test__panic()
+		})
 		this.measure = env.MEASURE
 	}
 
@@ -161,19 +174,20 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		this.ctx.abort()
 	}
 
-	private debug(...args: any[]) {
-		// uncomment for dev time debugging
-		// console.log('[TLPostgresReplicator]:', ...args)
-		if (this.sentry) {
-			// eslint-disable-next-line @typescript-eslint/no-deprecated
-			this.sentry.addBreadcrumb({
-				message: `[TLPostgresReplicator]: ${args.join(' ')}`,
-			})
-		}
-	}
 	override async alarm() {
 		this.ctx.storage.setAlarm(Date.now() + 1000)
 		this.maybeLogRpm()
+		// If we haven't heard anything from postgres for 5 seconds, do a little transaction
+		// to update a random string as a kind of 'ping' to keep the connection alive
+		// If we haven't heard anything for 10 seconds, reboot
+		if (Date.now() - this.lastPostgresMessageTime > 10000) {
+			this.log.debug('rebooting due to inactivity')
+			this.reboot()
+		} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
+			sql`insert into replicator_boot_id ("replicatorId", "bootId") values (${this.ctx.id.toString()}, ${uniqueId()}) on conflict ("replicatorId") do update set "bootId" = excluded."bootId"`.execute(
+				this.db
+			)
+		}
 	}
 
 	private maybeLogRpm() {
@@ -192,13 +206,13 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private async reboot(delay = true) {
 		this.logEvent({ type: 'reboot' })
-		this.debug('reboot push')
+		this.log.debug('reboot push')
 		await this.queue.push(async () => {
 			if (delay) {
 				await sleep(1000)
 			}
 			const start = Date.now()
-			this.debug('rebooting')
+			this.log.debug('rebooting')
 			const res = await Promise.race([
 				this.boot().then(() => 'ok'),
 				sleep(3000).then(() => 'timeout'),
@@ -207,7 +221,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				this.captureException(e)
 				return 'error'
 			})
-			this.debug('rebooted', res)
+			this.log.debug('rebooted', res)
 			if (res === 'ok') {
 				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })
 			} else {
@@ -217,7 +231,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private async boot() {
-		this.debug('booting')
+		this.log.debug('booting')
+		this.lastPostgresMessageTime = Date.now()
 		// clean up old resources if necessary
 		if (this.state.type === 'connected') {
 			this.state.subscription.unsubscribe()
@@ -275,8 +290,13 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+		this.lastPostgresMessageTime = Date.now()
+		if (event.relation.table === 'replicator_boot_id') {
+			// ping, ignore
+			return
+		}
 		this.postgresUpdates++
-		this.debug('handleEvent', event)
+		this.log.debug('handleEvent', event)
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
 		try {
 			switch (event.relation.table) {
@@ -380,7 +400,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				.toArray()[0]
 			if (!sub) {
 				// the file was deleted before the file state
-				this.debug('file state deleted before file', row)
+				this.log.debug('file state deleted before file', row)
 			} else {
 				this.sql.exec(
 					`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
@@ -441,7 +461,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private handleUserEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		assert(row?.id, 'user id is required')
-		this.debug('USER EVENT', event.command, row.id)
+		this.log.debug('USER EVENT', event.command, row.id)
 		this.messageUser(row.id, {
 			type: 'row_update',
 			row: row as any,
@@ -456,7 +476,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	async ping() {
-		this.debug('ping')
+		this.log.debug('ping')
 		return { sequenceId: this.state.sequenceId }
 	}
 
@@ -505,7 +525,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
 				})
 				if (res === 'unregister') {
-					this.debug('unregistering user', userId, event)
+					this.log.debug('unregistering user', userId, event)
 					this.unregisterUser(userId)
 				}
 			})
@@ -520,9 +540,11 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	async registerUser(userId: string) {
-		this.debug('registering user', userId)
+		this.log.debug('registering user', userId)
 		this.logEvent({ type: 'register_user' })
+		this.log.debug('reg user wait')
 		await this.waitUntilConnected()
+		this.log.debug('reg user connect')
 		assert(this.state.type === 'connected', 'state should be connected in registerUser')
 		const guestFiles = await this.state
 			.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`

commit 5c4b0489690d5cc4fe1f444c015b9d0fba51f0e8
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Jan 22 14:05:00 2025 +0100

    Asset uploads (#5218)
    
    Changes:
    * We now use the main sync worker for tldraw app asset uploads. For old
    assets we still continue to use the assets worker.
    * Image resize worker is now deployed as part of our deploy dotcom
    action. It receives the multiplayer worker url. If the asset origin is
    same as the multiplayer url (we are fetching tldraw app asset) it uses a
    service binding to request the asset. This is to avoid some permissions
    issues we encountered when the image worker fetched directly from the
    multiplayer worker. The fetching for existing assets should remain the
    same. I added `IMAGE_WORKER` env variable to different environments for
    our github actions.
    * We now associate assets with files. We do this in two ways: 1. when
    users upload the files we immediately add the `fileId` to the asset's
    `meta` property. We then also write an entry into a new postgres table
    called `asset`. 2. in some cases we do this server side (duplicating a
    room, copy pasting tldraw content, slurping legacy multiplayer rooms).
    The way it works is that the server checks all the tldraw app assets and
    makes sure their meta is associated to the correct file. If it is not it
    re-uploads the file to the uploads bucket and it updates the asset. It
    does this when persisting a file and also on restore.
    * There are some public API changes listed that were necessary to make
    this work. They are listed below.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    **Breaking change**
    
    - `@tldraw/tlschema`: `TLAssetStore.upload` used to return just the
    `src` of the uploaded asset. It now returns `{src: string, meta?:
    JsonObject}`. The returned metadata will be added to the asset record
    and thus allows the users to add some additional data to them when
    uploading.
    - `@tldraw/editor`: `Editor.uploadAsset` used to return
    `Promise<string>` and now returns `Promise<{ src: string; meta?:
    JsonObject }> `

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 37f21d3c1..beb52efd7 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -315,6 +315,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				case 'user':
 					this.handleUserEvent(row, event)
 					return
+				case 'asset':
+					// we don't synchronize asset information
+					return
 				default:
 					this.captureException(new Error(`Unhandled table: ${event.relation.table}`), {
 						event,

commit 5d3e4a1d9cd3f05e165c7c4e02c420272387fb44
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Jan 23 16:02:45 2025 +0100

    Fix sentry error (#5269)
    
    Should prevent errors like
    [these](https://tldraw.sentry.io/issues/6223002746/?environment=staging-tldraw-multiplayer&project=4503966963662848&query=is%3Aunresolved%20issue.priority%3A%5Bhigh%2C%20medium%5D&referrer=issue-stream&statsPeriod=7d&stream_index=2)
    in the future.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index beb52efd7..ebceed9ce 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -315,8 +315,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				case 'user':
 					this.handleUserEvent(row, event)
 					return
+				// We don't synchronize events for these tables
 				case 'asset':
-					// we don't synchronize asset information
+				case 'applied_migrations':
 					return
 				default:
 					this.captureException(new Error(`Unhandled table: ${event.relation.table}`), {

commit ab782583b3ba03a5746828428a16d3ba7e05e5a9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Jan 28 18:36:09 2025 +0000

    post release backend error handling (#5306)
    
    we were getting a lot of these errors in sentry
    https://tldraw.sentry.io/issues/6152025342/?environment=production&environment=production-tldraw-multiplayer&project=4503966963662848&query=is%3Aunresolved%20issue.priority%3A%5Bhigh%2C%20medium%5D&referrer=issue-stream&statsPeriod=14d&stream_index=1
    which seemed to mostly the registerUser failing ?
    
    But I couldn't figure out why, so I fixed the error reporting for that
    method, and added a bunch of debugs to add breadcrumb context on sentry.
    
    At the same time, I added a bunch of extra fail-safes to restart things
    if the user durable objects are failing to connect to the replicator.
    hopefully that will mitigate whatever is going on. this was causing the
    durable object's in-memory cache to get stale and make it look like the
    db writes were failing when in fact they were not.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index ebceed9ce..843eb463d 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -544,34 +544,43 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	async registerUser(userId: string) {
-		this.log.debug('registering user', userId)
-		this.logEvent({ type: 'register_user' })
-		this.log.debug('reg user wait')
-		await this.waitUntilConnected()
-		this.log.debug('reg user connect')
-		assert(this.state.type === 'connected', 'state should be connected in registerUser')
-		const guestFiles = await this.state
-			.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`
-
-		const sequenceIdSuffix = uniqueId()
-
-		// clear user and subscriptions
-		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
-		this.sql.exec(
-			`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix) VALUES (?, 0, ?)`,
-			userId,
-			sequenceIdSuffix
-		)
-		for (const file of guestFiles) {
+		try {
+			this.log.debug('registering user', userId)
+			this.logEvent({ type: 'register_user' })
+			this.log.debug('reg user wait')
+			await this.waitUntilConnected()
+			this.log.debug('reg user connect')
+			assert(this.state.type === 'connected', 'state should be connected in registerUser')
+			const guestFiles = await this.state
+				.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`
+			this.log.debug('got guest files')
+
+			const sequenceIdSuffix = uniqueId()
+
+			// clear user and subscriptions
+			this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+			this.log.debug('cleared active user')
 			this.sql.exec(
-				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
+				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix) VALUES (?, 0, ?)`,
 				userId,
-				file.id
+				sequenceIdSuffix
 			)
-		}
-		return {
-			sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
-			sequenceNumber: 0,
+			this.log.debug('inserted active user')
+			for (const file of guestFiles) {
+				this.sql.exec(
+					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
+					userId,
+					file.id
+				)
+			}
+			this.log.debug('inserted guest files', guestFiles.length)
+			return {
+				sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
+				sequenceNumber: 0,
+			}
+		} catch (e) {
+			this.captureException(e)
+			throw e
 		}
 	}
 

commit 86aae29d7f4a3bfb258730c51f051c8889e20e2c
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Feb 5 09:01:10 2025 +0100

    Move to server side slurping. (#5348)
    
    This moves duplication and legacy room slurping to the backend:
    * It removes the the file open mode logic (no more setting it when
    navigating, no more sending search params to the backend).
    * We now insert a file into the db with an additional column called
    `createSource` which is in the form of `f/kZTr6Zdx6TClE6I4qExV4`. In
    this case this means duplication of an existing app file. For legacy
    files we'd similarly use `/r|ro|v|s/kZTr6Zdx6TClE6I4qExV4` to use that
    existing legacy file as a starting point.
    * Room DO then sees this column and reads the data from the appropriate
    source and initializes the room.
    * We now retry getting the file record from the db, because otherwise we
    could still end up with a "Not found" issue since the navigation might
    happen before the replicator tells the room DO about the file creation.
    * Assets will get re-uploaded with our existing
    `maybeAssociateFileAssets` logic, that makes sure all the assets are
    associated with the file.
    
    We had to do this because in some cases the file got created in the db,
    then an file update was dispatched to the replicator (due to the trigger
    we have on the file table), which incorrectly the set room DO (its
    document info was set to a non app file without the creation params). If
    this happened before the user navigation hit the worker it would mean
    that duplication as well as slurping legacy files end up in a "Not
    found" error, even though the file was correctly inserted into the db.
    
    ### Change type
    - [x] `improvement`
    
    ### Release notes
    
    - Move duplicating and legacy file slurping to the server.

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 843eb463d..18ce9c4ac 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,4 +1,4 @@
-import { DB, ROOM_PREFIX, TlaFile, ZTable } from '@tldraw/dotcom-shared'
+import { DB, TlaFile, ZTable } from '@tldraw/dotcom-shared'
 import {
 	ExecutionQueue,
 	assert,
@@ -12,12 +12,11 @@ import { DurableObject } from 'cloudflare:workers'
 import { Kysely, sql } from 'kysely'
 import postgres from 'postgres'
 import { Logger } from './Logger'
-import type { TLDrawDurableObject } from './TLDrawDurableObject'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnection, createPostgresConnectionPool } from './postgres'
 import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
-import { getUserDurableObject } from './utils/durableObjects'
+import { getRoomDurableObject, getUserDurableObject } from './utils/durableObjects'
 
 interface Migration {
 	id: string
@@ -441,16 +440,17 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			.map((x) => x.userId as string)
 		// if the file state was deleted before the file, we might not have any impacted users
 		if (event.command === 'delete') {
-			this.getStubForFile(row.id).appFileRecordDidDelete()
+			getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
 			this.sql.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
 		} else if (event.command === 'update') {
 			assert(row.ownerId, 'ownerId is required when updating file')
-			this.getStubForFile(row.id).appFileRecordDidUpdate(row as TlaFile)
+			getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
 		} else if (event.command === 'insert') {
 			assert(row.ownerId, 'ownerId is required when inserting file')
 			if (!impactedUserIds.includes(row.ownerId)) {
 				impactedUserIds.push(row.ownerId)
 			}
+			getRoomDurableObject(this.env, row.id).appFileRecordCreated(row as TlaFile)
 		}
 		for (const userId of impactedUserIds) {
 			this.messageUser(userId, {
@@ -538,11 +538,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	private getStubForFile(fileId: string) {
-		const id = this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${fileId}`)
-		return this.env.TLDR_DOC.get(id) as any as TLDrawDurableObject
-	}
-
 	async registerUser(userId: string) {
 		try {
 			this.log.debug('registering user', userId)

commit be65d368fd8b3aaa31b3d6a41b3f563f3312b379
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Feb 7 14:00:14 2025 +0100

    Track user do cold start time on server side replicator (#5380)
    
    Add some additional tracking (active users in replicator and cold start
    time to used do). Added some additional panes to grafana, here's [the
    view](https://tldraw.grafana.net/d/adgumkhou3chsd/events?orgId=1&from=now-12h&to=now&timezone=browser&var-environment=pr-5380)
    for this pr.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    - Add some additional tracking (active users in replicator and cold
    start time to used do).

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 18ce9c4ac..886c32fea 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -274,6 +274,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		// re-register all active users to get their latest guest info
 		// do this in small batches to avoid overwhelming the system
 		const users = this.sql.exec('SELECT id FROM active_user').toArray()
+		this.reportActiveUsers()
 		const sequenceId = this.state.sequenceId
 		const BATCH_SIZE = 5
 		const tick = () => {
@@ -538,6 +539,15 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	reportActiveUsers() {
+		try {
+			const { count } = this.sql.exec('SELECT COUNT(*) as count FROM active_user').one()
+			this.logEvent({ type: 'active_users', count: count as number })
+		} catch (e) {
+			console.error('Error in reportActiveUsers', e)
+		}
+	}
+
 	async registerUser(userId: string) {
 		try {
 			this.log.debug('registering user', userId)
@@ -560,6 +570,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				userId,
 				sequenceIdSuffix
 			)
+			this.reportActiveUsers()
 			this.log.debug('inserted active user')
 			for (const file of guestFiles) {
 				this.sql.exec(
@@ -582,6 +593,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	async unregisterUser(userId: string) {
 		this.logEvent({ type: 'unregister_user' })
 		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+		this.reportActiveUsers()
 		const queue = this.userDispatchQueues.get(userId)
 		if (queue) {
 			queue.close()
@@ -617,6 +629,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					doubles: [event.rpm],
 				})
 				break
+			case 'active_users':
+				this.writeEvent({
+					blobs: [event.type],
+					doubles: [event.count],
+				})
+				break
 			default:
 				exhaustiveSwitchError(event)
 		}

commit 8792d999aa74842b2d392833662bea5be77988e8
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Feb 7 14:46:50 2025 +0000

    Improve published file experience (#5371)
    
    This is by no means a perfect solution, but it's a lot better than the
    current situation for logged in users, which is bad mainly because it
    shows the sidebar. Showing the sidebar for published files:
    
    - fails to give the file owner a sense of how other people will see the
    published version
    - prevents the viewer from really _feeling_ how published files are
    different
    - puts the sidebar in a confusing navigational state where nothing is
    selected
    
    With this PR
    
    1. Logged in users see the 'anonymous' view (no sidebar) but with a
    share button instead of the sign in button.
    2. Logged in users also get a 'copy to my files' affordance in the three
    dots menu.
    3. We replace the 'Save a copy' menu item (which opens the file picker)
    with a 'Download file' menu item (which downloads straight to the
    downloads folder).
    4. Clicking the tldraw logo takes you back to the main app view
    
    I think there's still a lot of room for improvement here, but this feels
    like a quick win to land ahead of launch
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 886c32fea..e91703731 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -505,6 +505,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private async messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
+		if (!this.userIsActive(userId)) return
 		try {
 			let q = this.userDispatchQueues.get(userId)
 			if (!q) {

commit 9ff4b63deedfc0d5b81d7acaaec4482a1c5e54ca
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Wed Feb 12 12:51:31 2025 +0100

    Fix replicator event tracking. (#5415)
    
    We need to set this first. Otherwise any events that come before it
    would not be tracked. We probably missed reboots because of this - we
    called `this.reboot` before setting the measure.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Fix replicator event tracking.

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index e91703731..5c22e5b95 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -110,6 +110,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private readonly db: Kysely<DB>
 	constructor(ctx: DurableObjectState, env: Environment) {
 		super(ctx, env)
+		this.measure = env.MEASURE
 		this.sentry = createSentry(ctx, env)
 		this.sql = this.ctx.storage.sql
 
@@ -129,7 +130,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			this.captureException(e)
 			this.__test__panic()
 		})
-		this.measure = env.MEASURE
 	}
 
 	private _applyMigration(index: number) {

commit 88e8ddb29f5df7daf7286114a4f814c742851b00
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Feb 13 10:08:06 2025 +0100

    Add additional reboot info. (#5416)
    
    Also track the source of the reboot.
    
    ### Change type
    - [x] `improvement`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 5c22e5b95..9897d0e9f 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -14,7 +14,12 @@ import postgres from 'postgres'
 import { Logger } from './Logger'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnection, createPostgresConnectionPool } from './postgres'
-import { Analytics, Environment, TLPostgresReplicatorEvent } from './types'
+import {
+	Analytics,
+	Environment,
+	TLPostgresReplicatorEvent,
+	TLPostgresReplicatorRebootSource,
+} from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
 import { getRoomDurableObject, getUserDurableObject } from './utils/durableObjects'
 
@@ -126,7 +131,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator')
 
 		this.alarm()
-		this.reboot(false).catch((e) => {
+		this.reboot('constructor', false).catch((e) => {
 			this.captureException(e)
 			this.__test__panic()
 		})
@@ -167,7 +172,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	__test__forceReboot() {
-		this.reboot()
+		this.reboot('test')
 	}
 	__test__panic() {
 		this.ctx.abort()
@@ -181,7 +186,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		// If we haven't heard anything for 10 seconds, reboot
 		if (Date.now() - this.lastPostgresMessageTime > 10000) {
 			this.log.debug('rebooting due to inactivity')
-			this.reboot()
+			this.reboot('inactivity')
 		} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
 			sql`insert into replicator_boot_id ("replicatorId", "bootId") values (${this.ctx.id.toString()}, ${uniqueId()}) on conflict ("replicatorId") do update set "bootId" = excluded."bootId"`.execute(
 				this.db
@@ -203,8 +208,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private queue = new ExecutionQueue()
 
-	private async reboot(delay = true) {
-		this.logEvent({ type: 'reboot' })
+	private async reboot(source: TLPostgresReplicatorRebootSource, delay = true) {
+		this.logEvent({ type: 'reboot', source })
 		this.log.debug('reboot push')
 		await this.queue.push(async () => {
 			if (delay) {
@@ -224,7 +229,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			if (res === 'ok') {
 				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })
 			} else {
-				this.reboot()
+				this.reboot('retry')
 			}
 		})
 	}
@@ -257,7 +262,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			() => {
 				// this is invoked if the subscription is closed unexpectedly
 				this.captureException(new Error('Subscription error (we can tolerate this)'))
-				this.reboot()
+				this.reboot('subscription_closed')
 			}
 		)
 
@@ -609,6 +614,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	logEvent(event: TLPostgresReplicatorEvent) {
 		switch (event.type) {
 			case 'reboot':
+				this.writeEvent({ blobs: [event.type, event.source] })
+				break
 			case 'reboot_error':
 			case 'register_user':
 			case 'unregister_user':

commit 115ffe542ddaeaba457b022203d3d4180b842d2d
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Feb 13 13:25:03 2025 +0100

    Actively prune users. (#5425)
    
    Track the time that users received their last updates then periodically
    prune them.
    
    Resolves INT-748
    
    ### Change type
    
    - [x] `improvement`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 9897d0e9f..8e647a941 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -54,9 +54,16 @@ const migrations: Migration[] = [
 			ALTER TABLE active_user ADD COLUMN sequenceIdSuffix TEXT NOT NULL DEFAULT '';
 		`,
 	},
+	{
+		id: '002_add_last_updated_at',
+		code: `
+			ALTER TABLE active_user ADD COLUMN lastUpdatedAt INTEGER NOT NULL DEFAULT 0;
+		`,
+	},
 ]
 
 const ONE_MINUTE = 60 * 1000
+const PRUNE_TIME = ONE_MINUTE
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
@@ -90,6 +97,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private postgresUpdates = 0
 	private lastPostgresMessageTime = Date.now()
 	private lastRpmLogTime = Date.now()
+	private lastUserPruneTime = Date.now()
 
 	// we need to guarantee in-order delivery of messages to users
 	// but DO RPC calls are not guaranteed to happen in order, so we need to
@@ -192,6 +200,24 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				this.db
 			)
 		}
+		this.maybePruneUsers()
+	}
+
+	private async maybePruneUsers() {
+		const now = Date.now()
+		if (now - this.lastUserPruneTime < PRUNE_TIME) return
+		const cutoffTime = now - PRUNE_TIME
+		const usersWithoutRecentUpdates = this.ctx.storage.sql
+			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)
+			.toArray() as {
+			id: string
+		}[]
+		for (const { id } of usersWithoutRecentUpdates) {
+			if (await getUserDurableObject(this.env, id).notActive()) {
+				await this.unregisterUser(id)
+			}
+		}
+		this.lastUserPruneTime = Date.now()
 	}
 
 	private maybeLogRpm() {
@@ -520,7 +546,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			await q.push(async () => {
 				const { sequenceNumber, sequenceIdSuffix } = this.sql
 					.exec(
-						'UPDATE active_user SET sequenceNumber = sequenceNumber + 1 WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
+						'UPDATE active_user SET sequenceNumber = sequenceNumber + 1, lastUpdatedAt = ? WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
+						Date.now(),
 						userId
 					)
 					.one()
@@ -572,9 +599,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 			this.log.debug('cleared active user')
 			this.sql.exec(
-				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix) VALUES (?, 0, ?)`,
+				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix, lastUpdatedAt) VALUES (?, 0, ?, ?)`,
 				userId,
-				sequenceIdSuffix
+				sequenceIdSuffix,
+				Date.now()
 			)
 			this.reportActiveUsers()
 			this.log.debug('inserted active user')

commit 62899bc86ee5faf9850691181520464b864ecbb2
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Feb 13 14:57:40 2025 +0000

    Replace postgres.js pt 1 (#5430)
    
    This replaces all the usages of postgres.js for normal
    (non-subscription) queries with Kysely.
    
    The next PR will be replacing the postgres.js subscription with
    [pg-logcial-replication](https://github.com/kibae/pg-logical-replication)
    and using a persistent replication slot to avoid the need to reboot user
    DOs whenever there is connection flake.
    
    Then after that we can look at
    
    - keeping a buffer of previous replication events so if a user DO misses
    a message or two it can request a catch-up rather than having to reboot.
    - look at doing persistence in the user DOs and requesting catchups when
    starting up so during deploys we can avoid triggering a reboot on every
    active user DO.
    
    And after that, new socket connections should be able to serve
    relatively up-to-date data immediately and we should have our immediate
    perf problems solved for a while.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 8e647a941..f4ba6e5b2 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -13,7 +13,7 @@ import { Kysely, sql } from 'kysely'
 import postgres from 'postgres'
 import { Logger } from './Logger'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
-import { createPostgresConnection, createPostgresConnectionPool } from './postgres'
+import { createPostgresConnectionPool } from './postgres'
 import {
 	Analytics,
 	Environment,
@@ -75,19 +75,19 @@ type BootState =
 	  }
 	| {
 			type: 'connecting'
-			db: postgres.Sql
+			directDb: postgres.Sql
 			sequenceId: string
 			promise: PromiseWithResolve
 	  }
 	| {
 			type: 'connected'
-			db: postgres.Sql
+			directDb: postgres.Sql
 			sequenceId: string
 			subscription: postgres.SubscriptionHandle
 	  }
 
 export class TLPostgresReplicator extends DurableObject<Environment> {
-	private sql: SqlStorage
+	private sqlite: SqlStorage
 	private state: BootState = {
 		type: 'init',
 		promise: promiseWithResolve(),
@@ -125,7 +125,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		super(ctx, env)
 		this.measure = env.MEASURE
 		this.sentry = createSentry(ctx, env)
-		this.sql = this.ctx.storage.sql
+		this.sqlite = this.ctx.storage.sql
 
 		this.ctx.blockConcurrencyWhile(async () =>
 			this._migrate().catch((e) => {
@@ -136,7 +136,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 		// debug logging in preview envs by default
 		this.log = new Logger(env, 'TLPostgresReplicator', this.sentry)
-		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator')
+		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator', 100)
 
 		this.alarm()
 		this.reboot('constructor', false).catch((e) => {
@@ -146,8 +146,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private _applyMigration(index: number) {
-		this.sql.exec(migrations[index].code)
-		this.sql.exec(
+		this.sqlite.exec(migrations[index].code)
+		this.sqlite.exec(
 			'insert into migrations (id, code) values (?, ?)',
 			migrations[index].id,
 			migrations[index].code
@@ -157,7 +157,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private async _migrate() {
 		let appliedMigrations: Migration[]
 		try {
-			appliedMigrations = this.sql
+			appliedMigrations = this.sqlite
 				.exec('select code, id from migrations order by id asc')
 				.toArray() as any
 		} catch (_e) {
@@ -266,9 +266,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		// clean up old resources if necessary
 		if (this.state.type === 'connected') {
 			this.state.subscription.unsubscribe()
-			this.state.db.end().catch(this.captureException)
+			this.state.directDb.end().catch(this.captureException)
 		} else if (this.state.type === 'connecting') {
-			this.state.db.end().catch(this.captureException)
+			this.state.directDb.end().catch(this.captureException)
 		}
 		const promise = 'promise' in this.state ? this.state.promise : promiseWithResolve()
 		this.state = {
@@ -276,10 +276,23 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
 			promise,
-			db: createPostgresConnection(this.env, { name: 'TLPostgresReplicator' }),
+			directDb: postgres(this.env.BOTCOM_POSTGRES_CONNECTION_STRING, {
+				types: {
+					bigint: {
+						from: [20], // PostgreSQL OID for BIGINT
+						parse: (value: string) => Number(value), // Convert string to number
+						to: 20,
+						serialize: (value: number) => String(value), // Convert number to string
+					},
+				},
+				idle_timeout: 30,
+				connection: {
+					application_name: 'TLPostgresReplicator',
+				},
+			}),
 			sequenceId: uniqueId(),
 		}
-		const subscription = await this.state.db.subscribe(
+		const subscription = await this.state.directDb.subscribe(
 			'*',
 			this.handleEvent.bind(this),
 			() => {
@@ -296,7 +309,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			type: 'connected',
 			subscription,
 			sequenceId: this.state.sequenceId,
-			db: this.state.db,
+			directDb: this.state.directDb,
 		}
 		promise.resolve(null)
 	}
@@ -304,7 +317,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private onDidBoot() {
 		// re-register all active users to get their latest guest info
 		// do this in small batches to avoid overwhelming the system
-		const users = this.sql.exec('SELECT id FROM active_user').toArray()
+		const users = this.sqlite.exec('SELECT id FROM active_user').toArray()
 		this.reportActiveUsers()
 		const sequenceId = this.state.sequenceId
 		const BATCH_SIZE = 5
@@ -389,7 +402,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		assert(row?.userId, 'userId is required')
 		if (!this.userIsActive(row.userId)) return
 		if (event.command === 'insert') {
-			this.sql.exec(
+			this.sqlite.exec(
 				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?)`,
 				row.userId,
 				row.fileId
@@ -404,7 +417,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					// check that we didn't reboot (in which case the user do will fetch the file record on its own)
 					if (this.state.sequenceId !== sequenceId) return
 					// check that the subscription wasn't deleted before we managed to fetch the file record
-					const sub = this.sql
+					const sub = this.sqlite
 						.exec(
 							`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
 							row.userId,
@@ -426,7 +439,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		} else if (event.command === 'delete') {
 			// If the file state being deleted does not belong to the file owner,
 			// we need to send a delete event for the file to the user
-			const sub = this.sql
+			const sub = this.sqlite
 				.exec(
 					`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
 					row.userId,
@@ -437,7 +450,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				// the file was deleted before the file state
 				this.log.debug('file state deleted before file', row)
 			} else {
-				this.sql.exec(
+				this.sqlite.exec(
 					`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
 					row.userId,
 					row.fileId
@@ -466,14 +479,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private handleFileEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		assert(row?.id, 'row id is required')
-		const impactedUserIds = this.sql
+		const impactedUserIds = this.sqlite
 			.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)
 			.toArray()
 			.map((x) => x.userId as string)
 		// if the file state was deleted before the file, we might not have any impacted users
 		if (event.command === 'delete') {
 			getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
-			this.sql.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
+			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
 		} else if (event.command === 'update') {
 			assert(row.ownerId, 'ownerId is required when updating file')
 			getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
@@ -508,7 +521,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private userIsActive(userId: string) {
-		return this.sql.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0
+		return this.sqlite.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0
 	}
 
 	async ping() {
@@ -527,9 +540,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		await this.waitUntilConnected()
 		assert(this.state.type === 'connected', 'state should be connected in getFileRecord')
 		try {
-			const res = await this.state.db`select * from public.file where id = ${fileId}`
-			if (res.length === 0) return null
-			return res[0] as TlaFile
+			const res = await sql`select * from public.file where id = ${fileId}`.execute(this.db)
+			if (res.rows.length === 0) return null
+			return res.rows[0] as TlaFile
 		} catch (_e) {
 			return null
 		}
@@ -544,7 +557,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				this.userDispatchQueues.set(userId, q)
 			}
 			await q.push(async () => {
-				const { sequenceNumber, sequenceIdSuffix } = this.sql
+				const { sequenceNumber, sequenceIdSuffix } = this.sqlite
 					.exec(
 						'UPDATE active_user SET sequenceNumber = sequenceNumber + 1, lastUpdatedAt = ? WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
 						Date.now(),
@@ -574,7 +587,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	reportActiveUsers() {
 		try {
-			const { count } = this.sql.exec('SELECT COUNT(*) as count FROM active_user').one()
+			const { count } = this.sqlite.exec('SELECT COUNT(*) as count FROM active_user').one()
 			this.logEvent({ type: 'active_users', count: count as number })
 		} catch (e) {
 			console.error('Error in reportActiveUsers', e)
@@ -589,16 +602,16 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			await this.waitUntilConnected()
 			this.log.debug('reg user connect')
 			assert(this.state.type === 'connected', 'state should be connected in registerUser')
-			const guestFiles = await this.state
-				.db`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`
+			const guestFiles = await sql<{
+				id: string
+			}>`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`.execute(this.db)
 			this.log.debug('got guest files')
 
 			const sequenceIdSuffix = uniqueId()
 
 			// clear user and subscriptions
-			this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
-			this.log.debug('cleared active user')
-			this.sql.exec(
+			this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+			this.sqlite.exec(
 				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix, lastUpdatedAt) VALUES (?, 0, ?, ?)`,
 				userId,
 				sequenceIdSuffix,
@@ -606,14 +619,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			)
 			this.reportActiveUsers()
 			this.log.debug('inserted active user')
-			for (const file of guestFiles) {
-				this.sql.exec(
+			for (const file of guestFiles.rows) {
+				this.sqlite.exec(
 					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
 					userId,
 					file.id
 				)
 			}
-			this.log.debug('inserted guest files', guestFiles.length)
+			this.log.debug('inserted guest files', guestFiles.rows.length)
 			return {
 				sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
 				sequenceNumber: 0,
@@ -626,7 +639,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	async unregisterUser(userId: string) {
 		this.logEvent({ type: 'unregister_user' })
-		this.sql.exec(`DELETE FROM active_user WHERE id = ?`, userId)
+		this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 		this.reportActiveUsers()
 		const queue = this.userDispatchQueues.get(userId)
 		if (queue) {

commit b5cf4f2757d13574803485c6c7469a3e5b1afee8
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Feb 17 17:23:46 2025 +0100

    Add dotcom checks that will serve for alerting (#5440)
    
    Collect some basic stats which can be used for alerting purposes.
    
    I investigated using checkly for some browser tests but decided against
    it. The main is is that it's not trivial to login from test automations
    like playwright. Even if you set the username / password for Oauth, you
    might get hit by captcha / automation detection. Two ways to get around
    that would be:
    * Allowing sign in via username + password combo.
    * Using some sort of email throwaway / burner service, which would allow
    api access to get the sign in codes.
    
    This will use our existing updown.io health checks, but will extend them
    with some basic app specific health checks. One downside of this is that
    we use CF for collecting these checks, so we might report DB / Clerk
    being down, when it's in fact CF that is down. That said I don't think
    that's a big problem since if CF is down our app is down for sure.
    
    I have added checks to updown.io, will enable them once this lands in
    prod.
    
    ### Change type
    
    - [x] `improvement`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index f4ba6e5b2..ce6d3311b 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -5,6 +5,7 @@ import {
 	exhaustiveSwitchError,
 	promiseWithResolve,
 	sleep,
+	throttle,
 	uniqueId,
 } from '@tldraw/utils'
 import { createSentry } from '@tldraw/worker-shared'
@@ -21,7 +22,11 @@ import {
 	TLPostgresReplicatorRebootSource,
 } from './types'
 import { EventData, writeDataPoint } from './utils/analytics'
-import { getRoomDurableObject, getUserDurableObject } from './utils/durableObjects'
+import {
+	getRoomDurableObject,
+	getStatsDurableObjct,
+	getUserDurableObject,
+} from './utils/durableObjects'
 
 interface Migration {
 	id: string
@@ -255,6 +260,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			if (res === 'ok') {
 				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })
 			} else {
+				getStatsDurableObjct(this.env).recordReplicatorBootRetry()
 				this.reboot('retry')
 			}
 		})
@@ -333,8 +339,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		tick()
 	}
 
+	private reportPostgresUpdate = throttle(
+		() => getStatsDurableObjct(this.env).recordReplicatorPostgresUpdate(),
+		5000
+	)
+
 	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
 		this.lastPostgresMessageTime = Date.now()
+		this.reportPostgresUpdate()
 		if (event.relation.table === 'replicator_boot_id') {
 			// ping, ignore
 			return

commit 7507686e603e17f3b81d986adbd28c78dc3a3626
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Wed Feb 19 14:57:40 2025 +0000

    switch to pg-logical-replication (#5433)
    
    follow up to #5430
    
    This PR swaps out our postgres.js subscription with
    pg-logical-replication, which allows us to use a persistent replication
    slot. This in turn means that when the postgres connection breaks we can
    reliably restart the replication slot from where we picked off with
    guaranteed consistency, and therefore we won't need to force our user
    durable objects to reboot.
    
    In the next PR I will make it so that the replicator keeps a log of
    events so user DOs can resume via catch-up instead of doing a full
    reboot.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index ce6d3311b..4095e2e24 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,4 +1,4 @@
-import { DB, TlaFile, ZTable } from '@tldraw/dotcom-shared'
+import { DB, TlaFile, TlaRow, ZTable } from '@tldraw/dotcom-shared'
 import {
 	ExecutionQueue,
 	assert,
@@ -11,7 +11,8 @@ import {
 import { createSentry } from '@tldraw/worker-shared'
 import { DurableObject } from 'cloudflare:workers'
 import { Kysely, sql } from 'kysely'
-import postgres from 'postgres'
+
+import { LogicalReplicationService, Wal2Json, Wal2JsonPlugin } from 'pg-logical-replication'
 import { Logger } from './Logger'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnectionPool } from './postgres'
@@ -28,6 +29,11 @@ import {
 	getUserDurableObject,
 } from './utils/durableObjects'
 
+interface ReplicationEvent {
+	command: 'insert' | 'update' | 'delete'
+	table: keyof DB | 'replicator_boot_id' | 'user_boot_id' | 'user_mutation_number'
+}
+
 interface Migration {
 	id: string
 	code: string
@@ -65,6 +71,19 @@ const migrations: Migration[] = [
 			ALTER TABLE active_user ADD COLUMN lastUpdatedAt INTEGER NOT NULL DEFAULT 0;
 		`,
 	},
+	{
+		id: '003_add_lsn_tracking',
+		code: `
+			CREATE TABLE IF NOT EXISTS meta (
+				lsn TEXT PRIMARY KEY,
+				slotName TEXT NOT NULL
+			);
+			-- The slot name references the replication slot in postgres.
+			-- If something ever gets messed up beyond mortal comprehension and we need to force all
+			-- clients to reboot, we can just change the slot name by altering the slotNamePrefix in the constructor.
+			INSERT INTO meta (lsn, slotName) VALUES ('0/0', 'init');
+		`,
+	},
 ]
 
 const ONE_MINUTE = 60 * 1000
@@ -72,32 +91,33 @@ const PRUNE_TIME = ONE_MINUTE
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
+type Row =
+	| TlaRow
+	| {
+			bootId: string
+			userId: string
+	  }
+	| {
+			mutationNumber: number
+			userId: string
+	  }
+
 type BootState =
 	| {
 			type: 'init'
 			promise: PromiseWithResolve
-			sequenceId: string
 	  }
 	| {
 			type: 'connecting'
-			directDb: postgres.Sql
-			sequenceId: string
 			promise: PromiseWithResolve
 	  }
 	| {
 			type: 'connected'
-			directDb: postgres.Sql
-			sequenceId: string
-			subscription: postgres.SubscriptionHandle
 	  }
 
 export class TLPostgresReplicator extends DurableObject<Environment> {
 	private sqlite: SqlStorage
-	private state: BootState = {
-		type: 'init',
-		promise: promiseWithResolve(),
-		sequenceId: uniqueId(),
-	}
+	private state: BootState
 	private measure: Analytics | undefined
 	private postgresUpdates = 0
 	private lastPostgresMessageTime = Date.now()
@@ -125,29 +145,75 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private log
 
+	private readonly replicationService
+	private readonly slotName
+	private readonly wal2jsonPlugin = new Wal2JsonPlugin({})
+
 	private readonly db: Kysely<DB>
 	constructor(ctx: DurableObjectState, env: Environment) {
 		super(ctx, env)
 		this.measure = env.MEASURE
 		this.sentry = createSentry(ctx, env)
 		this.sqlite = this.ctx.storage.sql
+		this.state = {
+			type: 'init',
+			promise: promiseWithResolve(),
+		}
 
-		this.ctx.blockConcurrencyWhile(async () =>
-			this._migrate().catch((e) => {
-				this.captureException(e)
-				throw e
-			})
-		)
+		const slotNameMaxLength = 63 // max postgres identifier length
+		const slotNamePrefix = 'tlpr_' // pick something short so we can get more of the durable object id
+		const durableObjectId = this.ctx.id.toString()
+		this.slotName =
+			slotNamePrefix + durableObjectId.slice(0, slotNameMaxLength - slotNamePrefix.length)
 
-		// debug logging in preview envs by default
 		this.log = new Logger(env, 'TLPostgresReplicator', this.sentry)
 		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator', 100)
 
+		this.replicationService = new LogicalReplicationService(
+			/**
+			 * node-postgres Client options for connection
+			 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/pg/index.d.ts#L16
+			 */
+			{
+				database: 'postgres',
+				connectionString: env.BOTCOM_POSTGRES_CONNECTION_STRING,
+				application_name: this.slotName,
+			},
+			/**
+			 * Logical replication service config
+			 * https://github.com/kibae/pg-logical-replication/blob/main/src/logical-replication-service.ts#L9
+			 */
+			{
+				acknowledge: {
+					auto: false,
+					timeoutSeconds: 10,
+				},
+			}
+		)
+
 		this.alarm()
-		this.reboot('constructor', false).catch((e) => {
-			this.captureException(e)
-			this.__test__panic()
-		})
+		this.ctx
+			.blockConcurrencyWhile(async () => {
+				await this._migrate().catch((e) => {
+					this.captureException(e)
+					throw e
+				})
+				// if the slot name changed, we set the lsn to null, which will trigger a mass user DO reboot
+				if (this.sqlite.exec('select slotName from meta').one().slotName !== this.slotName) {
+					this.sqlite.exec('UPDATE meta SET slotName = ?, lsn = null', this.slotName)
+				}
+				await sql`SELECT pg_create_logical_replication_slot(${this.slotName}, 'wal2json') WHERE NOT EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = ${this.slotName})`.execute(
+					this.db
+				)
+			})
+			.then(() => {
+				this.reboot('constructor', false).catch((e) => {
+					this.captureException(e)
+					this.__test__panic()
+				})
+			})
+		// no need to catch since throwing in a blockConcurrencyWhile will trigger
+		// a DO reboot
 	}
 
 	private _applyMigration(index: number) {
@@ -184,26 +250,26 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	__test__forceReboot() {
+	async __test__forceReboot() {
 		this.reboot('test')
 	}
-	__test__panic() {
+
+	async __test__panic() {
 		this.ctx.abort()
 	}
 
 	override async alarm() {
-		this.ctx.storage.setAlarm(Date.now() + 1000)
+		this.ctx.storage.setAlarm(Date.now() + 3000)
 		this.maybeLogRpm()
-		// If we haven't heard anything from postgres for 5 seconds, do a little transaction
-		// to update a random string as a kind of 'ping' to keep the connection alive
-		// If we haven't heard anything for 10 seconds, reboot
+		// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.
+		// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.
 		if (Date.now() - this.lastPostgresMessageTime > 10000) {
 			this.log.debug('rebooting due to inactivity')
 			this.reboot('inactivity')
 		} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
-			sql`insert into replicator_boot_id ("replicatorId", "bootId") values (${this.ctx.id.toString()}, ${uniqueId()}) on conflict ("replicatorId") do update set "bootId" = excluded."bootId"`.execute(
-				this.db
-			)
+			// this triggers a heartbeat
+			this.log.debug('triggering heartbeat due to inactivity')
+			this.replicationService.acknowledge('0/0')
 		}
 		this.maybePruneUsers()
 	}
@@ -241,18 +307,23 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private async reboot(source: TLPostgresReplicatorRebootSource, delay = true) {
 		this.logEvent({ type: 'reboot', source })
-		this.log.debug('reboot push')
+		if (!this.queue.isEmpty()) {
+			this.log.debug('reboot is already in progress.', source)
+			return
+		}
+		this.log.debug('reboot push', source)
 		await this.queue.push(async () => {
 			if (delay) {
-				await sleep(1000)
+				await sleep(2000)
 			}
 			const start = Date.now()
-			this.log.debug('rebooting')
+			this.log.debug('rebooting', source)
 			const res = await Promise.race([
 				this.boot().then(() => 'ok'),
 				sleep(3000).then(() => 'timeout'),
 			]).catch((e) => {
 				this.logEvent({ type: 'reboot_error' })
+				this.log.debug('reboot error', e.stack)
 				this.captureException(e)
 				return 'error'
 			})
@@ -269,70 +340,89 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private async boot() {
 		this.log.debug('booting')
 		this.lastPostgresMessageTime = Date.now()
-		// clean up old resources if necessary
-		if (this.state.type === 'connected') {
-			this.state.subscription.unsubscribe()
-			this.state.directDb.end().catch(this.captureException)
-		} else if (this.state.type === 'connecting') {
-			this.state.directDb.end().catch(this.captureException)
-		}
+		this.replicationService.removeAllListeners()
+
+		// stop any previous subscriptions both here and on the postgres side to make sure we will be allowed to connect
+		// to the slot again.
+		this.log.debug('stopping replication')
+		this.replicationService.stop().catch(this.captureException)
+		this.log.debug('terminating backend')
+		await sql`SELECT pg_terminate_backend(active_pid) FROM pg_replication_slots WHERE slot_name = ${this.slotName} AND active`.execute(
+			this.db
+		)
+		this.log.debug('done')
+
 		const promise = 'promise' in this.state ? this.state.promise : promiseWithResolve()
 		this.state = {
 			type: 'connecting',
 			// preserve the promise so any awaiters do eventually get resolved
 			// TODO: set a timeout on the promise?
 			promise,
-			directDb: postgres(this.env.BOTCOM_POSTGRES_CONNECTION_STRING, {
-				types: {
-					bigint: {
-						from: [20], // PostgreSQL OID for BIGINT
-						parse: (value: string) => Number(value), // Convert string to number
-						to: 20,
-						serialize: (value: number) => String(value), // Convert number to string
-					},
-				},
-				idle_timeout: 30,
-				connection: {
-					application_name: 'TLPostgresReplicator',
-				},
-			}),
-			sequenceId: uniqueId(),
 		}
-		const subscription = await this.state.directDb.subscribe(
-			'*',
-			this.handleEvent.bind(this),
-			() => {
-				this.onDidBoot()
-			},
-			() => {
-				// this is invoked if the subscription is closed unexpectedly
-				this.captureException(new Error('Subscription error (we can tolerate this)'))
-				this.reboot('subscription_closed')
+
+		this.replicationService.on('heartbeat', (lsn: string) => {
+			this.lastPostgresMessageTime = Date.now()
+			this.reportPostgresUpdate()
+			// don't call this.updateLsn here because it's not necessary
+			// to save the lsn after heartbeats since they contain no information
+			this.replicationService.acknowledge(lsn).catch(this.captureException)
+		})
+
+		this.replicationService.addListener('data', (lsn: string, log: Wal2Json.Output) => {
+			this.lastPostgresMessageTime = Date.now()
+			this.reportPostgresUpdate()
+			for (const change of log.change) {
+				this.handleEvent(change)
 			}
-		)
+			this.updateLsn(lsn)
+		})
+
+		const handleError = (e: Error) => {
+			this.captureException(e)
+			this.reboot('retry')
+		}
+
+		this.replicationService.on('error', handleError)
+		this.replicationService.subscribe(this.wal2jsonPlugin, this.slotName).catch(handleError)
 
 		this.state = {
 			type: 'connected',
-			subscription,
-			sequenceId: this.state.sequenceId,
-			directDb: this.state.directDb,
 		}
 		promise.resolve(null)
 	}
 
-	private onDidBoot() {
+	private getCurrentLsn() {
+		return this.sqlite.exec('SELECT lsn FROM meta').one().lsn as string | null
+	}
+
+	private async updateLsn(lsn: string) {
+		const result = await this.replicationService.acknowledge(lsn)
+		if (result) {
+			// if the current lsn in the meta table is null it means
+			// that we are using a brand new replication slot and we
+			// need to force all user DOs to reboot
+			const prevLsn = this.getCurrentLsn()
+			this.sqlite.exec('UPDATE meta SET lsn = ?', lsn)
+			if (!prevLsn) {
+				this.onDidSequenceBreak()
+			}
+		} else {
+			this.captureException(new Error('acknowledge failed'))
+			this.reboot('retry')
+		}
+	}
+
+	private onDidSequenceBreak() {
 		// re-register all active users to get their latest guest info
 		// do this in small batches to avoid overwhelming the system
 		const users = this.sqlite.exec('SELECT id FROM active_user').toArray()
 		this.reportActiveUsers()
-		const sequenceId = this.state.sequenceId
 		const BATCH_SIZE = 5
 		const tick = () => {
-			if (this.state.sequenceId !== sequenceId) return
 			if (users.length === 0) return
 			const batch = users.splice(0, BATCH_SIZE)
 			for (const user of batch) {
-				this.messageUser(user.id as string, { type: 'force_reboot' })
+				this.messageUser(user.id as string, { type: 'maybe_force_reboot' })
 			}
 			setTimeout(tick, 10)
 		}
@@ -344,52 +434,83 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		5000
 	)
 
-	private handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		this.lastPostgresMessageTime = Date.now()
-		this.reportPostgresUpdate()
-		if (event.relation.table === 'replicator_boot_id') {
-			// ping, ignore
+	private handleEvent(change: Wal2Json.Change) {
+		// ignore events received after disconnecting, if that can even happen
+		if (this.state.type !== 'connected') return
+
+		this.postgresUpdates++
+
+		// ignore our keepalive pings (we probably don't need this now we have the heartbeats)
+		if (change.table === 'replicator_boot_id') return
+
+		const { row, event } = this.getRowAndEvent(change)
+		// We shouldn't get these two, but just to be sure we'll filter them out
+		const { command, table } = event
+		if (command === 'truncate' || command === 'message') {
+			this.log.debug('ignoring event', event)
 			return
 		}
-		this.postgresUpdates++
-		this.log.debug('handleEvent', event)
+		this.log.debug('handleEvent', event, row)
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
 		try {
-			switch (event.relation.table) {
+			switch (table) {
 				case 'user_boot_id':
-					this.handleBootEvent(row, event)
-					return
+					this.handleBootEvent(row, { command, table })
+					break
 				case 'user_mutation_number':
-					this.handleMutationConfirmationEvent(row, event)
-					return
+					this.handleMutationConfirmationEvent(row, { command, table })
+					break
 				case 'file_state':
-					this.handleFileStateEvent(row, event)
-					return
+					this.handleFileStateEvent(row, { command, table })
+					break
 				case 'file':
-					this.handleFileEvent(row, event)
-					return
+					this.handleFileEvent(row, { command, table })
+					break
 				case 'user':
-					this.handleUserEvent(row, event)
-					return
+					this.handleUserEvent(row, { command, table })
+					break
 				// We don't synchronize events for these tables
 				case 'asset':
 				case 'applied_migrations':
-					return
+					break
 				default:
-					this.captureException(new Error(`Unhandled table: ${event.relation.table}`), {
+					this.captureException(new Error(`Unhandled table: ${table}`), {
 						event,
 						row,
 					})
-					return
+					break
 			}
 		} catch (e) {
 			this.captureException(e)
 		}
 	}
 
-	private handleBootEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
+	private getRowAndEvent(change: Wal2Json.Change) {
+		const row = {} as any
+		// take everything from change.columnnames and associated the values from change.columnvalues
+		if (change.kind === 'delete') {
+			const oldkeys = change.oldkeys
+			assert(oldkeys, 'oldkeys is required for delete events')
+			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')
+			oldkeys.keynames.forEach((key, i) => {
+				row[key] = oldkeys.keyvalues[i]
+			})
+		} else {
+			change.columnnames.forEach((col, i) => {
+				row[col] = change.columnvalues[i]
+			})
+		}
+
+		const event = {
+			command: change.kind,
+			table: change.table,
+		}
+		return { row, event }
+	}
+
+	private handleBootEvent(row: Row | null, event: ReplicationEvent) {
 		if (event.command === 'delete') return
-		assert(row?.bootId, 'bootId is required')
+		assert(row && 'bootId' in row, 'bootId is required')
 		this.messageUser(row.userId, {
 			type: 'boot_complete',
 			userId: row.userId,
@@ -397,12 +518,9 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		})
 	}
 
-	private handleMutationConfirmationEvent(
-		row: postgres.Row | null,
-		event: postgres.ReplicationEvent
-	) {
+	private handleMutationConfirmationEvent(row: Row | null, event: ReplicationEvent) {
 		if (event.command === 'delete') return
-		assert(typeof row?.mutationNumber === 'number', 'mutationNumber is required')
+		assert(row && 'mutationNumber' in row, 'mutationNumber is required')
 		this.messageUser(row.userId, {
 			type: 'mutation_commit',
 			mutationNumber: row.mutationNumber,
@@ -410,24 +528,19 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		})
 	}
 
-	private handleFileStateEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		assert(row?.userId, 'userId is required')
+	private handleFileStateEvent(row: Row | null, event: ReplicationEvent) {
+		assert(row && 'userId' in row && 'fileId' in row, 'userId is required')
 		if (!this.userIsActive(row.userId)) return
 		if (event.command === 'insert') {
 			this.sqlite.exec(
-				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?)`,
+				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
 				row.userId,
 				row.fileId
 			)
 			assert(typeof row.isFileOwner === 'boolean', 'isFileOwner is required')
 			if (!row.isFileOwner) {
 				// need to dispatch a file creation event to the user
-				const sequenceId = this.state.sequenceId
 				this.getFileRecord(row.fileId).then((file) => {
-					// mitigate a couple of race conditions
-
-					// check that we didn't reboot (in which case the user do will fetch the file record on its own)
-					if (this.state.sequenceId !== sequenceId) return
 					// check that the subscription wasn't deleted before we managed to fetch the file record
 					const sub = this.sqlite
 						.exec(
@@ -483,14 +596,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		this.messageUser(row.userId, {
 			type: 'row_update',
 			row: row as any,
-			table: event.relation.table as ZTable,
+			table: event.table as ZTable,
 			event: event.command,
 			userId: row.userId,
 		})
 	}
 
-	private handleFileEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		assert(row?.id, 'row id is required')
+	private handleFileEvent(row: Row | null, event: ReplicationEvent) {
+		assert(row && 'id' in row, 'row id is required')
 		const impactedUserIds = this.sqlite
 			.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)
 			.toArray()
@@ -500,10 +613,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
 			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
 		} else if (event.command === 'update') {
-			assert(row.ownerId, 'ownerId is required when updating file')
+			assert('ownerId' in row, 'ownerId is required when updating file')
 			getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
 		} else if (event.command === 'insert') {
-			assert(row.ownerId, 'ownerId is required when inserting file')
+			assert('ownerId' in row, 'ownerId is required when inserting file')
 			if (!impactedUserIds.includes(row.ownerId)) {
 				impactedUserIds.push(row.ownerId)
 			}
@@ -513,20 +626,20 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			this.messageUser(userId, {
 				type: 'row_update',
 				row: row as any,
-				table: event.relation.table as ZTable,
+				table: event.table as ZTable,
 				event: event.command,
 				userId,
 			})
 		}
 	}
 
-	private handleUserEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {
-		assert(row?.id, 'user id is required')
+	private handleUserEvent(row: Row | null, event: ReplicationEvent) {
+		assert(row && 'id' in row, 'user id is required')
 		this.log.debug('USER EVENT', event.command, row.id)
 		this.messageUser(row.id, {
 			type: 'row_update',
 			row: row as any,
-			table: event.relation.table as ZTable,
+			table: event.table as ZTable,
 			event: event.command,
 			userId: row.id,
 		})
@@ -538,7 +651,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	async ping() {
 		this.log.debug('ping')
-		return { sequenceId: this.state.sequenceId }
+		return { sequenceId: this.slotName }
 	}
 
 	private async waitUntilConnected() {
@@ -585,7 +698,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				const res = await user.handleReplicationEvent({
 					...event,
 					sequenceNumber,
-					sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
+					sequenceId: this.slotName,
 				})
 				if (res === 'unregister') {
 					this.log.debug('unregistering user', userId, event)
@@ -640,7 +753,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			}
 			this.log.debug('inserted guest files', guestFiles.rows.length)
 			return {
-				sequenceId: this.state.sequenceId + ':' + sequenceIdSuffix,
+				sequenceId: this.slotName,
 				sequenceNumber: 0,
 			}
 		} catch (e) {

commit 1f179c7395510c233dae0f4f85af2126c24dd685
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Feb 24 12:03:09 2025 +0100

    [botcom] Only prune the users that haven't been active for 10 minutes. (#5462)
    
    User DO reboots became more frequent and more spikey. Feels like the 1
    minute prune time might be too agressive:
    
    ![image](https://github.com/user-attachments/assets/689ec3b7-aa1e-48bc-a6ae-982c7947f991)
    
    
    ### Change type
    
    - [x] `improvement`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 4095e2e24..905e8bb69 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -87,7 +87,7 @@ const migrations: Migration[] = [
 ]
 
 const ONE_MINUTE = 60 * 1000
-const PRUNE_TIME = ONE_MINUTE
+const PRUNE_INTERVAL = 10 * ONE_MINUTE
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
@@ -276,8 +276,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private async maybePruneUsers() {
 		const now = Date.now()
-		if (now - this.lastUserPruneTime < PRUNE_TIME) return
-		const cutoffTime = now - PRUNE_TIME
+		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return
+		const cutoffTime = now - PRUNE_INTERVAL
 		const usersWithoutRecentUpdates = this.ctx.storage.sql
 			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)
 			.toArray() as {

commit c83fea52c1367d5991569a24a19f47500645fb41
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Feb 28 08:57:04 2025 +0000

    no reboot user data on deploy (#5497)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 905e8bb69..acccba993 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -1,10 +1,13 @@
-import { DB, TlaFile, TlaRow, ZTable } from '@tldraw/dotcom-shared'
+import { DB, TlaFile, TlaFileState, TlaRow, TlaUser, ZTable } from '@tldraw/dotcom-shared'
 import {
 	ExecutionQueue,
 	assert,
+	assertExists,
 	exhaustiveSwitchError,
+	groupBy,
 	promiseWithResolve,
 	sleep,
+	stringEnum,
 	throttle,
 	uniqueId,
 } from '@tldraw/utils'
@@ -14,6 +17,7 @@ import { Kysely, sql } from 'kysely'
 
 import { LogicalReplicationService, Wal2Json, Wal2JsonPlugin } from 'pg-logical-replication'
 import { Logger } from './Logger'
+import { UserChangeCollator } from './UserChangeCollator'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnectionPool } from './postgres'
 import {
@@ -29,9 +33,18 @@ import {
 	getUserDurableObject,
 } from './utils/durableObjects'
 
+const relevantTables = stringEnum('user', 'file', 'file_state', 'user_mutation_number')
+
 interface ReplicationEvent {
 	command: 'insert' | 'update' | 'delete'
-	table: keyof DB | 'replicator_boot_id' | 'user_boot_id' | 'user_mutation_number'
+	table: keyof typeof relevantTables
+}
+
+interface Change {
+	event: ReplicationEvent
+	userId: string
+	fileId: string | null
+	row: TlaRow
 }
 
 interface Migration {
@@ -84,10 +97,25 @@ const migrations: Migration[] = [
 			INSERT INTO meta (lsn, slotName) VALUES ('0/0', 'init');
 		`,
 	},
+	{
+		id: '004_keep_event_log',
+		code: `
+		  CREATE TABLE history (
+				lsn TEXT NOT NULL,
+				userId TEXT NOT NULL,
+				fileId TEXT,
+				json TEXT NOT NULL
+			);
+			CREATE INDEX history_lsn_userId ON history (lsn, userId);
+			CREATE INDEX history_lsn_fileId ON history (lsn, fileId);
+			PRAGMA optimize;
+		`,
+	},
 ]
 
 const ONE_MINUTE = 60 * 1000
 const PRUNE_INTERVAL = 10 * ONE_MINUTE
+const MAX_HISTORY_ROWS = 10_000
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
@@ -138,6 +166,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			// eslint-disable-next-line @typescript-eslint/no-deprecated
 			this.sentry?.captureException(exception) as any
 		})
+		this.log.debug('ERROR', (exception as any)?.stack ?? exception)
 		if (!this.sentry) {
 			console.error(`[TLPostgresReplicator]: `, exception)
 		}
@@ -217,12 +246,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private _applyMigration(index: number) {
+		this.log.debug('running migration', migrations[index].id)
 		this.sqlite.exec(migrations[index].code)
 		this.sqlite.exec(
 			'insert into migrations (id, code) values (?, ?)',
 			migrations[index].id,
 			migrations[index].code
 		)
+		this.log.debug('ran migration', migrations[index].id)
 	}
 
 	private async _migrate() {
@@ -259,22 +290,26 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	override async alarm() {
-		this.ctx.storage.setAlarm(Date.now() + 3000)
-		this.maybeLogRpm()
-		// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.
-		// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.
-		if (Date.now() - this.lastPostgresMessageTime > 10000) {
-			this.log.debug('rebooting due to inactivity')
-			this.reboot('inactivity')
-		} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
-			// this triggers a heartbeat
-			this.log.debug('triggering heartbeat due to inactivity')
-			this.replicationService.acknowledge('0/0')
-		}
-		this.maybePruneUsers()
-	}
-
-	private async maybePruneUsers() {
+		try {
+			this.ctx.storage.setAlarm(Date.now() + 3000)
+			this.maybeLogRpm()
+			// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.
+			// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.
+			if (Date.now() - this.lastPostgresMessageTime > 10000) {
+				this.log.debug('rebooting due to inactivity')
+				this.reboot('inactivity')
+			} else if (Date.now() - this.lastPostgresMessageTime > 5000) {
+				// this triggers a heartbeat
+				this.log.debug('triggering heartbeat due to inactivity')
+				await this.replicationService.acknowledge('0/0')
+			}
+			await this.maybePrune()
+		} catch (e) {
+			this.captureException(e)
+		}
+	}
+
+	private async maybePrune() {
 		const now = Date.now()
 		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return
 		const cutoffTime = now - PRUNE_INTERVAL
@@ -288,9 +323,20 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				await this.unregisterUser(id)
 			}
 		}
+		this.pruneHistory()
 		this.lastUserPruneTime = Date.now()
 	}
 
+	private pruneHistory() {
+		this.sqlite.exec(`
+      WITH max AS (
+        SELECT MAX(rowid) AS max_id FROM history
+      )
+      DELETE FROM history
+      WHERE rowid < (SELECT max_id FROM max) - ${MAX_HISTORY_ROWS};
+    `)
+	}
+
 	private maybeLogRpm() {
 		const now = Date.now()
 		if (this.postgresUpdates > 0 && now - this.lastRpmLogTime > ONE_MINUTE) {
@@ -361,6 +407,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 
 		this.replicationService.on('heartbeat', (lsn: string) => {
+			this.log.debug('heartbeat', lsn)
 			this.lastPostgresMessageTime = Date.now()
 			this.reportPostgresUpdate()
 			// don't call this.updateLsn here because it's not necessary
@@ -369,12 +416,46 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		})
 
 		this.replicationService.addListener('data', (lsn: string, log: Wal2Json.Output) => {
-			this.lastPostgresMessageTime = Date.now()
-			this.reportPostgresUpdate()
-			for (const change of log.change) {
-				this.handleEvent(change)
+			// ignore events received after disconnecting, if that can even happen
+			try {
+				if (this.state.type !== 'connected') return
+				this.postgresUpdates++
+				this.lastPostgresMessageTime = Date.now()
+				this.reportPostgresUpdate()
+				const collator = new UserChangeCollator()
+				for (const _change of log.change) {
+					const change = this.parseChange(_change)
+					if (!change) {
+						this.log.debug('IGNORING CHANGE', _change)
+						continue
+					}
+
+					this.handleEvent(collator, change, false)
+					this.sqlite.exec(
+						'INSERT INTO history (lsn, userId, fileId, json) VALUES (?, ?, ?, ?)',
+						lsn,
+						change.userId,
+						change.fileId,
+						JSON.stringify(change)
+					)
+				}
+				this.log.debug('changes', collator.changes.size)
+				for (const [userId, changes] of collator.changes) {
+					this._messageUser(userId, { type: 'changes', changes, lsn })
+				}
+				this.commitLsn(lsn)
+			} catch (e) {
+				this.captureException(e)
+			}
+		})
+
+		this.replicationService.addListener('start', () => {
+			if (!this.getCurrentLsn()) {
+				// make a request to force an updateLsn()
+				sql`insert into replicator_boot_id ("replicatorId", "bootId") values (${this.ctx.id.toString()}, ${uniqueId()}) on conflict ("replicatorId") do update set "bootId" = excluded."bootId"`.execute(
+					this.db
+				)
 			}
-			this.updateLsn(lsn)
 		})
 
 		const handleError = (e: Error) => {
@@ -395,7 +476,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		return this.sqlite.exec('SELECT lsn FROM meta').one().lsn as string | null
 	}
 
-	private async updateLsn(lsn: string) {
+	private async commitLsn(lsn: string) {
 		const result = await this.replicationService.acknowledge(lsn)
 		if (result) {
 			// if the current lsn in the meta table is null it means
@@ -412,6 +493,63 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	private parseChange(change: Wal2Json.Change): Change | null {
+		const table = change.table as ReplicationEvent['table']
+		if (change.kind === 'truncate' || change.kind === 'message' || !(table in relevantTables)) {
+			return null
+		}
+
+		const row = {} as any
+		// take everything from change.columnnames and associated the values from change.columnvalues
+		if (change.kind === 'delete') {
+			const oldkeys = change.oldkeys
+			assert(oldkeys, 'oldkeys is required for delete events')
+			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')
+			oldkeys.keynames.forEach((key, i) => {
+				row[key] = oldkeys.keyvalues[i]
+			})
+		} else {
+			change.columnnames.forEach((col, i) => {
+				row[col] = change.columnvalues[i]
+			})
+		}
+
+		let userId = null as string | null
+		let fileId = null as string | null
+		switch (table) {
+			case 'user':
+				userId = (row as TlaUser).id
+				break
+			case 'file':
+				userId = (row as TlaFile).ownerId
+				fileId = (row as TlaFile).id
+				break
+			case 'file_state':
+				userId = (row as TlaFileState).userId
+				fileId = (row as TlaFileState).fileId
+				break
+			case 'user_mutation_number':
+				userId = (row as { userId: string }).userId
+				break
+			default: {
+				// assert never
+				const _x: never = table
+			}
+		}
+
+		if (!userId) return null
+
+		return {
+			row,
+			event: {
+				command: change.kind,
+				table,
+			},
+			userId,
+			fileId,
+		}
+	}
+
 	private onDidSequenceBreak() {
 		// re-register all active users to get their latest guest info
 		// do this in small batches to avoid overwhelming the system
@@ -422,7 +560,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			if (users.length === 0) return
 			const batch = users.splice(0, BATCH_SIZE)
 			for (const user of batch) {
-				this.messageUser(user.id as string, { type: 'maybe_force_reboot' })
+				this._messageUser(user.id as string, { type: 'maybe_force_reboot' })
 			}
 			setTimeout(tick, 10)
 		}
@@ -434,166 +572,76 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		5000
 	)
 
-	private handleEvent(change: Wal2Json.Change) {
+	private handleEvent(collator: UserChangeCollator, change: Change, isReplay: boolean) {
 		// ignore events received after disconnecting, if that can even happen
 		if (this.state.type !== 'connected') return
 
-		this.postgresUpdates++
-
-		// ignore our keepalive pings (we probably don't need this now we have the heartbeats)
-		if (change.table === 'replicator_boot_id') return
-
-		const { row, event } = this.getRowAndEvent(change)
 		// We shouldn't get these two, but just to be sure we'll filter them out
-		const { command, table } = event
-		if (command === 'truncate' || command === 'message') {
-			this.log.debug('ignoring event', event)
-			return
-		}
-		this.log.debug('handleEvent', event, row)
+		const { command, table } = change.event
+		this.log.debug('handleEvent', change)
 		assert(this.state.type === 'connected', 'state should be connected in handleEvent')
 		try {
 			switch (table) {
-				case 'user_boot_id':
-					this.handleBootEvent(row, { command, table })
-					break
 				case 'user_mutation_number':
-					this.handleMutationConfirmationEvent(row, { command, table })
+					this.handleMutationConfirmationEvent(collator, change.row, { command, table })
 					break
 				case 'file_state':
-					this.handleFileStateEvent(row, { command, table })
+					this.handleFileStateEvent(collator, change.row, { command, table })
 					break
 				case 'file':
-					this.handleFileEvent(row, { command, table })
+					this.handleFileEvent(collator, change.row, { command, table }, isReplay)
 					break
 				case 'user':
-					this.handleUserEvent(row, { command, table })
+					this.handleUserEvent(collator, change.row, { command, table })
 					break
-				// We don't synchronize events for these tables
-				case 'asset':
-				case 'applied_migrations':
-					break
-				default:
-					this.captureException(new Error(`Unhandled table: ${table}`), {
-						event,
-						row,
-					})
+				default: {
+					const _x: never = table
+					this.captureException(new Error(`Unhandled table: ${table}`), { change })
 					break
+				}
 			}
 		} catch (e) {
 			this.captureException(e)
 		}
 	}
 
-	private getRowAndEvent(change: Wal2Json.Change) {
-		const row = {} as any
-		// take everything from change.columnnames and associated the values from change.columnvalues
-		if (change.kind === 'delete') {
-			const oldkeys = change.oldkeys
-			assert(oldkeys, 'oldkeys is required for delete events')
-			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')
-			oldkeys.keynames.forEach((key, i) => {
-				row[key] = oldkeys.keyvalues[i]
-			})
-		} else {
-			change.columnnames.forEach((col, i) => {
-				row[col] = change.columnvalues[i]
-			})
-		}
-
-		const event = {
-			command: change.kind,
-			table: change.table,
-		}
-		return { row, event }
-	}
-
-	private handleBootEvent(row: Row | null, event: ReplicationEvent) {
-		if (event.command === 'delete') return
-		assert(row && 'bootId' in row, 'bootId is required')
-		this.messageUser(row.userId, {
-			type: 'boot_complete',
-			userId: row.userId,
-			bootId: row.bootId,
-		})
-	}
-
-	private handleMutationConfirmationEvent(row: Row | null, event: ReplicationEvent) {
+	private handleMutationConfirmationEvent(
+		collator: UserChangeCollator,
+		row: Row | null,
+		event: ReplicationEvent
+	) {
 		if (event.command === 'delete') return
 		assert(row && 'mutationNumber' in row, 'mutationNumber is required')
-		this.messageUser(row.userId, {
+		collator.addChange(row.userId, {
 			type: 'mutation_commit',
 			mutationNumber: row.mutationNumber,
 			userId: row.userId,
 		})
 	}
 
-	private handleFileStateEvent(row: Row | null, event: ReplicationEvent) {
+	private handleFileStateEvent(
+		collator: UserChangeCollator,
+		row: Row | null,
+		event: ReplicationEvent
+	) {
 		assert(row && 'userId' in row && 'fileId' in row, 'userId is required')
 		if (!this.userIsActive(row.userId)) return
 		if (event.command === 'insert') {
-			this.sqlite.exec(
-				`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
-				row.userId,
-				row.fileId
-			)
-			assert(typeof row.isFileOwner === 'boolean', 'isFileOwner is required')
 			if (!row.isFileOwner) {
-				// need to dispatch a file creation event to the user
-				this.getFileRecord(row.fileId).then((file) => {
-					// check that the subscription wasn't deleted before we managed to fetch the file record
-					const sub = this.sqlite
-						.exec(
-							`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
-							row.userId,
-							row.fileId
-						)
-						.toArray()[0]
-					if (!sub) return
-
-					// alright we're good to go
-					this.messageUser(row.userId, {
-						type: 'row_update',
-						row: file as any,
-						table: 'file',
-						event: 'insert',
-						userId: row.userId,
-					})
-				})
-			}
-		} else if (event.command === 'delete') {
-			// If the file state being deleted does not belong to the file owner,
-			// we need to send a delete event for the file to the user
-			const sub = this.sqlite
-				.exec(
-					`SELECT * FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
-					row.userId,
-					row.fileId
-				)
-				.toArray()[0]
-			if (!sub) {
-				// the file was deleted before the file state
-				this.log.debug('file state deleted before file', row)
-			} else {
 				this.sqlite.exec(
-					`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
+					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
 					row.userId,
 					row.fileId
 				)
-				// We forward a file delete event to the user
-				// even if they are the file owner. This is because the file_state
-				// deletion might happen before the file deletion and we don't get the
-				// ownerId on file delete events
-				this.messageUser(row.userId, {
-					type: 'row_update',
-					row: { id: row.fileId } as any,
-					table: 'file',
-					event: 'delete',
-					userId: row.userId,
-				})
 			}
+		} else if (event.command === 'delete') {
+			this.sqlite.exec(
+				`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,
+				row.userId,
+				row.fileId
+			)
 		}
-		this.messageUser(row.userId, {
+		collator.addChange(row.userId, {
 			type: 'row_update',
 			row: row as any,
 			table: event.table as ZTable,
@@ -602,28 +650,33 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		})
 	}
 
-	private handleFileEvent(row: Row | null, event: ReplicationEvent) {
-		assert(row && 'id' in row, 'row id is required')
-		const impactedUserIds = this.sqlite
-			.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)
-			.toArray()
-			.map((x) => x.userId as string)
+	private handleFileEvent(
+		collator: UserChangeCollator,
+		row: Row | null,
+		event: ReplicationEvent,
+		isReplay: boolean
+	) {
+		assert(row && 'id' in row && 'ownerId' in row, 'row id is required')
+		const impactedUserIds = [
+			row.ownerId,
+			...this.sqlite
+				.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)
+				.toArray()
+				.map((x) => x.userId as string),
+		]
 		// if the file state was deleted before the file, we might not have any impacted users
 		if (event.command === 'delete') {
-			getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
 			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
 		} else if (event.command === 'update') {
 			assert('ownerId' in row, 'ownerId is required when updating file')
-			getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
 		} else if (event.command === 'insert') {
 			assert('ownerId' in row, 'ownerId is required when inserting file')
-			if (!impactedUserIds.includes(row.ownerId)) {
-				impactedUserIds.push(row.ownerId)
-			}
-			getRoomDurableObject(this.env, row.id).appFileRecordCreated(row as TlaFile)
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordCreated(row as TlaFile)
 		}
 		for (const userId of impactedUserIds) {
-			this.messageUser(userId, {
+			collator.addChange(userId, {
 				type: 'row_update',
 				row: row as any,
 				table: event.table as ZTable,
@@ -633,16 +686,17 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	private handleUserEvent(row: Row | null, event: ReplicationEvent) {
+	private handleUserEvent(collator: UserChangeCollator, row: Row | null, event: ReplicationEvent) {
 		assert(row && 'id' in row, 'user id is required')
 		this.log.debug('USER EVENT', event.command, row.id)
-		this.messageUser(row.id, {
+		collator.addChange(row.id, {
 			type: 'row_update',
 			row: row as any,
 			table: event.table as ZTable,
 			event: event.command,
 			userId: row.id,
 		})
+		return [row.id]
 	}
 
 	private userIsActive(userId: string) {
@@ -673,32 +727,35 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	private async messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
-		if (!this.userIsActive(userId)) return
+	private async _messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
+		this.log.debug('messageUser', userId, event)
+		if (!this.userIsActive(userId)) {
+			this.log.debug('user is not active', userId)
+			return
+		}
 		try {
 			let q = this.userDispatchQueues.get(userId)
 			if (!q) {
 				q = new ExecutionQueue()
 				this.userDispatchQueues.set(userId, q)
 			}
-			await q.push(async () => {
-				const { sequenceNumber, sequenceIdSuffix } = this.sqlite
-					.exec(
-						'UPDATE active_user SET sequenceNumber = sequenceNumber + 1, lastUpdatedAt = ? WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
-						Date.now(),
-						userId
-					)
-					.one()
+			const { sequenceNumber, sequenceIdSuffix } = this.sqlite
+				.exec(
+					'UPDATE active_user SET sequenceNumber = sequenceNumber + 1, lastUpdatedAt = ? WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',
+					Date.now(),
+					userId
+				)
+				.one()
+			assert(typeof sequenceNumber === 'number', 'sequenceNumber should be a number')
+			assert(typeof sequenceIdSuffix === 'string', 'sequenceIdSuffix should be a string')
 
+			await q.push(async () => {
 				const user = getUserDurableObject(this.env, userId)
 
-				assert(typeof sequenceNumber === 'number', 'sequenceNumber should be a number')
-				assert(typeof sequenceIdSuffix === 'string', 'sequenceIdSuffix should be a string')
-
 				const res = await user.handleReplicationEvent({
 					...event,
 					sequenceNumber,
-					sequenceId: this.slotName,
+					sequenceId: this.slotName + sequenceIdSuffix,
 				})
 				if (res === 'unregister') {
 					this.log.debug('unregistering user', userId, event)
@@ -719,41 +776,126 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	async registerUser(userId: string) {
+	private getResumeType(
+		lsn: string,
+		userId: string,
+		guestFileIds: string[]
+	): { type: 'done'; messages?: ZReplicationEventWithoutSequenceInfo[] } | { type: 'reboot' } {
+		const currentLsn = assertExists(this.getCurrentLsn())
+
+		if (lsn >= currentLsn) {
+			this.log.debug('resuming from current lsn', lsn, '>=', currentLsn)
+			// targetLsn is now or in the future, we can register them and deliver events
+			// without needing to check the history
+			return { type: 'done' }
+		}
+		const earliestLsn = this.sqlite
+			.exec<{ lsn: string }>('SELECT lsn FROM history ORDER BY rowid asc LIMIT 1')
+			.toArray()[0]?.lsn
+
+		if (!earliestLsn || lsn < earliestLsn) {
+			this.log.debug('not enough history', lsn, '<', earliestLsn)
+			// not enough history, we can't resume
+			return { type: 'reboot' }
+		}
+
+		const history = this.sqlite
+			.exec<{ json: string; lsn: string }>(
+				`
+			SELECT lsn, json
+			FROM history
+			WHERE
+			  lsn > ?
+				AND (
+				  userId = ? 
+					OR fileId IN (${guestFileIds.map((_, i) => '$' + (i + 1)).join(', ')})
+				)
+			ORDER BY rowid ASC
+		`,
+				lsn,
+				userId,
+				...guestFileIds
+			)
+			.toArray()
+			.map(({ json, lsn }) => ({ change: JSON.parse(json) as Change, lsn }))
+
+		if (history.length === 0) {
+			this.log.debug('no history to replay, all good', lsn)
+			return { type: 'done' }
+		}
+
+		const changesByLsn = groupBy(history, (x) => x.lsn)
+		const messages: ZReplicationEventWithoutSequenceInfo[] = []
+		for (const lsn of Object.keys(changesByLsn).sort()) {
+			const collator = new UserChangeCollator()
+			for (const change of changesByLsn[lsn]) {
+				this.handleEvent(collator, change.change, true)
+			}
+			const changes = collator.changes.get(userId)
+			if (changes?.length) {
+				messages.push({ type: 'changes', changes, lsn })
+			}
+		}
+		this.log.debug('resuming', messages.length, messages)
+		return { type: 'done', messages }
+	}
+
+	async registerUser({
+		userId,
+		lsn,
+		guestFileIds,
+		bootId,
+	}: {
+		userId: string
+		lsn: string
+		guestFileIds: string[]
+		bootId: string
+	}): Promise<{ type: 'done'; sequenceId: string; sequenceNumber: number } | { type: 'reboot' }> {
 		try {
-			this.log.debug('registering user', userId)
-			this.logEvent({ type: 'register_user' })
-			this.log.debug('reg user wait')
-			await this.waitUntilConnected()
-			this.log.debug('reg user connect')
-			assert(this.state.type === 'connected', 'state should be connected in registerUser')
-			const guestFiles = await sql<{
-				id: string
-			}>`SELECT "fileId" as id FROM file_state where "userId" = ${userId}`.execute(this.db)
-			this.log.debug('got guest files')
+			while (!this.getCurrentLsn()) {
+				// this should only happen once per slot name change, which should never happen!
+				await sleep(100)
+			}
 
-			const sequenceIdSuffix = uniqueId()
+			this.log.debug('registering user', userId, lsn, bootId, guestFileIds)
+			this.logEvent({ type: 'register_user' })
 
 			// clear user and subscriptions
 			this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)
 			this.sqlite.exec(
 				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix, lastUpdatedAt) VALUES (?, 0, ?, ?)`,
 				userId,
-				sequenceIdSuffix,
+				bootId,
 				Date.now()
 			)
-			this.reportActiveUsers()
-			this.log.debug('inserted active user')
-			for (const file of guestFiles.rows) {
+
+			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE userId = ?`, userId)
+			for (const fileId of guestFileIds) {
 				this.sqlite.exec(
 					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,
 					userId,
-					file.id
+					fileId
 				)
 			}
-			this.log.debug('inserted guest files', guestFiles.rows.length)
+			this.log.debug('inserted file subscriptions', guestFileIds.length)
+
+			this.reportActiveUsers()
+			this.log.debug('inserted active user')
+
+			const resume = this.getResumeType(lsn, userId, guestFileIds)
+			if (resume.type === 'reboot') {
+				return { type: 'reboot' }
+			}
+
+			if (resume.messages) {
+				for (const message of resume.messages) {
+					this._messageUser(userId, message)
+				}
+			}
+
 			return {
-				sequenceId: this.slotName,
+				type: 'done',
+				sequenceId: this.slotName + bootId,
 				sequenceNumber: 0,
 			}
 		} catch (e) {

commit 74380a338ae9f9f7c191f482b37cb2b6dc715c99
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Feb 28 16:07:46 2025 +0000

    Do hard deletes reactively (#5522)
    
    Before this PR the only path we had available for hard deletes was via
    client-side mutations. If we deleted the row manually in the db (e.g.
    because a user asked us to wipe their data) it would not result in the
    R2/KV artefacts being cleaned up.
    
    Before this PR we also needed to get the publsihedSlug from the row
    before deleting it so we could clean up the publishing artefacts.
    
    Now I added the publishedSlug to the file table primary key so we get it
    in delete events. Then when we handle those delete events in the file
    durable object, it does the cleanup there.
    
    We'd end up doing this during the switch to zero anyway I think.
    
    (note this wasn't totally safe to do before because file deletes may
    have happened while the replicator didn't have an open subscription to
    Postgres. But now we use a persistent replication slot this should
    always work)
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index acccba993..6a3cd38dd 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -666,14 +666,14 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		]
 		// if the file state was deleted before the file, we might not have any impacted users
 		if (event.command === 'delete') {
-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidDelete()
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidDelete(row)
 			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)
 		} else if (event.command === 'update') {
 			assert('ownerId' in row, 'ownerId is required when updating file')
-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row as TlaFile)
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row)
 		} else if (event.command === 'insert') {
 			assert('ownerId' in row, 'ownerId is required when inserting file')
-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordCreated(row as TlaFile)
+			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordCreated(row)
 		}
 		for (const userId of impactedUserIds) {
 			collator.addChange(userId, {
@@ -708,25 +708,6 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		return { sequenceId: this.slotName }
 	}
 
-	private async waitUntilConnected() {
-		while (this.state.type !== 'connected') {
-			await this.state.promise
-		}
-	}
-
-	async getFileRecord(fileId: string) {
-		this.logEvent({ type: 'get_file_record' })
-		await this.waitUntilConnected()
-		assert(this.state.type === 'connected', 'state should be connected in getFileRecord')
-		try {
-			const res = await sql`select * from public.file where id = ${fileId}`.execute(this.db)
-			if (res.rows.length === 0) return null
-			return res.rows[0] as TlaFile
-		} catch (_e) {
-			return null
-		}
-	}
-
 	private async _messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {
 		this.log.debug('messageUser', userId, event)
 		if (!this.userIsActive(userId)) {
@@ -763,7 +744,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				}
 			})
 		} catch (e) {
-			console.error('Error in messageUser', e)
+			this.captureException(e)
 		}
 	}
 

commit 7df0a29a4c9f9977a2de5762e76ff48fe2e9adb5
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Mar 4 21:26:21 2025 +0000

    Make better use of replicator history (#5532)
    
    After making a couple of deploys with the new backend this morning we
    noticed that a large portion of user DOs still ended up doing a full db
    reset and this seems to be for two reasons:
    
    1. we only stored about 10 minutes worth of history
    2. a lot of users in our active_users table are idle at any given time
    (maybe like 70-80% of them) so a lot of them will not have received
    updates for more than 10 minutes.
    
    This PR makes it so that if a user hasn't done anything for 5 minutes
    but their socket is still open, we execute a noop mutation number bump
    so that they receive a new `lsn`.
    
    I also cleaned up the mutation handling logic so that it no longer does
    two transactions per mutation. This was only required before because
    postgres.js would not dispatch events grouped by transaction, and the
    ordering was not maintained. wal2json guarantees changes to be grouped
    by transaction with formatVersion: 1 (the default that we use) so as
    long as we commit the mutations after handling any state updates it
    should avoid data races.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 6a3cd38dd..56c18b56b 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -115,7 +115,7 @@ const migrations: Migration[] = [
 
 const ONE_MINUTE = 60 * 1000
 const PRUNE_INTERVAL = 10 * ONE_MINUTE
-const MAX_HISTORY_ROWS = 10_000
+const MAX_HISTORY_ROWS = 50_000
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 

commit 283889799096b75e16d7a9ab38b1cd239d90790a
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Mar 11 12:17:56 2025 +0000

    Add more postgres history, reduce ping overhead (#5604)
    
    Last time we did a dotcom release during working hours there were way
    more User DO full postgres refetches than anticipated, which led to a
    couple of minutes of slowness.
    
    Investigating this, I couldn't find a link in the chain that had failed,
    so it seems likely that the history pruning was too aggressive and the
    length of time between 'noop' mutations was too long. So in this PR I
    tweak both of those variables, and make 'noop' mutations more efficient
    by bypassing postgres and just asking the replicator for an lsn update
    directly.
    
    If this doesn't work there is definitely something I'm missing about the
    production env that makes this stuff fail. In this PR I also added a
    bunch of extra analytics to maybe help narrow it down after the next
    release.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 56c18b56b..33fe1eda5 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -111,11 +111,17 @@ const migrations: Migration[] = [
 			PRAGMA optimize;
 		`,
 	},
+	{
+		id: '005_add_history_timestamp',
+		code: `
+			ALTER TABLE history ADD COLUMN timestamp INTEGER NOT NULL DEFAULT 0;
+		`,
+	},
 ]
 
 const ONE_MINUTE = 60 * 1000
 const PRUNE_INTERVAL = 10 * ONE_MINUTE
-const MAX_HISTORY_ROWS = 50_000
+const MAX_HISTORY_ROWS = 100_000
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
@@ -349,6 +355,23 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	async getDiagnostics() {
+		const earliestHistoryRow = this.sqlite
+			.exec('select * from history order by rowid asc limit 1')
+			.toArray()[0]
+		const latestHistoryRow = this.sqlite
+			.exec('select * from history order by rowid desc limit 1')
+			.toArray()[0]
+		const activeUsers = this.sqlite.exec('select count(*) from active_user').one().count as number
+		const meta = this.sqlite.exec('select * from meta').one()
+		return {
+			earliestHistoryRow,
+			latestHistoryRow,
+			activeUsers,
+			meta,
+		}
+	}
+
 	private queue = new ExecutionQueue()
 
 	private async reboot(source: TLPostgresReplicatorRebootSource, delay = true) {
@@ -432,11 +455,12 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 					this.handleEvent(collator, change, false)
 					this.sqlite.exec(
-						'INSERT INTO history (lsn, userId, fileId, json) VALUES (?, ?, ?, ?)',
+						'INSERT INTO history (lsn, userId, fileId, json, timestamp) VALUES (?, ?, ?, ?, ?)',
 						lsn,
 						change.userId,
 						change.fileId,
-						JSON.stringify(change)
+						JSON.stringify(change),
+						Date.now()
 					)
 				}
 				this.log.debug('changes', collator.changes.size)
@@ -765,7 +789,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		const currentLsn = assertExists(this.getCurrentLsn())
 
 		if (lsn >= currentLsn) {
-			this.log.debug('resuming from current lsn', lsn, '>=', currentLsn)
+			this.log.debug('getResumeType: resuming from current lsn', lsn, '>=', currentLsn)
 			// targetLsn is now or in the future, we can register them and deliver events
 			// without needing to check the history
 			return { type: 'done' }
@@ -775,7 +799,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			.toArray()[0]?.lsn
 
 		if (!earliestLsn || lsn < earliestLsn) {
-			this.log.debug('not enough history', lsn, '<', earliestLsn)
+			this.log.debug('getResumeType: not enough history', lsn, '<', earliestLsn)
 			// not enough history, we can't resume
 			return { type: 'reboot' }
 		}
@@ -801,7 +825,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			.map(({ json, lsn }) => ({ change: JSON.parse(json) as Change, lsn }))
 
 		if (history.length === 0) {
-			this.log.debug('no history to replay, all good', lsn)
+			this.log.debug('getResumeType: no history to replay, all good', lsn)
 			return { type: 'done' }
 		}
 
@@ -817,7 +841,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				messages.push({ type: 'changes', changes, lsn })
 			}
 		}
-		this.log.debug('resuming', messages.length, messages)
+		this.log.debug('getResumeType: resuming', messages.length, messages)
 		return { type: 'done', messages }
 	}
 
@@ -885,6 +909,19 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
+	async requestLsnUpdate(userId: string) {
+		try {
+			this.log.debug('requestLsnUpdate', userId)
+			this.logEvent({ type: 'request_lsn_update' })
+			const lsn = assertExists(this.getCurrentLsn(), 'lsn should exist')
+			this._messageUser(userId, { type: 'changes', changes: [], lsn })
+		} catch (e) {
+			this.captureException(e)
+			throw e
+		}
+		return
+	}
+
 	async unregisterUser(userId: string) {
 		this.logEvent({ type: 'unregister_user' })
 		this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)
@@ -908,6 +945,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			case 'reboot_error':
 			case 'register_user':
 			case 'unregister_user':
+			case 'request_lsn_update':
 			case 'get_file_record':
 				this.writeEvent({
 					blobs: [event.type],

commit a6c2905c622f1b9ffca2aeda734782af93e67f1b
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Fri Mar 21 09:25:04 2025 +0000

    Use pg message bus for requesting lsn update (#5722)
    
    After the deploy this morning we started getting a lot of
    
    > Error: Subrequest depth limit exceeded. This request recursed through
    Workers too many times. This can happen e.g. if you have a Worker or
    Durable Object that calls other Workers or objects recursively.
    
    In sentry. All seeming to originate from the new RPC-based lsn update
    mechanism. No idea why, there's a back and forth but no real chain of
    recursion here, it's just running on a setInterval.
    
    Anyway this cuts one side of the RPC link out so it can't possibly think
    there's a recursion chain.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 33fe1eda5..6f3230bfa 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -318,6 +318,8 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private async maybePrune() {
 		const now = Date.now()
 		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return
+		this.logEvent({ type: 'prune' })
+		this.log.debug('pruning')
 		const cutoffTime = now - PRUNE_INTERVAL
 		const usersWithoutRecentUpdates = this.ctx.storage.sql
 			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)
@@ -447,6 +449,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				this.reportPostgresUpdate()
 				const collator = new UserChangeCollator()
 				for (const _change of log.change) {
+					if (_change.kind === 'message' && (_change as any).prefix === 'requestLsnUpdate') {
+						this.requestLsnUpdate((_change as any).content)
+						continue
+					}
 					const change = this.parseChange(_change)
 					if (!change) {
 						this.log.debug('IGNORING CHANGE', _change)
@@ -909,7 +915,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 	}
 
-	async requestLsnUpdate(userId: string) {
+	private async requestLsnUpdate(userId: string) {
 		try {
 			this.log.debug('requestLsnUpdate', userId)
 			this.logEvent({ type: 'request_lsn_update' })
@@ -946,6 +952,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			case 'register_user':
 			case 'unregister_user':
 			case 'request_lsn_update':
+			case 'prune':
 			case 'get_file_record':
 				this.writeEvent({
 					blobs: [event.type],

commit 10d4563919ca3af6c0610f91357b5737c5885716
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Mar 24 14:08:57 2025 +0000

    [dotcom backend] Wrap writeDataPoint in try/catch to make it safe (#5739)
    
    This seems to have been causing errors since the deploy yesterday
    
    We were disptaching more analytics events than normal it seems? And this
    was throwing errors in our business logic and making things reset when
    they shouldn't.
    
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 6f3230bfa..e45c620ac 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -940,7 +940,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	}
 
 	private writeEvent(eventData: EventData) {
-		writeDataPoint(this.measure, this.env, 'replicator', eventData)
+		writeDataPoint(this.sentry, this.measure, this.env, 'replicator', eventData)
 	}
 
 	logEvent(event: TLPostgresReplicatorEvent) {

commit b1ca2fcd8c7dc5b8d079846cf24df5d860c29fbf
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Mar 25 09:46:35 2025 +0000

    Copy changes from hotfixes branch (#5744)
    
    We pushed a bunch of hotfixes directly yesterday while trying to make
    the backend behave itself.
    
    This PR collects all the changes and simplifies the concurrency
    prevention bugfix.
    
    ### Change type
    
    - [x] `other`

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index e45c620ac..085f60049 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -121,7 +121,7 @@ const migrations: Migration[] = [
 
 const ONE_MINUTE = 60 * 1000
 const PRUNE_INTERVAL = 10 * ONE_MINUTE
-const MAX_HISTORY_ROWS = 100_000
+const MAX_HISTORY_ROWS = 20_000
 
 type PromiseWithResolve = ReturnType<typeof promiseWithResolve>
 
@@ -182,7 +182,10 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 	private readonly replicationService
 	private readonly slotName
-	private readonly wal2jsonPlugin = new Wal2JsonPlugin({})
+	private readonly wal2jsonPlugin = new Wal2JsonPlugin({
+		addTables:
+			'public.user,public.file,public.file_state,public.user_mutation_number,public.replicator_boot_id',
+	})
 
 	private readonly db: Kysely<DB>
 	constructor(ctx: DurableObjectState, env: Environment) {
@@ -240,6 +243,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				await sql`SELECT pg_create_logical_replication_slot(${this.slotName}, 'wal2json') WHERE NOT EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = ${this.slotName})`.execute(
 					this.db
 				)
+				this.pruneHistory()
 			})
 			.then(() => {
 				this.reboot('constructor', false).catch((e) => {
@@ -327,9 +331,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			id: string
 		}[]
 		for (const { id } of usersWithoutRecentUpdates) {
-			if (await getUserDurableObject(this.env, id).notActive()) {
-				await this.unregisterUser(id)
-			}
+			await this.unregisterUser(id)
 		}
 		this.pruneHistory()
 		this.lastUserPruneTime = Date.now()

commit 21002dc7ca29a9de51c6f24676ba5812958a8248
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Apr 1 13:26:45 2025 +0200

    Zero spike (#5551)
    
    Describe what your pull request does. If you can, add GIFs or images
    showing the before and after of your change.
    
    ### Change type
    
    - [x] `other`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
index 085f60049..fc4adc3a9 100644
--- a/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
+++ b/apps/dotcom/sync-worker/src/TLPostgresReplicator.ts
@@ -20,6 +20,7 @@ import { Logger } from './Logger'
 import { UserChangeCollator } from './UserChangeCollator'
 import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'
 import { createPostgresConnectionPool } from './postgres'
+import { getR2KeyForRoom } from './r2'
 import {
 	Analytics,
 	Environment,
@@ -45,6 +46,7 @@ interface Change {
 	userId: string
 	fileId: string | null
 	row: TlaRow
+	previous?: TlaRow
 }
 
 interface Migration {
@@ -532,6 +534,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		}
 
 		const row = {} as any
+		const previous = {} as any
 		// take everything from change.columnnames and associated the values from change.columnvalues
 		if (change.kind === 'delete') {
 			const oldkeys = change.oldkeys
@@ -540,6 +543,16 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 			oldkeys.keynames.forEach((key, i) => {
 				row[key] = oldkeys.keyvalues[i]
 			})
+		} else if (change.kind === 'update') {
+			const oldkeys = change.oldkeys
+			assert(oldkeys, 'oldkeys is required for delete events')
+			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')
+			oldkeys.keynames.forEach((key, i) => {
+				previous[key] = oldkeys.keyvalues[i]
+			})
+			change.columnnames.forEach((col, i) => {
+				row[col] = change.columnvalues[i]
+			})
 		} else {
 			change.columnnames.forEach((col, i) => {
 				row[col] = change.columnvalues[i]
@@ -573,6 +586,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 
 		return {
 			row,
+			previous,
 			event: {
 				command: change.kind,
 				table,
@@ -621,7 +635,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 					this.handleFileStateEvent(collator, change.row, { command, table })
 					break
 				case 'file':
-					this.handleFileEvent(collator, change.row, { command, table }, isReplay)
+					this.handleFileEvent(collator, change.row, change.previous, { command, table }, isReplay)
 					break
 				case 'user':
 					this.handleUserEvent(collator, change.row, { command, table })
@@ -685,6 +699,7 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 	private handleFileEvent(
 		collator: UserChangeCollator,
 		row: Row | null,
+		previous: Row | undefined,
 		event: ReplicationEvent,
 		isReplay: boolean
 	) {
@@ -703,6 +718,16 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 		} else if (event.command === 'update') {
 			assert('ownerId' in row, 'ownerId is required when updating file')
 			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row)
+			if (previous && !isReplay) {
+				const prevFile = previous as TlaFile
+				if (row.published && !(prevFile as TlaFile).published) {
+					this.publishSnapshot(row)
+				} else if (!row.published && (prevFile as TlaFile).published) {
+					this.unpublishSnapshot(row)
+				} else if (row.published && row.lastPublished > prevFile.lastPublished) {
+					this.publishSnapshot(row)
+				}
+			}
 		} else if (event.command === 'insert') {
 			assert('ownerId' in row, 'ownerId is required when inserting file')
 			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordCreated(row)
@@ -983,4 +1008,45 @@ export class TLPostgresReplicator extends DurableObject<Environment> {
 				exhaustiveSwitchError(event)
 		}
 	}
+
+	private async publishSnapshot(file: TlaFile) {
+		try {
+			// make sure the room's snapshot is up to date
+			await getRoomDurableObject(this.env, file.id).awaitPersist()
+			// and that it exists
+			const snapshot = await this.env.ROOMS.get(getR2KeyForRoom({ slug: file.id, isApp: true }))
+
+			if (!snapshot) {
+				throw new Error('Snapshot not found')
+			}
+			const blob = await snapshot.blob()
+
+			// Create a new slug for the published room
+			await this.env.SNAPSHOT_SLUG_TO_PARENT_SLUG.put(file.publishedSlug, file.id)
+
+			// Bang the snapshot into the database
+			await this.env.ROOM_SNAPSHOTS.put(
+				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}`, isApp: true }),
+				blob
+			)
+			const currentTime = new Date().toISOString()
+			await this.env.ROOM_SNAPSHOTS.put(
+				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}|${currentTime}`, isApp: true }),
+				blob
+			)
+		} catch (e) {
+			this.log.debug('Error publishing snapshot', e)
+		}
+	}
+
+	private async unpublishSnapshot(file: TlaFile) {
+		try {
+			await this.env.SNAPSHOT_SLUG_TO_PARENT_SLUG.delete(file.publishedSlug)
+			await this.env.ROOM_SNAPSHOTS.delete(
+				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}`, isApp: true })
+			)
+		} catch (e) {
+			this.log.debug('Error unpublishing snapshot', e)
+		}
+	}
 }

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    