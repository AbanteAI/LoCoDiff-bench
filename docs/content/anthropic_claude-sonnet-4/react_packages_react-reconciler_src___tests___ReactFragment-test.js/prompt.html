<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/react-reconciler/src/__tests__/ReactFragment-test.js - Sonnet 4</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/react-reconciler/src/__tests__/ReactFragment-test.js</h1>
        <h2>Model: Sonnet 4</h2>
        <p><a href="../../../cases/anthropic_claude-sonnet-4/react_packages_react-reconciler_src___tests___ReactFragment-test.js.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/react-reconciler/src/__tests__/ReactFragment-test.js

commit 4ce5da7aee90a373f2f36d1beb559097af30952e
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Mon Oct 30 17:52:40 2017 -0700

    Add Fragment as a named export to React (#10783)
    
    * Add Fragment as a named export to React
    
    * Remove extra tests for Fragment
    
    * Change React.Fragment export to be a string '#fragment'
    
    * Fix fragment special case to work with 1 child
    
    * Add single child test for fragment export
    
    * Move fragment definition to ReactEntry.js and render components for key warning tests
    
    * Inline createFiberFromElementType into createFiberFromElement
    
    * Update reconciliation to special case fragments
    
    * Use same semantics as implicit childsets for ReactFragment
    
    * Add more fragment state preservation tests
    
    * Export symbol instead of string for fragments
    
    * Fix rebase breakages
    
    * Re-apply prettier at 1.2.2
    
    * Merge branches in updateElement
    
    * Remove unnecessary check
    
    * Re-use createFiberFromFragment for fragment case
    
    * Simplyify branches by adding type field to fragment fiber
    
    * Move branching logic for fragments to broader methods when possible.
    
    * Add more tests for fragments
    
    * Address Dan's feedback
    
    * Move REACT_FRAGMENT_TYPE into __DEV__ block for DCE
    
    * Change hex representation of REACT_FRAGMENT_TYPE to follow convention
    
    * Remove unnecessary branching and isArray checks
    
    * Update test for preserving children state when keys are same
    
    * Fix updateSlot bug and add more tests
    
    * Make fragment tests more robust by using ops pattern
    
    * Update jsx element validator to allow numbers and symbols
    
    * Remove type field from fragment fiber
    
    * Fork reconcileChildFibers instead of recursing
    
    * Use ternary if condition
    
    * Revamp fragment test suite:
    
    - Add more coverage to fragment tests
    - Use better names
    - Remove useless Fragment component inside tests
    - Remove useless tests so that tests are more concise
    
    * Check output of renderer in fragment tests to ensure no silly business despite states being preserved
    
    * Finish implementation of fragment reconciliation with desired behavior
    
    * Add reverse render direction for fragment tests
    
    * Remove unneeded fragment branch in updateElement
    
    * Add more test cases for ReactFragment
    
    * Handle childless fragment in reconciler
    
    * Support fragment flattening in SSR
    
    * Clean up ReactPartialRenderer
    
    * Warn when non-key and children props are passed to fragments
    
    * Add non-null key check back to updateSlot's array's case
    
    * Add test for positional reconciliation in fragments
    
    * Add warning for refs in fragments with stack trace

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
new file mode 100644
index 0000000000..2083d8643c
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -0,0 +1,721 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+'use strict';
+
+let React;
+let ReactNoop;
+
+describe('ReactFragment', () => {
+  beforeEach(function() {
+    jest.resetModules();
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop};
+  }
+
+  function text(val) {
+    return {text: val};
+  }
+
+  function div(...children) {
+    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
+    return {type: 'div', children, prop: undefined};
+  }
+
+  it('should render a single child via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        <span>foo</span>
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([span()]);
+  });
+
+  it('should render zero children via noop renderer', () => {
+    const element = <React.Fragment />;
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([]);
+  });
+
+  it('should render multiple children via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        hello <span>world</span>
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
+  });
+
+  it('should render an iterable via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
+  });
+
+  it('should preserve state of children with 1 level nesting', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <Stateful key="a" />
+            <div key="b">World</div>
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between top-level fragments', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment>
+            <Stateful />
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state of children nested at same level', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment>
+              <React.Fragment>
+                <Stateful key="a" />
+              </React.Fragment>
+            </React.Fragment>
+          </React.Fragment>
+        : <React.Fragment>
+            <React.Fragment>
+              <React.Fragment>
+                <div />
+                <Stateful key="a" />
+              </React.Fragment>
+            </React.Fragment>
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state in non-top-level fragment nesting', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>
+        : <React.Fragment><Stateful key="a" /></React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children if nested 2 levels without siblings', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children if nested 2 levels with siblings', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+            <div />
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between array nested in fragment and fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        : <React.Fragment>
+            {[<Stateful key="a" />]}
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between top level fragment and array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? [<Stateful key="a" />]
+        : <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between array nested in fragment and double nested fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        : <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between array nested in fragment and double nested array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        : [[<Stateful key="a" />]];
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between double nested fragment and double nested array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>
+        : [[<Stateful key="a" />]];
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children when the keys are different', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment key="a">
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment key="b">
+            <Stateful />
+            <span>World</span>
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between unkeyed and keyed fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment key="a">
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment>
+            <Stateful />
+          </React.Fragment>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state with reordering in multiple levels', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <div>
+            <React.Fragment key="c">
+              <span>foo</span>
+              <div key="b">
+                <Stateful key="a" />
+              </div>
+            </React.Fragment>
+            <span>boop</span>
+          </div>
+        : <div>
+            <span>beep</span>
+            <React.Fragment key="c">
+              <div key="b">
+                <Stateful key="a" />
+              </div>
+              <span>bar</span>
+            </React.Fragment>
+          </div>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+  });
+
+  it('should not preserve state when switching to a keyed fragment to an array', function() {
+    spyOn(console, 'error');
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? <div>
+            {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
+          </div>
+        : <div>{[<Stateful />]}<span /></div>;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
+  });
+
+  it('should preserve state when it does not change positions', function() {
+    spyOn(console, 'error');
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
+        : [<span />, <React.Fragment><Stateful /></React.Fragment>];
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    expectDev(console.error.calls.count()).toBe(3);
+    for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
+      expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
+        'Each child in an array or iterator should have a unique "key" prop.',
+      );
+    }
+  });
+});

commit 0e15ff5669271f5f5956e30a4fe1ae5963778e89
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Oct 31 17:43:55 2017 -0700

    Put React.Fragment under a feature flag (#11421)
    
    * Put React.Fragment under a feature flag
    
    * Don't export undefined Fragment

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 2083d8643c..1cc66a8d0c 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -8,6 +8,8 @@
  */
 'use strict';
 
+var ReactFeatureFlags = require('shared/ReactFeatureFlags');
+
 let React;
 let ReactNoop;
 
@@ -31,691 +33,699 @@ describe('ReactFragment', () => {
     return {type: 'div', children, prop: undefined};
   }
 
-  it('should render a single child via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        <span>foo</span>
-      </React.Fragment>
-    );
+  if (ReactFeatureFlags.enableReactFragment) {
+    it('should render a single child via noop renderer', () => {
+      const element = (
+        <React.Fragment>
+          <span>foo</span>
+        </React.Fragment>
+      );
 
-    ReactNoop.render(element);
-    ReactNoop.flush();
+      ReactNoop.render(element);
+      ReactNoop.flush();
 
-    expect(ReactNoop.getChildren()).toEqual([span()]);
-  });
+      expect(ReactNoop.getChildren()).toEqual([span()]);
+    });
 
-  it('should render zero children via noop renderer', () => {
-    const element = <React.Fragment />;
+    it('should render zero children via noop renderer', () => {
+      const element = <React.Fragment />;
 
-    ReactNoop.render(element);
-    ReactNoop.flush();
+      ReactNoop.render(element);
+      ReactNoop.flush();
 
-    expect(ReactNoop.getChildren()).toEqual([]);
-  });
+      expect(ReactNoop.getChildren()).toEqual([]);
+    });
 
-  it('should render multiple children via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        hello <span>world</span>
-      </React.Fragment>
-    );
+    it('should render multiple children via noop renderer', () => {
+      const element = (
+        <React.Fragment>
+          hello <span>world</span>
+        </React.Fragment>
+      );
 
-    ReactNoop.render(element);
-    ReactNoop.flush();
+      ReactNoop.render(element);
+      ReactNoop.flush();
 
-    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
-  });
+      expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
+    });
 
-  it('should render an iterable via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
-      </React.Fragment>
-    );
+    it('should render an iterable via noop renderer', () => {
+      const element = (
+        <React.Fragment>
+          {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
+        </React.Fragment>
+      );
 
-    ReactNoop.render(element);
-    ReactNoop.flush();
+      ReactNoop.render(element);
+      ReactNoop.flush();
 
-    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
-  });
+      expect(ReactNoop.getChildren()).toEqual([span(), span()]);
+    });
 
-  it('should preserve state of children with 1 level nesting', function() {
-    var ops = [];
+    it('should preserve state of children with 1 level nesting', function() {
+      var ops = [];
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
+
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <Stateful key="a" />
+          : <React.Fragment>
+              <Stateful key="a" />
+              <div key="b">World</div>
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <Stateful key="a" />
-            <div key="b">World</div>
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should preserve state between top-level fragments', function() {
+      var ops = [];
 
-  it('should preserve state between top-level fragments', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>
+              <Stateful />
+            </React.Fragment>
+          : <React.Fragment>
+              <Stateful />
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment>
-            <Stateful />
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state of children nested at same level', function() {
-    var ops = [];
+    it('should preserve state of children nested at same level', function() {
+      var ops = [];
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-      render() {
-        return <div>Hello</div>;
+        render() {
+          return <div>Hello</div>;
+        }
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <React.Fragment>
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>
               <React.Fragment>
-                <Stateful key="a" />
+                <React.Fragment>
+                  <Stateful key="a" />
+                </React.Fragment>
               </React.Fragment>
             </React.Fragment>
-          </React.Fragment>
-        : <React.Fragment>
-            <React.Fragment>
+          : <React.Fragment>
               <React.Fragment>
-                <div />
-                <Stateful key="a" />
+                <React.Fragment>
+                  <div />
+                  <Stateful key="a" />
+                </React.Fragment>
               </React.Fragment>
-            </React.Fragment>
-          </React.Fragment>;
-    }
+            </React.Fragment>;
+      }
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-  it('should not preserve state in non-top-level fragment nesting', function() {
-    var ops = [];
+    it('should not preserve state in non-top-level fragment nesting', function() {
+      var ops = [];
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
+
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>
+              <React.Fragment><Stateful key="a" /></React.Fragment>
+            </React.Fragment>
+          : <React.Fragment><Stateful key="a" /></React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
-          </React.Fragment>
-        : <React.Fragment><Stateful key="a" /></React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state of children if nested 2 levels without siblings', function() {
+      var ops = [];
 
-  it('should not preserve state of children if nested 2 levels without siblings', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <Stateful key="a" />
+          : <React.Fragment>
+              <React.Fragment>
+                <Stateful key="a" />
+              </React.Fragment>
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state of children if nested 2 levels with siblings', function() {
+      var ops = [];
 
-  it('should not preserve state of children if nested 2 levels with siblings', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <Stateful key="a" />
+          : <React.Fragment>
+              <React.Fragment>
+                <Stateful key="a" />
+              </React.Fragment>
+              <div />
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-            <div />
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should preserve state between array nested in fragment and fragment', function() {
+      var ops = [];
 
-  it('should preserve state between array nested in fragment and fragment', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+          : <React.Fragment>
+              {[<Stateful key="a" />]}
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        : <React.Fragment>
-            {[<Stateful key="a" />]}
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should preserve state between top level fragment and array', function() {
+      var ops = [];
 
-  it('should preserve state between top level fragment and array', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? [<Stateful key="a" />]
+          : <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? [<Stateful key="a" />]
-        : <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state between array nested in fragment and double nested fragment', function() {
+      var ops = [];
 
-  it('should not preserve state between array nested in fragment and double nested fragment', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+          : <React.Fragment>
+              <React.Fragment><Stateful key="a" /></React.Fragment>
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-        : <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state between array nested in fragment and double nested array', function() {
+      var ops = [];
 
-  it('should not preserve state between array nested in fragment and double nested array', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+          : [[<Stateful key="a" />]];
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-        : [[<Stateful key="a" />]];
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should preserve state between double nested fragment and double nested array', function() {
+      var ops = [];
 
-  it('should preserve state between double nested fragment and double nested array', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment>
+              <React.Fragment><Stateful key="a" /></React.Fragment>
+            </React.Fragment>
+          : [[<Stateful key="a" />]];
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
-          </React.Fragment>
-        : [[<Stateful key="a" />]];
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state of children when the keys are different', function() {
+      var ops = [];
 
-  it('should not preserve state of children when the keys are different', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment key="a">
+              <Stateful />
+            </React.Fragment>
+          : <React.Fragment key="b">
+              <Stateful />
+              <span>World</span>
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment key="a">
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment key="b">
-            <Stateful />
-            <span>World</span>
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div(), span()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should not preserve state between unkeyed and keyed fragment', function() {
+      var ops = [];
 
-  it('should not preserve state between unkeyed and keyed fragment', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <React.Fragment key="a">
+              <Stateful />
+            </React.Fragment>
+          : <React.Fragment>
+              <Stateful />
+            </React.Fragment>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <React.Fragment key="a">
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment>
-            <Stateful />
-          </React.Fragment>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div()]);
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
+    it('should preserve state with reordering in multiple levels', function() {
+      var ops = [];
 
-  it('should preserve state with reordering in multiple levels', function() {
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <div>
+              <React.Fragment key="c">
+                <span>foo</span>
+                <div key="b">
+                  <Stateful key="a" />
+                </div>
+              </React.Fragment>
+              <span>boop</span>
+            </div>
+          : <div>
+              <span>beep</span>
+              <React.Fragment key="c">
+                <div key="b">
+                  <Stateful key="a" />
+                </div>
+                <span>bar</span>
+              </React.Fragment>
+            </div>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <div>
-            <React.Fragment key="c">
-              <span>foo</span>
-              <div key="b">
-                <Stateful key="a" />
-              </div>
-            </React.Fragment>
-            <span>boop</span>
-          </div>
-        : <div>
-            <span>beep</span>
-            <React.Fragment key="c">
-              <div key="b">
-                <Stateful key="a" />
-              </div>
-              <span>bar</span>
-            </React.Fragment>
-          </div>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([
+        div(span(), div(div()), span()),
+      ]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([
+        div(span(), div(div()), span()),
+      ]);
+    });
 
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
-  });
+    it('should not preserve state when switching to a keyed fragment to an array', function() {
+      spyOn(console, 'error');
+      var ops = [];
 
-  it('should not preserve state when switching to a keyed fragment to an array', function() {
-    spyOn(console, 'error');
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? <div>
+              {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
+            </div>
+          : <div>{[<Stateful />]}<span /></div>;
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? <div>
-            {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
-          </div>
-        : <div>{[<Stateful />]}<span /></div>;
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      expect(ops).toEqual([]);
+      expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+      expectDev(console.error.calls.count()).toBe(1);
+      expectDev(console.error.calls.argsFor(0)[0]).toContain(
+        'Each child in an array or iterator should have a unique "key" prop.',
+      );
+    });
 
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Each child in an array or iterator should have a unique "key" prop.',
-    );
-  });
+    it('should preserve state when it does not change positions', function() {
+      spyOn(console, 'error');
+      var ops = [];
 
-  it('should preserve state when it does not change positions', function() {
-    spyOn(console, 'error');
-    var ops = [];
+      class Stateful extends React.Component {
+        componentDidUpdate() {
+          ops.push('Update Stateful');
+        }
 
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
+        render() {
+          return <div>Hello</div>;
+        }
       }
 
-      render() {
-        return <div>Hello</div>;
+      function Foo({condition}) {
+        return condition
+          ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
+          : [<span />, <React.Fragment><Stateful /></React.Fragment>];
       }
-    }
 
-    function Foo({condition}) {
-      return condition
-        ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
-        : [<span />, <React.Fragment><Stateful /></React.Fragment>];
-    }
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+      ReactNoop.render(<Foo condition={false} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+      expect(ops).toEqual(['Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+      ReactNoop.render(<Foo condition={true} />);
+      ReactNoop.flush();
 
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-    expectDev(console.error.calls.count()).toBe(3);
-    for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
-      expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
-        'Each child in an array or iterator should have a unique "key" prop.',
-      );
-    }
-  });
+      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+      expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+      expectDev(console.error.calls.count()).toBe(3);
+      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
+        expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
+          'Each child in an array or iterator should have a unique "key" prop.',
+        );
+      }
+    });
+  } else {
+    it('should not run any tests', function() {});
+  }
 });

commit 983ec907649be4259ecbc7241c5ab7a43a9cecf5
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 2 13:31:17 2017 +0000

    Always run React.Fragment tests (#11430)

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 1cc66a8d0c..0a51937b4c 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -16,6 +16,10 @@ let ReactNoop;
 describe('ReactFragment', () => {
   beforeEach(function() {
     jest.resetModules();
+
+    const ReactFeatureFlags = require('shared/ReactFeatureFlags');
+    ReactFeatureFlags.enableReactFragment = true;
+
     React = require('react');
     ReactNoop = require('react-noop-renderer');
   });
@@ -33,699 +37,691 @@ describe('ReactFragment', () => {
     return {type: 'div', children, prop: undefined};
   }
 
-  if (ReactFeatureFlags.enableReactFragment) {
-    it('should render a single child via noop renderer', () => {
-      const element = (
-        <React.Fragment>
-          <span>foo</span>
-        </React.Fragment>
-      );
+  it('should render a single child via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        <span>foo</span>
+      </React.Fragment>
+    );
 
-      ReactNoop.render(element);
-      ReactNoop.flush();
+    ReactNoop.render(element);
+    ReactNoop.flush();
 
-      expect(ReactNoop.getChildren()).toEqual([span()]);
-    });
-
-    it('should render zero children via noop renderer', () => {
-      const element = <React.Fragment />;
+    expect(ReactNoop.getChildren()).toEqual([span()]);
+  });
 
-      ReactNoop.render(element);
-      ReactNoop.flush();
+  it('should render zero children via noop renderer', () => {
+    const element = <React.Fragment />;
 
-      expect(ReactNoop.getChildren()).toEqual([]);
-    });
+    ReactNoop.render(element);
+    ReactNoop.flush();
 
-    it('should render multiple children via noop renderer', () => {
-      const element = (
-        <React.Fragment>
-          hello <span>world</span>
-        </React.Fragment>
-      );
+    expect(ReactNoop.getChildren()).toEqual([]);
+  });
 
-      ReactNoop.render(element);
-      ReactNoop.flush();
+  it('should render multiple children via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        hello <span>world</span>
+      </React.Fragment>
+    );
 
-      expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
-    });
+    ReactNoop.render(element);
+    ReactNoop.flush();
 
-    it('should render an iterable via noop renderer', () => {
-      const element = (
-        <React.Fragment>
-          {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
-        </React.Fragment>
-      );
+    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
+  });
 
-      ReactNoop.render(element);
-      ReactNoop.flush();
+  it('should render an iterable via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
+      </React.Fragment>
+    );
 
-      expect(ReactNoop.getChildren()).toEqual([span(), span()]);
-    });
+    ReactNoop.render(element);
+    ReactNoop.flush();
 
-    it('should preserve state of children with 1 level nesting', function() {
-      var ops = [];
+    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state of children with 1 level nesting', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <Stateful key="a" />
-          : <React.Fragment>
-              <Stateful key="a" />
-              <div key="b">World</div>
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <Stateful key="a" />
+            <div key="b">World</div>
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state between top-level fragments', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state between top-level fragments', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>
-              <Stateful />
-            </React.Fragment>
-          : <React.Fragment>
-              <Stateful />
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment>
+            <Stateful />
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state of children nested at same level', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state of children nested at same level', function() {
+    var ops = [];
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
 
-        render() {
-          return <div>Hello</div>;
-        }
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment>
               <React.Fragment>
-                <React.Fragment>
-                  <Stateful key="a" />
-                </React.Fragment>
+                <Stateful key="a" />
               </React.Fragment>
             </React.Fragment>
-          : <React.Fragment>
+          </React.Fragment>
+        : <React.Fragment>
+            <React.Fragment>
               <React.Fragment>
-                <React.Fragment>
-                  <div />
-                  <Stateful key="a" />
-                </React.Fragment>
+                <div />
+                <Stateful key="a" />
               </React.Fragment>
-            </React.Fragment>;
-      }
-
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+            </React.Fragment>
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state in non-top-level fragment nesting', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state in non-top-level fragment nesting', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>
-              <React.Fragment><Stateful key="a" /></React.Fragment>
-            </React.Fragment>
-          : <React.Fragment><Stateful key="a" /></React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>
+        : <React.Fragment><Stateful key="a" /></React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state of children if nested 2 levels without siblings', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state of children if nested 2 levels without siblings', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <Stateful key="a" />
-          : <React.Fragment>
-              <React.Fragment>
-                <Stateful key="a" />
-              </React.Fragment>
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state of children if nested 2 levels with siblings', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state of children if nested 2 levels with siblings', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <Stateful key="a" />
-          : <React.Fragment>
-              <React.Fragment>
-                <Stateful key="a" />
-              </React.Fragment>
-              <div />
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <Stateful key="a" />
+        : <React.Fragment>
+            <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+            <div />
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state between array nested in fragment and fragment', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state between array nested in fragment and fragment', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-          : <React.Fragment>
-              {[<Stateful key="a" />]}
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        : <React.Fragment>
+            {[<Stateful key="a" />]}
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state between top level fragment and array', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state between top level fragment and array', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? [<Stateful key="a" />]
-          : <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? [<Stateful key="a" />]
+        : <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state between array nested in fragment and double nested fragment', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state between array nested in fragment and double nested fragment', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-          : <React.Fragment>
-              <React.Fragment><Stateful key="a" /></React.Fragment>
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        : <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state between array nested in fragment and double nested array', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state between array nested in fragment and double nested array', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-          : [[<Stateful key="a" />]];
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        : [[<Stateful key="a" />]];
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state between double nested fragment and double nested array', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state between double nested fragment and double nested array', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment>
-              <React.Fragment><Stateful key="a" /></React.Fragment>
-            </React.Fragment>
-          : [[<Stateful key="a" />]];
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment>
+            <React.Fragment><Stateful key="a" /></React.Fragment>
+          </React.Fragment>
+        : [[<Stateful key="a" />]];
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state of children when the keys are different', function() {
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state of children when the keys are different', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment key="a">
-              <Stateful />
-            </React.Fragment>
-          : <React.Fragment key="b">
-              <Stateful />
-              <span>World</span>
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment key="a">
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment key="b">
+            <Stateful />
+            <span>World</span>
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div(), span()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state between unkeyed and keyed fragment', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state between unkeyed and keyed fragment', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <React.Fragment key="a">
-              <Stateful />
-            </React.Fragment>
-          : <React.Fragment>
-              <Stateful />
-            </React.Fragment>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <React.Fragment key="a">
+            <Stateful />
+          </React.Fragment>
+        : <React.Fragment>
+            <Stateful />
+          </React.Fragment>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div()]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state with reordering in multiple levels', function() {
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state with reordering in multiple levels', function() {
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <div>
-              <React.Fragment key="c">
-                <span>foo</span>
-                <div key="b">
-                  <Stateful key="a" />
-                </div>
-              </React.Fragment>
-              <span>boop</span>
-            </div>
-          : <div>
-              <span>beep</span>
-              <React.Fragment key="c">
-                <div key="b">
-                  <Stateful key="a" />
-                </div>
-                <span>bar</span>
-              </React.Fragment>
-            </div>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <div>
+            <React.Fragment key="c">
+              <span>foo</span>
+              <div key="b">
+                <Stateful key="a" />
+              </div>
+            </React.Fragment>
+            <span>boop</span>
+          </div>
+        : <div>
+            <span>beep</span>
+            <React.Fragment key="c">
+              <div key="b">
+                <Stateful key="a" />
+              </div>
+              <span>bar</span>
+            </React.Fragment>
+          </div>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([
-        div(span(), div(div()), span()),
-      ]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([
-        div(span(), div(div()), span()),
-      ]);
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should not preserve state when switching to a keyed fragment to an array', function() {
-      spyOn(console, 'error');
-      var ops = [];
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should not preserve state when switching to a keyed fragment to an array', function() {
+    spyOn(console, 'error');
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? <div>
-              {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
-            </div>
-          : <div>{[<Stateful />]}<span /></div>;
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? <div>
+            {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
+          </div>
+        : <div>{[<Stateful />]}<span /></div>;
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
 
-      expect(ops).toEqual([]);
-      expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-      expectDev(console.error.calls.count()).toBe(1);
-      expectDev(console.error.calls.argsFor(0)[0]).toContain(
-        'Each child in an array or iterator should have a unique "key" prop.',
-      );
-    });
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-    it('should preserve state when it does not change positions', function() {
-      spyOn(console, 'error');
-      var ops = [];
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    expectDev(console.error.calls.count()).toBe(1);
+    expectDev(console.error.calls.argsFor(0)[0]).toContain(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
+  });
 
-      class Stateful extends React.Component {
-        componentDidUpdate() {
-          ops.push('Update Stateful');
-        }
+  it('should preserve state when it does not change positions', function() {
+    spyOn(console, 'error');
+    var ops = [];
 
-        render() {
-          return <div>Hello</div>;
-        }
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
       }
 
-      function Foo({condition}) {
-        return condition
-          ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
-          : [<span />, <React.Fragment><Stateful /></React.Fragment>];
+      render() {
+        return <div>Hello</div>;
       }
+    }
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    function Foo({condition}) {
+      return condition
+        ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
+        : [<span />, <React.Fragment><Stateful /></React.Fragment>];
+    }
 
-      ReactNoop.render(<Foo condition={false} />);
-      ReactNoop.flush();
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
 
-      expect(ops).toEqual(['Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
 
-      ReactNoop.render(<Foo condition={true} />);
-      ReactNoop.flush();
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
-      expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-      expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-      expectDev(console.error.calls.count()).toBe(3);
-      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
-        expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
-          'Each child in an array or iterator should have a unique "key" prop.',
-        );
-      }
-    });
-  } else {
-    it('should not run any tests', function() {});
-  }
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    expectDev(console.error.calls.count()).toBe(3);
+    for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
+      expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
+        'Each child in an array or iterator should have a unique "key" prop.',
+      );
+    }
+  });
 });

commit b98313f17626c95050c19b620acd1eb750d64641
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 2 14:07:20 2017 +0000

    Fix lint issues

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 0a51937b4c..90b4acc115 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -8,8 +8,6 @@
  */
 'use strict';
 
-var ReactFeatureFlags = require('shared/ReactFeatureFlags');
-
 let React;
 let ReactNoop;
 

commit 94f44aeba72eacb04443974c2c6c91a050d61b1c
Author: Clement Hoang <clement.hoang24@gmail.com>
Date:   Tue Nov 7 18:09:33 2017 +0000

    Update prettier to 1.8.1 (#10785)
    
    * Change prettier dependency in package.json version 1.8.1
    
    * Update yarn.lock
    
    * Apply prettier changes
    
    * Fix ReactDOMServerIntegration-test.js
    
    * Fix test for ReactDOMComponent-test.js

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 90b4acc115..4cbbed760f 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -97,12 +97,14 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <Stateful key="a" />
-            <div key="b">World</div>
-          </React.Fragment>;
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+          <div key="b">World</div>
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -135,13 +137,15 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment>
-            <Stateful />
-          </React.Fragment>;
+      return condition ? (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -174,22 +178,24 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
             <React.Fragment>
-              <React.Fragment>
-                <Stateful key="a" />
-              </React.Fragment>
+              <Stateful key="a" />
             </React.Fragment>
           </React.Fragment>
-        : <React.Fragment>
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
             <React.Fragment>
-              <React.Fragment>
-                <div />
-                <Stateful key="a" />
-              </React.Fragment>
+              <div />
+              <Stateful key="a" />
             </React.Fragment>
-          </React.Fragment>;
+          </React.Fragment>
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -222,11 +228,17 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
           </React.Fragment>
-        : <React.Fragment><Stateful key="a" /></React.Fragment>;
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -259,13 +271,15 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>;
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -298,14 +312,16 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <Stateful key="a" />
-        : <React.Fragment>
-            <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-            <div />
-          </React.Fragment>;
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+          <div />
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -338,13 +354,13 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        : <React.Fragment>
-            {[<Stateful key="a" />]}
-          </React.Fragment>;
+      return condition ? (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -377,11 +393,13 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? [<Stateful key="a" />]
-        : <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>;
+      return condition ? (
+        [<Stateful key="a" />]
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -414,11 +432,15 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-        : <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
-          </React.Fragment>;
+      return condition ? (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -451,9 +473,11 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-        : [[<Stateful key="a" />]];
+      return condition ? (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      ) : (
+        [[<Stateful key="a" />]]
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -486,11 +510,15 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment>
-            <React.Fragment><Stateful key="a" /></React.Fragment>
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
           </React.Fragment>
-        : [[<Stateful key="a" />]];
+        </React.Fragment>
+      ) : (
+        [[<Stateful key="a" />]]
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -523,14 +551,16 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment key="a">
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment key="b">
-            <Stateful />
-            <span>World</span>
-          </React.Fragment>;
+      return condition ? (
+        <React.Fragment key="a">
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment key="b">
+          <Stateful />
+          <span>World</span>
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -563,13 +593,15 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <React.Fragment key="a">
-            <Stateful />
-          </React.Fragment>
-        : <React.Fragment>
-            <Stateful />
-          </React.Fragment>;
+      return condition ? (
+        <React.Fragment key="a">
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -602,25 +634,27 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <div>
-            <React.Fragment key="c">
-              <span>foo</span>
-              <div key="b">
-                <Stateful key="a" />
-              </div>
-            </React.Fragment>
-            <span>boop</span>
-          </div>
-        : <div>
-            <span>beep</span>
-            <React.Fragment key="c">
-              <div key="b">
-                <Stateful key="a" />
-              </div>
-              <span>bar</span>
-            </React.Fragment>
-          </div>;
+      return condition ? (
+        <div>
+          <React.Fragment key="c">
+            <span>foo</span>
+            <div key="b">
+              <Stateful key="a" />
+            </div>
+          </React.Fragment>
+          <span>boop</span>
+        </div>
+      ) : (
+        <div>
+          <span>beep</span>
+          <React.Fragment key="c">
+            <div key="b">
+              <Stateful key="a" />
+            </div>
+            <span>bar</span>
+          </React.Fragment>
+        </div>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -654,11 +688,21 @@ describe('ReactFragment', () => {
     }
 
     function Foo({condition}) {
-      return condition
-        ? <div>
-            {<React.Fragment key="foo"><Stateful /></React.Fragment>}<span />
-          </div>
-        : <div>{[<Stateful />]}<span /></div>;
+      return condition ? (
+        <div>
+          {
+            <React.Fragment key="foo">
+              <Stateful />
+            </React.Fragment>
+          }
+          <span />
+        </div>
+      ) : (
+        <div>
+          {[<Stateful />]}
+          <span />
+        </div>
+      );
     }
 
     ReactNoop.render(<Foo condition={true} />);
@@ -697,8 +741,18 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition
-        ? [<span />, <React.Fragment><Stateful /></React.Fragment>]
-        : [<span />, <React.Fragment><Stateful /></React.Fragment>];
+        ? [
+            <span />,
+            <React.Fragment>
+              <Stateful />
+            </React.Fragment>,
+          ]
+        : [
+            <span />,
+            <React.Fragment>
+              <Stateful />
+            </React.Fragment>,
+          ];
     }
 
     ReactNoop.render(<Foo condition={true} />);

commit 6041f481b7851d75649630eea489628d399cc3cf
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Nov 22 13:02:26 2017 +0000

    Run Jest in production mode (#11616)
    
    * Move Jest setup files to /dev/ subdirectory
    
    * Clone Jest /dev/ files into /prod/
    
    * Move shared code into scripts/jest
    
    * Move Jest config into the scripts folder
    
    * Fix the equivalence test
    
    It fails because the config is now passed to Jest explicitly.
    But the test doesn't know about the config.
    
    To fix this, we just run it via `yarn test` (which includes the config).
    We already depend on Yarn for development anyway.
    
    * Add yarn test-prod to run Jest with production environment
    
    * Actually flip the production tests to run in prod environment
    
    This produces a bunch of errors:
    
    Test Suites: 64 failed, 58 passed, 122 total
    Tests:       740 failed, 26 skipped, 1809 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Ignore expectDev() calls in production
    
    Down from 740 to 175 failed.
    
    Test Suites: 44 failed, 78 passed, 122 total
    Tests:       175 failed, 26 skipped, 2374 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Decode errors so tests can assert on their messages
    
    Down from 175 to 129.
    
    Test Suites: 33 failed, 89 passed, 122 total
    Tests:       129 failed, 1029 skipped, 1417 passed, 2575 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Remove ReactDOMProduction-test
    
    There is no need for it now. The only test that was special is moved into ReactDOM-test.
    
    * Remove production switches from ReactErrorUtils
    
    The tests now run in production in a separate pass.
    
    * Add and use spyOnDev() for warnings
    
    This ensures that by default we expect no warnings in production bundles.
    If the warning *is* expected, use the regular spyOn() method.
    
    This currently breaks all expectDev() assertions without __DEV__ blocks so we go back to:
    
    Test Suites: 56 failed, 65 passed, 121 total
    Tests:       379 failed, 1029 skipped, 1148 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Replace expectDev() with expect() in __DEV__ blocks
    
    We started using spyOnDev() for console warnings to ensure we don't *expect* them to occur in production. As a consequence, expectDev() assertions on console.error.calls fail because console.error.calls doesn't exist. This is actually good because it would help catch accidental warnings in production.
    
    To solve this, we are getting rid of expectDev() altogether, and instead introduce explicit expectation branches. We'd need them anyway for testing intentional behavior differences.
    
    This commit replaces all expectDev() calls with expect() calls in __DEV__ blocks. It also removes a few unnecessary expect() checks that no warnings were produced (by also removing the corresponding spyOnDev() calls).
    
    Some DEV-only assertions used plain expect(). Those were also moved into __DEV__ blocks.
    
    ReactFiberErrorLogger was special because it console.error()'s in production too. So in that case I intentionally used spyOn() instead of spyOnDev(), and added extra assertions.
    
    This gets us down to:
    
    Test Suites: 21 failed, 100 passed, 121 total
    Tests:       72 failed, 26 skipped, 2458 passed, 2556 total
    Snapshots:   16 failed, 4 passed, 20 total
    
    * Enable User Timing API for production testing
    
    We could've disabled it, but seems like a good idea to test since we use it at FB.
    
    * Test for explicit Object.freeze() differences between PROD and DEV
    
    This is one of the few places where DEV and PROD behavior differs for performance reasons.
    Now we explicitly test both branches.
    
    * Run Jest via "yarn test" on CI
    
    * Remove unused variable
    
    * Assert different error messages
    
    * Fix error handling tests
    
    This logic is really complicated because of the global ReactFiberErrorLogger mock.
    I understand it now, so I added TODOs for later.
    
    It can be much simpler if we change the rest of the tests that assert uncaught errors to also assert they are logged as warnings.
    Which mirrors what happens in practice anyway.
    
    * Fix more assertions
    
    * Change tests to document the DEV/PROD difference for state invariant
    
    It is very likely unintentional but I don't want to change behavior in this PR.
    Filed a follow up as https://github.com/facebook/react/issues/11618.
    
    * Remove unnecessary split between DEV/PROD ref tests
    
    * Fix more test message assertions
    
    * Make validateDOMNesting tests DEV-only
    
    * Fix error message assertions
    
    * Document existing DEV/PROD message difference (possible bug)
    
    * Change mocking assertions to be DEV-only
    
    * Fix the error code test
    
    * Fix more error message assertions
    
    * Fix the last failing test due to known issue
    
    * Run production tests on CI
    
    * Unify configuration
    
    * Fix coverage script
    
    * Remove expectDev from eslintrc
    
    * Run everything in band
    
    We used to before, too. I just forgot to add the arguments after deleting the script.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 4cbbed760f..9751a1e66f 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -674,7 +674,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state when switching to a keyed fragment to an array', function() {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     var ops = [];
 
     class Stateful extends React.Component {
@@ -719,14 +719,16 @@ describe('ReactFragment', () => {
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-    expectDev(console.error.calls.count()).toBe(1);
-    expectDev(console.error.calls.argsFor(0)[0]).toContain(
-      'Each child in an array or iterator should have a unique "key" prop.',
-    );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Each child in an array or iterator should have a unique "key" prop.',
+      );
+    }
   });
 
   it('should preserve state when it does not change positions', function() {
-    spyOn(console, 'error');
+    spyOnDev(console, 'error');
     var ops = [];
 
     class Stateful extends React.Component {
@@ -769,11 +771,13 @@ describe('ReactFragment', () => {
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-    expectDev(console.error.calls.count()).toBe(3);
-    for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
-      expectDev(console.error.calls.argsFor(errorIndex)[0]).toContain(
-        'Each child in an array or iterator should have a unique "key" prop.',
-      );
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(3);
+      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
+        expect(console.error.calls.argsFor(errorIndex)[0]).toContain(
+          'Each child in an array or iterator should have a unique "key" prop.',
+        );
+      }
     }
   });
 });

commit fa7a97fc46935e1611d52da2fdb7d53f6ab9577d
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Nov 23 17:44:58 2017 +0000

    Run 90% of tests on compiled bundles (both development and production) (#11633)
    
    * Extract Jest config into a separate file
    
    * Refactor Jest scripts directory structure
    
    Introduces a more consistent naming scheme.
    
    * Add yarn test-bundles and yarn test-prod-bundles
    
    Only files ending with -test.public.js are opted in (so far we don't have any).
    
    * Fix error decoding for production bundles
    
    GCC seems to remove `new` from `new Error()` which broke our proxy.
    
    * Build production version of react-noop-renderer
    
    This lets us test more bundles.
    
    * Switch to blacklist (exclude .private.js tests)
    
    * Rename tests that are currently broken against bundles to *-test.internal.js
    
    Some of these are using private APIs. Some have other issues.
    
    * Add bundle tests to CI
    
    * Split private and public ReactJSXElementValidator tests
    
    * Remove internal deps from ReactServerRendering-test and make it public
    
    * Only run tests directly in __tests__
    
    This lets us share code between test files by placing them in __tests__/utils.
    
    * Remove ExecutionEnvironment dependency from DOMServerIntegrationTest
    
    It's not necessary since Stack.
    
    * Split up ReactDOMServerIntegration into test suite and utilities
    
    This enables us to further split it down. Good both for parallelization and extracting public parts.
    
    * Split Fragment tests from other DOMServerIntegration tests
    
    This enables them to opt other DOMServerIntegration tests into bundle testing.
    
    * Split ReactDOMServerIntegration into different test files
    
    It was way too slow to run all these in sequence.
    
    * Don't reset the cache twice in DOMServerIntegration tests
    
    We used to do this to simulate testing separate bundles.
    But now we actually *do* test bundles. So there is no need for this, as it makes tests slower.
    
    * Rename test-bundles* commands to test-build*
    
    Also add test-prod-build as alias for test-build-prod because I keep messing them up.
    
    * Use regenerator polyfill for react-noop
    
    This fixes other issues and finally lets us run ReactNoop tests against a prod bundle.
    
    * Run most Incremental tests against bundles
    
    Now that GCC generator issue is fixed, we can do this.
    I split ErrorLogging test separately because it does mocking. Other error handling tests don't need it.
    
    * Update sizes
    
    * Fix ReactMount test
    
    * Enable ReactDOMComponent test
    
    * Fix a warning issue uncovered by flat bundle testing
    
    With flat bundles, we couldn't produce a good warning for <div onclick={}> on SSR
    because it doesn't use the event system. However the issue was not visible in normal
    Jest runs because the event plugins have been injected by the time the test ran.
    
    To solve this, I am explicitly passing whether event system is available as an argument
    to the hook. This makes the behavior consistent between source and bundle tests. Then
    I change the tests to document the actual logic and _attempt_ to show a nice message
    (e.g. we know for sure `onclick` is a bad event but we don't know the right name for it
    on the server so we just say a generic message about camelCase naming convention).

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
deleted file mode 100644
index 9751a1e66f..0000000000
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ /dev/null
@@ -1,783 +0,0 @@
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- *
- * @emails react-core
- */
-'use strict';
-
-let React;
-let ReactNoop;
-
-describe('ReactFragment', () => {
-  beforeEach(function() {
-    jest.resetModules();
-
-    const ReactFeatureFlags = require('shared/ReactFeatureFlags');
-    ReactFeatureFlags.enableReactFragment = true;
-
-    React = require('react');
-    ReactNoop = require('react-noop-renderer');
-  });
-
-  function span(prop) {
-    return {type: 'span', children: [], prop};
-  }
-
-  function text(val) {
-    return {text: val};
-  }
-
-  function div(...children) {
-    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
-    return {type: 'div', children, prop: undefined};
-  }
-
-  it('should render a single child via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        <span>foo</span>
-      </React.Fragment>
-    );
-
-    ReactNoop.render(element);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([span()]);
-  });
-
-  it('should render zero children via noop renderer', () => {
-    const element = <React.Fragment />;
-
-    ReactNoop.render(element);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([]);
-  });
-
-  it('should render multiple children via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        hello <span>world</span>
-      </React.Fragment>
-    );
-
-    ReactNoop.render(element);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
-  });
-
-  it('should render an iterable via noop renderer', () => {
-    const element = (
-      <React.Fragment>
-        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
-      </React.Fragment>
-    );
-
-    ReactNoop.render(element);
-    ReactNoop.flush();
-
-    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
-  });
-
-  it('should preserve state of children with 1 level nesting', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <Stateful key="a" />
-      ) : (
-        <React.Fragment>
-          <Stateful key="a" />
-          <div key="b">World</div>
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state between top-level fragments', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>
-          <Stateful />
-        </React.Fragment>
-      ) : (
-        <React.Fragment>
-          <Stateful />
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state of children nested at same level', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>
-          <React.Fragment>
-            <React.Fragment>
-              <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>
-        </React.Fragment>
-      ) : (
-        <React.Fragment>
-          <React.Fragment>
-            <React.Fragment>
-              <div />
-              <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state in non-top-level fragment nesting', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>
-          <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
-      ) : (
-        <React.Fragment>
-          <Stateful key="a" />
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state of children if nested 2 levels without siblings', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <Stateful key="a" />
-      ) : (
-        <React.Fragment>
-          <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state of children if nested 2 levels with siblings', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <Stateful key="a" />
-      ) : (
-        <React.Fragment>
-          <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-          <div />
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state between array nested in fragment and fragment', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>
-          <Stateful key="a" />
-        </React.Fragment>
-      ) : (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state between top level fragment and array', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        [<Stateful key="a" />]
-      ) : (
-        <React.Fragment>
-          <Stateful key="a" />
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state between array nested in fragment and double nested fragment', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-      ) : (
-        <React.Fragment>
-          <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state between array nested in fragment and double nested array', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
-      ) : (
-        [[<Stateful key="a" />]]
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state between double nested fragment and double nested array', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment>
-          <React.Fragment>
-            <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
-      ) : (
-        [[<Stateful key="a" />]]
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state of children when the keys are different', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment key="a">
-          <Stateful />
-        </React.Fragment>
-      ) : (
-        <React.Fragment key="b">
-          <Stateful />
-          <span>World</span>
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should not preserve state between unkeyed and keyed fragment', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <React.Fragment key="a">
-          <Stateful />
-        </React.Fragment>
-      ) : (
-        <React.Fragment>
-          <Stateful />
-        </React.Fragment>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
-  });
-
-  it('should preserve state with reordering in multiple levels', function() {
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <div>
-          <React.Fragment key="c">
-            <span>foo</span>
-            <div key="b">
-              <Stateful key="a" />
-            </div>
-          </React.Fragment>
-          <span>boop</span>
-        </div>
-      ) : (
-        <div>
-          <span>beep</span>
-          <React.Fragment key="c">
-            <div key="b">
-              <Stateful key="a" />
-            </div>
-            <span>bar</span>
-          </React.Fragment>
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
-  });
-
-  it('should not preserve state when switching to a keyed fragment to an array', function() {
-    spyOnDev(console, 'error');
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition ? (
-        <div>
-          {
-            <React.Fragment key="foo">
-              <Stateful />
-            </React.Fragment>
-          }
-          <span />
-        </div>
-      ) : (
-        <div>
-          {[<Stateful />]}
-          <span />
-        </div>
-      );
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Each child in an array or iterator should have a unique "key" prop.',
-      );
-    }
-  });
-
-  it('should preserve state when it does not change positions', function() {
-    spyOnDev(console, 'error');
-    var ops = [];
-
-    class Stateful extends React.Component {
-      componentDidUpdate() {
-        ops.push('Update Stateful');
-      }
-
-      render() {
-        return <div>Hello</div>;
-      }
-    }
-
-    function Foo({condition}) {
-      return condition
-        ? [
-            <span />,
-            <React.Fragment>
-              <Stateful />
-            </React.Fragment>,
-          ]
-        : [
-            <span />,
-            <React.Fragment>
-              <Stateful />
-            </React.Fragment>,
-          ];
-    }
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-
-    ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
-
-    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(3);
-      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
-        expect(console.error.calls.argsFor(errorIndex)[0]).toContain(
-          'Each child in an array or iterator should have a unique "key" prop.',
-        );
-      }
-    }
-  });
-});

commit fe551de2731375f673799d845fb329e5c2846648
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Nov 27 21:44:13 2017 +0000

    Enable bundle tests for React.Fragment (#11673)

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
new file mode 100644
index 0000000000..65e416f839
--- /dev/null
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -0,0 +1,780 @@
+/**
+ * Copyright (c) 2013-present, Facebook, Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @emails react-core
+ */
+'use strict';
+
+let React;
+let ReactNoop;
+
+describe('ReactFragment', () => {
+  beforeEach(function() {
+    jest.resetModules();
+
+    React = require('react');
+    ReactNoop = require('react-noop-renderer');
+  });
+
+  function span(prop) {
+    return {type: 'span', children: [], prop};
+  }
+
+  function text(val) {
+    return {text: val};
+  }
+
+  function div(...children) {
+    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
+    return {type: 'div', children, prop: undefined};
+  }
+
+  it('should render a single child via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        <span>foo</span>
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([span()]);
+  });
+
+  it('should render zero children via noop renderer', () => {
+    const element = <React.Fragment />;
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([]);
+  });
+
+  it('should render multiple children via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        hello <span>world</span>
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
+  });
+
+  it('should render an iterable via noop renderer', () => {
+    const element = (
+      <React.Fragment>
+        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
+      </React.Fragment>
+    );
+
+    ReactNoop.render(element);
+    ReactNoop.flush();
+
+    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
+  });
+
+  it('should preserve state of children with 1 level nesting', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+          <div key="b">World</div>
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between top-level fragments', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state of children nested at same level', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
+            <React.Fragment>
+              <Stateful key="a" />
+            </React.Fragment>
+          </React.Fragment>
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <React.Fragment>
+              <div />
+              <Stateful key="a" />
+            </React.Fragment>
+          </React.Fragment>
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state in non-top-level fragment nesting', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children if nested 2 levels without siblings', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children if nested 2 levels with siblings', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <Stateful key="a" />
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+          <div />
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between array nested in fragment and fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between top level fragment and array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        [<Stateful key="a" />]
+      ) : (
+        <React.Fragment>
+          <Stateful key="a" />
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between array nested in fragment and double nested fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      ) : (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between array nested in fragment and double nested array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+      ) : (
+        [[<Stateful key="a" />]]
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state between double nested fragment and double nested array', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment>
+          <React.Fragment>
+            <Stateful key="a" />
+          </React.Fragment>
+        </React.Fragment>
+      ) : (
+        [[<Stateful key="a" />]]
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state of children when the keys are different', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment key="a">
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment key="b">
+          <Stateful />
+          <span>World</span>
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state between unkeyed and keyed fragment', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <React.Fragment key="a">
+          <Stateful />
+        </React.Fragment>
+      ) : (
+        <React.Fragment>
+          <Stateful />
+        </React.Fragment>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should preserve state with reordering in multiple levels', function() {
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <div>
+          <React.Fragment key="c">
+            <span>foo</span>
+            <div key="b">
+              <Stateful key="a" />
+            </div>
+          </React.Fragment>
+          <span>boop</span>
+        </div>
+      ) : (
+        <div>
+          <span>beep</span>
+          <React.Fragment key="c">
+            <div key="b">
+              <Stateful key="a" />
+            </div>
+            <span>bar</span>
+          </React.Fragment>
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+  });
+
+  it('should not preserve state when switching to a keyed fragment to an array', function() {
+    spyOnDev(console, 'error');
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <div>
+          {
+            <React.Fragment key="foo">
+              <Stateful />
+            </React.Fragment>
+          }
+          <span />
+        </div>
+      ) : (
+        <div>
+          {[<Stateful />]}
+          <span />
+        </div>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(1);
+      expect(console.error.calls.argsFor(0)[0]).toContain(
+        'Each child in an array or iterator should have a unique "key" prop.',
+      );
+    }
+  });
+
+  it('should preserve state when it does not change positions', function() {
+    spyOnDev(console, 'error');
+    var ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition
+        ? [
+            <span />,
+            <React.Fragment>
+              <Stateful />
+            </React.Fragment>,
+          ]
+        : [
+            <span />,
+            <React.Fragment>
+              <Stateful />
+            </React.Fragment>,
+          ];
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    ReactNoop.render(<Foo condition={false} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    ReactNoop.flush();
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    if (__DEV__) {
+      expect(console.error.calls.count()).toBe(3);
+      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
+        expect(console.error.calls.argsFor(errorIndex)[0]).toContain(
+          'Each child in an array or iterator should have a unique "key" prop.',
+        );
+      }
+    }
+  });
+});

commit 6074664f73c6b1ea1f774f2bc698224e3677cef0
Author: Raphael Amorim <rapha850@gmail.com>
Date:   Thu Nov 30 21:59:05 2017 -0200

    react-reconciler: convert vars into let/const (#11729)

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 65e416f839..00ae2aa2e9 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -81,7 +81,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state of children with 1 level nesting', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -121,7 +121,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state between top-level fragments', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -162,7 +162,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state of children nested at same level', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -212,7 +212,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state in non-top-level fragment nesting', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -255,7 +255,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state of children if nested 2 levels without siblings', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -296,7 +296,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state of children if nested 2 levels with siblings', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -338,7 +338,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state between array nested in fragment and fragment', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -377,7 +377,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state between top level fragment and array', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -416,7 +416,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state between array nested in fragment and double nested fragment', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -457,7 +457,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state between array nested in fragment and double nested array', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -494,7 +494,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state between double nested fragment and double nested array', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -535,7 +535,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state of children when the keys are different', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -577,7 +577,7 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state between unkeyed and keyed fragment', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -618,7 +618,7 @@ describe('ReactFragment', () => {
   });
 
   it('should preserve state with reordering in multiple levels', function() {
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -672,7 +672,7 @@ describe('ReactFragment', () => {
 
   it('should not preserve state when switching to a keyed fragment to an array', function() {
     spyOnDev(console, 'error');
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {
@@ -726,7 +726,7 @@ describe('ReactFragment', () => {
 
   it('should preserve state when it does not change positions', function() {
     spyOnDev(console, 'error');
-    var ops = [];
+    const ops = [];
 
     class Stateful extends React.Component {
       componentDidUpdate() {

commit 0deea326674077598e351803d7a204a1c744a578
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Tue Jan 2 18:42:18 2018 +0000

    Run some tests in Node environment (#11948)
    
    * Run some tests in Node environment
    
    * Separate SSR tests that require DOM
    
    This allow us to run others with Node environment.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 00ae2aa2e9..d8974c7efa 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -5,6 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  *
  * @emails react-core
+ * @jest-environment node
  */
 'use strict';
 

commit 9f848f8ebec30b3aaa4844ecaef83b014359c5e3
Author: Brian Vaughn <brian.david.vaughn@gmail.com>
Date:   Wed Jan 3 13:55:37 2018 -0800

    Update additional tests to use .toWarnDev() matcher (#11957)
    
    * Migrated several additional tests to use new .toWarnDev() matcher
    
    * Migrated ReactDOMComponent-test to use .toWarnDev() matcher
    
    Note this test previous had some hacky logic to verify errors were reported against unique line numbers. Since the new matcher doesn't suppor this, I replaced this check with an equivalent (I think) comparison of unique DOM elements (eg div -> span)
    
    * Updated several additional tests to use the new .toWarnDev() matcher
    
    * Updated many more tests to use .toWarnDev()
    
    * Updated several additional tests to use .toWarnDev() matcher
    
    * Updated ReactElementValidator to distinguish between Array and Object in its warning. Also updated its test to use .toWarnDev() matcher.
    
    * Updated a couple of additional tests
    
    * Removed unused normalizeCodeLocInfo() methods

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index d8974c7efa..9aa38b80a4 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -672,7 +672,6 @@ describe('ReactFragment', () => {
   });
 
   it('should not preserve state when switching to a keyed fragment to an array', function() {
-    spyOnDev(console, 'error');
     const ops = [];
 
     class Stateful extends React.Component {
@@ -707,7 +706,9 @@ describe('ReactFragment', () => {
     ReactNoop.flush();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
@@ -717,16 +718,9 @@ describe('ReactFragment', () => {
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(1);
-      expect(console.error.calls.argsFor(0)[0]).toContain(
-        'Each child in an array or iterator should have a unique "key" prop.',
-      );
-    }
   });
 
   it('should preserve state when it does not change positions', function() {
-    spyOnDev(console, 'error');
     const ops = [];
 
     class Stateful extends React.Component {
@@ -756,26 +750,24 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop.flush).toWarnDev(
+      'Each child in an array or iterator should have a unique "key" prop.',
+    );
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
-    if (__DEV__) {
-      expect(console.error.calls.count()).toBe(3);
-      for (let errorIndex = 0; errorIndex < 3; ++errorIndex) {
-        expect(console.error.calls.argsFor(errorIndex)[0]).toContain(
-          'Each child in an array or iterator should have a unique "key" prop.',
-        );
-      }
-    }
   });
 });

commit b87aabdfe1b7461e7331abb3601d9e6bb27544bc
Author: Héctor Ramos <165856+hramos@users.noreply.github.com>
Date:   Fri Sep 7 15:11:23 2018 -0700

    Drop the year from Facebook copyright headers and the LICENSE file. (#13593)

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 9aa38b80a4..9843d96e4a 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) 2013-present, Facebook, Inc.
+ * Copyright (c) Facebook, Inc. and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit dac9202a9c5add480f853bcad2ee04d371e72c0c
Author: Andrew Clark <github@andrewclark.io>
Date:   Thu Oct 18 15:37:16 2018 -0700

    Hide timed-out children instead of deleting them so their state is preserved (#13823)
    
    * Store the start time on `updateQueue` instead of `stateNode`
    
    Originally I did this to free the `stateNode` field to store a second
    set of children. I don't we'll need this anymore, since we use fragment
    fibers instead. But I still think using `updateQueue` makes more sense
    so I'll leave this in.
    
    * Use fragment fibers to keep the primary and fallback children separate
    
    If the children timeout, we switch to showing the fallback children in
    place of the "primary" children. However, we don't want to delete the
    primary children because then their state will be lost (both the React
    state and the host state, e.g. uncontrolled form inputs). Instead we
    keep them mounted and hide them. Both the fallback children AND the
    primary children are rendered at the same time. Once the primary
    children are un-suspended, we can delete the fallback children — don't
    need to preserve their state.
    
    The two sets of children are siblings in the host environment, but
    semantically, for purposes of reconciliation, they are two separate
    sets. So we store them using two fragment fibers.
    
    However, we want to avoid allocating extra fibers for every placeholder.
    They're only necessary when the children time out, because that's the
    only time when both sets are mounted.
    
    So, the extra fragment fibers are only used if the children time out.
    Otherwise, we render the primary children directly. This requires some
    custom reconciliation logic to preserve the state of the primary
    children. It's essentially a very basic form of re-parenting.
    
    * Use `memoizedState` to store various pieces of SuspenseComponent's state
    
    SuspenseComponent has three pieces of state:
    
    - alreadyCaptured: Whether a component in the child subtree already
    suspended. If true, subsequent suspends should bubble up to the
    next boundary.
    - didTimeout: Whether the boundary renders the primary or fallback
    children. This is separate from `alreadyCaptured` because outside of
    strict mode, when a boundary times out, the first commit renders the
    primary children in an incomplete state, then performs a second commit
    to switch the fallback. In that first commit, `alreadyCaptured` is
    false and `didTimeout` is true.
    - timedOutAt: The time at which the boundary timed out. This is separate
    from `didTimeout` because it's not set unless the boundary
    actually commits.
    
    
    These were previously spread across several fields.
    
    This happens to make the non-strict case a bit less hacky; the logic for
    that special case is now mostly localized to the UnwindWork module.
    
    * Hide timed-out Suspense children
    
    When a subtree takes too long to load, we swap its contents out for
    a fallback to unblock the rest of the tree. Because we don't want
    to lose the state of the timed out view, we shouldn't actually delete
    the nodes from the tree. Instead, we'll keep them mounted and hide
    them visually. When the subtree is unblocked, we un-hide it, having
    preserved the existing state.
    
    Adds additional host config methods. For mutation mode:
    
    - hideInstance
    - hideTextInstance
    - unhideInstance
    - unhideTextInstance
    
    For persistent mode:
    
    - cloneHiddenInstance
    - cloneUnhiddenInstance
    - createHiddenTextInstance
    
    I've only implemented the new methods in the noop and test renderers.
    I'll implement them in the other renderers in subsequent commits.
    
    * Include `hidden` prop in noop renderer's output
    
    This will be used in subsequent commits to test that timed-out children
    are properly hidden.
    
    Also adds getChildrenAsJSX() method as an alternative to using
    getChildren(). (Ideally all our tests would use test renderer #oneday.)
    
    * Implement hide/unhide host config methods for DOM renderer
    
    For DOM nodes, we hide using `el.style.display = 'none'`.
    
    Text nodes don't have style, so we hide using `text.textContent = ''`.
    
    * Implement hide/unhide host config methods for Art renderer
    
    * Create DOM fixture that tests state preservation of timed out content
    
    * Account for class components that suspend outside concurrent mode
    
    Need to distinguish mount from update. An unfortunate edge case :(
    
    * Fork appendAllChildren between persistent and mutation mode
    
    * Remove redundant check for existence of el.style
    
    * Schedule placement effect on indeterminate components
    
    In non-concurrent mode, indeterminate fibers may commit in an
    inconsistent state. But when they update, we should throw out the
    old fiber and start fresh. Which means the new fiber needs a
    placement effect.
    
    * Pass null instead of current everywhere in mountIndeterminateComponent

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 9843d96e4a..a742ac0884 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -20,17 +20,19 @@ describe('ReactFragment', () => {
     ReactNoop = require('react-noop-renderer');
   });
 
-  function span(prop) {
-    return {type: 'span', children: [], prop};
+  function div(...children) {
+    children = children.map(
+      c => (typeof c === 'string' ? {text: c, hidden: false} : c),
+    );
+    return {type: 'div', children, prop: undefined, hidden: false};
   }
 
-  function text(val) {
-    return {text: val};
+  function span(prop) {
+    return {type: 'span', children: [], prop, hidden: false};
   }
 
-  function div(...children) {
-    children = children.map(c => (typeof c === 'string' ? {text: c} : c));
-    return {type: 'div', children, prop: undefined};
+  function text(t) {
+    return {text: t, hidden: false};
   }
 
   it('should render a single child via noop renderer', () => {

commit 547e059f0bc88e76cd738b01b76e777ff1b222a7
Author: Sophie Alpert <git@sophiebits.com>
Date:   Mon Jan 7 08:30:23 2019 -0800

    Simplify wording of key warning (#14503)
    
    I don't think "array or iterator" is adding anything, and it may well be confusing, especially since this is one of the first and most common warnings that devs see.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index a742ac0884..d6b8b41fc0 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -709,7 +709,7 @@ describe('ReactFragment', () => {
 
     ReactNoop.render(<Foo condition={false} />);
     expect(ReactNoop.flush).toWarnDev(
-      'Each child in an array or iterator should have a unique "key" prop.',
+      'Each child in a list should have a unique "key" prop.',
     );
 
     expect(ops).toEqual([]);
@@ -753,12 +753,12 @@ describe('ReactFragment', () => {
 
     ReactNoop.render(<Foo condition={true} />);
     expect(ReactNoop.flush).toWarnDev(
-      'Each child in an array or iterator should have a unique "key" prop.',
+      'Each child in a list should have a unique "key" prop.',
     );
 
     ReactNoop.render(<Foo condition={false} />);
     expect(ReactNoop.flush).toWarnDev(
-      'Each child in an array or iterator should have a unique "key" prop.',
+      'Each child in a list should have a unique "key" prop.',
     );
 
     expect(ops).toEqual(['Update Stateful']);
@@ -766,7 +766,7 @@ describe('ReactFragment', () => {
 
     ReactNoop.render(<Foo condition={true} />);
     expect(ReactNoop.flush).toWarnDev(
-      'Each child in an array or iterator should have a unique "key" prop.',
+      'Each child in a list should have a unique "key" prop.',
     );
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);

commit 8e25ed20bd27d126f670d04680db85209f779056
Author: Andrew Clark <git@andrewclark.io>
Date:   Mon Feb 25 19:01:45 2019 -0800

    Unify noop and test renderer assertion APIs (#14952)
    
    * Throw in tests if work is done before emptying log
    
    Test renderer already does this. Makes it harder to miss unexpected
    behavior by forcing you to assert on every logged value.
    
    * Convert ReactNoop tests to use jest matchers
    
    The matchers warn if work is flushed while the log is empty. This is
    the pattern we already follow for test renderer. I've used the same APIs
    as test renderer, so it should be easy to switch between the two.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index d6b8b41fc0..c72b395eb2 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -43,7 +43,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([span()]);
   });
@@ -52,7 +52,7 @@ describe('ReactFragment', () => {
     const element = <React.Fragment />;
 
     ReactNoop.render(element);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([]);
   });
@@ -65,7 +65,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
   });
@@ -78,7 +78,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([span(), span()]);
   });
@@ -108,16 +108,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -149,16 +149,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -199,16 +199,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -242,16 +242,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -283,16 +283,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -325,16 +325,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -364,16 +364,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -403,16 +403,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -444,16 +444,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -481,16 +481,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -522,16 +522,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -564,16 +564,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(), span()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -605,16 +605,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -658,16 +658,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
@@ -705,10 +705,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop.flush).toWarnDev(
+    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -716,7 +716,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
 
     ReactNoop.render(<Foo condition={true} />);
-    ReactNoop.flush();
+    expect(ReactNoop).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
@@ -752,12 +752,12 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop.flush).toWarnDev(
+    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop.flush).toWarnDev(
+    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -765,7 +765,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop.flush).toWarnDev(
+    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 

commit 69060e1da6061af845162dcf6854a5d9af28350a
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Feb 28 12:54:47 2019 -0800

    Swap expect(ReactNoop) for expect(Scheduler) (#14971)
    
    * Swap expect(ReactNoop) for expect(Scheduler)
    
    In the previous commits, I upgraded our custom Jest matchers for the
    noop and test renderers to use Scheduler under the hood.
    
    Now that all these matchers are using Scheduler, we can drop
    support for passing ReactNoop and test roots and always pass
    Scheduler directly.
    
    * Externalize Scheduler in noop and test bundles
    
    I also noticed we don't need to regenerator runtime in noop anymore.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index c72b395eb2..5b6030da64 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -11,6 +11,7 @@
 
 let React;
 let ReactNoop;
+let Scheduler;
 
 describe('ReactFragment', () => {
   beforeEach(function() {
@@ -18,6 +19,7 @@ describe('ReactFragment', () => {
 
     React = require('react');
     ReactNoop = require('react-noop-renderer');
+    Scheduler = require('scheduler');
   });
 
   function div(...children) {
@@ -43,7 +45,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([span()]);
   });
@@ -52,7 +54,7 @@ describe('ReactFragment', () => {
     const element = <React.Fragment />;
 
     ReactNoop.render(element);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([]);
   });
@@ -65,7 +67,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
   });
@@ -78,7 +80,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ReactNoop.getChildren()).toEqual([span(), span()]);
   });
@@ -108,16 +110,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -149,16 +151,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -199,16 +201,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -242,16 +244,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -283,16 +285,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -325,16 +327,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -364,16 +366,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -403,16 +405,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -444,16 +446,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -481,16 +483,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -522,16 +524,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -564,16 +566,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(), span()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -605,16 +607,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div()]);
@@ -658,16 +660,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
@@ -705,10 +707,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -716,7 +718,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(ReactNoop).toFlushWithoutYielding();
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
@@ -752,12 +754,12 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -765,7 +767,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(ReactNoop).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
       'Each child in a list should have a unique "key" prop.',
     );
 

commit 0bd0c5269f2fe90ff7897ed5ce9146db99126eaf
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Aug 9 12:59:02 2019 -0700

    Upgrade ESLint so we can use JSX Fragment syntax (#16328)
    
    Now that we're using Babel 7, this is the last blocker.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 5b6030da64..3d7e75cd6e 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -39,9 +39,9 @@ describe('ReactFragment', () => {
 
   it('should render a single child via noop renderer', () => {
     const element = (
-      <React.Fragment>
+      <>
         <span>foo</span>
-      </React.Fragment>
+      </>
     );
 
     ReactNoop.render(element);
@@ -61,9 +61,9 @@ describe('ReactFragment', () => {
 
   it('should render multiple children via noop renderer', () => {
     const element = (
-      <React.Fragment>
+      <>
         hello <span>world</span>
-      </React.Fragment>
+      </>
     );
 
     ReactNoop.render(element);
@@ -74,9 +74,7 @@ describe('ReactFragment', () => {
 
   it('should render an iterable via noop renderer', () => {
     const element = (
-      <React.Fragment>
-        {new Set([<span key="a">hi</span>, <span key="b">bye</span>])}
-      </React.Fragment>
+      <>{new Set([<span key="a">hi</span>, <span key="b">bye</span>])}</>
     );
 
     ReactNoop.render(element);
@@ -102,10 +100,10 @@ describe('ReactFragment', () => {
       return condition ? (
         <Stateful key="a" />
       ) : (
-        <React.Fragment>
+        <>
           <Stateful key="a" />
           <div key="b">World</div>
-        </React.Fragment>
+        </>
       );
     }
 
@@ -140,13 +138,13 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>
+        <>
           <Stateful />
-        </React.Fragment>
+        </>
       ) : (
-        <React.Fragment>
+        <>
           <Stateful />
-        </React.Fragment>
+        </>
       );
     }
 
@@ -181,22 +179,22 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>
-          <React.Fragment>
-            <React.Fragment>
+        <>
+          <>
+            <>
               <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>
-        </React.Fragment>
+            </>
+          </>
+        </>
       ) : (
-        <React.Fragment>
-          <React.Fragment>
-            <React.Fragment>
+        <>
+          <>
+            <>
               <div />
               <Stateful key="a" />
-            </React.Fragment>
-          </React.Fragment>
-        </React.Fragment>
+            </>
+          </>
+        </>
       );
     }
 
@@ -231,15 +229,15 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>
-          <React.Fragment>
+        <>
+          <>
             <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
+          </>
+        </>
       ) : (
-        <React.Fragment>
+        <>
           <Stateful key="a" />
-        </React.Fragment>
+        </>
       );
     }
 
@@ -276,11 +274,11 @@ describe('ReactFragment', () => {
       return condition ? (
         <Stateful key="a" />
       ) : (
-        <React.Fragment>
-          <React.Fragment>
+        <>
+          <>
             <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
+          </>
+        </>
       );
     }
 
@@ -317,12 +315,12 @@ describe('ReactFragment', () => {
       return condition ? (
         <Stateful key="a" />
       ) : (
-        <React.Fragment>
-          <React.Fragment>
+        <>
+          <>
             <Stateful key="a" />
-          </React.Fragment>
+          </>
           <div />
-        </React.Fragment>
+        </>
       );
     }
 
@@ -357,11 +355,11 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>
+        <>
           <Stateful key="a" />
-        </React.Fragment>
+        </>
       ) : (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        <>{[<Stateful key="a" />]}</>
       );
     }
 
@@ -398,9 +396,9 @@ describe('ReactFragment', () => {
       return condition ? (
         [<Stateful key="a" />]
       ) : (
-        <React.Fragment>
+        <>
           <Stateful key="a" />
-        </React.Fragment>
+        </>
       );
     }
 
@@ -435,13 +433,13 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        <>{[<Stateful key="a" />]}</>
       ) : (
-        <React.Fragment>
-          <React.Fragment>
+        <>
+          <>
             <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
+          </>
+        </>
       );
     }
 
@@ -476,7 +474,7 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>{[<Stateful key="a" />]}</React.Fragment>
+        <>{[<Stateful key="a" />]}</>
       ) : (
         [[<Stateful key="a" />]]
       );
@@ -513,11 +511,11 @@ describe('ReactFragment', () => {
 
     function Foo({condition}) {
       return condition ? (
-        <React.Fragment>
-          <React.Fragment>
+        <>
+          <>
             <Stateful key="a" />
-          </React.Fragment>
-        </React.Fragment>
+          </>
+        </>
       ) : (
         [[<Stateful key="a" />]]
       );
@@ -600,9 +598,9 @@ describe('ReactFragment', () => {
           <Stateful />
         </React.Fragment>
       ) : (
-        <React.Fragment>
+        <>
           <Stateful />
-        </React.Fragment>
+        </>
       );
     }
 
@@ -741,15 +739,15 @@ describe('ReactFragment', () => {
       return condition
         ? [
             <span />,
-            <React.Fragment>
+            <>
               <Stateful />
-            </React.Fragment>,
+            </>,
           ]
         : [
             <span />,
-            <React.Fragment>
+            <>
               <Stateful />
-            </React.Fragment>,
+            </>,
           ];
     }
 

commit 0b5a26a4895261894f04e50d5a700e83b9c0dcf6
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Mon Dec 16 12:48:16 2019 +0000

    Rename toWarnDev -> toErrorDev, toLowPriorityWarnDev -> toWarnDev (#17605)
    
    * Rename toWarnDev -> toErrorDev in tests
    
    * Rename toWarnDev matcher implementation to toErrorDev
    
    * Rename toLowPriorityWarnDev -> toWarnDev in tests and implementation

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 3d7e75cd6e..38e6c972f3 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -708,7 +708,7 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -752,12 +752,12 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -765,7 +765,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toWarnDev(
+    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 

commit 6fef7c47a984cf0d07776c017e58b45f5af8276e
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Wed Dec 18 15:21:42 2019 +0000

    Add a regression test for switching from Fragment to a component (#17647)
    
    * Add a regression test for switching from Fragment to a component
    
    * Add a few more tests

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 38e6c972f3..10537e0d5a 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -722,6 +722,149 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
   });
 
+  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function() {
+    const ops = [];
+
+    function Passthrough({children}) {
+      return children;
+    }
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <>
+          <>
+            <Stateful />
+          </>
+        </>
+      ) : (
+        <>
+          <Passthrough>
+            <Stateful />
+          </Passthrough>
+        </>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    ReactNoop.render(<Foo condition={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state when switching a nested keyed fragment to a passthrough component', function() {
+    const ops = [];
+
+    function Passthrough({children}) {
+      return children;
+    }
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <>
+          <React.Fragment key="a">
+            <Stateful />
+          </React.Fragment>
+        </>
+      ) : (
+        <>
+          <Passthrough>
+            <Stateful />
+          </Passthrough>
+        </>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    ReactNoop.render(<Foo condition={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
+  it('should not preserve state when switching a nested keyed array to a passthrough component', function() {
+    const ops = [];
+
+    function Passthrough({children}) {
+      return children;
+    }
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    function Foo({condition}) {
+      return condition ? (
+        <>{[<Stateful key="a" />]}</>
+      ) : (
+        <>
+          <Passthrough>
+            <Stateful />
+          </Passthrough>
+        </>
+      );
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    ReactNoop.render(<Foo condition={false} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+
+    ReactNoop.render(<Foo condition={true} />);
+    expect(Scheduler).toFlushWithoutYielding();
+
+    expect(ops).toEqual([]);
+    expect(ReactNoop.getChildren()).toEqual([div()]);
+  });
+
   it('should preserve state when it does not change positions', function() {
     const ops = [];
 

commit b979db4e7215957f03c4221622f0b115a868439a
Author: Dan Abramov <dan.abramov@gmail.com>
Date:   Thu Jan 9 13:54:11 2020 +0000

    Bump Prettier (#17811)
    
    * Bump Prettier
    
    * Reformat
    
    * Use non-deprecated option

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 10537e0d5a..c258b25146 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -23,8 +23,8 @@ describe('ReactFragment', () => {
   });
 
   function div(...children) {
-    children = children.map(
-      c => (typeof c === 'string' ? {text: c, hidden: false} : c),
+    children = children.map(c =>
+      typeof c === 'string' ? {text: c, hidden: false} : c,
     );
     return {type: 'div', children, prop: undefined, hidden: false};
   }

commit 98d410f5005988644d01c9ec79b7181c3dd6c847
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Fri Apr 10 13:32:12 2020 -0700

    Build Component Stacks from Native Stack Frames (#18561)
    
    * Implement component stack extraction hack
    
    * Normalize errors in tests
    
    This drops the requirement to include owner to pass the test.
    
    * Special case tests
    
    * Add destructuring to force toObject which throws before the side-effects
    
    This ensures that we don't double call yieldValue or advanceTime in tests.
    
    Ideally we could use empty destructuring but ES lint doesn't like it.
    
    * Cache the result in DEV
    
    In DEV it's somewhat likely that we'll see many logs that add component
    stacks. This could be slow so we cache the results of previous components.
    
    * Fixture
    
    * Add Reflect to lint
    
    * Log if out of range.
    
    * Fix special case when the function call throws in V8
    
    In V8 we need to ignore the first line. Normally we would never get there
    because the stacks would differ before that, but the stacks are the same if
    we end up throwing at the same place as the control.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index c258b25146..7c058e95d2 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -10,6 +10,7 @@
 'use strict';
 
 let React;
+let ReactFeatureFlags;
 let ReactNoop;
 let Scheduler;
 
@@ -18,6 +19,7 @@ describe('ReactFragment', () => {
     jest.resetModules();
 
     React = require('react');
+    ReactFeatureFlags = require('shared/ReactFeatureFlags');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
   });
@@ -900,17 +902,27 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
-      'Each child in a list should have a unique "key" prop.',
-    );
+    if (ReactFeatureFlags.enableComponentStackLocations) {
+      // The key warning gets deduped because it's in the same component.
+      expect(Scheduler).toFlushWithoutYielding();
+    } else {
+      expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+        'Each child in a list should have a unique "key" prop.',
+      );
+    }
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
-      'Each child in a list should have a unique "key" prop.',
-    );
+    if (ReactFeatureFlags.enableComponentStackLocations) {
+      // The key warning gets deduped because it's in the same component.
+      expect(Scheduler).toFlushWithoutYielding();
+    } else {
+      expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+        'Each child in a list should have a unique "key" prop.',
+      );
+    }
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);

commit b0cb137bcbd3a11d8eff3c2229cd6b8379d29785
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 22 19:02:11 2020 -0700

    Don't dedupe using the stack (#18693)
    
    We currently use the stack to dedupe warnings in a couple of places.
    This is a very heavy weight way of computing that a warning doesn't need
    to be fired.
    
    This uses parent component name as a heuristic for deduping. It's not
    perfect but as soon as you fix one you'll uncover the next. It might be a
    little annoying but having many logs is also annoying.
    
    We now have no special cases for stacks. The only thing that uses stacks in
    dev is the console.error and dev tools. This means that we could
    externalize this completely to an console.error patching module and drop
    it from being built-in to react.
    
    The only prod/dev behavior is the one we pass to error boundaries or the
    error we throw if you don't have an error boundary.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 7c058e95d2..783db60851 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -10,7 +10,6 @@
 'use strict';
 
 let React;
-let ReactFeatureFlags;
 let ReactNoop;
 let Scheduler;
 
@@ -19,7 +18,6 @@ describe('ReactFragment', () => {
     jest.resetModules();
 
     React = require('react');
-    ReactFeatureFlags = require('shared/ReactFeatureFlags');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
   });
@@ -902,27 +900,15 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    if (ReactFeatureFlags.enableComponentStackLocations) {
-      // The key warning gets deduped because it's in the same component.
-      expect(Scheduler).toFlushWithoutYielding();
-    } else {
-      expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
-        'Each child in a list should have a unique "key" prop.',
-      );
-    }
+    // The key warning gets deduped because it's in the same component.
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);
 
     ReactNoop.render(<Foo condition={true} />);
-    if (ReactFeatureFlags.enableComponentStackLocations) {
-      // The key warning gets deduped because it's in the same component.
-      expect(Scheduler).toFlushWithoutYielding();
-    } else {
-      expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
-        'Each child in a list should have a unique "key" prop.',
-      );
-    }
+    // The key warning gets deduped because it's in the same component.
+    expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop.getChildren()).toEqual([span(), div()]);

commit 9cdf8a99edcfd94d7420835ea663edca04237527
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Oct 18 11:19:24 2022 -0400

    [Codemod] Update copyright header to Meta (#25315)
    
    * Facebook -> Meta in copyright
    
    rg --files | xargs sed -i 's#Copyright (c) Facebook, Inc. and its affiliates.#Copyright (c) Meta Platforms, Inc. and affiliates.#g'
    
    * Manual tweaks

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 783db60851..3c4acd1ec2 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -1,5 +1,5 @@
 /**
- * Copyright (c) Facebook, Inc. and its affiliates.
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.

commit 6b3083266686f62b29462d32de75c6e71f7ba3e3
Author: Jan Kassens <jkassens@meta.com>
Date:   Tue Jan 31 08:25:05 2023 -0500

    Upgrade prettier (#26081)
    
    The old version of prettier we were using didn't support the Flow syntax
    to access properties in a type using `SomeType['prop']`. This updates
    `prettier` and `rollup-plugin-prettier` to the latest versions.
    
    I added the prettier config `arrowParens: "avoid"` to reduce the diff
    size as the default has changed in Prettier 2.0. The largest amount of
    changes comes from function expressions now having a space. This doesn't
    have an option to preserve the old behavior, so we have to update this.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 3c4acd1ec2..423cee2ed3 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -14,7 +14,7 @@ let ReactNoop;
 let Scheduler;
 
 describe('ReactFragment', () => {
-  beforeEach(function() {
+  beforeEach(function () {
     jest.resetModules();
 
     React = require('react');
@@ -83,7 +83,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([span(), span()]);
   });
 
-  it('should preserve state of children with 1 level nesting', function() {
+  it('should preserve state of children with 1 level nesting', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -123,7 +123,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state between top-level fragments', function() {
+  it('should preserve state between top-level fragments', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -164,7 +164,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state of children nested at same level', function() {
+  it('should preserve state of children nested at same level', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -214,7 +214,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state in non-top-level fragment nesting', function() {
+  it('should not preserve state in non-top-level fragment nesting', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -257,7 +257,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state of children if nested 2 levels without siblings', function() {
+  it('should not preserve state of children if nested 2 levels without siblings', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -298,7 +298,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state of children if nested 2 levels with siblings', function() {
+  it('should not preserve state of children if nested 2 levels with siblings', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -340,7 +340,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state between array nested in fragment and fragment', function() {
+  it('should preserve state between array nested in fragment and fragment', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -379,7 +379,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state between top level fragment and array', function() {
+  it('should preserve state between top level fragment and array', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -418,7 +418,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state between array nested in fragment and double nested fragment', function() {
+  it('should not preserve state between array nested in fragment and double nested fragment', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -459,7 +459,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state between array nested in fragment and double nested array', function() {
+  it('should not preserve state between array nested in fragment and double nested array', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -496,7 +496,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state between double nested fragment and double nested array', function() {
+  it('should preserve state between double nested fragment and double nested array', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -537,7 +537,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state of children when the keys are different', function() {
+  it('should not preserve state of children when the keys are different', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -579,7 +579,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state between unkeyed and keyed fragment', function() {
+  it('should not preserve state between unkeyed and keyed fragment', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -620,7 +620,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state with reordering in multiple levels', function() {
+  it('should preserve state with reordering in multiple levels', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -673,7 +673,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
   });
 
-  it('should not preserve state when switching to a keyed fragment to an array', function() {
+  it('should not preserve state when switching to a keyed fragment to an array', function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -722,7 +722,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
   });
 
-  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function() {
+  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -771,7 +771,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state when switching a nested keyed fragment to a passthrough component', function() {
+  it('should not preserve state when switching a nested keyed fragment to a passthrough component', function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -820,7 +820,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should not preserve state when switching a nested keyed array to a passthrough component', function() {
+  it('should not preserve state when switching a nested keyed array to a passthrough component', function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -865,7 +865,7 @@ describe('ReactFragment', () => {
     expect(ReactNoop.getChildren()).toEqual([div()]);
   });
 
-  it('should preserve state when it does not change positions', function() {
+  it('should preserve state when it does not change positions', function () {
     const ops = [];
 
     class Stateful extends React.Component {

commit 3ff1540e9bbe30aae52e2c9ab61c843bd0c94237
Author: Sebastian Silbermann <silbermann.sebastian@gmail.com>
Date:   Thu Feb 9 11:54:35 2023 +0100

    Prefer JSX in ReactNoop assertions (to combat out-of-memory test runs) (#26127)
    
    ## Summary
    
    Prefer `getChildrenAsJSX` or `toMatchRenderedOutput` over `getChildren`.
    Use `dangerouslyGetChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    Prefer `getPendingChildrenAsJSX` over `getPendingChildren`. Use
    `dangerouslyGetPendingChildren` if you really need to (e.g. for `toBe`
    assertions).
    
    `ReactNoop.getChildren` contains the fibers as non-enumerable
    properties. If you pass the children to `toEqual` and have a mismatch,
    Jest performance is very poor (to the point of causing out-of-memory
    crashes e.g.
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624297/parallel-runs/5?filterBy=ALL&invite=true#step-106-27).
    Mismatches can sometimes be intended e.g. on gated tests.
    
    Instead, I converted almost all of the `toEqual` assertions to
    `toMatchRenderedOutput` assertions or compare the JSX instead. For
    ReactNoopPersistent we still use `getChildren` since we have assertions
    on referential equality. `toMatchRenderedOutput` is more accurate in
    some instances anyway. I highlighted some of those more accurate
    assertions in review-comments.
    
    ## How did you test this change?
    
    - [x] `CIRCLE_NODE_TOTAL=20 CIRCLE_NODE_INDEX=5 yarn test
    -r=experimental --env=development --ci`: Can take up to 350s (and use up
    to 7GB of memory) on `main` but 11s on this branch
    - [x] No more slow `yarn test` parallel runs of `yarn_test` jobs (the
    steps in these runs should take <1min but sometimes they take 3min and
    end with OOM like
    https://app.circleci.com/pipelines/github/facebook/react/38084/workflows/02ca0cbb-bab4-4c19-8d7d-ada814eeebb9/jobs/624258/parallel-runs/5?filterBy=ALL:
    Looks good with a sample size of 1
    https://app.circleci.com/pipelines/github/facebook/react/38110/workflows/745109a2-b86b-429f-8c01-9b23a245417a/jobs/624651

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 423cee2ed3..f56602881d 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -22,21 +22,6 @@ describe('ReactFragment', () => {
     Scheduler = require('scheduler');
   });
 
-  function div(...children) {
-    children = children.map(c =>
-      typeof c === 'string' ? {text: c, hidden: false} : c,
-    );
-    return {type: 'div', children, prop: undefined, hidden: false};
-  }
-
-  function span(prop) {
-    return {type: 'span', children: [], prop, hidden: false};
-  }
-
-  function text(t) {
-    return {text: t, hidden: false};
-  }
-
   it('should render a single child via noop renderer', () => {
     const element = (
       <>
@@ -47,7 +32,7 @@ describe('ReactFragment', () => {
     ReactNoop.render(element);
     expect(Scheduler).toFlushWithoutYielding();
 
-    expect(ReactNoop.getChildren()).toEqual([span()]);
+    expect(ReactNoop).toMatchRenderedOutput(<span>foo</span>);
   });
 
   it('should render zero children via noop renderer', () => {
@@ -56,7 +41,7 @@ describe('ReactFragment', () => {
     ReactNoop.render(element);
     expect(Scheduler).toFlushWithoutYielding();
 
-    expect(ReactNoop.getChildren()).toEqual([]);
+    expect(ReactNoop).toMatchRenderedOutput(null);
   });
 
   it('should render multiple children via noop renderer', () => {
@@ -69,7 +54,11 @@ describe('ReactFragment', () => {
     ReactNoop.render(element);
     expect(Scheduler).toFlushWithoutYielding();
 
-    expect(ReactNoop.getChildren()).toEqual([text('hello '), span()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        hello <span>world</span>
+      </>,
+    );
   });
 
   it('should render an iterable via noop renderer', () => {
@@ -80,7 +69,12 @@ describe('ReactFragment', () => {
     ReactNoop.render(element);
     expect(Scheduler).toFlushWithoutYielding();
 
-    expect(ReactNoop.getChildren()).toEqual([span(), span()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <span>hi</span>
+        <span>bye</span>
+      </>,
+    );
   });
 
   it('should preserve state of children with 1 level nesting', function () {
@@ -114,13 +108,18 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <div>Hello</div>
+        <div>World</div>
+      </>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state between top-level fragments', function () {
@@ -155,13 +154,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state of children nested at same level', function () {
@@ -205,13 +204,18 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <div />
+        <div>Hello</div>
+      </>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state in non-top-level fragment nesting', function () {
@@ -248,13 +252,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state of children if nested 2 levels without siblings', function () {
@@ -289,13 +293,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state of children if nested 2 levels with siblings', function () {
@@ -331,13 +335,18 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), div()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <div>Hello</div>
+        <div />
+      </>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state between array nested in fragment and fragment', function () {
@@ -370,13 +379,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state between top level fragment and array', function () {
@@ -409,13 +418,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state between array nested in fragment and double nested fragment', function () {
@@ -450,13 +459,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state between array nested in fragment and double nested array', function () {
@@ -487,13 +496,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state between double nested fragment and double nested array', function () {
@@ -528,13 +537,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state of children when the keys are different', function () {
@@ -570,13 +579,18 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(), span()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <div>Hello</div>
+        <span>World</span>
+      </>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state between unkeyed and keyed fragment', function () {
@@ -611,13 +625,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state with reordering in multiple levels', function () {
@@ -664,13 +678,29 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>beep</span>
+        <div>
+          <div>Hello</div>
+        </div>
+        <span>bar</span>
+      </div>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([div(span(), div(div()), span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <span>foo</span>
+        <div>
+          <div>Hello</div>
+        </div>
+        <span>boop</span>
+      </div>,
+    );
   });
 
   it('should not preserve state when switching to a keyed fragment to an array', function () {
@@ -713,13 +743,23 @@ describe('ReactFragment', () => {
     );
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <div>Hello</div>
+        <span />
+      </div>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div(div(), span())]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <div>
+        <div>Hello</div>
+        <span />
+      </div>,
+    );
   });
 
   it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function () {
@@ -762,13 +802,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state when switching a nested keyed fragment to a passthrough component', function () {
@@ -811,13 +851,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should not preserve state when switching a nested keyed array to a passthrough component', function () {
@@ -856,13 +896,13 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual([]);
-    expect(ReactNoop.getChildren()).toEqual([div()]);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
   it('should preserve state when it does not change positions', function () {
@@ -904,13 +944,23 @@ describe('ReactFragment', () => {
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <span />
+        <div>Hello</div>
+      </>,
+    );
 
     ReactNoop.render(<Foo condition={true} />);
     // The key warning gets deduped because it's in the same component.
     expect(Scheduler).toFlushWithoutYielding();
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
-    expect(ReactNoop.getChildren()).toEqual([span(), div()]);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <span />
+        <div>Hello</div>
+      </>,
+    );
   });
 });

commit 25a8b9735ce7c84210707d5eced7fe2c9abbd0e1
Author: Andrew Clark <git@andrewclark.io>
Date:   Thu Mar 2 22:34:58 2023 -0500

    Codemod tests to waitFor pattern (1/?) (#26288)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index f56602881d..7de3300bf3 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -12,6 +12,7 @@
 let React;
 let ReactNoop;
 let Scheduler;
+let waitForAll;
 
 describe('ReactFragment', () => {
   beforeEach(function () {
@@ -20,9 +21,12 @@ describe('ReactFragment', () => {
     React = require('react');
     ReactNoop = require('react-noop-renderer');
     Scheduler = require('scheduler');
+
+    const InternalTestUtils = require('internal-test-utils');
+    waitForAll = InternalTestUtils.waitForAll;
   });
 
-  it('should render a single child via noop renderer', () => {
+  it('should render a single child via noop renderer', async () => {
     const element = (
       <>
         <span>foo</span>
@@ -30,21 +34,21 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ReactNoop).toMatchRenderedOutput(<span>foo</span>);
   });
 
-  it('should render zero children via noop renderer', () => {
+  it('should render zero children via noop renderer', async () => {
     const element = <React.Fragment />;
 
     ReactNoop.render(element);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ReactNoop).toMatchRenderedOutput(null);
   });
 
-  it('should render multiple children via noop renderer', () => {
+  it('should render multiple children via noop renderer', async () => {
     const element = (
       <>
         hello <span>world</span>
@@ -52,7 +56,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(element);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ReactNoop).toMatchRenderedOutput(
       <>
@@ -61,13 +65,13 @@ describe('ReactFragment', () => {
     );
   });
 
-  it('should render an iterable via noop renderer', () => {
+  it('should render an iterable via noop renderer', async () => {
     const element = (
       <>{new Set([<span key="a">hi</span>, <span key="b">bye</span>])}</>
     );
 
     ReactNoop.render(element);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ReactNoop).toMatchRenderedOutput(
       <>
@@ -77,7 +81,7 @@ describe('ReactFragment', () => {
     );
   });
 
-  it('should preserve state of children with 1 level nesting', function () {
+  it('should preserve state of children with 1 level nesting', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -102,10 +106,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -116,13 +120,13 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state between top-level fragments', function () {
+  it('should preserve state between top-level fragments', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -148,22 +152,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state of children nested at same level', function () {
+  it('should preserve state of children nested at same level', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -198,10 +202,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -212,13 +216,13 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state in non-top-level fragment nesting', function () {
+  it('should not preserve state in non-top-level fragment nesting', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -246,22 +250,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state of children if nested 2 levels without siblings', function () {
+  it('should not preserve state of children if nested 2 levels without siblings', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -287,22 +291,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state of children if nested 2 levels with siblings', function () {
+  it('should not preserve state of children if nested 2 levels with siblings', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -329,10 +333,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -343,13 +347,13 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state between array nested in fragment and fragment', function () {
+  it('should preserve state between array nested in fragment and fragment', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -373,22 +377,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state between top level fragment and array', function () {
+  it('should preserve state between top level fragment and array', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -412,22 +416,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state between array nested in fragment and double nested fragment', function () {
+  it('should not preserve state between array nested in fragment and double nested fragment', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -453,22 +457,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state between array nested in fragment and double nested array', function () {
+  it('should not preserve state between array nested in fragment and double nested array', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -490,22 +494,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state between double nested fragment and double nested array', function () {
+  it('should preserve state between double nested fragment and double nested array', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -531,22 +535,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state of children when the keys are different', function () {
+  it('should not preserve state of children when the keys are different', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -573,10 +577,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -587,13 +591,13 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state between unkeyed and keyed fragment', function () {
+  it('should not preserve state between unkeyed and keyed fragment', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -619,22 +623,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state with reordering in multiple levels', function () {
+  it('should preserve state with reordering in multiple levels', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -672,10 +676,10 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -689,7 +693,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -703,7 +707,7 @@ describe('ReactFragment', () => {
     );
   });
 
-  it('should not preserve state when switching to a keyed fragment to an array', function () {
+  it('should not preserve state when switching to a keyed fragment to an array', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -735,7 +739,7 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
     expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
@@ -751,7 +755,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -762,7 +766,7 @@ describe('ReactFragment', () => {
     );
   });
 
-  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', function () {
+  it('should not preserve state when switching a nested unkeyed fragment to a passthrough component', async function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -796,22 +800,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state when switching a nested keyed fragment to a passthrough component', function () {
+  it('should not preserve state when switching a nested keyed fragment to a passthrough component', async function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -845,22 +849,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should not preserve state when switching a nested keyed array to a passthrough component', function () {
+  it('should not preserve state when switching a nested keyed array to a passthrough component', async function () {
     const ops = [];
 
     function Passthrough({children}) {
@@ -890,22 +894,22 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
   });
 
-  it('should preserve state when it does not change positions', function () {
+  it('should preserve state when it does not change positions', async function () {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -940,8 +944,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={false} />);
-    // The key warning gets deduped because it's in the same component.
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -952,8 +955,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
-    // The key warning gets deduped because it's in the same component.
-    expect(Scheduler).toFlushWithoutYielding();
+    await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
     expect(ReactNoop).toMatchRenderedOutput(

commit 5c633a48f9bdc212e27ae026c74148b42cc47efb
Author: Andrew Clark <git@andrewclark.io>
Date:   Fri Mar 3 14:34:41 2023 -0500

    Add back accidentally deleted test comments (#26294)
    
    The codemod I used in #26288 accidentally caused some comments to be
    deleted. Because not all affected lines included comments, I didn't
    notice until after landing.
    
    This adds the comments back.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 7de3300bf3..e6b9c185ca 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -944,6 +944,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={false} />);
+    // The key warning gets deduped because it's in the same component.
     await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful']);
@@ -955,6 +956,7 @@ describe('ReactFragment', () => {
     );
 
     ReactNoop.render(<Foo condition={true} />);
+    // The key warning gets deduped because it's in the same component.
     await waitForAll([]);
 
     expect(ops).toEqual(['Update Stateful', 'Update Stateful']);

commit 25685d8a90dd83d30cee6bd365bcb0115f1a2ff1
Author: Andrew Clark <git@andrewclark.io>
Date:   Sat Mar 4 18:06:20 2023 -0500

    Codemod tests to waitFor pattern (9/?) (#26309)
    
    This converts some of our test suite to use the `waitFor` test pattern,
    instead of the `expect(Scheduler).toFlushAndYield` pattern. Most of
    these changes are automated with jscodeshift, with some slight manual
    cleanup in certain cases.
    
    See #26285 for full context.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index e6b9c185ca..3db7702f4c 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -11,7 +11,6 @@
 
 let React;
 let ReactNoop;
-let Scheduler;
 let waitForAll;
 
 describe('ReactFragment', () => {
@@ -20,7 +19,6 @@ describe('ReactFragment', () => {
 
     React = require('react');
     ReactNoop = require('react-noop-renderer');
-    Scheduler = require('scheduler');
 
     const InternalTestUtils = require('internal-test-utils');
     waitForAll = InternalTestUtils.waitForAll;
@@ -707,7 +705,7 @@ describe('ReactFragment', () => {
     );
   });
 
-  it('should not preserve state when switching to a keyed fragment to an array', async function () {
+  it('should not preserve state when switching to a keyed fragment to an array', async () => {
     const ops = [];
 
     class Stateful extends React.Component {
@@ -742,7 +740,7 @@ describe('ReactFragment', () => {
     await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+    await expect(async () => await waitForAll([])).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 
@@ -939,7 +937,7 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    expect(() => expect(Scheduler).toFlushWithoutYielding()).toErrorDev(
+    await expect(async () => await waitForAll([])).toErrorDev(
       'Each child in a list should have a unique "key" prop.',
     );
 

commit 30e2938e04c8cf51688509a457a494d36bcc4269
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Feb 6 12:43:27 2024 -0500

    [Tests] Reset modules by default (#28254)
    
    ## Overview
    
    Sets `resetModules: true` in the base Jest config, and deletes all the
    `jest.resetModule()` calls we don't need.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 3db7702f4c..29ad974f4a 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -15,8 +15,6 @@ let waitForAll;
 
 describe('ReactFragment', () => {
   beforeEach(function () {
-    jest.resetModules();
-
     React = require('react');
     ReactNoop = require('react-noop-renderer');
 

commit 015ff2ed66c1d164111752263682d1d757c97f3e
Author: Andrew Clark <git@andrewclark.io>
Date:   Tue Feb 13 11:39:45 2024 -0500

    Revert "[Tests] Reset modules by default" (#28318)
    
    This was causing a slowdown in one of the tests
    ESLintRuleExhaustiveDeps-test.js. Reverting until we figure out why.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 29ad974f4a..3db7702f4c 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -15,6 +15,8 @@ let waitForAll;
 
 describe('ReactFragment', () => {
   beforeEach(function () {
+    jest.resetModules();
+
     React = require('react');
     ReactNoop = require('react-noop-renderer');
 

commit 4ca20fd36b2444a74279e7022f89894710b1daab
Author: Sebastian Markbåge <sebastian@calyptus.eu>
Date:   Wed Apr 17 12:37:51 2024 -0400

    Test top level fragment inside lazy semantics (#28852)
    
    This wasn't clearly articulated and tested why the code structure is
    like this but I think the logic is correct - or at least consistent with
    the weird semantics.
    
    We place this top-level fragment check inside the recursion so that you
    can resolve how many every Lazy or Usable wrappers you want and it still
    preserves the same semantics if they weren't there (which they might not
    be as a matter of a race condition).
    
    However, we don't actually recurse with the top-level fragment
    unwrapping itself because nesting a bunch of keyless fragments isn't the
    same as a single fragment/element.

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 3db7702f4c..fe1d1f4f95 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -965,4 +965,51 @@ describe('ReactFragment', () => {
       </>,
     );
   });
+
+  it('should preserve state of children when adding a fragment wrapped in Lazy', async function () {
+    const ops = [];
+
+    class Stateful extends React.Component {
+      componentDidUpdate() {
+        ops.push('Update Stateful');
+      }
+
+      render() {
+        return <div>Hello</div>;
+      }
+    }
+
+    const lazyChild = React.lazy(async () => ({
+      default: (
+        <>
+          <Stateful key="a" />
+          <div key="b">World</div>
+        </>
+      ),
+    }));
+
+    function Foo({condition}) {
+      return condition ? <Stateful key="a" /> : lazyChild;
+    }
+
+    ReactNoop.render(<Foo condition={true} />);
+    await waitForAll([]);
+
+    ReactNoop.render(<Foo condition={false} />);
+    await waitForAll([]);
+
+    expect(ops).toEqual(['Update Stateful']);
+    expect(ReactNoop).toMatchRenderedOutput(
+      <>
+        <div>Hello</div>
+        <div>World</div>
+      </>,
+    );
+
+    ReactNoop.render(<Foo condition={true} />);
+    await waitForAll([]);
+
+    expect(ops).toEqual(['Update Stateful', 'Update Stateful']);
+    expect(ReactNoop).toMatchRenderedOutput(<div>Hello</div>);
+  });
 });

commit 6b865330f4bc6c87dcd2c8cdf665895c8a190fc1
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Mon Jan 6 14:12:53 2025 -0500

    [assert helpers] react-reconciler (#31986)
    
    Based off: https://github.com/facebook/react/pull/31984

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index fe1d1f4f95..559ede0dd9 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -12,6 +12,7 @@
 let React;
 let ReactNoop;
 let waitForAll;
+let assertConsoleErrorDev;
 
 describe('ReactFragment', () => {
   beforeEach(function () {
@@ -22,6 +23,7 @@ describe('ReactFragment', () => {
 
     const InternalTestUtils = require('internal-test-utils');
     waitForAll = InternalTestUtils.waitForAll;
+    assertConsoleErrorDev = InternalTestUtils.assertConsoleErrorDev;
   });
 
   it('should render a single child via noop renderer', async () => {
@@ -740,9 +742,22 @@ describe('ReactFragment', () => {
     await waitForAll([]);
 
     ReactNoop.render(<Foo condition={false} />);
-    await expect(async () => await waitForAll([])).toErrorDev(
-      'Each child in a list should have a unique "key" prop.',
-    );
+    await waitForAll([]);
+    assertConsoleErrorDev([
+      gate('enableOwnerStacks')
+        ? 'Each child in a list should have a unique "key" prop.\n' +
+          '\n' +
+          'Check the render method of `div`. ' +
+          'It was passed a child from Foo. ' +
+          'See https://react.dev/link/warning-keys for more information.\n' +
+          '    in Foo (at **)'
+        : 'Each child in a list should have a unique "key" prop.\n' +
+          '\n' +
+          'Check the render method of `Foo`. ' +
+          'See https://react.dev/link/warning-keys for more information.\n' +
+          '    in Stateful (at **)\n' +
+          '    in Foo (at **)',
+    ]);
 
     expect(ops).toEqual([]);
     expect(ReactNoop).toMatchRenderedOutput(
@@ -937,9 +952,16 @@ describe('ReactFragment', () => {
     }
 
     ReactNoop.render(<Foo condition={true} />);
-    await expect(async () => await waitForAll([])).toErrorDev(
-      'Each child in a list should have a unique "key" prop.',
-    );
+    await waitForAll([]);
+    assertConsoleErrorDev([
+      'Each child in a list should have a unique "key" prop.\n' +
+        '\n' +
+        'Check the top-level render call using <Foo>. ' +
+        'It was passed a child from Foo. ' +
+        'See https://react.dev/link/warning-keys for more information.\n' +
+        '    in span (at **)\n' +
+        '    in Foo (at **)',
+    ]);
 
     ReactNoop.render(<Foo condition={false} />);
     // The key warning gets deduped because it's in the same component.

commit e0fe3479671555e01531dbc3d2fd85d5bd4c5a56
Author: Rick Hanlon <rickhanlonii@gmail.com>
Date:   Tue Mar 4 12:34:34 2025 -0500

    [flags] remove enableOwnerStacks (#32426)
    
    Bassed off: https://github.com/facebook/react/pull/32425
    
    Wait to land internally.
    
    [Commit to
    review.](https://github.com/facebook/react/pull/32426/commits/66aa6a4dbb78106b4f3d3eb367f5c27eb8f30c66)
    
    This has landed everywhere

diff --git a/packages/react-reconciler/src/__tests__/ReactFragment-test.js b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
index 559ede0dd9..a9dbabca24 100644
--- a/packages/react-reconciler/src/__tests__/ReactFragment-test.js
+++ b/packages/react-reconciler/src/__tests__/ReactFragment-test.js
@@ -744,19 +744,12 @@ describe('ReactFragment', () => {
     ReactNoop.render(<Foo condition={false} />);
     await waitForAll([]);
     assertConsoleErrorDev([
-      gate('enableOwnerStacks')
-        ? 'Each child in a list should have a unique "key" prop.\n' +
-          '\n' +
-          'Check the render method of `div`. ' +
-          'It was passed a child from Foo. ' +
-          'See https://react.dev/link/warning-keys for more information.\n' +
-          '    in Foo (at **)'
-        : 'Each child in a list should have a unique "key" prop.\n' +
-          '\n' +
-          'Check the render method of `Foo`. ' +
-          'See https://react.dev/link/warning-keys for more information.\n' +
-          '    in Stateful (at **)\n' +
-          '    in Foo (at **)',
+      'Each child in a list should have a unique "key" prop.\n' +
+        '\n' +
+        'Check the render method of `div`. ' +
+        'It was passed a child from Foo. ' +
+        'See https://react.dev/link/warning-keys for more information.\n' +
+        '    in Foo (at **)',
     ]);
 
     expect(ops).toEqual([]);

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    