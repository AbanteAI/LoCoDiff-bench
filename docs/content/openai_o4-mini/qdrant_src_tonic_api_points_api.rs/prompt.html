<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/tonic/api/points_api.rs - o4-mini-medium</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/tonic/api/points_api.rs</h1>
        <h2>Model: o4-mini-medium</h2>
        <p><a href="../../../cases/openai_o4-mini/qdrant_src_tonic_api_points_api.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/tonic/api/points_api.rs

commit 56b127175210d8d314113f687e56b1c9032fc3a2
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Dec 11 20:55:01 2021 +0000

    [GRPC] Expose upsert points API (#107)
    
    * [GRPC] Expose upsert points API
    
    * refactor PointSruct: use map instead of list + grpc tests
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
new file mode 100644
index 000000000..7fd9f2078
--- /dev/null
+++ b/src/tonic/api/points_api.rs
@@ -0,0 +1,172 @@
+use tonic::{Request, Response, Status};
+
+use crate::common::points::do_update_points;
+use crate::tonic::proto::points_server::Points;
+use crate::tonic::proto::{
+    FloatPayload, GeoPayload, GeoPoint, IntegerPayload, KeywordPayload, PointStruct,
+    PointsOperationResponse, UpdateResult, UpsertPoints,
+};
+use collection::operations::point_ops::{PointInsertOperations, PointOperations};
+use collection::operations::types::UpdateResult as CollectionUpdateResult;
+use collection::operations::CollectionUpdateOperations;
+use segment::types::{PayloadInterface, PayloadInterfaceStrict, PayloadVariant};
+use std::collections::HashMap;
+use std::convert::{TryFrom, TryInto};
+use std::sync::Arc;
+use std::time::Instant;
+use storage::content_manager::errors::StorageError;
+use storage::content_manager::toc::TableOfContent;
+
+pub struct PointsService {
+    toc: Arc<TableOfContent>,
+}
+
+impl PointsService {
+    pub fn new(toc: Arc<TableOfContent>) -> Self {
+        Self { toc }
+    }
+}
+
+#[tonic::async_trait]
+impl Points for PointsService {
+    async fn upsert(
+        &self,
+        request: Request<UpsertPoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let UpsertPoints {
+            collection,
+            wait,
+            points,
+        } = request.into_inner();
+
+        let points = points
+            .into_iter()
+            .map(|point| point.try_into())
+            .collect::<Result<_, _>>()?;
+        let operation = CollectionUpdateOperations::PointOperation(PointOperations::UpsertPoints(
+            PointInsertOperations::PointsList(points),
+        ));
+
+        let timing = Instant::now();
+        let result = do_update_points(
+            self.toc.as_ref(),
+            &collection,
+            operation,
+            wait.unwrap_or(false),
+        )
+        .await;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+}
+
+impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
+    type Error = Status;
+
+    fn try_from(value: PointStruct) -> Result<Self, Self::Error> {
+        let PointStruct {
+            id,
+            vector,
+            payload,
+        } = value;
+
+        let mut converted_payload = HashMap::new();
+        for (key, payload_value) in payload.into_iter() {
+            let value = if let Some(keyword) = payload_value.keyword {
+                keyword.into()
+            } else if let Some(integer) = payload_value.integer {
+                integer.into()
+            } else if let Some(float) = payload_value.float {
+                float.into()
+            } else if let Some(geo) = payload_value.geo {
+                geo.into()
+            } else {
+                return Err(Status::failed_precondition("Unknown payload type"));
+            };
+            converted_payload.insert(key, value);
+        }
+
+        Ok(Self {
+            id,
+            vector,
+            payload: Some(converted_payload),
+        })
+    }
+}
+
+impl From<KeywordPayload> for PayloadInterface {
+    fn from(value: KeywordPayload) -> Self {
+        PayloadInterface::Payload(PayloadInterfaceStrict::Keyword(PayloadVariant::List(
+            value.value,
+        )))
+    }
+}
+
+impl From<IntegerPayload> for PayloadInterface {
+    fn from(value: IntegerPayload) -> Self {
+        PayloadInterface::Payload(PayloadInterfaceStrict::Integer(PayloadVariant::List(
+            value.value,
+        )))
+    }
+}
+
+impl From<FloatPayload> for PayloadInterface {
+    fn from(value: FloatPayload) -> Self {
+        PayloadInterface::Payload(PayloadInterfaceStrict::Float(PayloadVariant::List(
+            value.value,
+        )))
+    }
+}
+
+impl From<GeoPayload> for PayloadInterface {
+    fn from(value: GeoPayload) -> Self {
+        let variant =
+            PayloadVariant::List(value.value.into_iter().map(|point| point.into()).collect());
+        PayloadInterface::Payload(PayloadInterfaceStrict::Geo(variant))
+    }
+}
+
+impl From<GeoPoint> for segment::types::GeoPoint {
+    fn from(value: GeoPoint) -> Self {
+        Self {
+            lon: value.lon,
+            lat: value.lat,
+        }
+    }
+}
+
+impl From<(Instant, Result<CollectionUpdateResult, StorageError>)> for PointsOperationResponse {
+    fn from(value: (Instant, Result<CollectionUpdateResult, StorageError>)) -> Self {
+        let (timing, response) = value;
+        match response {
+            Ok(res) => Self {
+                result: Some(res.into()),
+                error: None,
+                time: timing.elapsed().as_secs_f64(),
+            },
+            Err(err) => {
+                let error_description = match err {
+                    StorageError::BadInput { description } => description,
+                    StorageError::NotFound { description } => description,
+                    StorageError::ServiceError { description } => description,
+                    StorageError::BadRequest { description } => description,
+                };
+                Self {
+                    result: None,
+                    error: Some(error_description),
+                    time: timing.elapsed().as_secs_f64(),
+                }
+            }
+        }
+    }
+}
+
+impl From<CollectionUpdateResult> for UpdateResult {
+    fn from(value: CollectionUpdateResult) -> Self {
+        Self {
+            operation_id: value.operation_id,
+            status: value.status as i32,
+        }
+    }
+}

commit 9c5eea37e7f905721c59d02b83b994b8a067b294
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Dec 13 14:06:40 2021 +0100

    pre-build proto structures #138 (#141)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 7fd9f2078..05b1ba2a8 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,8 +1,8 @@
 use tonic::{Request, Response, Status};
 
 use crate::common::points::do_update_points;
-use crate::tonic::proto::points_server::Points;
-use crate::tonic::proto::{
+use crate::tonic::qdrant::points_server::Points;
+use crate::tonic::qdrant::{
     FloatPayload, GeoPayload, GeoPoint, IntegerPayload, KeywordPayload, PointStruct,
     PointsOperationResponse, UpdateResult, UpsertPoints,
 };

commit 3e0aafa13ff8ed034ef1a75d0b39f4356abd11e5
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jan 18 14:51:11 2022 +0100

    gprc: use status instead errors in structures (#164)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 05b1ba2a8..7dc720e5f 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,6 +1,7 @@
 use tonic::{Request, Response, Status};
 
 use crate::common::points::do_update_points;
+use crate::tonic::api::common::error_to_status;
 use crate::tonic::qdrant::points_server::Points;
 use crate::tonic::qdrant::{
     FloatPayload, GeoPayload, GeoPoint, IntegerPayload, KeywordPayload, PointStruct,
@@ -14,7 +15,6 @@ use std::collections::HashMap;
 use std::convert::{TryFrom, TryInto};
 use std::sync::Arc;
 use std::time::Instant;
-use storage::content_manager::errors::StorageError;
 use storage::content_manager::toc::TableOfContent;
 
 pub struct PointsService {
@@ -54,7 +54,8 @@ impl Points for PointsService {
             operation,
             wait.unwrap_or(false),
         )
-        .await;
+        .await
+        .map_err(error_to_status)?;
 
         let response = PointsOperationResponse::from((timing, result));
         Ok(Response::new(response))
@@ -136,28 +137,12 @@ impl From<GeoPoint> for segment::types::GeoPoint {
     }
 }
 
-impl From<(Instant, Result<CollectionUpdateResult, StorageError>)> for PointsOperationResponse {
-    fn from(value: (Instant, Result<CollectionUpdateResult, StorageError>)) -> Self {
+impl From<(Instant, CollectionUpdateResult)> for PointsOperationResponse {
+    fn from(value: (Instant, CollectionUpdateResult)) -> Self {
         let (timing, response) = value;
-        match response {
-            Ok(res) => Self {
-                result: Some(res.into()),
-                error: None,
-                time: timing.elapsed().as_secs_f64(),
-            },
-            Err(err) => {
-                let error_description = match err {
-                    StorageError::BadInput { description } => description,
-                    StorageError::NotFound { description } => description,
-                    StorageError::ServiceError { description } => description,
-                    StorageError::BadRequest { description } => description,
-                };
-                Self {
-                    result: None,
-                    error: Some(error_description),
-                    time: timing.elapsed().as_secs_f64(),
-                }
-            }
+        Self {
+            result: Some(response.into()),
+            time: timing.elapsed().as_secs_f64(),
         }
     }
 }

commit d51a70fa931bc70443a369d08b3c55bceadfd015
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 24 17:33:57 2022 +0100

    add openapi validation during generation #208 (#248)
    
    * add openapi validation during generation #208
    
    * fix: POST -> PUT in point update api implementation and docs #208
    
    * fix: openapi structure exposure
    
    * fix: api usage in stress test

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 7dc720e5f..a9f7d3ec0 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -7,7 +7,7 @@ use crate::tonic::qdrant::{
     FloatPayload, GeoPayload, GeoPoint, IntegerPayload, KeywordPayload, PointStruct,
     PointsOperationResponse, UpdateResult, UpsertPoints,
 };
-use collection::operations::point_ops::{PointInsertOperations, PointOperations};
+use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
 use collection::operations::types::UpdateResult as CollectionUpdateResult;
 use collection::operations::CollectionUpdateOperations;
 use segment::types::{PayloadInterface, PayloadInterfaceStrict, PayloadVariant};
@@ -44,7 +44,7 @@ impl Points for PointsService {
             .map(|point| point.try_into())
             .collect::<Result<_, _>>()?;
         let operation = CollectionUpdateOperations::PointOperation(PointOperations::UpsertPoints(
-            PointInsertOperations::PointsList(points),
+            PointInsertOperations::PointsList(PointsList { points }),
         ));
 
         let timing = Instant::now();

commit 65787f7f556b309ffbfc733c0e3e01433e87e92b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 31 13:18:07 2022 +0100

    UUID as point id (#265)
    
    * wip: u64 -> u128 + serialization tests
    
    * breaking: use more flexible structure for saving point ids
    
    * replace u64 external id type with enum
    
    * update openapi definitions for uuid + fix retrieve point api + bash script tests

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index a9f7d3ec0..1471531df 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -10,7 +10,7 @@ use crate::tonic::qdrant::{
 use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
 use collection::operations::types::UpdateResult as CollectionUpdateResult;
 use collection::operations::CollectionUpdateOperations;
-use segment::types::{PayloadInterface, PayloadInterfaceStrict, PayloadVariant};
+use segment::types::{PayloadInterface, PayloadInterfaceStrict, PayloadVariant, PointIdType};
 use std::collections::HashMap;
 use std::convert::{TryFrom, TryInto};
 use std::sync::Arc;
@@ -89,7 +89,7 @@ impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
         }
 
         Ok(Self {
-            id,
+            id: PointIdType::NumId(id),
             vector,
             payload: Some(converted_payload),
         })

commit 3d2b2ce8c27c317d8234472604325e1dab93a033
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Feb 3 17:36:13 2022 +0100

    new gRPC points update API #242 (#264)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 1471531df..49831b08f 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,17 +1,31 @@
 use tonic::{Request, Response, Status};
 
-use crate::common::points::do_update_points;
+use crate::common::points::{
+    do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
+    do_set_payload, do_update_points, CreateFieldIndex,
+};
 use crate::tonic::api::common::error_to_status;
+use crate::tonic::qdrant::condition::ConditionOneOf;
+use crate::tonic::qdrant::payload::PayloadOneOf::{Float, Geo, Integer, Keyword};
+use crate::tonic::qdrant::points_selector::PointsSelectorOneOf;
 use crate::tonic::qdrant::points_server::Points;
 use crate::tonic::qdrant::{
-    FloatPayload, GeoPayload, GeoPoint, IntegerPayload, KeywordPayload, PointStruct,
-    PointsOperationResponse, UpdateResult, UpsertPoints,
+    ClearPayloadPoints, Condition, CreateFieldIndexCollection, DeleteFieldIndexCollection,
+    DeletePayloadPoints, DeletePoints, FieldCondition, Filter, FilterSelector, FloatPayload,
+    GeoBoundingBox, GeoPayload, GeoPoint, GeoRadius, HasIdCondition, IntegerPayload,
+    KeywordPayload, Match, Payload, PointStruct, PointsOperationResponse, PointsSelector, Range,
+    SetPayloadPoints, UpdateResult, UpsertPoints,
+};
+use collection::operations::payload_ops::DeletePayload;
+use collection::operations::point_ops::{
+    PointIdsList, PointInsertOperations, PointOperations, PointsList,
 };
-use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
 use collection::operations::types::UpdateResult as CollectionUpdateResult;
 use collection::operations::CollectionUpdateOperations;
-use segment::types::{PayloadInterface, PayloadInterfaceStrict, PayloadVariant, PointIdType};
-use std::collections::HashMap;
+use segment::types::{
+    PayloadInterface, PayloadInterfaceStrict, PayloadKeyType, PayloadVariant, PointIdType,
+};
+use std::collections::{HashMap, HashSet};
 use std::convert::{TryFrom, TryInto};
 use std::sync::Arc;
 use std::time::Instant;
@@ -43,6 +57,7 @@ impl Points for PointsService {
             .into_iter()
             .map(|point| point.try_into())
             .collect::<Result<_, _>>()?;
+
         let operation = CollectionUpdateOperations::PointOperation(PointOperations::UpsertPoints(
             PointInsertOperations::PointsList(PointsList { points }),
         ));
@@ -60,6 +75,174 @@ impl Points for PointsService {
         let response = PointsOperationResponse::from((timing, result));
         Ok(Response::new(response))
     }
+
+    async fn delete(
+        &self,
+        request: Request<DeletePoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let DeletePoints {
+            collection,
+            wait,
+            points,
+        } = request.into_inner();
+
+        let points_selector = match points {
+            None => return Err(Status::invalid_argument("PointSelector is missing")),
+            Some(p) => p.try_into()?,
+        };
+
+        let timing = Instant::now();
+        let result = do_delete_points(
+            self.toc.as_ref(),
+            &collection,
+            points_selector,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+
+    async fn set_payload(
+        &self,
+        request: Request<SetPayloadPoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let SetPayloadPoints {
+            collection,
+            wait,
+            payload,
+            points,
+        } = request.into_inner();
+
+        let operation = collection::operations::payload_ops::SetPayload {
+            payload: payload_to_interface(payload)?,
+            points: points.into_iter().map(|p| p.into()).collect(),
+        };
+
+        let timing = Instant::now();
+        let result = do_set_payload(
+            self.toc.as_ref(),
+            &collection,
+            operation,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+
+    async fn delete_payload(
+        &self,
+        request: Request<DeletePayloadPoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let DeletePayloadPoints {
+            collection,
+            wait,
+            keys,
+            points,
+        } = request.into_inner();
+
+        let operation = DeletePayload {
+            keys,
+            points: points.into_iter().map(|p| p.into()).collect(),
+        };
+
+        let timing = Instant::now();
+        let result = do_delete_payload(
+            self.toc.as_ref(),
+            &collection,
+            operation,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+
+    async fn clear_payload(
+        &self,
+        request: Request<ClearPayloadPoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let ClearPayloadPoints {
+            collection,
+            wait,
+            points,
+        } = request.into_inner();
+
+        let points_selector = match points {
+            None => return Err(Status::invalid_argument("PointSelector is missing")),
+            Some(p) => p.try_into()?,
+        };
+
+        let timing = Instant::now();
+        let result = do_clear_payload(
+            self.toc.as_ref(),
+            &collection,
+            points_selector,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+
+    async fn create_field_index(
+        &self,
+        request: Request<CreateFieldIndexCollection>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let CreateFieldIndexCollection {
+            collection,
+            wait,
+            field_name,
+        } = request.into_inner();
+
+        let operation = CreateFieldIndex { field_name };
+
+        let timing = Instant::now();
+        let result = do_create_index(
+            self.toc.as_ref(),
+            &collection,
+            operation,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
+
+    async fn delete_field_index(
+        &self,
+        request: Request<DeleteFieldIndexCollection>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        let DeleteFieldIndexCollection {
+            collection,
+            wait,
+            field_name,
+        } = request.into_inner();
+
+        let timing = Instant::now();
+        let result = do_delete_index(
+            self.toc.as_ref(),
+            &collection,
+            field_name,
+            wait.unwrap_or(false),
+        )
+        .await
+        .map_err(error_to_status)?;
+
+        let response = PointsOperationResponse::from((timing, result));
+        Ok(Response::new(response))
+    }
 }
 
 impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
@@ -72,21 +255,7 @@ impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
             payload,
         } = value;
 
-        let mut converted_payload = HashMap::new();
-        for (key, payload_value) in payload.into_iter() {
-            let value = if let Some(keyword) = payload_value.keyword {
-                keyword.into()
-            } else if let Some(integer) = payload_value.integer {
-                integer.into()
-            } else if let Some(float) = payload_value.float {
-                float.into()
-            } else if let Some(geo) = payload_value.geo {
-                geo.into()
-            } else {
-                return Err(Status::failed_precondition("Unknown payload type"));
-            };
-            converted_payload.insert(key, value);
-        }
+        let converted_payload = payload_to_interface(payload)?;
 
         Ok(Self {
             id: PointIdType::NumId(id),
@@ -96,6 +265,127 @@ impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
     }
 }
 
+fn payload_to_interface(
+    payload: HashMap<String, Payload>,
+) -> Result<HashMap<PayloadKeyType, PayloadInterface>, Status> {
+    let mut converted_payload = HashMap::new();
+    for (key, payload_value) in payload.into_iter() {
+        let value = match payload_value.payload_one_of {
+            Some(Keyword(k)) => k.into(),
+            Some(Integer(i)) => i.into(),
+            Some(Float(f)) => f.into(),
+            Some(Geo(g)) => g.into(),
+            None => return Err(Status::invalid_argument("Unknown payload type")),
+        };
+        converted_payload.insert(key, value);
+    }
+    Ok(converted_payload)
+}
+
+impl TryFrom<PointsSelector> for collection::operations::point_ops::PointsSelector {
+    type Error = Status;
+
+    fn try_from(value: PointsSelector) -> Result<Self, Self::Error> {
+        match value.points_selector_one_of {
+            Some(PointsSelectorOneOf::Ids(ids)) => Ok(
+                collection::operations::point_ops::PointsSelector::PointIdsSelector(PointIdsList {
+                    points: ids.ids.into_iter().map(|p| p.into()).collect(),
+                }),
+            ),
+            Some(PointsSelectorOneOf::FilterSelector(FilterSelector { filter: Some(f) })) => Ok(
+                collection::operations::point_ops::PointsSelector::FilterSelector(
+                    collection::operations::point_ops::FilterSelector {
+                        filter: f.try_into()?,
+                    },
+                ),
+            ),
+            _ => Err(Status::invalid_argument("Malformed PointsSelector type")),
+        }
+    }
+}
+
+fn conditions_helper(
+    conditions: Vec<Condition>,
+) -> Result<Option<Vec<segment::types::Condition>>, tonic::Status> {
+    if conditions.is_empty() {
+        Ok(None)
+    } else {
+        let vec = conditions
+            .into_iter()
+            .map(|c| c.try_into())
+            .collect::<Result<_, _>>()?;
+        Ok(Some(vec))
+    }
+}
+
+impl TryFrom<Filter> for segment::types::Filter {
+    type Error = Status;
+
+    fn try_from(value: Filter) -> Result<Self, Self::Error> {
+        Ok(Self {
+            should: conditions_helper(value.should)?,
+            must: conditions_helper(value.must)?,
+            must_not: conditions_helper(value.must_not)?,
+        })
+    }
+}
+
+impl TryFrom<Condition> for segment::types::Condition {
+    type Error = Status;
+
+    fn try_from(value: Condition) -> Result<Self, Self::Error> {
+        match value.condition_one_of {
+            Some(ConditionOneOf::Field(field)) => {
+                Ok(segment::types::Condition::Field(field.try_into()?))
+            }
+            Some(ConditionOneOf::HasId(has_id)) => {
+                Ok(segment::types::Condition::HasId(has_id.try_into()?))
+            }
+            Some(ConditionOneOf::Filter(filter)) => {
+                Ok(segment::types::Condition::Filter(filter.try_into()?))
+            }
+            _ => Err(Status::invalid_argument("Malformed Condition type")),
+        }
+    }
+}
+
+impl TryFrom<HasIdCondition> for segment::types::HasIdCondition {
+    type Error = Status;
+
+    fn try_from(value: HasIdCondition) -> Result<Self, Self::Error> {
+        let set: HashSet<PointIdType> = value.has_id.into_iter().map(|p| p.into()).collect();
+        Ok(Self { has_id: set })
+    }
+}
+
+impl TryFrom<FieldCondition> for segment::types::FieldCondition {
+    type Error = Status;
+
+    fn try_from(value: FieldCondition) -> Result<Self, Self::Error> {
+        match value {
+            FieldCondition {
+                key: Some(k),
+                r#match,
+                range,
+                geo_bounding_box,
+                geo_radius,
+            } => {
+                let geo_bounding_box =
+                    geo_bounding_box.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
+                let geo_radius = geo_radius.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
+                Ok(Self {
+                    key: k.value,
+                    r#match: r#match.map(|m| m.into()),
+                    range: range.map(|r| r.into()),
+                    geo_bounding_box,
+                    geo_radius,
+                })
+            }
+            _ => Err(Status::invalid_argument("Malformed FieldCondition type")),
+        }
+    }
+}
+
 impl From<KeywordPayload> for PayloadInterface {
     fn from(value: KeywordPayload) -> Self {
         PayloadInterface::Payload(PayloadInterfaceStrict::Keyword(PayloadVariant::List(
@@ -128,6 +418,40 @@ impl From<GeoPayload> for PayloadInterface {
     }
 }
 
+impl TryFrom<GeoBoundingBox> for segment::types::GeoBoundingBox {
+    type Error = Status;
+
+    fn try_from(value: GeoBoundingBox) -> Result<Self, Self::Error> {
+        match value {
+            GeoBoundingBox {
+                top_left: Some(t),
+                bottom_right: Some(b),
+            } => Ok(Self {
+                top_left: t.into(),
+                bottom_right: b.into(),
+            }),
+            _ => Err(Status::invalid_argument("Malformed GeoBoundingBox type")),
+        }
+    }
+}
+
+impl TryFrom<GeoRadius> for segment::types::GeoRadius {
+    type Error = Status;
+
+    fn try_from(value: GeoRadius) -> Result<Self, Self::Error> {
+        match value {
+            GeoRadius {
+                center: Some(c),
+                radius,
+            } => Ok(Self {
+                center: c.into(),
+                radius: radius.into(),
+            }),
+            _ => Err(Status::invalid_argument("Malformed GeoRadius type")),
+        }
+    }
+}
+
 impl From<GeoPoint> for segment::types::GeoPoint {
     fn from(value: GeoPoint) -> Self {
         Self {
@@ -137,6 +461,26 @@ impl From<GeoPoint> for segment::types::GeoPoint {
     }
 }
 
+impl From<Range> for segment::types::Range {
+    fn from(value: Range) -> Self {
+        Self {
+            lt: value.lt.map(|v| v.value),
+            gt: value.gt.map(|v| v.value),
+            gte: value.gte.map(|v| v.value),
+            lte: value.lte.map(|v| v.value),
+        }
+    }
+}
+
+impl From<Match> for segment::types::Match {
+    fn from(value: Match) -> Self {
+        Self {
+            keyword: value.keyword,
+            integer: value.integer.map(|i| i.value),
+        }
+    }
+}
+
 impl From<(Instant, CollectionUpdateResult)> for PointsOperationResponse {
     fn from(value: (Instant, CollectionUpdateResult)) -> Self {
         let (timing, response) = value;

commit 02a50212e516a8601829c97b7b8facf388ad7c49
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Feb 14 09:58:23 2022 +0100

    Refactor proto & rest (#302)
    
    * reorder points.proto
    
    * simplify grpc + replace match with enum (backward compatible)
    
    * fmt
    
    * remove try_match
    
    * upd openapi schema
    
    * fix grpc test
    
    * fix grpc readme

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 49831b08f..2de8937ad 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -9,12 +9,13 @@ use crate::tonic::qdrant::condition::ConditionOneOf;
 use crate::tonic::qdrant::payload::PayloadOneOf::{Float, Geo, Integer, Keyword};
 use crate::tonic::qdrant::points_selector::PointsSelectorOneOf;
 use crate::tonic::qdrant::points_server::Points;
+use crate::tonic::qdrant::r#match::MatchValue;
 use crate::tonic::qdrant::{
     ClearPayloadPoints, Condition, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, FieldCondition, Filter, FilterSelector, FloatPayload,
-    GeoBoundingBox, GeoPayload, GeoPoint, GeoRadius, HasIdCondition, IntegerPayload,
-    KeywordPayload, Match, Payload, PointStruct, PointsOperationResponse, PointsSelector, Range,
-    SetPayloadPoints, UpdateResult, UpsertPoints,
+    DeletePayloadPoints, DeletePoints, FieldCondition, Filter, FloatPayload, GeoBoundingBox,
+    GeoPayload, GeoPoint, GeoRadius, HasIdCondition, IntegerPayload, KeywordPayload, Match,
+    Payload, PointStruct, PointsOperationResponse, PointsSelector, Range, SetPayloadPoints,
+    UpdateResult, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
 use collection::operations::point_ops::{
@@ -287,12 +288,12 @@ impl TryFrom<PointsSelector> for collection::operations::point_ops::PointsSelect
 
     fn try_from(value: PointsSelector) -> Result<Self, Self::Error> {
         match value.points_selector_one_of {
-            Some(PointsSelectorOneOf::Ids(ids)) => Ok(
+            Some(PointsSelectorOneOf::Points(points)) => Ok(
                 collection::operations::point_ops::PointsSelector::PointIdsSelector(PointIdsList {
-                    points: ids.ids.into_iter().map(|p| p.into()).collect(),
+                    points: points.ids.into_iter().map(|p| p.into()).collect(),
                 }),
             ),
-            Some(PointsSelectorOneOf::FilterSelector(FilterSelector { filter: Some(f) })) => Ok(
+            Some(PointsSelectorOneOf::Filter(f)) => Ok(
                 collection::operations::point_ops::PointsSelector::FilterSelector(
                     collection::operations::point_ops::FilterSelector {
                         filter: f.try_into()?,
@@ -362,34 +363,31 @@ impl TryFrom<FieldCondition> for segment::types::FieldCondition {
     type Error = Status;
 
     fn try_from(value: FieldCondition) -> Result<Self, Self::Error> {
-        match value {
-            FieldCondition {
-                key: Some(k),
-                r#match,
-                range,
-                geo_bounding_box,
-                geo_radius,
-            } => {
-                let geo_bounding_box =
-                    geo_bounding_box.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
-                let geo_radius = geo_radius.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
-                Ok(Self {
-                    key: k.value,
-                    r#match: r#match.map(|m| m.into()),
-                    range: range.map(|r| r.into()),
-                    geo_bounding_box,
-                    geo_radius,
-                })
-            }
-            _ => Err(Status::invalid_argument("Malformed FieldCondition type")),
-        }
+        let FieldCondition {
+            key,
+            r#match,
+            range,
+            geo_bounding_box,
+            geo_radius,
+        } = value;
+
+        let geo_bounding_box =
+            geo_bounding_box.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
+        let geo_radius = geo_radius.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
+        Ok(Self {
+            key,
+            r#match: r#match.map_or_else(|| Ok(None), |m| m.try_into().map(Some))?,
+            range: range.map(|r| r.into()),
+            geo_bounding_box,
+            geo_radius,
+        })
     }
 }
 
 impl From<KeywordPayload> for PayloadInterface {
     fn from(value: KeywordPayload) -> Self {
         PayloadInterface::Payload(PayloadInterfaceStrict::Keyword(PayloadVariant::List(
-            value.value,
+            value.values,
         )))
     }
 }
@@ -397,7 +395,7 @@ impl From<KeywordPayload> for PayloadInterface {
 impl From<IntegerPayload> for PayloadInterface {
     fn from(value: IntegerPayload) -> Self {
         PayloadInterface::Payload(PayloadInterfaceStrict::Integer(PayloadVariant::List(
-            value.value,
+            value.values,
         )))
     }
 }
@@ -405,7 +403,7 @@ impl From<IntegerPayload> for PayloadInterface {
 impl From<FloatPayload> for PayloadInterface {
     fn from(value: FloatPayload) -> Self {
         PayloadInterface::Payload(PayloadInterfaceStrict::Float(PayloadVariant::List(
-            value.value,
+            value.values,
         )))
     }
 }
@@ -413,7 +411,7 @@ impl From<FloatPayload> for PayloadInterface {
 impl From<GeoPayload> for PayloadInterface {
     fn from(value: GeoPayload) -> Self {
         let variant =
-            PayloadVariant::List(value.value.into_iter().map(|point| point.into()).collect());
+            PayloadVariant::List(value.values.into_iter().map(|point| point.into()).collect());
         PayloadInterface::Payload(PayloadInterfaceStrict::Geo(variant))
     }
 }
@@ -464,19 +462,24 @@ impl From<GeoPoint> for segment::types::GeoPoint {
 impl From<Range> for segment::types::Range {
     fn from(value: Range) -> Self {
         Self {
-            lt: value.lt.map(|v| v.value),
-            gt: value.gt.map(|v| v.value),
-            gte: value.gte.map(|v| v.value),
-            lte: value.lte.map(|v| v.value),
+            lt: value.lt,
+            gt: value.gt,
+            gte: value.gte,
+            lte: value.lte,
         }
     }
 }
 
-impl From<Match> for segment::types::Match {
-    fn from(value: Match) -> Self {
-        Self {
-            keyword: value.keyword,
-            integer: value.integer.map(|i| i.value),
+impl TryFrom<Match> for segment::types::Match {
+    type Error = Status;
+
+    fn try_from(value: Match) -> Result<Self, Self::Error> {
+        match value.match_value {
+            Some(mv) => Ok(match mv {
+                MatchValue::Keyword(kw) => kw.into(),
+                MatchValue::Integer(int) => int.into(),
+            }),
+            _ => Err(Status::invalid_argument("Malformed Match condition")),
         }
     }
 }
@@ -499,3 +502,12 @@ impl From<CollectionUpdateResult> for UpdateResult {
         }
     }
 }
+
+#[cfg(test)]
+mod tests {
+    #[test]
+    fn test_grpc() {
+        // For running build from IDE
+        eprintln!("hello");
+    }
+}

commit c1b6cb163b6818aac10b664a86d6c2ee3087398b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Feb 14 11:59:16 2022 +0100

    UUID support in gRPC with oneof (#299)
    
    * add PointId message proto
    
    * fix clippy

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 2de8937ad..6ac917e30 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,4 +1,5 @@
 use tonic::{Request, Response, Status};
+use uuid::Uuid;
 
 use crate::common::points::{
     do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
@@ -7,6 +8,7 @@ use crate::common::points::{
 use crate::tonic::api::common::error_to_status;
 use crate::tonic::qdrant::condition::ConditionOneOf;
 use crate::tonic::qdrant::payload::PayloadOneOf::{Float, Geo, Integer, Keyword};
+use crate::tonic::qdrant::point_id::PointIdOptions;
 use crate::tonic::qdrant::points_selector::PointsSelectorOneOf;
 use crate::tonic::qdrant::points_server::Points;
 use crate::tonic::qdrant::r#match::MatchValue;
@@ -14,8 +16,8 @@ use crate::tonic::qdrant::{
     ClearPayloadPoints, Condition, CreateFieldIndexCollection, DeleteFieldIndexCollection,
     DeletePayloadPoints, DeletePoints, FieldCondition, Filter, FloatPayload, GeoBoundingBox,
     GeoPayload, GeoPoint, GeoRadius, HasIdCondition, IntegerPayload, KeywordPayload, Match,
-    Payload, PointStruct, PointsOperationResponse, PointsSelector, Range, SetPayloadPoints,
-    UpdateResult, UpsertPoints,
+    Payload, PointId, PointStruct, PointsOperationResponse, PointsSelector, Range,
+    SetPayloadPoints, UpdateResult, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
 use collection::operations::point_ops::{
@@ -119,7 +121,10 @@ impl Points for PointsService {
 
         let operation = collection::operations::payload_ops::SetPayload {
             payload: payload_to_interface(payload)?,
-            points: points.into_iter().map(|p| p.into()).collect(),
+            points: points
+                .into_iter()
+                .map(|p| p.try_into())
+                .collect::<Result<_, _>>()?,
         };
 
         let timing = Instant::now();
@@ -149,7 +154,10 @@ impl Points for PointsService {
 
         let operation = DeletePayload {
             keys,
-            points: points.into_iter().map(|p| p.into()).collect(),
+            points: points
+                .into_iter()
+                .map(|p| p.try_into())
+                .collect::<Result<_, _>>()?,
         };
 
         let timing = Instant::now();
@@ -246,6 +254,24 @@ impl Points for PointsService {
     }
 }
 
+impl TryFrom<PointId> for PointIdType {
+    type Error = Status;
+
+    fn try_from(value: PointId) -> Result<Self, Self::Error> {
+        match value.point_id_options {
+            Some(PointIdOptions::Num(num_id)) => Ok(PointIdType::NumId(num_id)),
+            Some(PointIdOptions::Uuid(uui_str)) => Uuid::parse_str(&uui_str)
+                .map(PointIdType::Uuid)
+                .map_err(|_err| {
+                    Status::invalid_argument(format!("Unable to parse UUID: {}", uui_str))
+                }),
+            _ => Err(Status::invalid_argument(
+                "No ID options provided".to_string(),
+            )),
+        }
+    }
+}
+
 impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
     type Error = Status;
 
@@ -259,7 +285,9 @@ impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
         let converted_payload = payload_to_interface(payload)?;
 
         Ok(Self {
-            id: PointIdType::NumId(id),
+            id: id
+                .ok_or_else(|| Status::invalid_argument("Empty ID is not allowed"))?
+                .try_into()?,
             vector,
             payload: Some(converted_payload),
         })
@@ -290,7 +318,11 @@ impl TryFrom<PointsSelector> for collection::operations::point_ops::PointsSelect
         match value.points_selector_one_of {
             Some(PointsSelectorOneOf::Points(points)) => Ok(
                 collection::operations::point_ops::PointsSelector::PointIdsSelector(PointIdsList {
-                    points: points.ids.into_iter().map(|p| p.into()).collect(),
+                    points: points
+                        .ids
+                        .into_iter()
+                        .map(|p| p.try_into())
+                        .collect::<Result<Vec<_>, _>>()?,
                 }),
             ),
             Some(PointsSelectorOneOf::Filter(f)) => Ok(
@@ -354,7 +386,11 @@ impl TryFrom<HasIdCondition> for segment::types::HasIdCondition {
     type Error = Status;
 
     fn try_from(value: HasIdCondition) -> Result<Self, Self::Error> {
-        let set: HashSet<PointIdType> = value.has_id.into_iter().map(|p| p.into()).collect();
+        let set: HashSet<PointIdType> = value
+            .has_id
+            .into_iter()
+            .map(|p| p.try_into())
+            .collect::<Result<_, _>>()?;
         Ok(Self { has_id: set })
     }
 }

commit 58ce28a9331bada11dbdbf3b7e04d9ead6f37032
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Feb 14 12:49:24 2022 +0100

    [gPRC] search method (#300)
    
    * wip: grpc search + refactor payload selector
    
    * grpc: search api + test
    
    * fmt
    
    * fix clippy
    
    * update openapi schema (backward compatible)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 6ac917e30..587fdc11b 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,35 +1,23 @@
 use tonic::{Request, Response, Status};
-use uuid::Uuid;
 
 use crate::common::points::{
     do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
-    do_set_payload, do_update_points, CreateFieldIndex,
+    do_search_points, do_set_payload, do_update_points, CreateFieldIndex,
 };
 use crate::tonic::api::common::error_to_status;
-use crate::tonic::qdrant::condition::ConditionOneOf;
-use crate::tonic::qdrant::payload::PayloadOneOf::{Float, Geo, Integer, Keyword};
-use crate::tonic::qdrant::point_id::PointIdOptions;
-use crate::tonic::qdrant::points_selector::PointsSelectorOneOf;
+use crate::tonic::api::conversions::*;
 use crate::tonic::qdrant::points_server::Points;
-use crate::tonic::qdrant::r#match::MatchValue;
+
 use crate::tonic::qdrant::{
-    ClearPayloadPoints, Condition, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, FieldCondition, Filter, FloatPayload, GeoBoundingBox,
-    GeoPayload, GeoPoint, GeoRadius, HasIdCondition, IntegerPayload, KeywordPayload, Match,
-    Payload, PointId, PointStruct, PointsOperationResponse, PointsSelector, Range,
-    SetPayloadPoints, UpdateResult, UpsertPoints,
+    ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
+    DeletePayloadPoints, DeletePoints, PointsOperationResponse, SearchPoints, SearchResponse,
+    SetPayloadPoints, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
-use collection::operations::point_ops::{
-    PointIdsList, PointInsertOperations, PointOperations, PointsList,
-};
-use collection::operations::types::UpdateResult as CollectionUpdateResult;
+use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
+use collection::operations::types::SearchRequest;
 use collection::operations::CollectionUpdateOperations;
-use segment::types::{
-    PayloadInterface, PayloadInterfaceStrict, PayloadKeyType, PayloadVariant, PointIdType,
-};
-use std::collections::{HashMap, HashSet};
-use std::convert::{TryFrom, TryInto};
+use std::convert::TryInto;
 use std::sync::Arc;
 use std::time::Instant;
 use storage::content_manager::toc::TableOfContent;
@@ -252,290 +240,44 @@ impl Points for PointsService {
         let response = PointsOperationResponse::from((timing, result));
         Ok(Response::new(response))
     }
-}
-
-impl TryFrom<PointId> for PointIdType {
-    type Error = Status;
-
-    fn try_from(value: PointId) -> Result<Self, Self::Error> {
-        match value.point_id_options {
-            Some(PointIdOptions::Num(num_id)) => Ok(PointIdType::NumId(num_id)),
-            Some(PointIdOptions::Uuid(uui_str)) => Uuid::parse_str(&uui_str)
-                .map(PointIdType::Uuid)
-                .map_err(|_err| {
-                    Status::invalid_argument(format!("Unable to parse UUID: {}", uui_str))
-                }),
-            _ => Err(Status::invalid_argument(
-                "No ID options provided".to_string(),
-            )),
-        }
-    }
-}
-
-impl TryFrom<PointStruct> for collection::operations::point_ops::PointStruct {
-    type Error = Status;
 
-    fn try_from(value: PointStruct) -> Result<Self, Self::Error> {
-        let PointStruct {
-            id,
+    async fn search(
+        &self,
+        request: Request<SearchPoints>,
+    ) -> Result<Response<SearchResponse>, Status> {
+        let SearchPoints {
+            collection,
             vector,
-            payload,
-        } = value;
-
-        let converted_payload = payload_to_interface(payload)?;
+            filter,
+            top,
+            with_vector,
+            with_payload,
+            params,
+        } = request.into_inner();
 
-        Ok(Self {
-            id: id
-                .ok_or_else(|| Status::invalid_argument("Empty ID is not allowed"))?
-                .try_into()?,
+        let search_request = SearchRequest {
             vector,
-            payload: Some(converted_payload),
-        })
-    }
-}
-
-fn payload_to_interface(
-    payload: HashMap<String, Payload>,
-) -> Result<HashMap<PayloadKeyType, PayloadInterface>, Status> {
-    let mut converted_payload = HashMap::new();
-    for (key, payload_value) in payload.into_iter() {
-        let value = match payload_value.payload_one_of {
-            Some(Keyword(k)) => k.into(),
-            Some(Integer(i)) => i.into(),
-            Some(Float(f)) => f.into(),
-            Some(Geo(g)) => g.into(),
-            None => return Err(Status::invalid_argument("Unknown payload type")),
+            filter: filter.map(|f| f.try_into()).transpose()?,
+            params: params.map(|p| p.into()),
+            top: top as usize,
+            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
+            with_vector,
         };
-        converted_payload.insert(key, value);
-    }
-    Ok(converted_payload)
-}
-
-impl TryFrom<PointsSelector> for collection::operations::point_ops::PointsSelector {
-    type Error = Status;
-
-    fn try_from(value: PointsSelector) -> Result<Self, Self::Error> {
-        match value.points_selector_one_of {
-            Some(PointsSelectorOneOf::Points(points)) => Ok(
-                collection::operations::point_ops::PointsSelector::PointIdsSelector(PointIdsList {
-                    points: points
-                        .ids
-                        .into_iter()
-                        .map(|p| p.try_into())
-                        .collect::<Result<Vec<_>, _>>()?,
-                }),
-            ),
-            Some(PointsSelectorOneOf::Filter(f)) => Ok(
-                collection::operations::point_ops::PointsSelector::FilterSelector(
-                    collection::operations::point_ops::FilterSelector {
-                        filter: f.try_into()?,
-                    },
-                ),
-            ),
-            _ => Err(Status::invalid_argument("Malformed PointsSelector type")),
-        }
-    }
-}
-
-fn conditions_helper(
-    conditions: Vec<Condition>,
-) -> Result<Option<Vec<segment::types::Condition>>, tonic::Status> {
-    if conditions.is_empty() {
-        Ok(None)
-    } else {
-        let vec = conditions
-            .into_iter()
-            .map(|c| c.try_into())
-            .collect::<Result<_, _>>()?;
-        Ok(Some(vec))
-    }
-}
-
-impl TryFrom<Filter> for segment::types::Filter {
-    type Error = Status;
-
-    fn try_from(value: Filter) -> Result<Self, Self::Error> {
-        Ok(Self {
-            should: conditions_helper(value.should)?,
-            must: conditions_helper(value.must)?,
-            must_not: conditions_helper(value.must_not)?,
-        })
-    }
-}
-
-impl TryFrom<Condition> for segment::types::Condition {
-    type Error = Status;
-
-    fn try_from(value: Condition) -> Result<Self, Self::Error> {
-        match value.condition_one_of {
-            Some(ConditionOneOf::Field(field)) => {
-                Ok(segment::types::Condition::Field(field.try_into()?))
-            }
-            Some(ConditionOneOf::HasId(has_id)) => {
-                Ok(segment::types::Condition::HasId(has_id.try_into()?))
-            }
-            Some(ConditionOneOf::Filter(filter)) => {
-                Ok(segment::types::Condition::Filter(filter.try_into()?))
-            }
-            _ => Err(Status::invalid_argument("Malformed Condition type")),
-        }
-    }
-}
-
-impl TryFrom<HasIdCondition> for segment::types::HasIdCondition {
-    type Error = Status;
-
-    fn try_from(value: HasIdCondition) -> Result<Self, Self::Error> {
-        let set: HashSet<PointIdType> = value
-            .has_id
-            .into_iter()
-            .map(|p| p.try_into())
-            .collect::<Result<_, _>>()?;
-        Ok(Self { has_id: set })
-    }
-}
-
-impl TryFrom<FieldCondition> for segment::types::FieldCondition {
-    type Error = Status;
-
-    fn try_from(value: FieldCondition) -> Result<Self, Self::Error> {
-        let FieldCondition {
-            key,
-            r#match,
-            range,
-            geo_bounding_box,
-            geo_radius,
-        } = value;
-
-        let geo_bounding_box =
-            geo_bounding_box.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
-        let geo_radius = geo_radius.map_or_else(|| Ok(None), |g| g.try_into().map(Some))?;
-        Ok(Self {
-            key,
-            r#match: r#match.map_or_else(|| Ok(None), |m| m.try_into().map(Some))?,
-            range: range.map(|r| r.into()),
-            geo_bounding_box,
-            geo_radius,
-        })
-    }
-}
 
-impl From<KeywordPayload> for PayloadInterface {
-    fn from(value: KeywordPayload) -> Self {
-        PayloadInterface::Payload(PayloadInterfaceStrict::Keyword(PayloadVariant::List(
-            value.values,
-        )))
-    }
-}
-
-impl From<IntegerPayload> for PayloadInterface {
-    fn from(value: IntegerPayload) -> Self {
-        PayloadInterface::Payload(PayloadInterfaceStrict::Integer(PayloadVariant::List(
-            value.values,
-        )))
-    }
-}
-
-impl From<FloatPayload> for PayloadInterface {
-    fn from(value: FloatPayload) -> Self {
-        PayloadInterface::Payload(PayloadInterfaceStrict::Float(PayloadVariant::List(
-            value.values,
-        )))
-    }
-}
-
-impl From<GeoPayload> for PayloadInterface {
-    fn from(value: GeoPayload) -> Self {
-        let variant =
-            PayloadVariant::List(value.values.into_iter().map(|point| point.into()).collect());
-        PayloadInterface::Payload(PayloadInterfaceStrict::Geo(variant))
-    }
-}
-
-impl TryFrom<GeoBoundingBox> for segment::types::GeoBoundingBox {
-    type Error = Status;
-
-    fn try_from(value: GeoBoundingBox) -> Result<Self, Self::Error> {
-        match value {
-            GeoBoundingBox {
-                top_left: Some(t),
-                bottom_right: Some(b),
-            } => Ok(Self {
-                top_left: t.into(),
-                bottom_right: b.into(),
-            }),
-            _ => Err(Status::invalid_argument("Malformed GeoBoundingBox type")),
-        }
-    }
-}
-
-impl TryFrom<GeoRadius> for segment::types::GeoRadius {
-    type Error = Status;
-
-    fn try_from(value: GeoRadius) -> Result<Self, Self::Error> {
-        match value {
-            GeoRadius {
-                center: Some(c),
-                radius,
-            } => Ok(Self {
-                center: c.into(),
-                radius: radius.into(),
-            }),
-            _ => Err(Status::invalid_argument("Malformed GeoRadius type")),
-        }
-    }
-}
-
-impl From<GeoPoint> for segment::types::GeoPoint {
-    fn from(value: GeoPoint) -> Self {
-        Self {
-            lon: value.lon,
-            lat: value.lat,
-        }
-    }
-}
-
-impl From<Range> for segment::types::Range {
-    fn from(value: Range) -> Self {
-        Self {
-            lt: value.lt,
-            gt: value.gt,
-            gte: value.gte,
-            lte: value.lte,
-        }
-    }
-}
-
-impl TryFrom<Match> for segment::types::Match {
-    type Error = Status;
-
-    fn try_from(value: Match) -> Result<Self, Self::Error> {
-        match value.match_value {
-            Some(mv) => Ok(match mv {
-                MatchValue::Keyword(kw) => kw.into(),
-                MatchValue::Integer(int) => int.into(),
-            }),
-            _ => Err(Status::invalid_argument("Malformed Match condition")),
-        }
-    }
-}
+        let timing = Instant::now();
+        let scored_points = do_search_points(self.toc.as_ref(), &collection, search_request)
+            .await
+            .map_err(error_to_status)?;
 
-impl From<(Instant, CollectionUpdateResult)> for PointsOperationResponse {
-    fn from(value: (Instant, CollectionUpdateResult)) -> Self {
-        let (timing, response) = value;
-        Self {
-            result: Some(response.into()),
+        let response = SearchResponse {
+            result: scored_points
+                .into_iter()
+                .map(|point| point.into())
+                .collect(),
             time: timing.elapsed().as_secs_f64(),
-        }
-    }
-}
+        };
 
-impl From<CollectionUpdateResult> for UpdateResult {
-    fn from(value: CollectionUpdateResult) -> Self {
-        Self {
-            operation_id: value.operation_id,
-            status: value.status as i32,
-        }
+        Ok(Response::new(response))
     }
 }
 

commit c59c35d44dd507fbd45f9286a861068b873618a7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Feb 28 15:13:08 2022 +0100

    gRPC retrieve methods (#343)
    
    * gRPC retrieve methods
    
    * code review: remove duplicate do_get_points
    
    * code review: import for readability
    
    * code review: reinstate fullpath by convention
    
    * code review: experiment changing shape of with_vector flag
    
    * code review: update openapi spec

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 587fdc11b..d3c0dd123 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -2,7 +2,8 @@ use tonic::{Request, Response, Status};
 
 use crate::common::points::{
     do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
-    do_search_points, do_set_payload, do_update_points, CreateFieldIndex,
+    do_get_points, do_scroll_points, do_search_points, do_set_payload, do_update_points,
+    CreateFieldIndex,
 };
 use crate::tonic::api::common::error_to_status;
 use crate::tonic::api::conversions::*;
@@ -10,12 +11,12 @@ use crate::tonic::qdrant::points_server::Points;
 
 use crate::tonic::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, PointsOperationResponse, SearchPoints, SearchResponse,
-    SetPayloadPoints, UpsertPoints,
+    DeletePayloadPoints, DeletePoints, GetPoints, GetResponse, PointsOperationResponse,
+    ScrollPoints, ScrollResponse, SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
 use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
-use collection::operations::types::SearchRequest;
+use collection::operations::types::{PointRequest, ScrollRequest, SearchRequest};
 use collection::operations::CollectionUpdateOperations;
 use std::convert::TryInto;
 use std::sync::Arc;
@@ -96,6 +97,37 @@ impl Points for PointsService {
         Ok(Response::new(response))
     }
 
+    async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
+        let GetPoints {
+            collection,
+            ids,
+            with_vector,
+            with_payload,
+        } = request.into_inner();
+
+        let point_request = PointRequest {
+            ids: ids
+                .into_iter()
+                .map(|p| p.try_into())
+                .collect::<Result<_, _>>()?,
+            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
+            with_vector: with_vector.unwrap_or(false),
+        };
+
+        let timing = Instant::now();
+
+        let records = do_get_points(self.toc.as_ref(), &collection, point_request)
+            .await
+            .map_err(error_to_status)?;
+
+        let response = GetResponse {
+            result: records.into_iter().map(|point| point.into()).collect(),
+            time: timing.elapsed().as_secs_f64(),
+        };
+
+        Ok(Response::new(response))
+    }
+
     async fn set_payload(
         &self,
         request: Request<SetPayloadPoints>,
@@ -261,7 +293,7 @@ impl Points for PointsService {
             params: params.map(|p| p.into()),
             top: top as usize,
             with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
-            with_vector,
+            with_vector: with_vector.unwrap_or(false),
         };
 
         let timing = Instant::now();
@@ -279,6 +311,45 @@ impl Points for PointsService {
 
         Ok(Response::new(response))
     }
+
+    async fn scroll(
+        &self,
+        request: Request<ScrollPoints>,
+    ) -> Result<Response<ScrollResponse>, Status> {
+        let ScrollPoints {
+            collection,
+            filter,
+            offset,
+            limit,
+            with_vector,
+            with_payload,
+        } = request.into_inner();
+
+        let scroll_request = ScrollRequest {
+            offset: offset.map(|o| o.try_into()).transpose()?,
+            limit: limit.map(|l| l as usize),
+            filter: filter.map(|f| f.try_into()).transpose()?,
+            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
+            with_vector: with_vector.unwrap_or(false),
+        };
+
+        let timing = Instant::now();
+        let scrolled_points = do_scroll_points(self.toc.as_ref(), &collection, scroll_request)
+            .await
+            .map_err(error_to_status)?;
+
+        let response = ScrollResponse {
+            next_page_offset: scrolled_points.next_page_offset.map(|n| n.into()),
+            result: scrolled_points
+                .points
+                .into_iter()
+                .map(|point| point.into())
+                .collect(),
+            time: timing.elapsed().as_secs_f64(),
+        };
+
+        Ok(Response::new(response))
+    }
 }
 
 #[cfg(test)]

commit c6441f06c1b3b708d69d89e22a131422b7cbd43f
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Mar 3 15:30:09 2022 +0100

    [gPRC] docs + refactoring (#363)
    
    * wip: doc generator script
    
    * fix enum default value + CollectionInfo upd + collections comments
    
    * refactor grpc + generate docs
    
    * disable clippy for auto-generated files
    
    * Update src/tonic/proto/points.proto
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index d3c0dd123..cb5b4257f 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -40,7 +40,7 @@ impl Points for PointsService {
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let UpsertPoints {
-            collection,
+            collection_name,
             wait,
             points,
         } = request.into_inner();
@@ -57,7 +57,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_update_points(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             operation,
             wait.unwrap_or(false),
         )
@@ -73,7 +73,7 @@ impl Points for PointsService {
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let DeletePoints {
-            collection,
+            collection_name,
             wait,
             points,
         } = request.into_inner();
@@ -86,7 +86,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_delete_points(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             points_selector,
             wait.unwrap_or(false),
         )
@@ -99,7 +99,7 @@ impl Points for PointsService {
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         let GetPoints {
-            collection,
+            collection_name,
             ids,
             with_vector,
             with_payload,
@@ -116,7 +116,7 @@ impl Points for PointsService {
 
         let timing = Instant::now();
 
-        let records = do_get_points(self.toc.as_ref(), &collection, point_request)
+        let records = do_get_points(self.toc.as_ref(), &collection_name, point_request)
             .await
             .map_err(error_to_status)?;
 
@@ -133,7 +133,7 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let SetPayloadPoints {
-            collection,
+            collection_name,
             wait,
             payload,
             points,
@@ -150,7 +150,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_set_payload(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             operation,
             wait.unwrap_or(false),
         )
@@ -166,7 +166,7 @@ impl Points for PointsService {
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let DeletePayloadPoints {
-            collection,
+            collection_name,
             wait,
             keys,
             points,
@@ -183,7 +183,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_delete_payload(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             operation,
             wait.unwrap_or(false),
         )
@@ -199,7 +199,7 @@ impl Points for PointsService {
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let ClearPayloadPoints {
-            collection,
+            collection_name,
             wait,
             points,
         } = request.into_inner();
@@ -212,7 +212,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_clear_payload(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             points_selector,
             wait.unwrap_or(false),
         )
@@ -228,7 +228,7 @@ impl Points for PointsService {
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let CreateFieldIndexCollection {
-            collection,
+            collection_name,
             wait,
             field_name,
         } = request.into_inner();
@@ -238,7 +238,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_create_index(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             operation,
             wait.unwrap_or(false),
         )
@@ -254,7 +254,7 @@ impl Points for PointsService {
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         let DeleteFieldIndexCollection {
-            collection,
+            collection_name,
             wait,
             field_name,
         } = request.into_inner();
@@ -262,7 +262,7 @@ impl Points for PointsService {
         let timing = Instant::now();
         let result = do_delete_index(
             self.toc.as_ref(),
-            &collection,
+            &collection_name,
             field_name,
             wait.unwrap_or(false),
         )
@@ -278,7 +278,7 @@ impl Points for PointsService {
         request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
         let SearchPoints {
-            collection,
+            collection_name,
             vector,
             filter,
             top,
@@ -297,7 +297,7 @@ impl Points for PointsService {
         };
 
         let timing = Instant::now();
-        let scored_points = do_search_points(self.toc.as_ref(), &collection, search_request)
+        let scored_points = do_search_points(self.toc.as_ref(), &collection_name, search_request)
             .await
             .map_err(error_to_status)?;
 
@@ -317,7 +317,7 @@ impl Points for PointsService {
         request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
         let ScrollPoints {
-            collection,
+            collection_name,
             filter,
             offset,
             limit,
@@ -334,7 +334,7 @@ impl Points for PointsService {
         };
 
         let timing = Instant::now();
-        let scrolled_points = do_scroll_points(self.toc.as_ref(), &collection, scroll_request)
+        let scrolled_points = do_scroll_points(self.toc.as_ref(), &collection_name, scroll_request)
             .await
             .map_err(error_to_status)?;
 

commit 5cf9a8c21b935703788ba2b153a00e2a17f87d98
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Mar 3 20:39:07 2022 +0100

    [gRPC] recommendation method (#364)
    
    * grpc: recommend points
    
    * grpc:recommend docs

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index cb5b4257f..69e427df2 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -12,7 +12,8 @@ use crate::tonic::qdrant::points_server::Points;
 use crate::tonic::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
     DeletePayloadPoints, DeletePoints, GetPoints, GetResponse, PointsOperationResponse,
-    ScrollPoints, ScrollResponse, SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
+    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
+    SetPayloadPoints, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
 use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
@@ -350,6 +351,56 @@ impl Points for PointsService {
 
         Ok(Response::new(response))
     }
+
+    async fn recommend(
+        &self,
+        request: Request<RecommendPoints>,
+    ) -> Result<Response<RecommendResponse>, Status> {
+        let RecommendPoints {
+            collection_name,
+            positive,
+            negative,
+            filter,
+            top,
+            with_vector,
+            with_payload,
+            params,
+        } = request.into_inner();
+
+        let request = collection::operations::types::RecommendRequest {
+            positive: positive
+                .into_iter()
+                .map(|p| p.try_into())
+                .collect::<Result<_, _>>()?,
+            negative: negative
+                .into_iter()
+                .map(|p| p.try_into())
+                .collect::<Result<_, _>>()?,
+            filter: filter.map(|f| f.try_into()).transpose()?,
+            params: params.map(|p| p.into()),
+            top: top as usize,
+            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
+            with_vector: with_vector.unwrap_or(false),
+        };
+
+        let timing = Instant::now();
+        let recommended_points = self
+            .toc
+            .as_ref()
+            .recommend(&collection_name, request)
+            .await
+            .map_err(error_to_status)?;
+
+        let response = RecommendResponse {
+            result: recommended_points
+                .into_iter()
+                .map(|point| point.into())
+                .collect(),
+            time: timing.elapsed().as_secs_f64(),
+        };
+
+        Ok(Response::new(response))
+    }
 }
 
 #[cfg(test)]

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 69e427df2..192b485f4 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,12 +6,12 @@ use crate::common::points::{
     CreateFieldIndex,
 };
 use crate::tonic::api::common::error_to_status;
-use crate::tonic::api::conversions::*;
 use crate::tonic::qdrant::points_server::Points;
 
+use crate::tonic::api::conversions::proto_to_payloads;
 use crate::tonic::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, GetPoints, GetResponse, PointsOperationResponse,
+    DeletePayloadPoints, DeletePoints, FieldType, GetPoints, GetResponse, PointsOperationResponse,
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
     SetPayloadPoints, UpsertPoints,
 };
@@ -19,6 +19,7 @@ use collection::operations::payload_ops::DeletePayload;
 use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
 use collection::operations::types::{PointRequest, ScrollRequest, SearchRequest};
 use collection::operations::CollectionUpdateOperations;
+use segment::types::PayloadSchemaType;
 use std::convert::TryInto;
 use std::sync::Arc;
 use std::time::Instant;
@@ -141,7 +142,7 @@ impl Points for PointsService {
         } = request.into_inner();
 
         let operation = collection::operations::payload_ops::SetPayload {
-            payload: payload_to_interface(payload)?,
+            payload: proto_to_payloads(payload)?,
             points: points
                 .into_iter()
                 .map(|p| p.try_into())
@@ -232,9 +233,26 @@ impl Points for PointsService {
             collection_name,
             wait,
             field_name,
+            field_type,
         } = request.into_inner();
 
-        let operation = CreateFieldIndex { field_name };
+        let field_type = match field_type {
+            None => None,
+            Some(f) => match FieldType::from_i32(f) {
+                None => return Err(Status::invalid_argument("cannot convert field_type")),
+                Some(v) => match v {
+                    FieldType::Keyword => Some(PayloadSchemaType::Keyword),
+                    FieldType::Integer => Some(PayloadSchemaType::Integer),
+                    FieldType::Float => Some(PayloadSchemaType::Float),
+                    FieldType::Geo => Some(PayloadSchemaType::Geo),
+                },
+            },
+        };
+
+        let operation = CreateFieldIndex {
+            field_name,
+            field_type,
+        };
 
         let timing = Instant::now();
         let result = do_create_index(

commit 967e265900856e51cae3498de67792bdbeecfaa7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Mar 30 10:12:02 2022 +0200

    [sharding] Extract grpc feature into sub-crate (#412)
    
    * extract grpc feature into sub-crate
    
    * move build.rs to api crate
    
    * split proto files between services and objects
    
    * update docs

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 192b485f4..022af98b7 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -5,11 +5,11 @@ use crate::common::points::{
     do_get_points, do_scroll_points, do_search_points, do_set_payload, do_update_points,
     CreateFieldIndex,
 };
-use crate::tonic::api::common::error_to_status;
-use crate::tonic::qdrant::points_server::Points;
 
-use crate::tonic::api::conversions::proto_to_payloads;
-use crate::tonic::qdrant::{
+use api::grpc::qdrant::points_server::Points;
+
+use api::grpc::conversions::proto_to_payloads;
+use api::grpc::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
     DeletePayloadPoints, DeletePoints, FieldType, GetPoints, GetResponse, PointsOperationResponse,
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
@@ -23,6 +23,7 @@ use segment::types::PayloadSchemaType;
 use std::convert::TryInto;
 use std::sync::Arc;
 use std::time::Instant;
+use storage::content_manager::conversions::error_to_status;
 use storage::content_manager::toc::TableOfContent;
 
 pub struct PointsService {
@@ -35,6 +36,16 @@ impl PointsService {
     }
 }
 
+fn points_operation_response(
+    timing: Instant,
+    update_result: collection::operations::types::UpdateResult,
+) -> PointsOperationResponse {
+    PointsOperationResponse {
+        result: Some(update_result.into()),
+        time: timing.elapsed().as_secs_f64(),
+    }
+}
+
 #[tonic::async_trait]
 impl Points for PointsService {
     async fn upsert(
@@ -66,7 +77,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -95,7 +106,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -159,7 +170,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -192,7 +203,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -221,7 +232,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -264,7 +275,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 
@@ -288,7 +299,7 @@ impl Points for PointsService {
         .await
         .map_err(error_to_status)?;
 
-        let response = PointsOperationResponse::from((timing, result));
+        let response = points_operation_response(timing, result);
         Ok(Response::new(response))
     }
 

commit ded49e505ce9bc7eeba2592349c6e9ea5c07a072
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Apr 4 11:25:43 2022 +0200

    [Sharding] Shard aware updates for internal API (#427)
    
    * Shard aware updates for internal API
    
    * code-review: remove general purpose collection update API
    
    * code review: add clarification comment

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 022af98b7..96ed09bd7 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -2,12 +2,12 @@ use tonic::{Request, Response, Status};
 
 use crate::common::points::{
     do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
-    do_get_points, do_scroll_points, do_search_points, do_set_payload, do_update_points,
-    CreateFieldIndex,
+    do_get_points, do_scroll_points, do_search_points, do_set_payload, CreateFieldIndex,
 };
 
 use api::grpc::qdrant::points_server::Points;
 
+use crate::tonic::api::points_common::{points_operation_response, upsert};
 use api::grpc::conversions::proto_to_payloads;
 use api::grpc::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
@@ -16,9 +16,7 @@ use api::grpc::qdrant::{
     SetPayloadPoints, UpsertPoints,
 };
 use collection::operations::payload_ops::DeletePayload;
-use collection::operations::point_ops::{PointInsertOperations, PointOperations, PointsList};
 use collection::operations::types::{PointRequest, ScrollRequest, SearchRequest};
-use collection::operations::CollectionUpdateOperations;
 use segment::types::PayloadSchemaType;
 use std::convert::TryInto;
 use std::sync::Arc;
@@ -36,49 +34,13 @@ impl PointsService {
     }
 }
 
-fn points_operation_response(
-    timing: Instant,
-    update_result: collection::operations::types::UpdateResult,
-) -> PointsOperationResponse {
-    PointsOperationResponse {
-        result: Some(update_result.into()),
-        time: timing.elapsed().as_secs_f64(),
-    }
-}
-
 #[tonic::async_trait]
 impl Points for PointsService {
     async fn upsert(
         &self,
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let UpsertPoints {
-            collection_name,
-            wait,
-            points,
-        } = request.into_inner();
-
-        let points = points
-            .into_iter()
-            .map(|point| point.try_into())
-            .collect::<Result<_, _>>()?;
-
-        let operation = CollectionUpdateOperations::PointOperation(PointOperations::UpsertPoints(
-            PointInsertOperations::PointsList(PointsList { points }),
-        ));
-
-        let timing = Instant::now();
-        let result = do_update_points(
-            self.toc.as_ref(),
-            &collection_name,
-            operation,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        upsert(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete(
@@ -101,6 +63,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             points_selector,
+            None,
             wait.unwrap_or(false),
         )
         .await
@@ -165,6 +128,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             operation,
+            None,
             wait.unwrap_or(false),
         )
         .await
@@ -198,6 +162,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             operation,
+            None,
             wait.unwrap_or(false),
         )
         .await
@@ -227,6 +192,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             points_selector,
+            None,
             wait.unwrap_or(false),
         )
         .await
@@ -270,6 +236,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             operation,
+            None,
             wait.unwrap_or(false),
         )
         .await
@@ -294,6 +261,7 @@ impl Points for PointsService {
             self.toc.as_ref(),
             &collection_name,
             field_name,
+            None,
             wait.unwrap_or(false),
         )
         .await

commit b77482702aad471d816f503ed60bd2fc67f6fcb0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Apr 11 11:27:44 2022 +0200

    add internal API for CollectionUpdateOperations (#445)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 96ed09bd7..8f0817a47 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,23 +1,20 @@
 use tonic::{Request, Response, Status};
 
-use crate::common::points::{
-    do_clear_payload, do_create_index, do_delete_index, do_delete_payload, do_delete_points,
-    do_get_points, do_scroll_points, do_search_points, do_set_payload, CreateFieldIndex,
-};
+use crate::common::points::{do_get_points, do_scroll_points, do_search_points};
 
 use api::grpc::qdrant::points_server::Points;
 
-use crate::tonic::api::points_common::{points_operation_response, upsert};
-use api::grpc::conversions::proto_to_payloads;
+use crate::tonic::api::points_common::{
+    clear_payload, create_field_index, delete, delete_field_index, delete_payload, set_payload,
+    upsert,
+};
 use api::grpc::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, FieldType, GetPoints, GetResponse, PointsOperationResponse,
+    DeletePayloadPoints, DeletePoints, GetPoints, GetResponse, PointsOperationResponse,
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
     SetPayloadPoints, UpsertPoints,
 };
-use collection::operations::payload_ops::DeletePayload;
 use collection::operations::types::{PointRequest, ScrollRequest, SearchRequest};
-use segment::types::PayloadSchemaType;
 use std::convert::TryInto;
 use std::sync::Arc;
 use std::time::Instant;
@@ -47,30 +44,7 @@ impl Points for PointsService {
         &self,
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let DeletePoints {
-            collection_name,
-            wait,
-            points,
-        } = request.into_inner();
-
-        let points_selector = match points {
-            None => return Err(Status::invalid_argument("PointSelector is missing")),
-            Some(p) => p.try_into()?,
-        };
-
-        let timing = Instant::now();
-        let result = do_delete_points(
-            self.toc.as_ref(),
-            &collection_name,
-            points_selector,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        delete(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
@@ -108,167 +82,35 @@ impl Points for PointsService {
         &self,
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let SetPayloadPoints {
-            collection_name,
-            wait,
-            payload,
-            points,
-        } = request.into_inner();
-
-        let operation = collection::operations::payload_ops::SetPayload {
-            payload: proto_to_payloads(payload)?,
-            points: points
-                .into_iter()
-                .map(|p| p.try_into())
-                .collect::<Result<_, _>>()?,
-        };
-
-        let timing = Instant::now();
-        let result = do_set_payload(
-            self.toc.as_ref(),
-            &collection_name,
-            operation,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        set_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete_payload(
         &self,
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let DeletePayloadPoints {
-            collection_name,
-            wait,
-            keys,
-            points,
-        } = request.into_inner();
-
-        let operation = DeletePayload {
-            keys,
-            points: points
-                .into_iter()
-                .map(|p| p.try_into())
-                .collect::<Result<_, _>>()?,
-        };
-
-        let timing = Instant::now();
-        let result = do_delete_payload(
-            self.toc.as_ref(),
-            &collection_name,
-            operation,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        delete_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn clear_payload(
         &self,
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let ClearPayloadPoints {
-            collection_name,
-            wait,
-            points,
-        } = request.into_inner();
-
-        let points_selector = match points {
-            None => return Err(Status::invalid_argument("PointSelector is missing")),
-            Some(p) => p.try_into()?,
-        };
-
-        let timing = Instant::now();
-        let result = do_clear_payload(
-            self.toc.as_ref(),
-            &collection_name,
-            points_selector,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        clear_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn create_field_index(
         &self,
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let CreateFieldIndexCollection {
-            collection_name,
-            wait,
-            field_name,
-            field_type,
-        } = request.into_inner();
-
-        let field_type = match field_type {
-            None => None,
-            Some(f) => match FieldType::from_i32(f) {
-                None => return Err(Status::invalid_argument("cannot convert field_type")),
-                Some(v) => match v {
-                    FieldType::Keyword => Some(PayloadSchemaType::Keyword),
-                    FieldType::Integer => Some(PayloadSchemaType::Integer),
-                    FieldType::Float => Some(PayloadSchemaType::Float),
-                    FieldType::Geo => Some(PayloadSchemaType::Geo),
-                },
-            },
-        };
-
-        let operation = CreateFieldIndex {
-            field_name,
-            field_type,
-        };
-
-        let timing = Instant::now();
-        let result = do_create_index(
-            self.toc.as_ref(),
-            &collection_name,
-            operation,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        create_field_index(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete_field_index(
         &self,
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
-        let DeleteFieldIndexCollection {
-            collection_name,
-            wait,
-            field_name,
-        } = request.into_inner();
-
-        let timing = Instant::now();
-        let result = do_delete_index(
-            self.toc.as_ref(),
-            &collection_name,
-            field_name,
-            None,
-            wait.unwrap_or(false),
-        )
-        .await
-        .map_err(error_to_status)?;
-
-        let response = points_operation_response(timing, result);
-        Ok(Response::new(response))
+        delete_field_index(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn search(

commit 367afa3866eeba51228426b63d9e1774386365c6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Apr 13 13:16:53 2022 +0200

    [sharding] Add internal gRPC API for search recommend & scroll (#463)
    
    * Add internal gRPC API for search recommend & scroll
    
    * introduce BadShardSelection which translates into a client side error
    
    * introduce Collection target_shards to decrease code duplication
    
    * recommend uses a shard_selection aware retrieve

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 8f0817a47..019a406a7 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,12 +1,12 @@
 use tonic::{Request, Response, Status};
 
-use crate::common::points::{do_get_points, do_scroll_points, do_search_points};
+use crate::common::points::do_get_points;
 
 use api::grpc::qdrant::points_server::Points;
 
 use crate::tonic::api::points_common::{
-    clear_payload, create_field_index, delete, delete_field_index, delete_payload, set_payload,
-    upsert,
+    clear_payload, create_field_index, delete, delete_field_index, delete_payload, recommend,
+    scroll, search, set_payload, upsert,
 };
 use api::grpc::qdrant::{
     ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
@@ -14,7 +14,7 @@ use api::grpc::qdrant::{
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
     SetPayloadPoints, UpsertPoints,
 };
-use collection::operations::types::{PointRequest, ScrollRequest, SearchRequest};
+use collection::operations::types::PointRequest;
 use std::convert::TryInto;
 use std::sync::Arc;
 use std::time::Instant;
@@ -117,128 +117,21 @@ impl Points for PointsService {
         &self,
         request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
-        let SearchPoints {
-            collection_name,
-            vector,
-            filter,
-            top,
-            with_vector,
-            with_payload,
-            params,
-        } = request.into_inner();
-
-        let search_request = SearchRequest {
-            vector,
-            filter: filter.map(|f| f.try_into()).transpose()?,
-            params: params.map(|p| p.into()),
-            top: top as usize,
-            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
-            with_vector: with_vector.unwrap_or(false),
-        };
-
-        let timing = Instant::now();
-        let scored_points = do_search_points(self.toc.as_ref(), &collection_name, search_request)
-            .await
-            .map_err(error_to_status)?;
-
-        let response = SearchResponse {
-            result: scored_points
-                .into_iter()
-                .map(|point| point.into())
-                .collect(),
-            time: timing.elapsed().as_secs_f64(),
-        };
-
-        Ok(Response::new(response))
+        search(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn scroll(
         &self,
         request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
-        let ScrollPoints {
-            collection_name,
-            filter,
-            offset,
-            limit,
-            with_vector,
-            with_payload,
-        } = request.into_inner();
-
-        let scroll_request = ScrollRequest {
-            offset: offset.map(|o| o.try_into()).transpose()?,
-            limit: limit.map(|l| l as usize),
-            filter: filter.map(|f| f.try_into()).transpose()?,
-            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
-            with_vector: with_vector.unwrap_or(false),
-        };
-
-        let timing = Instant::now();
-        let scrolled_points = do_scroll_points(self.toc.as_ref(), &collection_name, scroll_request)
-            .await
-            .map_err(error_to_status)?;
-
-        let response = ScrollResponse {
-            next_page_offset: scrolled_points.next_page_offset.map(|n| n.into()),
-            result: scrolled_points
-                .points
-                .into_iter()
-                .map(|point| point.into())
-                .collect(),
-            time: timing.elapsed().as_secs_f64(),
-        };
-
-        Ok(Response::new(response))
+        scroll(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn recommend(
         &self,
         request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
-        let RecommendPoints {
-            collection_name,
-            positive,
-            negative,
-            filter,
-            top,
-            with_vector,
-            with_payload,
-            params,
-        } = request.into_inner();
-
-        let request = collection::operations::types::RecommendRequest {
-            positive: positive
-                .into_iter()
-                .map(|p| p.try_into())
-                .collect::<Result<_, _>>()?,
-            negative: negative
-                .into_iter()
-                .map(|p| p.try_into())
-                .collect::<Result<_, _>>()?,
-            filter: filter.map(|f| f.try_into()).transpose()?,
-            params: params.map(|p| p.into()),
-            top: top as usize,
-            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
-            with_vector: with_vector.unwrap_or(false),
-        };
-
-        let timing = Instant::now();
-        let recommended_points = self
-            .toc
-            .as_ref()
-            .recommend(&collection_name, request)
-            .await
-            .map_err(error_to_status)?;
-
-        let response = RecommendResponse {
-            result: recommended_points
-                .into_iter()
-                .map(|point| point.into())
-                .collect(),
-            time: timing.elapsed().as_secs_f64(),
-        };
-
-        Ok(Response::new(response))
+        recommend(self.toc.as_ref(), request.into_inner(), None).await
     }
 }
 

commit 62d4273ed2dbf1206758252c0bbda2a06f9d79ef
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Apr 13 14:10:15 2022 +0200

    [Sharding] internal API for shard-aware points retrieval (#475)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 019a406a7..06cc76f76 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,11 +1,9 @@
 use tonic::{Request, Response, Status};
 
-use crate::common::points::do_get_points;
-
 use api::grpc::qdrant::points_server::Points;
 
 use crate::tonic::api::points_common::{
-    clear_payload, create_field_index, delete, delete_field_index, delete_payload, recommend,
+    clear_payload, create_field_index, delete, delete_field_index, delete_payload, get, recommend,
     scroll, search, set_payload, upsert,
 };
 use api::grpc::qdrant::{
@@ -14,11 +12,8 @@ use api::grpc::qdrant::{
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
     SetPayloadPoints, UpsertPoints,
 };
-use collection::operations::types::PointRequest;
-use std::convert::TryInto;
 use std::sync::Arc;
-use std::time::Instant;
-use storage::content_manager::conversions::error_to_status;
+
 use storage::content_manager::toc::TableOfContent;
 
 pub struct PointsService {
@@ -48,34 +43,7 @@ impl Points for PointsService {
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
-        let GetPoints {
-            collection_name,
-            ids,
-            with_vector,
-            with_payload,
-        } = request.into_inner();
-
-        let point_request = PointRequest {
-            ids: ids
-                .into_iter()
-                .map(|p| p.try_into())
-                .collect::<Result<_, _>>()?,
-            with_payload: with_payload.map(|wp| wp.try_into()).transpose()?,
-            with_vector: with_vector.unwrap_or(false),
-        };
-
-        let timing = Instant::now();
-
-        let records = do_get_points(self.toc.as_ref(), &collection_name, point_request)
-            .await
-            .map_err(error_to_status)?;
-
-        let response = GetResponse {
-            result: records.into_iter().map(|point| point.into()).collect(),
-            time: timing.elapsed().as_secs_f64(),
-        };
-
-        Ok(Response::new(response))
+        get(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn set_payload(

commit 098bc4c751909647dc3887e88e1f44b91d52f32b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jul 5 09:33:38 2022 +0200

    Count api (#777)
    
    * count api
    
    * test for approx counting
    
    * fmt + clippy
    
    * unit test
    
    * add warning

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 06cc76f76..c24625c6f 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -3,14 +3,14 @@ use tonic::{Request, Response, Status};
 use api::grpc::qdrant::points_server::Points;
 
 use crate::tonic::api::points_common::{
-    clear_payload, create_field_index, delete, delete_field_index, delete_payload, get, recommend,
-    scroll, search, set_payload, upsert,
+    clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
+    recommend, scroll, search, set_payload, upsert,
 };
 use api::grpc::qdrant::{
-    ClearPayloadPoints, CreateFieldIndexCollection, DeleteFieldIndexCollection,
-    DeletePayloadPoints, DeletePoints, GetPoints, GetResponse, PointsOperationResponse,
-    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchPoints, SearchResponse,
-    SetPayloadPoints, UpsertPoints,
+    ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
+    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePoints, GetPoints, GetResponse,
+    PointsOperationResponse, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
+    SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
 };
 use std::sync::Arc;
 
@@ -101,6 +101,13 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendResponse>, Status> {
         recommend(self.toc.as_ref(), request.into_inner(), None).await
     }
+
+    async fn count(
+        &self,
+        request: Request<CountPoints>,
+    ) -> Result<Response<CountResponse>, Status> {
+        count(self.toc.as_ref(), request.into_inner(), None).await
+    }
 }
 
 #[cfg(test)]

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index c24625c6f..4444d367e 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,20 +1,19 @@
-use tonic::{Request, Response, Status};
+use std::sync::Arc;
 
 use api::grpc::qdrant::points_server::Points;
-
-use crate::tonic::api::points_common::{
-    clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
-    recommend, scroll, search, set_payload, upsert,
-};
 use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePoints, GetPoints, GetResponse,
     PointsOperationResponse, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
     SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
 };
-use std::sync::Arc;
-
 use storage::content_manager::toc::TableOfContent;
+use tonic::{Request, Response, Status};
+
+use crate::tonic::api::points_common::{
+    clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
+    recommend, scroll, search, set_payload, upsert,
+};
 
 pub struct PointsService {
     toc: Arc<TableOfContent>,

commit a2acca0345057dfb7fd8f218801a1c84cd77616b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Aug 18 14:48:17 2022 +0200

    Segment batch search (#813)
    
    * batch search benchmark
    
    * collect filter iterator in indexed search
    
    * fmt
    
    * fix
    
    * fix
    
    * fmt
    
    * use new tempfile create
    
    * auto batching
    
    * Clippy fixes
    
    * REST, gRPC and internal APIs
    
    * fix bugs & less duplication
    
    * two steps payload retrieval mechanism & fix duplication
    
    * add proxy_segment implementation & tests
    
    * add gRPC docs
    
    * remove unused code (#950)
    
    * only filter ids within a batch
    
    * add more equivalence tests
    
    * add integration test search vs batch
    
    * assert more search options in tests
    
    * cleanup assertions
    
    * fix offset panic
    
    * rename search batch API
    
    * openapi spec
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 4444d367e..cab6f59db 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -5,14 +5,15 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePoints, GetPoints, GetResponse,
     PointsOperationResponse, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
-    SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
+    SearchBatchPoints, SearchBatchResponse, SearchPoints, SearchResponse, SetPayloadPoints,
+    UpsertPoints,
 };
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
-    recommend, scroll, search, set_payload, upsert,
+    recommend, scroll, search, search_batch, set_payload, upsert,
 };
 
 pub struct PointsService {
@@ -87,6 +88,17 @@ impl Points for PointsService {
         search(self.toc.as_ref(), request.into_inner(), None).await
     }
 
+    async fn search_batch(
+        &self,
+        request: Request<SearchBatchPoints>,
+    ) -> Result<Response<SearchBatchResponse>, Status> {
+        let SearchBatchPoints {
+            collection_name,
+            search_points,
+        } = request.into_inner();
+        search_batch(self.toc.as_ref(), collection_name, search_points, None).await
+    }
+
     async fn scroll(
         &self,
         request: Request<ScrollPoints>,

commit 03c10fc310a6bdaa750fda6115fb7666082ef4b7
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Aug 22 09:41:22 2022 +0200

    Batch recommendation API (#954)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index cab6f59db..8a8257f19 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -4,16 +4,16 @@ use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePoints, GetPoints, GetResponse,
-    PointsOperationResponse, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
-    SearchBatchPoints, SearchBatchResponse, SearchPoints, SearchResponse, SetPayloadPoints,
-    UpsertPoints,
+    PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendPoints,
+    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
+    SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
 };
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
-    recommend, scroll, search, search_batch, set_payload, upsert,
+    recommend, recommend_batch, scroll, search, search_batch, set_payload, upsert,
 };
 
 pub struct PointsService {
@@ -113,6 +113,17 @@ impl Points for PointsService {
         recommend(self.toc.as_ref(), request.into_inner(), None).await
     }
 
+    async fn recommend_batch(
+        &self,
+        request: Request<RecommendBatchPoints>,
+    ) -> Result<Response<RecommendBatchResponse>, Status> {
+        let RecommendBatchPoints {
+            collection_name,
+            recommend_points,
+        } = request.into_inner();
+        recommend_batch(self.toc.as_ref(), collection_name, recommend_points, None).await
+    }
+
     async fn count(
         &self,
         request: Request<CountPoints>,

commit 0d130c395a65f13f48d13c6b1db83542e3e7ec82
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Nov 28 13:46:58 2022 +0100

    Full payload update (#1245)
    
    * implement api to fully overwrite payload of the point
    
    * fmt

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 8a8257f19..da4d3e7f4 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -13,7 +13,8 @@ use tonic::{Request, Response, Status};
 
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
-    recommend, recommend_batch, scroll, search, search_batch, set_payload, upsert,
+    overwrite_payload, recommend, recommend_batch, scroll, search, search_batch, set_payload,
+    upsert,
 };
 
 pub struct PointsService {
@@ -53,6 +54,13 @@ impl Points for PointsService {
         set_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
+    async fn overwrite_payload(
+        &self,
+        request: Request<SetPayloadPoints>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        overwrite_payload(self.toc.as_ref(), request.into_inner(), None).await
+    }
+
     async fn delete_payload(
         &self,
         request: Request<DeletePayloadPoints>,

commit a1f651fbd6b9ff386c259fbe398455f9a2ba126a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Dec 22 09:29:36 2022 +0100

    Recommendation with other collection (#1283)
    
    * WIP: move recommendation API out of collection
    
    * recomendations with external source of vectors
    
    * fix test
    
    * fmt
    
    * fixes + test
    
    * review fixes

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index da4d3e7f4..9fe294c94 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -118,7 +118,7 @@ impl Points for PointsService {
         &self,
         request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
-        recommend(self.toc.as_ref(), request.into_inner(), None).await
+        recommend(self.toc.as_ref(), request.into_inner()).await
     }
 
     async fn recommend_batch(
@@ -129,7 +129,7 @@ impl Points for PointsService {
             collection_name,
             recommend_points,
         } = request.into_inner();
-        recommend_batch(self.toc.as_ref(), collection_name, recommend_points, None).await
+        recommend_batch(self.toc.as_ref(), collection_name, recommend_points).await
     }
 
     async fn count(

commit 34bdbc2fe68b2327cf79fdaeb0e991a9281ddf47
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Feb 3 01:12:28 2023 +0100

    Add `read_consistency` parameter to the APIs (#1371) (#1407)
    
    * WIP: Add `read_consistency` parameter to the APIs
    
    * WIP: Add `read_consistency` parameter to the APIs
    
    TODO:
    - Add documentation
    
    * `cargo fmt`
    
    * Add gRPC documentation
    
    * Add OpenAPI documentation
    
    * Cleanup
    
    * fixup! Add OpenAPI documentation
    
    * fixup! Add gRPC documentation
    
    Who would have known there's `generate_grpc_docs.sh`!? 🥲🙈🤦‍♀️
    
    * generate openapi
    
    * Fix `read_consistency` query parameter deserialization
    
    * Further improve `read_consistency` query parameter deserialization
    
    * `cargo clippy`
    
    * Fix `Payload` comparison during read operation result resolving
    
    * Fix grammar
    
    * rename `read_consistency` -> `consistency` and add integration test
    
    * use majority for test
    
    * fix tests
    
    * Fix tests
    
    * fixup! Fix tests
    
    Apply the same fix to `ScoredPoint`
    
    * Remove an `unwrap`
    
    * fixup! Fix tests
    
    Gotta love those negative conditions, or how a missed `!` can ruin your day... 🤦‍♀️
    
    * Make internal API calls strictly "local-shard only"
    
    * Implement a few basic traits for `ResolverRecord`
    
    * fixup! Implement a few basic traits for `ResolverRecord`
    
    * Revert "Make internal API calls strictly "local-shard only""
    
    This reverts commit 25378e61ff248682c6ac0fb334814fd2f354053e.
    
    * Fix `Record::payload` and `ScoredPoint::payload` serialization
    
    * Revert "Fix `Record::payload` and `ScoredPoint::payload` serialization"
    
    This reverts commit b566bea49bc326ae3e860a4f0397348a596b9fef.
    
    * Fix `Record::payload` and `ScoredPoint::payload` visibility
    
    * fixup! Fix `Record::payload` and `ScoredPoint::payload` visibility
    
    Remove `todo!()`
    
    * refactoring
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 9fe294c94..0c46ba44d 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -103,8 +103,16 @@ impl Points for PointsService {
         let SearchBatchPoints {
             collection_name,
             search_points,
+            read_consistency,
         } = request.into_inner();
-        search_batch(self.toc.as_ref(), collection_name, search_points, None).await
+        search_batch(
+            self.toc.as_ref(),
+            collection_name,
+            search_points,
+            read_consistency,
+            None,
+        )
+        .await
     }
 
     async fn scroll(
@@ -128,8 +136,15 @@ impl Points for PointsService {
         let RecommendBatchPoints {
             collection_name,
             recommend_points,
+            read_consistency,
         } = request.into_inner();
-        recommend_batch(self.toc.as_ref(), collection_name, recommend_points).await
+        recommend_batch(
+            self.toc.as_ref(),
+            collection_name,
+            recommend_points,
+            read_consistency,
+        )
+        .await
     }
 
     async fn count(

commit c4c78e2b2d9e423c5c43f6e9dff0997f214386aa
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Apr 10 17:04:27 2023 +0200

    Add validation to gRPC (#1634)
    
    * Implement validation on generated gRPC point types
    
    * Validate gRPC point API requests
    
    * Nicely describe validation errors
    
    * Add validation extensions for special types used in gRPC
    
    * Validate gRPC collection API requests
    
    * Validate gRPC Raft and snapshot API requests
    
    * Simplify validation builder, guess derives from fields, fix two fields
    
    * Remove point recommending limit constraint to fix gRPC tests
    
    * Clean up validation logic for gRPC in build.rs
    
    * Validate internal gRPC requests, don't error but show warnings in log
    
    * Optimize gRPC validation extensions, remove unused bits
    
    * Validate gRPC collection creation configuration
    
    * Add custom validators for special gRPC types
    
    * Value is automatically attached to validation error
    
    * Cleanup
    
    * Remove obsolete tests
    
    * Add basic gRPC validation test
    
    * Add some gRPC request payload validation tests
    
    * Set max collection name length to 255 in validation to match Actix

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 0c46ba44d..1eebfbe22 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -11,6 +11,7 @@ use api::grpc::qdrant::{
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
+use super::validate;
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
     overwrite_payload, recommend, recommend_batch, scroll, search, search_batch, set_payload,
@@ -33,6 +34,7 @@ impl Points for PointsService {
         &self,
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         upsert(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -40,10 +42,12 @@ impl Points for PointsService {
         &self,
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         delete(self.toc.as_ref(), request.into_inner(), None).await
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
+        validate(request.get_ref())?;
         get(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -51,6 +55,7 @@ impl Points for PointsService {
         &self,
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         set_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -58,6 +63,7 @@ impl Points for PointsService {
         &self,
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         overwrite_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -65,6 +71,7 @@ impl Points for PointsService {
         &self,
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         delete_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -72,6 +79,7 @@ impl Points for PointsService {
         &self,
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         clear_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -79,6 +87,7 @@ impl Points for PointsService {
         &self,
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         create_field_index(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -86,6 +95,7 @@ impl Points for PointsService {
         &self,
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
         delete_field_index(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -93,6 +103,7 @@ impl Points for PointsService {
         &self,
         request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
+        validate(request.get_ref())?;
         search(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -100,6 +111,7 @@ impl Points for PointsService {
         &self,
         request: Request<SearchBatchPoints>,
     ) -> Result<Response<SearchBatchResponse>, Status> {
+        validate(request.get_ref())?;
         let SearchBatchPoints {
             collection_name,
             search_points,
@@ -119,6 +131,7 @@ impl Points for PointsService {
         &self,
         request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
+        validate(request.get_ref())?;
         scroll(self.toc.as_ref(), request.into_inner(), None).await
     }
 
@@ -126,6 +139,7 @@ impl Points for PointsService {
         &self,
         request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
+        validate(request.get_ref())?;
         recommend(self.toc.as_ref(), request.into_inner()).await
     }
 
@@ -133,6 +147,7 @@ impl Points for PointsService {
         &self,
         request: Request<RecommendBatchPoints>,
     ) -> Result<Response<RecommendBatchResponse>, Status> {
+        validate(request.get_ref())?;
         let RecommendBatchPoints {
             collection_name,
             recommend_points,
@@ -151,15 +166,7 @@ impl Points for PointsService {
         &self,
         request: Request<CountPoints>,
     ) -> Result<Response<CountResponse>, Status> {
+        validate(request.get_ref())?;
         count(self.toc.as_ref(), request.into_inner(), None).await
     }
 }
-
-#[cfg(test)]
-mod tests {
-    #[test]
-    fn test_grpc() {
-        // For running build from IDE
-        eprintln!("hello");
-    }
-}

commit 5805811ad4b6d41aaa3033c4df36a4fe8536e958
Author: Tim Visée <tim+github@visee.me>
Date:   Fri May 5 15:18:19 2023 +0200

    Add gRPC interface to update/delete optional named vectors (#1816)
    
    * Add segment entry function to update named vectors
    
    * Use already available function to update existing vectors
    
    We already had a segment function to update existing named vectors. This
    change ensure we use that instead of separating it separately. As a
    bonus, this adds support for setting multiple named vectors at once.
    
    * Update set vectors ourselves, don't drop omitted vectors
    
    * Refactor vector updating functions, separate update and replace
    
    * Add basic vector ops, add update/delete functionality to segment updater
    
    * Add internal and public gRPC types and actions for vectors
    
    * Add gRPC API actions
    
    * Reformat
    
    * Add VectorOperations to vector ops, add basic validation
    
    * Validate gRPC vector types
    
    * Validate vector operation structs
    
    * Construct PointIdsList through From trait
    
    * Update gRPC docs
    
    * Use VectorsSelector for vector deletions in gRPC
    
    * Add support for updating multiple points/vectors in update vectors API
    
    * Update gRPC docs
    
    * Fix incorrect gRPC type numbering
    
    * Return point ID error from vector update/delete functions if not found
    
    * Fix disbalanced vectors test

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 1eebfbe22..9c0891951 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -3,14 +3,16 @@ use std::sync::Arc;
 use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
-    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePoints, GetPoints, GetResponse,
-    PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendPoints,
-    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
-    SearchPoints, SearchResponse, SetPayloadPoints, UpsertPoints,
+    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints, GetPoints,
+    GetResponse, PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse,
+    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
+    SearchBatchResponse, SearchPoints, SearchResponse, SetPayloadPoints, UpdatePointVectors,
+    UpsertPoints,
 };
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
+use super::points_common::{delete_vectors, update_vectors};
 use super::validate;
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
@@ -51,6 +53,22 @@ impl Points for PointsService {
         get(self.toc.as_ref(), request.into_inner(), None).await
     }
 
+    async fn update_vectors(
+        &self,
+        request: Request<UpdatePointVectors>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
+        update_vectors(self.toc.as_ref(), request.into_inner(), None).await
+    }
+
+    async fn delete_vectors(
+        &self,
+        request: Request<DeletePointVectors>,
+    ) -> Result<Response<PointsOperationResponse>, Status> {
+        validate(request.get_ref())?;
+        delete_vectors(self.toc.as_ref(), request.into_inner(), None).await
+    }
+
     async fn set_payload(
         &self,
         request: Request<SetPayloadPoints>,

commit 716f84cfcc10c815a24710d7f2b15acbf413818e
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon May 15 17:05:20 2023 -0400

    Group by key (#1768)
    
    * test: test must_not is_null
    
    * vcs: ignore vscode files
    
    * feat: group-by initial implementation
    
    * cargo fmt
    
    * refactor: same request behavior on reco and search
    
    * refactor: get rid of RefCell
    
    * refactor-fix: correct hashmap keys, and early stops
    
    * chore: small improvements
    
    * feat: groups aggregator
    
    * fix: pull changes from other files
    
    * cargo fix
    
    * cargo fmt
    
    * docs: edit docstrings
    
    * allow dead code (while the complete feature is beint built)
    
    * chore: restructure
    
    * feat: introduce GroupKey, minor other improvements
    
    * cargo fmt
    
    * chore: specify aggregator visibility
    
    * fix: oops, leaking "private" type
    
    * refactor-fix: restructure and refactor group_by
    
    * cargo fix
    
    * fix: don't panic when there is no group-by field
    
    * remove print statements
    
    * amend: `>=`  -> `==`
    
    * perf: remove double clone
    
    * chore: sync aggregator from other branch
    
    * chore: cleanup print statemets
    
    * test: ignore big tests
    
    * cargo fmt
    
    * refactor: add early stop when the groups have been filled, improve code
    
    * chore: sync aggregator, remove print from test
    
    * refactor: consider shard_selection, improve collection_by_name handling
    
    * feat: add bucketing to table of content
    
    * refactor: better errors, improve tests
    
    * test: add integration tests
    
    * feat: add endpoints
    
    * refactor: introduce ScoredPoint wrapper, restructure types
    
    * sync aggregator
    
    * edit internal grouping visibility
    
    * feat: group_by internals
    
    * cargo fmt
    
    * cargo fmt
    
    * refactor: turn inner fn into closure
    
    * test: fix test to support new vector output representation
    
    * feat: wire up grouping with actix
    
    * expose grouped_by field
    
    * fix: change output group format
    
    * feat: wire up openapi
    
    * fix: finish wiring up grouping in actix
    
    * tests: fix test_group.py
    
    * cargo fmt
    
    * refactor: extract constants
    
    * remove Hash from ScoredPoint
    
    * `Option<collection_by_name>` -> `collection_by_name`
    
    * fix: handle better cases on `match_on`
    
    * fix: consider that subsequent calls can bring better results
    
    * cargo fmt
    
    * fix clippy warnings
    
    * cargo fmt
    
    * refactor: move `Group` to `types`, localize `hydrate_from`, remove `Deref` impls
    
    * refactor `add_points`
    
    * refactor: turn `GroupKey` into enum
    
    * refactor: make `HashablePoint` inner struct private
    
    * feat: add grpc layer, make new `PointGroup` type to use as output
    
    * fix: update openapi models
    
    * docs: update grpc docs
    
    * fix merge errors
    
    * refactor: add BaseGroupRequest to make code DRYer, improve doc comments
    
    * cargo fmt
    
    * perf: increase precision; choose best groups by score
    
    * misc: add more integration tests, fix review comments
    
    * cargo fmt
    
    * fix: reimplement interface to flatten search and recommend requests, excluding offset
    
    * cargo fmt
    
    * refactor: move `r#do` impl to `GroupRequest`
    
    * fix: update grpc docs
    
    * perf: sort in reverse order
    
    * fix: use fist value of a Value::Array
    
    * fix: validate group_by to not support bracket notation, fix int. tests
    
    * fix: update grpc validation
    
    * tests: update collection_tests
    
    * refactor: move validation to the api layers
    
    * Oops: reupdate tests
    
    * refactor: let the derives derive (thanks @ffuugoo)
    
    * refactor: use a new GroupId on the output
    
    also increases performance by copying less
    
    * remove hashable set, take ordering into an account, fix mutliple groups values support
    
    * fmt
    
    * refactor group_id + rename per_group -> group_size, fix clippy
    
    * remove GroupKey wrapper
    
    * @agourlay review fixes
    
    * refactor: `group_min_scores` and `group_max_scores` ->  `group_best_scores`
    
    * refactor: use set difference on `keys_of_unfilled_best_groups`
    
    * refactor: use set intersection on `len_of_filled_best_groups`
    
    * refactor: turn best_group_keys into iterator
    
    * fix: remove [] syntax limitation
    
    * fix: update openapi.json
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 9c0891951..fa0070617 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -5,14 +5,15 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints, GetPoints,
     GetResponse, PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse,
-    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
-    SearchBatchResponse, SearchPoints, SearchResponse, SetPayloadPoints, UpdatePointVectors,
+    RecommendGroupsResponse, RecommendPointGroups, RecommendPoints, RecommendResponse,
+    ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse,
+    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdatePointVectors,
     UpsertPoints,
 };
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
-use super::points_common::{delete_vectors, update_vectors};
+use super::points_common::{delete_vectors, recommend_groups, search_groups, update_vectors};
 use super::validate;
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
@@ -145,6 +146,14 @@ impl Points for PointsService {
         .await
     }
 
+    async fn search_groups(
+        &self,
+        request: Request<SearchPointGroups>,
+    ) -> Result<Response<SearchGroupsResponse>, Status> {
+        validate(request.get_ref())?;
+        search_groups(self.toc.as_ref(), request.into_inner(), None).await
+    }
+
     async fn scroll(
         &self,
         request: Request<ScrollPoints>,
@@ -180,6 +189,14 @@ impl Points for PointsService {
         .await
     }
 
+    async fn recommend_groups(
+        &self,
+        request: Request<RecommendPointGroups>,
+    ) -> Result<Response<RecommendGroupsResponse>, Status> {
+        validate(request.get_ref())?;
+        recommend_groups(self.toc.as_ref(), request.into_inner()).await
+    }
+
     async fn count(
         &self,
         request: Request<CountPoints>,

commit 57ef69f95427b741709308dfe4846c9d21ea29b3
Author: Jesse <github@jessebakker.com>
Date:   Mon Aug 7 16:16:41 2023 +0200

    Add batch update endpoint for points API (#1951)
    
    * Add batch update endpoint for points API
    
    * Add validation to batch update operation
    
    * Update gRPC
    
    * Add update and delete vector operations to point update batch
    
    * Improve batch point update tests, add multivec, extract into module
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index fa0070617..70f658a51 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -7,13 +7,15 @@ use api::grpc::qdrant::{
     GetResponse, PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse,
     RecommendGroupsResponse, RecommendPointGroups, RecommendPoints, RecommendResponse,
     ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse,
-    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdatePointVectors,
-    UpsertPoints,
+    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
+    UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
 use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
-use super::points_common::{delete_vectors, recommend_groups, search_groups, update_vectors};
+use super::points_common::{
+    delete_vectors, recommend_groups, search_groups, update_batch, update_vectors,
+};
 use super::validate;
 use crate::tonic::api::points_common::{
     clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
@@ -102,6 +104,14 @@ impl Points for PointsService {
         clear_payload(self.toc.as_ref(), request.into_inner(), None).await
     }
 
+    async fn update_batch(
+        &self,
+        request: Request<UpdateBatchPoints>,
+    ) -> Result<Response<UpdateBatchResponse>, Status> {
+        validate(request.get_ref())?;
+        update_batch(self.toc.as_ref(), request.into_inner(), None).await
+    }
+
     async fn create_field_index(
         &self,
         request: Request<CreateFieldIndexCollection>,

commit 87524275d4ff940145ff0110932f2b4d64f987b9
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Nov 2 12:45:46 2023 -0400

    Expose timeout query param for search requests (#2748)
    
    * add timeout query param for search requests
    
    * enable timeout for recommend requests
    
    * Add query timeout for group by requests
    
    * update openapi models
    
    * Don't decrease timeout after recommend preprocessing
    
    * Add openapi test
    
    * code review
    
    * add timeout to individual group by requests, non-decreasing
    
    * handle timeout for discover
    
    * Update timeout field tag in SearchBatchPoints
    message

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 70f658a51..7c0010fa1 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,4 +1,5 @@
 use std::sync::Arc;
+use std::time::Duration;
 
 use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
@@ -145,13 +146,18 @@ impl Points for PointsService {
             collection_name,
             search_points,
             read_consistency,
+            timeout,
         } = request.into_inner();
+
+        let timeout = timeout.map(Duration::from_secs);
+
         search_batch(
             self.toc.as_ref(),
             collection_name,
             search_points,
             read_consistency,
             None,
+            timeout,
         )
         .await
     }
@@ -189,12 +195,14 @@ impl Points for PointsService {
             collection_name,
             recommend_points,
             read_consistency,
+            timeout,
         } = request.into_inner();
         recommend_batch(
             self.toc.as_ref(),
             collection_name,
             recommend_points,
             read_consistency,
+            timeout.map(Duration::from_secs),
         )
         .await
     }

commit 91eb3f36e2fb417ace435cb7a336c8999109d090
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 8 09:22:31 2023 -0400

    Discovery API (#2861)
    
    * create and connect discovery http and grpc interfaces
    
    * add openapi tests
    
    * fix bad rebase
    
    * Add better descriptions
    
    * remove numpy from openapi tests
    
    * fix rebase artifact
    
    * remove already addressed TODO
    
    * add more tests
    
    * 🤡🔫 (cfg batch handler)
    
    * add timeout query param for discover requests
    
    * More gRPC validation
    
    * make fields pydantic_openapi_generator_v3 friendly
    
    * `context_pairs` -> `context` with struct for pairs
    
    * discovery api is only discovery or context,
    move struct description to fields
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 7c0010fa1..82240faa5 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -4,7 +4,8 @@ use std::time::Duration;
 use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
-    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints, GetPoints,
+    DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
+    DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, GetPoints,
     GetResponse, PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse,
     RecommendGroupsResponse, RecommendPointGroups, RecommendPoints, RecommendResponse,
     ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse,
@@ -15,7 +16,8 @@ use storage::content_manager::toc::TableOfContent;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
-    delete_vectors, recommend_groups, search_groups, update_batch, update_vectors,
+    delete_vectors, discover, discover_batch, recommend_groups, search_groups, update_batch,
+    update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
@@ -215,6 +217,35 @@ impl Points for PointsService {
         recommend_groups(self.toc.as_ref(), request.into_inner()).await
     }
 
+    async fn discover(
+        &self,
+        request: Request<DiscoverPoints>,
+    ) -> Result<Response<DiscoverResponse>, Status> {
+        validate(request.get_ref())?;
+        discover(self.toc.as_ref(), request.into_inner()).await
+    }
+
+    async fn discover_batch(
+        &self,
+        request: Request<DiscoverBatchPoints>,
+    ) -> Result<Response<DiscoverBatchResponse>, Status> {
+        validate(request.get_ref())?;
+        let DiscoverBatchPoints {
+            collection_name,
+            discover_points,
+            read_consistency,
+            timeout,
+        } = request.into_inner();
+        discover_batch(
+            self.toc.as_ref(),
+            collection_name,
+            discover_points,
+            read_consistency,
+            timeout.map(Duration::from_secs),
+        )
+        .await
+    }
+
     async fn count(
         &self,
         request: Request<CountPoints>,

commit d3aada0e9644975b94409fd79c94e990643614a0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Nov 10 17:23:30 2023 +0100

    Shard key index consistency (#2938)
    
    * WIP: collection-level storage for payload indexe scheme
    
    * introduce consensus-level operation for creating payload index
    
    * make operation_id optional in the UpdateResult
    
    * set payload index in newly created shards
    
    * upd api definitions
    
    * include payload index schema into collection consensus state
    
    * include payload index schema into shard snapshot
    
    * review fixes

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 82240faa5..b372e3dde 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -12,7 +12,7 @@ use api::grpc::qdrant::{
     SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
     UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
-use storage::content_manager::toc::TableOfContent;
+use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
@@ -27,12 +27,12 @@ use crate::tonic::api::points_common::{
 };
 
 pub struct PointsService {
-    toc: Arc<TableOfContent>,
+    dispatcher: Arc<Dispatcher>,
 }
 
 impl PointsService {
-    pub fn new(toc: Arc<TableOfContent>) -> Self {
-        Self { toc }
+    pub fn new(dispatcher: Arc<Dispatcher>) -> Self {
+        Self { dispatcher }
     }
 }
 
@@ -43,7 +43,7 @@ impl Points for PointsService {
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        upsert(self.toc.as_ref(), request.into_inner(), None).await
+        upsert(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete(
@@ -51,12 +51,12 @@ impl Points for PointsService {
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete(self.toc.as_ref(), request.into_inner(), None).await
+        delete(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         validate(request.get_ref())?;
-        get(self.toc.as_ref(), request.into_inner(), None).await
+        get(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn update_vectors(
@@ -64,7 +64,7 @@ impl Points for PointsService {
         request: Request<UpdatePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        update_vectors(self.toc.as_ref(), request.into_inner(), None).await
+        update_vectors(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete_vectors(
@@ -72,7 +72,7 @@ impl Points for PointsService {
         request: Request<DeletePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_vectors(self.toc.as_ref(), request.into_inner(), None).await
+        delete_vectors(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn set_payload(
@@ -80,7 +80,7 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        set_payload(self.toc.as_ref(), request.into_inner(), None).await
+        set_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn overwrite_payload(
@@ -88,7 +88,7 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        overwrite_payload(self.toc.as_ref(), request.into_inner(), None).await
+        overwrite_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete_payload(
@@ -96,7 +96,7 @@ impl Points for PointsService {
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_payload(self.toc.as_ref(), request.into_inner(), None).await
+        delete_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn clear_payload(
@@ -104,7 +104,7 @@ impl Points for PointsService {
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        clear_payload(self.toc.as_ref(), request.into_inner(), None).await
+        clear_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn update_batch(
@@ -112,7 +112,7 @@ impl Points for PointsService {
         request: Request<UpdateBatchPoints>,
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
-        update_batch(self.toc.as_ref(), request.into_inner(), None).await
+        update_batch(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn create_field_index(
@@ -120,7 +120,7 @@ impl Points for PointsService {
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        create_field_index(self.toc.as_ref(), request.into_inner(), None).await
+        create_field_index(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn delete_field_index(
@@ -128,7 +128,7 @@ impl Points for PointsService {
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_field_index(self.toc.as_ref(), request.into_inner(), None).await
+        delete_field_index(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn search(
@@ -136,7 +136,7 @@ impl Points for PointsService {
         request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
-        search(self.toc.as_ref(), request.into_inner(), None).await
+        search(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn search_batch(
@@ -154,7 +154,7 @@ impl Points for PointsService {
         let timeout = timeout.map(Duration::from_secs);
 
         search_batch(
-            self.toc.as_ref(),
+            self.dispatcher.as_ref(),
             collection_name,
             search_points,
             read_consistency,
@@ -169,7 +169,7 @@ impl Points for PointsService {
         request: Request<SearchPointGroups>,
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        search_groups(self.toc.as_ref(), request.into_inner(), None).await
+        search_groups(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn scroll(
@@ -177,7 +177,7 @@ impl Points for PointsService {
         request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
         validate(request.get_ref())?;
-        scroll(self.toc.as_ref(), request.into_inner(), None).await
+        scroll(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 
     async fn recommend(
@@ -185,7 +185,7 @@ impl Points for PointsService {
         request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
-        recommend(self.toc.as_ref(), request.into_inner()).await
+        recommend(self.dispatcher.as_ref(), request.into_inner()).await
     }
 
     async fn recommend_batch(
@@ -200,7 +200,7 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
         recommend_batch(
-            self.toc.as_ref(),
+            self.dispatcher.as_ref(),
             collection_name,
             recommend_points,
             read_consistency,
@@ -214,7 +214,7 @@ impl Points for PointsService {
         request: Request<RecommendPointGroups>,
     ) -> Result<Response<RecommendGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        recommend_groups(self.toc.as_ref(), request.into_inner()).await
+        recommend_groups(self.dispatcher.as_ref(), request.into_inner()).await
     }
 
     async fn discover(
@@ -222,7 +222,7 @@ impl Points for PointsService {
         request: Request<DiscoverPoints>,
     ) -> Result<Response<DiscoverResponse>, Status> {
         validate(request.get_ref())?;
-        discover(self.toc.as_ref(), request.into_inner()).await
+        discover(self.dispatcher.as_ref(), request.into_inner()).await
     }
 
     async fn discover_batch(
@@ -237,7 +237,7 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
         discover_batch(
-            self.toc.as_ref(),
+            self.dispatcher.as_ref(),
             collection_name,
             discover_points,
             read_consistency,
@@ -251,6 +251,6 @@ impl Points for PointsService {
         request: Request<CountPoints>,
     ) -> Result<Response<CountResponse>, Status> {
         validate(request.get_ref())?;
-        count(self.toc.as_ref(), request.into_inner(), None).await
+        count(self.dispatcher.as_ref(), request.into_inner(), None).await
     }
 }

commit cae3c45bf5d08ef6900cb88891b72f0b0bbf154e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Nov 10 18:38:01 2023 +0100

    Remove deprecated search methods (#2970)
    
    * remove duplicated search methods, introduced for compatibility in last version
    
    * Use `with_capacity` rather than a manual reserve
    
    * explicit Arc clones
    
    * get rid of batching by runs of same strategy
    
    * avoid refactor in group by
    
    * more explicit arc clones, remove one .expect()
    
    * little extra refactor on recommendations.rs
    
    * refactor grouping_test.rs too
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index b372e3dde..8f680a3c9 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -12,6 +12,7 @@ use api::grpc::qdrant::{
     SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
     UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
+use collection::operations::types::{CoreSearchRequest, CoreSearchRequestBatch};
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
@@ -21,9 +22,9 @@ use super::points_common::{
 };
 use super::validate;
 use crate::tonic::api::points_common::{
-    clear_payload, count, create_field_index, delete, delete_field_index, delete_payload, get,
-    overwrite_payload, recommend, recommend_batch, scroll, search, search_batch, set_payload,
-    upsert,
+    clear_payload, core_search_batch, count, create_field_index, delete, delete_field_index,
+    delete_payload, get, overwrite_payload, recommend, recommend_batch, scroll, search,
+    set_payload, upsert,
 };
 
 pub struct PointsService {
@@ -153,10 +154,19 @@ impl Points for PointsService {
 
         let timeout = timeout.map(Duration::from_secs);
 
-        search_batch(
+        let core_search_points: Result<Vec<_>, _> = search_points
+            .into_iter()
+            .map(CoreSearchRequest::try_from)
+            .collect();
+
+        let request = CoreSearchRequestBatch {
+            searches: core_search_points?,
+        };
+
+        core_search_batch(
             self.dispatcher.as_ref(),
             collection_name,
-            search_points,
+            request,
             read_consistency,
             None,
             timeout,

commit 2810672598fcba5aac80077daf469791475d1b5e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 14 16:47:05 2023 +0100

    Huge refactoring to make read requests aware of shard key selector (#3004)
    
    * huge refactoring to make read requests avare of shard key selector
    
    * fix integration test
    
    * review fixes
    
    * allow lookup_from specific shards

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 8f680a3c9..49834a6a0 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -12,7 +12,7 @@ use api::grpc::qdrant::{
     SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
     UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
-use collection::operations::types::{CoreSearchRequest, CoreSearchRequestBatch};
+use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
@@ -22,9 +22,9 @@ use super::points_common::{
 };
 use super::validate;
 use crate::tonic::api::points_common::{
-    clear_payload, core_search_batch, count, create_field_index, delete, delete_field_index,
-    delete_payload, get, overwrite_payload, recommend, recommend_batch, scroll, search,
-    set_payload, upsert,
+    clear_payload, convert_shard_selector_for_read, core_search_batch, count, create_field_index,
+    delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
+    scroll, search, set_payload, upsert,
 };
 
 pub struct PointsService {
@@ -154,21 +154,22 @@ impl Points for PointsService {
 
         let timeout = timeout.map(Duration::from_secs);
 
-        let core_search_points: Result<Vec<_>, _> = search_points
-            .into_iter()
-            .map(CoreSearchRequest::try_from)
-            .collect();
+        let mut requests = Vec::new();
 
-        let request = CoreSearchRequestBatch {
-            searches: core_search_points?,
-        };
+        for mut search_point in search_points {
+            let shard_key = search_point.shard_key_selector.take();
+
+            let shard_selector = convert_shard_selector_for_read(None, shard_key);
+            let core_search_request = CoreSearchRequest::try_from(search_point)?;
+
+            requests.push((core_search_request, shard_selector));
+        }
 
         core_search_batch(
             self.dispatcher.as_ref(),
             collection_name,
-            request,
+            requests,
             read_consistency,
-            None,
             timeout,
         )
         .await

commit 4fce0037f330fc244be93bd2a8da08a97648563d
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Jan 31 09:00:42 2024 +0100

    Make update API cancel safe (#3367)
    
    * WIP: `tokio::spawn` update API request handlers [skip ci]
    
    * WIP: `cancel::future::spawn_cancel_on_drop` update API request handlers [skip ci]
    
    * WIP: Make update API cancel-safe [skip ci]
    
    TODO:
    - Fix tests
    - Evaluate and resolve TODOs
    
    * Fix tests
    
    * Fix benches
    
    * WIP: Simplify cancel safety implementation
    
    * Document and annotate cancel safety guarantees of update API
    
    - Also fix tests after simplifying update API cancel safety impl
    - And add a few `cancel::future::cancel_on_token` calls here and there
    
    * Further simplify cancel safety implementation
    
    No more cancellation tokens! 🎉
    
    * Resolve cancel safety TODO
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 49834a6a0..99b6fbc0d 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -44,7 +44,7 @@ impl Points for PointsService {
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        upsert(self.dispatcher.as_ref(), request.into_inner(), None).await
+        upsert(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn delete(
@@ -52,7 +52,7 @@ impl Points for PointsService {
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete(self.dispatcher.as_ref(), request.into_inner(), None).await
+        delete(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
@@ -65,7 +65,7 @@ impl Points for PointsService {
         request: Request<UpdatePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        update_vectors(self.dispatcher.as_ref(), request.into_inner(), None).await
+        update_vectors(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn delete_vectors(
@@ -73,7 +73,7 @@ impl Points for PointsService {
         request: Request<DeletePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_vectors(self.dispatcher.as_ref(), request.into_inner(), None).await
+        delete_vectors(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn set_payload(
@@ -81,7 +81,7 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        set_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
+        set_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn overwrite_payload(
@@ -89,7 +89,7 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        overwrite_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
+        overwrite_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn delete_payload(
@@ -97,7 +97,7 @@ impl Points for PointsService {
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
+        delete_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn clear_payload(
@@ -105,7 +105,7 @@ impl Points for PointsService {
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        clear_payload(self.dispatcher.as_ref(), request.into_inner(), None).await
+        clear_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn update_batch(
@@ -113,7 +113,7 @@ impl Points for PointsService {
         request: Request<UpdateBatchPoints>,
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
-        update_batch(self.dispatcher.as_ref(), request.into_inner(), None).await
+        update_batch(self.dispatcher.toc().clone(), request.into_inner(), None).await
     }
 
     async fn create_field_index(
@@ -121,7 +121,7 @@ impl Points for PointsService {
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        create_field_index(self.dispatcher.as_ref(), request.into_inner(), None).await
+        create_field_index(self.dispatcher.clone(), request.into_inner(), None).await
     }
 
     async fn delete_field_index(
@@ -129,7 +129,7 @@ impl Points for PointsService {
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_field_index(self.dispatcher.as_ref(), request.into_inner(), None).await
+        delete_field_index(self.dispatcher.clone(), request.into_inner(), None).await
     }
 
     async fn search(

commit 99b750fcfa63444e07105947f7fd4fb241d7b050
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Feb 1 11:44:13 2024 +0100

    Add `clock_tag` field to update operations (#3408)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 99b6fbc0d..b8fa36ff7 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -44,7 +44,14 @@ impl Points for PointsService {
         request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        upsert(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        upsert(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn delete(
@@ -52,7 +59,14 @@ impl Points for PointsService {
         request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        delete(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
@@ -65,7 +79,14 @@ impl Points for PointsService {
         request: Request<UpdatePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        update_vectors(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        update_vectors(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn delete_vectors(
@@ -73,7 +94,14 @@ impl Points for PointsService {
         request: Request<DeletePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_vectors(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        delete_vectors(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn set_payload(
@@ -81,7 +109,14 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        set_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        set_payload(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn overwrite_payload(
@@ -89,7 +124,14 @@ impl Points for PointsService {
         request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        overwrite_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        overwrite_payload(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn delete_payload(
@@ -97,7 +139,14 @@ impl Points for PointsService {
         request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        delete_payload(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn clear_payload(
@@ -105,7 +154,14 @@ impl Points for PointsService {
         request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        clear_payload(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        clear_payload(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn update_batch(
@@ -113,7 +169,13 @@ impl Points for PointsService {
         request: Request<UpdateBatchPoints>,
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
-        update_batch(self.dispatcher.toc().clone(), request.into_inner(), None).await
+        update_batch(
+            self.dispatcher.toc().clone(),
+            request.into_inner(),
+            None,
+            None,
+        )
+        .await
     }
 
     async fn create_field_index(
@@ -121,7 +183,9 @@ impl Points for PointsService {
         request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        create_field_index(self.dispatcher.clone(), request.into_inner(), None).await
+        create_field_index(self.dispatcher.clone(), request.into_inner(), None, None)
+            .await
+            .map(|resp| resp.map(Into::into))
     }
 
     async fn delete_field_index(
@@ -129,7 +193,9 @@ impl Points for PointsService {
         request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_field_index(self.dispatcher.clone(), request.into_inner(), None).await
+        delete_field_index(self.dispatcher.clone(), request.into_inner(), None, None)
+            .await
+            .map(|resp| resp.map(Into::into))
     }
 
     async fn search(

commit 7c69d2b0acb5441a5fe614d3a040f953a29dbeac
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Mar 18 13:14:09 2024 -0300

    RBAC: Route `Claims` into `TableOfContent` for points API (#3801)
    
    * drill claims into search api
    
    * drill claims into recommend api
    
    * drill claims into count api
    
    * drill claims into retrieve api
    
    * drill claims into groups api
    
    * drill claims into discover api
    
    * drill claims into scroll api
    
    * drill claims into update apis
    
    * use `Extension<T>`
    
    * use owned claims everywhere
    
    * no claims in internal api

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index b8fa36ff7..5fdb49b74 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -26,6 +26,7 @@ use crate::tonic::api::points_common::{
     delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
     scroll, search, set_payload, upsert,
 };
+use crate::tonic::auth::extract_claims;
 
 pub struct PointsService {
     dispatcher: Arc<Dispatcher>,
@@ -41,14 +42,18 @@ impl PointsService {
 impl Points for PointsService {
     async fn upsert(
         &self,
-        request: Request<UpsertPoints>,
+        mut request: Request<UpsertPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         upsert(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -56,34 +61,45 @@ impl Points for PointsService {
 
     async fn delete(
         &self,
-        request: Request<DeletePoints>,
+        mut request: Request<DeletePoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         delete(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
     }
 
-    async fn get(&self, request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
+    async fn get(&self, mut request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         validate(request.get_ref())?;
-        get(self.dispatcher.as_ref(), request.into_inner(), None).await
+
+        let claims = extract_claims(&mut request);
+
+        get(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
     async fn update_vectors(
         &self,
-        request: Request<UpdatePointVectors>,
+        mut request: Request<UpdatePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         update_vectors(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -91,14 +107,18 @@ impl Points for PointsService {
 
     async fn delete_vectors(
         &self,
-        request: Request<DeletePointVectors>,
+        mut request: Request<DeletePointVectors>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         delete_vectors(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -106,14 +126,18 @@ impl Points for PointsService {
 
     async fn set_payload(
         &self,
-        request: Request<SetPayloadPoints>,
+        mut request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         set_payload(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -121,14 +145,18 @@ impl Points for PointsService {
 
     async fn overwrite_payload(
         &self,
-        request: Request<SetPayloadPoints>,
+        mut request: Request<SetPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         overwrite_payload(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -136,14 +164,18 @@ impl Points for PointsService {
 
     async fn delete_payload(
         &self,
-        request: Request<DeletePayloadPoints>,
+        mut request: Request<DeletePayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         delete_payload(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -151,14 +183,18 @@ impl Points for PointsService {
 
     async fn clear_payload(
         &self,
-        request: Request<ClearPayloadPoints>,
+        mut request: Request<ClearPayloadPoints>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         clear_payload(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -166,51 +202,77 @@ impl Points for PointsService {
 
     async fn update_batch(
         &self,
-        request: Request<UpdateBatchPoints>,
+        mut request: Request<UpdateBatchPoints>,
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         update_batch(
             self.dispatcher.toc().clone(),
             request.into_inner(),
             None,
             None,
+            claims,
         )
         .await
     }
 
     async fn create_field_index(
         &self,
-        request: Request<CreateFieldIndexCollection>,
+        mut request: Request<CreateFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        create_field_index(self.dispatcher.clone(), request.into_inner(), None, None)
-            .await
-            .map(|resp| resp.map(Into::into))
+
+        let claims = extract_claims(&mut request);
+
+        create_field_index(
+            self.dispatcher.clone(),
+            request.into_inner(),
+            None,
+            None,
+            claims,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn delete_field_index(
         &self,
-        request: Request<DeleteFieldIndexCollection>,
+        mut request: Request<DeleteFieldIndexCollection>,
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
-        delete_field_index(self.dispatcher.clone(), request.into_inner(), None, None)
-            .await
-            .map(|resp| resp.map(Into::into))
+
+        let claims = extract_claims(&mut request);
+
+        delete_field_index(
+            self.dispatcher.clone(),
+            request.into_inner(),
+            None,
+            None,
+            claims,
+        )
+        .await
+        .map(|resp| resp.map(Into::into))
     }
 
     async fn search(
         &self,
-        request: Request<SearchPoints>,
+        mut request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
-        search(self.dispatcher.as_ref(), request.into_inner(), None).await
+        let claims = extract_claims(&mut request);
+        search(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
     async fn search_batch(
         &self,
-        request: Request<SearchBatchPoints>,
+        mut request: Request<SearchBatchPoints>,
     ) -> Result<Response<SearchBatchResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         let SearchBatchPoints {
             collection_name,
             search_points,
@@ -236,6 +298,7 @@ impl Points for PointsService {
             collection_name,
             requests,
             read_consistency,
+            claims,
             timeout,
         )
         .await
@@ -243,33 +306,39 @@ impl Points for PointsService {
 
     async fn search_groups(
         &self,
-        request: Request<SearchPointGroups>,
+        mut request: Request<SearchPointGroups>,
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        search_groups(self.dispatcher.as_ref(), request.into_inner(), None).await
+        let claims = extract_claims(&mut request);
+        search_groups(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
     async fn scroll(
         &self,
-        request: Request<ScrollPoints>,
+        mut request: Request<ScrollPoints>,
     ) -> Result<Response<ScrollResponse>, Status> {
         validate(request.get_ref())?;
-        scroll(self.dispatcher.as_ref(), request.into_inner(), None).await
+
+        let claims = extract_claims(&mut request);
+
+        scroll(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
     async fn recommend(
         &self,
-        request: Request<RecommendPoints>,
+        mut request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
-        recommend(self.dispatcher.as_ref(), request.into_inner()).await
+        let claims = extract_claims(&mut request);
+        recommend(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
 
     async fn recommend_batch(
         &self,
-        request: Request<RecommendBatchPoints>,
+        mut request: Request<RecommendBatchPoints>,
     ) -> Result<Response<RecommendBatchResponse>, Status> {
         validate(request.get_ref())?;
+        let claims = extract_claims(&mut request);
         let RecommendBatchPoints {
             collection_name,
             recommend_points,
@@ -281,6 +350,7 @@ impl Points for PointsService {
             collection_name,
             recommend_points,
             read_consistency,
+            claims,
             timeout.map(Duration::from_secs),
         )
         .await
@@ -288,36 +358,47 @@ impl Points for PointsService {
 
     async fn recommend_groups(
         &self,
-        request: Request<RecommendPointGroups>,
+        mut request: Request<RecommendPointGroups>,
     ) -> Result<Response<RecommendGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        recommend_groups(self.dispatcher.as_ref(), request.into_inner()).await
+
+        let claims = extract_claims(&mut request);
+
+        recommend_groups(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
 
     async fn discover(
         &self,
-        request: Request<DiscoverPoints>,
+        mut request: Request<DiscoverPoints>,
     ) -> Result<Response<DiscoverResponse>, Status> {
         validate(request.get_ref())?;
-        discover(self.dispatcher.as_ref(), request.into_inner()).await
+
+        let claims = extract_claims(&mut request);
+
+        discover(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
 
     async fn discover_batch(
         &self,
-        request: Request<DiscoverBatchPoints>,
+        mut request: Request<DiscoverBatchPoints>,
     ) -> Result<Response<DiscoverBatchResponse>, Status> {
         validate(request.get_ref())?;
+
+        let claims = extract_claims(&mut request);
+
         let DiscoverBatchPoints {
             collection_name,
             discover_points,
             read_consistency,
             timeout,
         } = request.into_inner();
+
         discover_batch(
             self.dispatcher.as_ref(),
             collection_name,
             discover_points,
             read_consistency,
+            claims,
             timeout.map(Duration::from_secs),
         )
         .await
@@ -325,9 +406,12 @@ impl Points for PointsService {
 
     async fn count(
         &self,
-        request: Request<CountPoints>,
+        mut request: Request<CountPoints>,
     ) -> Result<Response<CountResponse>, Status> {
         validate(request.get_ref())?;
-        count(self.dispatcher.as_ref(), request.into_inner(), None).await
+
+        let claims = extract_claims(&mut request);
+
+        count(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 }

commit 802641f9d6725eaf01eb5c9d3fb71151e7b00045
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Mar 27 15:44:26 2024 +0000

    RBAC: Introduce Access object and use it (#3925)
    
    * Introduce Access object and use it
    
    * Make Access non-optional
    
    * Allow creating sharding key if collection claim is not present
    
    * Tear up rbac crate into the main crate and storage crate

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 5fdb49b74..ca0fe6092 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -26,7 +26,7 @@ use crate::tonic::api::points_common::{
     delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
     scroll, search, set_payload, upsert,
 };
-use crate::tonic::auth::extract_claims;
+use crate::tonic::auth::extract_access;
 
 pub struct PointsService {
     dispatcher: Arc<Dispatcher>,
@@ -46,7 +46,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         upsert(
             self.dispatcher.toc().clone(),
@@ -65,7 +65,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         delete(
             self.dispatcher.toc().clone(),
@@ -81,7 +81,7 @@ impl Points for PointsService {
     async fn get(&self, mut request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         get(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
@@ -92,7 +92,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         update_vectors(
             self.dispatcher.toc().clone(),
@@ -111,7 +111,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         delete_vectors(
             self.dispatcher.toc().clone(),
@@ -130,7 +130,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         set_payload(
             self.dispatcher.toc().clone(),
@@ -149,7 +149,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         overwrite_payload(
             self.dispatcher.toc().clone(),
@@ -168,7 +168,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         delete_payload(
             self.dispatcher.toc().clone(),
@@ -187,7 +187,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         clear_payload(
             self.dispatcher.toc().clone(),
@@ -206,7 +206,7 @@ impl Points for PointsService {
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         update_batch(
             self.dispatcher.toc().clone(),
@@ -224,7 +224,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         create_field_index(
             self.dispatcher.clone(),
@@ -243,7 +243,7 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         delete_field_index(
             self.dispatcher.clone(),
@@ -261,7 +261,7 @@ impl Points for PointsService {
         mut request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
         search(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
@@ -271,7 +271,7 @@ impl Points for PointsService {
     ) -> Result<Response<SearchBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         let SearchBatchPoints {
             collection_name,
@@ -309,7 +309,7 @@ impl Points for PointsService {
         mut request: Request<SearchPointGroups>,
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
         search_groups(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
 
@@ -319,7 +319,7 @@ impl Points for PointsService {
     ) -> Result<Response<ScrollResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         scroll(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }
@@ -329,7 +329,7 @@ impl Points for PointsService {
         mut request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
         recommend(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
 
@@ -338,7 +338,7 @@ impl Points for PointsService {
         mut request: Request<RecommendBatchPoints>,
     ) -> Result<Response<RecommendBatchResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
         let RecommendBatchPoints {
             collection_name,
             recommend_points,
@@ -362,7 +362,7 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendGroupsResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         recommend_groups(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
@@ -373,7 +373,7 @@ impl Points for PointsService {
     ) -> Result<Response<DiscoverResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         discover(self.dispatcher.as_ref(), request.into_inner(), claims).await
     }
@@ -384,7 +384,7 @@ impl Points for PointsService {
     ) -> Result<Response<DiscoverBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         let DiscoverBatchPoints {
             collection_name,
@@ -410,7 +410,7 @@ impl Points for PointsService {
     ) -> Result<Response<CountResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_claims(&mut request);
+        let claims = extract_access(&mut request);
 
         count(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
     }

commit e4286f98b5334f60bdb7ec03753623f1effa9f1b
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 3 13:10:46 2024 +0000

    RBAC: new JWT schema (#3941)
    
    * RBAC: new JWT schema
    
    * Address review comments
    
    Renames, validation, default values, drop Ord
    
    * require access to whole collection to read its stats
    
    * fmt
    
    * remove unrelated
    
    * Introduce AccessRequrements
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index ca0fe6092..e9c2e3201 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -83,7 +83,7 @@ impl Points for PointsService {
 
         let claims = extract_access(&mut request);
 
-        get(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
+        get(self.dispatcher.toc(), request.into_inner(), None, claims).await
     }
 
     async fn update_vectors(
@@ -262,7 +262,7 @@ impl Points for PointsService {
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
         let claims = extract_access(&mut request);
-        search(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
+        search(self.dispatcher.toc(), request.into_inner(), None, claims).await
     }
 
     async fn search_batch(
@@ -294,7 +294,7 @@ impl Points for PointsService {
         }
 
         core_search_batch(
-            self.dispatcher.as_ref(),
+            self.dispatcher.toc(),
             collection_name,
             requests,
             read_consistency,
@@ -310,7 +310,7 @@ impl Points for PointsService {
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
         let claims = extract_access(&mut request);
-        search_groups(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
+        search_groups(self.dispatcher.toc(), request.into_inner(), None, claims).await
     }
 
     async fn scroll(
@@ -321,7 +321,7 @@ impl Points for PointsService {
 
         let claims = extract_access(&mut request);
 
-        scroll(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
+        scroll(self.dispatcher.toc(), request.into_inner(), None, claims).await
     }
 
     async fn recommend(
@@ -330,7 +330,7 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
         let claims = extract_access(&mut request);
-        recommend(self.dispatcher.as_ref(), request.into_inner(), claims).await
+        recommend(self.dispatcher.toc(), request.into_inner(), claims).await
     }
 
     async fn recommend_batch(
@@ -346,7 +346,7 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
         recommend_batch(
-            self.dispatcher.as_ref(),
+            self.dispatcher.toc(),
             collection_name,
             recommend_points,
             read_consistency,
@@ -364,7 +364,7 @@ impl Points for PointsService {
 
         let claims = extract_access(&mut request);
 
-        recommend_groups(self.dispatcher.as_ref(), request.into_inner(), claims).await
+        recommend_groups(self.dispatcher.toc(), request.into_inner(), claims).await
     }
 
     async fn discover(
@@ -375,7 +375,7 @@ impl Points for PointsService {
 
         let claims = extract_access(&mut request);
 
-        discover(self.dispatcher.as_ref(), request.into_inner(), claims).await
+        discover(self.dispatcher.toc(), request.into_inner(), claims).await
     }
 
     async fn discover_batch(
@@ -394,7 +394,7 @@ impl Points for PointsService {
         } = request.into_inner();
 
         discover_batch(
-            self.dispatcher.as_ref(),
+            self.dispatcher.toc(),
             collection_name,
             discover_points,
             read_consistency,
@@ -412,6 +412,6 @@ impl Points for PointsService {
 
         let claims = extract_access(&mut request);
 
-        count(self.dispatcher.as_ref(), request.into_inner(), None, claims).await
+        count(self.dispatcher.toc(), request.into_inner(), None, claims).await
     }
 }

commit ae08d856b764cbe762047dbfdc318f2adfe85627
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Apr 8 22:19:43 2024 +0000

    RBAC: require access token in ToC functions (#3972)
    
    * claims -> access
    
    * Require access for Dispatcher::toc()
    
    * Require Access for various collection functions
    
    * review fixes
    
    * comment nit
    
    * Add periods to docsting
    
    * Disallow creating and deleting sharding keys for non-manage access
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index e9c2e3201..5e6c957f9 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -46,14 +46,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         upsert(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -65,14 +65,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         delete(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -81,9 +81,15 @@ impl Points for PointsService {
     async fn get(&self, mut request: Request<GetPoints>) -> Result<Response<GetResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
-        get(self.dispatcher.toc(), request.into_inner(), None, claims).await
+        get(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
     }
 
     async fn update_vectors(
@@ -92,14 +98,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         update_vectors(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -111,14 +117,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         delete_vectors(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -130,14 +136,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         set_payload(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -149,14 +155,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         overwrite_payload(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -168,14 +174,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         delete_payload(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -187,14 +193,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         clear_payload(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -206,14 +212,14 @@ impl Points for PointsService {
     ) -> Result<Response<UpdateBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         update_batch(
-            self.dispatcher.toc().clone(),
+            self.dispatcher.toc(&access).clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
     }
@@ -224,14 +230,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         create_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -243,14 +249,14 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         delete_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
             None,
             None,
-            claims,
+            access,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -261,8 +267,14 @@ impl Points for PointsService {
         mut request: Request<SearchPoints>,
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_access(&mut request);
-        search(self.dispatcher.toc(), request.into_inner(), None, claims).await
+        let access = extract_access(&mut request);
+        search(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
     }
 
     async fn search_batch(
@@ -271,7 +283,7 @@ impl Points for PointsService {
     ) -> Result<Response<SearchBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         let SearchBatchPoints {
             collection_name,
@@ -294,11 +306,11 @@ impl Points for PointsService {
         }
 
         core_search_batch(
-            self.dispatcher.toc(),
+            self.dispatcher.toc(&access),
             collection_name,
             requests,
             read_consistency,
-            claims,
+            access,
             timeout,
         )
         .await
@@ -309,8 +321,14 @@ impl Points for PointsService {
         mut request: Request<SearchPointGroups>,
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_access(&mut request);
-        search_groups(self.dispatcher.toc(), request.into_inner(), None, claims).await
+        let access = extract_access(&mut request);
+        search_groups(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
     }
 
     async fn scroll(
@@ -319,9 +337,15 @@ impl Points for PointsService {
     ) -> Result<Response<ScrollResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
-        scroll(self.dispatcher.toc(), request.into_inner(), None, claims).await
+        scroll(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
     }
 
     async fn recommend(
@@ -329,8 +353,8 @@ impl Points for PointsService {
         mut request: Request<RecommendPoints>,
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_access(&mut request);
-        recommend(self.dispatcher.toc(), request.into_inner(), claims).await
+        let access = extract_access(&mut request);
+        recommend(self.dispatcher.toc(&access), request.into_inner(), access).await
     }
 
     async fn recommend_batch(
@@ -338,7 +362,7 @@ impl Points for PointsService {
         mut request: Request<RecommendBatchPoints>,
     ) -> Result<Response<RecommendBatchResponse>, Status> {
         validate(request.get_ref())?;
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
         let RecommendBatchPoints {
             collection_name,
             recommend_points,
@@ -346,11 +370,11 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
         recommend_batch(
-            self.dispatcher.toc(),
+            self.dispatcher.toc(&access),
             collection_name,
             recommend_points,
             read_consistency,
-            claims,
+            access,
             timeout.map(Duration::from_secs),
         )
         .await
@@ -362,9 +386,9 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendGroupsResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
-        recommend_groups(self.dispatcher.toc(), request.into_inner(), claims).await
+        recommend_groups(self.dispatcher.toc(&access), request.into_inner(), access).await
     }
 
     async fn discover(
@@ -373,9 +397,9 @@ impl Points for PointsService {
     ) -> Result<Response<DiscoverResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
-        discover(self.dispatcher.toc(), request.into_inner(), claims).await
+        discover(self.dispatcher.toc(&access), request.into_inner(), access).await
     }
 
     async fn discover_batch(
@@ -384,7 +408,7 @@ impl Points for PointsService {
     ) -> Result<Response<DiscoverBatchResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
         let DiscoverBatchPoints {
             collection_name,
@@ -394,11 +418,11 @@ impl Points for PointsService {
         } = request.into_inner();
 
         discover_batch(
-            self.dispatcher.toc(),
+            self.dispatcher.toc(&access),
             collection_name,
             discover_points,
             read_consistency,
-            claims,
+            access,
             timeout.map(Duration::from_secs),
         )
         .await
@@ -410,8 +434,14 @@ impl Points for PointsService {
     ) -> Result<Response<CountResponse>, Status> {
         validate(request.get_ref())?;
 
-        let claims = extract_access(&mut request);
+        let access = extract_access(&mut request);
 
-        count(self.dispatcher.toc(), request.into_inner(), None, claims).await
+        count(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
     }
 }

commit 922fdefc6b9d66a9b75d3147bde33fc7233908fd
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Jun 18 21:14:30 2024 +0200

    universal-query: gRPC query API (#4495)
    
    * universal-query: gRPC query API
    
    * misc fixes
    
    * more review
    
    * add custom validation on QueryPoints.limit
    
    * fix jwt_access test for gRPC query

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 5e6c957f9..132d24cd4 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,18 +6,18 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
     DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, GetPoints,
-    GetResponse, PointsOperationResponse, RecommendBatchPoints, RecommendBatchResponse,
-    RecommendGroupsResponse, RecommendPointGroups, RecommendPoints, RecommendResponse,
-    ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse,
-    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
-    UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
+    GetResponse, PointsOperationResponse, QueryPoints, QueryResponse, RecommendBatchPoints,
+    RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups, RecommendPoints,
+    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
+    SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints,
+    UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
-    delete_vectors, discover, discover_batch, recommend_groups, search_groups, update_batch,
+    delete_vectors, discover, discover_batch, query, recommend_groups, search_groups, update_batch,
     update_vectors,
 };
 use super::validate;
@@ -444,4 +444,19 @@ impl Points for PointsService {
         )
         .await
     }
+
+    async fn query(
+        &self,
+        mut request: Request<QueryPoints>,
+    ) -> Result<Response<QueryResponse>, Status> {
+        validate(request.get_ref())?;
+        let access = extract_access(&mut request);
+        query(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
+    }
 }

commit 19d878d277258bb8ce6a0a620caef02378c97fa8
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jun 20 14:10:27 2024 +0200

    universal-query: gRPC batch API (#4513)
    
    * universal-query: gRPC batch API
    
    * regen gRPC docs
    
    * enable jwt access test

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 132d24cd4..051966db6 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,19 +6,20 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
     DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, GetPoints,
-    GetResponse, PointsOperationResponse, QueryPoints, QueryResponse, RecommendBatchPoints,
-    RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups, RecommendPoints,
-    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
-    SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints,
-    UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
+    GetResponse, PointsOperationResponse, QueryBatchPoints, QueryBatchResponse, QueryPoints,
+    QueryResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse,
+    RecommendPointGroups, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
+    SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse, SearchPointGroups, SearchPoints,
+    SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors,
+    UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
-    delete_vectors, discover, discover_batch, query, recommend_groups, search_groups, update_batch,
-    update_vectors,
+    delete_vectors, discover, discover_batch, query, query_batch, recommend_groups, search_groups,
+    update_batch, update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
@@ -459,4 +460,29 @@ impl Points for PointsService {
         )
         .await
     }
+
+    async fn query_batch(
+        &self,
+        mut request: Request<QueryBatchPoints>,
+    ) -> Result<Response<QueryBatchResponse>, Status> {
+        validate(request.get_ref())?;
+        let access = extract_access(&mut request);
+        let request = request.into_inner();
+        let QueryBatchPoints {
+            collection_name,
+            query_points,
+            read_consistency,
+            timeout,
+        } = request;
+        let timeout = timeout.map(Duration::from_secs);
+        query_batch(
+            self.dispatcher.toc(&access),
+            collection_name,
+            query_points,
+            read_consistency,
+            access,
+            timeout,
+        )
+        .await
+    }
 }

commit 445a70f42ca5a5ad24aaf35bf7869398d4306df1
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jul 11 20:13:39 2024 +0200

    universal-query: gRPC group API (#4656)
    
    * universal-query: gRPC group API
    
    * fix jwt test
    
    * resolve default values for CollectionQueryGroupsRequest

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 051966db6..ff28c62d7 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,20 +6,20 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
     DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, GetPoints,
-    GetResponse, PointsOperationResponse, QueryBatchPoints, QueryBatchResponse, QueryPoints,
-    QueryResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse,
-    RecommendPointGroups, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
-    SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse, SearchPointGroups, SearchPoints,
-    SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors,
-    UpsertPoints,
+    GetResponse, PointsOperationResponse, QueryBatchPoints, QueryBatchResponse,
+    QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse, RecommendBatchPoints,
+    RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups, RecommendPoints,
+    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
+    SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints,
+    UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
-    delete_vectors, discover, discover_batch, query, query_batch, recommend_groups, search_groups,
-    update_batch, update_vectors,
+    delete_vectors, discover, discover_batch, query, query_batch, query_groups, recommend_groups,
+    search_groups, update_batch, update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
@@ -485,4 +485,18 @@ impl Points for PointsService {
         )
         .await
     }
+
+    async fn query_groups(
+        &self,
+        mut request: Request<QueryPointGroups>,
+    ) -> Result<Response<QueryGroupsResponse>, Status> {
+        let access = extract_access(&mut request);
+        query_groups(
+            self.dispatcher.toc(&access),
+            request.into_inner(),
+            None,
+            access,
+        )
+        .await
+    }
 }

commit 5f5fd25d6407ed81da1db0fd0e9681f46c573616
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Aug 22 08:27:25 2024 -0400

    Add grpc endpoint for Facet (#4933)
    
    * add grpc endpoint
    
    * gen grpc docs

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index ff28c62d7..5107e33ec 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -5,21 +5,21 @@ use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
-    DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, GetPoints,
-    GetResponse, PointsOperationResponse, QueryBatchPoints, QueryBatchResponse,
-    QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse, RecommendBatchPoints,
-    RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups, RecommendPoints,
-    RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints, SearchBatchResponse,
-    SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints,
-    UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
+    DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, FacetCounts,
+    FacetResponse, GetPoints, GetResponse, PointsOperationResponse, QueryBatchPoints,
+    QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse,
+    RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups,
+    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
+    SearchBatchResponse, SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse,
+    SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
 use super::points_common::{
-    delete_vectors, discover, discover_batch, query, query_batch, query_groups, recommend_groups,
-    search_groups, update_batch, update_vectors,
+    delete_vectors, discover, discover_batch, facet, query, query_batch, query_groups,
+    recommend_groups, search_groups, update_batch, update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
@@ -499,4 +499,12 @@ impl Points for PointsService {
         )
         .await
     }
+    async fn facet(
+        &self,
+        mut request: Request<FacetCounts>,
+    ) -> Result<Response<FacetResponse>, Status> {
+        validate(request.get_ref())?;
+        let access = extract_access(&mut request);
+        facet(self.dispatcher.toc(&access), request.into_inner(), access).await
+    }
 }

commit ba57d6320012f47dd0c7bfd233688096bd3ba7d6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Sep 4 20:25:00 2024 +0200

    gRPC API for Distance Matrix (#5011)
    
    * gRPC API for Distance Matrix
    
    * generate API docs
    
    * apply correct limit to sample
    
    * add JWT tests
    
    * pluralitiy
    
    * fix COO naming
    
    * drops COO as it trips codespell and is redundant
    
    * clarify docs

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 5107e33ec..2e934247c 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -1,5 +1,5 @@
 use std::sync::Arc;
-use std::time::Duration;
+use std::time::{Duration, Instant};
 
 use api::grpc::qdrant::points_server::Points;
 use api::grpc::qdrant::{
@@ -10,8 +10,10 @@ use api::grpc::qdrant::{
     QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse,
     RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups,
     RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
-    SearchBatchResponse, SearchGroupsResponse, SearchPointGroups, SearchPoints, SearchResponse,
-    SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
+    SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets, SearchMatrixOffsetsResponse,
+    SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints, SearchPointGroups,
+    SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse,
+    UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use storage::dispatcher::Dispatcher;
@@ -19,7 +21,7 @@ use tonic::{Request, Response, Status};
 
 use super::points_common::{
     delete_vectors, discover, discover_batch, facet, query, query_batch, query_groups,
-    recommend_groups, search_groups, update_batch, update_vectors,
+    recommend_groups, search_groups, search_points_matrix, update_batch, update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
@@ -507,4 +509,38 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         facet(self.dispatcher.toc(&access), request.into_inner(), access).await
     }
+
+    async fn search_matrix_pairs(
+        &self,
+        mut request: Request<SearchMatrixPoints>,
+    ) -> Result<Response<SearchMatrixPairsResponse>, Status> {
+        validate(request.get_ref())?;
+        let access = extract_access(&mut request);
+        let timing = Instant::now();
+        let search_matrix_response =
+            search_points_matrix(self.dispatcher.toc(&access), request.into_inner(), access)
+                .await?;
+        let pairs_response = SearchMatrixPairsResponse {
+            result: Some(SearchMatrixPairs::from(search_matrix_response)),
+            time: timing.elapsed().as_secs_f64(),
+        };
+        Ok(Response::new(pairs_response))
+    }
+
+    async fn search_matrix_offsets(
+        &self,
+        mut request: Request<SearchMatrixPoints>,
+    ) -> Result<Response<SearchMatrixOffsetsResponse>, Status> {
+        validate(request.get_ref())?;
+        let access = extract_access(&mut request);
+        let timing = Instant::now();
+        let search_matrix_response =
+            search_points_matrix(self.dispatcher.toc(&access), request.into_inner(), access)
+                .await?;
+        let offsets_response = SearchMatrixOffsetsResponse {
+            result: Some(SearchMatrixOffsets::from(search_matrix_response)),
+            time: timing.elapsed().as_secs_f64(),
+        };
+        Ok(Response::new(offsets_response))
+    }
 }

commit b7c5f7359079fbfd30b315078c0b122fe28fca45
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Sep 25 13:22:37 2024 +0200

    [Strict mode] GRPC verification (#5003)
    
    * first grpc implementations
    
    * make usage of 'scroll' more clear
    
    * introduce 'CheckedTocProvider' trait
    
    * implement more grpc types
    
    * more grpc implementations
    
    * rename StrictModeCheckedProvider to StrictModeCheckedTocProvider
    
    * don't use deprecated feature for UncheckedTocProvider

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 2e934247c..82baf1c68 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -21,15 +21,16 @@ use tonic::{Request, Response, Status};
 
 use super::points_common::{
     delete_vectors, discover, discover_batch, facet, query, query_batch, query_groups,
-    recommend_groups, search_groups, search_points_matrix, update_batch, update_vectors,
+    recommend_groups, scroll, search_groups, search_points_matrix, update_batch, update_vectors,
 };
 use super::validate;
 use crate::tonic::api::points_common::{
     clear_payload, convert_shard_selector_for_read, core_search_batch, count, create_field_index,
     delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
-    scroll, search, set_payload, upsert,
+    search, set_payload, upsert,
 };
 use crate::tonic::auth::extract_access;
+use crate::tonic::verification::StrictModeCheckedTocProvider;
 
 pub struct PointsService {
     dispatcher: Arc<Dispatcher>,
@@ -71,7 +72,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         delete(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -123,7 +124,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         delete_vectors(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -142,7 +143,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         set_payload(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -161,7 +162,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         overwrite_payload(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -180,7 +181,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         delete_payload(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -199,7 +200,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         clear_payload(
-            self.dispatcher.toc(&access).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -217,14 +218,7 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
-        update_batch(
-            self.dispatcher.toc(&access).clone(),
-            request.into_inner(),
-            None,
-            None,
-            access,
-        )
-        .await
+        update_batch(&self.dispatcher, request.into_inner(), None, None, access).await
     }
 
     async fn create_field_index(
@@ -272,7 +266,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         search(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -309,7 +303,7 @@ impl Points for PointsService {
         }
 
         core_search_batch(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             collection_name,
             requests,
             read_consistency,
@@ -326,7 +320,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         search_groups(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -343,7 +337,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         scroll(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -357,7 +351,12 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        recommend(self.dispatcher.toc(&access), request.into_inner(), access).await
+        recommend(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await
     }
 
     async fn recommend_batch(
@@ -372,8 +371,9 @@ impl Points for PointsService {
             read_consistency,
             timeout,
         } = request.into_inner();
+
         recommend_batch(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             collection_name,
             recommend_points,
             read_consistency,
@@ -391,7 +391,12 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
-        recommend_groups(self.dispatcher.toc(&access), request.into_inner(), access).await
+        recommend_groups(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await
     }
 
     async fn discover(
@@ -402,7 +407,12 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
-        discover(self.dispatcher.toc(&access), request.into_inner(), access).await
+        discover(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await
     }
 
     async fn discover_batch(
@@ -421,7 +431,7 @@ impl Points for PointsService {
         } = request.into_inner();
 
         discover_batch(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             collection_name,
             discover_points,
             read_consistency,
@@ -440,10 +450,10 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         count(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
-            access,
+            &access,
         )
         .await
     }
@@ -455,7 +465,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         query(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -478,7 +488,7 @@ impl Points for PointsService {
         } = request;
         let timeout = timeout.map(Duration::from_secs);
         query_batch(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             collection_name,
             query_points,
             read_consistency,
@@ -494,7 +504,7 @@ impl Points for PointsService {
     ) -> Result<Response<QueryGroupsResponse>, Status> {
         let access = extract_access(&mut request);
         query_groups(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -507,7 +517,12 @@ impl Points for PointsService {
     ) -> Result<Response<FacetResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        facet(self.dispatcher.toc(&access), request.into_inner(), access).await
+        facet(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await
     }
 
     async fn search_matrix_pairs(
@@ -517,9 +532,12 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
-        let search_matrix_response =
-            search_points_matrix(self.dispatcher.toc(&access), request.into_inner(), access)
-                .await?;
+        let search_matrix_response = search_points_matrix(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await?;
         let pairs_response = SearchMatrixPairsResponse {
             result: Some(SearchMatrixPairs::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
@@ -534,9 +552,12 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
-        let search_matrix_response =
-            search_points_matrix(self.dispatcher.toc(&access), request.into_inner(), access)
-                .await?;
+        let search_matrix_response = search_points_matrix(
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
+            request.into_inner(),
+            access,
+        )
+        .await?;
         let offsets_response = SearchMatrixOffsetsResponse {
             result: Some(SearchMatrixOffsets::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),

commit 9e1ccf62377bf3a8ff5885b807acb5e74f09ec31
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Wed Sep 25 15:15:58 2024 +0200

    [Strict mode] migrate toc_new -> toc (#5120)
    
    * Replace all remaining calls of toc() with toc_new
    
    * mirgate toc_new -> toc

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 82baf1c68..3d66f6327 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -16,6 +16,7 @@ use api::grpc::qdrant::{
     UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
+use collection::operations::verification::new_unchecked_verification_pass;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
@@ -50,10 +51,13 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
+        // Nothing to verify here.
+        let pass = new_unchecked_verification_pass();
+
         let access = extract_access(&mut request);
 
         upsert(
-            self.dispatcher.toc(&access).clone(),
+            self.dispatcher.toc(&access, &pass).clone(),
             request.into_inner(),
             None,
             None,
@@ -88,7 +92,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
 
         get(
-            self.dispatcher.toc(&access),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
@@ -102,10 +106,13 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
+        // Nothing to verify here.
+        let pass = new_unchecked_verification_pass();
+
         let access = extract_access(&mut request);
 
         update_vectors(
-            self.dispatcher.toc(&access).clone(),
+            self.dispatcher.toc(&access, &pass).clone(),
             request.into_inner(),
             None,
             None,

commit 13cabb32e48d3e02cb52ee423a17c23239480a58
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Nov 5 16:15:39 2024 +0100

    Add hardware usage to grpc API (#5333)
    
    * Add hardware usage to grpc API
    
    * generate grpc docs

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 3d66f6327..02dbafd42 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,17 +6,18 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
     DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, FacetCounts,
-    FacetResponse, GetPoints, GetResponse, PointsOperationResponse, QueryBatchPoints,
-    QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse,
-    RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups,
-    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
-    SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets, SearchMatrixOffsetsResponse,
-    SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints, SearchPointGroups,
-    SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse,
-    UpdatePointVectors, UpsertPoints,
+    FacetResponse, GetPoints, GetResponse, HardwareUsage, PointsOperationResponse,
+    QueryBatchPoints, QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints,
+    QueryResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse,
+    RecommendPointGroups, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
+    SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets,
+    SearchMatrixOffsetsResponse, SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints,
+    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
+    UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use collection::operations::verification::new_unchecked_verification_pass;
+use common::counter::hardware_accumulator::HwMeasurementAcc;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
@@ -25,6 +26,7 @@ use super::points_common::{
     recommend_groups, scroll, search_groups, search_points_matrix, update_batch, update_vectors,
 };
 use super::validate;
+use crate::settings::ServiceConfig;
 use crate::tonic::api::points_common::{
     clear_payload, convert_shard_selector_for_read, core_search_batch, count, create_field_index,
     delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
@@ -35,11 +37,15 @@ use crate::tonic::verification::StrictModeCheckedTocProvider;
 
 pub struct PointsService {
     dispatcher: Arc<Dispatcher>,
+    service_config: ServiceConfig,
 }
 
 impl PointsService {
-    pub fn new(dispatcher: Arc<Dispatcher>) -> Self {
-        Self { dispatcher }
+    pub fn new(dispatcher: Arc<Dispatcher>, service_config: ServiceConfig) -> Self {
+        Self {
+            dispatcher,
+            service_config,
+        }
     }
 }
 
@@ -277,6 +283,7 @@ impl Points for PointsService {
             request.into_inner(),
             None,
             access,
+            &self.service_config,
         )
         .await
     }
@@ -316,6 +323,7 @@ impl Points for PointsService {
             read_consistency,
             access,
             timeout,
+            &self.service_config,
         )
         .await
     }
@@ -331,6 +339,7 @@ impl Points for PointsService {
             request.into_inner(),
             None,
             access,
+            &self.service_config,
         )
         .await
     }
@@ -362,6 +371,7 @@ impl Points for PointsService {
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            &self.service_config,
         )
         .await
     }
@@ -386,6 +396,7 @@ impl Points for PointsService {
             read_consistency,
             access,
             timeout.map(Duration::from_secs),
+            &self.service_config,
         )
         .await
     }
@@ -402,6 +413,7 @@ impl Points for PointsService {
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            &self.service_config,
         )
         .await
     }
@@ -418,6 +430,7 @@ impl Points for PointsService {
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            &self.service_config,
         )
         .await
     }
@@ -444,6 +457,7 @@ impl Points for PointsService {
             read_consistency,
             access,
             timeout.map(Duration::from_secs),
+            &self.service_config,
         )
         .await
     }
@@ -461,6 +475,7 @@ impl Points for PointsService {
             request.into_inner(),
             None,
             &access,
+            &self.service_config,
         )
         .await
     }
@@ -476,6 +491,7 @@ impl Points for PointsService {
             request.into_inner(),
             None,
             access,
+            &self.service_config,
         )
         .await
     }
@@ -501,6 +517,7 @@ impl Points for PointsService {
             read_consistency,
             access,
             timeout,
+            &self.service_config,
         )
         .await
     }
@@ -515,6 +532,7 @@ impl Points for PointsService {
             request.into_inner(),
             None,
             access,
+            &self.service_config,
         )
         .await
     }
@@ -539,15 +557,21 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
+        let hw_measurement_acc = HwMeasurementAcc::new();
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            hw_measurement_acc.clone(),
         )
         .await?;
         let pairs_response = SearchMatrixPairsResponse {
             result: Some(SearchMatrixPairs::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
+            usage: self
+                .service_config
+                .hardware_reporting()
+                .then(|| HardwareUsage::from(hw_measurement_acc)),
         };
         Ok(Response::new(pairs_response))
     }
@@ -559,15 +583,21 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
+        let hw_measurement_acc = HwMeasurementAcc::new();
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            hw_measurement_acc.clone(),
         )
         .await?;
         let offsets_response = SearchMatrixOffsetsResponse {
             result: Some(SearchMatrixOffsets::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
+            usage: self
+                .service_config
+                .hardware_reporting()
+                .then(|| HardwareUsage::from(hw_measurement_acc)),
         };
         Ok(Response::new(offsets_response))
     }

commit b4e30ad6bfff857e212b7d63079783569e572267
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Sun Nov 17 12:46:01 2024 +0100

    Per collection hardware measurements  (#5453)
    
    * Add HwMeasurementCollector
    
    * Add hardware reporting to TOC + RequestHwCounter
    
    * Pass HwMeasurementAcc by reference + Update accumulation
    
    * Update tests and benchmarks
    
    * update REST API
    
    * Update gRPC API
    
    * codespell
    
    * Adjust internal API
    
    * improve docs
    
    * introduce drain to the HwMeasurementAcc
    
    * fmt
    
    * use drain to report to the collection counter
    
    * implement hw metrics drain for internal and external queries
    
    * fix drinage
    
    * refactor rest models: move away from grpc crate
    
    * fmt
    
    * implement usage reporting to collection acc for rest api
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 02dbafd42..f4e4f1b0c 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -6,18 +6,19 @@ use api::grpc::qdrant::{
     ClearPayloadPoints, CountPoints, CountResponse, CreateFieldIndexCollection,
     DeleteFieldIndexCollection, DeletePayloadPoints, DeletePointVectors, DeletePoints,
     DiscoverBatchPoints, DiscoverBatchResponse, DiscoverPoints, DiscoverResponse, FacetCounts,
-    FacetResponse, GetPoints, GetResponse, HardwareUsage, PointsOperationResponse,
-    QueryBatchPoints, QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints,
-    QueryResponse, RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse,
-    RecommendPointGroups, RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse,
-    SearchBatchPoints, SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets,
-    SearchMatrixOffsetsResponse, SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints,
-    SearchPointGroups, SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints,
-    UpdateBatchResponse, UpdatePointVectors, UpsertPoints,
+    FacetResponse, GetPoints, GetResponse, PointsOperationResponse, QueryBatchPoints,
+    QueryBatchResponse, QueryGroupsResponse, QueryPointGroups, QueryPoints, QueryResponse,
+    RecommendBatchPoints, RecommendBatchResponse, RecommendGroupsResponse, RecommendPointGroups,
+    RecommendPoints, RecommendResponse, ScrollPoints, ScrollResponse, SearchBatchPoints,
+    SearchBatchResponse, SearchGroupsResponse, SearchMatrixOffsets, SearchMatrixOffsetsResponse,
+    SearchMatrixPairs, SearchMatrixPairsResponse, SearchMatrixPoints, SearchPointGroups,
+    SearchPoints, SearchResponse, SetPayloadPoints, UpdateBatchPoints, UpdateBatchResponse,
+    UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
 use collection::operations::verification::new_unchecked_verification_pass;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
+use storage::content_manager::toc::request_hw_counter::RequestHwCounter;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
@@ -47,6 +48,14 @@ impl PointsService {
             service_config,
         }
     }
+
+    fn get_request_collection_hw_usage_counter(&self, collection_name: String) -> RequestHwCounter {
+        let counter = HwMeasurementAcc::new_with_drain(
+            &self.dispatcher.get_collection_hw_metrics(collection_name),
+        );
+
+        RequestHwCounter::new(counter, self.service_config.hardware_reporting(), false)
+    }
 }
 
 #[tonic::async_trait]
@@ -278,14 +287,19 @@ impl Points for PointsService {
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        search(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+
+        let res = search(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn search_batch(
@@ -316,16 +330,20 @@ impl Points for PointsService {
             requests.push((core_search_request, shard_selector));
         }
 
-        core_search_batch(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+
+        let res = core_search_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            collection_name,
+            &collection_name,
             requests,
             read_consistency,
             access,
             timeout,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn search_groups(
@@ -334,14 +352,18 @@ impl Points for PointsService {
     ) -> Result<Response<SearchGroupsResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        search_groups(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let res = search_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn scroll(
@@ -351,7 +373,6 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
-
         scroll(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -367,13 +388,17 @@ impl Points for PointsService {
     ) -> Result<Response<RecommendResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        recommend(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let res = recommend(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn recommend_batch(
@@ -389,16 +414,20 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
 
-        recommend_batch(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+
+        let res = recommend_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            collection_name,
+            &collection_name,
             recommend_points,
             read_consistency,
             access,
             timeout.map(Duration::from_secs),
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn recommend_groups(
@@ -406,16 +435,19 @@ impl Points for PointsService {
         mut request: Request<RecommendPointGroups>,
     ) -> Result<Response<RecommendGroupsResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
 
-        recommend_groups(
+        let res = recommend_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn discover(
@@ -423,16 +455,19 @@ impl Points for PointsService {
         mut request: Request<DiscoverPoints>,
     ) -> Result<Response<DiscoverResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
+        let collection_name = request.get_ref().collection_name.clone();
 
-        discover(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let res = discover(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn discover_batch(
@@ -440,9 +475,7 @@ impl Points for PointsService {
         mut request: Request<DiscoverBatchPoints>,
     ) -> Result<Response<DiscoverBatchResponse>, Status> {
         validate(request.get_ref())?;
-
         let access = extract_access(&mut request);
-
         let DiscoverBatchPoints {
             collection_name,
             discover_points,
@@ -450,16 +483,19 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
 
-        discover_batch(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let res = discover_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            collection_name,
+            &collection_name,
             discover_points,
             read_consistency,
             access,
             timeout.map(Duration::from_secs),
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn count(
@@ -469,15 +505,18 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
-
-        count(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let res = count(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             &access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn query(
@@ -486,14 +525,19 @@ impl Points for PointsService {
     ) -> Result<Response<QueryResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        query(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+
+        let res = query(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn query_batch(
@@ -510,16 +554,19 @@ impl Points for PointsService {
             timeout,
         } = request;
         let timeout = timeout.map(Duration::from_secs);
-        query_batch(
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let res = query_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            collection_name,
+            &collection_name,
             query_points,
             read_consistency,
             access,
             timeout,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
 
     async fn query_groups(
@@ -527,14 +574,19 @@ impl Points for PointsService {
         mut request: Request<QueryPointGroups>,
     ) -> Result<Response<QueryGroupsResponse>, Status> {
         let access = extract_access(&mut request);
-        query_groups(
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+
+        let res = query_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             access,
-            &self.service_config,
+            hw_metrics,
         )
-        .await
+        .await?;
+
+        Ok(res)
     }
     async fn facet(
         &self,
@@ -557,22 +609,22 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
-        let hw_measurement_acc = HwMeasurementAcc::new();
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            hw_measurement_acc.clone(),
+            hw_metrics.get_counter(),
         )
         .await?;
+
         let pairs_response = SearchMatrixPairsResponse {
             result: Some(SearchMatrixPairs::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
-            usage: self
-                .service_config
-                .hardware_reporting()
-                .then(|| HardwareUsage::from(hw_measurement_acc)),
+            usage: hw_metrics.to_grpc_api(),
         };
+
         Ok(Response::new(pairs_response))
     }
 
@@ -583,22 +635,22 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let timing = Instant::now();
-        let hw_measurement_acc = HwMeasurementAcc::new();
+        let collection_name = request.get_ref().collection_name.clone();
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
-            hw_measurement_acc.clone(),
+            hw_metrics.get_counter(),
         )
         .await?;
+
         let offsets_response = SearchMatrixOffsetsResponse {
             result: Some(SearchMatrixOffsets::from(search_matrix_response)),
             time: timing.elapsed().as_secs_f64(),
-            usage: self
-                .service_config
-                .hardware_reporting()
-                .then(|| HardwareUsage::from(hw_measurement_acc)),
+            usage: hw_metrics.to_grpc_api(),
         };
+
         Ok(Response::new(offsets_response))
     }
 }

commit 0702854477ae7b23f3f50d94ea9a4cac167bd612
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Dec 5 17:28:09 2024 +0100

    Strict mode max collection vector size (#5501)
    
    * Strict mode config: Max collection size
    
    * api specs
    
    * Add tests + set/update payload check
    
    * Improve function names and add comments
    
    * rename config to separate vectors and payload
    
    * fix tests
    
    * Adjust configs docs
    
    * add benchmark
    
    * improve performance by caching shard info
    
    * add bench for size_info() and fix tests
    
    * Also limit the batch-size for vector updates (#5508)
    
    * Also limit the batch-size for vector updates
    
    * clippy
    
    * add lost commit
    
    * Load cache on collection initialization
    
    * add unit type to parameter name
    
    * fix renaming in test
    
    * clearer error message
    
    * fix test
    
    * review remarks
    
    * remove unused function for now
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index f4e4f1b0c..9b0cf93e3 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -16,7 +16,6 @@ use api::grpc::qdrant::{
     UpdatePointVectors, UpsertPoints,
 };
 use collection::operations::types::CoreSearchRequest;
-use collection::operations::verification::new_unchecked_verification_pass;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use storage::content_manager::toc::request_hw_counter::RequestHwCounter;
 use storage::dispatcher::Dispatcher;
@@ -66,13 +65,10 @@ impl Points for PointsService {
     ) -> Result<Response<PointsOperationResponse>, Status> {
         validate(request.get_ref())?;
 
-        // Nothing to verify here.
-        let pass = new_unchecked_verification_pass();
-
         let access = extract_access(&mut request);
 
         upsert(
-            self.dispatcher.toc(&access, &pass).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,
@@ -122,12 +118,11 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         // Nothing to verify here.
-        let pass = new_unchecked_verification_pass();
 
         let access = extract_access(&mut request);
 
         update_vectors(
-            self.dispatcher.toc(&access, &pass).clone(),
+            StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             None,
             None,

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 9b0cf93e3..9e138db3d 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -49,11 +49,11 @@ impl PointsService {
     }
 
     fn get_request_collection_hw_usage_counter(&self, collection_name: String) -> RequestHwCounter {
-        let counter = HwMeasurementAcc::new_with_drain(
-            &self.dispatcher.get_collection_hw_metrics(collection_name),
+        let counter = HwMeasurementAcc::new_with_metrics_drain(
+            self.dispatcher.get_collection_hw_metrics(collection_name),
         );
 
-        RequestHwCounter::new(counter, self.service_config.hardware_reporting(), false)
+        RequestHwCounter::new(counter, self.service_config.hardware_reporting())
     }
 }
 

commit 1d7ce8f9ce9ecbbb788123c85b547d7e959b429b
Author: n0x29a <15330763+n0x29a@users.noreply.github.com>
Date:   Mon Dec 16 14:08:06 2024 +0000

    Pass inference API token from request to inference service (#5589)
    
     Pass inference API token from request to inference service
    
    ---------
    
    Co-authored-by: n0x29a <n0x29a@example.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 9e138db3d..f88815a41 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -26,6 +26,7 @@ use super::points_common::{
     recommend_groups, scroll, search_groups, search_points_matrix, update_batch, update_vectors,
 };
 use super::validate;
+use crate::common::inference::extract_token;
 use crate::settings::ServiceConfig;
 use crate::tonic::api::points_common::{
     clear_payload, convert_shard_selector_for_read, core_search_batch, count, create_field_index,
@@ -66,6 +67,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
 
         upsert(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -73,6 +75,7 @@ impl Points for PointsService {
             None,
             None,
             access,
+            inference_token,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -85,6 +88,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
 
         delete(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -92,6 +96,7 @@ impl Points for PointsService {
             None,
             None,
             access,
+            inference_token,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -120,6 +125,7 @@ impl Points for PointsService {
         // Nothing to verify here.
 
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
 
         update_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -127,6 +133,7 @@ impl Points for PointsService {
             None,
             None,
             access,
+            inference_token,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -234,8 +241,17 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
 
-        update_batch(&self.dispatcher, request.into_inner(), None, None, access).await
+        update_batch(
+            &self.dispatcher,
+            request.into_inner(),
+            None,
+            None,
+            access,
+            inference_token,
+        )
+        .await
     }
 
     async fn create_field_index(
@@ -520,6 +536,7 @@ impl Points for PointsService {
     ) -> Result<Response<QueryResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
         let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
 
@@ -529,6 +546,7 @@ impl Points for PointsService {
             None,
             access,
             hw_metrics,
+            inference_token,
         )
         .await?;
 
@@ -541,6 +559,7 @@ impl Points for PointsService {
     ) -> Result<Response<QueryBatchResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
         let request = request.into_inner();
         let QueryBatchPoints {
             collection_name,
@@ -558,6 +577,7 @@ impl Points for PointsService {
             access,
             timeout,
             hw_metrics,
+            inference_token,
         )
         .await?;
 
@@ -569,6 +589,7 @@ impl Points for PointsService {
         mut request: Request<QueryPointGroups>,
     ) -> Result<Response<QueryGroupsResponse>, Status> {
         let access = extract_access(&mut request);
+        let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
         let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
 
@@ -578,6 +599,7 @@ impl Points for PointsService {
             None,
             access,
             hw_metrics,
+            inference_token,
         )
         .await?;
 

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index f88815a41..7d1646541 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -107,11 +107,17 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let inner_request = request.into_inner();
+
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(inner_request.collection_name.clone());
+
         get(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            request.into_inner(),
+            inner_request,
             None,
             access,
+            hw_metrics,
         )
         .await
     }
@@ -384,11 +390,18 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
+
+        let inner_request = request.into_inner();
+
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(inner_request.collection_name.clone());
+
         scroll(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
-            request.into_inner(),
+            inner_request,
             None,
             access,
+            hw_metrics,
         )
         .await
     }

commit 97743b1b625d42f73955ecb32d54ca34ea3a5cb7
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jan 24 16:33:44 2025 +0100

    Propagate hardware counter for more functions (#5844)
    
    * Propagate hardware counter for more functions
    
    * Minor improvements
    
    * use vector_query_contexts hardware_counter

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 7d1646541..a652e3760 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -624,10 +624,13 @@ impl Points for PointsService {
     ) -> Result<Response<FacetResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(request.get_ref().collection_name.clone());
         facet(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             access,
+            hw_metrics,
         )
         .await
     }

commit 0d169116075716ee13e01b7af51590ca1b190a6d
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Mon Jan 27 18:30:14 2025 +0100

    Split `tonic::api::points_common` module (#5865)

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index a652e3760..675e25fd8 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -21,18 +21,11 @@ use storage::content_manager::toc::request_hw_counter::RequestHwCounter;
 use storage::dispatcher::Dispatcher;
 use tonic::{Request, Response, Status};
 
-use super::points_common::{
-    delete_vectors, discover, discover_batch, facet, query, query_batch, query_groups,
-    recommend_groups, scroll, search_groups, search_points_matrix, update_batch, update_vectors,
-};
+use super::query_common::*;
+use super::update_common::*;
 use super::validate;
 use crate::common::inference::extract_token;
 use crate::settings::ServiceConfig;
-use crate::tonic::api::points_common::{
-    clear_payload, convert_shard_selector_for_read, core_search_batch, count, create_field_index,
-    delete, delete_field_index, delete_payload, get, overwrite_payload, recommend, recommend_batch,
-    search, set_payload, upsert,
-};
 use crate::tonic::auth::extract_access;
 use crate::tonic::verification::StrictModeCheckedTocProvider;
 

commit 363c5412a0803b525a9c907347aeb1065e4fb3e9
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Tue Feb 11 18:23:11 2025 +0100

    Add `InternalUpdateParams` structure (#5968)
    
    * Add `InternalUpdateParams` structure...
    
    ...to easier propagate `shard_id` and `clock_tag` internal API parameters
    
    * fixup! Add `InternalUpdateParams` structure...
    
    Use `InternalUpdateParams::default` instead of `Default::default`
    
    * Remove now obsolete delinters, expect them where still applicable
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 675e25fd8..948abc8a8 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -25,6 +25,7 @@ use super::query_common::*;
 use super::update_common::*;
 use super::validate;
 use crate::common::inference::extract_token;
+use crate::common::update::InternalUpdateParams;
 use crate::settings::ServiceConfig;
 use crate::tonic::auth::extract_access;
 use crate::tonic::verification::StrictModeCheckedTocProvider;
@@ -65,8 +66,7 @@ impl Points for PointsService {
         upsert(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
             inference_token,
         )
@@ -86,8 +86,7 @@ impl Points for PointsService {
         delete(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
             inference_token,
         )
@@ -129,8 +128,7 @@ impl Points for PointsService {
         update_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
             inference_token,
         )
@@ -149,8 +147,7 @@ impl Points for PointsService {
         delete_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -168,8 +165,7 @@ impl Points for PointsService {
         set_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -187,8 +183,7 @@ impl Points for PointsService {
         overwrite_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -206,8 +201,7 @@ impl Points for PointsService {
         delete_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -225,8 +219,7 @@ impl Points for PointsService {
         clear_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -245,8 +238,7 @@ impl Points for PointsService {
         update_batch(
             &self.dispatcher,
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
             inference_token,
         )
@@ -264,8 +256,7 @@ impl Points for PointsService {
         create_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await
@@ -283,8 +274,7 @@ impl Points for PointsService {
         delete_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
-            None,
-            None,
+            InternalUpdateParams::default(),
             access,
         )
         .await

commit 78f0428f3e23b41cb5702b7aa6caab5564f4af26
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Mar 6 15:03:23 2025 +0100

    Measure hardware IO for update operations (#5922)
    
    * Measure update operations hardware IO
    
    * Add support for distributed setups
    
    * also measure update_local
    
    * Add consensus tests for HW metrics of update operations
    
    * add test for upserting without waiting
    
    * Disable HW usage reporting when not waiting for update API
    
    * Review remarks
    
    * Fix resharding collecting hw measurements
    
    * Fix metric type
    
    * New struct HardwareData for better accumulation
    
    * Ensure we always apply CPU multiplier
    
    * Apply suggestions from code review
    
    * Update src/actix/api/update_api.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    * Fix assert_with_upper_bound_error threshold calculation.
    
    * Clarifying why we don't measure shard cleanup
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index 948abc8a8..ec1712492 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -43,12 +43,17 @@ impl PointsService {
         }
     }
 
-    fn get_request_collection_hw_usage_counter(&self, collection_name: String) -> RequestHwCounter {
+    fn get_request_collection_hw_usage_counter(
+        &self,
+        collection_name: String,
+        wait: Option<bool>,
+    ) -> RequestHwCounter {
         let counter = HwMeasurementAcc::new_with_metrics_drain(
             self.dispatcher.get_collection_hw_metrics(collection_name),
         );
 
-        RequestHwCounter::new(counter, self.service_config.hardware_reporting())
+        let waiting = wait != Some(false);
+        RequestHwCounter::new(counter, self.service_config.hardware_reporting() && waiting)
     }
 }
 
@@ -63,12 +68,17 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         upsert(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
             inference_token,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -83,12 +93,17 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         delete(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
             inference_token,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -101,8 +116,8 @@ impl Points for PointsService {
 
         let inner_request = request.into_inner();
 
-        let hw_metrics =
-            self.get_request_collection_hw_usage_counter(inner_request.collection_name.clone());
+        let hw_metrics = self
+            .get_request_collection_hw_usage_counter(inner_request.collection_name.clone(), None);
 
         get(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -125,12 +140,17 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         update_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
             inference_token,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -144,11 +164,17 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            request.get_ref().collection_name.clone(),
+            None,
+        );
+
         delete_vectors(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -162,11 +188,16 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         set_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -180,11 +211,16 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         overwrite_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -198,11 +234,16 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         delete_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -216,11 +257,16 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         clear_payload(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -235,12 +281,17 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         update_batch(
             &self.dispatcher,
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
             inference_token,
+            hw_metrics,
         )
         .await
     }
@@ -253,11 +304,16 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
 
+        let collection_name = request.get_ref().collection_name.clone();
+        let wait = Some(request.get_ref().wait.unwrap_or(false));
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);
+
         create_field_index(
             self.dispatcher.clone(),
             request.into_inner(),
             InternalUpdateParams::default(),
             access,
+            hw_metrics,
         )
         .await
         .map(|resp| resp.map(Into::into))
@@ -287,8 +343,9 @@ impl Points for PointsService {
     ) -> Result<Response<SearchResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
+
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
 
         let res = search(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -330,7 +387,8 @@ impl Points for PointsService {
             requests.push((core_search_request, shard_selector));
         }
 
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
 
         let res = core_search_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -353,7 +411,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let res = search_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -376,8 +434,8 @@ impl Points for PointsService {
 
         let inner_request = request.into_inner();
 
-        let hw_metrics =
-            self.get_request_collection_hw_usage_counter(inner_request.collection_name.clone());
+        let hw_metrics = self
+            .get_request_collection_hw_usage_counter(inner_request.collection_name.clone(), None);
 
         scroll(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -396,7 +454,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let res = recommend(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -421,7 +479,8 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
 
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
 
         let res = recommend_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -444,7 +503,7 @@ impl Points for PointsService {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
 
         let res = recommend_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -465,7 +524,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
 
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let res = discover(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -490,7 +549,8 @@ impl Points for PointsService {
             timeout,
         } = request.into_inner();
 
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
         let res = discover_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             &collection_name,
@@ -513,7 +573,7 @@ impl Points for PointsService {
 
         let access = extract_access(&mut request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let res = count(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -534,7 +594,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
 
         let res = query(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -564,7 +624,8 @@ impl Points for PointsService {
             timeout,
         } = request;
         let timeout = timeout.map(Duration::from_secs);
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name.clone());
+        let hw_metrics =
+            self.get_request_collection_hw_usage_counter(collection_name.clone(), None);
         let res = query_batch(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             &collection_name,
@@ -587,7 +648,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let inference_token = extract_token(&request);
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
 
         let res = query_groups(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
@@ -607,8 +668,10 @@ impl Points for PointsService {
     ) -> Result<Response<FacetResponse>, Status> {
         validate(request.get_ref())?;
         let access = extract_access(&mut request);
-        let hw_metrics =
-            self.get_request_collection_hw_usage_counter(request.get_ref().collection_name.clone());
+        let hw_metrics = self.get_request_collection_hw_usage_counter(
+            request.get_ref().collection_name.clone(),
+            None,
+        );
         facet(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -626,7 +689,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let timing = Instant::now();
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),
@@ -652,7 +715,7 @@ impl Points for PointsService {
         let access = extract_access(&mut request);
         let timing = Instant::now();
         let collection_name = request.get_ref().collection_name.clone();
-        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name);
+        let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, None);
         let search_matrix_response = search_points_matrix(
             StrictModeCheckedTocProvider::new(&self.dispatcher),
             request.into_inner(),

commit 5cd7239b61d1a6944984132283f762850275670f
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 24 19:39:17 2025 +0100

    Measure Payload Index IO Writes (#6137)
    
    * Prepare measurement of index creation + Remove vector deletion
    measurement
    
    * add hw_counter to add_point functions
    
    * Adjust add_point(..) function signatures
    
    * Add new measurement type: payload index IO write
    
    * Measure payload index IO writes
    
    * Some Hw measurement performance improvements
    
    * Review remarks
    
    * Fix measurements in distributed setups
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/src/tonic/api/points_api.rs b/src/tonic/api/points_api.rs
index ec1712492..3fe8d8463 100644
--- a/src/tonic/api/points_api.rs
+++ b/src/tonic/api/points_api.rs
@@ -303,7 +303,6 @@ impl Points for PointsService {
         validate(request.get_ref())?;
 
         let access = extract_access(&mut request);
-
         let collection_name = request.get_ref().collection_name.clone();
         let wait = Some(request.get_ref().wait.unwrap_or(false));
         let hw_metrics = self.get_request_collection_hw_usage_counter(collection_name, wait);

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    