<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/apprt/glfw.zig - o4-mini-medium</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/apprt/glfw.zig</h1>
        <p><a href="../../../cases/openai_o4-mini/ghostty_src_apprt_glfw.zig.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/apprt/glfw.zig

commit 11a3577ef1e993af19cfd71e4b79c41940ac77fb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Dec 29 15:11:03 2022 -0800

    rename window package to apprt

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
new file mode 100644
index 00000000..0862a439
--- /dev/null
+++ b/src/apprt/glfw.zig
@@ -0,0 +1,149 @@
+//! Application runtime implementation that uses GLFW (https://www.glfw.org/).
+//!
+//! This works on macOS and Linux with OpenGL and Metal.
+//! (The above sentence may be out of date).
+
+const std = @import("std");
+const builtin = @import("builtin");
+const assert = std.debug.assert;
+const Allocator = std.mem.Allocator;
+const glfw = @import("glfw");
+const objc = @import("objc");
+const App = @import("../App.zig");
+const internal_os = @import("../os/main.zig");
+const renderer = @import("../renderer.zig");
+const Renderer = renderer.Renderer;
+const apprt = @import("../apprt.zig");
+
+// Get native API access on certain platforms so we can do more customization.
+const glfwNative = glfw.Native(.{
+    .cocoa = builtin.target.isDarwin(),
+});
+
+const log = std.log.scoped(.glfw);
+
+pub const Window = struct {
+    /// The glfw window handle
+    window: glfw.Window,
+
+    /// The glfw mouse cursor handle.
+    cursor: glfw.Cursor,
+
+    pub fn init(app: *const App) !Window {
+        // Create our window
+        const win = try glfw.Window.create(
+            640,
+            480,
+            "ghostty",
+            null,
+            null,
+            Renderer.glfwWindowHints(),
+        );
+        errdefer win.destroy();
+
+        if (builtin.mode == .Debug) {
+            // Get our physical DPI - debug only because we don't have a use for
+            // this but the logging of it may be useful
+            const monitor = win.getMonitor() orelse monitor: {
+                log.warn("window had null monitor, getting primary monitor", .{});
+                break :monitor glfw.Monitor.getPrimary().?;
+            };
+            const physical_size = monitor.getPhysicalSize();
+            const video_mode = try monitor.getVideoMode();
+            const physical_x_dpi = @intToFloat(f32, video_mode.getWidth()) / (@intToFloat(f32, physical_size.width_mm) / 25.4);
+            const physical_y_dpi = @intToFloat(f32, video_mode.getHeight()) / (@intToFloat(f32, physical_size.height_mm) / 25.4);
+            log.debug("physical dpi x={} y={}", .{
+                physical_x_dpi,
+                physical_y_dpi,
+            });
+        }
+
+        // On Mac, enable tabbing
+        if (comptime builtin.target.isDarwin()) {
+            const NSWindowTabbingMode = enum(usize) { automatic = 0, preferred = 1, disallowed = 2 };
+            const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(win).?);
+
+            // Tabbing mode enables tabbing at all
+            nswindow.setProperty("tabbingMode", NSWindowTabbingMode.automatic);
+
+            // All windows within a tab bar must have a matching tabbing ID.
+            // The app sets this up for us.
+            nswindow.setProperty("tabbingIdentifier", app.darwin.tabbing_id);
+        }
+
+        // Create the cursor
+        const cursor = try glfw.Cursor.createStandard(.ibeam);
+        errdefer cursor.destroy();
+        if ((comptime !builtin.target.isDarwin()) or internal_os.macosVersionAtLeast(13, 0, 0)) {
+            // We only set our cursor if we're NOT on Mac, or if we are then the
+            // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
+            // since we use a tab group.
+            try win.setCursor(cursor);
+        }
+
+        // Build our result
+        return Window{
+            .window = win,
+            .cursor = cursor,
+        };
+    }
+
+    pub fn deinit(self: *Window) void {
+        var tabgroup_opt: if (builtin.target.isDarwin()) ?objc.Object else void = undefined;
+        if (comptime builtin.target.isDarwin()) {
+            const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(self.window).?);
+            const tabgroup = nswindow.getProperty(objc.Object, "tabGroup");
+
+            // On macOS versions prior to Ventura, we lose window focus on tab close
+            // for some reason. We manually fix this by keeping track of the tab
+            // group and just selecting the next window.
+            if (internal_os.macosVersionAtLeast(13, 0, 0))
+                tabgroup_opt = null
+            else
+                tabgroup_opt = tabgroup;
+
+            const windows = tabgroup.getProperty(objc.Object, "windows");
+            switch (windows.getProperty(usize, "count")) {
+                // If we're going down to one window our tab bar is going to be
+                // destroyed so unset it so that the later logic doesn't try to
+                // use it.
+                1 => tabgroup_opt = null,
+
+                // If our tab bar is visible and we are going down to 1 window,
+                // hide the tab bar. The check is "2" because our current window
+                // is still present.
+                2 => if (tabgroup.getProperty(bool, "tabBarVisible")) {
+                    nswindow.msgSend(void, objc.sel("toggleTabBar:"), .{nswindow.value});
+                },
+
+                else => {},
+            }
+        }
+
+        // We can now safely destroy our windows. We have to do this BEFORE
+        // setting up the new focused window below.
+        self.window.destroy();
+        self.cursor.destroy();
+
+        // If we have a tabgroup set, we want to manually focus the next window.
+        // We should NOT have to do this usually, see the comments above.
+        if (comptime builtin.target.isDarwin()) {
+            if (tabgroup_opt) |tabgroup| {
+                const selected = tabgroup.getProperty(objc.Object, "selectedWindow");
+                selected.msgSend(void, objc.sel("makeKeyWindow"), .{});
+            }
+        }
+    }
+
+    /// Returns the content scale for the created window.
+    pub fn getContentScale(self: *const Window) !apprt.ContentScale {
+        const scale = try self.window.getContentScale();
+        return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
+    }
+
+    /// Returns the size of the window in screen coordinates.
+    pub fn getSize(self: *const Window) !apprt.WindowSize {
+        const size = try self.window.getSize();
+        return apprt.WindowSize{ .width = size.width, .height = size.height };
+    }
+};

commit ff1f1d8925ce5442250fc90b9b4dfca42dd546ef
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 13:33:19 2022 -0800

    move the size callback into apprt

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0862a439..5865f3e9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -14,6 +14,7 @@ const internal_os = @import("../os/main.zig");
 const renderer = @import("../renderer.zig");
 const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
+const CoreWindow = @import("../Window.zig");
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
@@ -29,7 +30,7 @@ pub const Window = struct {
     /// The glfw mouse cursor handle.
     cursor: glfw.Cursor,
 
-    pub fn init(app: *const App) !Window {
+    pub fn init(app: *const App, core_win: *CoreWindow) !Window {
         // Create our window
         const win = try glfw.Window.create(
             640,
@@ -81,6 +82,10 @@ pub const Window = struct {
             try win.setCursor(cursor);
         }
 
+        // Set our callbacks
+        win.setUserPointer(core_win);
+        win.setSizeCallback(sizeCallback);
+
         // Build our result
         return Window{
             .window = win,
@@ -141,9 +146,35 @@ pub const Window = struct {
         return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
     }
 
-    /// Returns the size of the window in screen coordinates.
+    /// Returns the size of the window in pixels. The pixel size may
+    /// not match screen coordinate size but we should be able to convert
+    /// back and forth using getContentScale.
     pub fn getSize(self: *const Window) !apprt.WindowSize {
-        const size = try self.window.getSize();
+        const size = self.window.getFramebufferSize() catch |err| err: {
+            log.err("error querying window size in pixels, will use screen size err={}", .{err});
+            break :err try self.window.getSize();
+        };
+
         return apprt.WindowSize{ .width = size.width, .height = size.height };
     }
+
+    fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
+        _ = width;
+        _ = height;
+
+        // Get the size. We are given a width/height but this is in screen
+        // coordinates and we want raw pixels. The core window uses the content
+        // scale to scale appropriately.
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const size = core_win.windowing_system.getSize() catch |err| {
+            log.err("error querying window size for size callback err={}", .{err});
+            return;
+        };
+
+        // Call the primary callback.
+        core_win.sizeCallback(size) catch |err| {
+            log.err("error in size callback err={}", .{err});
+            return;
+        };
+    }
 };

commit 946383eb770491d4ccf950c411881adf3652c33c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 14:45:03 2022 -0800

    apprt: key/charCallback, input supports all glfw keys

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 5865f3e9..f5e485fc 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -7,9 +7,11 @@ const std = @import("std");
 const builtin = @import("builtin");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
+const trace = @import("tracy").trace;
 const glfw = @import("glfw");
 const objc = @import("objc");
 const App = @import("../App.zig");
+const input = @import("../input.zig");
 const internal_os = @import("../os/main.zig");
 const renderer = @import("../renderer.zig");
 const Renderer = renderer.Renderer;
@@ -85,6 +87,8 @@ pub const Window = struct {
         // Set our callbacks
         win.setUserPointer(core_win);
         win.setSizeCallback(sizeCallback);
+        win.setCharCallback(charCallback);
+        win.setKeyCallback(keyCallback);
 
         // Build our result
         return Window{
@@ -158,6 +162,12 @@ pub const Window = struct {
         return apprt.WindowSize{ .width = size.width, .height = size.height };
     }
 
+    /// Set the flag that notes this window should be closed for the next
+    /// iteration of the event loop.
+    pub fn setShouldClose(self: *Window) void {
+        self.window.setShouldClose(true);
+    }
+
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
         _ = width;
         _ = height;
@@ -177,4 +187,167 @@ pub const Window = struct {
             return;
         };
     }
+
+    fn charCallback(window: glfw.Window, codepoint: u21) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        core_win.charCallback(codepoint) catch |err| {
+            log.err("error in char callback err={}", .{err});
+            return;
+        };
+    }
+
+    fn keyCallback(
+        window: glfw.Window,
+        glfw_key: glfw.Key,
+        scancode: i32,
+        glfw_action: glfw.Action,
+        glfw_mods: glfw.Mods,
+    ) void {
+        _ = scancode;
+
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        // Convert our glfw types into our input types
+        const mods = @bitCast(input.Mods, glfw_mods);
+        const action: input.Action = switch (glfw_action) {
+            .release => .release,
+            .press => .press,
+            .repeat => .repeat,
+        };
+        const key: input.Key = switch (glfw_key) {
+            .a => .a,
+            .b => .b,
+            .c => .c,
+            .d => .d,
+            .e => .e,
+            .f => .f,
+            .g => .g,
+            .h => .h,
+            .i => .i,
+            .j => .j,
+            .k => .k,
+            .l => .l,
+            .m => .m,
+            .n => .n,
+            .o => .o,
+            .p => .p,
+            .q => .q,
+            .r => .r,
+            .s => .s,
+            .t => .t,
+            .u => .u,
+            .v => .v,
+            .w => .w,
+            .x => .x,
+            .y => .y,
+            .z => .z,
+            .zero => .zero,
+            .one => .one,
+            .two => .three,
+            .three => .four,
+            .four => .four,
+            .five => .five,
+            .six => .six,
+            .seven => .seven,
+            .eight => .eight,
+            .nine => .nine,
+            .up => .up,
+            .down => .down,
+            .right => .right,
+            .left => .left,
+            .home => .home,
+            .end => .end,
+            .page_up => .page_up,
+            .page_down => .page_down,
+            .escape => .escape,
+            .F1 => .f1,
+            .F2 => .f2,
+            .F3 => .f3,
+            .F4 => .f4,
+            .F5 => .f5,
+            .F6 => .f6,
+            .F7 => .f7,
+            .F8 => .f8,
+            .F9 => .f9,
+            .F10 => .f10,
+            .F11 => .f11,
+            .F12 => .f12,
+            .F13 => .f13,
+            .F14 => .f14,
+            .F15 => .f15,
+            .F16 => .f16,
+            .F17 => .f17,
+            .F18 => .f18,
+            .F19 => .f19,
+            .F20 => .f20,
+            .F21 => .f21,
+            .F22 => .f22,
+            .F23 => .f23,
+            .F24 => .f24,
+            .F25 => .f25,
+            .kp_0 => .kp_0,
+            .kp_1 => .kp_1,
+            .kp_2 => .kp_2,
+            .kp_3 => .kp_3,
+            .kp_4 => .kp_4,
+            .kp_5 => .kp_5,
+            .kp_6 => .kp_6,
+            .kp_7 => .kp_7,
+            .kp_8 => .kp_8,
+            .kp_9 => .kp_9,
+            .kp_decimal => .kp_decimal,
+            .kp_divide => .kp_divide,
+            .kp_multiply => .kp_multiply,
+            .kp_subtract => .kp_subtract,
+            .kp_add => .kp_add,
+            .kp_enter => .kp_enter,
+            .kp_equal => .kp_equal,
+            .grave_accent => .grave_accent,
+            .minus => .minus,
+            .equal => .equal,
+            .space => .space,
+            .semicolon => .semicolon,
+            .apostrophe => .apostrophe,
+            .comma => .comma,
+            .period => .period,
+            .slash => .slash,
+            .left_bracket => .left_bracket,
+            .right_bracket => .right_bracket,
+            .backslash => .backslash,
+            .enter => .enter,
+            .tab => .tab,
+            .backspace => .backspace,
+            .insert => .insert,
+            .delete => .delete,
+            .caps_lock => .caps_lock,
+            .scroll_lock => .scroll_lock,
+            .num_lock => .num_lock,
+            .print_screen => .print_screen,
+            .pause => .pause,
+            .left_shift => .left_shift,
+            .left_control => .left_control,
+            .left_alt => .left_alt,
+            .left_super => .left_super,
+            .right_shift => .right_shift,
+            .right_control => .right_control,
+            .right_alt => .right_alt,
+            .right_super => .right_super,
+
+            .menu,
+            .world_1,
+            .world_2,
+            .unknown,
+            => .invalid,
+        };
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        core_win.keyCallback(action, key, mods) catch |err| {
+            log.err("error in key callback err={}", .{err});
+            return;
+        };
+    }
 };

commit 8196481ddaeb8d590822ffc766b1fc111d64a33b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 14:47:31 2022 -0800

    apprt: couple more easy callbacks

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index f5e485fc..e33346fb 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -89,6 +89,8 @@ pub const Window = struct {
         win.setSizeCallback(sizeCallback);
         win.setCharCallback(charCallback);
         win.setKeyCallback(keyCallback);
+        win.setFocusCallback(focusCallback);
+        win.setRefreshCallback(refreshCallback);
 
         // Build our result
         return Window{
@@ -350,4 +352,26 @@ pub const Window = struct {
             return;
         };
     }
+
+    fn focusCallback(window: glfw.Window, focused: bool) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        core_win.focusCallback(focused) catch |err| {
+            log.err("error in focus callback err={}", .{err});
+            return;
+        };
+    }
+
+    fn refreshCallback(window: glfw.Window) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        core_win.refreshCallback() catch |err| {
+            log.err("error in refresh callback err={}", .{err});
+            return;
+        };
+    }
 };

commit fe84686a1d478d04f6aa77336ba9228d30ba6e62
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:15:35 2022 -0800

    apprt: all mouse callbacks

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e33346fb..4ca564df 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -91,6 +91,9 @@ pub const Window = struct {
         win.setKeyCallback(keyCallback);
         win.setFocusCallback(focusCallback);
         win.setRefreshCallback(refreshCallback);
+        win.setScrollCallback(scrollCallback);
+        win.setCursorPosCallback(cursorPosCallback);
+        win.setMouseButtonCallback(mouseButtonCallback);
 
         // Build our result
         return Window{
@@ -164,12 +167,45 @@ pub const Window = struct {
         return apprt.WindowSize{ .width = size.width, .height = size.height };
     }
 
+    /// Returns the cursor position in scaled pixels relative to the
+    /// upper-left of the window.
+    pub fn getCursorPos(self: *const Window) !apprt.CursorPos {
+        const unscaled_pos = try self.window.getCursorPos();
+        const pos = try self.cursorPosToPixels(unscaled_pos);
+        return apprt.CursorPos{
+            .x = @floatCast(f32, pos.xpos),
+            .y = @floatCast(f32, pos.ypos),
+        };
+    }
+
     /// Set the flag that notes this window should be closed for the next
     /// iteration of the event loop.
     pub fn setShouldClose(self: *Window) void {
         self.window.setShouldClose(true);
     }
 
+    /// The cursor position from glfw directly is in screen coordinates but
+    /// all our interface works in pixels.
+    fn cursorPosToPixels(self: *const Window, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {
+        // The cursor position is in screen coordinates but we
+        // want it in pixels. we need to get both the size of the
+        // window in both to get the ratio to make the conversion.
+        const size = try self.window.getSize();
+        const fb_size = try self.window.getFramebufferSize();
+
+        // If our framebuffer and screen are the same, then there is no scaling
+        // happening and we can short-circuit by returning the pos as-is.
+        if (fb_size.width == size.width and fb_size.height == size.height)
+            return pos;
+
+        const x_scale = @intToFloat(f64, fb_size.width) / @intToFloat(f64, size.width);
+        const y_scale = @intToFloat(f64, fb_size.height) / @intToFloat(f64, size.height);
+        return .{
+            .xpos = pos.xpos * x_scale,
+            .ypos = pos.ypos * y_scale,
+        };
+    }
+
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
         _ = width;
         _ = height;
@@ -374,4 +410,81 @@ pub const Window = struct {
             return;
         };
     }
+
+    fn scrollCallback(window: glfw.Window, xoff: f64, yoff: f64) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        core_win.scrollCallback(xoff, yoff) catch |err| {
+            log.err("error in scroll callback err={}", .{err});
+            return;
+        };
+    }
+
+    fn cursorPosCallback(
+        window: glfw.Window,
+        unscaled_xpos: f64,
+        unscaled_ypos: f64,
+    ) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+
+        // Convert our unscaled x/y to scaled.
+        const pos = core_win.windowing_system.cursorPosToPixels(.{
+            .xpos = unscaled_xpos,
+            .ypos = unscaled_ypos,
+        }) catch |err| {
+            log.err(
+                "error converting cursor pos to scaled pixels in cursor pos callback err={}",
+                .{err},
+            );
+            return;
+        };
+
+        core_win.cursorPosCallback(.{
+            .x = @floatCast(f32, pos.xpos),
+            .y = @floatCast(f32, pos.ypos),
+        }) catch |err| {
+            log.err("error in cursor pos callback err={}", .{err});
+            return;
+        };
+    }
+
+    fn mouseButtonCallback(
+        window: glfw.Window,
+        glfw_button: glfw.MouseButton,
+        glfw_action: glfw.Action,
+        glfw_mods: glfw.Mods,
+    ) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const core_win = window.getUserPointer(CoreWindow) orelse return;
+
+        // Convert glfw button to input button
+        const mods = @bitCast(input.Mods, glfw_mods);
+        const button: input.MouseButton = switch (glfw_button) {
+            .left => .left,
+            .right => .right,
+            .middle => .middle,
+            .four => .four,
+            .five => .five,
+            .six => .six,
+            .seven => .seven,
+            .eight => .eight,
+        };
+        const action: input.MouseButtonState = switch (glfw_action) {
+            .press => .press,
+            .release => .release,
+            else => unreachable,
+        };
+
+        core_win.mouseButtonCallback(action, button, mods) catch |err| {
+            log.err("error in scroll callback err={}", .{err});
+            return;
+        };
+    }
 };

commit ba0cbecd79ea0773189531bfe65862a9736351c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:18:32 2022 -0800

    core window doesn't have reference to glfw window anymore!

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4ca564df..4973ca44 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -184,6 +184,15 @@ pub const Window = struct {
         self.window.setShouldClose(true);
     }
 
+    /// Returns true if the window is flagged to close.
+    pub fn shouldClose(self: *const Window) bool {
+        return self.window.shouldClose();
+    }
+
+    pub fn setTitle(self: *Window, slice: [:0]const u8) !void {
+        try self.window.setTitle(slice.ptr);
+    }
+
     /// The cursor position from glfw directly is in screen coordinates but
     /// all our interface works in pixels.
     fn cursorPosToPixels(self: *const Window, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {

commit 8907104e7c692cef713cd39d835da281a96bbf40
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:22:18 2022 -0800

    comments

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4973ca44..1a94d17a 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -189,6 +189,7 @@ pub const Window = struct {
         return self.window.shouldClose();
     }
 
+    /// Set the title of the window.
     pub fn setTitle(self: *Window, slice: [:0]const u8) !void {
         try self.window.setTitle(slice.ptr);
     }

commit 0e73c5eb936c7db51c6dc7d9deb1aa34293a3472
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:29:36 2022 -0800

    apprt: clipboard

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 1a94d17a..8e8bd58f 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -194,6 +194,20 @@ pub const Window = struct {
         try self.window.setTitle(slice.ptr);
     }
 
+    /// Read the clipboard. The windowing system is responsible for allocating
+    /// a buffer as necessary. This should be a stable pointer until the next
+    /// time getClipboardString is called.
+    pub fn getClipboardString(self: *const Window) ![:0]const u8 {
+        _ = self;
+        return try glfw.getClipboardString();
+    }
+
+    /// Set the clipboard.
+    pub fn setClipboardString(self: *const Window, val: [:0]const u8) !void {
+        _ = self;
+        try glfw.setClipboardString(val);
+    }
+
     /// The cursor position from glfw directly is in screen coordinates but
     /// all our interface works in pixels.
     fn cursorPosToPixels(self: *const Window, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {

commit d5895f903479890c2fb61fd80dce32a5bbd7e84e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:32:36 2022 -0800

    rename windowing_system to just window

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8e8bd58f..53c28a4a 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -238,7 +238,7 @@ pub const Window = struct {
         // coordinates and we want raw pixels. The core window uses the content
         // scale to scale appropriately.
         const core_win = window.getUserPointer(CoreWindow) orelse return;
-        const size = core_win.windowing_system.getSize() catch |err| {
+        const size = core_win.window.getSize() catch |err| {
             log.err("error querying window size for size callback err={}", .{err});
             return;
         };
@@ -457,7 +457,7 @@ pub const Window = struct {
         const core_win = window.getUserPointer(CoreWindow) orelse return;
 
         // Convert our unscaled x/y to scaled.
-        const pos = core_win.windowing_system.cursorPosToPixels(.{
+        const pos = core_win.window.cursorPosToPixels(.{
             .xpos = unscaled_xpos,
             .ypos = unscaled_ypos,
         }) catch |err| {

commit b502d5aa7dc76dff33df17b3077b612ba0b4da5e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:36:25 2022 -0800

    apprt: window size limits

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 53c28a4a..d4893919 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -149,6 +149,23 @@ pub const Window = struct {
         }
     }
 
+    /// Set the size limits of the window.
+    /// Note: this interface is not good, we should redo it if we plan
+    /// to use this more. i.e. you can't set max width but no max height,
+    /// or no mins.
+    pub fn setSizeLimits(self: *Window, min: apprt.WindowSize, max_: ?apprt.WindowSize) !void {
+        try self.window.setSizeLimits(.{
+            .width = min.width,
+            .height = min.height,
+        }, if (max_) |max| .{
+            .width = max.width,
+            .height = max.height,
+        } else .{
+            .width = null,
+            .height = null,
+        });
+    }
+
     /// Returns the content scale for the created window.
     pub fn getContentScale(self: *const Window) !apprt.ContentScale {
         const scale = try self.window.getContentScale();

commit 58218af2b535b44b8da192c5e852962ca5cb13a4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Dec 30 15:56:42 2022 -0800

    app: make apprt agnostic

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index d4893919..9aded5d2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -10,12 +10,12 @@ const Allocator = std.mem.Allocator;
 const trace = @import("tracy").trace;
 const glfw = @import("glfw");
 const objc = @import("objc");
-const App = @import("../App.zig");
 const input = @import("../input.zig");
 const internal_os = @import("../os/main.zig");
 const renderer = @import("../renderer.zig");
 const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
+const CoreApp = @import("../App.zig");
 const CoreWindow = @import("../Window.zig");
 
 // Get native API access on certain platforms so we can do more customization.
@@ -25,6 +25,30 @@ const glfwNative = glfw.Native(.{
 
 const log = std.log.scoped(.glfw);
 
+pub const App = struct {
+    pub fn init() !App {
+        try glfw.init(.{});
+        return .{};
+    }
+
+    pub fn terminate(self: App) void {
+        _ = self;
+        glfw.terminate();
+    }
+
+    /// Wakeup the event loop. This should be able to be called from any thread.
+    pub fn wakeup(self: App) !void {
+        _ = self;
+        try glfw.postEmptyEvent();
+    }
+
+    /// Wait for events in the event loop to process.
+    pub fn wait(self: App) !void {
+        _ = self;
+        try glfw.waitEvents();
+    }
+};
+
 pub const Window = struct {
     /// The glfw window handle
     window: glfw.Window,
@@ -32,7 +56,7 @@ pub const Window = struct {
     /// The glfw mouse cursor handle.
     cursor: glfw.Cursor,
 
-    pub fn init(app: *const App, core_win: *CoreWindow) !Window {
+    pub fn init(app: *const CoreApp, core_win: *CoreWindow) !Window {
         // Create our window
         const win = try glfw.Window.create(
             640,

commit be75109a1dcc2add39f9b868f67f620728986717
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 14 20:58:33 2023 -0800

    new build system

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 9aded5d2..0cb5fab8 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -27,7 +27,7 @@ const log = std.log.scoped(.glfw);
 
 pub const App = struct {
     pub fn init() !App {
-        try glfw.init(.{});
+        if (!glfw.init(.{})) return error.GlfwInitFailed;
         return .{};
     }
 
@@ -39,13 +39,13 @@ pub const App = struct {
     /// Wakeup the event loop. This should be able to be called from any thread.
     pub fn wakeup(self: App) !void {
         _ = self;
-        try glfw.postEmptyEvent();
+        glfw.postEmptyEvent();
     }
 
     /// Wait for events in the event loop to process.
     pub fn wait(self: App) !void {
         _ = self;
-        try glfw.waitEvents();
+        glfw.waitEvents();
     }
 };
 
@@ -58,14 +58,14 @@ pub const Window = struct {
 
     pub fn init(app: *const CoreApp, core_win: *CoreWindow) !Window {
         // Create our window
-        const win = try glfw.Window.create(
+        const win = glfw.Window.create(
             640,
             480,
             "ghostty",
             null,
             null,
             Renderer.glfwWindowHints(),
-        );
+        ) orelse return glfw.mustGetErrorCode();
         errdefer win.destroy();
 
         if (builtin.mode == .Debug) {
@@ -76,7 +76,7 @@ pub const Window = struct {
                 break :monitor glfw.Monitor.getPrimary().?;
             };
             const physical_size = monitor.getPhysicalSize();
-            const video_mode = try monitor.getVideoMode();
+            const video_mode = monitor.getVideoMode() orelse return glfw.mustGetErrorCode();
             const physical_x_dpi = @intToFloat(f32, video_mode.getWidth()) / (@intToFloat(f32, physical_size.width_mm) / 25.4);
             const physical_y_dpi = @intToFloat(f32, video_mode.getHeight()) / (@intToFloat(f32, physical_size.height_mm) / 25.4);
             log.debug("physical dpi x={} y={}", .{
@@ -99,13 +99,13 @@ pub const Window = struct {
         }
 
         // Create the cursor
-        const cursor = try glfw.Cursor.createStandard(.ibeam);
+        const cursor = glfw.Cursor.createStandard(.ibeam) orelse return glfw.mustGetErrorCode();
         errdefer cursor.destroy();
         if ((comptime !builtin.target.isDarwin()) or internal_os.macosVersionAtLeast(13, 0, 0)) {
             // We only set our cursor if we're NOT on Mac, or if we are then the
             // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
             // since we use a tab group.
-            try win.setCursor(cursor);
+            win.setCursor(cursor);
         }
 
         // Set our callbacks
@@ -178,7 +178,7 @@ pub const Window = struct {
     /// to use this more. i.e. you can't set max width but no max height,
     /// or no mins.
     pub fn setSizeLimits(self: *Window, min: apprt.WindowSize, max_: ?apprt.WindowSize) !void {
-        try self.window.setSizeLimits(.{
+        self.window.setSizeLimits(.{
             .width = min.width,
             .height = min.height,
         }, if (max_) |max| .{
@@ -192,7 +192,7 @@ pub const Window = struct {
 
     /// Returns the content scale for the created window.
     pub fn getContentScale(self: *const Window) !apprt.ContentScale {
-        const scale = try self.window.getContentScale();
+        const scale = self.window.getContentScale();
         return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
     }
 
@@ -200,18 +200,14 @@ pub const Window = struct {
     /// not match screen coordinate size but we should be able to convert
     /// back and forth using getContentScale.
     pub fn getSize(self: *const Window) !apprt.WindowSize {
-        const size = self.window.getFramebufferSize() catch |err| err: {
-            log.err("error querying window size in pixels, will use screen size err={}", .{err});
-            break :err try self.window.getSize();
-        };
-
+        const size = self.window.getFramebufferSize();
         return apprt.WindowSize{ .width = size.width, .height = size.height };
     }
 
     /// Returns the cursor position in scaled pixels relative to the
     /// upper-left of the window.
     pub fn getCursorPos(self: *const Window) !apprt.CursorPos {
-        const unscaled_pos = try self.window.getCursorPos();
+        const unscaled_pos = self.window.getCursorPos();
         const pos = try self.cursorPosToPixels(unscaled_pos);
         return apprt.CursorPos{
             .x = @floatCast(f32, pos.xpos),
@@ -232,7 +228,7 @@ pub const Window = struct {
 
     /// Set the title of the window.
     pub fn setTitle(self: *Window, slice: [:0]const u8) !void {
-        try self.window.setTitle(slice.ptr);
+        self.window.setTitle(slice.ptr);
     }
 
     /// Read the clipboard. The windowing system is responsible for allocating
@@ -240,13 +236,13 @@ pub const Window = struct {
     /// time getClipboardString is called.
     pub fn getClipboardString(self: *const Window) ![:0]const u8 {
         _ = self;
-        return try glfw.getClipboardString();
+        return glfw.getClipboardString() orelse return glfw.mustGetErrorCode();
     }
 
     /// Set the clipboard.
     pub fn setClipboardString(self: *const Window, val: [:0]const u8) !void {
         _ = self;
-        try glfw.setClipboardString(val);
+        glfw.setClipboardString(val);
     }
 
     /// The cursor position from glfw directly is in screen coordinates but
@@ -255,8 +251,8 @@ pub const Window = struct {
         // The cursor position is in screen coordinates but we
         // want it in pixels. we need to get both the size of the
         // window in both to get the ratio to make the conversion.
-        const size = try self.window.getSize();
-        const fb_size = try self.window.getFramebufferSize();
+        const size = self.window.getSize();
+        const fb_size = self.window.getFramebufferSize();
 
         // If our framebuffer and screen are the same, then there is no scaling
         // happening and we can short-circuit by returning the pos as-is.

commit eed6979868573df6786406c568204bf02d01a27d
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 16 08:52:40 2023 -0800

    apprt: start embedded implement, make App API available to C

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0cb5fab8..f64ad200 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -26,7 +26,9 @@ const glfwNative = glfw.Native(.{
 const log = std.log.scoped(.glfw);
 
 pub const App = struct {
-    pub fn init() !App {
+    pub const Options = struct {};
+
+    pub fn init(_: Options) !App {
         if (!glfw.init(.{})) return error.GlfwInitFailed;
         return .{};
     }

commit c68f8082df8dfffe1730394d1a5b4c0b6798f751
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 17 09:03:23 2023 -0800

    apprt: can pass options through to Windows

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index f64ad200..1e03f30e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -58,7 +58,11 @@ pub const Window = struct {
     /// The glfw mouse cursor handle.
     cursor: glfw.Cursor,
 
-    pub fn init(app: *const CoreApp, core_win: *CoreWindow) !Window {
+    pub const Options = struct {};
+
+    pub fn init(app: *const CoreApp, core_win: *CoreWindow, opts: Options) !Window {
+        _ = opts;
+
         // Create our window
         const win = glfw.Window.create(
             640,

commit 3d8c62c41ff673a5156388863db8f70680d3e05e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 12:24:22 2023 -0800

    apprt refactor in progress, launches glfw no window

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 1e03f30e..5473e13d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -5,10 +5,12 @@
 
 const std = @import("std");
 const builtin = @import("builtin");
+const build_config = @import("../build_config.zig");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const trace = @import("tracy").trace;
 const glfw = @import("glfw");
+const macos = @import("macos");
 const objc = @import("objc");
 const input = @import("../input.zig");
 const internal_os = @import("../os/main.zig");
@@ -26,11 +28,28 @@ const glfwNative = glfw.Native(.{
 const log = std.log.scoped(.glfw);
 
 pub const App = struct {
+    app: *CoreApp,
+
+    /// Mac-specific state.
+    darwin: if (Darwin.enabled) Darwin else void,
+
     pub const Options = struct {};
 
-    pub fn init(_: Options) !App {
+    pub fn init(core_app: *CoreApp, _: Options) !App {
         if (!glfw.init(.{})) return error.GlfwInitFailed;
-        return .{};
+        glfw.setErrorCallback(glfwErrorCallback);
+
+        // Mac-specific state. For example, on Mac we enable window tabbing.
+        var darwin = if (Darwin.enabled) try Darwin.init() else {};
+        errdefer if (Darwin.enabled) darwin.deinit();
+
+        // Set our callback for being woken up
+        core_app.wakeup_cb = wakeup;
+
+        return .{
+            .app = core_app,
+            .darwin = darwin,
+        };
     }
 
     pub fn terminate(self: App) void {
@@ -38,17 +57,67 @@ pub const App = struct {
         glfw.terminate();
     }
 
+    /// Run the event loop. This doesn't return until the app exits.
+    pub fn run(self: *App) !void {
+        while (true) {
+            // Wait for any events from the app event loop. wakeup will post
+            // an empty event so that this will return.
+            glfw.waitEvents();
+
+            // Tick the terminal app
+            const should_quit = try self.app.tick(self);
+            if (should_quit) return;
+        }
+    }
+
     /// Wakeup the event loop. This should be able to be called from any thread.
-    pub fn wakeup(self: App) !void {
-        _ = self;
+    pub fn wakeup() void {
         glfw.postEmptyEvent();
     }
 
-    /// Wait for events in the event loop to process.
-    pub fn wait(self: App) !void {
-        _ = self;
-        glfw.waitEvents();
+    fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
+        std.log.warn("glfw error={} message={s}", .{ code, desc });
+
+        // Workaround for: https://github.com/ocornut/imgui/issues/5908
+        // If we get an invalid value with "scancode" in the message we assume
+        // it is from the glfw key callback that imgui sets and we clear the
+        // error so that our future code doesn't crash.
+        if (code == glfw.ErrorCode.InvalidValue and
+            std.mem.indexOf(u8, desc, "scancode") != null)
+        {
+            _ = glfw.getError();
+        }
     }
+
+    /// Mac-specific settings. This is only enabled when the target is
+    /// Mac and the artifact is a standalone exe. We don't target libs because
+    /// the embedded API doesn't do windowing.
+    const Darwin = struct {
+        const enabled = builtin.target.isDarwin() and build_config.artifact == .exe;
+
+        tabbing_id: *macos.foundation.String,
+
+        pub fn init() !Darwin {
+            const NSWindow = objc.Class.getClass("NSWindow").?;
+            NSWindow.msgSend(void, objc.sel("setAllowsAutomaticWindowTabbing:"), .{true});
+
+            // Our tabbing ID allows all of our windows to group together
+            const tabbing_id = try macos.foundation.String.createWithBytes(
+                "com.mitchellh.ghostty.window",
+                .utf8,
+                false,
+            );
+            errdefer tabbing_id.release();
+
+            // Setup our Mac settings
+            return .{ .tabbing_id = tabbing_id };
+        }
+
+        pub fn deinit(self: *Darwin) void {
+            self.tabbing_id.release();
+            self.* = undefined;
+        }
+    };
 };
 
 pub const Window = struct {

commit fbe35c226bf354d7c256d2bb5970f434d567889a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 14:37:37 2023 -0800

    Integrating new surface

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 5473e13d..2150711d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -18,7 +18,7 @@ const renderer = @import("../renderer.zig");
 const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
-const CoreWindow = @import("../Window.zig");
+const CoreSurface = @import("../Surface.zig");
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
@@ -75,6 +75,16 @@ pub const App = struct {
         glfw.postEmptyEvent();
     }
 
+    /// Create a new window for the app.
+    pub fn newWindow(self: *App) !void {
+        // Grab a surface allocation because we're going to need it.
+        const surface = try self.app.surface_pool.create();
+        errdefer self.app.surface_pool.destroy(surface);
+
+        // Create the surface -- because windows are surfaces for glfw.
+        try surface.init(self);
+    }
+
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
         std.log.warn("glfw error={} message={s}", .{ code, desc });
 
@@ -120,18 +130,32 @@ pub const App = struct {
     };
 };
 
-pub const Window = struct {
+/// Surface represents the drawable surface for glfw. In glfw, a surface
+/// is always a window because that is the only abstraction that glfw exposes.
+///
+/// This means that there is no way for the glfw runtime to support tabs,
+/// splits, etc. without considerable effort. In fact, on Darwin, we do
+/// support tabs because the minimal tabbing interface is a window abstraction,
+/// but this is a bit of a hack. The native Swift runtime should be used instead
+/// which uses real native tabbing.
+///
+/// Other runtimes a surface usually represents the equivalent of a "view"
+/// or "widget" level granularity.
+pub const Surface = struct {
     /// The glfw window handle
     window: glfw.Window,
 
     /// The glfw mouse cursor handle.
     cursor: glfw.Cursor,
 
-    pub const Options = struct {};
+    /// A core surface
+    core_surface: CoreSurface,
 
-    pub fn init(app: *const CoreApp, core_win: *CoreWindow, opts: Options) !Window {
-        _ = opts;
+    pub const Options = struct {};
 
+    /// Initialize the surface into the given self pointer. This gives a
+    /// stable pointer to the destination that can be used for callbacks.
+    pub fn init(self: *Surface, app: *App) !void {
         // Create our window
         const win = glfw.Window.create(
             640,
@@ -143,9 +167,9 @@ pub const Window = struct {
         ) orelse return glfw.mustGetErrorCode();
         errdefer win.destroy();
 
+        // Get our physical DPI - debug only because we don't have a use for
+        // this but the logging of it may be useful
         if (builtin.mode == .Debug) {
-            // Get our physical DPI - debug only because we don't have a use for
-            // this but the logging of it may be useful
             const monitor = win.getMonitor() orelse monitor: {
                 log.warn("window had null monitor, getting primary monitor", .{});
                 break :monitor glfw.Monitor.getPrimary().?;
@@ -160,8 +184,8 @@ pub const Window = struct {
             });
         }
 
-        // On Mac, enable tabbing
-        if (comptime builtin.target.isDarwin()) {
+        // On Mac, enable window tabbing
+        if (App.Darwin.enabled) {
             const NSWindowTabbingMode = enum(usize) { automatic = 0, preferred = 1, disallowed = 2 };
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(win).?);
 
@@ -184,7 +208,7 @@ pub const Window = struct {
         }
 
         // Set our callbacks
-        win.setUserPointer(core_win);
+        win.setUserPointer(&self.core_surface);
         win.setSizeCallback(sizeCallback);
         win.setCharCallback(charCallback);
         win.setKeyCallback(keyCallback);
@@ -195,13 +219,23 @@ pub const Window = struct {
         win.setMouseButtonCallback(mouseButtonCallback);
 
         // Build our result
-        return Window{
+        self.* = .{
             .window = win,
             .cursor = cursor,
+            .core_surface = undefined,
         };
+        errdefer self.* = undefined;
+
+        // Add ourselves to the list of surfaces on the app.
+        try app.app.addSurface(self);
+        errdefer app.app.deleteSurface(self);
+
+        // Initialize our surface now that we have the stable pointer.
+        try self.core_surface.init(app.app, app.app.config, self);
+        errdefer self.core_surface.destroy();
     }
 
-    pub fn deinit(self: *Window) void {
+    pub fn deinit(self: *Surface) void {
         var tabgroup_opt: if (builtin.target.isDarwin()) ?objc.Object else void = undefined;
         if (comptime builtin.target.isDarwin()) {
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(self.window).?);
@@ -240,7 +274,7 @@ pub const Window = struct {
 
         // If we have a tabgroup set, we want to manually focus the next window.
         // We should NOT have to do this usually, see the comments above.
-        if (comptime builtin.target.isDarwin()) {
+        if (App.Darwin.enabled) {
             if (tabgroup_opt) |tabgroup| {
                 const selected = tabgroup.getProperty(objc.Object, "selectedWindow");
                 selected.msgSend(void, objc.sel("makeKeyWindow"), .{});
@@ -252,7 +286,7 @@ pub const Window = struct {
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,
     /// or no mins.
-    pub fn setSizeLimits(self: *Window, min: apprt.WindowSize, max_: ?apprt.WindowSize) !void {
+    pub fn setSizeLimits(self: *Surface, min: apprt.WindowSize, max_: ?apprt.WindowSize) !void {
         self.window.setSizeLimits(.{
             .width = min.width,
             .height = min.height,
@@ -266,7 +300,7 @@ pub const Window = struct {
     }
 
     /// Returns the content scale for the created window.
-    pub fn getContentScale(self: *const Window) !apprt.ContentScale {
+    pub fn getContentScale(self: *const Surface) !apprt.ContentScale {
         const scale = self.window.getContentScale();
         return apprt.ContentScale{ .x = scale.x_scale, .y = scale.y_scale };
     }
@@ -274,14 +308,14 @@ pub const Window = struct {
     /// Returns the size of the window in pixels. The pixel size may
     /// not match screen coordinate size but we should be able to convert
     /// back and forth using getContentScale.
-    pub fn getSize(self: *const Window) !apprt.WindowSize {
+    pub fn getSize(self: *const Surface) !apprt.WindowSize {
         const size = self.window.getFramebufferSize();
         return apprt.WindowSize{ .width = size.width, .height = size.height };
     }
 
     /// Returns the cursor position in scaled pixels relative to the
     /// upper-left of the window.
-    pub fn getCursorPos(self: *const Window) !apprt.CursorPos {
+    pub fn getCursorPos(self: *const Surface) !apprt.CursorPos {
         const unscaled_pos = self.window.getCursorPos();
         const pos = try self.cursorPosToPixels(unscaled_pos);
         return apprt.CursorPos{
@@ -292,37 +326,37 @@ pub const Window = struct {
 
     /// Set the flag that notes this window should be closed for the next
     /// iteration of the event loop.
-    pub fn setShouldClose(self: *Window) void {
+    pub fn setShouldClose(self: *Surface) void {
         self.window.setShouldClose(true);
     }
 
     /// Returns true if the window is flagged to close.
-    pub fn shouldClose(self: *const Window) bool {
+    pub fn shouldClose(self: *const Surface) bool {
         return self.window.shouldClose();
     }
 
     /// Set the title of the window.
-    pub fn setTitle(self: *Window, slice: [:0]const u8) !void {
+    pub fn setTitle(self: *Surface, slice: [:0]const u8) !void {
         self.window.setTitle(slice.ptr);
     }
 
     /// Read the clipboard. The windowing system is responsible for allocating
     /// a buffer as necessary. This should be a stable pointer until the next
     /// time getClipboardString is called.
-    pub fn getClipboardString(self: *const Window) ![:0]const u8 {
+    pub fn getClipboardString(self: *const Surface) ![:0]const u8 {
         _ = self;
         return glfw.getClipboardString() orelse return glfw.mustGetErrorCode();
     }
 
     /// Set the clipboard.
-    pub fn setClipboardString(self: *const Window, val: [:0]const u8) !void {
+    pub fn setClipboardString(self: *const Surface, val: [:0]const u8) !void {
         _ = self;
         glfw.setClipboardString(val);
     }
 
     /// The cursor position from glfw directly is in screen coordinates but
     /// all our interface works in pixels.
-    fn cursorPosToPixels(self: *const Window, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {
+    fn cursorPosToPixels(self: *const Surface, pos: glfw.Window.CursorPos) !glfw.Window.CursorPos {
         // The cursor position is in screen coordinates but we
         // want it in pixels. we need to get both the size of the
         // window in both to get the ratio to make the conversion.
@@ -349,8 +383,8 @@ pub const Window = struct {
         // Get the size. We are given a width/height but this is in screen
         // coordinates and we want raw pixels. The core window uses the content
         // scale to scale appropriately.
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
-        const size = core_win.window.getSize() catch |err| {
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
+        const size = core_win.rt_surface.getSize() catch |err| {
             log.err("error querying window size for size callback err={}", .{err});
             return;
         };
@@ -366,7 +400,7 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.charCallback(codepoint) catch |err| {
             log.err("error in char callback err={}", .{err});
             return;
@@ -518,7 +552,7 @@ pub const Window = struct {
             => .invalid,
         };
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.keyCallback(action, key, mods) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
@@ -529,7 +563,7 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.focusCallback(focused) catch |err| {
             log.err("error in focus callback err={}", .{err});
             return;
@@ -540,7 +574,7 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.refreshCallback() catch |err| {
             log.err("error in refresh callback err={}", .{err});
             return;
@@ -551,7 +585,7 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.scrollCallback(xoff, yoff) catch |err| {
             log.err("error in scroll callback err={}", .{err});
             return;
@@ -566,10 +600,10 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert our unscaled x/y to scaled.
-        const pos = core_win.window.cursorPosToPixels(.{
+        const pos = core_win.rt_surface.cursorPosToPixels(.{
             .xpos = unscaled_xpos,
             .ypos = unscaled_ypos,
         }) catch |err| {
@@ -598,7 +632,7 @@ pub const Window = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
-        const core_win = window.getUserPointer(CoreWindow) orelse return;
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
         const mods = @bitCast(input.Mods, glfw_mods);

commit 913131c8f1bce61008d5e95eab933ef848a93054
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 14:52:38 2023 -0800

    rename more stuff

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 2150711d..beb56062 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -83,6 +83,7 @@ pub const App = struct {
 
         // Create the surface -- because windows are surfaces for glfw.
         try surface.init(self);
+        errdefer surface.deinit();
     }
 
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
@@ -232,12 +233,15 @@ pub const Surface = struct {
 
         // Initialize our surface now that we have the stable pointer.
         try self.core_surface.init(app.app, app.app.config, self);
-        errdefer self.core_surface.destroy();
+        errdefer self.core_surface.deinit();
     }
 
     pub fn deinit(self: *Surface) void {
-        var tabgroup_opt: if (builtin.target.isDarwin()) ?objc.Object else void = undefined;
-        if (comptime builtin.target.isDarwin()) {
+        // First clean up our core surface so that all the rendering and IO stop.
+        self.core_surface.deinit();
+
+        var tabgroup_opt: if (App.Darwin.enabled) ?objc.Object else void = undefined;
+        if (App.Darwin.enabled) {
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(self.window).?);
             const tabgroup = nswindow.getProperty(objc.Object, "tabGroup");
 
@@ -286,7 +290,7 @@ pub const Surface = struct {
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,
     /// or no mins.
-    pub fn setSizeLimits(self: *Surface, min: apprt.WindowSize, max_: ?apprt.WindowSize) !void {
+    pub fn setSizeLimits(self: *Surface, min: apprt.SurfaceSize, max_: ?apprt.SurfaceSize) !void {
         self.window.setSizeLimits(.{
             .width = min.width,
             .height = min.height,
@@ -308,9 +312,9 @@ pub const Surface = struct {
     /// Returns the size of the window in pixels. The pixel size may
     /// not match screen coordinate size but we should be able to convert
     /// back and forth using getContentScale.
-    pub fn getSize(self: *const Surface) !apprt.WindowSize {
+    pub fn getSize(self: *const Surface) !apprt.SurfaceSize {
         const size = self.window.getFramebufferSize();
-        return apprt.WindowSize{ .width = size.width, .height = size.height };
+        return apprt.SurfaceSize{ .width = size.width, .height = size.height };
     }
 
     /// Returns the cursor position in scaled pixels relative to the

commit 9e4560043a58199ff6d4fd2702c85b7a3a0aa81e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 14:58:20 2023 -0800

    fix crashes on close

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index beb56062..0aa2b5f4 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -86,6 +86,12 @@ pub const App = struct {
         errdefer surface.deinit();
     }
 
+    /// Close the given surface.
+    pub fn closeSurface(self: *App, surface: *Surface) void {
+        surface.deinit();
+        self.app.surface_pool.destroy(surface);
+    }
+
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
         std.log.warn("glfw error={} message={s}", .{ code, desc });
 
@@ -237,7 +243,10 @@ pub const Surface = struct {
     }
 
     pub fn deinit(self: *Surface) void {
-        // First clean up our core surface so that all the rendering and IO stop.
+        // Remove ourselves from the list of known surfaces in the app.
+        self.core_surface.app.deleteSurface(self);
+
+        // Clean up our core surface so that all the rendering and IO stop.
         self.core_surface.deinit();
 
         var tabgroup_opt: if (App.Darwin.enabled) ?objc.Object else void = undefined;

commit 053748481aed950536692f4a2e2b5e86a3391489
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 15:16:17 2023 -0800

    more crap

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0aa2b5f4..23c8bd42 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -76,7 +76,7 @@ pub const App = struct {
     }
 
     /// Create a new window for the app.
-    pub fn newWindow(self: *App) !void {
+    pub fn newWindow(self: *App) !*Surface {
         // Grab a surface allocation because we're going to need it.
         const surface = try self.app.surface_pool.create();
         errdefer self.app.surface_pool.destroy(surface);
@@ -84,6 +84,42 @@ pub const App = struct {
         // Create the surface -- because windows are surfaces for glfw.
         try surface.init(self);
         errdefer surface.deinit();
+
+        return surface;
+    }
+
+    /// Create a new tab in the parent surface.
+    pub fn newTab(self: *App, parent: *CoreSurface) !void {
+        if (!Darwin.enabled) {
+            log.warn("tabbing is not supported on this platform", .{});
+            return;
+        }
+
+        // Create the new window
+        const window = try self.newWindow();
+
+        // Add the new window the parent window
+        const parent_win = glfwNative.getCocoaWindow(parent.rt_surface.window).?;
+        const other_win = glfwNative.getCocoaWindow(window.window).?;
+        const NSWindowOrderingMode = enum(isize) { below = -1, out = 0, above = 1 };
+        const nswindow = objc.Object.fromId(parent_win);
+        nswindow.msgSend(void, objc.sel("addTabbedWindow:ordered:"), .{
+            objc.Object.fromId(other_win),
+            NSWindowOrderingMode.above,
+        });
+
+        // Adding a new tab can cause the tab bar to appear which changes
+        // our viewport size. We need to call the size callback in order to
+        // update values. For example, we need this to set the proper mouse selection
+        // point in the grid.
+        const size = parent.rt_surface.getSize() catch |err| {
+            log.err("error querying window size for size callback on new tab err={}", .{err});
+            return;
+        };
+        parent.sizeCallback(size) catch |err| {
+            log.err("error in size callback from new tab err={}", .{err});
+            return;
+        };
     }
 
     /// Close the given surface.

commit 8c18e1ee48b9e1ff2ad114051b8ebfd309dcaacc
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 15:32:30 2023 -0800

    remove memory pool usage for mac

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 23c8bd42..560d7fd0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -78,8 +78,8 @@ pub const App = struct {
     /// Create a new window for the app.
     pub fn newWindow(self: *App) !*Surface {
         // Grab a surface allocation because we're going to need it.
-        const surface = try self.app.surface_pool.create();
-        errdefer self.app.surface_pool.destroy(surface);
+        var surface = try self.app.alloc.create(Surface);
+        errdefer self.app.alloc.destroy(surface);
 
         // Create the surface -- because windows are surfaces for glfw.
         try surface.init(self);
@@ -125,7 +125,7 @@ pub const App = struct {
     /// Close the given surface.
     pub fn closeSurface(self: *App, surface: *Surface) void {
         surface.deinit();
-        self.app.surface_pool.destroy(surface);
+        self.app.alloc.destroy(surface);
     }
 
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {

commit ac772c2d2d1c54534d156abca21074ce016d7516
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 19:31:12 2023 -0800

    inherit font size works again

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 560d7fd0..8fa6a6b0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -89,10 +89,10 @@ pub const App = struct {
     }
 
     /// Create a new tab in the parent surface.
-    pub fn newTab(self: *App, parent: *CoreSurface) !void {
+    pub fn newTab(self: *App, parent: *CoreSurface) !*Surface {
         if (!Darwin.enabled) {
             log.warn("tabbing is not supported on this platform", .{});
-            return;
+            return error.TabbingNotSupported;
         }
 
         // Create the new window
@@ -120,6 +120,8 @@ pub const App = struct {
             log.err("error in size callback from new tab err={}", .{err});
             return;
         };
+
+        return window;
     }
 
     /// Close the given surface.

commit 705d56d18e362f7402b220cb8a9c6a826719907a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Feb 22 20:08:48 2023 -0800

    surface no longer has reference to app

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8fa6a6b0..59c79dfa 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -43,9 +43,6 @@ pub const App = struct {
         var darwin = if (Darwin.enabled) try Darwin.init() else {};
         errdefer if (Darwin.enabled) darwin.deinit();
 
-        // Set our callback for being woken up
-        core_app.wakeup_cb = wakeup;
-
         return .{
             .app = core_app,
             .darwin = darwin,
@@ -71,7 +68,8 @@ pub const App = struct {
     }
 
     /// Wakeup the event loop. This should be able to be called from any thread.
-    pub fn wakeup() void {
+    pub fn wakeup(self: *const App) void {
+        _ = self;
         glfw.postEmptyEvent();
     }
 
@@ -114,11 +112,11 @@ pub const App = struct {
         // point in the grid.
         const size = parent.rt_surface.getSize() catch |err| {
             log.err("error querying window size for size callback on new tab err={}", .{err});
-            return;
+            return window;
         };
         parent.sizeCallback(size) catch |err| {
             log.err("error in size callback from new tab err={}", .{err});
-            return;
+            return window;
         };
 
         return window;
@@ -193,6 +191,9 @@ pub const Surface = struct {
     /// The glfw mouse cursor handle.
     cursor: glfw.Cursor,
 
+    /// The app we're part of
+    app: *App,
+
     /// A core surface
     core_surface: CoreSurface,
 
@@ -265,6 +266,7 @@ pub const Surface = struct {
 
         // Build our result
         self.* = .{
+            .app = app,
             .window = win,
             .cursor = cursor,
             .core_surface = undefined,
@@ -276,13 +278,18 @@ pub const Surface = struct {
         errdefer app.app.deleteSurface(self);
 
         // Initialize our surface now that we have the stable pointer.
-        try self.core_surface.init(app.app, app.app.config, self);
+        try self.core_surface.init(
+            app.app.alloc,
+            app.app.config,
+            .{ .rt_app = app, .mailbox = &app.app.mailbox },
+            self,
+        );
         errdefer self.core_surface.deinit();
     }
 
     pub fn deinit(self: *Surface) void {
         // Remove ourselves from the list of known surfaces in the app.
-        self.core_surface.app.deleteSurface(self);
+        self.app.app.deleteSurface(self);
 
         // Clean up our core surface so that all the rendering and IO stop.
         self.core_surface.deinit();

commit fb13838532fed17ad0695728c776e4f2aefec32a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 08:44:01 2023 -0800

    apprt newWindow/newTab do not have to return a surface

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 59c79dfa..3faab933 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -74,27 +74,19 @@ pub const App = struct {
     }
 
     /// Create a new window for the app.
-    pub fn newWindow(self: *App) !*Surface {
-        // Grab a surface allocation because we're going to need it.
-        var surface = try self.app.alloc.create(Surface);
-        errdefer self.app.alloc.destroy(surface);
-
-        // Create the surface -- because windows are surfaces for glfw.
-        try surface.init(self);
-        errdefer surface.deinit();
-
-        return surface;
+    pub fn newWindow(self: *App, parent_: ?*CoreSurface) !void {
+        _ = try self.newSurface(parent_);
     }
 
     /// Create a new tab in the parent surface.
-    pub fn newTab(self: *App, parent: *CoreSurface) !*Surface {
+    pub fn newTab(self: *App, parent: *CoreSurface) !void {
         if (!Darwin.enabled) {
             log.warn("tabbing is not supported on this platform", .{});
-            return error.TabbingNotSupported;
+            return;
         }
 
         // Create the new window
-        const window = try self.newWindow();
+        const window = try self.newWindow(parent);
 
         // Add the new window the parent window
         const parent_win = glfwNative.getCocoaWindow(parent.rt_surface.window).?;
@@ -112,14 +104,31 @@ pub const App = struct {
         // point in the grid.
         const size = parent.rt_surface.getSize() catch |err| {
             log.err("error querying window size for size callback on new tab err={}", .{err});
-            return window;
+            return;
         };
         parent.sizeCallback(size) catch |err| {
             log.err("error in size callback from new tab err={}", .{err});
-            return window;
+            return;
         };
+    }
 
-        return window;
+    fn newSurface(self: *App, parent_: ?*CoreSurface) !*Surface {
+        // Grab a surface allocation because we're going to need it.
+        var surface = try self.app.alloc.create(Surface);
+        errdefer self.app.alloc.destroy(surface);
+
+        // Create the surface -- because windows are surfaces for glfw.
+        try surface.init(self);
+        errdefer surface.deinit();
+
+        // If we have a parent, inherit some properties
+        if (self.app.config.@"window-inherit-font-size") {
+            if (parent_) |parent| {
+                surface.core_surface.setFontSize(parent.font_size);
+            }
+        }
+
+        return surface;
     }
 
     /// Close the given surface.

commit 7991e6e495a3350330b304f63918d54cabf13103
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 08:46:52 2023 -0800

    apprt/glfw: fix macos build

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 3faab933..6ba10656 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -86,7 +86,7 @@ pub const App = struct {
         }
 
         // Create the new window
-        const window = try self.newWindow(parent);
+        const window = try self.newSurface(parent);
 
         // Add the new window the parent window
         const parent_win = glfwNative.getCocoaWindow(parent.rt_surface.window).?;

commit 6acf67ec662c124a11debdf0669b822f84b1508b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 23 11:19:51 2023 -0800

    gtk: render!

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 6ba10656..dbdb925d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -137,6 +137,13 @@ pub const App = struct {
         self.app.alloc.destroy(surface);
     }
 
+    pub fn redrawSurface(self: *App, surface: *Surface) void {
+        _ = self;
+        _ = surface;
+
+        @panic("This should never be called for GLFW.");
+    }
+
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
         std.log.warn("glfw error={} message={s}", .{ code, desc });
 

commit 7a0411d65a29660da6ebd7697bd2342b5b637b35
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Feb 25 10:38:19 2023 -0800

    apprt: move newTab to a surface callback rather than app

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index dbdb925d..31c117c3 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -79,7 +79,7 @@ pub const App = struct {
     }
 
     /// Create a new tab in the parent surface.
-    pub fn newTab(self: *App, parent: *CoreSurface) !void {
+    fn newTab(self: *App, parent: *CoreSurface) !void {
         if (!Darwin.enabled) {
             log.warn("tabbing is not supported on this platform", .{});
             return;
@@ -356,6 +356,11 @@ pub const Surface = struct {
         }
     }
 
+    /// Create a new tab in the window containing this surface.
+    pub fn newTab(self: *Surface) !void {
+        try self.app.newTab(&self.core_surface);
+    }
+
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,

commit b4d8419feb8b0fd9d094fe14f0583d93fb67151e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 1 17:04:45 2023 -0800

    screen: trim trailing no-character cells when rows is changing
    
    This matches Terminal.app, and makes it so the `ESC [ J` doesn't
    generate scrollback on rows change.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 31c117c3..892c1ed0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -59,6 +59,13 @@ pub const App = struct {
         while (true) {
             // Wait for any events from the app event loop. wakeup will post
             // an empty event so that this will return.
+            //
+            // Warning: a known issue on macOS is that this will block while
+            // a resize event is actively happening, which will prevent the
+            // app tick from happening. I don't know know a way around this
+            // but its not a big deal since we don't use glfw for the official
+            // mac app, but noting it in case anyone builds for macos using
+            // glfw.
             glfw.waitEvents();
 
             // Tick the terminal app

commit 58d89b6bb3a44d352f65440a3b8086f81a7b738e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 12 17:27:33 2023 -0700

    apprt/glfw: add logging with error information when glfw init fails

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 892c1ed0..53388734 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -36,7 +36,17 @@ pub const App = struct {
     pub const Options = struct {};
 
     pub fn init(core_app: *CoreApp, _: Options) !App {
-        if (!glfw.init(.{})) return error.GlfwInitFailed;
+        if (!glfw.init(.{})) {
+            if (glfw.getError()) |err| {
+                log.err("error initializing GLFW err={} msg={s}", .{
+                    err.error_code,
+                    err.description,
+                });
+                return err.error_code;
+            }
+
+            return error.GlfwInitFailedUnknownReason;
+        }
         glfw.setErrorCallback(glfwErrorCallback);
 
         // Mac-specific state. For example, on Mac we enable window tabbing.

commit 00c837e0d2a48545803d5b2729af718c36d3a3f8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 18 19:25:54 2023 -0700

    apprt: all implement close surface

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 53388734..1995f03c 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -378,6 +378,11 @@ pub const Surface = struct {
         try self.app.newTab(&self.core_surface);
     }
 
+    /// Close this surface.
+    pub fn close(self: *const Surface) void {
+        self.window.setShouldClose(true);
+    }
+
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,

commit 3e1f975551c2258b82dbc4bb747fef3a5d5d1910
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 21:44:45 2023 -0700

    move config loading into apprt to prep for reloading

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 1995f03c..c8603160 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -19,6 +19,7 @@ const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
 const CoreSurface = @import("../Surface.zig");
+const Config = @import("../config.zig").Config;
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
@@ -29,6 +30,7 @@ const log = std.log.scoped(.glfw);
 
 pub const App = struct {
     app: *CoreApp,
+    config: Config,
 
     /// Mac-specific state.
     darwin: if (Darwin.enabled) Darwin else void,
@@ -53,14 +55,19 @@ pub const App = struct {
         var darwin = if (Darwin.enabled) try Darwin.init() else {};
         errdefer if (Darwin.enabled) darwin.deinit();
 
+        // Load our configuration
+        var config = try Config.load(core_app.alloc);
+        errdefer config.deinit();
+
         return .{
             .app = core_app,
+            .config = config,
             .darwin = darwin,
         };
     }
 
-    pub fn terminate(self: App) void {
-        _ = self;
+    pub fn terminate(self: *App) void {
+        self.config.deinit();
         glfw.terminate();
     }
 
@@ -139,7 +146,7 @@ pub const App = struct {
         errdefer surface.deinit();
 
         // If we have a parent, inherit some properties
-        if (self.app.config.@"window-inherit-font-size") {
+        if (self.config.@"window-inherit-font-size") {
             if (parent_) |parent| {
                 surface.core_surface.setFontSize(parent.font_size);
             }
@@ -313,7 +320,7 @@ pub const Surface = struct {
         // Initialize our surface now that we have the stable pointer.
         try self.core_surface.init(
             app.app.alloc,
-            app.app.config,
+            &app.config,
             .{ .rt_app = app, .mailbox = &app.app.mailbox },
             self,
         );

commit a9928cfb90a70bb5a24aca2b9193a1c4c38d8d76
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 13 21:52:42 2023 -0700

    implement reload_config app message

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c8603160..dfe758bf 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -20,6 +20,7 @@ const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
 const CoreSurface = @import("../Surface.zig");
 const Config = @import("../config.zig").Config;
+const DevMode = @import("../DevMode.zig");
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
@@ -59,6 +60,11 @@ pub const App = struct {
         var config = try Config.load(core_app.alloc);
         errdefer config.deinit();
 
+        // If we have DevMode on, store the config so we can show it. This
+        // is messy because we're copying a thing here. We should clean this
+        // up when we take a pass at cleaning up the dev mode.
+        if (DevMode.enabled) DevMode.instance.config = config;
+
         return .{
             .app = core_app,
             .config = config,
@@ -97,6 +103,23 @@ pub const App = struct {
         glfw.postEmptyEvent();
     }
 
+    /// Reload the configuration. This should return the new configuration.
+    /// The old value can be freed immediately at this point assuming a
+    /// successful return.
+    ///
+    /// The returned pointer value is only valid for a stable self pointer.
+    pub fn reloadConfig(self: *App) !?*const Config {
+        // Load our configuration
+        var config = try Config.load(self.app.alloc);
+        errdefer config.deinit();
+
+        // Update the existing config, be sure to clean up the old one.
+        self.config.deinit();
+        self.config = config;
+
+        return &self.config;
+    }
+
     /// Create a new window for the app.
     pub fn newWindow(self: *App, parent_: ?*CoreSurface) !void {
         _ = try self.newSurface(parent_);

commit 67d3507f9a80a5eb821ebb5f0eb858cdaa0ceb11
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 25 15:40:49 2023 -0700

    apprt/glfw: new keycallback for unmapped

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index dfe758bf..a71399cd 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -683,8 +683,10 @@ pub const Surface = struct {
             => .invalid,
         };
 
+        // TODO: we need to do mapped keybindings
+
         const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.keyCallback(action, key, mods) catch |err| {
+        core_win.keyCallback(action, key, key, mods) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };

commit 3689f1fe390ad14651d3cc96042339b7c47cd3cb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Mar 25 16:36:12 2023 -0700

    apprt/gtk: only show exit confirmation if process is alive

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index dfe758bf..034ed31c 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -409,8 +409,11 @@ pub const Surface = struct {
     }
 
     /// Close this surface.
-    pub fn close(self: *const Surface) void {
-        self.window.setShouldClose(true);
+    pub fn close(self: *Surface, processActive: bool) void {
+        _ = processActive;
+        self.setShouldClose();
+        self.deinit();
+        self.app.app.alloc.destroy(self);
     }
 
     /// Set the size limits of the window.

commit 4d41b3ff54a9815583d5c9c73efa723e9613387e
Merge: a534f5c5 8fa5a9d2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Mar 26 10:59:09 2023 -0700

    Merge pull request #134 from mitchellh/gtk-confirm
    
    gtk, macos: show confirmation dialog on surface close with active child process


commit f5269df68f8250e5f4fc8b879553f24f54455cca
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Mar 27 10:47:54 2023 -0700

    apprt/glfw: quit cleans up resources properly

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a3e43b15..d8da8264 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -93,7 +93,13 @@ pub const App = struct {
 
             // Tick the terminal app
             const should_quit = try self.app.tick(self);
-            if (should_quit) return;
+            if (should_quit) {
+                for (self.app.surfaces.items) |surface| {
+                    surface.close(false);
+                }
+
+                return;
+            }
         }
     }
 

commit 0fca74c0897ccd58db369cb030222631c81c8324
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 19:18:55 2023 -0700

    apprt/glfw: inherit working dir

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index d8da8264..b65573a0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -346,10 +346,25 @@ pub const Surface = struct {
         try app.app.addSurface(self);
         errdefer app.app.deleteSurface(self);
 
+        // Our parent pwd will be tracked here
+        const alloc = app.app.alloc;
+        var parent_pwd: ?[]const u8 = null;
+        defer if (parent_pwd) |v| alloc.free(v);
+
+        // Shallow copy the config so that we can modify it.
+        var config = app.config;
+
+        // Get our previously focused surface
+        const parent = app.app.focusedSurface();
+        if (parent) |p| {
+            parent_pwd = try p.pwd(alloc);
+            if (parent_pwd) |v| config.@"working-directory" = v;
+        }
+
         // Initialize our surface now that we have the stable pointer.
         try self.core_surface.init(
-            app.app.alloc,
-            &app.config,
+            alloc,
+            &config,
             .{ .rt_app = app, .mailbox = &app.app.mailbox },
             self,
         );

commit f31d6fb8fe64ba52d5adde20a17c6709abe7d0c8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed May 31 21:08:50 2023 -0700

    apprt: clean up how apprt initializes surfaces

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index b65573a0..822437b5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -346,24 +346,13 @@ pub const Surface = struct {
         try app.app.addSurface(self);
         errdefer app.app.deleteSurface(self);
 
-        // Our parent pwd will be tracked here
-        const alloc = app.app.alloc;
-        var parent_pwd: ?[]const u8 = null;
-        defer if (parent_pwd) |v| alloc.free(v);
-
-        // Shallow copy the config so that we can modify it.
-        var config = app.config;
-
-        // Get our previously focused surface
-        const parent = app.app.focusedSurface();
-        if (parent) |p| {
-            parent_pwd = try p.pwd(alloc);
-            if (parent_pwd) |v| config.@"working-directory" = v;
-        }
+        // Get our new surface config
+        var config = try apprt.surface.newConfig(app.app, &app.config);
+        defer config.deinit();
 
         // Initialize our surface now that we have the stable pointer.
         try self.core_surface.init(
-            alloc,
+            app.app.alloc,
             &config,
             .{ .rt_app = app, .mailbox = &app.app.mailbox },
             self,

commit 56f8e39e5bc4f7c96a5f5c661604d6a10390875f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 25 11:08:12 2023 -0700

    Update zig, mach, fmt

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 822437b5..619df6a9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -291,8 +291,8 @@ pub const Surface = struct {
             };
             const physical_size = monitor.getPhysicalSize();
             const video_mode = monitor.getVideoMode() orelse return glfw.mustGetErrorCode();
-            const physical_x_dpi = @intToFloat(f32, video_mode.getWidth()) / (@intToFloat(f32, physical_size.width_mm) / 25.4);
-            const physical_y_dpi = @intToFloat(f32, video_mode.getHeight()) / (@intToFloat(f32, physical_size.height_mm) / 25.4);
+            const physical_x_dpi = @floatFromInt(f32, video_mode.getWidth()) / (@floatFromInt(f32, physical_size.width_mm) / 25.4);
+            const physical_y_dpi = @floatFromInt(f32, video_mode.getHeight()) / (@floatFromInt(f32, physical_size.height_mm) / 25.4);
             log.debug("physical dpi x={} y={}", .{
                 physical_x_dpi,
                 physical_y_dpi,
@@ -512,8 +512,8 @@ pub const Surface = struct {
         if (fb_size.width == size.width and fb_size.height == size.height)
             return pos;
 
-        const x_scale = @intToFloat(f64, fb_size.width) / @intToFloat(f64, size.width);
-        const y_scale = @intToFloat(f64, fb_size.height) / @intToFloat(f64, size.height);
+        const x_scale = @floatFromInt(f64, fb_size.width) / @floatFromInt(f64, size.width);
+        const y_scale = @floatFromInt(f64, fb_size.height) / @floatFromInt(f64, size.height);
         return .{
             .xpos = pos.xpos * x_scale,
             .ypos = pos.ypos * y_scale,

commit 68631a1ccde79cbe7e713b1a0e07551351cfa7bd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jun 29 10:41:42 2023 -0700

    apprt: plumb through scroll mods to core, don't handle them yet

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 619df6a9..ad90b436 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -731,8 +731,11 @@ pub const Surface = struct {
         const tracy = trace(@src());
         defer tracy.end();
 
+        // Glfw doesn't support any of the scroll mods.
+        const scroll_mods: input.ScrollMods = .{};
+
         const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.scrollCallback(xoff, yoff) catch |err| {
+        core_win.scrollCallback(xoff, yoff, scroll_mods) catch |err| {
             log.err("error in scroll callback err={}", .{err});
             return;
         };

commit 314f9287b1854911e38d030ad6ec42bb6cd0a105
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Jun 30 12:15:31 2023 -0700

    Update Zig (#164)
    
    * update zig
    
    * pkg/fontconfig: clean up @as
    
    * pkg/freetype,harfbuzz: clean up @as
    
    * pkg/imgui: clean up @as
    
    * pkg/macos: clean up @as
    
    * pkg/pixman,utf8proc: clean up @as
    
    * clean up @as
    
    * lots more @as cleanup
    
    * undo flatpak changes
    
    * clean up @as

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index ad90b436..47bf9c42 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -291,8 +291,8 @@ pub const Surface = struct {
             };
             const physical_size = monitor.getPhysicalSize();
             const video_mode = monitor.getVideoMode() orelse return glfw.mustGetErrorCode();
-            const physical_x_dpi = @floatFromInt(f32, video_mode.getWidth()) / (@floatFromInt(f32, physical_size.width_mm) / 25.4);
-            const physical_y_dpi = @floatFromInt(f32, video_mode.getHeight()) / (@floatFromInt(f32, physical_size.height_mm) / 25.4);
+            const physical_x_dpi = @as(f32, @floatFromInt(video_mode.getWidth())) / (@as(f32, @floatFromInt(physical_size.width_mm)) / 25.4);
+            const physical_y_dpi = @as(f32, @floatFromInt(video_mode.getHeight())) / (@as(f32, @floatFromInt(physical_size.height_mm)) / 25.4);
             log.debug("physical dpi x={} y={}", .{
                 physical_x_dpi,
                 physical_y_dpi,
@@ -463,8 +463,8 @@ pub const Surface = struct {
         const unscaled_pos = self.window.getCursorPos();
         const pos = try self.cursorPosToPixels(unscaled_pos);
         return apprt.CursorPos{
-            .x = @floatCast(f32, pos.xpos),
-            .y = @floatCast(f32, pos.ypos),
+            .x = @floatCast(pos.xpos),
+            .y = @floatCast(pos.ypos),
         };
     }
 
@@ -512,8 +512,8 @@ pub const Surface = struct {
         if (fb_size.width == size.width and fb_size.height == size.height)
             return pos;
 
-        const x_scale = @floatFromInt(f64, fb_size.width) / @floatFromInt(f64, size.width);
-        const y_scale = @floatFromInt(f64, fb_size.height) / @floatFromInt(f64, size.height);
+        const x_scale = @as(f64, @floatFromInt(fb_size.width)) / @as(f64, @floatFromInt(size.width));
+        const y_scale = @as(f64, @floatFromInt(fb_size.height)) / @as(f64, @floatFromInt(size.height));
         return .{
             .xpos = pos.xpos * x_scale,
             .ypos = pos.ypos * y_scale,
@@ -564,7 +564,7 @@ pub const Surface = struct {
         defer tracy.end();
 
         // Convert our glfw types into our input types
-        const mods = @bitCast(input.Mods, glfw_mods);
+        const mods: input.Mods = @bitCast(glfw_mods);
         const action: input.Action = switch (glfw_action) {
             .release => .release,
             .press => .press,
@@ -764,8 +764,8 @@ pub const Surface = struct {
         };
 
         core_win.cursorPosCallback(.{
-            .x = @floatCast(f32, pos.xpos),
-            .y = @floatCast(f32, pos.ypos),
+            .x = @floatCast(pos.xpos),
+            .y = @floatCast(pos.ypos),
         }) catch |err| {
             log.err("error in cursor pos callback err={}", .{err});
             return;
@@ -784,7 +784,7 @@ pub const Surface = struct {
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
-        const mods = @bitCast(input.Mods, glfw_mods);
+        const mods: input.Mods = @bitCast(glfw_mods);
         const button: input.MouseButton = switch (glfw_button) {
             .left => .left,
             .right => .right,

commit 017da411f8935c6b249ff2d2b9f4fb89751854c3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Jul 3 17:59:50 2023 -0700

    metal: start setting up background transparency

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 47bf9c42..4863e551 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -278,7 +278,7 @@ pub const Surface = struct {
             "ghostty",
             null,
             null,
-            Renderer.glfwWindowHints(),
+            Renderer.glfwWindowHints(&app.config),
         ) orelse return glfw.mustGetErrorCode();
         errdefer win.destroy();
 

commit 67cbabd605b064100c1588d0ec63fafa1764186c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 14:33:56 2023 -0700

    make keyboard modifiers left/right-aware throughout core

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4863e551..c3cb6d68 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -564,7 +564,7 @@ pub const Surface = struct {
         defer tracy.end();
 
         // Convert our glfw types into our input types
-        const mods: input.Mods = @bitCast(glfw_mods);
+        const mods = convertMods(glfw_mods);
         const action: input.Action = switch (glfw_action) {
             .release => .release,
             .press => .press,
@@ -784,7 +784,7 @@ pub const Surface = struct {
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
-        const mods: input.Mods = @bitCast(glfw_mods);
+        const mods = convertMods(glfw_mods);
         const button: input.MouseButton = switch (glfw_button) {
             .left => .left,
             .right => .right,
@@ -806,4 +806,15 @@ pub const Surface = struct {
             return;
         };
     }
+
+    fn convertMods(mods: glfw.Mods) input.Mods {
+        return .{
+            .shift = if (mods.shift) .both else .none,
+            .ctrl = if (mods.control) .both else .none,
+            .alt = if (mods.alt) .both else .none,
+            .super = if (mods.super) .both else .none,
+            .caps_lock = mods.caps_lock,
+            .num_lock = mods.num_lock,
+        };
+    }
 };

commit 22296b377a9336114c56a92fe82653b63328a646
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 17:06:40 2023 -0700

    Revert "Merge pull request #244 from mitchellh/alt-as-esc"
    
    This reverts commit c139279d479682c17f63d9b57c2d56608d09d16a, reversing
    changes made to 4ed21047a734d7c586debe0026e3b6ea90ed1622.
    
    We do want to do this but this broke bindings.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c3cb6d68..4863e551 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -564,7 +564,7 @@ pub const Surface = struct {
         defer tracy.end();
 
         // Convert our glfw types into our input types
-        const mods = convertMods(glfw_mods);
+        const mods: input.Mods = @bitCast(glfw_mods);
         const action: input.Action = switch (glfw_action) {
             .release => .release,
             .press => .press,
@@ -784,7 +784,7 @@ pub const Surface = struct {
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
-        const mods = convertMods(glfw_mods);
+        const mods: input.Mods = @bitCast(glfw_mods);
         const button: input.MouseButton = switch (glfw_button) {
             .left => .left,
             .right => .right,
@@ -806,15 +806,4 @@ pub const Surface = struct {
             return;
         };
     }
-
-    fn convertMods(mods: glfw.Mods) input.Mods {
-        return .{
-            .shift = if (mods.shift) .both else .none,
-            .ctrl = if (mods.control) .both else .none,
-            .alt = if (mods.alt) .both else .none,
-            .super = if (mods.super) .both else .none,
-            .caps_lock = mods.caps_lock,
-            .num_lock = mods.num_lock,
-        };
-    }
 };

commit 2e98d43a584a90d14172b631d519bad499ac8a75
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 19:28:48 2023 -0700

    apprt/glfw: launch window on startup

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c3cb6d68..1c2d3b2c 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -65,6 +65,14 @@ pub const App = struct {
         // up when we take a pass at cleaning up the dev mode.
         if (DevMode.enabled) DevMode.instance.config = config;
 
+        // Queue a single new window that starts on launch
+        _ = core_app.mailbox.push(.{
+            .new_window = .{},
+        }, .{ .forever = {} });
+
+        // We want the event loop to wake up instantly so we can process our tick.
+        glfw.postEmptyEvent();
+
         return .{
             .app = core_app,
             .config = config,

commit aff64d99516337d813ae11f32cd94952d6fe84e2
Merge: 22296b37 6d32d749
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 7 21:43:08 2023 -0700

    Merge pull request #247 from mitchellh/gtk-single-instance
    
    GTK single instance, fix UB in termio read thread termination


commit 6b45d931c341195c5dfd30b62c157f57db384437
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Aug 8 09:29:38 2023 -0700

    plumb through the resources dir to termio

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4db75f31..0cef7251 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -363,6 +363,7 @@ pub const Surface = struct {
             app.app.alloc,
             &config,
             .{ .rt_app = app, .mailbox = &app.app.mailbox },
+            app.app.resources_dir,
             self,
         );
         errdefer self.core_surface.deinit();

commit ecb9563f2a4a0f9932190b3e2bfe0e5818ca6431
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 15:14:39 2023 -0700

    apprt/glfw: warn that the macos version has bugs

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0cef7251..6dd7c431 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -39,6 +39,13 @@ pub const App = struct {
     pub const Options = struct {};
 
     pub fn init(core_app: *CoreApp, _: Options) !App {
+        if (comptime builtin.target.isDarwin()) {
+            log.warn("WARNING WARNING WARNING: GLFW ON MAC HAS BUGS.", .{});
+            log.warn("You should use the AppKit-based app instead. The official download", .{});
+            log.warn("is properly built and available from GitHub. If you're building from", .{});
+            log.warn("source, see the README for details on how to build the AppKit app.", .{});
+        }
+
         if (!glfw.init(.{})) {
             if (glfw.getError()) |err| {
                 log.err("error initializing GLFW err={} msg={s}", .{

commit ca008df73d5ecd07b3cde82844581f1bf2743901
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 14:22:17 2023 -0700

    apprt/glfw: support primary clipboard

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0cef7251..6705dc7e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -25,6 +25,7 @@ const DevMode = @import("../DevMode.zig");
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
     .cocoa = builtin.target.isDarwin(),
+    .x11 = builtin.os.tag == .linux,
 });
 
 const log = std.log.scoped(.glfw);
@@ -496,15 +497,39 @@ pub const Surface = struct {
     /// Read the clipboard. The windowing system is responsible for allocating
     /// a buffer as necessary. This should be a stable pointer until the next
     /// time getClipboardString is called.
-    pub fn getClipboardString(self: *const Surface) ![:0]const u8 {
+    pub fn getClipboardString(
+        self: *const Surface,
+        clipboard_type: apprt.Clipboard,
+    ) ![:0]const u8 {
         _ = self;
-        return glfw.getClipboardString() orelse return glfw.mustGetErrorCode();
+        return switch (clipboard_type) {
+            .standard => glfw.getClipboardString() orelse glfw.mustGetErrorCode(),
+            .selection => selection: {
+                // Not supported except on Linux
+                if (comptime builtin.os.tag != .linux) return "";
+
+                const raw = glfwNative.getX11SelectionString() orelse
+                    return glfw.mustGetErrorCode();
+                break :selection std.mem.span(raw);
+            },
+        };
     }
 
     /// Set the clipboard.
-    pub fn setClipboardString(self: *const Surface, val: [:0]const u8) !void {
+    pub fn setClipboardString(
+        self: *const Surface,
+        val: [:0]const u8,
+        clipboard_type: apprt.Clipboard,
+    ) !void {
         _ = self;
-        glfw.setClipboardString(val);
+        switch (clipboard_type) {
+            .standard => glfw.setClipboardString(val),
+            .selection => {
+                // Not supported except on Linux
+                if (comptime builtin.os.tag != .linux) return "";
+                glfwNative.setX11SelectionString(val.ptr);
+            },
+        }
     }
 
     /// The cursor position from glfw directly is in screen coordinates but

commit afc6a9976f2f8c794a8e979c2091124210db4b29
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 14:29:39 2023 -0700

    apprt/embedded: support selection clipboard

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 6705dc7e..625355ca 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -526,7 +526,7 @@ pub const Surface = struct {
             .standard => glfw.setClipboardString(val),
             .selection => {
                 // Not supported except on Linux
-                if (comptime builtin.os.tag != .linux) return "";
+                if (comptime builtin.os.tag != .linux) return;
                 glfwNative.setX11SelectionString(val.ptr);
             },
         }

commit 7b33ee6b71ac596b26570855570ac5e8a49317ef
Merge: ecb9563f 688ab846
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 9 15:14:59 2023 -0700

    Merge pull request #266 from mitchellh/primary-clipboard
    
    Primary (selection) clipboard support


commit 4fe739cae0071c442308416c1dc35668ffe66e84
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Aug 10 15:29:46 2023 -0700

    core: note when keyCallback processed the input

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 83de490d..6b0edc22 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -740,7 +740,7 @@ pub const Surface = struct {
         // TODO: we need to do mapped keybindings
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
-        core_win.keyCallback(action, key, key, mods) catch |err| {
+        _ = core_win.keyCallback(action, key, key, mods) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };

commit ce4eb2112cb014091dab73641d93b69ff013677e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 11 09:42:16 2023 -0700

    core: get rid of ignore_char, apprt must handle this now

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 6b0edc22..a5cfcc12 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -282,6 +282,10 @@ pub const Surface = struct {
     /// A core surface
     core_surface: CoreSurface,
 
+    /// This is set to true when keyCallback consumes the input, suppressing
+    /// the charCallback from being fired.
+    key_consumed: bool = false,
+
     pub const Options = struct {};
 
     /// Initialize the surface into the given self pointer. This gives a
@@ -586,6 +590,13 @@ pub const Surface = struct {
         defer tracy.end();
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
+
+        // If our keyCallback consumed the key input, don't emit a char.
+        if (core_win.rt_surface.key_consumed) {
+            core_win.rt_surface.key_consumed = false;
+            return;
+        }
+
         core_win.charCallback(codepoint) catch |err| {
             log.err("error in char callback err={}", .{err});
             return;
@@ -601,6 +612,11 @@ pub const Surface = struct {
     ) void {
         _ = scancode;
 
+        const core_win = window.getUserPointer(CoreSurface) orelse return;
+
+        // Reset our consumption state
+        core_win.rt_surface.key_consumed = false;
+
         const tracy = trace(@src());
         defer tracy.end();
 
@@ -739,8 +755,12 @@ pub const Surface = struct {
 
         // TODO: we need to do mapped keybindings
 
-        const core_win = window.getUserPointer(CoreSurface) orelse return;
-        _ = core_win.keyCallback(action, key, key, mods) catch |err| {
+        core_win.rt_surface.key_consumed = core_win.keyCallback(
+            action,
+            key,
+            key,
+            mods,
+        ) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };

commit 619d2ade3ee194551889fe6cb1ea2d28aada8cba
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 08:01:33 2023 -0700

    only initialize font discovery mechanism once, cache on App
    
    Fontconfig in particular appears unsafe to initialize multiple times.
    
    Font discovery is a singleton object in an application and only ever
    accessed from the main thread so we can work around this by only
    initializing and caching the font discovery mechanism exactly once on
    the app singleton.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a5cfcc12..9f222b2c 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -374,8 +374,8 @@ pub const Surface = struct {
         try self.core_surface.init(
             app.app.alloc,
             &config,
+            app.app,
             .{ .rt_app = app, .mailbox = &app.app.mailbox },
-            app.app.resources_dir,
             self,
         );
         errdefer self.core_surface.deinit();

commit 5e2fa50d0b9fe4d8372d4068679860bbf64a993a
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Aug 12 16:30:52 2023 -0700

    macos-option-as-alt config, handle alt-prefix for charCallback

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 9f222b2c..44467cb9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -597,7 +597,8 @@ pub const Surface = struct {
             return;
         }
 
-        core_win.charCallback(codepoint) catch |err| {
+        // TODO: mods
+        core_win.charCallback(codepoint, .{}) catch |err| {
             log.err("error in char callback err={}", .{err});
             return;
         };

commit 4a384aa27275db509b4395ccb5cd6398fb0011f4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 15:12:13 2023 -0700

    parse and respect mode 1036

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 44467cb9..195f6764 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -611,16 +611,12 @@ pub const Surface = struct {
         glfw_action: glfw.Action,
         glfw_mods: glfw.Mods,
     ) void {
+        const tracy = trace(@src());
+        defer tracy.end();
         _ = scancode;
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
-        // Reset our consumption state
-        core_win.rt_surface.key_consumed = false;
-
-        const tracy = trace(@src());
-        defer tracy.end();
-
         // Convert our glfw types into our input types
         const mods: input.Mods = @bitCast(glfw_mods);
         const action: input.Action = switch (glfw_action) {
@@ -756,6 +752,7 @@ pub const Surface = struct {
 
         // TODO: we need to do mapped keybindings
 
+        core_win.rt_surface.key_mods = mods;
         core_win.rt_surface.key_consumed = core_win.keyCallback(
             action,
             key,

commit 6fb9a113c121ec7f5623b67e6fa14fc1e67ea853
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 13 15:12:25 2023 -0700

    apprt/glfw: send mods to charcallback

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 195f6764..90d08dfb 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -285,6 +285,7 @@ pub const Surface = struct {
     /// This is set to true when keyCallback consumes the input, suppressing
     /// the charCallback from being fired.
     key_consumed: bool = false,
+    key_mods: input.Mods = .{},
 
     pub const Options = struct {};
 
@@ -597,8 +598,7 @@ pub const Surface = struct {
             return;
         }
 
-        // TODO: mods
-        core_win.charCallback(codepoint, .{}) catch |err| {
+        core_win.charCallback(codepoint, core_win.rt_surface.key_mods) catch |err| {
             log.err("error in char callback err={}", .{err});
             return;
         };

commit e7bb9c60b21a30e8142c96069b2fa2b2c8651641
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 14 12:31:16 2023 -0700

    input: expand Mods size, convert everything to use it

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 90d08dfb..bb00efaf 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -618,7 +618,12 @@ pub const Surface = struct {
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert our glfw types into our input types
-        const mods: input.Mods = @bitCast(glfw_mods);
+        const mods: input.Mods = .{
+            .shift = glfw_mods.shift,
+            .ctrl = glfw_mods.control,
+            .alt = glfw_mods.alt,
+            .super = glfw_mods.super,
+        };
         const action: input.Action = switch (glfw_action) {
             .release => .release,
             .press => .press,
@@ -843,7 +848,12 @@ pub const Surface = struct {
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
-        const mods: input.Mods = @bitCast(glfw_mods);
+        const mods: input.Mods = .{
+            .shift = glfw_mods.shift,
+            .ctrl = glfw_mods.control,
+            .alt = glfw_mods.alt,
+            .super = glfw_mods.super,
+        };
         const button: input.MouseButton = switch (glfw_button) {
             .left => .left,
             .right => .right,

commit dd385cc633df6b6d78df508e59fa709c64b5b626
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 16 13:34:31 2023 -0700

    apprt/glfw: convert to new key2callback

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index bb00efaf..37faa73d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -282,10 +282,11 @@ pub const Surface = struct {
     /// A core surface
     core_surface: CoreSurface,
 
-    /// This is set to true when keyCallback consumes the input, suppressing
-    /// the charCallback from being fired.
-    key_consumed: bool = false,
-    key_mods: input.Mods = .{},
+    /// This is the key event that was processed in keyCallback. This is only
+    /// non-null if the event was NOT consumed in keyCallback. This lets us
+    /// know in charCallback whether we should populate it and call it again.
+    /// (GLFW guarantees that charCallback is called after keyCallback).
+    key_event: ?input.KeyEvent = null,
 
     pub const Options = struct {};
 
@@ -592,14 +593,21 @@ pub const Surface = struct {
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
-        // If our keyCallback consumed the key input, don't emit a char.
-        if (core_win.rt_surface.key_consumed) {
-            core_win.rt_surface.key_consumed = false;
+        // We need a key event in order to process the charcallback. If it
+        // isn't set then the key event was consumed.
+        var key_event = core_win.rt_surface.key_event orelse return;
+        core_win.rt_surface.key_event = null;
+
+        // Populate the utf8 value for the event
+        var buf: [4]u8 = undefined;
+        const len = std.unicode.utf8Encode(codepoint, &buf) catch |err| {
+            log.err("error encoding codepoint={} err={}", .{ codepoint, err });
             return;
-        }
+        };
+        key_event.utf8 = buf[0..len];
 
-        core_win.charCallback(codepoint, core_win.rt_surface.key_mods) catch |err| {
-            log.err("error in char callback err={}", .{err});
+        _ = core_win.key2Callback(key_event) catch |err| {
+            log.err("error in key callback err={}", .{err});
             return;
         };
     }
@@ -755,18 +763,28 @@ pub const Surface = struct {
             => .invalid,
         };
 
-        // TODO: we need to do mapped keybindings
+        const key_event: input.KeyEvent = .{
+            .action = action,
+            .key = key,
+            .physical_key = key,
+            .mods = mods,
+            .consumed_mods = .{},
+            .composing = false,
+            .utf8 = "",
+        };
 
-        core_win.rt_surface.key_mods = mods;
-        core_win.rt_surface.key_consumed = core_win.keyCallback(
-            action,
-            key,
-            key,
-            mods,
-        ) catch |err| {
+        const consumed = core_win.key2Callback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };
+
+        // If it wasn't consumed, we set it on our self so that charcallback
+        // can make another attempt. Otherwise, we set null so the charcallback
+        // is ignored.
+        core_win.rt_surface.key_event = null;
+        if (!consumed and (action == .press or action == .repeat)) {
+            core_win.rt_surface.key_event = key_event;
+        }
     }
 
     fn focusCallback(window: glfw.Window, focused: bool) void {

commit 33bef288506da3459d91d0bcda2ff431ca432def
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Aug 16 13:40:57 2023 -0700

    rename key2callback to keycallback

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 37faa73d..6e823643 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -606,7 +606,7 @@ pub const Surface = struct {
         };
         key_event.utf8 = buf[0..len];
 
-        _ = core_win.key2Callback(key_event) catch |err| {
+        _ = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };
@@ -773,7 +773,7 @@ pub const Surface = struct {
             .utf8 = "",
         };
 
-        const consumed = core_win.key2Callback(key_event) catch |err| {
+        const consumed = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };

commit 72f5370066faad6df96a36d8ba80cd1ae0501225
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Aug 17 12:51:07 2023 -0700

    apprt/glfw: always say alt is consumed on macos

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 6e823643..e9706bfa 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -606,6 +606,14 @@ pub const Surface = struct {
         };
         key_event.utf8 = buf[0..len];
 
+        // On macOS we need to also disable some modifiers because
+        // alt+key consumes the alt.
+        if (comptime builtin.target.isDarwin()) {
+            // For GLFW, we say we always consume alt because
+            // GLFW doesn't have a way to disable the alt key.
+            key_event.consumed_mods.alt = true;
+        }
+
         _ = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;

commit 7ccf86b1758dc559b0a5074187a1f6813bf9c94c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Aug 20 08:50:24 2023 -0700

    remove imgui and devmode
    
    imgui has been a source of compilation challenges (our fault not theirs)
    and devmode hasn't worked in awhile, so drop it.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e9706bfa..8d96c99e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -20,7 +20,6 @@ const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
 const CoreSurface = @import("../Surface.zig");
 const Config = @import("../config.zig").Config;
-const DevMode = @import("../DevMode.zig");
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
@@ -68,11 +67,6 @@ pub const App = struct {
         var config = try Config.load(core_app.alloc);
         errdefer config.deinit();
 
-        // If we have DevMode on, store the config so we can show it. This
-        // is messy because we're copying a thing here. We should clean this
-        // up when we take a pass at cleaning up the dev mode.
-        if (DevMode.enabled) DevMode.instance.config = config;
-
         // Queue a single new window that starts on launch
         _ = core_app.mailbox.push(.{
             .new_window = .{},

commit 4ee9531ce3c0acd0d221419dc36567d4df67c727
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Sep 11 09:16:56 2023 -0700

    apprt/glfw: log configuration errors

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8d96c99e..c3c07af0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -67,6 +67,13 @@ pub const App = struct {
         var config = try Config.load(core_app.alloc);
         errdefer config.deinit();
 
+        // If we had configuration errors, then log them.
+        if (!config._errors.empty()) {
+            for (config._errors.list.items) |err| {
+                log.warn("configuration error: {s}", .{err.message});
+            }
+        }
+
         // Queue a single new window that starts on launch
         _ = core_app.mailbox.push(.{
             .new_window = .{},

commit 678bd0de0c4938e2150e1627fb75038b915f9db5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 13 08:34:09 2023 -0700

    core: surface should not use app mailbox
    
    The surface runs on the same thread as the app so if we use the app
    mailbox then we risk filling the queue before it can drain. The surface
    should use the app directly.
    
    This commit just changes all the calls to use the app directly. We may
    also want to coalesce certain changes to avoid too much CPU but I defer
    that to a future change.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c3c07af0..47b37ec9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -378,7 +378,7 @@ pub const Surface = struct {
             app.app.alloc,
             &config,
             app.app,
-            .{ .rt_app = app, .mailbox = &app.app.mailbox },
+            app,
             self,
         );
         errdefer self.core_surface.deinit();

commit 7734bab8c4ddf046fc84c4a0f076281ed893011c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 14 10:12:38 2023 -0700

    terminal: cursor shape parsing, hook up to apprt callback

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 47b37ec9..36bafb54 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -15,6 +15,7 @@ const objc = @import("objc");
 const input = @import("../input.zig");
 const internal_os = @import("../os/main.zig");
 const renderer = @import("../renderer.zig");
+const terminal = @import("../terminal/main.zig");
 const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
@@ -508,6 +509,12 @@ pub const Surface = struct {
         self.window.setTitle(slice.ptr);
     }
 
+    /// Set the shape of the cursor.
+    pub fn setCursorShape(self: *Surface, shape: terminal.CursorShape) !void {
+        _ = self;
+        _ = shape;
+    }
+
     /// Read the clipboard. The windowing system is responsible for allocating
     /// a buffer as necessary. This should be a stable pointer until the next
     /// time getClipboardString is called.

commit 31a61613e9c40c5e37850f1d4fdff295fcb64707
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 14 10:23:11 2023 -0700

    apprt/glfw: support setting cursor shape

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 36bafb54..a5686892 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -276,7 +276,7 @@ pub const Surface = struct {
     window: glfw.Window,
 
     /// The glfw mouse cursor handle.
-    cursor: glfw.Cursor,
+    cursor: ?glfw.Cursor,
 
     /// The app we're part of
     app: *App,
@@ -336,16 +336,6 @@ pub const Surface = struct {
             nswindow.setProperty("tabbingIdentifier", app.darwin.tabbing_id);
         }
 
-        // Create the cursor
-        const cursor = glfw.Cursor.createStandard(.ibeam) orelse return glfw.mustGetErrorCode();
-        errdefer cursor.destroy();
-        if ((comptime !builtin.target.isDarwin()) or internal_os.macosVersionAtLeast(13, 0, 0)) {
-            // We only set our cursor if we're NOT on Mac, or if we are then the
-            // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
-            // since we use a tab group.
-            win.setCursor(cursor);
-        }
-
         // Set our callbacks
         win.setUserPointer(&self.core_surface);
         win.setSizeCallback(sizeCallback);
@@ -361,11 +351,14 @@ pub const Surface = struct {
         self.* = .{
             .app = app,
             .window = win,
-            .cursor = cursor,
+            .cursor = null,
             .core_surface = undefined,
         };
         errdefer self.* = undefined;
 
+        // Initialize our cursor
+        try self.setCursorShape(.text);
+
         // Add ourselves to the list of surfaces on the app.
         try app.app.addSurface(self);
         errdefer app.app.deleteSurface(self);
@@ -426,7 +419,10 @@ pub const Surface = struct {
         // We can now safely destroy our windows. We have to do this BEFORE
         // setting up the new focused window below.
         self.window.destroy();
-        self.cursor.destroy();
+        if (self.cursor) |c| {
+            c.destroy();
+            self.cursor = null;
+        }
 
         // If we have a tabgroup set, we want to manually focus the next window.
         // We should NOT have to do this usually, see the comments above.
@@ -511,8 +507,39 @@ pub const Surface = struct {
 
     /// Set the shape of the cursor.
     pub fn setCursorShape(self: *Surface, shape: terminal.CursorShape) !void {
-        _ = self;
-        _ = shape;
+        if ((comptime builtin.target.isDarwin()) and
+            !internal_os.macosVersionAtLeast(13, 0, 0))
+        {
+            // We only set our cursor if we're NOT on Mac, or if we are then the
+            // macOS version is >= 13 (Ventura). On prior versions, glfw crashes
+            // since we use a tab group.
+            return;
+        }
+
+        const new = glfw.Cursor.createStandard(switch (shape) {
+            .default => .arrow,
+            .text => .ibeam,
+            .crosshair => .crosshair,
+            .pointer => .pointing_hand,
+            .ew_resize => .resize_ew,
+            .ns_resize => .resize_ns,
+            .nwse_resize => .resize_nwse,
+            .nesw_resize => .resize_nesw,
+            .all_scroll => .resize_all,
+            .not_allowed => .not_allowed,
+            else => return, // unsupported, ignore
+        }) orelse {
+            const err = glfw.mustGetErrorCode();
+            log.warn("error creating cursor: {}", .{err});
+            return;
+        };
+        errdefer new.destroy();
+
+        // Set our cursor before we destroy the old one
+        self.window.setCursor(new);
+
+        if (self.cursor) |c| c.destroy();
+        self.cursor = new;
     }
 
     /// Read the clipboard. The windowing system is responsible for allocating

commit cb2931cb276dd15fc078e87334a6ad3a37248118
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 14 10:59:22 2023 -0700

    rename cursor shape to mouse shape for OSC 22

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a5686892..2efab953 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -357,7 +357,7 @@ pub const Surface = struct {
         errdefer self.* = undefined;
 
         // Initialize our cursor
-        try self.setCursorShape(.text);
+        try self.setMouseShape(.text);
 
         // Add ourselves to the list of surfaces on the app.
         try app.app.addSurface(self);
@@ -506,7 +506,7 @@ pub const Surface = struct {
     }
 
     /// Set the shape of the cursor.
-    pub fn setCursorShape(self: *Surface, shape: terminal.CursorShape) !void {
+    pub fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
         if ((comptime builtin.target.isDarwin()) and
             !internal_os.macosVersionAtLeast(13, 0, 0))
         {

commit a7e8b7559e25060019b9e4aeeedb93103dfeeca0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 14 17:36:21 2023 -0700

    mouse-hide-while-typing config and glfw implementation

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 2efab953..3a53bb9d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -542,6 +542,11 @@ pub const Surface = struct {
         self.cursor = new;
     }
 
+    /// Set the visibility of the mouse cursor.
+    pub fn setMouseVisibility(self: *Surface, visible: bool) void {
+        self.window.setInputModeCursor(if (visible) .normal else .hidden);
+    }
+
     /// Read the clipboard. The windowing system is responsible for allocating
     /// a buffer as necessary. This should be a stable pointer until the next
     /// time getClipboardString is called.

commit b30feeb596ae8dd2a73948dbfffcab540e98bcce
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Sep 19 10:18:17 2023 -0700

    core: move clipboard to async process

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 3a53bb9d..e4acab28 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -547,25 +547,27 @@ pub const Surface = struct {
         self.window.setInputModeCursor(if (visible) .normal else .hidden);
     }
 
-    /// Read the clipboard. The windowing system is responsible for allocating
-    /// a buffer as necessary. This should be a stable pointer until the next
-    /// time getClipboardString is called.
-    pub fn getClipboardString(
-        self: *const Surface,
+    /// Start an async clipboard request.
+    pub fn clipboardRequest(
+        self: *Surface,
         clipboard_type: apprt.Clipboard,
-    ) ![:0]const u8 {
-        _ = self;
-        return switch (clipboard_type) {
-            .standard => glfw.getClipboardString() orelse glfw.mustGetErrorCode(),
+        state: apprt.ClipboardRequest,
+    ) !void {
+        // GLFW can read clipboards immediately so just do that.
+        const str: []const u8 = switch (clipboard_type) {
+            .standard => glfw.getClipboardString() orelse return glfw.mustGetErrorCode(),
             .selection => selection: {
                 // Not supported except on Linux
-                if (comptime builtin.os.tag != .linux) return "";
+                if (comptime builtin.os.tag != .linux) break :selection "";
 
                 const raw = glfwNative.getX11SelectionString() orelse
                     return glfw.mustGetErrorCode();
                 break :selection std.mem.span(raw);
             },
         };
+
+        // Complete our request
+        try self.core_surface.completeClipboardRequest(state, str);
     }
 
     /// Set the clipboard.

commit 604eeceb0344043ad0479f050550bf380f810272
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Sep 22 18:54:58 2023 -0700

    apprt/glfw: support window-width, window-height configurations

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e4acab28..e69aa147 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -376,6 +376,15 @@ pub const Surface = struct {
             self,
         );
         errdefer self.core_surface.deinit();
+
+        // If we have a desired window size, we can now calculate the size
+        // because we have the cell size.
+        if (config.@"window-height" > 0 or config.@"window-width" > 0) {
+            self.window.setSize(.{
+                .height = @max(config.@"window-height" * self.core_surface.cell_size.height, 480),
+                .width = @max(config.@"window-width" * self.core_surface.cell_size.width, 640),
+            });
+        }
     }
 
     pub fn deinit(self: *Surface) void {

commit a1a8aeb104e9fb47f1396ddb0572b056533ffeaa
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 30 21:35:50 2023 -0700

    initial window size needs to take into account window chrome

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e69aa147..4a40ed22 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -376,15 +376,6 @@ pub const Surface = struct {
             self,
         );
         errdefer self.core_surface.deinit();
-
-        // If we have a desired window size, we can now calculate the size
-        // because we have the cell size.
-        if (config.@"window-height" > 0 or config.@"window-width" > 0) {
-            self.window.setSize(.{
-                .height = @max(config.@"window-height" * self.core_surface.cell_size.height, 480),
-                .width = @max(config.@"window-width" * self.core_surface.cell_size.width, 640),
-            });
-        }
     }
 
     pub fn deinit(self: *Surface) void {
@@ -456,6 +447,13 @@ pub const Surface = struct {
         self.app.app.alloc.destroy(self);
     }
 
+    /// Set the initial window size. This is called exactly once at
+    /// surface initialization time. This may be called before "self"
+    /// is fully initialized.
+    pub fn setInitialWindowSize(self: *const Surface, width: u32, height: u32) !void {
+        self.window.setSize(.{ .width = width, .height = height });
+    }
+
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,

commit a9279f98710a62edafb8846505646d772816df25
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Oct 22 09:27:30 2023 -0700

    apprt/glfw: does not implement inspector

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4a40ed22..36367e20 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -215,6 +215,13 @@ pub const App = struct {
         @panic("This should never be called for GLFW.");
     }
 
+    pub fn redrawInspector(self: *App, surface: *Surface) void {
+        _ = self;
+        _ = surface;
+
+        // GLFW doesn't support the inspector
+    }
+
     fn glfwErrorCallback(code: glfw.ErrorCode, desc: [:0]const u8) void {
         std.log.warn("glfw error={} message={s}", .{ code, desc });
 

commit 2ee80a52df2fdec3d08df69b01e4c6c7b0071ccd
Author: Gregory Anders <greg@gpanders.com>
Date:   Tue Oct 24 21:18:40 2023 -0500

    macos: set window resizeIncrements when cell size changes
    
    The resizeIncrements property is only modified when the cell size of the
    focused window changes. If two splits have the same cell size then the
    property is not modified when focusing between the two splits.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 36367e20..bf96e1e6 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -461,6 +461,13 @@ pub const Surface = struct {
         self.window.setSize(.{ .width = width, .height = height });
     }
 
+    /// Set the cell size. Unused by GLFW.
+    pub fn setCellSize(self: *const Surface, width: u32, height: u32) !void {
+        _ = self;
+        _ = width;
+        _ = height;
+    }
+
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,

commit 008736c3bf8f7e45bdcf435749fe9cb7d4820c33
Author: xdBronch <51252236+xdBronch@users.noreply.github.com>
Date:   Wed Nov 1 19:19:30 2023 -0400

    add support for file dropping to glfw runtime

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index bf96e1e6..65ab3cd5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -353,6 +353,7 @@ pub const Surface = struct {
         win.setScrollCallback(scrollCallback);
         win.setCursorPosCallback(cursorPosCallback);
         win.setMouseButtonCallback(mouseButtonCallback);
+        win.setDropCallback(dropCallback);
 
         // Build our result
         self.* = .{
@@ -964,4 +965,38 @@ pub const Surface = struct {
             return;
         };
     }
+
+    fn dropCallback(window: glfw.Window, paths: [][*:0]const u8) void {
+        const tracy = trace(@src());
+        defer tracy.end();
+
+        const surface = window.getUserPointer(CoreSurface) orelse return;
+
+        var list = std.ArrayList(u8).init(surface.alloc);
+        defer list.deinit();
+
+        for (paths) |path| {
+            const path_slice = std.mem.span(path);
+            const writer = list.writer();
+
+            list.ensureTotalCapacity(path_slice.len * 2 + 1) catch |err| { // preallocate worst case of escaping every char + space
+                log.err("error in drop callback err={}", .{err});
+                return;
+            };
+
+            for (path_slice) |c| {
+                if (std.mem.indexOfScalar(u8, "\\ ()[]{}<>\"'`!#$&;|*?\t", c)) |_| {
+                    writer.print("\\{c}", .{c}) catch unreachable; // only error is OOM, memory preallocated
+                } else writer.writeByte(c) catch unreachable; // same here
+            }
+            writer.writeByte(' ') catch unreachable; // separate paths
+
+            surface.textCallback(list.items) catch |err| {
+                log.err("error in drop callback err={}", .{err});
+                return;
+            };
+
+            list.clearRetainingCapacity(); // avoid unnecessary reallocations
+        }
+    }
 };

commit 657111c4101264c4d69020b0d3000e4a97e4e504
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 2 21:34:43 2023 -0700

    apprt/glfw: small line length fixes

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 65ab3cd5..be4103f7 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -977,16 +977,17 @@ pub const Surface = struct {
 
         for (paths) |path| {
             const path_slice = std.mem.span(path);
-            const writer = list.writer();
 
-            list.ensureTotalCapacity(path_slice.len * 2 + 1) catch |err| { // preallocate worst case of escaping every char + space
+            // preallocate worst case of escaping every char + space
+            list.ensureTotalCapacity(path_slice.len * 2 + 1) catch |err| {
                 log.err("error in drop callback err={}", .{err});
                 return;
             };
 
+            const writer = list.writer();
             for (path_slice) |c| {
                 if (std.mem.indexOfScalar(u8, "\\ ()[]{}<>\"'`!#$&;|*?\t", c)) |_| {
-                    writer.print("\\{c}", .{c}) catch unreachable; // only error is OOM, memory preallocated
+                    writer.print("\\{c}", .{c}) catch unreachable; //  memory preallocated
                 } else writer.writeByte(c) catch unreachable; // same here
             }
             writer.writeByte(' ') catch unreachable; // separate paths

commit a578ec342f570adf601e2ba621d6d5a8603576b8
Author: David Rubin <daviru007@icloud.com>
Date:   Fri Nov 3 14:20:24 2023 -0700

    forgot to update other backends

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index be4103f7..044da8e9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -589,7 +589,7 @@ pub const Surface = struct {
         };
 
         // Complete our request
-        try self.core_surface.completeClipboardRequest(state, str);
+        try self.core_surface.completeClipboardRequest(state, str, false);
     }
 
     /// Set the clipboard.

commit 65c9ba0a86c86bafbd80ff705db9d2f78848cbb4
Author: David Rubin <daviru007@icloud.com>
Date:   Sat Nov 4 00:50:26 2023 -0700

    add todos + make sure non-implimented platforms still work.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 044da8e9..83be181e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -589,7 +589,8 @@ pub const Surface = struct {
         };
 
         // Complete our request
-        try self.core_surface.completeClipboardRequest(state, str, false);
+        // TODO: Support sanaization for GLFW (force: false)
+        try self.core_surface.completeClipboardRequest(state, str, true);
     }
 
     /// Set the clipboard.

commit a38220eaded2a5f8813c650489b897f7771cbaca
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Nov 4 11:19:25 2023 -0700

    terminal: move sanitization check to this package, unit test

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 83be181e..41bfae89 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -588,8 +588,8 @@ pub const Surface = struct {
             },
         };
 
-        // Complete our request
-        // TODO: Support sanaization for GLFW (force: false)
+        // Complete our request. We always allow unsafe because we don't
+        // want to deal with user confirmation in this runtime.
         try self.core_surface.completeClipboardRequest(state, str, true);
     }
 

commit fbe2b7c2677fbb5af88d9cd6387d1bcf71628435
Author: Raiden1411 <67233402+Raiden1411@users.noreply.github.com>
Date:   Tue Nov 7 17:58:00 2023 +0000

    feat: fullscreen and toggleFullscreen support

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 41bfae89..33010b61 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -144,6 +144,38 @@ pub const App = struct {
         return &self.config;
     }
 
+    /// Toggle the window to fullscreen mode.
+    pub fn toggleFullscreen(self: *App, surface: *Surface) void {
+        _ = self;
+        const win = surface.window;
+
+        if (!surface.isFullscreen()) {
+            const monitor = win.getMonitor() orelse monitor: {
+                log.warn("window had null monitor, getting primary monitor", .{});
+                break :monitor glfw.Monitor.getPrimary() orelse {
+                    log.warn("window could not get any monitor. Will not perform action", .{});
+                    return;
+                };
+            };
+            const position = win.getPos();
+            const size = surface.getSize() catch {
+                log.warn("Failed to get window size. Will not perform fullscreen action", .{});
+                return;
+            };
+
+            surface.window_dimensions = .{
+                .width = size.width,
+                .height = size.height,
+                .position_x = position.x,
+                .position_y = position.y,
+            };
+
+            win.setMonitor(monitor, 0, 0, surface.window_dimensions.width, surface.window_dimensions.height, 0);
+        } else {
+            win.setMonitor(null, @as(i32, @intCast(surface.window_dimensions.position_x)), @as(i32, @intCast(surface.window_dimensions.position_y)), surface.window_dimensions.width, surface.window_dimensions.height, 0);
+        }
+    }
+
     /// Create a new window for the app.
     pub fn newWindow(self: *App, parent_: ?*CoreSurface) !void {
         _ = try self.newSurface(parent_);
@@ -267,6 +299,15 @@ pub const App = struct {
     };
 };
 
+/// These are used to keep track of the original monitor values so that we can safely
+/// toggle on and off of fullscreen.
+const MonitorDimensions = struct {
+    width: u32,
+    height: u32,
+    position_x: i64,
+    position_y: i64,
+};
+
 /// Surface represents the drawable surface for glfw. In glfw, a surface
 /// is always a window because that is the only abstraction that glfw exposes.
 ///
@@ -297,17 +338,21 @@ pub const Surface = struct {
     /// (GLFW guarantees that charCallback is called after keyCallback).
     key_event: ?input.KeyEvent = null,
 
+    window_dimensions: MonitorDimensions,
+
     pub const Options = struct {};
 
     /// Initialize the surface into the given self pointer. This gives a
     /// stable pointer to the destination that can be used for callbacks.
     pub fn init(self: *Surface, app: *App) !void {
+        const fullscreen = if (app.config.fullscreen) glfw.Monitor.getPrimary().? else null;
+
         // Create our window
         const win = glfw.Window.create(
             640,
             480,
             "ghostty",
-            null,
+            fullscreen,
             null,
             Renderer.glfwWindowHints(&app.config),
         ) orelse return glfw.mustGetErrorCode();
@@ -320,8 +365,8 @@ pub const Surface = struct {
                 log.warn("window had null monitor, getting primary monitor", .{});
                 break :monitor glfw.Monitor.getPrimary().?;
             };
-            const physical_size = monitor.getPhysicalSize();
             const video_mode = monitor.getVideoMode() orelse return glfw.mustGetErrorCode();
+            const physical_size = monitor.getPhysicalSize();
             const physical_x_dpi = @as(f32, @floatFromInt(video_mode.getWidth())) / (@as(f32, @floatFromInt(physical_size.width_mm)) / 25.4);
             const physical_y_dpi = @as(f32, @floatFromInt(video_mode.getHeight())) / (@as(f32, @floatFromInt(physical_size.height_mm)) / 25.4);
             log.debug("physical dpi x={} y={}", .{
@@ -361,6 +406,7 @@ pub const Surface = struct {
             .window = win,
             .cursor = null,
             .core_surface = undefined,
+            .window_dimensions = undefined,
         };
         errdefer self.* = undefined;
 
@@ -447,6 +493,15 @@ pub const Surface = struct {
         try self.app.newTab(&self.core_surface);
     }
 
+    /// Checks if the glfw window is in fullscreen.
+    pub fn isFullscreen(self: *Surface) bool {
+        return self.window.getMonitor() != null;
+    }
+
+    pub fn toggleFullscreen(self: *Surface, _: Config.NonNativeFullscreen) void {
+        self.app.toggleFullscreen(self);
+    }
+
     /// Close this surface.
     pub fn close(self: *Surface, processActive: bool) void {
         _ = processActive;

commit b9ad49acc3dd1e698ace23311b996920c3cc7607
Author: Raiden1411 <67233402+Raiden1411@users.noreply.github.com>
Date:   Tue Nov 7 18:07:22 2023 +0000

    chore: add video mode

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 33010b61..c7bbd9e7 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -153,13 +153,18 @@ pub const App = struct {
             const monitor = win.getMonitor() orelse monitor: {
                 log.warn("window had null monitor, getting primary monitor", .{});
                 break :monitor glfw.Monitor.getPrimary() orelse {
-                    log.warn("window could not get any monitor. Will not perform action", .{});
+                    log.warn("window could not get any monitor. will not perform action", .{});
                     return;
                 };
             };
+            const video_mode = monitor.getVideoMode() orelse {
+                log.warn("failed to get video mode. will not perform action", .{});
+                return;
+            };
+
             const position = win.getPos();
             const size = surface.getSize() catch {
-                log.warn("Failed to get window size. Will not perform fullscreen action", .{});
+                log.warn("failed to get window size. will not perform fullscreen action", .{});
                 return;
             };
 
@@ -170,7 +175,7 @@ pub const App = struct {
                 .position_y = position.y,
             };
 
-            win.setMonitor(monitor, 0, 0, surface.window_dimensions.width, surface.window_dimensions.height, 0);
+            win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
         } else {
             win.setMonitor(null, @as(i32, @intCast(surface.window_dimensions.position_x)), @as(i32, @intCast(surface.window_dimensions.position_y)), surface.window_dimensions.width, surface.window_dimensions.height, 0);
         }

commit b0f6b1e2c937585afbd662bba15d9f3ba1863d28
Author: Raiden1411 <67233402+Raiden1411@users.noreply.github.com>
Date:   Tue Nov 7 19:24:02 2023 +0000

    re-add dimensions

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c7bbd9e7..c1b2c187 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -405,13 +405,17 @@ pub const Surface = struct {
         win.setMouseButtonCallback(mouseButtonCallback);
         win.setDropCallback(dropCallback);
 
+        const pos = win.getPos();
+        const size = win.getFramebufferSize();
+
+        const dimensions = .{ .width = size.width, .height = size.height, .position_x = pos.x, .position_y = pos.y };
         // Build our result
         self.* = .{
             .app = app,
             .window = win,
             .cursor = null,
             .core_surface = undefined,
-            .window_dimensions = undefined,
+            .window_dimensions = dimensions,
         };
         errdefer self.* = undefined;
 

commit 126f02187ac176e0d4b1d26b1dc2d8f6a5f3efbb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Nov 9 15:00:16 2023 -0800

    apprt/glfw: minor stylistic things

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c1b2c187..7dadcab5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -149,36 +149,45 @@ pub const App = struct {
         _ = self;
         const win = surface.window;
 
-        if (!surface.isFullscreen()) {
-            const monitor = win.getMonitor() orelse monitor: {
-                log.warn("window had null monitor, getting primary monitor", .{});
-                break :monitor glfw.Monitor.getPrimary() orelse {
-                    log.warn("window could not get any monitor. will not perform action", .{});
-                    return;
-                };
-            };
-            const video_mode = monitor.getVideoMode() orelse {
-                log.warn("failed to get video mode. will not perform action", .{});
-                return;
-            };
+        if (surface.isFullscreen()) {
+            win.setMonitor(
+                null,
+                @intCast(surface.monitor_dims.position_x),
+                @intCast(surface.monitor_dims.position_y),
+                surface.monitor_dims.width,
+                surface.monitor_dims.height,
+                0,
+            );
+            return;
+        }
 
-            const position = win.getPos();
-            const size = surface.getSize() catch {
-                log.warn("failed to get window size. will not perform fullscreen action", .{});
+        const monitor = win.getMonitor() orelse monitor: {
+            log.warn("window had null monitor, getting primary monitor", .{});
+            break :monitor glfw.Monitor.getPrimary() orelse {
+                log.warn("window could not get any monitor. will not perform action", .{});
                 return;
             };
+        };
 
-            surface.window_dimensions = .{
-                .width = size.width,
-                .height = size.height,
-                .position_x = position.x,
-                .position_y = position.y,
-            };
+        const video_mode = monitor.getVideoMode() orelse {
+            log.warn("failed to get video mode. will not perform action", .{});
+            return;
+        };
 
-            win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
-        } else {
-            win.setMonitor(null, @as(i32, @intCast(surface.window_dimensions.position_x)), @as(i32, @intCast(surface.window_dimensions.position_y)), surface.window_dimensions.width, surface.window_dimensions.height, 0);
-        }
+        const position = win.getPos();
+        const size = surface.getSize() catch {
+            log.warn("failed to get window size. will not perform fullscreen action", .{});
+            return;
+        };
+
+        surface.monitor_dims = .{
+            .width = size.width,
+            .height = size.height,
+            .position_x = position.x,
+            .position_y = position.y,
+        };
+
+        win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
     }
 
     /// Create a new window for the app.
@@ -304,8 +313,8 @@ pub const App = struct {
     };
 };
 
-/// These are used to keep track of the original monitor values so that we can safely
-/// toggle on and off of fullscreen.
+/// These are used to keep track of the original monitor values so that we can
+/// safely toggle on and off of fullscreen.
 const MonitorDimensions = struct {
     width: u32,
     height: u32,
@@ -343,21 +352,21 @@ pub const Surface = struct {
     /// (GLFW guarantees that charCallback is called after keyCallback).
     key_event: ?input.KeyEvent = null,
 
-    window_dimensions: MonitorDimensions,
+    /// The monitor dimensions so we can toggle fullscreen on and off.
+    monitor_dims: MonitorDimensions,
 
     pub const Options = struct {};
 
     /// Initialize the surface into the given self pointer. This gives a
     /// stable pointer to the destination that can be used for callbacks.
     pub fn init(self: *Surface, app: *App) !void {
-        const fullscreen = if (app.config.fullscreen) glfw.Monitor.getPrimary().? else null;
 
         // Create our window
         const win = glfw.Window.create(
             640,
             480,
             "ghostty",
-            fullscreen,
+            if (app.config.fullscreen) glfw.Monitor.getPrimary() else null,
             null,
             Renderer.glfwWindowHints(&app.config),
         ) orelse return glfw.mustGetErrorCode();
@@ -405,17 +414,24 @@ pub const Surface = struct {
         win.setMouseButtonCallback(mouseButtonCallback);
         win.setDropCallback(dropCallback);
 
-        const pos = win.getPos();
-        const size = win.getFramebufferSize();
+        const dimensions: MonitorDimensions = dimensions: {
+            const pos = win.getPos();
+            const size = win.getFramebufferSize();
+            break :dimensions .{
+                .width = size.width,
+                .height = size.height,
+                .position_x = pos.x,
+                .position_y = pos.y,
+            };
+        };
 
-        const dimensions = .{ .width = size.width, .height = size.height, .position_x = pos.x, .position_y = pos.y };
         // Build our result
         self.* = .{
             .app = app,
             .window = win,
             .cursor = null,
             .core_surface = undefined,
-            .window_dimensions = dimensions,
+            .monitor_dims = dimensions,
         };
         errdefer self.* = undefined;
 

commit 86245ff0cf5cea4c2779e21f36897ed1068cd64f
Author: Gregory Anders <greg@gpanders.com>
Date:   Thu Nov 9 20:45:50 2023 -0600

    macos: add option to prompt user for confirmation on OSC 52 commands

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 7dadcab5..9f1bb5a4 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -678,7 +678,9 @@ pub const Surface = struct {
         self: *const Surface,
         val: [:0]const u8,
         clipboard_type: apprt.Clipboard,
+        confirm: bool,
     ) !void {
+        _ = confirm;
         _ = self;
         switch (clipboard_type) {
             .standard => glfw.setClipboardString(val),

commit 960a1bb091cc2081e25eb076fe2ad505873b88dc
Author: Gregory Anders <greg@gpanders.com>
Date:   Fri Nov 10 12:04:53 2023 -0600

    gtk: implement OSC 52 prompts

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 9f1bb5a4..7bf5a9e9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -656,15 +656,14 @@ pub const Surface = struct {
         state: apprt.ClipboardRequest,
     ) !void {
         // GLFW can read clipboards immediately so just do that.
-        const str: []const u8 = switch (clipboard_type) {
+        const str: [:0]const u8 = switch (clipboard_type) {
             .standard => glfw.getClipboardString() orelse return glfw.mustGetErrorCode(),
             .selection => selection: {
                 // Not supported except on Linux
                 if (comptime builtin.os.tag != .linux) break :selection "";
 
-                const raw = glfwNative.getX11SelectionString() orelse
+                break :selection glfwNative.getX11SelectionString() orelse
                     return glfw.mustGetErrorCode();
-                break :selection std.mem.span(raw);
             },
         };
 

commit 593cfa256c4026030d596256fc8de9fa7b2431b6
Author: Gregory Anders <greg@gpanders.com>
Date:   Sat Nov 11 17:21:10 2023 -0500

    glfw: fix compile error

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 7bf5a9e9..a4178dfb 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -662,8 +662,9 @@ pub const Surface = struct {
                 // Not supported except on Linux
                 if (comptime builtin.os.tag != .linux) break :selection "";
 
-                break :selection glfwNative.getX11SelectionString() orelse
+                const raw = glfwNative.getX11SelectionString() orelse
                     return glfw.mustGetErrorCode();
+                break :selection std.mem.span(raw);
             },
         };
 

commit 5290070be938ae745b706f81871155604220e8b0
Author: Gregory Anders <greg@gpanders.com>
Date:   Thu Nov 16 16:35:48 2023 -0600

    clipboard: add Clipboard variant for primary clipboard
    
    In practice, the primary and selection clipboards are treated exactly
    the same, but this allows OSC 52 sequences to use either 's' or 'p' as
    the clipboard target.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a4178dfb..53cd31c1 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -658,7 +658,7 @@ pub const Surface = struct {
         // GLFW can read clipboards immediately so just do that.
         const str: [:0]const u8 = switch (clipboard_type) {
             .standard => glfw.getClipboardString() orelse return glfw.mustGetErrorCode(),
-            .selection => selection: {
+            .selection, .primary => selection: {
                 // Not supported except on Linux
                 if (comptime builtin.os.tag != .linux) break :selection "";
 
@@ -684,7 +684,7 @@ pub const Surface = struct {
         _ = self;
         switch (clipboard_type) {
             .standard => glfw.setClipboardString(val),
-            .selection => {
+            .selection, .primary => {
                 // Not supported except on Linux
                 if (comptime builtin.os.tag != .linux) return;
                 glfwNative.setX11SelectionString(val.ptr);

commit 67dce5ce0e7dfbb9dca356bc3072ba4fea25757c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 14 12:28:36 2023 -0800

    update zig-objc

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 53cd31c1..c75e5a3e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -291,7 +291,7 @@ pub const App = struct {
         tabbing_id: *macos.foundation.String,
 
         pub fn init() !Darwin {
-            const NSWindow = objc.Class.getClass("NSWindow").?;
+            const NSWindow = objc.getClass("NSWindow").?;
             NSWindow.msgSend(void, objc.sel("setAllowsAutomaticWindowTabbing:"), .{true});
 
             // Our tabbing ID allows all of our windows to group together

commit 9de5d991a20458ad8317558bed73e6c9cb4e965b
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Dec 7 10:24:39 2023 -0800

    core: detect inputs that result in surface close and avoid segfault
    
    Fixes #965
    
    When processing keybindings that closed the surface (`close_surface`,
    `close_window`), the surface and associated runtime structures would be
    freed so we could segfault.
    
    This PR introduces a new enum result for input events (only key for now)
    that returns whether an event resulted in a close. In this case, callers
    can properly return immediately and avoid writing to deallocated memory.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c75e5a3e..809ed6c3 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -928,16 +928,21 @@ pub const Surface = struct {
             .utf8 = "",
         };
 
-        const consumed = core_win.keyCallback(key_event) catch |err| {
+        const effect = core_win.keyCallback(key_event) catch |err| {
             log.err("error in key callback err={}", .{err});
             return;
         };
 
+        // Surface closed.
+        if (effect == .closed) return;
+
         // If it wasn't consumed, we set it on our self so that charcallback
         // can make another attempt. Otherwise, we set null so the charcallback
         // is ignored.
         core_win.rt_surface.key_event = null;
-        if (!consumed and (action == .press or action == .repeat)) {
+        if (effect == .ignored and
+            (action == .press or action == .repeat))
+        {
             core_win.rt_surface.key_event = key_event;
         }
     }

commit b021d76edf8d8574c1b60cf75e04944c1394dcb4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 13 16:35:14 2023 -0800

    core: quit-after-last-window-closed works properly with "exit"
    
    Fixes #1085
    
    This moves the logic of exiting when there are no surfaces left fully to
    apprt and away from the core.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 809ed6c3..fce84bea 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -111,7 +111,7 @@ pub const App = struct {
 
             // Tick the terminal app
             const should_quit = try self.app.tick(self);
-            if (should_quit) {
+            if (should_quit or self.app.surfaces.items.len == 0) {
                 for (self.app.surfaces.items) |surface| {
                     surface.close(false);
                 }

commit ed3e436e47092800735e38c6e1b4b09d9036572e
Author: Brian Cain <bcain@hashicorp.com>
Date:   Fri Dec 15 11:23:52 2023 -0800

    apprt: Fix key callback input key assignments
    
    Prior to this commit, two and three were not properly assigned. This
    commit updates that to assign two to two, and three to three.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index fce84bea..18593672 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -821,8 +821,8 @@ pub const Surface = struct {
             .z => .z,
             .zero => .zero,
             .one => .one,
-            .two => .three,
-            .three => .four,
+            .two => .two,
+            .three => .three,
             .four => .four,
             .five => .five,
             .six => .six,

commit b711ac8a4222e8ad5c610387aea6c09cab64b1da
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Dec 18 08:20:29 2023 -0800

    apprt/glfw: implement openconfig

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 18593672..9b19b501 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -20,6 +20,7 @@ const Renderer = renderer.Renderer;
 const apprt = @import("../apprt.zig");
 const CoreApp = @import("../App.zig");
 const CoreSurface = @import("../Surface.zig");
+const configpkg = @import("../config.zig");
 const Config = @import("../config.zig").Config;
 
 // Get native API access on certain platforms so we can do more customization.
@@ -127,6 +128,11 @@ pub const App = struct {
         glfw.postEmptyEvent();
     }
 
+    /// Open the configuration in the system editor.
+    pub fn openConfig(self: *App) !void {
+        try configpkg.edit.open(self.app.alloc);
+    }
+
     /// Reload the configuration. This should return the new configuration.
     /// The old value can be freed immediately at this point assuming a
     /// successful return.

commit adb7958f6177dfe5df69bc2202da98c566f389b9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 13 15:06:08 2024 -0800

    remove tracy usage from all files

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 9b19b501..55478674 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -8,7 +8,6 @@ const builtin = @import("builtin");
 const build_config = @import("../build_config.zig");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
-const trace = @import("tracy").trace;
 const glfw = @import("glfw");
 const macos = @import("macos");
 const objc = @import("objc");
@@ -741,9 +740,6 @@ pub const Surface = struct {
     }
 
     fn charCallback(window: glfw.Window, codepoint: u21) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // We need a key event in order to process the charcallback. If it
@@ -780,8 +776,6 @@ pub const Surface = struct {
         glfw_action: glfw.Action,
         glfw_mods: glfw.Mods,
     ) void {
-        const tracy = trace(@src());
-        defer tracy.end();
         _ = scancode;
 
         const core_win = window.getUserPointer(CoreSurface) orelse return;
@@ -954,9 +948,6 @@ pub const Surface = struct {
     }
 
     fn focusCallback(window: glfw.Window, focused: bool) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.focusCallback(focused) catch |err| {
             log.err("error in focus callback err={}", .{err});
@@ -965,9 +956,6 @@ pub const Surface = struct {
     }
 
     fn refreshCallback(window: glfw.Window) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const core_win = window.getUserPointer(CoreSurface) orelse return;
         core_win.refreshCallback() catch |err| {
             log.err("error in refresh callback err={}", .{err});
@@ -976,9 +964,6 @@ pub const Surface = struct {
     }
 
     fn scrollCallback(window: glfw.Window, xoff: f64, yoff: f64) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         // Glfw doesn't support any of the scroll mods.
         const scroll_mods: input.ScrollMods = .{};
 
@@ -994,9 +979,6 @@ pub const Surface = struct {
         unscaled_xpos: f64,
         unscaled_ypos: f64,
     ) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert our unscaled x/y to scaled.
@@ -1026,9 +1008,6 @@ pub const Surface = struct {
         glfw_action: glfw.Action,
         glfw_mods: glfw.Mods,
     ) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const core_win = window.getUserPointer(CoreSurface) orelse return;
 
         // Convert glfw button to input button
@@ -1061,9 +1040,6 @@ pub const Surface = struct {
     }
 
     fn dropCallback(window: glfw.Window, paths: [][*:0]const u8) void {
-        const tracy = trace(@src());
-        defer tracy.end();
-
         const surface = window.getUserPointer(CoreSurface) orelse return;
 
         var list = std.ArrayList(u8).init(surface.alloc);

commit bf4211e06032d69672e25c7a96b9f65d423036cd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jan 25 14:59:36 2024 -0800

    input: handle more ctrl+<key> sequences, namely ctrl+_
    
    Previously, we encoded `ctrl+_` in the CSIu format[1]. This breaks most
    notably emacs which expects the legacy ambiguous encoding.
    
    This commit utilizes the generator from Kitty to generate our control
    key mappings. We also switch from keycode mapping to key contents
    mapping which appears to be the correct behavior also compared to other
    terminals.
    
    In the course of doing this, I also found one bug with our fixterms
    implementation. Fixterms states: "The Shift key should not be considered
    as a modifier for Unicode characters, because it is most likely used to
    obtain the character in the first place (e.g. the shift key is often
    required to obtain the ! symbol)." We were not applying that logic and
    now do.
    
    [1]: https://www.leonerd.org.uk/hacks/fixterms/

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 55478674..55e8069e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -918,6 +918,20 @@ pub const Surface = struct {
             => .invalid,
         };
 
+        // This is a hack for GLFW. We require our apprts to send both
+        // the UTF8 encoding AND the keypress at the same time. Its critical
+        // for things like ctrl sequences to work. However, GLFW doesn't
+        // provide this information all at once. So we just infer based on
+        // the key press. This isn't portable but GLFW is only for testing.
+        const utf8 = switch (key) {
+            inline else => |k| utf8: {
+                if (mods.shift) break :utf8 "";
+                const cp = k.codepoint() orelse break :utf8 "";
+                const byte = std.math.cast(u8, cp) orelse break :utf8 "";
+                break :utf8 &.{byte};
+            },
+        };
+
         const key_event: input.KeyEvent = .{
             .action = action,
             .key = key,
@@ -925,7 +939,8 @@ pub const Surface = struct {
             .mods = mods,
             .consumed_mods = .{},
             .composing = false,
-            .utf8 = "",
+            .utf8 = utf8,
+            .unshifted_codepoint = if (utf8.len > 0) @intCast(utf8[0]) else 0,
         };
 
         const effect = core_win.keyCallback(key_event) catch |err| {

commit 506ba854fa160852e0622c89f41f7463abdff1e2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Apr 6 19:33:49 2024 -0700

    core: font size changes work

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 55e8069e..932e27de 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -246,7 +246,7 @@ pub const App = struct {
         // If we have a parent, inherit some properties
         if (self.config.@"window-inherit-font-size") {
             if (parent_) |parent| {
-                surface.core_surface.setFontSize(parent.font_size);
+                try surface.core_surface.setFontSize(parent.font_size);
             }
         }
 

commit 03f37087a5e24a76b02404da439ccc6fb7f3da76
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sun Jun 30 09:40:06 2024 -0700

    mouse button callbacks returns bool for consumption

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 932e27de..911eb6f5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -1048,7 +1048,7 @@ pub const Surface = struct {
             else => unreachable,
         };
 
-        core_win.mouseButtonCallback(action, button, mods) catch |err| {
+        _ = core_win.mouseButtonCallback(action, button, mods) catch |err| {
             log.err("error in scroll callback err={}", .{err});
             return;
         };

commit 36648ae397428d9256e61a072771c5e62cd99682
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jul 6 10:29:23 2024 -0700

    apprt: stubs for mouseOverLink

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 911eb6f5..81063bc6 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -649,6 +649,12 @@ pub const Surface = struct {
         self.cursor = new;
     }
 
+    pub fn mouseOverLink(self: *Surface, uri: ?[]const u8) void {
+        // We don't do anything in GLFW.
+        _ = self;
+        _ = uri;
+    }
+
     /// Set the visibility of the mouse cursor.
     pub fn setMouseVisibility(self: *Surface, visible: bool) void {
         self.window.setInputModeCursor(if (visible) .normal else .hidden);

commit ce5e55d4aa87f0bcf2562281b972015bfa5eb01a
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Wed Aug 7 00:12:20 2024 -0500

    Implement the XTWINOPS (CSI t) control sequences that "make sense".
    
    These sequences were implemented:
    
    CSI 14 t - report the text area size in pixels
    CSI 16 t - report the cell size in pixels
    CSI 18 t - report the text area size in cells
    CSI 21 t - report the window title
    
    These sequences were not implemented because they manuipulate the window
    state in ways that we do not want.
    
    CSI 1 t
    CSI 2 t
    CSI 3 ; x ; y t
    CSI 4 ; height ; width ; t
    CSI 5 t
    CSI 6 t
    CSI 7 t
    CSI 8 ; height ; width ; t
    CSI 9 ; 0 t
    CSI 9 ; 1 t
    CSI 9 ; 2 t
    CSI 9 ; 3 t
    CSI 10 ; 0 t
    CSI 10 ; 1 t
    CSI 10 ; 2 t
    CSI 24 t
    
    These sequences were not implemented because they do not make sense in
    a Wayland context:
    
    CSI 11 t
    CSI 13 t
    CSI 14 ; 2 t
    
    These sequences were not implemented because they provide information
    about the screen that is unnecessary.
    
    CSI 15 t
    CSI 19 t
    
    These sequences were not implemeted because Ghostty does not maintain an
    icon title for windows.
    
    CSI 20 t
    CSI 22 ; 0 t
    CSI 22 ; 1 t
    CSI 23 ; 0 t
    CSI 23 ; 1 t
    
    These sequences were not implemented because of the additional
    complexity of maintaining a stack of window titles.
    
    CSI 22 ; 2 t
    CSI 23 ; 2 t

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 81063bc6..89448c35 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -360,6 +360,11 @@ pub const Surface = struct {
     /// The monitor dimensions so we can toggle fullscreen on and off.
     monitor_dims: MonitorDimensions,
 
+    /// Save the title text so that we can return it later when requested.
+    /// This is allocated from the heap so it must be freed when we deinit the
+    /// surface.
+    title_text: ?[:0]const u8 = null,
+
     pub const Options = struct {};
 
     /// Initialize the surface into the given self pointer. This gives a
@@ -463,6 +468,8 @@ pub const Surface = struct {
     }
 
     pub fn deinit(self: *Surface) void {
+        if (self.title_text) |t| self.core_surface.alloc.free(t);
+
         // Remove ourselves from the list of known surfaces in the app.
         self.app.app.deleteSurface(self);
 
@@ -609,7 +616,14 @@ pub const Surface = struct {
 
     /// Set the title of the window.
     pub fn setTitle(self: *Surface, slice: [:0]const u8) !void {
-        self.window.setTitle(slice.ptr);
+        if (self.title_text) |t| self.core_surface.alloc.free(t);
+        self.title_text = try self.core_surface.alloc.dupeZ(u8, slice);
+        self.window.setTitle(self.title_text.?.ptr);
+    }
+
+    /// Return the title of the window.
+    pub fn getTitle(self: *Surface) ?[:0]const u8 {
+        return self.title_text;
     }
 
     /// Set the shape of the cursor.

commit 18419d3589fdcac1f148659e76ab5b26bb6b83c1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 26 09:53:31 2024 -0700

    Clamp initial window size configurations to screen size
    
    Fixes #2145

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 89448c35..f38214e3 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -551,7 +551,16 @@ pub const Surface = struct {
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
     pub fn setInitialWindowSize(self: *const Surface, width: u32, height: u32) !void {
-        self.window.setSize(.{ .width = width, .height = height });
+        const monitor = self.window.getMonitor() orelse glfw.Monitor.getPrimary() orelse {
+            log.warn("window is not on a monitor, not setting initial size", .{});
+            return;
+        };
+
+        const workarea = monitor.getWorkarea();
+        self.window.setSize(.{
+            .width = @min(width, workarea.width),
+            .height = @min(height, workarea.height),
+        });
     }
 
     /// Set the cell size. Unused by GLFW.

commit 261ce00552d3275d9f2790883ecbe9cff0be6187
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 21 15:11:28 2024 -0700

    apprt/macos,gtk: unfocused splits now highlight hovered links
    
    Fixes #1547
    
    The core change to make this work is to make the cursor position
    callback support taking updated modifiers. On both macOS and GTK, cursor
    position events also provide the pressed modifiers so we can pass those
    in.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index f38214e3..57cb257b 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -1040,7 +1040,7 @@ pub const Surface = struct {
         core_win.cursorPosCallback(.{
             .x = @floatCast(pos.xpos),
             .y = @floatCast(pos.ypos),
-        }) catch |err| {
+        }, null) catch |err| {
             log.err("error in cursor pos callback err={}", .{err});
             return;
         };

commit 13603c51a922392e925fd5f8bd2f0221ac438dbb
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 11:01:35 2024 -0700

    apprt: begin transition to making actions an enum and not use hasDecl

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 57cb257b..e5405eb3 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -127,6 +127,23 @@ pub const App = struct {
         glfw.postEmptyEvent();
     }
 
+    /// Perform a given action.
+    pub fn performAction(
+        self: *App,
+        target: apprt.Target,
+        comptime action: apprt.Action.Key,
+        value: apprt.Action.Value(action),
+    ) !void {
+        _ = value;
+
+        switch (action) {
+            .new_window => _ = try self.newSurface(switch (target) {
+                .app => null,
+                .surface => |v| v,
+            }),
+        }
+    }
+
     /// Open the configuration in the system editor.
     pub fn openConfig(self: *App) !void {
         try configpkg.edit.open(self.app.alloc);
@@ -195,11 +212,6 @@ pub const App = struct {
         win.setMonitor(monitor, 0, 0, video_mode.getWidth(), video_mode.getHeight(), 0);
     }
 
-    /// Create a new window for the app.
-    pub fn newWindow(self: *App, parent_: ?*CoreSurface) !void {
-        _ = try self.newSurface(parent_);
-    }
-
     /// Create a new tab in the parent surface.
     fn newTab(self: *App, parent: *CoreSurface) !void {
         if (!Darwin.enabled) {

commit 0e043bc0e479d17b60c4401ca82742ee2269e4f0
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 11:25:20 2024 -0700

    apprt: transition all hasDecls in App.zig to use the new action dispatch

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e5405eb3..8bf07c8a 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -141,12 +141,14 @@ pub const App = struct {
                 .app => null,
                 .surface => |v| v,
             }),
-        }
-    }
 
-    /// Open the configuration in the system editor.
-    pub fn openConfig(self: *App) !void {
-        try configpkg.edit.open(self.app.alloc);
+            .open_config => try configpkg.edit.open(self.app.alloc),
+
+            // Unimplemented
+            .close_all_windows,
+            .quit_timer,
+            => log.warn("unimplemented action={}", .{action}),
+        }
     }
 
     /// Reload the configuration. This should return the new configuration.

commit 02d7e766e150d44fdecbe3df6d43e9a79a4c3e42
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 11:43:35 2024 -0700

    core: move password input into action enum

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8bf07c8a..439efa3e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -147,7 +147,8 @@ pub const App = struct {
             // Unimplemented
             .close_all_windows,
             .quit_timer,
-            => log.warn("unimplemented action={}", .{action}),
+            .secure_input,
+            => log.info("unimplemented action={}", .{action}),
         }
     }
 

commit 1e010b8e087ca9620924588455220fe8c552f3ee
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 26 09:37:24 2024 -0700

    core: more actions

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 439efa3e..a3854a17 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -142,10 +142,16 @@ pub const App = struct {
                 .surface => |v| v,
             }),
 
+            .new_tab => try self.newTab(switch (target) {
+                .app => null,
+                .surface => |v| v,
+            }),
+
             .open_config => try configpkg.edit.open(self.app.alloc),
 
             // Unimplemented
             .close_all_windows,
+            .goto_tab,
             .quit_timer,
             .secure_input,
             => log.info("unimplemented action={}", .{action}),
@@ -216,12 +222,17 @@ pub const App = struct {
     }
 
     /// Create a new tab in the parent surface.
-    fn newTab(self: *App, parent: *CoreSurface) !void {
+    fn newTab(self: *App, parent_: ?*CoreSurface) !void {
         if (!Darwin.enabled) {
             log.warn("tabbing is not supported on this platform", .{});
             return;
         }
 
+        const parent = parent_ orelse {
+            _ = try self.newSurface(null);
+            return;
+        };
+
         // Create the new window
         const window = try self.newSurface(parent);
 
@@ -540,11 +551,6 @@ pub const Surface = struct {
         }
     }
 
-    /// Create a new tab in the window containing this surface.
-    pub fn newTab(self: *Surface) !void {
-        try self.app.newTab(&self.core_surface);
-    }
-
     /// Checks if the glfw window is in fullscreen.
     pub fn isFullscreen(self: *Surface) bool {
         return self.window.getMonitor() != null;

commit 9202cba1f5ac5e7753e9a5669e2f33321d5f5ae1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 26 10:05:04 2024 -0700

    core: many more actions

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a3854a17..dabf63c2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -150,7 +150,13 @@ pub const App = struct {
             .open_config => try configpkg.edit.open(self.app.alloc),
 
             // Unimplemented
+            .new_split,
+            .goto_split,
+            .resize_split,
+            .equalize_splits,
+            .toggle_split_zoom,
             .close_all_windows,
+            .toggle_window_decorations,
             .goto_tab,
             .quit_timer,
             .secure_input,

commit e29918ebb849f8502ac490b6f87490d7fce5050f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 26 10:20:40 2024 -0700

    core: more actions

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index dabf63c2..4be6aaf8 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -147,6 +147,8 @@ pub const App = struct {
                 .surface => |v| v,
             }),
 
+            .toggle_fullscreen => self.toggleFullscreen(target),
+
             .open_config => try configpkg.edit.open(self.app.alloc),
 
             // Unimplemented
@@ -155,11 +157,14 @@ pub const App = struct {
             .resize_split,
             .equalize_splits,
             .toggle_split_zoom,
+            .present_terminal,
             .close_all_windows,
             .toggle_window_decorations,
             .goto_tab,
+            .inspector,
             .quit_timer,
             .secure_input,
+            .desktop_notification,
             => log.info("unimplemented action={}", .{action}),
         }
     }
@@ -182,8 +187,12 @@ pub const App = struct {
     }
 
     /// Toggle the window to fullscreen mode.
-    pub fn toggleFullscreen(self: *App, surface: *Surface) void {
+    fn toggleFullscreen(self: *App, target: apprt.Target) void {
         _ = self;
+        const surface: *Surface = switch (target) {
+            .app => return,
+            .surface => |v| v.rt_surface,
+        };
         const win = surface.window;
 
         if (surface.isFullscreen()) {
@@ -562,10 +571,6 @@ pub const Surface = struct {
         return self.window.getMonitor() != null;
     }
 
-    pub fn toggleFullscreen(self: *Surface, _: Config.NonNativeFullscreen) void {
-        self.app.toggleFullscreen(self);
-    }
-
     /// Close this surface.
     pub fn close(self: *Surface, processActive: bool) void {
         _ = processActive;

commit 4cc4eb5ed033bb578f0d43e0c9ba840871a725f7
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 26 14:21:01 2024 -0700

    core: remove more hasdecls

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 4be6aaf8..b73aefce 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -411,7 +411,6 @@ pub const Surface = struct {
     /// Initialize the surface into the given self pointer. This gives a
     /// stable pointer to the destination that can be used for callbacks.
     pub fn init(self: *Surface, app: *App) !void {
-
         // Create our window
         const win = glfw.Window.create(
             640,
@@ -715,6 +714,23 @@ pub const Surface = struct {
         self.window.setInputModeCursor(if (visible) .normal else .hidden);
     }
 
+    pub fn updateRendererHealth(self: *const Surface, health: renderer.Health) void {
+        // We don't support this in GLFW.
+        _ = self;
+        _ = health;
+    }
+
+    pub fn supportsClipboard(
+        self: *const Surface,
+        clipboard_type: apprt.Clipboard,
+    ) bool {
+        _ = self;
+        return switch (clipboard_type) {
+            .standard => true,
+            .selection, .primary => comptime builtin.os.tag == .linux,
+        };
+    }
+
     /// Start an async clipboard request.
     pub fn clipboardRequest(
         self: *Surface,

commit 4ae20212bfe707ec3bedd9555321d51cfed1e3d4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Sep 26 16:18:11 2024 -0700

    libghostty: unified action dispatch
    
    First, this commit modifies libghostty to use a single unified action
    dispatch system based on a tagged union versus the one-off callback
    system that was previously in place. This change simplifies the code on
    both the core and consumer sides of the library. Importantly, as we
    introduce new actions, we can now maintain ABI compatibility so long as
    our union size does not change (something I don't promise yet).
    
    Second, this moves a lot more of the functions call on a surface into
    the action system. This affects all apprts and continues the previous
    work of introducing a more unified API for optional surface features.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index b73aefce..57667afb 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -134,8 +134,6 @@ pub const App = struct {
         comptime action: apprt.Action.Key,
         value: apprt.Action.Value(action),
     ) !void {
-        _ = value;
-
         switch (action) {
             .new_window => _ = try self.newSurface(switch (target) {
                 .app => null,
@@ -147,10 +145,47 @@ pub const App = struct {
                 .surface => |v| v,
             }),
 
+            .size_limit => switch (target) {
+                .app => {},
+                .surface => |surface| try surface.rt_surface.setSizeLimits(.{
+                    .width = value.min_width,
+                    .height = value.min_height,
+                }, if (value.max_width > 0) .{
+                    .width = value.max_width,
+                    .height = value.max_height,
+                } else null),
+            },
+
+            .initial_size => switch (target) {
+                .app => {},
+                .surface => |surface| try surface.rt_surface.setInitialWindowSize(
+                    value.width,
+                    value.height,
+                ),
+            },
+
             .toggle_fullscreen => self.toggleFullscreen(target),
 
             .open_config => try configpkg.edit.open(self.app.alloc),
 
+            .set_title => switch (target) {
+                .app => {},
+                .surface => |surface| try surface.rt_surface.setTitle(value.title),
+            },
+
+            .mouse_shape => switch (target) {
+                .app => {},
+                .surface => |surface| try surface.rt_surface.setMouseShape(value),
+            },
+
+            .mouse_visibility => switch (target) {
+                .app => {},
+                .surface => |surface| surface.rt_surface.setMouseVisibility(switch (value) {
+                    .visible => true,
+                    .hidden => false,
+                }),
+            },
+
             // Unimplemented
             .new_split,
             .goto_split,
@@ -162,9 +197,13 @@ pub const App = struct {
             .toggle_window_decorations,
             .goto_tab,
             .inspector,
+            .render_inspector,
             .quit_timer,
             .secure_input,
             .desktop_notification,
+            .mouse_over_link,
+            .cell_size,
+            .renderer_health,
             => log.info("unimplemented action={}", .{action}),
         }
     }
@@ -581,7 +620,7 @@ pub const Surface = struct {
     /// Set the initial window size. This is called exactly once at
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
-    pub fn setInitialWindowSize(self: *const Surface, width: u32, height: u32) !void {
+    fn setInitialWindowSize(self: *const Surface, width: u32, height: u32) !void {
         const monitor = self.window.getMonitor() orelse glfw.Monitor.getPrimary() orelse {
             log.warn("window is not on a monitor, not setting initial size", .{});
             return;
@@ -594,18 +633,11 @@ pub const Surface = struct {
         });
     }
 
-    /// Set the cell size. Unused by GLFW.
-    pub fn setCellSize(self: *const Surface, width: u32, height: u32) !void {
-        _ = self;
-        _ = width;
-        _ = height;
-    }
-
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,
     /// or no mins.
-    pub fn setSizeLimits(self: *Surface, min: apprt.SurfaceSize, max_: ?apprt.SurfaceSize) !void {
+    fn setSizeLimits(self: *Surface, min: apprt.SurfaceSize, max_: ?apprt.SurfaceSize) !void {
         self.window.setSizeLimits(.{
             .width = min.width,
             .height = min.height,
@@ -655,7 +687,7 @@ pub const Surface = struct {
     }
 
     /// Set the title of the window.
-    pub fn setTitle(self: *Surface, slice: [:0]const u8) !void {
+    fn setTitle(self: *Surface, slice: [:0]const u8) !void {
         if (self.title_text) |t| self.core_surface.alloc.free(t);
         self.title_text = try self.core_surface.alloc.dupeZ(u8, slice);
         self.window.setTitle(self.title_text.?.ptr);
@@ -667,7 +699,7 @@ pub const Surface = struct {
     }
 
     /// Set the shape of the cursor.
-    pub fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
+    fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
         if ((comptime builtin.target.isDarwin()) and
             !internal_os.macosVersionAtLeast(13, 0, 0))
         {
@@ -703,23 +735,11 @@ pub const Surface = struct {
         self.cursor = new;
     }
 
-    pub fn mouseOverLink(self: *Surface, uri: ?[]const u8) void {
-        // We don't do anything in GLFW.
-        _ = self;
-        _ = uri;
-    }
-
     /// Set the visibility of the mouse cursor.
-    pub fn setMouseVisibility(self: *Surface, visible: bool) void {
+    fn setMouseVisibility(self: *Surface, visible: bool) void {
         self.window.setInputModeCursor(if (visible) .normal else .hidden);
     }
 
-    pub fn updateRendererHealth(self: *const Surface, health: renderer.Health) void {
-        // We don't support this in GLFW.
-        _ = self;
-        _ = health;
-    }
-
     pub fn supportsClipboard(
         self: *const Surface,
         clipboard_type: apprt.Clipboard,

commit f1474c220d1a4896120058bddbaa6e8ba53a1b48
Author: Paul Berg <paul.berg@univ-ubs.fr>
Date:   Fri Sep 27 09:36:45 2024 +0200

    bind: add toggle_tab_overview binding

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 57667afb..fb31f7c2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -194,6 +194,7 @@ pub const App = struct {
             .toggle_split_zoom,
             .present_terminal,
             .close_all_windows,
+            .toggle_tab_overview,
             .toggle_window_decorations,
             .goto_tab,
             .inspector,

commit 7806366eec8d631d97c42d05210bad39a8c8eaaf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Sep 25 09:48:47 2024 -0700

    core: fix up toggle_slide_terminal action for rebase

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index fb31f7c2..a64ed0af 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -196,6 +196,7 @@ pub const App = struct {
             .close_all_windows,
             .toggle_tab_overview,
             .toggle_window_decorations,
+            .toggle_slide_terminal,
             .goto_tab,
             .inspector,
             .render_inspector,

commit 1570ef01a78072ad34f3fab160ed85d180c46465
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Sep 28 15:20:24 2024 -0700

    rename slide to quick terminal

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a64ed0af..87314c0e 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -196,7 +196,7 @@ pub const App = struct {
             .close_all_windows,
             .toggle_tab_overview,
             .toggle_window_decorations,
-            .toggle_slide_terminal,
+            .toggle_quick_terminal,
             .goto_tab,
             .inspector,
             .render_inspector,

commit 24ba1a6100fb13a07fd847416b0dbb20aabbf4b0
Author: Roland Peelen <roland@peppr.nl>
Date:   Mon Sep 30 19:53:18 2024 +0200

    Add action on Zig side

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 87314c0e..948b38a2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -197,6 +197,7 @@ pub const App = struct {
             .toggle_tab_overview,
             .toggle_window_decorations,
             .toggle_quick_terminal,
+            .toggle_visibility,
             .goto_tab,
             .inspector,
             .render_inspector,

commit 5c1ffbb64209c9cc75f9a32256b7addf45975ee8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Oct 8 06:51:25 2024 -1000

    apprt: implement key_sequence action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 948b38a2..980c2dba 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -203,6 +203,7 @@ pub const App = struct {
             .render_inspector,
             .quit_timer,
             .secure_input,
+            .key_sequence,
             .desktop_notification,
             .mouse_over_link,
             .cell_size,

commit eec77e271c2a07c3556800e12f6a6189e1e963ca
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 9 14:35:23 2024 -0700

    macos: change our minimum version to macOS 13
    
    macOS 12 is officially EOL by Apple and the project only supports
    officially supported versions of macOS. Once publicly released, users on
    older macOS versions will have to use older released builds.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 980c2dba..cbb9b7e4 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -559,25 +559,15 @@ pub const Surface = struct {
         // Clean up our core surface so that all the rendering and IO stop.
         self.core_surface.deinit();
 
-        var tabgroup_opt: if (App.Darwin.enabled) ?objc.Object else void = undefined;
         if (App.Darwin.enabled) {
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(self.window).?);
             const tabgroup = nswindow.getProperty(objc.Object, "tabGroup");
-
-            // On macOS versions prior to Ventura, we lose window focus on tab close
-            // for some reason. We manually fix this by keeping track of the tab
-            // group and just selecting the next window.
-            if (internal_os.macosVersionAtLeast(13, 0, 0))
-                tabgroup_opt = null
-            else
-                tabgroup_opt = tabgroup;
-
             const windows = tabgroup.getProperty(objc.Object, "windows");
             switch (windows.getProperty(usize, "count")) {
                 // If we're going down to one window our tab bar is going to be
                 // destroyed so unset it so that the later logic doesn't try to
                 // use it.
-                1 => tabgroup_opt = null,
+                1 => {},
 
                 // If our tab bar is visible and we are going down to 1 window,
                 // hide the tab bar. The check is "2" because our current window
@@ -597,15 +587,6 @@ pub const Surface = struct {
             c.destroy();
             self.cursor = null;
         }
-
-        // If we have a tabgroup set, we want to manually focus the next window.
-        // We should NOT have to do this usually, see the comments above.
-        if (App.Darwin.enabled) {
-            if (tabgroup_opt) |tabgroup| {
-                const selected = tabgroup.getProperty(objc.Object, "selectedWindow");
-                selected.msgSend(void, objc.sel("makeKeyWindow"), .{});
-            }
-        }
     }
 
     /// Checks if the glfw window is in fullscreen.

commit a4e14631ef6eb57382ff3c15134d90617c8fd264
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 16 16:45:38 2024 -0700

    config: richer diagnostics for errors
    
    Rather than storing a list of errors we now store a list of
    "diagnostics." Each diagnostic has a richer set of structured
    information, including a message, a key, the location where it occurred.
    
    This lets us show more detailed messages, more human friendly messages, and
    also let's us filter by key or location. We don't take advantage of
    all of this capability in this initial commit, but we do use every field
    for something.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index cbb9b7e4..0f0be548 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -69,9 +69,13 @@ pub const App = struct {
         errdefer config.deinit();
 
         // If we had configuration errors, then log them.
-        if (!config._errors.empty()) {
-            for (config._errors.list.items) |err| {
-                log.warn("configuration error: {s}", .{err.message});
+        if (!config._diagnostics.empty()) {
+            var buf = std.ArrayList(u8).init(core_app.alloc);
+            defer buf.deinit();
+            for (config._diagnostics.items()) |diag| {
+                try diag.write(buf.writer());
+                log.warn("configuration error: {s}", .{buf.items});
+                buf.clearRetainingCapacity();
             }
         }
 

commit 463f4afc0529f3992aecdf552cfe0f3e81796722
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Oct 18 08:14:40 2024 -0700

    apprt/glfw: exit with invalid CLI args

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 0f0be548..668dd914 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -11,6 +11,7 @@ const Allocator = std.mem.Allocator;
 const glfw = @import("glfw");
 const macos = @import("macos");
 const objc = @import("objc");
+const cli = @import("../cli.zig");
 const input = @import("../input.zig");
 const internal_os = @import("../os/main.zig");
 const renderer = @import("../renderer.zig");
@@ -77,9 +78,18 @@ pub const App = struct {
                 log.warn("configuration error: {s}", .{buf.items});
                 buf.clearRetainingCapacity();
             }
+
+            // If we have any CLI errors, exit.
+            if (config._diagnostics.containsLocation(.cli)) {
+                log.warn("CLI errors detected, exiting", .{});
+                _ = core_app.mailbox.push(.{
+                    .quit = {},
+                }, .{ .forever = {} });
+            }
         }
 
         // Queue a single new window that starts on launch
+        // Note: above we may send a quit so this may never happen
         _ = core_app.mailbox.push(.{
             .new_window = .{},
         }, .{ .forever = {} });

commit 465d60def86c86593eb28d9d4b39aa4a06452326
Author: axdank <alexisslobodzian2@gmail.com>
Date:   Thu Oct 24 00:01:54 2024 -0300

    gui: add move_current_tab action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 668dd914..49eecab3 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -213,6 +213,7 @@ pub const App = struct {
             .toggle_quick_terminal,
             .toggle_visibility,
             .goto_tab,
+            .move_current_tab,
             .inspector,
             .render_inspector,
             .quit_timer,

commit 520dda65cbd50a48b45acf834b830f2938749492
Author: axdank <alexisslobodzian2@gmail.com>
Date:   Fri Oct 25 08:07:11 2024 -0300

    apply review changes

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 49eecab3..1dde97c9 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -213,7 +213,7 @@ pub const App = struct {
             .toggle_quick_terminal,
             .toggle_visibility,
             .goto_tab,
-            .move_current_tab,
+            .move_tab,
             .inspector,
             .render_inspector,
             .quit_timer,

commit a2a1d93d5cbc2c6e00193902b4d3ac09d161b330
Author: CJ van den Berg <cj@vdbonline.com>
Date:   Mon Oct 28 09:48:01 2024 +0100

    apprt: propagate OSC10/11 (set term fore/background color) through to apprt
    
    This is to allow the running apprt to set the UI theme to match the
    terminal application coloring.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 1dde97c9..f9651a93 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -223,6 +223,8 @@ pub const App = struct {
             .mouse_over_link,
             .cell_size,
             .renderer_health,
+            .set_foreground,
+            .set_background,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit 1065359b9a7b3ee597df47309854c5ee22d2c988
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 30 16:31:59 2024 -0400

    apprt: rename set_bg/fg to "color_change" to report all color changes

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index f9651a93..638f52ba 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -223,8 +223,7 @@ pub const App = struct {
             .mouse_over_link,
             .cell_size,
             .renderer_health,
-            .set_foreground,
-            .set_background,
+            .color_change,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit 3ca246ceb931fd39c9b8112a46e188eb3f5028ec
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 13 12:28:26 2024 -0800

    apprt: support a pwd change action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 638f52ba..54c53139 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -224,6 +224,7 @@ pub const App = struct {
             .cell_size,
             .renderer_health,
             .color_change,
+            .pwd,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit b7f1eaa14568bab988ea135dec98dc005b88ddbf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Nov 19 15:35:42 2024 -0800

    apprt: action to change conditional state, implement for embedded

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 54c53139..3c866a1d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -225,6 +225,7 @@ pub const App = struct {
             .renderer_health,
             .color_change,
             .pwd,
+            .config_change_conditional_state,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit fadfb08efef52b23ceac598839c98fdf51d2cf1c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Nov 20 15:08:47 2024 -0800

    apprt: add `config_change` action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 3c866a1d..19be4677 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -226,6 +226,7 @@ pub const App = struct {
             .color_change,
             .pwd,
             .config_change_conditional_state,
+            .config_change,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit 0a794addf1523a9dd333ae025d386beea8cc7918
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 22 11:27:40 2024 -0800

    apprt/glfw: update to new reload config action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 19be4677..51d82ca7 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -200,6 +200,8 @@ pub const App = struct {
                 }),
             },
 
+            .reload_config => try self.reloadConfig(target, value),
+
             // Unimplemented
             .new_split,
             .goto_split,
@@ -236,16 +238,34 @@ pub const App = struct {
     /// successful return.
     ///
     /// The returned pointer value is only valid for a stable self pointer.
-    pub fn reloadConfig(self: *App) !?*const Config {
+    fn reloadConfig(
+        self: *App,
+        target: apprt.action.Target,
+        opts: apprt.action.ReloadConfig,
+    ) !void {
+        if (opts.soft) {
+            switch (target) {
+                .app => try self.app.updateConfig(self, &self.config),
+                .surface => |core_surface| try core_surface.updateConfig(
+                    &self.config,
+                ),
+            }
+            return;
+        }
+
         // Load our configuration
         var config = try Config.load(self.app.alloc);
         errdefer config.deinit();
 
+        // Call into our app to update
+        switch (target) {
+            .app => try self.app.updateConfig(self, &config),
+            .surface => |core_surface| try core_surface.updateConfig(&config),
+        }
+
         // Update the existing config, be sure to clean up the old one.
         self.config.deinit();
         self.config = config;
-
-        return &self.config;
     }
 
     /// Toggle the window to fullscreen mode.

commit 00c62708d328ef038913f1c91aa03d47f07310a3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Nov 22 11:33:15 2024 -0800

    apprt: remove change conditional state action

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 51d82ca7..e793615d 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -227,7 +227,6 @@ pub const App = struct {
             .renderer_health,
             .color_change,
             .pwd,
-            .config_change_conditional_state,
             .config_change,
             => log.info("unimplemented action={}", .{action}),
         }

commit 10e37a3deefcb3e433f4dfa77336cafdd363edc2
Author: Kyaw <mail@kyswtn.com>
Date:   Sun Nov 24 17:08:07 2024 +0700

    config: support loading from "Application Support" directory on macOS

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index e793615d..bf4c44ad 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -724,7 +724,7 @@ pub const Surface = struct {
     /// Set the shape of the cursor.
     fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
         if ((comptime builtin.target.isDarwin()) and
-            !internal_os.macosVersionAtLeast(13, 0, 0))
+            !internal_os.macos.isAtLeastVersion(13, 0, 0))
         {
             // We only set our cursor if we're NOT on Mac, or if we are then the
             // macOS version is >= 13 (Ventura). On prior versions, glfw crashes

commit ab60fbc096674da013e87c769f2d79a4f30944f6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Dec 11 11:14:36 2024 -0800

    apprt/glfw: add noop keyboardLayout func to satisfy tests and builds

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index bf4c44ad..64b0cbe8 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -409,6 +409,13 @@ pub const App = struct {
         }
     }
 
+    pub fn keyboardLayout(self: *const App) input.KeyboardLayout {
+        _ = self;
+
+        // Not supported by glfw
+        return .unknown;
+    }
+
     /// Mac-specific settings. This is only enabled when the target is
     /// Mac and the artifact is a standalone exe. We don't target libs because
     /// the embedded API doesn't do windowing.

commit 5ced72498e122bcdf0b5c390f72a389ddbf2f1f5
Author: Adam Wolf <adam@travefy.com>
Date:   Sun Dec 29 11:23:54 2024 -0600

    feat(linux): allow setting an intial start position

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 64b0cbe8..a17b18a2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -178,6 +178,14 @@ pub const App = struct {
                 ),
             },
 
+            .initial_position => switch (target) {
+                .app => {},
+                .surface => |surface| surface.rt_surface.setInitialWindowPosition(
+                    value.x,
+                    value.y,
+                ),
+            },
+
             .toggle_fullscreen => self.toggleFullscreen(target),
 
             .open_config => try configpkg.edit.open(self.app.alloc),
@@ -663,6 +671,15 @@ pub const Surface = struct {
         });
     }
 
+    /// Set the initial window position. This is called exactly once at
+    /// surface initialization time. This may be called before "self"
+    /// is fully initialized.
+    fn setInitialWindowPosition(self: *const Surface, x: i32, y: i32) void {
+        log.debug("setting initial window position ({},{})", .{ x, y });
+
+        self.window.setPos(.{ .x = x, .y = y });
+    }
+
     /// Set the size limits of the window.
     /// Note: this interface is not good, we should redo it if we plan
     /// to use this more. i.e. you can't set max width but no max height,

commit 7195bda7a24cc7abbb19ffeccce56d2ad1bc0a8d
Author: Adam Wolf <adam@travefy.com>
Date:   Sun Dec 29 13:08:34 2024 -0600

    chore: add missing case in switch statement

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index a17b18a2..8f5519a5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -180,7 +180,7 @@ pub const App = struct {
 
             .initial_position => switch (target) {
                 .app => {},
-                .surface => |surface| surface.rt_surface.setInitialWindowPosition(
+                .surface => |surface| try surface.rt_surface.setInitialWindowPosition(
                     value.x,
                     value.y,
                 ),
@@ -674,7 +674,7 @@ pub const Surface = struct {
     /// Set the initial window position. This is called exactly once at
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
-    fn setInitialWindowPosition(self: *const Surface, x: i32, y: i32) void {
+    fn setInitialWindowPosition(self: *const Surface, x: i32, y: i32) !void {
         log.debug("setting initial window position ({},{})", .{ x, y });
 
         self.window.setPos(.{ .x = x, .y = y });

commit 970e45559b4e0a6677bcc5cf5b77311bd48b8d21
Author: Adam Wolf <adam@travefy.com>
Date:   Mon Dec 30 07:39:56 2024 -0600

    apprt/glfw: handle setting initial window position when window is
    created

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8f5519a5..3481e483 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -149,10 +149,14 @@ pub const App = struct {
         value: apprt.Action.Value(action),
     ) !void {
         switch (action) {
-            .new_window => _ = try self.newSurface(switch (target) {
-                .app => null,
-                .surface => |v| v,
-            }),
+            .new_window => {
+                var surface = try self.newSurface(switch (target) {
+                    .app => null,
+                    .surface => |v| v,
+                });
+
+                try surface.setInitialWindowPosition(self.config.@"window-position-x", self.config.@"window-position-y");
+            },
 
             .new_tab => try self.newTab(switch (target) {
                 .app => null,
@@ -178,14 +182,6 @@ pub const App = struct {
                 ),
             },
 
-            .initial_position => switch (target) {
-                .app => {},
-                .surface => |surface| try surface.rt_surface.setInitialWindowPosition(
-                    value.x,
-                    value.y,
-                ),
-            },
-
             .toggle_fullscreen => self.toggleFullscreen(target),
 
             .open_config => try configpkg.edit.open(self.app.alloc),
@@ -674,10 +670,12 @@ pub const Surface = struct {
     /// Set the initial window position. This is called exactly once at
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
-    fn setInitialWindowPosition(self: *const Surface, x: i32, y: i32) !void {
-        log.debug("setting initial window position ({},{})", .{ x, y });
+    fn setInitialWindowPosition(self: *const Surface, x: ?i16, y: ?i16) !void {
+        const start_position_x = x orelse return;
+        const start_position_y = y orelse return;
 
-        self.window.setPos(.{ .x = x, .y = y });
+        log.debug("setting initial window position ({},{})", .{ start_position_x, start_position_y });
+        self.window.setPos(.{ .x = start_position_x, .y = start_position_y });
     }
 
     /// Set the size limits of the window.

commit f9250e28b52c779d154fbf13db74b418e74c172c
Author: Adam Wolf <adam@travefy.com>
Date:   Tue Dec 31 10:35:23 2024 -0600

    chore: rename window-position-{x,y} to window-initial-position-{x,y}

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 3481e483..5f48e0dd 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -155,7 +155,7 @@ pub const App = struct {
                     .surface => |v| v,
                 });
 
-                try surface.setInitialWindowPosition(self.config.@"window-position-x", self.config.@"window-position-y");
+                try surface.setInitialWindowPosition(self.config.@"window-initial-position-x", self.config.@"window-initial-position-y");
             },
 
             .new_tab => try self.newTab(switch (target) {

commit 29b96be84fb3e1498172e02cdc42a481b4e2e998
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Jan 2 13:04:30 2025 -0800

    tweaks to window position

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 5f48e0dd..3fbef0f2 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -149,14 +149,10 @@ pub const App = struct {
         value: apprt.Action.Value(action),
     ) !void {
         switch (action) {
-            .new_window => {
-                var surface = try self.newSurface(switch (target) {
-                    .app => null,
-                    .surface => |v| v,
-                });
-
-                try surface.setInitialWindowPosition(self.config.@"window-initial-position-x", self.config.@"window-initial-position-y");
-            },
+            .new_window => _ = try self.newSurface(switch (target) {
+                .app => null,
+                .surface => |v| v,
+            }),
 
             .new_tab => try self.newTab(switch (target) {
                 .app => null,
@@ -514,6 +510,13 @@ pub const Surface = struct {
         ) orelse return glfw.mustGetErrorCode();
         errdefer win.destroy();
 
+        // Setup our
+        setInitialWindowPosition(
+            win,
+            app.config.@"window-position-x",
+            app.config.@"window-position-y",
+        );
+
         // Get our physical DPI - debug only because we don't have a use for
         // this but the logging of it may be useful
         if (builtin.mode == .Debug) {
@@ -670,12 +673,12 @@ pub const Surface = struct {
     /// Set the initial window position. This is called exactly once at
     /// surface initialization time. This may be called before "self"
     /// is fully initialized.
-    fn setInitialWindowPosition(self: *const Surface, x: ?i16, y: ?i16) !void {
+    fn setInitialWindowPosition(win: glfw.Window, x: ?i16, y: ?i16) void {
         const start_position_x = x orelse return;
         const start_position_y = y orelse return;
 
         log.debug("setting initial window position ({},{})", .{ start_position_x, start_position_y });
-        self.window.setPos(.{ .x = start_position_x, .y = start_position_y });
+        win.setPos(.{ .x = start_position_x, .y = start_position_y });
     }
 
     /// Set the size limits of the window.

commit e8811ac6fb0063887adcaa58892a76e77a5c180c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Sat Jan 4 07:10:07 2025 -0800

    Move app quit to apprt action
    
    This changes quit signaling from a boolean return from core app `tick()`
    to an apprt action. This simplifies the API and conceptually makes more
    sense to me now.
    
    This wasn't done just for that; this change was also needed so that
    macOS can quit cleanly while fixing #4540 since we may no longer trigger
    menu items. I wanted to split this out into a separate commit/PR because
    it adds complexity making the diff harder to read.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 3fbef0f2..c9146406 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -35,6 +35,10 @@ pub const App = struct {
     app: *CoreApp,
     config: Config,
 
+    /// Flips to true to quit on the next event loop tick. This
+    /// never goes false and forces the event loop to exit.
+    quit: bool = false,
+
     /// Mac-specific state.
     darwin: if (Darwin.enabled) Darwin else void,
 
@@ -124,8 +128,10 @@ pub const App = struct {
             glfw.waitEvents();
 
             // Tick the terminal app
-            const should_quit = try self.app.tick(self);
-            if (should_quit or self.app.surfaces.items.len == 0) {
+            try self.app.tick(self);
+
+            // If the tick caused us to quit, then we're done.
+            if (self.quit or self.app.surfaces.items.len == 0) {
                 for (self.app.surfaces.items) |surface| {
                     surface.close(false);
                 }
@@ -149,6 +155,8 @@ pub const App = struct {
         value: apprt.Action.Value(action),
     ) !void {
         switch (action) {
+            .quit => self.quit = true,
+
             .new_window => _ = try self.newSurface(switch (target) {
                 .app => null,
                 .surface => |v| v,

commit 306c7ea2beef0f8b195fbd73d5c044180cc33368
Author: Sabarigirish Manikandan <68274755+lg28literconvectionmicrowaveoven@users.noreply.github.com>
Date:   Thu Jan 9 00:37:00 2025 +0530

    close_tab keybind (gtk apprt only) (#4033)
    
    Title. Adds a close_tab keybind that essentially behaves the exact same
    as clicking the tab close button on the tab bar.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c9146406..8094baeb 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -218,6 +218,7 @@ pub const App = struct {
             .toggle_split_zoom,
             .present_terminal,
             .close_all_windows,
+            .close_tab,
             .toggle_tab_overview,
             .toggle_window_decorations,
             .toggle_quick_terminal,

commit 8102fddceb7e2c1bea1c8901977f9cab38a25618
Author: Adam Wolf <adam@travefy.com>
Date:   Fri Jan 10 22:42:41 2025 -0600

    apprt/gtk: add toggle_maximize keybind and window-maximize config option

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 8094baeb..686a70dd 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -237,6 +237,7 @@ pub const App = struct {
             .color_change,
             .pwd,
             .config_change,
+            .toggle_maximize,
             => log.info("unimplemented action={}", .{action}),
         }
     }

commit 56ea6c406c155a48947274cd871ae274e654c957
Author: Leah Amelia Chen <hi@pluie.me>
Date:   Sun Feb 9 19:52:09 2025 +0100

    gtk(x11): set `WINDOWID` env var for subprocesses
    
    `WINDOWID` is the conventional environment variable for scripts that
    want to know the X11 window ID of the terminal, so that it may call
    tools like `xprop` or `xdotool`. We already know the window ID for
    window protocol handling, so we might as well throw this in for
    convenience.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 686a70dd..729decc0 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -874,6 +874,11 @@ pub const Surface = struct {
         };
     }
 
+    pub fn defaultTermioEnv(self: *Surface) !?std.process.EnvMap {
+        _ = self;
+        return null;
+    }
+
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {
         _ = width;
         _ = height;

commit 4ad749607aaafdba457aa21e5a5645c19976b341
Author: Jeffrey C. Ollie <jeff@ocjtech.us>
Date:   Sat Feb 8 15:56:29 2025 -0600

    core: performAction now returns a bool
    
    This is to facilitate the `performable:` prefix on keybinds that are
    implemented using app runtime actions.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 729decc0..bcb7ee5b 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -147,13 +147,14 @@ pub const App = struct {
         glfw.postEmptyEvent();
     }
 
-    /// Perform a given action.
+    /// Perform a given action. Returns `true` if the action was able to be
+    /// performed, `false` otherwise.
     pub fn performAction(
         self: *App,
         target: apprt.Target,
         comptime action: apprt.Action.Key,
         value: apprt.Action.Value(action),
-    ) !void {
+    ) !bool {
         switch (action) {
             .quit => self.quit = true,
 
@@ -240,6 +241,8 @@ pub const App = struct {
             .toggle_maximize,
             => log.info("unimplemented action={}", .{action}),
         }
+
+        return true;
     }
 
     /// Reload the configuration. This should return the new configuration.

commit f26c96d51b4f8add3ccd61fc48d6226dade437dd
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Feb 11 16:52:58 2025 -0800

    apprt/glfw: return false for unimplemented actions

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index bcb7ee5b..cb034cd8 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -239,7 +239,10 @@ pub const App = struct {
             .pwd,
             .config_change,
             .toggle_maximize,
-            => log.info("unimplemented action={}", .{action}),
+            => {
+                log.info("unimplemented action={}", .{action});
+                return false;
+            },
         }
 
         return true;

commit 1fea8028a3b303cce50dd7173ccace683cf0b877
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Feb 13 12:24:34 2025 -0800

    apprt: require envmap for exec-based termio
    
    Supercedes #5726

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index cb034cd8..39c6e058 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -880,9 +880,8 @@ pub const Surface = struct {
         };
     }
 
-    pub fn defaultTermioEnv(self: *Surface) !?std.process.EnvMap {
-        _ = self;
-        return null;
+    pub fn defaultTermioEnv(self: *Surface) !std.process.EnvMap {
+        return try internal_os.getEnvMap(self.app.app.alloc);
     }
 
     fn sizeCallback(window: glfw.Window, width: i32, height: i32) void {

commit a581955b9b7622f07e94b1736d2a26511a12e0fa
Author: Aswin M Prabhu <aswinmprabhu@gmail.com>
Date:   Wed Jan 1 01:01:42 2025 +0530

    Add tab title rename feature to macos

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 39c6e058..531269ee 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -239,6 +239,7 @@ pub const App = struct {
             .pwd,
             .config_change,
             .toggle_maximize,
+            .prompt_title,
             => {
                 log.info("unimplemented action={}", .{action});
                 return false;

commit 17cae57f510cd9f11ca83cec3f24f3563a2674ae
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Feb 28 15:25:14 2025 -0800

    Introduce `reset_window_size` keybinding and apprt action
    
    Related to #6035
    
    This implements the keybind/action portion of #5974 so that this can
    have a binding and so that other apprts can respond to this and
    implement it this way.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 531269ee..bc4d32bd 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -240,6 +240,7 @@ pub const App = struct {
             .config_change,
             .toggle_maximize,
             .prompt_title,
+            .reset_window_size,
             => {
                 log.info("unimplemented action={}", .{action});
                 return false;

commit 9ed76729abfa0fd57feb9b330559a4d3dbeabd39
Author: Leah Amelia Chen <hi@pluie.me>
Date:   Thu Feb 13 20:12:12 2025 +0100

    gtk: add separate close_window apprt action
    
    For *some* reason we have a binding for close_window but it merely closes
    the surface and not the entire window. That is not only misleading but
    also just wrong. Now we make a separate apprt action for close_window
    that would make it show a close confirmation prompt identical to as if
    the user had clicked the (X) button on the window titlebar.

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index bc4d32bd..935ca85a 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -219,6 +219,7 @@ pub const App = struct {
             .toggle_split_zoom,
             .present_terminal,
             .close_all_windows,
+            .close_window,
             .close_tab,
             .toggle_tab_overview,
             .toggle_window_decorations,

commit 0f4d2bb2375c707182dba8cf2dd7723a2e918e79
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 12 09:55:46 2025 -0700

    Lots of 0.14 changes

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 935ca85a..10835fb5 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -25,7 +25,7 @@ const Config = @import("../config.zig").Config;
 
 // Get native API access on certain platforms so we can do more customization.
 const glfwNative = glfw.Native(.{
-    .cocoa = builtin.target.isDarwin(),
+    .cocoa = builtin.target.os.tag.isDarwin(),
     .x11 = builtin.os.tag == .linux,
 });
 
@@ -45,7 +45,7 @@ pub const App = struct {
     pub const Options = struct {};
 
     pub fn init(core_app: *CoreApp, _: Options) !App {
-        if (comptime builtin.target.isDarwin()) {
+        if (comptime builtin.target.os.tag.isDarwin()) {
             log.warn("WARNING WARNING WARNING: GLFW ON MAC HAS BUGS.", .{});
             log.warn("You should use the AppKit-based app instead. The official download", .{});
             log.warn("is properly built and available from GitHub. If you're building from", .{});
@@ -439,7 +439,7 @@ pub const App = struct {
     /// Mac and the artifact is a standalone exe. We don't target libs because
     /// the embedded API doesn't do windowing.
     const Darwin = struct {
-        const enabled = builtin.target.isDarwin() and build_config.artifact == .exe;
+        const enabled = builtin.target.os.tag.isDarwin() and build_config.artifact == .exe;
 
         tabbing_id: *macos.foundation.String,
 
@@ -767,7 +767,7 @@ pub const Surface = struct {
 
     /// Set the shape of the cursor.
     fn setMouseShape(self: *Surface, shape: terminal.MouseShape) !void {
-        if ((comptime builtin.target.isDarwin()) and
+        if ((comptime builtin.target.os.tag.isDarwin()) and
             !internal_os.macos.isAtLeastVersion(13, 0, 0))
         {
             // We only set our cursor if we're NOT on Mac, or if we are then the
@@ -925,7 +925,7 @@ pub const Surface = struct {
 
         // On macOS we need to also disable some modifiers because
         // alt+key consumes the alt.
-        if (comptime builtin.target.isDarwin()) {
+        if (comptime builtin.target.os.tag.isDarwin()) {
             // For GLFW, we say we always consume alt because
             // GLFW doesn't have a way to disable the alt key.
             key_event.consumed_mods.alt = true;

commit 1f6aa0e90d5bd63005864b4f22c0df55143f3d2e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 12 12:45:30 2025 -0700

    apprt/glfw: move darwin enabled const out to top-level

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 10835fb5..998f8802 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -29,6 +29,10 @@ const glfwNative = glfw.Native(.{
     .x11 = builtin.os.tag == .linux,
 });
 
+/// True if darwin-specific logic is enabled
+const darwin_enabled = builtin.target.os.tag.isDarwin() and
+    build_config.artifact == .exe;
+
 const log = std.log.scoped(.glfw);
 
 pub const App = struct {
@@ -40,7 +44,7 @@ pub const App = struct {
     quit: bool = false,
 
     /// Mac-specific state.
-    darwin: if (Darwin.enabled) Darwin else void,
+    darwin: if (darwin_enabled) Darwin else void,
 
     pub const Options = struct {};
 
@@ -66,8 +70,8 @@ pub const App = struct {
         glfw.setErrorCallback(glfwErrorCallback);
 
         // Mac-specific state. For example, on Mac we enable window tabbing.
-        var darwin = if (Darwin.enabled) try Darwin.init() else {};
-        errdefer if (Darwin.enabled) darwin.deinit();
+        var darwin = if (darwin_enabled) try Darwin.init() else {};
+        errdefer if (darwin_enabled) darwin.deinit();
 
         // Load our configuration
         var config = try Config.load(core_app.alloc);
@@ -338,7 +342,7 @@ pub const App = struct {
 
     /// Create a new tab in the parent surface.
     fn newTab(self: *App, parent_: ?*CoreSurface) !void {
-        if (!Darwin.enabled) {
+        if (comptime !darwin_enabled) {
             log.warn("tabbing is not supported on this platform", .{});
             return;
         }
@@ -439,8 +443,6 @@ pub const App = struct {
     /// Mac and the artifact is a standalone exe. We don't target libs because
     /// the embedded API doesn't do windowing.
     const Darwin = struct {
-        const enabled = builtin.target.os.tag.isDarwin() and build_config.artifact == .exe;
-
         tabbing_id: *macos.foundation.String,
 
         pub fn init() !Darwin {
@@ -554,7 +556,7 @@ pub const Surface = struct {
         }
 
         // On Mac, enable window tabbing
-        if (App.Darwin.enabled) {
+        if (comptime darwin_enabled) {
             const NSWindowTabbingMode = enum(usize) { automatic = 0, preferred = 1, disallowed = 2 };
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(win).?);
 
@@ -630,7 +632,7 @@ pub const Surface = struct {
         // Clean up our core surface so that all the rendering and IO stop.
         self.core_surface.deinit();
 
-        if (App.Darwin.enabled) {
+        if (comptime darwin_enabled) {
             const nswindow = objc.Object.fromId(glfwNative.getCocoaWindow(self.window).?);
             const tabgroup = nswindow.getProperty(objc.Object, "tabGroup");
             const windows = tabgroup.getProperty(objc.Object, "windows");

commit a0760cabd65fd4da46c6832bd44318c9526842d4
Author: Leah Amelia Chen <hi@pluie.me>
Date:   Mon Apr 14 21:43:02 2025 +0800

    gtk: implement bell
    
    Co-authored-by: Jeffrey C. Ollie <jeff@ocjtech.us>

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index 998f8802..c5ee802c 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -246,6 +246,7 @@ pub const App = struct {
             .toggle_maximize,
             .prompt_title,
             .reset_window_size,
+            .ring_bell,
             => {
                 log.info("unimplemented action={}", .{action});
                 return false;

commit 6d2685b5a2353e95f697f4be9c1e603a4c886211
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Apr 21 09:52:21 2025 -0700

    add toggle command palette binding

diff --git a/src/apprt/glfw.zig b/src/apprt/glfw.zig
index c5ee802c..66b99405 100644
--- a/src/apprt/glfw.zig
+++ b/src/apprt/glfw.zig
@@ -228,6 +228,7 @@ pub const App = struct {
             .toggle_tab_overview,
             .toggle_window_decorations,
             .toggle_quick_terminal,
+            .toggle_command_palette,
             .toggle_visibility,
             .goto_tab,
             .move_tab,

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    