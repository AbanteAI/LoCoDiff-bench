<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: src/font/Collection.zig - Gemini 2.5 Pro</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: src/font/Collection.zig</h1>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview-03-25/ghostty_src_font_Collection.zig.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- src/font/Collection.zig

commit 72d59956d5a0526d56394acb38203a6d74deffc8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 10:24:56 2024 -0700

    font: [broken] working on extracting Collection from Group

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
new file mode 100644
index 00000000..09e6c6c0
--- /dev/null
+++ b/src/font/Collection.zig
@@ -0,0 +1,264 @@
+//! A font collection is a list of faces of different styles. The list is
+//! ordered by priority (per style). All fonts in a collection share the same
+//! size so they can be used interchangeably in cases a glyph is missing in one
+//! and present in another.
+const Collection = @This();
+
+const std = @import("std");
+const Allocator = std.mem.Allocator;
+const font = @import("main.zig");
+const DeferredFace = font.DeferredFace;
+const Face = font.Face;
+const Library = font.Library;
+const Presentation = font.Presentation;
+const Style = font.Style;
+
+/// The available faces we have. This shouldn't be modified manually.
+/// Instead, use the functions available on Collection.
+faces: StyleArray,
+
+/// Initialize an empty collection.
+pub fn init(alloc: Allocator) !Collection {
+    // Initialize our styles array, preallocating some space that is
+    // likely to be used.
+    var faces = StyleArray.initFill(.{});
+    for (&faces.values) |*list| try list.ensureTotalCapacityPrecise(alloc, 2);
+    return .{ .faces = faces };
+}
+
+pub fn deinit(self: *Collection, alloc: Allocator) void {
+    var it = self.faces.iterator();
+    while (it.next()) |entry| {
+        for (entry.value.items) |*item| item.deinit();
+        entry.value.deinit(alloc);
+    }
+}
+
+pub const AddError = Allocator.Error || error{
+    CollectionFull,
+};
+
+/// Add a face to the collection for the given style. This face will be added
+/// next in priority if others exist already, i.e. it'll be the _last_ to be
+/// searched for a glyph in that list.
+///
+/// The collection takes ownership of the face. The face will be deallocated
+/// when the collection is deallocated.
+///
+/// If a loaded face is added to the collection, it should be the same
+/// size as all the other faces in the collection. This function will not
+/// verify or modify the size until the size of the entire collection is
+/// changed.
+pub fn add(
+    self: *Collection,
+    alloc: Allocator,
+    style: Style,
+    face: Entry,
+) AddError!Index {
+    const list = self.faces.getPtr(style);
+
+    // We have some special indexes so we must never pass those.
+    if (list.items.len >= Index.Special.start - 1)
+        return error.CollectionFull;
+
+    const idx = list.items.len;
+    try list.append(alloc, face);
+    return .{ .style = style, .idx = @intCast(idx) };
+}
+
+/// Packed array of all Style enum cases mapped to a growable list of faces.
+///
+/// We use this data structure because there aren't many styles and all
+/// styles are typically loaded for a terminal session. The overhead per
+/// style even if it is not used or barely used is minimal given the
+/// small style count.
+const StyleArray = std.EnumArray(Style, std.ArrayListUnmanaged(Entry));
+
+/// A entry in a collection can be deferred or loaded. A deferred face
+/// is not yet fully loaded and only represents the font descriptor
+/// and usually uses less resources. A loaded face is fully parsed,
+/// ready to rasterize, and usually uses more resources than a
+/// deferred version.
+///
+/// A face can also be a "fallback" variant that is still either
+/// deferred or loaded. Today, there is only one difference between
+/// fallback and non-fallback (or "explicit") faces: the handling
+/// of emoji presentation.
+///
+/// For explicit faces, when an explicit emoji presentation is
+/// not requested, we will use any glyph for that codepoint found
+/// even if the font presentation does not match the UCD
+/// (Unicode Character Database) value. When an explicit presentation
+/// is requested (via either VS15/V16), that is always honored.
+/// The reason we do this is because we assume that if a user
+/// explicitly chosen a font face (hence it is "explicit" and
+/// not "fallback"), they want to use any glyphs possible within that
+/// font face. Fallback fonts on the other hand are picked as a
+/// last resort, so we should prefer exactness if possible.
+pub const Entry = union(enum) {
+    deferred: DeferredFace, // Not loaded
+    loaded: Face, // Loaded, explicit use
+
+    // The same as deferred/loaded but fallback font semantics (see large
+    // comment above Entry).
+    fallback_deferred: DeferredFace,
+    fallback_loaded: Face,
+
+    pub fn deinit(self: *Entry) void {
+        switch (self.*) {
+            inline .deferred,
+            .loaded,
+            .fallback_deferred,
+            .fallback_loaded,
+            => |*v| v.deinit(),
+        }
+    }
+
+    /// True if this face satisfies the given codepoint and presentation.
+    fn hasCodepoint(self: Entry, cp: u32, p_mode: PresentationMode) bool {
+        return switch (self) {
+            // Non-fallback fonts require explicit presentation matching but
+            // otherwise don't care about presentation
+            .deferred => |v| switch (p_mode) {
+                .explicit => |p| v.hasCodepoint(cp, p),
+                .default, .any => v.hasCodepoint(cp, null),
+            },
+
+            .loaded => |face| switch (p_mode) {
+                .explicit => |p| face.presentation == p and face.glyphIndex(cp) != null,
+                .default, .any => face.glyphIndex(cp) != null,
+            },
+
+            // Fallback fonts require exact presentation matching.
+            .fallback_deferred => |v| switch (p_mode) {
+                .explicit, .default => |p| v.hasCodepoint(cp, p),
+                .any => v.hasCodepoint(cp, null),
+            },
+
+            .fallback_loaded => |face| switch (p_mode) {
+                .explicit,
+                .default,
+                => |p| face.presentation == p and face.glyphIndex(cp) != null,
+                .any => face.glyphIndex(cp) != null,
+            },
+        };
+    }
+};
+
+/// The requested presentation for a codepoint.
+pub const PresentationMode = union(enum) {
+    /// The codepoint has an explicit presentation that is required,
+    /// i.e. VS15/V16.
+    explicit: Presentation,
+
+    /// The codepoint has no explicit presentation and we should use
+    /// the presentation from the UCd.
+    default: Presentation,
+
+    /// The codepoint can be any presentation.
+    any: void,
+};
+
+/// This represents a specific font in the collection.
+///
+/// The backing size of this packed struct represents the total number
+/// of possible usable fonts in a collection. And the number of bits
+/// used for the index and not the style represents the total number
+/// of possible usable fonts for a given style.
+///
+/// The goal is to keep the size of this struct as small as practical. We
+/// accept the limitations that this imposes so long as they're reasonable.
+/// At the time of writing this comment, this is a 16-bit struct with 13
+/// bits used for the index, supporting up to 8192 fonts per style. This
+/// seems more than reasonable. There are synthetic scenarios where this
+/// could be a limitation but I can't think of any that are practical.
+///
+/// If you somehow need more fonts per style, you can increase the size of
+/// the Backing type and everything should just work fine.
+pub const Index = packed struct(Index.Backing) {
+    const Backing = u16;
+    const backing_bits = @typeInfo(Backing).Int.bits;
+
+    /// The number of bits we use for the index.
+    const idx_bits = backing_bits - @typeInfo(@typeInfo(Style).Enum.tag_type).Int.bits;
+    pub const IndexInt = @Type(.{ .Int = .{ .signedness = .unsigned, .bits = idx_bits } });
+
+    /// The special-case fonts that we support.
+    pub const Special = enum(IndexInt) {
+        // We start all special fonts at this index so they can be detected.
+        pub const start = std.math.maxInt(IndexInt);
+
+        /// Sprite drawing, this is rendered JIT using 2D graphics APIs.
+        sprite = start,
+    };
+
+    style: Style = .regular,
+    idx: IndexInt = 0,
+
+    /// Initialize a special font index.
+    pub fn initSpecial(v: Special) Index {
+        return .{ .style = .regular, .idx = @intFromEnum(v) };
+    }
+
+    /// Convert to int
+    pub fn int(self: Index) Backing {
+        return @bitCast(self);
+    }
+
+    /// Returns true if this is a "special" index which doesn't map to
+    /// a real font face. We can still render it but there is no face for
+    /// this font.
+    pub fn special(self: Index) ?Special {
+        if (self.idx < Special.start) return null;
+        return @enumFromInt(self.idx);
+    }
+
+    test {
+        // We never want to take up more than a byte since font indexes are
+        // everywhere so if we increase the size of this we'll dramatically
+        // increase our memory usage.
+        try std.testing.expectEqual(@sizeOf(Backing), @sizeOf(Index));
+
+        // Just so we're aware when this changes. The current maximum number
+        // of fonts for a style is 13 bits or 8192 fonts.
+        try std.testing.expectEqual(13, idx_bits);
+    }
+};
+
+test init {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+}
+
+test "add full" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+
+    for (0..Index.Special.start - 1) |_| {
+        _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+            lib,
+            testFont,
+            .{ .size = .{ .points = 12 } },
+        ) });
+    }
+
+    try testing.expectError(error.CollectionFull, c.add(
+        alloc,
+        .regular,
+        .{ .loaded = try Face.init(
+            lib,
+            testFont,
+            .{ .size = .{ .points = 12 } },
+        ) },
+    ));
+}

commit 833d54e441f3423f7133609ed39d56d3b15a47e5
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 11:07:37 2024 -0700

    font: Collection has load options

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 09e6c6c0..162ec849 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -8,8 +8,10 @@ const std = @import("std");
 const Allocator = std.mem.Allocator;
 const font = @import("main.zig");
 const DeferredFace = font.DeferredFace;
+const DesiredSize = font.face.DesiredSize;
 const Face = font.Face;
 const Library = font.Library;
+const Metrics = font.face.Metrics;
 const Presentation = font.Presentation;
 const Style = font.Style;
 
@@ -17,12 +19,19 @@ const Style = font.Style;
 /// Instead, use the functions available on Collection.
 faces: StyleArray,
 
+/// The load options for deferred faces in the face list. If this
+/// is not set, then deferred faces will not be loaded. Attempting to
+/// add a deferred face will result in an error.
+load_options: ?LoadOptions = null,
+
 /// Initialize an empty collection.
-pub fn init(alloc: Allocator) !Collection {
+pub fn init(
+    alloc: Allocator,
+) !Collection {
     // Initialize our styles array, preallocating some space that is
     // likely to be used.
     var faces = StyleArray.initFill(.{});
-    for (&faces.values) |*list| try list.ensureTotalCapacityPrecise(alloc, 2);
+    for (&faces.values) |*v| try v.ensureTotalCapacityPrecise(alloc, 2);
     return .{ .faces = faces };
 }
 
@@ -32,10 +41,13 @@ pub fn deinit(self: *Collection, alloc: Allocator) void {
         for (entry.value.items) |*item| item.deinit();
         entry.value.deinit(alloc);
     }
+
+    //self.load_options.deinit(alloc);
 }
 
 pub const AddError = Allocator.Error || error{
     CollectionFull,
+    DeferredLoadingUnavailable,
 };
 
 /// Add a face to the collection for the given style. This face will be added
@@ -61,11 +73,47 @@ pub fn add(
     if (list.items.len >= Index.Special.start - 1)
         return error.CollectionFull;
 
+    // If this is deferred and we don't have load options, we can't.
+    if (face.isDeferred() and self.load_options == null)
+        return error.DeferredLoadingUnavailable;
+
     const idx = list.items.len;
     try list.append(alloc, face);
     return .{ .style = style, .idx = @intCast(idx) };
 }
 
+/// Return the Face represented by a given Index. The returned pointer
+/// is only valid as long as this collection is not modified.
+///
+/// This will initialize the face if it is deferred and not yet loaded,
+/// which can fail.
+pub fn getFace(self: *Collection, index: Index) !*Face {
+    if (index.special() != null) return error.SpecialHasNoFace;
+    const list = self.faces.getPtr(index.style);
+    const item = &list.items[index.idx];
+    return switch (item.*) {
+        inline .deferred, .fallback_deferred => |*d, tag| deferred: {
+            const opts = self.load_options orelse
+                return error.DeferredLoadingUnavailable;
+            const face = try d.load(opts.library, opts.faceOptions());
+            d.deinit();
+            item.* = switch (tag) {
+                .deferred => .{ .loaded = face },
+                .fallback_deferred => .{ .fallback_loaded = face },
+                else => unreachable,
+            };
+
+            break :deferred switch (tag) {
+                .deferred => &item.loaded,
+                .fallback_deferred => &item.fallback_loaded,
+                else => unreachable,
+            };
+        },
+
+        .loaded, .fallback_loaded => |*f| f,
+    };
+}
+
 /// Packed array of all Style enum cases mapped to a growable list of faces.
 ///
 /// We use this data structure because there aren't many styles and all
@@ -74,6 +122,32 @@ pub fn add(
 /// small style count.
 const StyleArray = std.EnumArray(Style, std.ArrayListUnmanaged(Entry));
 
+/// Load options are used to configure all the details a Collection
+/// needs to load deferred faces.
+pub const LoadOptions = struct {
+    /// The library to use for loading faces. This is not owned by
+    /// the collection and can be used by multiple collections. When
+    /// deinitializing the collection, the library is not deinitialized.
+    library: Library,
+
+    /// The desired font size for all loaded faces.
+    size: DesiredSize = .{ .points = 12 },
+
+    /// The metric modifiers to use for all loaded faces. If this is
+    /// set then the memory is owned by the collection and will be
+    /// freed when the collection is deinitialized. The modifier set
+    /// must use the same allocator as the collection.
+    metric_modifiers: Metrics.ModifierSet = .{},
+
+    /// The options to use for loading faces.
+    fn faceOptions(self: *const LoadOptions) font.face.Options {
+        return .{
+            .size = self.size,
+            .metric_modifiers = &self.metric_modifiers,
+        };
+    }
+};
+
 /// A entry in a collection can be deferred or loaded. A deferred face
 /// is not yet fully loaded and only represents the font descriptor
 /// and usually uses less resources. A loaded face is fully parsed,
@@ -114,6 +188,14 @@ pub const Entry = union(enum) {
         }
     }
 
+    /// True if the entry is deferred.
+    fn isDeferred(self: Entry) bool {
+        return switch (self) {
+            .deferred, .fallback_deferred => true,
+            .loaded, .fallback_loaded => false,
+        };
+    }
+
     /// True if this face satisfies the given codepoint and presentation.
     fn hasCodepoint(self: Entry, cp: u32, p_mode: PresentationMode) bool {
         return switch (self) {
@@ -262,3 +344,43 @@ test "add full" {
         ) },
     ));
 }
+
+test "add deferred without loading options" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+
+    try testing.expectError(error.DeferredLoadingUnavailable, c.add(
+        alloc,
+        .regular,
+
+        // This can be undefined because it should never be accessed.
+        .{ .deferred = undefined },
+    ));
+}
+
+test getFace {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+
+    const idx = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    {
+        const face1 = try c.getFace(idx);
+        const face2 = try c.getFace(idx);
+        try testing.expectEqual(@intFromPtr(face1), @intFromPtr(face2));
+    }
+}

commit 0d0688404e39a96d4bfde378c32def5b88d9b229
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 11:13:36 2024 -0700

    font: Collection.getIndex

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 162ec849..a7e87d89 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -114,6 +114,31 @@ pub fn getFace(self: *Collection, index: Index) !*Face {
     };
 }
 
+/// Return the index of the font in this collection that contains
+/// the given codepoint, style, and presentation. If no font is found,
+/// null is returned.
+///
+/// This does not trigger font loading; deferred fonts can be
+/// searched for codepoints.
+pub fn getIndex(
+    self: *const Collection,
+    cp: u32,
+    style: Style,
+    p_mode: PresentationMode,
+) ?Index {
+    for (self.faces.get(style).items, 0..) |elem, i| {
+        if (elem.hasCodepoint(cp, p_mode)) {
+            return .{
+                .style = style,
+                .idx = @intCast(i),
+            };
+        }
+    }
+
+    // Not found
+    return null;
+}
+
 /// Packed array of all Style enum cases mapped to a growable list of faces.
 ///
 /// We use this data structure because there aren't many styles and all
@@ -384,3 +409,34 @@ test getFace {
         try testing.expectEqual(@intFromPtr(face1), @intFromPtr(face2));
     }
 }
+
+test getIndex {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    // Should find all visible ASCII
+    var i: u32 = 32;
+    while (i < 127) : (i += 1) {
+        const idx = c.getIndex(i, .regular, .{ .any = {} });
+        try testing.expect(idx != null);
+    }
+
+    // Should not find emoji
+    {
+        const idx = c.getIndex('ü•∏', .regular, .{ .any = {} });
+        try testing.expect(idx == null);
+    }
+}

commit 40b4183b1ffbf4d88b1060099c8549f2b40ca6d1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 11:16:50 2024 -0700

    font: Collection deinit

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index a7e87d89..64453fc3 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -42,7 +42,7 @@ pub fn deinit(self: *Collection, alloc: Allocator) void {
         entry.value.deinit(alloc);
     }
 
-    //self.load_options.deinit(alloc);
+    if (self.load_options) |*v| v.deinit(alloc);
 }
 
 pub const AddError = Allocator.Error || error{
@@ -164,6 +164,10 @@ pub const LoadOptions = struct {
     /// must use the same allocator as the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
+    pub fn deinit(self: *LoadOptions, alloc: Allocator) void {
+        self.metric_modifiers.deinit(alloc);
+    }
+
     /// The options to use for loading faces.
     fn faceOptions(self: *const LoadOptions) font.face.Options {
         return .{

commit 4d7085986407aac468877740494af8fd0e790a02
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 11:27:54 2024 -0700

    font: Collection autoItalicize

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 64453fc3..d9b88a1b 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -2,6 +2,17 @@
 //! ordered by priority (per style). All fonts in a collection share the same
 //! size so they can be used interchangeably in cases a glyph is missing in one
 //! and present in another.
+//!
+//! The purpose of a collection is to store a list of fonts by style
+//! and priority order. A collection does not handle searching for font
+//! callbacks, rasterization, etc.
+//!
+//! The collection can contain both loaded and deferred faces. Deferred faces
+//! typically use less memory while still providing some necessary information
+//! such as codepoint support, presentation, etc. This is useful for looking
+//! for fallback fonts as efficiently as possible. For example, when the glyph
+//! "X" is not found, we can quickly search through deferred fonts rather
+//! than loading the font completely.
 const Collection = @This();
 
 const std = @import("std");
@@ -15,6 +26,8 @@ const Metrics = font.face.Metrics;
 const Presentation = font.Presentation;
 const Style = font.Style;
 
+const log = std.log.scoped(.font_collection);
+
 /// The available faces we have. This shouldn't be modified manually.
 /// Instead, use the functions available on Collection.
 faces: StyleArray,
@@ -139,6 +152,57 @@ pub fn getIndex(
     return null;
 }
 
+/// Automatically create an italicized font from the regular
+/// font face if we don't have one already. If we already have
+/// an italicized font face, this does nothing.
+pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
+    // If we have an italic font, do nothing.
+    const italic_list = self.faces.getPtr(.italic);
+    if (italic_list.items.len > 0) return;
+
+    // Not all font backends support auto-italicization.
+    if (comptime !@hasDecl(Face, "italicize")) {
+        log.warn(
+            "no italic font face available, italics will not render",
+            .{},
+        );
+        return;
+    }
+
+    // Our regular font. If we have no regular font we also do nothing.
+    const regular = regular: {
+        const list = self.faces.get(.regular);
+        if (list.items.len == 0) return;
+
+        // Find our first font that is text. This will force
+        // loading any deferred faces but we only load them until
+        // we find a text face. A text face is almost always the
+        // first face in the list.
+        for (0..list.items.len) |i| {
+            const face = try self.getFace(.{
+                .style = .regular,
+                .idx = @intCast(i),
+            });
+            if (face.presentation == .text) break :regular face;
+        }
+
+        // No regular text face found.
+        return;
+    };
+
+    // We require loading options to auto-italicize.
+    const opts = self.load_options orelse return error.DeferredLoadingUnavailable;
+
+    // Try to italicize it.
+    const face = try regular.italicize(opts.faceOptions());
+    try italic_list.append(alloc, .{ .loaded = face });
+
+    var buf: [256]u8 = undefined;
+    if (face.name(&buf)) |name| {
+        log.info("font auto-italicized: {s}", .{name});
+    } else |_| {}
+}
+
 /// Packed array of all Style enum cases mapped to a growable list of faces.
 ///
 /// We use this data structure because there aren't many styles and all
@@ -444,3 +508,26 @@ test getIndex {
         try testing.expect(idx == null);
     }
 }
+
+test autoItalicize {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+    c.load_options = .{ .library = lib };
+
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) == null);
+    try c.autoItalicize(alloc);
+    try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) != null);
+}

commit bd479db09f2929ea3e0cb02803ecc18b03513b91
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 11:32:42 2024 -0700

    font: Collection setSize

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index d9b88a1b..e3ad969b 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -203,6 +203,31 @@ pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
     } else |_| {}
 }
 
+/// Update the size of all faces in the collection. This will
+/// also update the size in the load options for future deferred
+/// face loading.
+///
+/// This requires load options to be set.
+pub fn setSize(self: *Collection, size: DesiredSize) !void {
+    // Get a pointer to our options so we can modify the size.
+    const opts = if (self.load_options) |*v|
+        v
+    else
+        return error.DeferredLoadingUnavailable;
+    opts.size = size;
+
+    // Resize all our faces that are loaded
+    var it = self.faces.iterator();
+    while (it.next()) |entry| {
+        for (entry.value.items) |*elem| switch (elem.*) {
+            .deferred, .fallback_deferred => continue,
+            .loaded, .fallback_loaded => |*f| try f.setSize(
+                opts.faceOptions(),
+            ),
+        };
+    }
+}
+
 /// Packed array of all Style enum cases mapped to a growable list of faces.
 ///
 /// We use this data structure because there aren't many styles and all
@@ -531,3 +556,26 @@ test autoItalicize {
     try c.autoItalicize(alloc);
     try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) != null);
 }
+
+test setSize {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+    c.load_options = .{ .library = lib };
+
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    try testing.expectEqual(@as(u32, 12), c.load_options.?.size.points);
+    try c.setSize(.{ .points = 24 });
+    try testing.expectEqual(@as(u32, 24), c.load_options.?.size.points);
+}

commit 4eccd42f6b281e06038ac3d412586a239d27209e
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 14:59:54 2024 -0700

    font: CodepointResolver beginnings

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index e3ad969b..4d623967 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -5,7 +5,7 @@
 //!
 //! The purpose of a collection is to store a list of fonts by style
 //! and priority order. A collection does not handle searching for font
-//! callbacks, rasterization, etc.
+//! callbacks, rasterization, etc. For this, see CodepointResolver.
 //!
 //! The collection can contain both loaded and deferred faces. Deferred faces
 //! typically use less memory while still providing some necessary information
@@ -152,6 +152,24 @@ pub fn getIndex(
     return null;
 }
 
+/// Check if a specific font index has a specific codepoint. This does not
+/// necessarily force the font to load. The presentation value "p" will
+/// verify the Emoji representation matches if it is non-null. If "p" is
+/// null then any presentation will be accepted.
+pub fn hasCodepoint(
+    self: *const Collection,
+    index: Index,
+    cp: u32,
+    p: ?Presentation,
+) bool {
+    const list = self.faces.get(index.style);
+    if (index.idx >= list.items.len) return false;
+    return list.items[index.idx].hasCodepoint(
+        cp,
+        if (p) |v| .{ .explicit = v } else .{ .any = {} },
+    );
+}
+
 /// Automatically create an italicized font from the regular
 /// font face if we don't have one already. If we already have
 /// an italicized font face, this does nothing.
@@ -315,7 +333,11 @@ pub const Entry = union(enum) {
     }
 
     /// True if this face satisfies the given codepoint and presentation.
-    fn hasCodepoint(self: Entry, cp: u32, p_mode: PresentationMode) bool {
+    pub fn hasCodepoint(
+        self: Entry,
+        cp: u32,
+        p_mode: PresentationMode,
+    ) bool {
         return switch (self) {
             // Non-fallback fonts require explicit presentation matching but
             // otherwise don't care about presentation

commit b2541d24f19f3233f8a862f10dfa20d1e16cd5c9
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue Apr 2 19:32:03 2024 -0700

    font: CodepointResolver style disabling test

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 4d623967..f75356bc 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -18,6 +18,7 @@ const Collection = @This();
 const std = @import("std");
 const Allocator = std.mem.Allocator;
 const font = @import("main.zig");
+const options = font.options;
 const DeferredFace = font.DeferredFace;
 const DesiredSize = font.face.DesiredSize;
 const Face = font.Face;
@@ -160,14 +161,11 @@ pub fn hasCodepoint(
     self: *const Collection,
     index: Index,
     cp: u32,
-    p: ?Presentation,
+    p_mode: PresentationMode,
 ) bool {
     const list = self.faces.get(index.style);
     if (index.idx >= list.items.len) return false;
-    return list.items[index.idx].hasCodepoint(
-        cp,
-        if (p) |v| .{ .explicit = v } else .{ .any = {} },
-    );
+    return list.items[index.idx].hasCodepoint(cp, p_mode);
 }
 
 /// Automatically create an italicized font from the regular
@@ -601,3 +599,50 @@ test setSize {
     try c.setSize(.{ .points = 24 });
     try testing.expectEqual(@as(u32, 24), c.load_options.?.size.points);
 }
+
+test hasCodepoint {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = @import("test.zig").fontRegular;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+    c.load_options = .{ .library = lib };
+
+    const idx = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    try testing.expect(c.hasCodepoint(idx, 'A', .{ .any = {} }));
+    try testing.expect(!c.hasCodepoint(idx, 'ü•∏', .{ .any = {} }));
+}
+
+test "hasCodepoint emoji default graphical" {
+    if (options.backend != .fontconfig_freetype) return error.SkipZigTest;
+
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testEmoji = @import("test.zig").fontEmoji;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = try init(alloc);
+    defer c.deinit(alloc);
+    c.load_options = .{ .library = lib };
+
+    const idx = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testEmoji,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    try testing.expect(!c.hasCodepoint(idx, 'A', .{ .any = {} }));
+    try testing.expect(c.hasCodepoint(idx, 'ü•∏', .{ .any = {} }));
+    // TODO(fontmem): test explicit/implicit
+}

commit 4a29da35257a4e8d823bc1229dd17a42ea5ef163
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 5 15:15:30 2024 -0700

    font: SharedGridSet clarify memory ownership

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index f75356bc..89d4aee4 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -263,18 +263,17 @@ pub const LoadOptions = struct {
     /// The desired font size for all loaded faces.
     size: DesiredSize = .{ .points = 12 },
 
-    /// The metric modifiers to use for all loaded faces. If this is
-    /// set then the memory is owned by the collection and will be
-    /// freed when the collection is deinitialized. The modifier set
-    /// must use the same allocator as the collection.
+    /// The metric modifiers to use for all loaded faces. The memory
+    /// for this is owned by the user and is not freed by the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
     pub fn deinit(self: *LoadOptions, alloc: Allocator) void {
-        self.metric_modifiers.deinit(alloc);
+        _ = self;
+        _ = alloc;
     }
 
     /// The options to use for loading faces.
-    fn faceOptions(self: *const LoadOptions) font.face.Options {
+    pub fn faceOptions(self: *const LoadOptions) font.face.Options {
         return .{
             .size = self.size,
             .metric_modifiers = &self.metric_modifiers,

commit b77513de1a6bcfd9d23fc35bcfb5cb86e8cabaaf
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Apr 5 21:48:53 2024 -0700

    font/harfbuzz: work with new font structures

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 89d4aee4..38f4b92f 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -554,6 +554,8 @@ test getIndex {
 }
 
 test autoItalicize {
+    if (comptime !@hasDecl(Face, "italicize")) return error.SkipZigTest;
+
     const testing = std.testing;
     const alloc = testing.allocator;
     const testFont = @import("test.zig").fontRegular;

commit 326659c522536e9215afbc64feb9e6015d5e7fa8
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Tue May 28 20:09:05 2024 -0700

    font: handle presentation at glyph layer

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 38f4b92f..86231b83 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -190,16 +190,23 @@ pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
         const list = self.faces.get(.regular);
         if (list.items.len == 0) return;
 
-        // Find our first font that is text. This will force
-        // loading any deferred faces but we only load them until
-        // we find a text face. A text face is almost always the
-        // first face in the list.
+        // Find our first regular face that has text glyphs.
         for (0..list.items.len) |i| {
             const face = try self.getFace(.{
                 .style = .regular,
                 .idx = @intCast(i),
             });
-            if (face.presentation == .text) break :regular face;
+
+            // We have two conditionals here. The color check is obvious:
+            // we want to auto-italicize a normal text font. The second
+            // check is less obvious... for mixed color/non-color fonts, we
+            // accept the regular font if it has basic ASCII. This may not
+            // be strictly correct (especially with international fonts) but
+            // it's a reasonable heuristic and the first case will match 99%
+            // of the time.
+            if (!face.hasColor() or face.glyphIndex('A') != null) {
+                break :regular face;
+            }
         }
 
         // No regular text face found.
@@ -344,7 +351,13 @@ pub const Entry = union(enum) {
             },
 
             .loaded => |face| switch (p_mode) {
-                .explicit => |p| face.presentation == p and face.glyphIndex(cp) != null,
+                .explicit => |p| explicit: {
+                    const index = face.glyphIndex(cp) orelse break :explicit false;
+                    break :explicit switch (p) {
+                        .text => !face.isColorGlyph(index),
+                        .emoji => face.isColorGlyph(index),
+                    };
+                },
                 .default, .any => face.glyphIndex(cp) != null,
             },
 
@@ -357,7 +370,13 @@ pub const Entry = union(enum) {
             .fallback_loaded => |face| switch (p_mode) {
                 .explicit,
                 .default,
-                => |p| face.presentation == p and face.glyphIndex(cp) != null,
+                => |p| explicit: {
+                    const index = face.glyphIndex(cp) orelse break :explicit false;
+                    break :explicit switch (p) {
+                        .text => !face.isColorGlyph(index),
+                        .emoji => face.isColorGlyph(index),
+                    };
+                },
                 .any => face.glyphIndex(cp) != null,
             },
         };
@@ -371,7 +390,7 @@ pub const PresentationMode = union(enum) {
     explicit: Presentation,
 
     /// The codepoint has no explicit presentation and we should use
-    /// the presentation from the UCd.
+    /// the presentation from the UCD.
     default: Presentation,
 
     /// The codepoint can be any presentation.

commit c183e71a92bf80ca19da02186486b4cc2dcb68c2
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 10:28:58 2024 -0700

    font: support aliased entries in the font collection style table

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 86231b83..08d5c81c 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -16,6 +16,7 @@
 const Collection = @This();
 
 const std = @import("std");
+const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
 const font = @import("main.zig");
 const options = font.options;
@@ -104,7 +105,21 @@ pub fn add(
 pub fn getFace(self: *Collection, index: Index) !*Face {
     if (index.special() != null) return error.SpecialHasNoFace;
     const list = self.faces.getPtr(index.style);
-    const item = &list.items[index.idx];
+    const item: *Entry = item: {
+        var item = &list.items[index.idx];
+        switch (item.*) {
+            .alias => |ptr| item = ptr,
+
+            .deferred,
+            .fallback_deferred,
+            .loaded,
+            .fallback_loaded,
+            => {},
+        }
+        assert(item.* != .alias);
+        break :item item;
+    };
+
     return switch (item.*) {
         inline .deferred, .fallback_deferred => |*d, tag| deferred: {
             const opts = self.load_options orelse
@@ -125,6 +140,10 @@ pub fn getFace(self: *Collection, index: Index) !*Face {
         },
 
         .loaded, .fallback_loaded => |*f| f,
+
+        // When setting `item` above, we ensure we don't end up with
+        // an alias.
+        .alias => unreachable,
     };
 }
 
@@ -168,6 +187,23 @@ pub fn hasCodepoint(
     return list.items[index.idx].hasCodepoint(cp, p_mode);
 }
 
+/// Ensure we have an option for all styles in the collection, such
+/// as italic and bold.
+///
+/// This requires that a regular font face is already loaded.
+/// This is asserted. If a font style is missing, we will synthesize
+/// it if possible. Otherwise, we will use the regular font style.
+pub fn completeStyles(self: *Collection, alloc: Allocator) !void {
+    const regular_list = self.faces.getPtr(.regular);
+    assert(regular_list.items.len > 0);
+
+    // If we don't have bold, use the regular font.
+    const bold_list = self.faces.getPtr(.bold);
+    if (bold_list.items.len == 0) {}
+
+    _ = alloc;
+}
+
 /// Automatically create an italicized font from the regular
 /// font face if we don't have one already. If we already have
 /// an italicized font face, this does nothing.
@@ -243,10 +279,16 @@ pub fn setSize(self: *Collection, size: DesiredSize) !void {
     var it = self.faces.iterator();
     while (it.next()) |entry| {
         for (entry.value.items) |*elem| switch (elem.*) {
-            .deferred, .fallback_deferred => continue,
             .loaded, .fallback_loaded => |*f| try f.setSize(
                 opts.faceOptions(),
             ),
+
+            // Deferred aren't loaded so we don't need to set their size.
+            // The size for when they're loaded is set since `opts` changed.
+            .deferred, .fallback_deferred => continue,
+
+            // Alias faces don't own their size.
+            .alias => continue,
         };
     }
 }
@@ -318,6 +360,10 @@ pub const Entry = union(enum) {
     fallback_deferred: DeferredFace,
     fallback_loaded: Face,
 
+    // An alias to another entry. This is used to share the same face,
+    // avoid memory duplication. An alias must point to a non-alias entry.
+    alias: *Entry,
+
     pub fn deinit(self: *Entry) void {
         switch (self.*) {
             inline .deferred,
@@ -325,6 +371,10 @@ pub const Entry = union(enum) {
             .fallback_deferred,
             .fallback_loaded,
             => |*v| v.deinit(),
+
+            // Aliased fonts are not owned by this entry so we let them
+            // be deallocated by the owner.
+            .alias => {},
         }
     }
 
@@ -333,6 +383,7 @@ pub const Entry = union(enum) {
         return switch (self) {
             .deferred, .fallback_deferred => true,
             .loaded, .fallback_loaded => false,
+            .alias => |v| v.isDeferred(),
         };
     }
 
@@ -343,6 +394,8 @@ pub const Entry = union(enum) {
         p_mode: PresentationMode,
     ) bool {
         return switch (self) {
+            .alias => |v| v.hasCodepoint(cp, p_mode),
+
             // Non-fallback fonts require explicit presentation matching but
             // otherwise don't care about presentation
             .deferred => |v| switch (p_mode) {

commit 1f3ccb2d664cf0fe041943e6073c97c36650d431
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 14:49:51 2024 -0700

    font: Collection uses SegmentedList for styles for pointer stability

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 08d5c81c..f5e1880e 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -40,21 +40,18 @@ faces: StyleArray,
 load_options: ?LoadOptions = null,
 
 /// Initialize an empty collection.
-pub fn init(
-    alloc: Allocator,
-) !Collection {
+pub fn init() Collection {
     // Initialize our styles array, preallocating some space that is
     // likely to be used.
-    var faces = StyleArray.initFill(.{});
-    for (&faces.values) |*v| try v.ensureTotalCapacityPrecise(alloc, 2);
-    return .{ .faces = faces };
+    return .{ .faces = StyleArray.initFill(.{}) };
 }
 
 pub fn deinit(self: *Collection, alloc: Allocator) void {
     var it = self.faces.iterator();
-    while (it.next()) |entry| {
-        for (entry.value.items) |*item| item.deinit();
-        entry.value.deinit(alloc);
+    while (it.next()) |array| {
+        var entry_it = array.value.iterator(0);
+        while (entry_it.next()) |entry| entry.deinit();
+        array.value.deinit(alloc);
     }
 
     if (self.load_options) |*v| v.deinit(alloc);
@@ -85,14 +82,14 @@ pub fn add(
     const list = self.faces.getPtr(style);
 
     // We have some special indexes so we must never pass those.
-    if (list.items.len >= Index.Special.start - 1)
+    const idx = list.count();
+    if (idx >= Index.Special.start - 1)
         return error.CollectionFull;
 
     // If this is deferred and we don't have load options, we can't.
     if (face.isDeferred() and self.load_options == null)
         return error.DeferredLoadingUnavailable;
 
-    const idx = list.items.len;
     try list.append(alloc, face);
     return .{ .style = style, .idx = @intCast(idx) };
 }
@@ -106,7 +103,7 @@ pub fn getFace(self: *Collection, index: Index) !*Face {
     if (index.special() != null) return error.SpecialHasNoFace;
     const list = self.faces.getPtr(index.style);
     const item: *Entry = item: {
-        var item = &list.items[index.idx];
+        var item = list.at(index.idx);
         switch (item.*) {
             .alias => |ptr| item = ptr,
 
@@ -159,13 +156,17 @@ pub fn getIndex(
     style: Style,
     p_mode: PresentationMode,
 ) ?Index {
-    for (self.faces.get(style).items, 0..) |elem, i| {
-        if (elem.hasCodepoint(cp, p_mode)) {
+    var i: usize = 0;
+    var it = self.faces.get(style).constIterator(0);
+    while (it.next()) |entry| {
+        if (entry.hasCodepoint(cp, p_mode)) {
             return .{
                 .style = style,
                 .idx = @intCast(i),
             };
         }
+
+        i += 1;
     }
 
     // Not found
@@ -183,8 +184,8 @@ pub fn hasCodepoint(
     p_mode: PresentationMode,
 ) bool {
     const list = self.faces.get(index.style);
-    if (index.idx >= list.items.len) return false;
-    return list.items[index.idx].hasCodepoint(cp, p_mode);
+    if (index.idx >= list.count()) return false;
+    return list.at(index.idx).hasCodepoint(cp, p_mode);
 }
 
 /// Ensure we have an option for all styles in the collection, such
@@ -210,7 +211,7 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) !void {
 pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
     // If we have an italic font, do nothing.
     const italic_list = self.faces.getPtr(.italic);
-    if (italic_list.items.len > 0) return;
+    if (italic_list.count() > 0) return;
 
     // Not all font backends support auto-italicization.
     if (comptime !@hasDecl(Face, "italicize")) {
@@ -224,10 +225,10 @@ pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
     // Our regular font. If we have no regular font we also do nothing.
     const regular = regular: {
         const list = self.faces.get(.regular);
-        if (list.items.len == 0) return;
+        if (list.count() == 0) return;
 
         // Find our first regular face that has text glyphs.
-        for (0..list.items.len) |i| {
+        for (0..list.count()) |i| {
             const face = try self.getFace(.{
                 .style = .regular,
                 .idx = @intCast(i),
@@ -277,8 +278,9 @@ pub fn setSize(self: *Collection, size: DesiredSize) !void {
 
     // Resize all our faces that are loaded
     var it = self.faces.iterator();
-    while (it.next()) |entry| {
-        for (entry.value.items) |*elem| switch (elem.*) {
+    while (it.next()) |array| {
+        var entry_it = array.value.iterator(0);
+        while (entry_it.next()) |entry| switch (entry.*) {
             .loaded, .fallback_loaded => |*f| try f.setSize(
                 opts.faceOptions(),
             ),
@@ -299,7 +301,12 @@ pub fn setSize(self: *Collection, size: DesiredSize) !void {
 /// styles are typically loaded for a terminal session. The overhead per
 /// style even if it is not used or barely used is minimal given the
 /// small style count.
-const StyleArray = std.EnumArray(Style, std.ArrayListUnmanaged(Entry));
+///
+/// We use a segmented list because the entry values must be pointer-stable
+/// to support the "alias" field in Entry. SegmentedList also lets us do
+/// a prealloc which is great for performance since most happy path cases
+/// do not use many font fallbacks.
+const StyleArray = std.EnumArray(Style, std.SegmentedList(Entry, 4));
 
 /// Load options are used to configure all the details a Collection
 /// needs to load deferred faces.
@@ -520,7 +527,7 @@ test init {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
 }
 
@@ -532,7 +539,7 @@ test "add full" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
 
     for (0..Index.Special.start - 1) |_| {
@@ -558,7 +565,7 @@ test "add deferred without loading options" {
     const testing = std.testing;
     const alloc = testing.allocator;
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
 
     try testing.expectError(error.DeferredLoadingUnavailable, c.add(
@@ -578,7 +585,7 @@ test getFace {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
 
     const idx = try c.add(alloc, .regular, .{ .loaded = try Face.init(
@@ -602,7 +609,7 @@ test getIndex {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
 
     _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
@@ -635,7 +642,7 @@ test autoItalicize {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
     c.load_options = .{ .library = lib };
 
@@ -658,7 +665,7 @@ test setSize {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
     c.load_options = .{ .library = lib };
 
@@ -681,7 +688,7 @@ test hasCodepoint {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
     c.load_options = .{ .library = lib };
 
@@ -705,7 +712,7 @@ test "hasCodepoint emoji default graphical" {
     var lib = try Library.init();
     defer lib.deinit();
 
-    var c = try init(alloc);
+    var c = init();
     defer c.deinit(alloc);
     c.load_options = .{ .library = lib };
 

commit 874caf29da6b2df4167f17f9be29477400f35eb3
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 15:21:10 2024 -0700

    font: completeStyles

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index f5e1880e..1d6c3e2f 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -117,28 +117,37 @@ pub fn getFace(self: *Collection, index: Index) !*Face {
         break :item item;
     };
 
-    return switch (item.*) {
+    return self.getFaceFromEntry(item);
+}
+
+/// Get the face from an entry.
+///
+/// This entry must not be an alias.
+fn getFaceFromEntry(self: *Collection, entry: *Entry) !*Face {
+    assert(entry.* != .alias);
+
+    return switch (entry.*) {
         inline .deferred, .fallback_deferred => |*d, tag| deferred: {
             const opts = self.load_options orelse
                 return error.DeferredLoadingUnavailable;
             const face = try d.load(opts.library, opts.faceOptions());
             d.deinit();
-            item.* = switch (tag) {
+            entry.* = switch (tag) {
                 .deferred => .{ .loaded = face },
                 .fallback_deferred => .{ .fallback_loaded = face },
                 else => unreachable,
             };
 
             break :deferred switch (tag) {
-                .deferred => &item.loaded,
-                .fallback_deferred => &item.fallback_loaded,
+                .deferred => &entry.loaded,
+                .fallback_deferred => &entry.fallback_loaded,
                 else => unreachable,
             };
         },
 
         .loaded, .fallback_loaded => |*f| f,
 
-        // When setting `item` above, we ensure we don't end up with
+        // When setting `entry` above, we ensure we don't end up with
         // an alias.
         .alias => unreachable,
     };
@@ -188,51 +197,48 @@ pub fn hasCodepoint(
     return list.at(index.idx).hasCodepoint(cp, p_mode);
 }
 
+pub const CompleteError = Allocator.Error || error{
+    DefaultUnavailable,
+};
+
 /// Ensure we have an option for all styles in the collection, such
 /// as italic and bold.
 ///
 /// This requires that a regular font face is already loaded.
 /// This is asserted. If a font style is missing, we will synthesize
 /// it if possible. Otherwise, we will use the regular font style.
-pub fn completeStyles(self: *Collection, alloc: Allocator) !void {
-    const regular_list = self.faces.getPtr(.regular);
-    assert(regular_list.items.len > 0);
-
-    // If we don't have bold, use the regular font.
-    const bold_list = self.faces.getPtr(.bold);
-    if (bold_list.items.len == 0) {}
-
-    _ = alloc;
-}
-
-/// Automatically create an italicized font from the regular
-/// font face if we don't have one already. If we already have
-/// an italicized font face, this does nothing.
-pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
-    // If we have an italic font, do nothing.
-    const italic_list = self.faces.getPtr(.italic);
-    if (italic_list.count() > 0) return;
+pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
+    // If every style has at least one entry then we're done!
+    // This is the most common case.
+    empty: {
+        var it = self.faces.iterator();
+        while (it.next()) |entry| {
+            if (entry.value.count() == 0) break :empty;
+        }
 
-    // Not all font backends support auto-italicization.
-    if (comptime !@hasDecl(Face, "italicize")) {
-        log.warn(
-            "no italic font face available, italics will not render",
-            .{},
-        );
         return;
     }
 
-    // Our regular font. If we have no regular font we also do nothing.
-    const regular = regular: {
-        const list = self.faces.get(.regular);
-        if (list.count() == 0) return;
+    // Find the first regular face that has non-colorized text glyphs.
+    // This is the font we want to fallback to. This may not be index zero
+    // if a user configures something like an Emoji font first.
+    const regular_entry: *Entry = entry: {
+        const list = self.faces.getPtr(.regular);
+        assert(list.count() > 0);
 
         // Find our first regular face that has text glyphs.
-        for (0..list.count()) |i| {
-            const face = try self.getFace(.{
-                .style = .regular,
-                .idx = @intCast(i),
-            });
+        var it = list.iterator(0);
+        while (it.next()) |entry| {
+            // Load our face. If we fail to load it, we just skip it and
+            // continue on to try the next one.
+            const face = self.getFaceFromEntry(entry) catch |err| {
+                log.warn("error loading regular entry={d} err={}", .{
+                    it.index - 1,
+                    err,
+                });
+
+                continue;
+            };
 
             // We have two conditionals here. The color check is obvious:
             // we want to auto-italicize a normal text font. The second
@@ -242,25 +248,62 @@ pub fn autoItalicize(self: *Collection, alloc: Allocator) !void {
             // it's a reasonable heuristic and the first case will match 99%
             // of the time.
             if (!face.hasColor() or face.glyphIndex('A') != null) {
-                break :regular face;
+                break :entry entry;
             }
         }
 
-        // No regular text face found.
-        return;
+        // No regular text face found. We can't provide any fallback.
+        return error.DefaultUnavailable;
     };
 
+    // If we don't have italic, attempt to create a synthetic italic face.
+    // If we can't create a synthetic italic face, we'll just use the regular
+    // face for italic.
+    const italic_list = self.faces.getPtr(.italic);
+    if (italic_list.count() == 0) italic: {
+        const synthetic = self.syntheticItalic(regular_entry) catch |err| {
+            log.warn("failed to create synthetic italic, italic style will not be available err={}", .{err});
+            try italic_list.append(alloc, .{ .alias = regular_entry });
+            break :italic;
+        };
+
+        log.info("synthetic italic face created", .{});
+        try italic_list.append(alloc, .{ .loaded = synthetic });
+    }
+
+    // If we don't have bold, use the regular font.
+    const bold_list = self.faces.getPtr(.bold);
+    if (bold_list.count() == 0) {
+        log.warn("bold style not available, using regular font", .{});
+        try bold_list.append(alloc, .{ .alias = regular_entry });
+    }
+
+    // If we don't have bold italic, use the regular italic font.
+    const bold_italic_list = self.faces.getPtr(.bold_italic);
+    if (bold_italic_list.count() == 0) {
+        log.warn("bold italic style not available, using italic font", .{});
+        try bold_italic_list.append(alloc, .{ .alias = italic_list.at(0) });
+    }
+}
+
+// Create an synthetic italic font face from the given entry and return it.
+fn syntheticItalic(self: *Collection, entry: *Entry) !Face {
+    // Not all font backends support auto-italicization.
+    if (comptime !@hasDecl(Face, "italicize")) return error.SyntheticItalicUnavailable;
+
     // We require loading options to auto-italicize.
     const opts = self.load_options orelse return error.DeferredLoadingUnavailable;
 
     // Try to italicize it.
+    const regular = try self.getFaceFromEntry(entry);
     const face = try regular.italicize(opts.faceOptions());
-    try italic_list.append(alloc, .{ .loaded = face });
 
     var buf: [256]u8 = undefined;
     if (face.name(&buf)) |name| {
         log.info("font auto-italicized: {s}", .{name});
     } else |_| {}
+
+    return face;
 }
 
 /// Update the size of all faces in the collection. This will
@@ -632,9 +675,7 @@ test getIndex {
     }
 }
 
-test autoItalicize {
-    if (comptime !@hasDecl(Face, "italicize")) return error.SkipZigTest;
-
+test completeStyles {
     const testing = std.testing;
     const alloc = testing.allocator;
     const testFont = @import("test.zig").fontRegular;
@@ -652,9 +693,13 @@ test autoItalicize {
         .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
     ) });
 
+    try testing.expect(c.getIndex('A', .bold, .{ .any = {} }) == null);
     try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) == null);
-    try c.autoItalicize(alloc);
+    try testing.expect(c.getIndex('A', .bold_italic, .{ .any = {} }) == null);
+    try c.completeStyles(alloc);
+    try testing.expect(c.getIndex('A', .bold, .{ .any = {} }) != null);
     try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) != null);
+    try testing.expect(c.getIndex('A', .bold_italic, .{ .any = {} }) != null);
 }
 
 test setSize {

commit 47fb7f0115a3f9bc8198bd304e216ce392426580
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 19:18:07 2024 -0700

    font: Collection can't use segmentedlist prealloc

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 1d6c3e2f..18a23662 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -346,10 +346,11 @@ pub fn setSize(self: *Collection, size: DesiredSize) !void {
 /// small style count.
 ///
 /// We use a segmented list because the entry values must be pointer-stable
-/// to support the "alias" field in Entry. SegmentedList also lets us do
-/// a prealloc which is great for performance since most happy path cases
-/// do not use many font fallbacks.
-const StyleArray = std.EnumArray(Style, std.SegmentedList(Entry, 4));
+/// to support the "alias" field in Entry.
+///
+/// WARNING: We cannot use any prealloc yet for the segmented list because
+/// the collection is copied around by value and pointers aren't stable.
+const StyleArray = std.EnumArray(Style, std.SegmentedList(Entry, 0));
 
 /// Load options are used to configure all the details a Collection
 /// needs to load deferred faces.

commit 9941440f4714beb491cd511d5b5e0a446541afb6
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 20:20:32 2024 -0700

    font: bold italic fallback has to avoid nested alias entry

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 18a23662..2a836805 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -282,7 +282,25 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     const bold_italic_list = self.faces.getPtr(.bold_italic);
     if (bold_italic_list.count() == 0) {
         log.warn("bold italic style not available, using italic font", .{});
-        try bold_italic_list.append(alloc, .{ .alias = italic_list.at(0) });
+
+        // Nested alias isn't allowed so if the italic entry is an
+        // alias then we use the aliased entry.
+        const italic_entry = italic_list.at(0);
+        switch (italic_entry.*) {
+            .alias => |v| try bold_italic_list.append(
+                alloc,
+                .{ .alias = v },
+            ),
+
+            .loaded,
+            .fallback_loaded,
+            .deferred,
+            .fallback_deferred,
+            => try bold_italic_list.append(
+                alloc,
+                .{ .alias = italic_entry },
+            ),
+        }
     }
 }
 

commit 74291793db0437d2c5d201f7f38d15dfcaf0ba83
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 20:34:19 2024 -0700

    font: rename auto-italicize to synthetic italic

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 2a836805..256c6b73 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -306,19 +306,19 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
 
 // Create an synthetic italic font face from the given entry and return it.
 fn syntheticItalic(self: *Collection, entry: *Entry) !Face {
-    // Not all font backends support auto-italicization.
-    if (comptime !@hasDecl(Face, "italicize")) return error.SyntheticItalicUnavailable;
+    // Not all font backends support synthetic italicization.
+    if (comptime !@hasDecl(Face, "syntheticItalic")) return error.SyntheticItalicUnavailable;
 
-    // We require loading options to auto-italicize.
+    // We require loading options to create a synthetic italic face.
     const opts = self.load_options orelse return error.DeferredLoadingUnavailable;
 
     // Try to italicize it.
     const regular = try self.getFaceFromEntry(entry);
-    const face = try regular.italicize(opts.faceOptions());
+    const face = try regular.syntheticItalic(opts.faceOptions());
 
     var buf: [256]u8 = undefined;
     if (face.name(&buf)) |name| {
-        log.info("font auto-italicized: {s}", .{name});
+        log.info("font synthetic italic created family={s}", .{name});
     } else |_| {}
 
     return face;

commit d22551cd31b76a4d25d5f9cdbc08451d5d35d3b1
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 20:52:13 2024 -0700

    font/coretext: support synthetic bold

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 256c6b73..01237a10 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -273,9 +273,15 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
 
     // If we don't have bold, use the regular font.
     const bold_list = self.faces.getPtr(.bold);
-    if (bold_list.count() == 0) {
-        log.warn("bold style not available, using regular font", .{});
-        try bold_list.append(alloc, .{ .alias = regular_entry });
+    if (bold_list.count() == 0) bold: {
+        const synthetic = self.syntheticBold(regular_entry) catch |err| {
+            log.warn("failed to create synthetic bold, bold style will not be available err={}", .{err});
+            try bold_list.append(alloc, .{ .alias = regular_entry });
+            break :bold;
+        };
+
+        log.info("synthetic bold face created", .{});
+        try bold_list.append(alloc, .{ .loaded = synthetic });
     }
 
     // If we don't have bold italic, use the regular italic font.
@@ -304,6 +310,26 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     }
 }
 
+// Create an synthetic italic font face from the given entry and return it.
+fn syntheticBold(self: *Collection, entry: *Entry) !Face {
+    // Not all font backends support synthetic bold.
+    if (comptime !@hasDecl(Face, "syntheticBold")) return error.SyntheticBoldUnavailable;
+
+    // We require loading options to create a synthetic bold face.
+    const opts = self.load_options orelse return error.DeferredLoadingUnavailable;
+
+    // Try to bold it.
+    const regular = try self.getFaceFromEntry(entry);
+    const face = try regular.syntheticBold(opts.faceOptions());
+
+    var buf: [256]u8 = undefined;
+    if (face.name(&buf)) |name| {
+        log.info("font synthetic bold created family={s}", .{name});
+    } else |_| {}
+
+    return face;
+}
+
 // Create an synthetic italic font face from the given entry and return it.
 fn syntheticItalic(self: *Collection, entry: *Entry) !Face {
     // Not all font backends support synthetic italicization.

commit ce6c5517afe140a050ca4978aab90bf4e5ffcdb4
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 21:03:33 2024 -0700

    font: synthesize bold italic

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 01237a10..fbc23f00 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -260,7 +260,8 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     // If we can't create a synthetic italic face, we'll just use the regular
     // face for italic.
     const italic_list = self.faces.getPtr(.italic);
-    if (italic_list.count() == 0) italic: {
+    const have_italic = italic_list.count() > 0;
+    if (!have_italic) italic: {
         const synthetic = self.syntheticItalic(regular_entry) catch |err| {
             log.warn("failed to create synthetic italic, italic style will not be available err={}", .{err});
             try italic_list.append(alloc, .{ .alias = regular_entry });
@@ -273,7 +274,8 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
 
     // If we don't have bold, use the regular font.
     const bold_list = self.faces.getPtr(.bold);
-    if (bold_list.count() == 0) bold: {
+    const have_bold = bold_list.count() > 0;
+    if (!have_bold) bold: {
         const synthetic = self.syntheticBold(regular_entry) catch |err| {
             log.warn("failed to create synthetic bold, bold style will not be available err={}", .{err});
             try bold_list.append(alloc, .{ .alias = regular_entry });
@@ -284,29 +286,45 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
         try bold_list.append(alloc, .{ .loaded = synthetic });
     }
 
-    // If we don't have bold italic, use the regular italic font.
+    // If we don't have bold italic, we attempt to synthesize a bold variant
+    // of the italic font. If we can't do that, we'll use the italic font.
     const bold_italic_list = self.faces.getPtr(.bold_italic);
-    if (bold_italic_list.count() == 0) {
-        log.warn("bold italic style not available, using italic font", .{});
+    if (bold_italic_list.count() == 0) bold_italic: {
+        // Prefer to synthesize on top of the face we already had. If we
+        // have bold then we try to synthesize italic on top of bold.
+        if (have_bold) {
+            if (self.syntheticItalic(bold_list.at(0))) |synthetic| {
+                log.info("synthetic bold italic face created from bold", .{});
+                try bold_italic_list.append(alloc, .{ .loaded = synthetic });
+                break :bold_italic;
+            } else |_| {}
+
+            // If synthesizing italic failed, then we try to synthesize
+            // boldon whatever italic font we have.
+        }
 
-        // Nested alias isn't allowed so if the italic entry is an
-        // alias then we use the aliased entry.
-        const italic_entry = italic_list.at(0);
-        switch (italic_entry.*) {
-            .alias => |v| try bold_italic_list.append(
-                alloc,
-                .{ .alias = v },
-            ),
+        // Nested alias isn't allowed so we need to unwrap the italic entry.
+        const base_entry = base: {
+            const italic_entry = italic_list.at(0);
+            break :base switch (italic_entry.*) {
+                .alias => |v| v,
+
+                .loaded,
+                .fallback_loaded,
+                .deferred,
+                .fallback_deferred,
+                => italic_entry,
+            };
+        };
 
-            .loaded,
-            .fallback_loaded,
-            .deferred,
-            .fallback_deferred,
-            => try bold_italic_list.append(
-                alloc,
-                .{ .alias = italic_entry },
-            ),
-        }
+        if (self.syntheticBold(base_entry)) |synthetic| {
+            log.info("synthetic bold italic face created from italic", .{});
+            try bold_italic_list.append(alloc, .{ .loaded = synthetic });
+            break :bold_italic;
+        } else |_| {}
+
+        log.warn("bold italic style not available, using italic font", .{});
+        try bold_italic_list.append(alloc, .{ .alias = base_entry });
     }
 }
 

commit ac3e2163f342ae89c8c683b19833c52dfff6cc4c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Fri Aug 23 21:19:20 2024 -0700

    typos

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index fbc23f00..84286793 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -300,7 +300,7 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
             } else |_| {}
 
             // If synthesizing italic failed, then we try to synthesize
-            // boldon whatever italic font we have.
+            // bold on whatever italic font we have.
         }
 
         // Nested alias isn't allowed so we need to unwrap the italic entry.
@@ -328,7 +328,7 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     }
 }
 
-// Create an synthetic italic font face from the given entry and return it.
+// Create a synthetic bold font face from the given entry and return it.
 fn syntheticBold(self: *Collection, entry: *Entry) !Face {
     // Not all font backends support synthetic bold.
     if (comptime !@hasDecl(Face, "syntheticBold")) return error.SyntheticBoldUnavailable;
@@ -348,7 +348,7 @@ fn syntheticBold(self: *Collection, entry: *Entry) !Face {
     return face;
 }
 
-// Create an synthetic italic font face from the given entry and return it.
+// Create a synthetic italic font face from the given entry and return it.
 fn syntheticItalic(self: *Collection, entry: *Entry) !Face {
     // Not all font backends support synthetic italicization.
     if (comptime !@hasDecl(Face, "syntheticItalic")) return error.SyntheticItalicUnavailable;

commit bdcc21942d0ab073248fbdfda79fc22cf69e0e9f
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Mon Aug 26 20:46:14 2024 -0700

    config: font-synthetic-style to enable/disable synthetic styles
    
    This adds a new configuration "font-synthetic-style" to enable or
    disable synthetic styles. This is different from "font-style-*" which
    specifies a named style or disables a style completely.
    
    Instead, "font-synthetic-style" will disable only the creation of
    synthetic styles in the case a font does not support a given style.
    This is useful for users who want to obviously know when a font doesn't
    support a given style or a user who wants to explicitly only use the
    styles that were designed by the font designer.
    
    The default value is to enable all synthetic styles.

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 84286793..4601a012 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -18,6 +18,7 @@ const Collection = @This();
 const std = @import("std");
 const assert = std.debug.assert;
 const Allocator = std.mem.Allocator;
+const config = @import("../config.zig");
 const font = @import("main.zig");
 const options = font.options;
 const DeferredFace = font.DeferredFace;
@@ -207,7 +208,11 @@ pub const CompleteError = Allocator.Error || error{
 /// This requires that a regular font face is already loaded.
 /// This is asserted. If a font style is missing, we will synthesize
 /// it if possible. Otherwise, we will use the regular font style.
-pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
+pub fn completeStyles(
+    self: *Collection,
+    alloc: Allocator,
+    synthetic_config: config.FontSyntheticStyle,
+) CompleteError!void {
     // If every style has at least one entry then we're done!
     // This is the most common case.
     empty: {
@@ -262,6 +267,12 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     const italic_list = self.faces.getPtr(.italic);
     const have_italic = italic_list.count() > 0;
     if (!have_italic) italic: {
+        if (!synthetic_config.italic) {
+            log.info("italic style not available and synthetic italic disabled", .{});
+            try italic_list.append(alloc, .{ .alias = regular_entry });
+            break :italic;
+        }
+
         const synthetic = self.syntheticItalic(regular_entry) catch |err| {
             log.warn("failed to create synthetic italic, italic style will not be available err={}", .{err});
             try italic_list.append(alloc, .{ .alias = regular_entry });
@@ -276,6 +287,12 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     const bold_list = self.faces.getPtr(.bold);
     const have_bold = bold_list.count() > 0;
     if (!have_bold) bold: {
+        if (!synthetic_config.bold) {
+            log.info("bold style not available and synthetic bold disabled", .{});
+            try bold_list.append(alloc, .{ .alias = regular_entry });
+            break :bold;
+        }
+
         const synthetic = self.syntheticBold(regular_entry) catch |err| {
             log.warn("failed to create synthetic bold, bold style will not be available err={}", .{err});
             try bold_list.append(alloc, .{ .alias = regular_entry });
@@ -290,6 +307,12 @@ pub fn completeStyles(self: *Collection, alloc: Allocator) CompleteError!void {
     // of the italic font. If we can't do that, we'll use the italic font.
     const bold_italic_list = self.faces.getPtr(.bold_italic);
     if (bold_italic_list.count() == 0) bold_italic: {
+        if (!synthetic_config.@"bold-italic") {
+            log.info("bold italic style not available and synthetic bold italic disabled", .{});
+            try bold_italic_list.append(alloc, .{ .alias = regular_entry });
+            break :bold_italic;
+        }
+
         // Prefer to synthesize on top of the face we already had. If we
         // have bold then we try to synthesize italic on top of bold.
         if (have_bold) {
@@ -759,7 +782,7 @@ test completeStyles {
     try testing.expect(c.getIndex('A', .bold, .{ .any = {} }) == null);
     try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) == null);
     try testing.expect(c.getIndex('A', .bold_italic, .{ .any = {} }) == null);
-    try c.completeStyles(alloc);
+    try c.completeStyles(alloc, .{});
     try testing.expect(c.getIndex('A', .bold, .{ .any = {} }) != null);
     try testing.expect(c.getIndex('A', .italic, .{ .any = {} }) != null);
     try testing.expect(c.getIndex('A', .bold_italic, .{ .any = {} }) != null);

commit be3ae56bc8cdd8c6b15c3bcd885d572300b28953
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Oct 2 14:45:34 2024 -0700

    font: add stylistic variants for built-in font, fix naming convention
    
    Fixes #2364
    
    This adds the bold, italic, and bold italic variants of JB Mono so it is
    built-in. This also fixes up the naming convention for the embedded font
    files across tests and removes redundant embedded font files.

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 4601a012..8f338be1 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -203,11 +203,11 @@ pub const CompleteError = Allocator.Error || error{
 };
 
 /// Ensure we have an option for all styles in the collection, such
-/// as italic and bold.
+/// as italic and bold by synthesizing them if necessary from the
+/// first regular face that has text glyphs.
 ///
-/// This requires that a regular font face is already loaded.
-/// This is asserted. If a font style is missing, we will synthesize
-/// it if possible. Otherwise, we will use the regular font style.
+/// If there is no regular face that has text glyphs, then this
+/// does nothing.
 pub fn completeStyles(
     self: *Collection,
     alloc: Allocator,
@@ -229,7 +229,7 @@ pub fn completeStyles(
     // if a user configures something like an Emoji font first.
     const regular_entry: *Entry = entry: {
         const list = self.faces.getPtr(.regular);
-        assert(list.count() > 0);
+        if (list.count() == 0) return;
 
         // Find our first regular face that has text glyphs.
         var it = list.iterator(0);
@@ -663,7 +663,7 @@ test init {
 test "add full" {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -709,7 +709,7 @@ test "add deferred without loading options" {
 test getFace {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -733,7 +733,7 @@ test getFace {
 test getIndex {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -764,7 +764,7 @@ test getIndex {
 test completeStyles {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -791,7 +791,7 @@ test completeStyles {
 test setSize {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -814,7 +814,7 @@ test setSize {
 test hasCodepoint {
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testFont = @import("test.zig").fontRegular;
+    const testFont = font.embedded.regular;
 
     var lib = try Library.init();
     defer lib.deinit();
@@ -838,7 +838,7 @@ test "hasCodepoint emoji default graphical" {
 
     const testing = std.testing;
     const alloc = testing.allocator;
-    const testEmoji = @import("test.zig").fontEmoji;
+    const testEmoji = font.embedded.emoji;
 
     var lib = try Library.init();
     defer lib.deinit();

commit 3f1d6eb301a7fb3d967c7f17c555c8dd761d900c
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Thu Oct 17 22:00:05 2024 -0700

    expand explicit error set usage
    
    This continues our work to improve the amount of explicit error sets
    we use in the codebase. Explicit error sets make it easier to understand
    possible failure scenarios, allow us to use exhaustive matching, create
    compiler errors if errors are unexpectedly added or removed, etc.
    
    The goal eventually is 100% coverage but we're not even close yet.
    This just moves us a little closer.

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 8f338be1..47678774 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -118,7 +118,7 @@ pub fn getFace(self: *Collection, index: Index) !*Face {
         break :item item;
     };
 
-    return self.getFaceFromEntry(item);
+    return try self.getFaceFromEntry(item);
 }
 
 /// Get the face from an entry.

commit 945a715b08d9955b759e06f0c7ce6726d4e2604f
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 00:41:55 2024 +0100

    refactor: handle freetype load flags in face instead of renderer

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 47678774..25615bde 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -452,6 +452,8 @@ pub const LoadOptions = struct {
     /// for this is owned by the user and is not freed by the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
+    freetype_load_flags: config.Config.FreetypeLoadFlags = .{},
+
     pub fn deinit(self: *LoadOptions, alloc: Allocator) void {
         _ = self;
         _ = alloc;
@@ -462,6 +464,7 @@ pub const LoadOptions = struct {
         return .{
             .size = self.size,
             .metric_modifiers = &self.metric_modifiers,
+            .freetype_load_flags = self.freetype_load_flags,
         };
     }
 };

commit c0b24ee60d65bee135dea7c99ad9446e9649a574
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 01:35:39 2024 +0100

    refactor: make freetype flags void for non-freetype backend
    
    This is an attempt to use `void` as type for Freetype Load Flags when
    backend does not use these flags.

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 25615bde..b65b4bd2 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -452,7 +452,18 @@ pub const LoadOptions = struct {
     /// for this is owned by the user and is not freed by the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
-    freetype_load_flags: config.Config.FreetypeLoadFlags = .{},
+    freetype_load_flags: config.FreetypeLoadFlags = switch (font.options.backend) {
+        .freetype,
+        .fontconfig_freetype,
+        .coretext_freetype,
+        => .{},
+
+        .coretext,
+        .coretext_harfbuzz,
+        .coretext_noshape,
+        .web_canvas,
+        => {},
+    },
 
     pub fn deinit(self: *LoadOptions, alloc: Allocator) void {
         _ = self;

commit 83c4d0077b7a06d487057fca3bddcc8a3685ed03
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 11:55:29 2024 +0100

    refactor: define `FreetypeLoadFlags` struct and default in `font.face`

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index b65b4bd2..478c39de 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -452,18 +452,7 @@ pub const LoadOptions = struct {
     /// for this is owned by the user and is not freed by the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
-    freetype_load_flags: config.FreetypeLoadFlags = switch (font.options.backend) {
-        .freetype,
-        .fontconfig_freetype,
-        .coretext_freetype,
-        => .{},
-
-        .coretext,
-        .coretext_harfbuzz,
-        .coretext_noshape,
-        .web_canvas,
-        => {},
-    },
+    freetype_load_flags: font.face.FreetypeLoadFlags = font.face.freetype_load_flags_default,
 
     pub fn deinit(self: *LoadOptions, alloc: Allocator) void {
         _ = self;

commit 0e0751ad5b82c9926dd6fabd127edb086a915a9e
Author: Nadir Fejzic <n.fejzic@commend.com>
Date:   Sat Nov 9 12:34:45 2024 +0100

    docs: write documentation for `freetype_load_flags` field

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 478c39de..f79c8093 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -452,6 +452,10 @@ pub const LoadOptions = struct {
     /// for this is owned by the user and is not freed by the collection.
     metric_modifiers: Metrics.ModifierSet = .{},
 
+    /// Freetype Load Flags to use when loading glyphs. This is a list of
+    /// bitfield constants that controls operations to perform during glyph
+    /// loading. Only a subset is exposed for configuration, for the whole set
+    /// of flags see `pkg.freetype.face.LoadFlags`.
     freetype_load_flags: font.face.FreetypeLoadFlags = font.face.freetype_load_flags_default,
 
     pub fn deinit(self: *LoadOptions, alloc: Allocator) void {

commit 540fcc0b690901f185ca00465dafed2e9423b479
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 17:39:53 2025 -0500

    refactor(font): move `Metrics` out of `face`
    
    in preparation to move ownership of metrics from faces to collections

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index f79c8093..629f4e59 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -25,7 +25,7 @@ const DeferredFace = font.DeferredFace;
 const DesiredSize = font.face.DesiredSize;
 const Face = font.Face;
 const Library = font.Library;
-const Metrics = font.face.Metrics;
+const Metrics = font.Metrics;
 const Presentation = font.Presentation;
 const Style = font.Style;
 

commit 298aeb7536d69b8aef236569ee86ecfddd45d991
Author: Qwerasd <qwerasd205@users.noreply.github.com>
Date:   Mon Jan 6 19:00:13 2025 -0500

    refactor(font): move ownership of `Metrics` to `Collection`
    
    This sets the stage for dynamically adjusting the sizes of fallback
    fonts based on the primary font's face metrics. It also removes a lot of
    unnecessary work when loading fallback fonts, since we only actually use
    the metrics based on the parimary font.

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index 629f4e59..cb16528a 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -35,6 +35,17 @@ const log = std.log.scoped(.font_collection);
 /// Instead, use the functions available on Collection.
 faces: StyleArray,
 
+/// The metric modifiers to use for this collection. The memory
+/// for this is owned by the user and is not freed by the collection.
+///
+/// Call `Collection.updateMetrics` to recompute the
+/// collection's metrics after making changes to these.
+metric_modifiers: Metrics.ModifierSet = .{},
+
+/// Metrics for this collection. Call `Collection.updateMetrics` to (re)compute
+/// these after adding a primary font or making changes to `metric_modifiers`.
+metrics: ?Metrics = null,
+
 /// The load options for deferred faces in the face list. If this
 /// is not set, then deferred faces will not be loaded. Attempting to
 /// add a deferred face will result in an error.
@@ -421,6 +432,28 @@ pub fn setSize(self: *Collection, size: DesiredSize) !void {
             .alias => continue,
         };
     }
+
+    try self.updateMetrics();
+}
+
+const UpdateMetricsError = font.Face.GetMetricsError || error{
+    CannotLoadPrimaryFont,
+};
+
+/// Update the cell metrics for this collection, based on
+/// the primary font and the modifiers in `metric_modifiers`.
+///
+/// This requires a primary font (index `0`) to be present.
+pub fn updateMetrics(self: *Collection) UpdateMetricsError!void {
+    const primary_face = self.getFace(.{ .idx = 0 }) catch return error.CannotLoadPrimaryFont;
+
+    const face_metrics = try primary_face.getMetrics();
+
+    var metrics = Metrics.calc(face_metrics);
+
+    metrics.apply(self.metric_modifiers);
+
+    self.metrics = metrics;
 }
 
 /// Packed array of all Style enum cases mapped to a growable list of faces.
@@ -448,10 +481,6 @@ pub const LoadOptions = struct {
     /// The desired font size for all loaded faces.
     size: DesiredSize = .{ .points = 12 },
 
-    /// The metric modifiers to use for all loaded faces. The memory
-    /// for this is owned by the user and is not freed by the collection.
-    metric_modifiers: Metrics.ModifierSet = .{},
-
     /// Freetype Load Flags to use when loading glyphs. This is a list of
     /// bitfield constants that controls operations to perform during glyph
     /// loading. Only a subset is exposed for configuration, for the whole set
@@ -467,7 +496,6 @@ pub const LoadOptions = struct {
     pub fn faceOptions(self: *const LoadOptions) font.face.Options {
         return .{
             .size = self.size,
-            .metric_modifiers = &self.metric_modifiers,
             .freetype_load_flags = self.freetype_load_flags,
         };
     }
@@ -864,3 +892,66 @@ test "hasCodepoint emoji default graphical" {
     try testing.expect(c.hasCodepoint(idx, 'ü•∏', .{ .any = {} }));
     // TODO(fontmem): test explicit/implicit
 }
+
+test "metrics" {
+    const testing = std.testing;
+    const alloc = testing.allocator;
+    const testFont = font.embedded.inconsolata;
+
+    var lib = try Library.init();
+    defer lib.deinit();
+
+    var c = init();
+    defer c.deinit(alloc);
+    c.load_options = .{ .library = lib };
+
+    _ = try c.add(alloc, .regular, .{ .loaded = try Face.init(
+        lib,
+        testFont,
+        .{ .size = .{ .points = 12, .xdpi = 96, .ydpi = 96 } },
+    ) });
+
+    try c.updateMetrics();
+
+    try std.testing.expectEqual(font.Metrics{
+        .cell_width = 8,
+        // The cell height is 17 px because the calculation is
+        //
+        //  ascender - descender + gap
+        //
+        // which, for inconsolata is
+        //
+        //  859 - -190 + 0
+        //
+        // font units, at 1000 units per em that works out to 1.049 em,
+        // and 1em should be the point size * dpi scale, so 12 * (96/72)
+        // which is 16, and 16 * 1.049 = 16.784, which finally is rounded
+        // to 17.
+        .cell_height = 17,
+        .cell_baseline = 3,
+        .underline_position = 17,
+        .underline_thickness = 1,
+        .strikethrough_position = 10,
+        .strikethrough_thickness = 1,
+        .overline_position = 0,
+        .overline_thickness = 1,
+        .box_thickness = 1,
+        .cursor_height = 17,
+    }, c.metrics);
+
+    // Resize should change metrics
+    try c.setSize(.{ .points = 24, .xdpi = 96, .ydpi = 96 });
+    try std.testing.expectEqual(font.Metrics{
+        .cell_width = 16,
+        .cell_height = 34,
+        .cell_baseline = 6,
+        .underline_position = 34,
+        .underline_thickness = 2,
+        .strikethrough_position = 19,
+        .strikethrough_thickness = 2,
+        .overline_position = 0,
+        .overline_thickness = 2,
+        .box_thickness = 2,
+        .cursor_height = 34,
+    }, c.metrics);
+}

commit 0f4d2bb2375c707182dba8cf2dd7723a2e918e79
Author: Mitchell Hashimoto <m@mitchellh.com>
Date:   Wed Mar 12 09:55:46 2025 -0700

    Lots of 0.14 changes

diff --git a/src/font/Collection.zig b/src/font/Collection.zig
index cb16528a..cfc633b0 100644
--- a/src/font/Collection.zig
+++ b/src/font/Collection.zig
@@ -639,11 +639,11 @@ pub const PresentationMode = union(enum) {
 /// the Backing type and everything should just work fine.
 pub const Index = packed struct(Index.Backing) {
     const Backing = u16;
-    const backing_bits = @typeInfo(Backing).Int.bits;
+    const backing_bits = @typeInfo(Backing).int.bits;
 
     /// The number of bits we use for the index.
-    const idx_bits = backing_bits - @typeInfo(@typeInfo(Style).Enum.tag_type).Int.bits;
-    pub const IndexInt = @Type(.{ .Int = .{ .signedness = .unsigned, .bits = idx_bits } });
+    const idx_bits = backing_bits - @typeInfo(@typeInfo(Style).@"enum".tag_type).int.bits;
+    pub const IndexInt = @Type(.{ .int = .{ .signedness = .unsigned, .bits = idx_bits } });
 
     /// The special-case fonts that we support.
     pub const Special = enum(IndexInt) {

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    