<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/benches/vector_search.rs - Gemini 2.5 Pro 03-25</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/benches/vector_search.rs</h1>
        <h2>Model: Gemini 2.5 Pro 03-25</h2>
        <p><a href="../../../cases/google_gemini-2.5-pro-preview-03-25/qdrant_lib_segment_benches_vector_search.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/benches/vector_search.rs

commit bd7ed06bfef324421952312eb52c224403eff12a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jan 3 01:25:41 2021 +0100

    add benchmark for vector similarity speed comparasion

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
new file mode 100644
index 000000000..0a03beb6e
--- /dev/null
+++ b/lib/segment/benches/vector_search.rs
@@ -0,0 +1,74 @@
+use criterion::{Criterion, criterion_group, criterion_main};
+use itertools::Itertools;
+use ndarray::{Array, Array1, Array2, ArrayBase, ShapeBuilder};
+use tempdir::TempDir;
+
+use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
+use segment::types::Distance;
+use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
+use segment::vector_storage::vector_storage::{ScoredPointOffset, VectorStorage};
+
+const NUM_VECTORS: usize = 50000;
+const DIM: usize = 1000;
+
+fn random_vector(size: usize) -> Vec<f32> {
+    let mut vec: Vec<f32> = Vec::with_capacity(size);
+    for _ in 0..vec.capacity() {
+        vec.push(rand::random());
+    };
+    return vec;
+}
+
+fn init_vector_storage(dir: &TempDir, dim: usize, num: usize) -> SimpleVectorStorage {
+    let mut storage = SimpleVectorStorage::open(dir.path(), dim).unwrap();
+
+    for _i in 0..num {
+        let vector: Vec<f32> = random_vector(dim);
+        storage.put_vector(&vector).unwrap();
+    }
+
+    storage
+}
+
+fn benchmark_naive(c: &mut Criterion) {
+    let dir = TempDir::new("storage_dir").unwrap();
+
+    let dist = Distance::Dot;
+    let storage = init_vector_storage(&dir, DIM, NUM_VECTORS);
+
+    c.bench_function("naive vector search",
+                     |b| b.iter(|| {
+                         let vector = random_vector(DIM);
+                         storage.score_all(&vector, 10, &dist)
+                     }));
+}
+
+fn benchmark_ndarray(c: &mut Criterion) {
+    let mut matrix: Array2<f32> = Array::<f32, _>::zeros((NUM_VECTORS, DIM));
+
+    for i in 0..NUM_VECTORS {
+        let vector = Array::from(random_vector(DIM));
+        matrix.row_mut(i).assign(&vector);
+    }
+
+    eprintln!("matrix.shape() = {:#?}", matrix.shape());
+
+
+    c.bench_function("ndarray BLAS dot production",
+                     |b| b.iter(|| {
+                         let vector = Array::from(random_vector(DIM));
+                         let production_result: Array1<f32> = matrix.dot(&vector);
+                         let top = peek_top_scores_iterable(
+                             production_result.iter()
+                                 .cloned()
+                                 .enumerate()
+                                 .map(
+                                     |(idx, score)| ScoredPointOffset { idx, score }),
+                             10,
+                             &Distance::Dot,
+                         );
+                     }));
+}
+
+criterion_group!(benches, benchmark_ndarray, benchmark_naive);
+criterion_main!(benches);

commit 8a85c109345708b6af14604fa212567aaea61c2a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 4 22:59:22 2021 +0100

    use BLAS for vector dot production

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 0a03beb6e..b34baafa3 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,6 +1,6 @@
 use criterion::{Criterion, criterion_group, criterion_main};
 use itertools::Itertools;
-use ndarray::{Array, Array1, Array2, ArrayBase, ShapeBuilder};
+use ndarray::{Array, Array1, Array2, ArrayBase, ShapeBuilder, Axis};
 use tempdir::TempDir;
 
 use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
@@ -9,7 +9,7 @@ use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
 use segment::vector_storage::vector_storage::{ScoredPointOffset, VectorStorage};
 
 const NUM_VECTORS: usize = 50000;
-const DIM: usize = 1000;
+const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
 
 fn random_vector(size: usize) -> Vec<f32> {
     let mut vec: Vec<f32> = Vec::with_capacity(size);
@@ -36,7 +36,7 @@ fn benchmark_naive(c: &mut Criterion) {
     let dist = Distance::Dot;
     let storage = init_vector_storage(&dir, DIM, NUM_VECTORS);
 
-    c.bench_function("naive vector search",
+    c.bench_function("storage vector search",
                      |b| b.iter(|| {
                          let vector = random_vector(DIM);
                          storage.score_all(&vector, 10, &dist)
@@ -57,7 +57,8 @@ fn benchmark_ndarray(c: &mut Criterion) {
     c.bench_function("ndarray BLAS dot production",
                      |b| b.iter(|| {
                          let vector = Array::from(random_vector(DIM));
-                         let production_result: Array1<f32> = matrix.dot(&vector);
+                         let mut production_result = matrix.dot(&vector);
+
                          let top = peek_top_scores_iterable(
                              production_result.iter()
                                  .cloned()

commit 3616631300ab6d2b2a2cefb002ff567448710e06
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun May 30 17:14:42 2021 +0200

    Filtrable hnsw (#26)
    
    * raw points scorer
    
    * raw point scorer for memmap storage
    
    * search interface prepare
    
    * graph binary saving + store PointOffsetId as u32
    
    * WIP: entry points
    
    * connect new link method
    
    * update libs + search layer method + visited list + search context + update rust
    
    * implement Euclid metric + always use MinHeap for priority queue
    
    * small refactor
    
    * search for 0 level entry
    
    * update visited pool to be lock free and thread safe
    
    * use ef_construct from graph layer struct + limit visited links to M
    
    * add metric pre-processing before on vector upsert
    
    * old hnsw heuristic
    
    * save hnsw graph for export
    
    * search method + tests
    
    * small fixes
    
    * add benchmark and profiler
    
    * build time optimizations
    
    * use SeaHash
    
    * remove unsed benchmark
    
    * merge hnsw graph function
    
    * WIP:HNSW index build function
    
    * HNSW build_index with additional indexing
    
    * refactor fixtures
    
    * graph save and load test
    
    * test and fixes for filterable HNSW
    
    * enable hnsw index for query planning
    
    * fix cardinality estimation tests + remove query planner as class
    
    * small refactor
    
    * store full copy of collection settings with collection + allow partial override on creation #16
    
    * API for updating collection parameters #16
    
    * refactor: move collection error -> types
    
    * report collection status in info API #17
    
    * update OpenAPI Schema

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index b34baafa3..e275d6159 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -4,27 +4,27 @@ use ndarray::{Array, Array1, Array2, ArrayBase, ShapeBuilder, Axis};
 use tempdir::TempDir;
 
 use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
-use segment::types::Distance;
+use segment::types::{Distance, VectorElementType, PointOffsetType};
 use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
 use segment::vector_storage::vector_storage::{ScoredPointOffset, VectorStorage};
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
 
-fn random_vector(size: usize) -> Vec<f32> {
-    let mut vec: Vec<f32> = Vec::with_capacity(size);
+fn random_vector(size: usize) -> Vec<VectorElementType> {
+    let mut vec: Vec<VectorElementType> = Vec::with_capacity(size);
     for _ in 0..vec.capacity() {
         vec.push(rand::random());
     };
     return vec;
 }
 
-fn init_vector_storage(dir: &TempDir, dim: usize, num: usize) -> SimpleVectorStorage {
-    let mut storage = SimpleVectorStorage::open(dir.path(), dim).unwrap();
+fn init_vector_storage(dir: &TempDir, dim: usize, num: usize, dist: Distance) -> SimpleVectorStorage {
+    let mut storage = SimpleVectorStorage::open(dir.path(), dim, dist).unwrap();
 
     for _i in 0..num {
-        let vector: Vec<f32> = random_vector(dim);
-        storage.put_vector(&vector).unwrap();
+        let vector: Vec<VectorElementType> = random_vector(dim);
+        storage.put_vector(vector).unwrap();
     }
 
     storage
@@ -34,12 +34,12 @@ fn benchmark_naive(c: &mut Criterion) {
     let dir = TempDir::new("storage_dir").unwrap();
 
     let dist = Distance::Dot;
-    let storage = init_vector_storage(&dir, DIM, NUM_VECTORS);
+    let storage = init_vector_storage(&dir, DIM, NUM_VECTORS, dist);
 
     c.bench_function("storage vector search",
                      |b| b.iter(|| {
                          let vector = random_vector(DIM);
-                         storage.score_all(&vector, 10, &dist)
+                         storage.score_all(&vector, 10)
                      }));
 }
 
@@ -64,9 +64,8 @@ fn benchmark_ndarray(c: &mut Criterion) {
                                  .cloned()
                                  .enumerate()
                                  .map(
-                                     |(idx, score)| ScoredPointOffset { idx, score }),
-                             10,
-                             &Distance::Dot,
+                                     |(idx, score)| ScoredPointOffset { idx: idx as PointOffsetType, score }),
+                             10
                          );
                      }));
 }

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index e275d6159..85a9aba75 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,10 +1,10 @@
-use criterion::{Criterion, criterion_group, criterion_main};
+use criterion::{criterion_group, criterion_main, Criterion};
 use itertools::Itertools;
-use ndarray::{Array, Array1, Array2, ArrayBase, ShapeBuilder, Axis};
+use ndarray::{Array, Array1, Array2, ArrayBase, Axis, ShapeBuilder};
 use tempdir::TempDir;
 
 use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
-use segment::types::{Distance, VectorElementType, PointOffsetType};
+use segment::types::{Distance, PointOffsetType, VectorElementType};
 use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
 use segment::vector_storage::vector_storage::{ScoredPointOffset, VectorStorage};
 
@@ -15,11 +15,16 @@ fn random_vector(size: usize) -> Vec<VectorElementType> {
     let mut vec: Vec<VectorElementType> = Vec::with_capacity(size);
     for _ in 0..vec.capacity() {
         vec.push(rand::random());
-    };
+    }
     return vec;
 }
 
-fn init_vector_storage(dir: &TempDir, dim: usize, num: usize, dist: Distance) -> SimpleVectorStorage {
+fn init_vector_storage(
+    dir: &TempDir,
+    dim: usize,
+    num: usize,
+    dist: Distance,
+) -> SimpleVectorStorage {
     let mut storage = SimpleVectorStorage::open(dir.path(), dim, dist).unwrap();
 
     for _i in 0..num {
@@ -36,11 +41,12 @@ fn benchmark_naive(c: &mut Criterion) {
     let dist = Distance::Dot;
     let storage = init_vector_storage(&dir, DIM, NUM_VECTORS, dist);
 
-    c.bench_function("storage vector search",
-                     |b| b.iter(|| {
-                         let vector = random_vector(DIM);
-                         storage.score_all(&vector, 10)
-                     }));
+    c.bench_function("storage vector search", |b| {
+        b.iter(|| {
+            let vector = random_vector(DIM);
+            storage.score_all(&vector, 10)
+        })
+    });
 }
 
 fn benchmark_ndarray(c: &mut Criterion) {
@@ -53,21 +59,24 @@ fn benchmark_ndarray(c: &mut Criterion) {
 
     eprintln!("matrix.shape() = {:#?}", matrix.shape());
 
-
-    c.bench_function("ndarray BLAS dot production",
-                     |b| b.iter(|| {
-                         let vector = Array::from(random_vector(DIM));
-                         let mut production_result = matrix.dot(&vector);
-
-                         let top = peek_top_scores_iterable(
-                             production_result.iter()
-                                 .cloned()
-                                 .enumerate()
-                                 .map(
-                                     |(idx, score)| ScoredPointOffset { idx: idx as PointOffsetType, score }),
-                             10
-                         );
-                     }));
+    c.bench_function("ndarray BLAS dot production", |b| {
+        b.iter(|| {
+            let vector = Array::from(random_vector(DIM));
+            let mut production_result = matrix.dot(&vector);
+
+            let top = peek_top_scores_iterable(
+                production_result
+                    .iter()
+                    .cloned()
+                    .enumerate()
+                    .map(|(idx, score)| ScoredPointOffset {
+                        idx: idx as PointOffsetType,
+                        score,
+                    }),
+                10,
+            );
+        })
+    });
 }
 
 criterion_group!(benches, benchmark_ndarray, benchmark_naive);

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 85a9aba75..4ba5515fc 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -6,7 +6,7 @@ use tempdir::TempDir;
 use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
 use segment::types::{Distance, PointOffsetType, VectorElementType};
 use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
-use segment::vector_storage::vector_storage::{ScoredPointOffset, VectorStorage};
+use segment::vector_storage::{ScoredPointOffset, VectorStorage};
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 4ba5515fc..fe1806e6f 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,9 +1,11 @@
 use criterion::{criterion_group, criterion_main, Criterion};
-use itertools::Itertools;
-use ndarray::{Array, Array1, Array2, ArrayBase, Axis, ShapeBuilder};
+
+use ndarray::Array;
+use rand::distributions::Standard;
+use rand::Rng;
 use tempdir::TempDir;
 
-use segment::spaces::tools::{peek_top_scores, peek_top_scores_iterable};
+use segment::spaces::tools::peek_top_scores_iterable;
 use segment::types::{Distance, PointOffsetType, VectorElementType};
 use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
 use segment::vector_storage::{ScoredPointOffset, VectorStorage};
@@ -12,11 +14,9 @@ const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
 
 fn random_vector(size: usize) -> Vec<VectorElementType> {
-    let mut vec: Vec<VectorElementType> = Vec::with_capacity(size);
-    for _ in 0..vec.capacity() {
-        vec.push(rand::random());
-    }
-    return vec;
+    let rng = rand::thread_rng();
+
+    rng.sample_iter(Standard).take(size).collect()
 }
 
 fn init_vector_storage(

commit fdcc4fa67404d58f53408bca9a6210958292aa82
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Thu Nov 11 10:42:27 2021 +0100

    Fix ndarray imports in segment benches (#121)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index fe1806e6f..7ad00c5d7 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,6 +1,6 @@
 use criterion::{criterion_group, criterion_main, Criterion};
 
-use ndarray::Array;
+use ndarray::{Array, Array2};
 use rand::distributions::Standard;
 use rand::Rng;
 use tempdir::TempDir;

commit c1a790a7af6fb0219b64b470ffd48956b360cba1
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Fri Nov 12 19:16:00 2021 +0100

    Add more refactorings (#122)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 7ad00c5d7..5d8cb102f 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,5 +1,4 @@
 use criterion::{criterion_group, criterion_main, Criterion};
-
 use ndarray::{Array, Array2};
 use rand::distributions::Standard;
 use rand::Rng;
@@ -50,7 +49,7 @@ fn benchmark_naive(c: &mut Criterion) {
 }
 
 fn benchmark_ndarray(c: &mut Criterion) {
-    let mut matrix: Array2<f32> = Array::<f32, _>::zeros((NUM_VECTORS, DIM));
+    let mut matrix = Array2::<f32>::zeros((NUM_VECTORS, DIM));
 
     for i in 0..NUM_VECTORS {
         let vector = Array::from(random_vector(DIM));
@@ -62,9 +61,9 @@ fn benchmark_ndarray(c: &mut Criterion) {
     c.bench_function("ndarray BLAS dot production", |b| {
         b.iter(|| {
             let vector = Array::from(random_vector(DIM));
-            let mut production_result = matrix.dot(&vector);
+            let production_result = matrix.dot(&vector);
 
-            let top = peek_top_scores_iterable(
+            peek_top_scores_iterable(
                 production_result
                     .iter()
                     .cloned()

commit bcaa160ad8658fa4052aae4a854686379b1e35d7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 31 11:38:33 2021 +0300

    Remove dyn Metric from vector storage and use generics (#163)
    
    * Remove dyn Metric from vector storage and use generics
    
    * upd benchmark code
    
    * fix benchmark usage
    
    * fmt
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 5d8cb102f..f5ac903fd 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,12 +1,14 @@
+use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
 use ndarray::{Array, Array2};
 use rand::distributions::Standard;
 use rand::Rng;
+use std::sync::Arc;
 use tempdir::TempDir;
 
 use segment::spaces::tools::peek_top_scores_iterable;
 use segment::types::{Distance, PointOffsetType, VectorElementType};
-use segment::vector_storage::simple_vector_storage::SimpleVectorStorage;
+use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{ScoredPointOffset, VectorStorage};
 
 const NUM_VECTORS: usize = 50000;
@@ -23,12 +25,14 @@ fn init_vector_storage(
     dim: usize,
     num: usize,
     dist: Distance,
-) -> SimpleVectorStorage {
-    let mut storage = SimpleVectorStorage::open(dir.path(), dim, dist).unwrap();
-
-    for _i in 0..num {
-        let vector: Vec<VectorElementType> = random_vector(dim);
-        storage.put_vector(vector).unwrap();
+) -> Arc<AtomicRefCell<dyn VectorStorage>> {
+    let storage = open_simple_vector_storage(dir.path(), dim, dist).unwrap();
+    {
+        let mut borrowed_storage = storage.borrow_mut();
+        for _i in 0..num {
+            let vector: Vec<VectorElementType> = random_vector(dim);
+            borrowed_storage.put_vector(vector).unwrap();
+        }
     }
 
     storage
@@ -39,11 +43,15 @@ fn benchmark_naive(c: &mut Criterion) {
 
     let dist = Distance::Dot;
     let storage = init_vector_storage(&dir, DIM, NUM_VECTORS, dist);
+    let borrowed_storage = storage.borrow();
+
+    let mut group = c.benchmark_group("storage-score-all");
+    group.sample_size(1000);
 
-    c.bench_function("storage vector search", |b| {
+    group.bench_function("storage vector search", |b| {
         b.iter(|| {
             let vector = random_vector(DIM);
-            storage.score_all(&vector, 10)
+            borrowed_storage.score_all(&vector, 10)
         })
     });
 }

commit 297f54141d82fe4923847715a6253bb804f28022
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Jan 3 22:16:27 2022 +0300

    remove blas

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index f5ac903fd..53f3694a8 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -12,7 +12,7 @@ use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{ScoredPointOffset, VectorStorage};
 
 const NUM_VECTORS: usize = 50000;
-const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
+const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage
 
 fn random_vector(size: usize) -> Vec<VectorElementType> {
     let rng = rand::thread_rng();
@@ -66,7 +66,7 @@ fn benchmark_ndarray(c: &mut Criterion) {
 
     eprintln!("matrix.shape() = {:#?}", matrix.shape());
 
-    c.bench_function("ndarray BLAS dot production", |b| {
+    c.bench_function("ndarray SIMD dot production", |b| {
         b.iter(|| {
             let vector = Array::from(random_vector(DIM));
             let production_result = matrix.dot(&vector);

commit ee461ce0a6cc031e8289bc7a238bb2e807e85b20
Author: Prokudin Alexander <prok20@inbox.ru>
Date:   Tue Jan 18 01:33:26 2022 +0300

    Extend clippy to workspace and fix some warnings (#199)
    
    * Fix clippy in linting workflow
    
    * Add toolchain override flag
    
    * Add components to toolchain installation explicitly
    
    * Add --workspace flag to clippy to check all packages
    
    * Remove unnecessary clones
    
    * remove redundant .clone() calls
    
    * fix wrong arguments order in tests (typo)
    
    * Fix vec! macro usage in test
    
    * Correct redundant assert! usages
    
    * Provide a quick fix for 'unused' test function lint
    
    * fix unsound Send + Sync
    
    * fix clippy complains
    
    * fmt
    
    * fix clippy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index f5ac903fd..c24ff42ae 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -9,7 +9,7 @@ use tempdir::TempDir;
 use segment::spaces::tools::peek_top_scores_iterable;
 use segment::types::{Distance, PointOffsetType, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use segment::vector_storage::{ScoredPointOffset, VectorStorage};
+use segment::vector_storage::{ScoredPointOffset, VectorStorageSS};
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
@@ -25,7 +25,7 @@ fn init_vector_storage(
     dim: usize,
     num: usize,
     dist: Distance,
-) -> Arc<AtomicRefCell<dyn VectorStorage>> {
+) -> Arc<AtomicRefCell<VectorStorageSS>> {
     let storage = open_simple_vector_storage(dir.path(), dim, dist).unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();

commit 2c4fd0a2059bc3d03e8cd0116bec23792c03ad87
Merge: 063d0abe8 bb8dba39b
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 15:48:25 2022 +0000

    Merge branch 'master' into remove-blas

diff --cc lib/segment/benches/vector_search.rs
index 53f3694a8,c24ff42ae..27a3eeba3
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@@ -9,10 -9,10 +9,10 @@@ use tempdir::TempDir
  use segment::spaces::tools::peek_top_scores_iterable;
  use segment::types::{Distance, PointOffsetType, VectorElementType};
  use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
- use segment::vector_storage::{ScoredPointOffset, VectorStorage};
+ use segment::vector_storage::{ScoredPointOffset, VectorStorageSS};
  
  const NUM_VECTORS: usize = 50000;
 -const DIM: usize = 1000; // Larger dimensionality - greater the BLAS advantage
 +const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage
  
  fn random_vector(size: usize) -> Vec<VectorElementType> {
      let rng = rand::thread_rng();

commit a91e77b824540f7394e0a65da465f223b817bbca
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 9 21:40:16 2022 +0000

    fix segment benches

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 27a3eeba3..a7a6ae67a 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,15 +1,13 @@
 use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
-use ndarray::{Array, Array2};
 use rand::distributions::Standard;
 use rand::Rng;
 use std::sync::Arc;
 use tempdir::TempDir;
 
-use segment::spaces::tools::peek_top_scores_iterable;
-use segment::types::{Distance, PointOffsetType, VectorElementType};
+use segment::types::{Distance, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use segment::vector_storage::{ScoredPointOffset, VectorStorageSS};
+use segment::vector_storage::VectorStorageSS;
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage
@@ -56,35 +54,5 @@ fn benchmark_naive(c: &mut Criterion) {
     });
 }
 
-fn benchmark_ndarray(c: &mut Criterion) {
-    let mut matrix = Array2::<f32>::zeros((NUM_VECTORS, DIM));
-
-    for i in 0..NUM_VECTORS {
-        let vector = Array::from(random_vector(DIM));
-        matrix.row_mut(i).assign(&vector);
-    }
-
-    eprintln!("matrix.shape() = {:#?}", matrix.shape());
-
-    c.bench_function("ndarray SIMD dot production", |b| {
-        b.iter(|| {
-            let vector = Array::from(random_vector(DIM));
-            let production_result = matrix.dot(&vector);
-
-            peek_top_scores_iterable(
-                production_result
-                    .iter()
-                    .cloned()
-                    .enumerate()
-                    .map(|(idx, score)| ScoredPointOffset {
-                        idx: idx as PointOffsetType,
-                        score,
-                    }),
-                10,
-            );
-        })
-    });
-}
-
-criterion_group!(benches, benchmark_ndarray, benchmark_naive);
+criterion_group!(benches, benchmark_naive);
 criterion_main!(benches);

commit effb79733d8936b5a1afb4ab45dba4b355f75999
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri May 13 17:06:07 2022 +0400

    Unite rocksdb of segment (#585)
    
    unite rocksdb for segment

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index a7a6ae67a..9b648214a 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -2,9 +2,11 @@ use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
+use std::path::Path;
 use std::sync::Arc;
 use tempdir::TempDir;
 
+use segment::common::rocksdb_operations::open_db;
 use segment::types::{Distance, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::VectorStorageSS;
@@ -19,12 +21,13 @@ fn random_vector(size: usize) -> Vec<VectorElementType> {
 }
 
 fn init_vector_storage(
-    dir: &TempDir,
+    path: &Path,
     dim: usize,
     num: usize,
     dist: Distance,
 ) -> Arc<AtomicRefCell<VectorStorageSS>> {
-    let storage = open_simple_vector_storage(dir.path(), dim, dist).unwrap();
+    let db = open_db(path).unwrap();
+    let storage = open_simple_vector_storage(db, dim, dist).unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();
         for _i in 0..num {
@@ -40,7 +43,7 @@ fn benchmark_naive(c: &mut Criterion) {
     let dir = TempDir::new("storage_dir").unwrap();
 
     let dist = Distance::Dot;
-    let storage = init_vector_storage(&dir, DIM, NUM_VECTORS, dist);
+    let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
     let borrowed_storage = storage.borrow();
 
     let mut group = c.benchmark_group("storage-score-all");

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 9b648214a..465a7dd50 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,15 +1,15 @@
+use std::path::Path;
+use std::sync::Arc;
+
 use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
-use std::path::Path;
-use std::sync::Arc;
-use tempdir::TempDir;
-
 use segment::common::rocksdb_operations::open_db;
 use segment::types::{Distance, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::VectorStorageSS;
+use tempdir::TempDir;
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage

commit 8e1f2ca35322cc699232ec8d8177fe05baae3f98
Author: Russ Cam <russ.cam@forloop.co.uk>
Date:   Wed Aug 10 17:39:21 2022 +1000

    Use tempfile (#922)
    
    This commit replaces tempdir with tempfile.
    tempdir is archived.
    
    Closes #544

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 465a7dd50..1dbe80977 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -9,7 +9,7 @@ use segment::common::rocksdb_operations::open_db;
 use segment::types::{Distance, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::VectorStorageSS;
-use tempdir::TempDir;
+use tempfile::Builder;
 
 const NUM_VECTORS: usize = 50000;
 const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage
@@ -40,7 +40,7 @@ fn init_vector_storage(
 }
 
 fn benchmark_naive(c: &mut Criterion) {
-    let dir = TempDir::new("storage_dir").unwrap();
+    let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
 
     let dist = Distance::Dot;
     let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);

commit f9fb0777a0fa67f3b297140493a3c71a4ef42064
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 22 10:41:08 2022 +0300

    Wrap rocksdb column usages (#951)
    
    * wrap rocksdb column usages
    
    * remove obsolete comments
    
    * are you happy clippy

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 1dbe80977..b1363849a 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -5,7 +5,7 @@ use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
-use segment::common::rocksdb_operations::open_db;
+use segment::common::rocksdb_wrapper::open_db;
 use segment::types::{Distance, VectorElementType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::VectorStorageSS;

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index b1363849a..6fb11ea74 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -5,8 +5,9 @@ use atomic_refcell::AtomicRefCell;
 use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
-use segment::common::rocksdb_wrapper::open_db;
-use segment::types::{Distance, VectorElementType};
+use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+use segment::data_types::vectors::VectorElementType;
+use segment::types::Distance;
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::VectorStorageSS;
 use tempfile::Builder;
@@ -26,8 +27,8 @@ fn init_vector_storage(
     num: usize,
     dist: Distance,
 ) -> Arc<AtomicRefCell<VectorStorageSS>> {
-    let db = open_db(path).unwrap();
-    let storage = open_simple_vector_storage(db, dim, dist).unwrap();
+    let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
+    let storage = open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist).unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();
         for _i in 0..num {

commit 9bb29c26a6ddf3aa0092d45f797aca45735b9ba3
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Mar 9 09:43:20 2023 +0400

    Vector storages enum (#1533)
    
    * separate scoring and data containing
    
    * vector storage enum
    
    * fix test build
    
    * are you happy clippy
    
    * review fixes

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 6fb11ea74..75cefbc50 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -9,7 +9,7 @@ use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::VectorElementType;
 use segment::types::Distance;
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use segment::vector_storage::VectorStorageSS;
+use segment::vector_storage::{VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 
 const NUM_VECTORS: usize = 50000;
@@ -26,7 +26,7 @@ fn init_vector_storage(
     dim: usize,
     num: usize,
     dist: Distance,
-) -> Arc<AtomicRefCell<VectorStorageSS>> {
+) -> Arc<AtomicRefCell<VectorStorageEnum>> {
     let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
     let storage = open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist).unwrap();
     {
@@ -46,6 +46,7 @@ fn benchmark_naive(c: &mut Criterion) {
     let dist = Distance::Dot;
     let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
     let borrowed_storage = storage.borrow();
+    let vector_scorer = borrowed_storage.scorer();
 
     let mut group = c.benchmark_group("storage-score-all");
     group.sample_size(1000);
@@ -53,7 +54,7 @@ fn benchmark_naive(c: &mut Criterion) {
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
             let vector = random_vector(DIM);
-            borrowed_storage.score_all(&vector, 10)
+            vector_scorer.score_all(&vector, 10)
         })
     });
 }

commit 9639df19985bfa6d13d6bb8fb0c8beb1031ce51e
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Mar 11 23:13:24 2023 +0400

    Remove vector scorer trait (#1546)
    
    * remove vector scorer
    
    * nits
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 75cefbc50..f4816471a 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -46,7 +46,6 @@ fn benchmark_naive(c: &mut Criterion) {
     let dist = Distance::Dot;
     let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
     let borrowed_storage = storage.borrow();
-    let vector_scorer = borrowed_storage.scorer();
 
     let mut group = c.benchmark_group("storage-score-all");
     group.sample_size(1000);
@@ -54,7 +53,7 @@ fn benchmark_naive(c: &mut Criterion) {
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
             let vector = random_vector(DIM);
-            vector_scorer.score_all(&vector, 10)
+            borrowed_storage.raw_scorer(vector).peek_top_all(10)
         })
     });
 }

commit 9cfbfe7637ab823d21ece83966c7c3245f1c8be6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sat Mar 11 23:25:18 2023 +0100

    add benchmark for random vector scoring

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index f4816471a..6d18be8b4 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -7,13 +7,13 @@ use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::VectorElementType;
-use segment::types::Distance;
+use segment::types::{Distance, PointOffsetType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 
-const NUM_VECTORS: usize = 50000;
-const DIM: usize = 1000; // Larger dimensionality - greater the SIMD advantage
+const NUM_VECTORS: usize = 100000;
+const DIM: usize = 1024; // Larger dimensionality - greater the SIMD advantage
 
 fn random_vector(size: usize) -> Vec<VectorElementType> {
     let rng = rand::thread_rng();
@@ -48,7 +48,6 @@ fn benchmark_naive(c: &mut Criterion) {
     let borrowed_storage = storage.borrow();
 
     let mut group = c.benchmark_group("storage-score-all");
-    group.sample_size(1000);
 
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
@@ -58,5 +57,27 @@ fn benchmark_naive(c: &mut Criterion) {
     });
 }
 
-criterion_group!(benches, benchmark_naive);
+fn random_access_benchmark(c: &mut Criterion) {
+    let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
+
+    let dist = Distance::Dot;
+    let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
+    let borrowed_storage = storage.borrow();
+
+    let mut group = c.benchmark_group("storage-score-random");
+
+    let vector = random_vector(DIM);
+    let scorer = borrowed_storage.raw_scorer(vector);
+
+    let mut total_score = 0.;
+    group.bench_function("storage vector search", |b| {
+        b.iter(|| {
+            let random_id = rand::thread_rng().gen_range(0..NUM_VECTORS) as PointOffsetType;
+            total_score += scorer.score_point(random_id);
+        })
+    });
+    eprintln!("total_score = {:?}", total_score);
+}
+
+criterion_group!(benches, benchmark_naive, random_access_benchmark);
 criterion_main!(benches);

commit e3448c0056978a47fb9c1b0d95742bebd2ae99f0
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Wed Mar 15 17:05:07 2023 +0400

    Remove deleted flags from vector storage (#1561)
    
    * remove deleted flags from vector storage
    
    * remove deleted flags from mmap
    
    * new simple vector storage format
    
    * are you happy clippy
    
    * remove id_tracker from raw_scorer
    
    * revert vector storage format changes
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 6d18be8b4..e7531dea7 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -7,9 +7,11 @@ use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::VectorElementType;
+use segment::fixtures::payload_context_fixture::FixtureIdTracker;
+use segment::id_tracker::IdTrackerSS;
 use segment::types::{Distance, PointOffsetType};
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
-use segment::vector_storage::{VectorStorage, VectorStorageEnum};
+use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 
 const NUM_VECTORS: usize = 100000;
@@ -26,33 +28,45 @@ fn init_vector_storage(
     dim: usize,
     num: usize,
     dist: Distance,
-) -> Arc<AtomicRefCell<VectorStorageEnum>> {
+) -> (
+    Arc<AtomicRefCell<VectorStorageEnum>>,
+    Arc<AtomicRefCell<IdTrackerSS>>,
+) {
     let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
+    let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num)));
     let storage = open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist).unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();
-        for _i in 0..num {
+        for i in 0..num {
             let vector: Vec<VectorElementType> = random_vector(dim);
-            borrowed_storage.put_vector(vector).unwrap();
+            borrowed_storage
+                .insert_vector(i as PointOffsetType, &vector)
+                .unwrap();
         }
     }
 
-    storage
+    (storage, id_tracker)
 }
 
 fn benchmark_naive(c: &mut Criterion) {
     let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
 
     let dist = Distance::Dot;
-    let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
+    let (storage, id_tracker) = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
     let borrowed_storage = storage.borrow();
+    let borrowed_id_tracker = id_tracker.borrow();
 
     let mut group = c.benchmark_group("storage-score-all");
 
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
             let vector = random_vector(DIM);
-            borrowed_storage.raw_scorer(vector).peek_top_all(10)
+            new_raw_scorer(
+                vector,
+                &borrowed_storage,
+                borrowed_id_tracker.deleted_bitvec(),
+            )
+            .peek_top_all(10)
         })
     });
 }
@@ -61,13 +75,18 @@ fn random_access_benchmark(c: &mut Criterion) {
     let dir = Builder::new().prefix("storage_dir").tempdir().unwrap();
 
     let dist = Distance::Dot;
-    let storage = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
+    let (storage, id_tracker) = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
     let borrowed_storage = storage.borrow();
+    let borrowed_id_tracker = id_tracker.borrow();
 
     let mut group = c.benchmark_group("storage-score-random");
 
     let vector = random_vector(DIM);
-    let scorer = borrowed_storage.raw_scorer(vector);
+    let scorer = new_raw_scorer(
+        vector,
+        &borrowed_storage,
+        borrowed_id_tracker.deleted_bitvec(),
+    );
 
     let mut total_score = 0.;
     group.bench_function("storage vector search", |b| {

commit 511704d88d8f915eb142e5873edbf20d249c3132
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 20 12:06:29 2023 +0200

    Add support for deleted vectors in segments (#1724)
    
    * Use resize rather than while-push loop
    
    * Add deleted flags to simple vector storage
    
    * Add deleted flag to memmap vector storage
    
    * Map BitSlice on mmap file for deleted flags
    
    * Use vector specific deletion BitSlice in RawScorer
    
    * Use BitSlice for deleted points, fix check point logic, clarify names
    
    * Extract div_ceil function to shared module
    
    * We can use unchecked set and replace because we just checked the length
    
    * Add deleted count function to vector storage
    
    * Add vector storage point deletion tests
    
    * Keep deleted state in simple vector storage with update_from, add test
    
    * Keep deleted state in memmap vector storage with update_from, add test
    
    * Simplify div_ceil
    
    * Improve deletion handling in update_from in mmap vector storage
    
    * Improve performance, use trickery to get BitSlice view over deleted mmap
    
    * Use BitSlice where possible, construct BitVec more efficiently
    
    * Incorporate vector specific delete flags in quantized raw scorer
    
    * Don't pin MmapMut, it is not required
    
    * With quantization, keep mmap deleted flags in RAM for better performance
    
    * Advice the kernel to prepare deleted flags mmap for faster future access
    
    * Simplify deleted bitslice access, add bound check, remove unused function
    
    * Fix compilation on Windows
    
    * Cleanup
    
    * Rename delete functions to delete_{point,vec} to prevent confusion
    
    * Use then_some rather than match a boolean
    
    * Lock deleted flags in memory only when quantization is available
    
    * Add docs and stabilize issue link to dev_ceil
    
    * Flush deleted mmap when closing segment
    
    This requires us to to wrap the memory map struct in an Arc and Mutex.
    Though this may look inefficient, it doesn't have a negative side effect
    on deleted flag performance, because the flags are accessed through a
    BitSlice that is separate and doesn't use locking.
    
    * Rename some point functions to vec because that makes more sense
    
    * Simplify delete flag fetching option, use deref func instead of asterisk
    
    * Do not calculate slice size manually, use size_of_val
    
    * remove test raw scorer
    
    * use deref in check
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index e7531dea7..366b17a3b 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -64,7 +64,7 @@ fn benchmark_naive(c: &mut Criterion) {
             new_raw_scorer(
                 vector,
                 &borrowed_storage,
-                borrowed_id_tracker.deleted_bitvec(),
+                borrowed_id_tracker.deleted_point_bitslice(),
             )
             .peek_top_all(10)
         })
@@ -85,7 +85,7 @@ fn random_access_benchmark(c: &mut Criterion) {
     let scorer = new_raw_scorer(
         vector,
         &borrowed_storage,
-        borrowed_id_tracker.deleted_bitvec(),
+        borrowed_id_tracker.deleted_point_bitslice(),
     );
 
     let mut total_score = 0.;

commit c8bdec7b0616c47e1c3057b3f8ef8435833dc74f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Sep 5 09:26:24 2023 -0300

    Refactor batch search to allow different scorers (#2529)
    
    * add enum for vector query on segment search
    
    * rename newly introduced types
    
    * fix: handle QueryVector on async scorer
    
    * handle QueryVector in QuantizedVectors impl
    
    * fix async scorer test after refactor
    
    * rebase + refactor on queue_proxy_shard.rs
    
    * constrain refactor propagation to segment_searcher
    
    * fmt
    
    * fix after rebase

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 366b17a3b..d3383a6bc 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -61,6 +61,7 @@ fn benchmark_naive(c: &mut Criterion) {
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
             let vector = random_vector(DIM);
+            let vector = vector.as_slice().into();
             new_raw_scorer(
                 vector,
                 &borrowed_storage,
@@ -82,6 +83,8 @@ fn random_access_benchmark(c: &mut Criterion) {
     let mut group = c.benchmark_group("storage-score-random");
 
     let vector = random_vector(DIM);
+    let vector = vector.as_slice().into();
+
     let scorer = new_raw_scorer(
         vector,
         &borrowed_storage,

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index d3383a6bc..8528f3c3f 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -2,6 +2,7 @@ use std::path::Path;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::types::PointOffsetType;
 use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
@@ -9,7 +10,7 @@ use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::VectorElementType;
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
-use segment::types::{Distance, PointOffsetType};
+use segment::types::Distance;
 use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;

commit 5517cfbc9aa3923bea72ecac05c62eb1c72ee387
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Thu Oct 19 14:49:31 2023 +0200

    Use enum vector type in vector storage (#2841)
    
    * use enum vector type in vector storage
    
    * add to_vec_ref

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 8528f3c3f..863013598 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -41,7 +41,7 @@ fn init_vector_storage(
         for i in 0..num {
             let vector: Vec<VectorElementType> = random_vector(dim);
             borrowed_storage
-                .insert_vector(i as PointOffsetType, &vector)
+                .insert_vector(i as PointOffsetType, vector.as_slice().into())
                 .unwrap();
         }
     }

commit 7134ba7dc25ad7a2dccbbf9c3bd4f3072e46f6c5
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Oct 31 23:44:20 2023 +0100

    raw scorer with operation result (#2897)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 863013598..397602a0f 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -68,6 +68,7 @@ fn benchmark_naive(c: &mut Criterion) {
                 &borrowed_storage,
                 borrowed_id_tracker.deleted_point_bitslice(),
             )
+            .unwrap()
             .peek_top_all(10)
         })
     });
@@ -90,7 +91,8 @@ fn random_access_benchmark(c: &mut Criterion) {
         vector,
         &borrowed_storage,
         borrowed_id_tracker.deleted_point_bitslice(),
-    );
+    )
+    .unwrap();
 
     let mut total_score = 0.;
     group.bench_function("storage vector search", |b| {

commit 13f15955fcc5920aab21c3e1d5a2a81794f3e299
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Nov 21 09:18:15 2023 +0100

    Sparse vectors rest search and upsert (#3051)
    
    * sparse vector sparse search and upsert
    
    are you happy fmt
    
    fix build
    
    update openapi
    
    batch changes
    
    update openapi
    
    named sparse vector
    
    * review remarks
    
    * cowvalue to cowvector

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 397602a0f..91df76afd 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -7,7 +7,7 @@ use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-use segment::data_types::vectors::VectorElementType;
+use segment::data_types::vectors::{Vector, VectorElementType};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
@@ -39,9 +39,9 @@ fn init_vector_storage(
     {
         let mut borrowed_storage = storage.borrow_mut();
         for i in 0..num {
-            let vector: Vec<VectorElementType> = random_vector(dim);
+            let vector: Vector = random_vector(dim).into();
             borrowed_storage
-                .insert_vector(i as PointOffsetType, vector.as_slice().into())
+                .insert_vector(i as PointOffsetType, vector.to_vec_ref())
                 .unwrap();
         }
     }

commit 8c93500998e7fb1fa8d6435d6561dd4316ab7b2d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Dec 13 17:08:37 2023 +0000

    Rename SimpleDenseVectorStorage (#3223)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 91df76afd..cf5058914 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -11,7 +11,7 @@ use segment::data_types::vectors::{Vector, VectorElementType};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
-use segment::vector_storage::simple_vector_storage::open_simple_vector_storage;
+use segment::vector_storage::simple_dense_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 

commit 8ae92d47161cbb90b6c211400cc307069858ffc6
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Feb 8 12:52:03 2024 +0100

    allow stopping segment loading (#3498)
    
    * allow stopping segment loading
    
    * fix benches

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index cf5058914..8aa71ecf9 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,4 +1,5 @@
 use std::path::Path;
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
@@ -35,7 +36,8 @@ fn init_vector_storage(
 ) {
     let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
     let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num)));
-    let storage = open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist).unwrap();
+    let storage =
+        open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist, &AtomicBool::new(false)).unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();
         for i in 0..num {

commit fb796d4888aa1c4d1f19826f7fa66a431c88867e
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Feb 28 10:31:16 2024 +0100

    Use DenseVector alias where possible (#3705)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 8aa71ecf9..873a5cf46 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -8,7 +8,7 @@ use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-use segment::data_types::vectors::{Vector, VectorElementType};
+use segment::data_types::vectors::{DenseVector, Vector};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
@@ -19,7 +19,7 @@ use tempfile::Builder;
 const NUM_VECTORS: usize = 100000;
 const DIM: usize = 1024; // Larger dimensionality - greater the SIMD advantage
 
-fn random_vector(size: usize) -> Vec<VectorElementType> {
+fn random_vector(size: usize) -> DenseVector {
     let rng = rand::thread_rng();
 
     rng.sample_iter(Standard).take(size).collect()

commit 8ce9d0fa8774884a6fc68d042860d4f7ba423b04
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Mar 19 14:35:17 2024 +0100

    Remove duplicated VectorRef conversion (#3864)

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 873a5cf46..bace7420c 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -8,7 +8,7 @@ use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-use segment::data_types::vectors::{DenseVector, Vector};
+use segment::data_types::vectors::{DenseVector, Vector, VectorRef};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
@@ -43,7 +43,7 @@ fn init_vector_storage(
         for i in 0..num {
             let vector: Vector = random_vector(dim).into();
             borrowed_storage
-                .insert_vector(i as PointOffsetType, vector.to_vec_ref())
+                .insert_vector(i as PointOffsetType, VectorRef::from(&vector))
                 .unwrap();
         }
     }

commit 6b3629e2fc77aee1aa63b361ed827916497289b3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Mar 25 13:21:21 2024 +0100

    Refactor vector storage infra to be generic over vector element type (#3900)
    
    * make SimpleDenseVectorStorage generic against VectorElementType
    
    * make generic loading of the simple dense storage
    
    * move memmap_dense_vector_storage
    
    * move mmap_dense_vectors
    
    * move appendable_mmap_dense_vector_storage
    
    * fmt
    
    * move dynamic_mmap_flags
    
    * move simple_dense_vector_storage
    
    * move PrimitiveVectorElement
    
    * fmt
    
    * make MmapDenseVectors generic
    
    * make MemmapDenseVectorStorage generic to data type
    
    * fix UringReader on non-linux platform
    
    * make ChunkedMmapVectors generic of the vector element type
    
    * make AppendableMmapDenseVectorStorage generic of the vector element type
    
    * make PrimitiveVectorElement trait even more global
    
    * make Metric generic over vector element type and refactor it into GenericMetric
    
    * make DenseVectorStorage generic over vector element
    
    * remove temorary trait for migrating Metric
    
    * make CustomQueryScorer generic against vector element type
    
    * refactor PrimitiveVectorElement to use Cow and allow owned conversions
    
    * Move score post-processing out of metric object
    
    * naive implementation of metrics for byte vectors

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index bace7420c..0b4e0d1ac 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -12,7 +12,7 @@ use segment::data_types::vectors::{DenseVector, Vector, VectorRef};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
-use segment::vector_storage::simple_dense_vector_storage::open_simple_vector_storage;
+use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
 use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 

commit a330542c8ac3b3228e0f06d1b9fd1c2ce36230f0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Apr 8 12:22:24 2024 +0200

    Integrate Multivector at segment level (#3973)
    
    * Integrate Multivector at segment level
    
    * more tests - green with lower accuracy
    
    * decrease expected accuracy to fix test
    
    * cleanup test
    
    * multivector can not be empty
    
    * vary number of vector per multivec point

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 0b4e0d1ac..afd699fa0 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -12,7 +12,7 @@ use segment::data_types::vectors::{DenseVector, Vector, VectorRef};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
-use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_vector_storage;
+use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
 use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 
@@ -37,7 +37,8 @@ fn init_vector_storage(
     let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
     let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num)));
     let storage =
-        open_simple_vector_storage(db, DB_VECTOR_CF, dim, dist, &AtomicBool::new(false)).unwrap();
+        open_simple_dense_vector_storage(db, DB_VECTOR_CF, dim, dist, &AtomicBool::new(false))
+            .unwrap();
     {
         let mut borrowed_storage = storage.borrow_mut();
         for i in 0..num {

commit 96ecd2cca8ba311282b5d72c9e41ed71ddca036d
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Jun 4 11:16:11 2024 +0200

    Fix hnsw full scan threshold (#4369)
    
    * fix hnsw full scan threshold
    
    * add test
    
    * are you happy clippy
    
    * separate open_vector_storage
    
    * remove public fields from builder
    
    * wip: do not create segment in builder before build
    
    * avoid arc in storage test and low-level loading functions
    
    * WIP: remove internal segment from SegmentBuilder
    
    * fmt
    
    * finalize segment builder fixes
    
    * Revert "are you happy clippy"
    
    This reverts commit c04afa698995f75f8b589737c2a794aee03824d8.
    
    * Revert "add test"
    
    This reverts commit 8e7ad6207ed042f25dcd07a16fac7c109b9c5a9e.
    
    * Revert "fix hnsw full scan threshold"
    
    This reverts commit 8904443fcb849cca30885b0b6980b0113ed25c16.
    
    * remove _daatabse from builder
    
    * fix optimizer test
    
    * fix id tracker versions persistence
    
    * do flush for segment components on build
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index afd699fa0..c915f58da 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -30,20 +30,16 @@ fn init_vector_storage(
     dim: usize,
     num: usize,
     dist: Distance,
-) -> (
-    Arc<AtomicRefCell<VectorStorageEnum>>,
-    Arc<AtomicRefCell<IdTrackerSS>>,
-) {
+) -> (VectorStorageEnum, Arc<AtomicRefCell<IdTrackerSS>>) {
     let db = open_db(path, &[DB_VECTOR_CF]).unwrap();
     let id_tracker = Arc::new(AtomicRefCell::new(FixtureIdTracker::new(num)));
-    let storage =
+    let mut storage =
         open_simple_dense_vector_storage(db, DB_VECTOR_CF, dim, dist, &AtomicBool::new(false))
             .unwrap();
     {
-        let mut borrowed_storage = storage.borrow_mut();
         for i in 0..num {
             let vector: Vector = random_vector(dim).into();
-            borrowed_storage
+            storage
                 .insert_vector(i as PointOffsetType, VectorRef::from(&vector))
                 .unwrap();
         }
@@ -57,7 +53,6 @@ fn benchmark_naive(c: &mut Criterion) {
 
     let dist = Distance::Dot;
     let (storage, id_tracker) = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
-    let borrowed_storage = storage.borrow();
     let borrowed_id_tracker = id_tracker.borrow();
 
     let mut group = c.benchmark_group("storage-score-all");
@@ -68,7 +63,7 @@ fn benchmark_naive(c: &mut Criterion) {
             let vector = vector.as_slice().into();
             new_raw_scorer(
                 vector,
-                &borrowed_storage,
+                &storage,
                 borrowed_id_tracker.deleted_point_bitslice(),
             )
             .unwrap()
@@ -82,7 +77,6 @@ fn random_access_benchmark(c: &mut Criterion) {
 
     let dist = Distance::Dot;
     let (storage, id_tracker) = init_vector_storage(dir.path(), DIM, NUM_VECTORS, dist);
-    let borrowed_storage = storage.borrow();
     let borrowed_id_tracker = id_tracker.borrow();
 
     let mut group = c.benchmark_group("storage-score-random");
@@ -92,7 +86,7 @@ fn random_access_benchmark(c: &mut Criterion) {
 
     let scorer = new_raw_scorer(
         vector,
-        &borrowed_storage,
+        &storage,
         borrowed_id_tracker.deleted_point_bitslice(),
     )
     .unwrap();

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index c915f58da..300765d10 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -98,7 +98,7 @@ fn random_access_benchmark(c: &mut Criterion) {
             total_score += scorer.score_point(random_id);
         })
     });
-    eprintln!("total_score = {:?}", total_score);
+    eprintln!("total_score = {total_score:?}");
 }
 
 criterion_group!(benches, benchmark_naive, random_access_benchmark);

commit 1d0ee7ea32043598f8b240e6a3a52be20663fa44
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Oct 9 10:15:46 2024 +0200

    Inference interface in REST and gRPC (#5165)
    
    * include document & image objects into grpc API
    
    * introduce image and object to rest api
    
    * minor refactoring
    
    * rename Vector -> VectorInternal
    
    * decompose vector data structures
    
    * add schema
    
    * fmt
    
    * grpc docs
    
    * fix conversion
    
    * fix clippy
    
    * fix another conversion
    
    * rename VectorInput -> VectorInputInternal
    
    * replace grpc TryFrom with async functions
    
    * fmt
    
    * replace rest TryFrom with async functions
    
    * add image and object into query rest
    
    * separate inference related conversions
    
    * move json-related conversions into a separate file
    
    * move vector-related transformations into a separate file
    
    * move more vector related-conversions into dedicated module

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 300765d10..45db2fba7 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -8,7 +8,7 @@ use criterion::{criterion_group, criterion_main, Criterion};
 use rand::distributions::Standard;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-use segment::data_types::vectors::{DenseVector, Vector, VectorRef};
+use segment::data_types::vectors::{DenseVector, VectorInternal, VectorRef};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
@@ -38,7 +38,7 @@ fn init_vector_storage(
             .unwrap();
     {
         for i in 0..num {
-            let vector: Vector = random_vector(dim).into();
+            let vector: VectorInternal = random_vector(dim).into();
             storage
                 .insert_vector(i as PointOffsetType, VectorRef::from(&vector))
                 .unwrap();

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 45db2fba7..2b348075f 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -13,7 +13,7 @@ use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
 use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-use segment::vector_storage::{new_raw_scorer, VectorStorage, VectorStorageEnum};
+use segment::vector_storage::{new_raw_scorer_for_test, VectorStorage, VectorStorageEnum};
 use tempfile::Builder;
 
 const NUM_VECTORS: usize = 100000;
@@ -61,7 +61,7 @@ fn benchmark_naive(c: &mut Criterion) {
         b.iter(|| {
             let vector = random_vector(DIM);
             let vector = vector.as_slice().into();
-            new_raw_scorer(
+            new_raw_scorer_for_test(
                 vector,
                 &storage,
                 borrowed_id_tracker.deleted_point_bitslice(),
@@ -84,7 +84,7 @@ fn random_access_benchmark(c: &mut Criterion) {
     let vector = random_vector(DIM);
     let vector = vector.as_slice().into();
 
-    let scorer = new_raw_scorer(
+    let scorer = new_raw_scorer_for_test(
         vector,
         &storage,
         borrowed_id_tracker.deleted_point_bitslice(),

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 2b348075f..6f80f54f7 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -5,7 +5,7 @@ use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
 use criterion::{criterion_group, criterion_main, Criterion};
-use rand::distributions::Standard;
+use rand::distr::StandardUniform;
 use rand::Rng;
 use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
 use segment::data_types::vectors::{DenseVector, VectorInternal, VectorRef};
@@ -20,9 +20,9 @@ const NUM_VECTORS: usize = 100000;
 const DIM: usize = 1024; // Larger dimensionality - greater the SIMD advantage
 
 fn random_vector(size: usize) -> DenseVector {
-    let rng = rand::thread_rng();
+    let rng = rand::rng();
 
-    rng.sample_iter(Standard).take(size).collect()
+    rng.sample_iter(StandardUniform).take(size).collect()
 }
 
 fn init_vector_storage(
@@ -94,7 +94,7 @@ fn random_access_benchmark(c: &mut Criterion) {
     let mut total_score = 0.;
     group.bench_function("storage vector search", |b| {
         b.iter(|| {
-            let random_id = rand::thread_rng().gen_range(0..NUM_VECTORS) as PointOffsetType;
+            let random_id = rand::rng().random_range(0..NUM_VECTORS) as PointOffsetType;
             total_score += scorer.score_point(random_id);
         })
     });

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 6f80f54f7..9041e1d8c 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -1,19 +1,19 @@
 use std::path::Path;
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
-use criterion::{criterion_group, criterion_main, Criterion};
-use rand::distr::StandardUniform;
+use criterion::{Criterion, criterion_group, criterion_main};
 use rand::Rng;
-use segment::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
+use rand::distr::StandardUniform;
+use segment::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
 use segment::data_types::vectors::{DenseVector, VectorInternal, VectorRef};
 use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
 use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-use segment::vector_storage::{new_raw_scorer_for_test, VectorStorage, VectorStorageEnum};
+use segment::vector_storage::{VectorStorage, VectorStorageEnum, new_raw_scorer_for_test};
 use tempfile::Builder;
 
 const NUM_VECTORS: usize = 100000;

commit a2d7947917ca8d58c85360d1f07a387289b67a1b
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Mar 10 15:27:06 2025 +0100

    Measure io writes for vector upsertions (#5944)
    
    * Add counter to vector storage API
    
    * Measuring IO write for dense vectors
    
    * Tests, GPU and sparse
    
    * Measure multi vectors too
    
    * Fix comment

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 9041e1d8c..3caeae056 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -3,6 +3,7 @@ use std::sync::Arc;
 use std::sync::atomic::AtomicBool;
 
 use atomic_refcell::AtomicRefCell;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 use criterion::{Criterion, criterion_group, criterion_main};
 use rand::Rng;
@@ -36,11 +37,14 @@ fn init_vector_storage(
     let mut storage =
         open_simple_dense_vector_storage(db, DB_VECTOR_CF, dim, dist, &AtomicBool::new(false))
             .unwrap();
+
+    let hw_counter = HardwareCounterCell::new();
+
     {
         for i in 0..num {
             let vector: VectorInternal = random_vector(dim).into();
             storage
-                .insert_vector(i as PointOffsetType, VectorRef::from(&vector))
+                .insert_vector(i as PointOffsetType, VectorRef::from(&vector), &hw_counter)
                 .unwrap();
         }
     }

commit 3d988e66c49c5edf7d3daceea801f30b01303afe
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Apr 9 08:54:42 2025 +0000

    Remove is_stopped from RawScorer  (#6305)
    
    * Introduce CancelledError
    
    * Remove is_stopped from RawScorer

diff --git a/lib/segment/benches/vector_search.rs b/lib/segment/benches/vector_search.rs
index 3caeae056..860ad283b 100644
--- a/lib/segment/benches/vector_search.rs
+++ b/lib/segment/benches/vector_search.rs
@@ -14,7 +14,9 @@ use segment::fixtures::payload_context_fixture::FixtureIdTracker;
 use segment::id_tracker::IdTrackerSS;
 use segment::types::Distance;
 use segment::vector_storage::dense::simple_dense_vector_storage::open_simple_dense_vector_storage;
-use segment::vector_storage::{VectorStorage, VectorStorageEnum, new_raw_scorer_for_test};
+use segment::vector_storage::{
+    DEFAULT_STOPPED, VectorStorage, VectorStorageEnum, new_raw_scorer_for_test,
+};
 use tempfile::Builder;
 
 const NUM_VECTORS: usize = 100000;
@@ -71,7 +73,8 @@ fn benchmark_naive(c: &mut Criterion) {
                 borrowed_id_tracker.deleted_point_bitslice(),
             )
             .unwrap()
-            .peek_top_all(10)
+            .peek_top_all(10, &DEFAULT_STOPPED)
+            .unwrap();
         })
     });
 }

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    