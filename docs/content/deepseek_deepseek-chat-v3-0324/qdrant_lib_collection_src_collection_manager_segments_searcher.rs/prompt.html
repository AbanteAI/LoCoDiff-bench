<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/collection/src/collection_manager/segments_searcher.rs - DeepSeek Chat v3-0324</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/collection/src/collection_manager/segments_searcher.rs</h1>
        <h2>Model: DeepSeek Chat v3-0324</h2>
        <p><a href="../../../cases/deepseek_deepseek-chat-v3-0324/qdrant_lib_collection_src_collection_manager_segments_searcher.rs.html">Back to Case</a> | <a href="../../../cases.html">All Cases</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/collection/src/collection_manager/segments_searcher.rs

commit 83c21450c32290fac018a31b07e9fbf53bb2cda8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jun 27 13:22:02 2022 +0200

    Pagination (#743)
    
    * offset param for search and recomendation
    
    * test and fix for pagination
    
    * clippy + fmt
    
    * upd schemas
    
    * fix grpc requests in test

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
new file mode 100644
index 000000000..4b169e4ed
--- /dev/null
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -0,0 +1,198 @@
+use std::collections::{HashMap, HashSet};
+use std::sync::Arc;
+
+use futures::future::try_join_all;
+use itertools::Itertools;
+use parking_lot::RwLock;
+use segment::entry::entry_point::OperationError;
+use tokio::runtime::Handle;
+
+use segment::spaces::tools::peek_top_largest_scores_iterable;
+use segment::types::{PointIdType, ScoredPoint, SeqNumberType, WithPayload, WithPayloadInterface};
+
+use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
+use crate::operations::types::CollectionResult;
+use crate::operations::types::{Record, SearchRequest};
+
+/// Simple implementation of segment manager
+///  - rebuild segment for memory optimization purposes
+#[derive(Default)]
+pub struct SegmentsSearcher {}
+
+impl SegmentsSearcher {
+    pub async fn search(
+        segments: &RwLock<SegmentHolder>,
+        request: Arc<SearchRequest>,
+        runtime_handle: &Handle,
+    ) -> CollectionResult<Vec<ScoredPoint>> {
+        // Using { } block to ensure segments variable is dropped in the end of it
+        // and is not transferred across the all_searches.await? boundary as it
+        // does not impl Send trait
+        let searches: Vec<_> = {
+            let segments = segments.read();
+
+            let some_segment = segments.iter().next();
+
+            if some_segment.is_none() {
+                return Ok(vec![]);
+            }
+
+            segments
+                .iter()
+                .map(|(_id, segment)| search_in_segment(segment.clone(), request.clone()))
+                .map(|f| runtime_handle.spawn(f))
+                .collect()
+        };
+
+        let all_searches = try_join_all(searches);
+        let all_search_results = all_searches.await?;
+
+        match all_search_results
+            .iter()
+            .filter_map(|res| res.to_owned().err())
+            .next()
+        {
+            None => {}
+            Some(error) => return Err(error),
+        }
+
+        let mut seen_idx: HashSet<PointIdType> = HashSet::new();
+
+        let top_scores = peek_top_largest_scores_iterable(
+            all_search_results
+                .into_iter()
+                .flat_map(Result::unwrap) // already checked for errors
+                .sorted_by_key(|a| (a.id, 1 - a.version as i64)) // Prefer higher version first
+                .dedup_by(|a, b| a.id == b.id) // Keep only highest version
+                .filter(|scored| {
+                    let res = seen_idx.contains(&scored.id);
+                    seen_idx.insert(scored.id);
+                    !res
+                }),
+            request.limit + request.offset,
+        );
+
+        Ok(top_scores)
+    }
+
+    pub async fn retrieve(
+        segments: &RwLock<SegmentHolder>,
+        points: &[PointIdType],
+        with_payload: &WithPayload,
+        with_vector: bool,
+    ) -> CollectionResult<Vec<Record>> {
+        let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
+        let mut point_records: HashMap<PointIdType, Record> = Default::default();
+
+        segments.read().read_points(points, |id, segment| {
+            let version = segment.point_version(id).ok_or_else(|| {
+                OperationError::service_error(&format!("No version for point {}", id))
+            })?;
+            // If this point was not found yet or this segment have later version
+            if !point_version.contains_key(&id) || point_version[&id] < version {
+                point_records.insert(
+                    id,
+                    Record {
+                        id,
+                        payload: if with_payload.enable {
+                            if let Some(selector) = &with_payload.payload_selector {
+                                Some(selector.process(segment.payload(id)?))
+                            } else {
+                                Some(segment.payload(id)?)
+                            }
+                        } else {
+                            None
+                        },
+                        vector: if with_vector {
+                            Some(segment.vector(id)?)
+                        } else {
+                            None
+                        },
+                    },
+                );
+                point_version.insert(id, version);
+            }
+            Ok(true)
+        })?;
+        Ok(point_records.into_iter().map(|(_, r)| r).collect())
+    }
+}
+
+async fn search_in_segment(
+    segment: LockedSegment,
+    request: Arc<SearchRequest>,
+) -> CollectionResult<Vec<ScoredPoint>> {
+    let with_payload_interface = request
+        .with_payload
+        .as_ref()
+        .unwrap_or(&WithPayloadInterface::Bool(false));
+    let with_payload = WithPayload::from(with_payload_interface);
+    let with_vector = request.with_vector;
+
+    let res = segment.get().read().search(
+        &request.vector,
+        &with_payload,
+        with_vector,
+        request.filter.as_ref(),
+        request.limit + request.offset,
+        request.params.as_ref(),
+    )?;
+
+    Ok(res)
+}
+
+#[cfg(test)]
+mod tests {
+    use tempdir::TempDir;
+
+    use crate::collection_manager::fixtures::build_test_holder;
+
+    use super::*;
+
+    #[tokio::test]
+    async fn test_segments_search() {
+        let dir = TempDir::new("segment_dir").unwrap();
+
+        let segment_holder = build_test_holder(dir.path());
+
+        let query = vec![1.0, 1.0, 1.0, 1.0];
+
+        let req = Arc::new(SearchRequest {
+            vector: query,
+            with_payload: None,
+            with_vector: false,
+            filter: None,
+            params: None,
+            limit: 5,
+            score_threshold: None,
+            offset: 0,
+        });
+
+        let result = SegmentsSearcher::search(&segment_holder, req, &Handle::current())
+            .await
+            .unwrap();
+
+        // eprintln!("result = {:?}", &result);
+
+        assert_eq!(result.len(), 5);
+
+        assert!(result[0].id == 3.into() || result[0].id == 11.into());
+        assert!(result[1].id == 3.into() || result[1].id == 11.into());
+    }
+
+    #[tokio::test]
+    async fn test_retrieve() {
+        let dir = TempDir::new("segment_dir").unwrap();
+        let segment_holder = build_test_holder(dir.path());
+
+        let records = SegmentsSearcher::retrieve(
+            &segment_holder,
+            &[1.into(), 2.into(), 3.into()],
+            &WithPayload::from(true),
+            true,
+        )
+        .await
+        .unwrap();
+        assert_eq!(records.len(), 3);
+    }
+}

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 4b169e4ed..a1eca6986 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -5,14 +5,12 @@ use futures::future::try_join_all;
 use itertools::Itertools;
 use parking_lot::RwLock;
 use segment::entry::entry_point::OperationError;
-use tokio::runtime::Handle;
-
 use segment::spaces::tools::peek_top_largest_scores_iterable;
 use segment::types::{PointIdType, ScoredPoint, SeqNumberType, WithPayload, WithPayloadInterface};
+use tokio::runtime::Handle;
 
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
-use crate::operations::types::CollectionResult;
-use crate::operations::types::{Record, SearchRequest};
+use crate::operations::types::{CollectionResult, Record, SearchRequest};
 
 /// Simple implementation of segment manager
 ///  - rebuild segment for memory optimization purposes
@@ -145,9 +143,8 @@ async fn search_in_segment(
 mod tests {
     use tempdir::TempDir;
 
-    use crate::collection_manager::fixtures::build_test_holder;
-
     use super::*;
+    use crate::collection_manager::fixtures::build_test_holder;
 
     #[tokio::test]
     async fn test_segments_search() {

commit 8e1f2ca35322cc699232ec8d8177fe05baae3f98
Author: Russ Cam <russ.cam@forloop.co.uk>
Date:   Wed Aug 10 17:39:21 2022 +1000

    Use tempfile (#922)
    
    This commit replaces tempdir with tempfile.
    tempdir is archived.
    
    Closes #544

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index a1eca6986..cc623d5b9 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -141,14 +141,14 @@ async fn search_in_segment(
 
 #[cfg(test)]
 mod tests {
-    use tempdir::TempDir;
+    use tempfile::Builder;
 
     use super::*;
     use crate::collection_manager::fixtures::build_test_holder;
 
     #[tokio::test]
     async fn test_segments_search() {
-        let dir = TempDir::new("segment_dir").unwrap();
+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
 
         let segment_holder = build_test_holder(dir.path());
 
@@ -179,7 +179,7 @@ mod tests {
 
     #[tokio::test]
     async fn test_retrieve() {
-        let dir = TempDir::new("segment_dir").unwrap();
+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
         let segment_holder = build_test_holder(dir.path());
 
         let records = SegmentsSearcher::retrieve(

commit a2acca0345057dfb7fd8f218801a1c84cd77616b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Aug 18 14:48:17 2022 +0200

    Segment batch search (#813)
    
    * batch search benchmark
    
    * collect filter iterator in indexed search
    
    * fmt
    
    * fix
    
    * fix
    
    * fmt
    
    * use new tempfile create
    
    * auto batching
    
    * Clippy fixes
    
    * REST, gRPC and internal APIs
    
    * fix bugs & less duplication
    
    * two steps payload retrieval mechanism & fix duplication
    
    * add proxy_segment implementation & tests
    
    * add gRPC docs
    
    * remove unused code (#950)
    
    * only filter ids within a batch
    
    * add more equivalence tests
    
    * add integration test search vs batch
    
    * assert more search options in tests
    
    * cleanup assertions
    
    * fix offset panic
    
    * rename search batch API
    
    * openapi spec
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index cc623d5b9..f4d94ce43 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -6,11 +6,14 @@ use itertools::Itertools;
 use parking_lot::RwLock;
 use segment::entry::entry_point::OperationError;
 use segment::spaces::tools::peek_top_largest_scores_iterable;
-use segment::types::{PointIdType, ScoredPoint, SeqNumberType, WithPayload, WithPayloadInterface};
+use segment::types::{
+    Filter, PointIdType, ScoredPoint, SearchParams, SeqNumberType, VectorElementType, WithPayload,
+    WithPayloadInterface,
+};
 use tokio::runtime::Handle;
 
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
-use crate::operations::types::{CollectionResult, Record, SearchRequest};
+use crate::operations::types::{CollectionResult, Record, SearchRequestBatch};
 
 /// Simple implementation of segment manager
 ///  - rebuild segment for memory optimization purposes
@@ -20,9 +23,9 @@ pub struct SegmentsSearcher {}
 impl SegmentsSearcher {
     pub async fn search(
         segments: &RwLock<SegmentHolder>,
-        request: Arc<SearchRequest>,
+        request: Arc<SearchRequestBatch>,
         runtime_handle: &Handle,
-    ) -> CollectionResult<Vec<ScoredPoint>> {
+    ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         // Using { } block to ensure segments variable is dropped in the end of it
         // and is not transferred across the all_searches.await? boundary as it
         // does not impl Send trait
@@ -42,8 +45,9 @@ impl SegmentsSearcher {
                 .collect()
         };
 
+        // perform search on all segments concurrently
         let all_searches = try_join_all(searches);
-        let all_search_results = all_searches.await?;
+        let all_search_results: Vec<CollectionResult<Vec<Vec<ScoredPoint>>>> = all_searches.await?;
 
         match all_search_results
             .iter()
@@ -54,21 +58,33 @@ impl SegmentsSearcher {
             Some(error) => return Err(error),
         }
 
-        let mut seen_idx: HashSet<PointIdType> = HashSet::new();
+        let mut merged_results: Vec<Vec<ScoredPoint>> = vec![vec![]; request.searches.len()];
+        for segment_result in all_search_results {
+            let segment_result = segment_result.unwrap();
+            for (idx, query_res) in segment_result.into_iter().enumerate() {
+                merged_results[idx].extend(query_res);
+            }
+        }
 
-        let top_scores = peek_top_largest_scores_iterable(
-            all_search_results
-                .into_iter()
-                .flat_map(Result::unwrap) // already checked for errors
-                .sorted_by_key(|a| (a.id, 1 - a.version as i64)) // Prefer higher version first
-                .dedup_by(|a, b| a.id == b.id) // Keep only highest version
-                .filter(|scored| {
-                    let res = seen_idx.contains(&scored.id);
-                    seen_idx.insert(scored.id);
-                    !res
-                }),
-            request.limit + request.offset,
-        );
+        let top_scores = merged_results
+            .into_iter()
+            .zip(request.searches.iter())
+            .map(|(all_search_results_per_vector, req)| {
+                let mut seen_idx: HashSet<PointIdType> = HashSet::new();
+                peek_top_largest_scores_iterable(
+                    all_search_results_per_vector
+                        .into_iter()
+                        .sorted_by_key(|a| (a.id, 1 - a.version as i64)) // Prefer higher version first
+                        .dedup_by(|a, b| a.id == b.id) // Keep only highest version
+                        .filter(|scored| {
+                            let res = seen_idx.contains(&scored.id);
+                            seen_idx.insert(scored.id);
+                            !res
+                        }),
+                    req.limit + req.offset,
+                )
+            })
+            .collect();
 
         Ok(top_scores)
     }
@@ -116,27 +132,77 @@ impl SegmentsSearcher {
     }
 }
 
+#[derive(PartialEq, Default)]
+struct BatchSearchParams<'a> {
+    pub filter: Option<&'a Filter>,
+    pub with_payload: WithPayload,
+    pub with_vector: bool,
+    pub top: usize,
+    pub params: Option<&'a SearchParams>,
+}
+
+/// Process sequentially contiguous batches
 async fn search_in_segment(
     segment: LockedSegment,
-    request: Arc<SearchRequest>,
-) -> CollectionResult<Vec<ScoredPoint>> {
-    let with_payload_interface = request
-        .with_payload
-        .as_ref()
-        .unwrap_or(&WithPayloadInterface::Bool(false));
-    let with_payload = WithPayload::from(with_payload_interface);
-    let with_vector = request.with_vector;
-
-    let res = segment.get().read().search(
-        &request.vector,
-        &with_payload,
-        with_vector,
-        request.filter.as_ref(),
-        request.limit + request.offset,
-        request.params.as_ref(),
-    )?;
-
-    Ok(res)
+    request: Arc<SearchRequestBatch>,
+) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
+    let mut result: Vec<Vec<ScoredPoint>> = vec![];
+    let mut vectors_batch: Vec<&[VectorElementType]> = vec![];
+    let mut prev_params = BatchSearchParams::default();
+
+    for search_query in &request.searches {
+        let with_payload_interface = search_query
+            .with_payload
+            .as_ref()
+            .unwrap_or(&WithPayloadInterface::Bool(false));
+
+        let params = BatchSearchParams {
+            filter: search_query.filter.as_ref(),
+            with_payload: WithPayload::from(with_payload_interface),
+            with_vector: search_query.with_vector,
+            top: search_query.limit + search_query.offset,
+            params: search_query.params.as_ref(),
+        };
+
+        // same params enables batching
+        if params == prev_params {
+            vectors_batch.push(search_query.vector.as_ref());
+        } else {
+            // different params means different batches
+            // execute what has been batched so far
+            if !vectors_batch.is_empty() {
+                let mut res = segment.get().read().search_batch(
+                    &vectors_batch,
+                    &prev_params.with_payload,
+                    prev_params.with_vector,
+                    prev_params.filter,
+                    prev_params.top,
+                    prev_params.params,
+                )?;
+                result.append(&mut res);
+                // clear current batch
+                vectors_batch.clear();
+            }
+            // start new batch for current search query
+            vectors_batch.push(search_query.vector.as_ref());
+            prev_params = params;
+        }
+    }
+
+    // run last batch if any
+    if !vectors_batch.is_empty() {
+        let mut res = segment.get().read().search_batch(
+            &vectors_batch,
+            &prev_params.with_payload,
+            prev_params.with_vector,
+            prev_params.filter,
+            prev_params.top,
+            prev_params.params,
+        )?;
+        result.append(&mut res);
+    }
+
+    Ok(result)
 }
 
 #[cfg(test)]
@@ -145,6 +211,7 @@ mod tests {
 
     use super::*;
     use crate::collection_manager::fixtures::build_test_holder;
+    use crate::operations::types::SearchRequest;
 
     #[tokio::test]
     async fn test_segments_search() {
@@ -154,7 +221,7 @@ mod tests {
 
         let query = vec![1.0, 1.0, 1.0, 1.0];
 
-        let req = Arc::new(SearchRequest {
+        let req = SearchRequest {
             vector: query,
             with_payload: None,
             with_vector: false,
@@ -163,11 +230,19 @@ mod tests {
             limit: 5,
             score_threshold: None,
             offset: 0,
-        });
+        };
+
+        let batch_request = SearchRequestBatch {
+            searches: vec![req],
+        };
 
-        let result = SegmentsSearcher::search(&segment_holder, req, &Handle::current())
-            .await
-            .unwrap();
+        let result =
+            SegmentsSearcher::search(&segment_holder, Arc::new(batch_request), &Handle::current())
+                .await
+                .unwrap()
+                .into_iter()
+                .next()
+                .unwrap();
 
         // eprintln!("result = {:?}", &result);
 

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index f4d94ce43..46158ab77 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -4,11 +4,13 @@ use std::sync::Arc;
 use futures::future::try_join_all;
 use itertools::Itertools;
 use parking_lot::RwLock;
+use segment::data_types::named_vectors::NamedVectors;
+use segment::data_types::vectors::VectorElementType;
 use segment::entry::entry_point::OperationError;
 use segment::spaces::tools::peek_top_largest_scores_iterable;
 use segment::types::{
-    Filter, PointIdType, ScoredPoint, SearchParams, SeqNumberType, VectorElementType, WithPayload,
-    WithPayloadInterface,
+    Filter, PointIdType, ScoredPoint, SearchParams, SeqNumberType, WithPayload,
+    WithPayloadInterface, WithVector,
 };
 use tokio::runtime::Handle;
 
@@ -93,7 +95,7 @@ impl SegmentsSearcher {
         segments: &RwLock<SegmentHolder>,
         points: &[PointIdType],
         with_payload: &WithPayload,
-        with_vector: bool,
+        with_vector: &WithVector,
     ) -> CollectionResult<Vec<Record>> {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
         let mut point_records: HashMap<PointIdType, Record> = Default::default();
@@ -117,10 +119,19 @@ impl SegmentsSearcher {
                         } else {
                             None
                         },
-                        vector: if with_vector {
-                            Some(segment.vector(id)?)
-                        } else {
-                            None
+                        vector: match with_vector {
+                            WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
+                            WithVector::Bool(false) => None,
+                            WithVector::Selector(vector_names) => {
+                                let mut selected_vectors = NamedVectors::default();
+                                for vector_name in vector_names {
+                                    selected_vectors.insert(
+                                        vector_name.clone(),
+                                        segment.vector(vector_name, id)?,
+                                    );
+                                }
+                                Some(selected_vectors.into())
+                            }
                         },
                     },
                 );
@@ -134,9 +145,10 @@ impl SegmentsSearcher {
 
 #[derive(PartialEq, Default)]
 struct BatchSearchParams<'a> {
+    pub vector_name: &'a str,
     pub filter: Option<&'a Filter>,
     pub with_payload: WithPayload,
-    pub with_vector: bool,
+    pub with_vector: WithVector,
     pub top: usize,
     pub params: Option<&'a SearchParams>,
 }
@@ -157,24 +169,26 @@ async fn search_in_segment(
             .unwrap_or(&WithPayloadInterface::Bool(false));
 
         let params = BatchSearchParams {
+            vector_name: search_query.vector.get_name(),
             filter: search_query.filter.as_ref(),
             with_payload: WithPayload::from(with_payload_interface),
-            with_vector: search_query.with_vector,
+            with_vector: search_query.with_vector.clone(),
             top: search_query.limit + search_query.offset,
             params: search_query.params.as_ref(),
         };
 
         // same params enables batching
         if params == prev_params {
-            vectors_batch.push(search_query.vector.as_ref());
+            vectors_batch.push(search_query.vector.get_vector().as_slice());
         } else {
             // different params means different batches
             // execute what has been batched so far
             if !vectors_batch.is_empty() {
                 let mut res = segment.get().read().search_batch(
+                    prev_params.vector_name,
                     &vectors_batch,
                     &prev_params.with_payload,
-                    prev_params.with_vector,
+                    &prev_params.with_vector,
                     prev_params.filter,
                     prev_params.top,
                     prev_params.params,
@@ -184,7 +198,7 @@ async fn search_in_segment(
                 vectors_batch.clear();
             }
             // start new batch for current search query
-            vectors_batch.push(search_query.vector.as_ref());
+            vectors_batch.push(search_query.vector.get_vector().as_slice());
             prev_params = params;
         }
     }
@@ -192,9 +206,10 @@ async fn search_in_segment(
     // run last batch if any
     if !vectors_batch.is_empty() {
         let mut res = segment.get().read().search_batch(
+            prev_params.vector_name,
             &vectors_batch,
             &prev_params.with_payload,
-            prev_params.with_vector,
+            &prev_params.with_vector,
             prev_params.filter,
             prev_params.top,
             prev_params.params,
@@ -222,9 +237,9 @@ mod tests {
         let query = vec![1.0, 1.0, 1.0, 1.0];
 
         let req = SearchRequest {
-            vector: query,
+            vector: query.into(),
             with_payload: None,
-            with_vector: false,
+            with_vector: false.into(),
             filter: None,
             params: None,
             limit: 5,
@@ -261,7 +276,7 @@ mod tests {
             &segment_holder,
             &[1.into(), 2.into(), 3.into()],
             &WithPayload::from(true),
-            true,
+            &true.into(),
         )
         .await
         .unwrap();

commit ba26e2f85e36fc1f4258de9351ad4d90082056c0
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Sep 12 17:55:56 2022 +0200

    Faster filtered scroll (#1003)
    
    * faster filtered scroll for low cardinality filters
    
    * add test
    
    * scroll strategy heuristics

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 46158ab77..40a72c979 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -7,7 +7,7 @@ use parking_lot::RwLock;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::VectorElementType;
 use segment::entry::entry_point::OperationError;
-use segment::spaces::tools::peek_top_largest_scores_iterable;
+use segment::spaces::tools::peek_top_largest_iterable;
 use segment::types::{
     Filter, PointIdType, ScoredPoint, SearchParams, SeqNumberType, WithPayload,
     WithPayloadInterface, WithVector,
@@ -73,7 +73,7 @@ impl SegmentsSearcher {
             .zip(request.searches.iter())
             .map(|(all_search_results_per_vector, req)| {
                 let mut seen_idx: HashSet<PointIdType> = HashSet::new();
-                peek_top_largest_scores_iterable(
+                peek_top_largest_iterable(
                     all_search_results_per_vector
                         .into_iter()
                         .sorted_by_key(|a| (a.id, 1 - a.version as i64)) // Prefer higher version first

commit 94883e7062c3eab7c65886daa524a0ff3cec3c37
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Sep 16 01:37:04 2022 +0200

    allow empty with_vector

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 40a72c979..29132e066 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -172,7 +172,7 @@ async fn search_in_segment(
             vector_name: search_query.vector.get_name(),
             filter: search_query.filter.as_ref(),
             with_payload: WithPayload::from(with_payload_interface),
-            with_vector: search_query.with_vector.clone(),
+            with_vector: search_query.with_vector.clone().unwrap_or_default(),
             top: search_query.limit + search_query.offset,
             params: search_query.params.as_ref(),
         };
@@ -239,7 +239,7 @@ mod tests {
         let req = SearchRequest {
             vector: query.into(),
             with_payload: None,
-            with_vector: false.into(),
+            with_vector: None,
             filter: None,
             params: None,
             limit: 5,

commit 361c7ff716083464dbee305442ecd8f3a2d7c65e
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 16 20:53:58 2022 +0100

    Probabilistic search sampling for better limit (#1199)
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 29132e066..c1ce732e9 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,37 +1,159 @@
-use std::collections::{HashMap, HashSet};
+use std::cmp::max;
+use std::collections::HashMap;
 use std::sync::Arc;
 
 use futures::future::try_join_all;
-use itertools::Itertools;
+use ordered_float::Float;
 use parking_lot::RwLock;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::VectorElementType;
 use segment::entry::entry_point::OperationError;
-use segment::spaces::tools::peek_top_largest_iterable;
 use segment::types::{
-    Filter, PointIdType, ScoredPoint, SearchParams, SeqNumberType, WithPayload,
-    WithPayloadInterface, WithVector,
+    Filter, Indexes, PointIdType, ScoreType, ScoredPoint, SearchParams, SegmentConfig,
+    SeqNumberType, WithPayload, WithPayloadInterface, WithVector,
 };
 use tokio::runtime::Handle;
+use tokio::task::JoinHandle;
 
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
+use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
+use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
 use crate::operations::types::{CollectionResult, Record, SearchRequestBatch};
 
+type BatchOffset = usize;
+type SegmentOffset = usize;
+
+// batch -> point for one segment
+type SegmentBatchSearchResult = Vec<Vec<ScoredPoint>>;
+// Segment -> batch -> point
+type BatchSearchResult = Vec<SegmentBatchSearchResult>;
+
+// Result of batch search in one segment
+type SegmentSearchExecutedResult = CollectionResult<(SegmentBatchSearchResult, Vec<bool>)>;
+
 /// Simple implementation of segment manager
 ///  - rebuild segment for memory optimization purposes
 #[derive(Default)]
 pub struct SegmentsSearcher {}
 
 impl SegmentsSearcher {
+    async fn execute_searches(
+        searches: Vec<JoinHandle<SegmentSearchExecutedResult>>,
+    ) -> CollectionResult<(BatchSearchResult, Vec<Vec<bool>>)> {
+        let searches = try_join_all(searches);
+        let search_results_per_segment_res = searches.await?;
+
+        let mut search_results_per_segment = vec![];
+        let mut further_searches_per_segment = vec![];
+        for search_result in search_results_per_segment_res {
+            let (search_results, further_searches) = search_result?;
+            debug_assert!(search_results.len() == further_searches.len());
+            search_results_per_segment.push(search_results);
+            further_searches_per_segment.push(further_searches);
+        }
+        Ok((search_results_per_segment, further_searches_per_segment))
+    }
+
+    /// Processes search result of [segment_size x batch_size]
+    ///
+    /// # Arguments
+    /// * search_result - [segment_size x batch_size]
+    /// * limits - [batch_size] - how many results to return for each batched request
+    /// * further_searches - [segment_size x batch_size] - whether we can search further in the segment
+    ///
+    /// Returns batch results aggregated by [batch_size] and list of queries, grouped by segment to re-run
+    pub(crate) fn process_search_result_step1(
+        search_result: BatchSearchResult,
+        limits: Vec<usize>,
+        further_results: Vec<Vec<bool>>,
+    ) -> (
+        BatchResultAggregator,
+        HashMap<SegmentOffset, Vec<BatchOffset>>,
+    ) {
+        let number_segments = search_result.len();
+        let batch_size = limits.len();
+
+        // The lowest scored element must be larger or equal to the worst scored element in each segment.
+        // Otherwise, the sampling is invalid and some points might be missing.
+        // e.g. with 3 segments with the following sampled ranges:
+        // s1 - [0.91 -> 0.87]
+        // s2 - [0.92 -> 0.86]
+        // s3 - [0.93 -> 0.85]
+        // If the top merged scores result range is [0.93 -> 0.86] then we do not know if s1 could have contributed more points at the lower part between [0.87 -> 0.86]
+        // In that case, we need to re-run the search without sampling on that segment.
+
+        // Initialize result aggregators for each batched request
+        let mut result_aggregator = BatchResultAggregator::new(limits.iter().copied());
+        result_aggregator.update_point_versions(&search_result);
+
+        // Therefore we need to track the lowest scored element per segment for each batch
+        let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![
+            vec![f32::max_value(); batch_size]; // initial max score value for each batch
+            number_segments
+        ];
+
+        let mut retrieved_points_per_request: Vec<Vec<BatchOffset>> = vec![
+            vec![0; batch_size]; // initial max score value for each batch
+            number_segments
+        ];
+
+        // Batch results merged from all segments
+        for (segment_idx, segment_result) in search_result.into_iter().enumerate() {
+            // merge results for each batch search request across segments
+            for (batch_req_idx, query_res) in segment_result.into_iter().enumerate() {
+                retrieved_points_per_request[segment_idx][batch_req_idx] = query_res.len();
+                lowest_scores_per_request[segment_idx][batch_req_idx] = query_res
+                    .last()
+                    .map(|x| x.score)
+                    .unwrap_or_else(f32::min_value);
+                result_aggregator.update_batch_results(batch_req_idx, query_res.into_iter());
+            }
+        }
+
+        // segment id -> list of batch ids
+        let mut searches_to_rerun: HashMap<SegmentOffset, Vec<BatchOffset>> = HashMap::new();
+
+        // Check if we want to re-run the search without sampling on some segments
+        for (batch_id, required_limit) in limits.iter().copied().enumerate() {
+            let lowest_batch_score_opt = result_aggregator.batch_lowest_scores(batch_id);
+
+            // If there are no results, we do not need to re-run the search
+            if let Some(lowest_batch_score) = lowest_batch_score_opt {
+                for segment_id in 0..number_segments {
+                    let segment_lowest_score = lowest_scores_per_request[segment_id][batch_id];
+                    let retrieved_points = retrieved_points_per_request[segment_id][batch_id];
+                    let have_further_results = further_results[segment_id][batch_id];
+
+                    if have_further_results
+                        && retrieved_points < required_limit
+                        && segment_lowest_score >= lowest_batch_score
+                    {
+                        log::debug!("Search to re-run without sampling on segment_id: {} segment_lowest_score: {}, lowest_batch_score: {}, retrieved_points: {}, required_limit: {}", segment_id, segment_lowest_score, lowest_batch_score, retrieved_points, required_limit);
+                        // It is possible, that current segment can have better results than
+                        // the lowest score in the batch. In that case, we need to re-run the search
+                        // without sampling on that segment.
+                        searches_to_rerun
+                            .entry(segment_id)
+                            .or_insert_with(Vec::new)
+                            .push(batch_id);
+                    }
+                }
+            }
+        }
+
+        (result_aggregator, searches_to_rerun)
+    }
+
     pub async fn search(
         segments: &RwLock<SegmentHolder>,
-        request: Arc<SearchRequestBatch>,
+        batch_request: Arc<SearchRequestBatch>,
         runtime_handle: &Handle,
+        sampling_enabled: bool,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         // Using { } block to ensure segments variable is dropped in the end of it
         // and is not transferred across the all_searches.await? boundary as it
         // does not impl Send trait
-        let searches: Vec<_> = {
+        let (locked_segments, searches): (Vec<_>, Vec<_>) = {
             let segments = segments.read();
 
             let some_segment = segments.iter().next();
@@ -40,54 +162,94 @@ impl SegmentsSearcher {
                 return Ok(vec![]);
             }
 
+            // Probabilistic sampling for the `limit` parameter avoids over-fetching points from segments.
+            // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.
+            // With probabilistic sampling we determine a smaller sampling limit for each segment.
+            // Use probabilistic sampling if:
+            // - sampling is enabled
+            // - more than 1 segment
+            // - segments are not empty
+            let total_points_segments = segments
+                .iter()
+                .map(|(_, segment)| segment.get().read().points_count())
+                .sum();
+            let use_sampling = sampling_enabled && segments.len() > 1 && total_points_segments > 0;
+
             segments
                 .iter()
-                .map(|(_id, segment)| search_in_segment(segment.clone(), request.clone()))
-                .map(|f| runtime_handle.spawn(f))
-                .collect()
+                .map(|(_id, segment)| {
+                    (
+                        segment.clone(),
+                        search_in_segment(
+                            segment.clone(),
+                            batch_request.clone(),
+                            total_points_segments,
+                            use_sampling,
+                        ),
+                    )
+                })
+                .map(|(segment, f)| (segment, runtime_handle.spawn(f)))
+                .unzip()
         };
-
         // perform search on all segments concurrently
-        let all_searches = try_join_all(searches);
-        let all_search_results: Vec<CollectionResult<Vec<Vec<ScoredPoint>>>> = all_searches.await?;
-
-        match all_search_results
-            .iter()
-            .filter_map(|res| res.to_owned().err())
-            .next()
-        {
-            None => {}
-            Some(error) => return Err(error),
-        }
-
-        let mut merged_results: Vec<Vec<ScoredPoint>> = vec![vec![]; request.searches.len()];
-        for segment_result in all_search_results {
-            let segment_result = segment_result.unwrap();
-            for (idx, query_res) in segment_result.into_iter().enumerate() {
-                merged_results[idx].extend(query_res);
+        // the resulting Vec is in the same order as the segment searches were provided.
+        let (all_search_results_per_segment, further_results) =
+            Self::execute_searches(searches).await?;
+        debug_assert!(all_search_results_per_segment.len() == locked_segments.len());
+
+        let (mut result_aggregator, searches_to_rerun) = Self::process_search_result_step1(
+            all_search_results_per_segment,
+            batch_request
+                .searches
+                .iter()
+                .map(|request| request.limit + request.offset)
+                .collect(),
+            further_results,
+        );
+        // The second step of the search is to re-run the search without sampling on some segments
+        // Expected that this stage will be executed rarely
+        if !searches_to_rerun.is_empty() {
+            // TODO notify telemetry of failing sampling
+            // Ensure consistent order of segment ids
+            let searches_to_rerun: Vec<(SegmentOffset, Vec<BatchOffset>)> =
+                searches_to_rerun.into_iter().collect();
+
+            let secondary_searches: Vec<_> = {
+                let mut res = vec![];
+                for (segment_id, batch_ids) in searches_to_rerun.iter() {
+                    let segment = locked_segments[*segment_id].clone();
+                    let partial_batch_request = Arc::new(SearchRequestBatch {
+                        searches: batch_ids
+                            .iter()
+                            .map(|batch_id| batch_request.searches[*batch_id].clone())
+                            .collect(),
+                    });
+
+                    let search = search_in_segment(segment, partial_batch_request, 0, false);
+                    res.push(runtime_handle.spawn(search))
+                }
+                res
+            };
+
+            let (secondary_search_results_per_segment, _) =
+                Self::execute_searches(secondary_searches).await?;
+
+            result_aggregator.update_point_versions(&secondary_search_results_per_segment);
+
+            for ((_segment_id, batch_ids), segments_result) in searches_to_rerun
+                .into_iter()
+                .zip(secondary_search_results_per_segment.into_iter())
+            {
+                for (batch_id, secondary_batch_result) in
+                    batch_ids.into_iter().zip(segments_result.into_iter())
+                {
+                    result_aggregator
+                        .update_batch_results(batch_id, secondary_batch_result.into_iter());
+                }
             }
         }
 
-        let top_scores = merged_results
-            .into_iter()
-            .zip(request.searches.iter())
-            .map(|(all_search_results_per_vector, req)| {
-                let mut seen_idx: HashSet<PointIdType> = HashSet::new();
-                peek_top_largest_iterable(
-                    all_search_results_per_vector
-                        .into_iter()
-                        .sorted_by_key(|a| (a.id, 1 - a.version as i64)) // Prefer higher version first
-                        .dedup_by(|a, b| a.id == b.id) // Keep only highest version
-                        .filter(|scored| {
-                            let res = seen_idx.contains(&scored.id);
-                            seen_idx.insert(scored.id);
-                            !res
-                        }),
-                    req.limit + req.offset,
-                )
-            })
-            .collect();
-
+        let top_scores: Vec<_> = result_aggregator.into_topk();
         Ok(top_scores)
     }
 
@@ -153,12 +315,63 @@ struct BatchSearchParams<'a> {
     pub params: Option<&'a SearchParams>,
 }
 
+/// Returns suggested search sampling size for a given number of points and required limit.
+fn sampling_limit(
+    limit: usize,
+    ef_limit: Option<usize>,
+    segment_points: usize,
+    total_points: usize,
+) -> usize {
+    // shortcut empty segment
+    if segment_points == 0 {
+        return 0;
+    }
+    let segment_probability = segment_points as f64 / total_points as f64;
+    let poisson_sampling =
+        find_search_sampling_over_point_distribution(limit as f64, segment_probability)
+            .unwrap_or(limit);
+    let res = if poisson_sampling > limit {
+        // sampling cannot be greater than limit
+        return limit;
+    } else {
+        // sampling should not be less than ef_limit
+        max(poisson_sampling, ef_limit.unwrap_or(0))
+    };
+    log::trace!(
+        "sampling: {}, poisson: {} segment_probability: {}, segment_points: {}, total_points: {}",
+        res,
+        poisson_sampling,
+        segment_probability,
+        segment_points,
+        total_points
+    );
+    res
+}
+
 /// Process sequentially contiguous batches
+///
+/// # Arguments
+///
+/// * `segment` - Locked segment to search in
+/// * `request` - Batch of search requests
+/// * `total_points` - Number of points in all segments combined
+/// * `use_sampling` - If true, try to use probabilistic sampling
+///
+/// # Returns
+///
+/// Collection Result of:
+/// * Vector of ScoredPoints for each request in the batch
+/// * Vector of boolean indicating if the segment have further points to search
 async fn search_in_segment(
     segment: LockedSegment,
     request: Arc<SearchRequestBatch>,
-) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
-    let mut result: Vec<Vec<ScoredPoint>> = vec![];
+    total_points: usize,
+    use_sampling: bool,
+) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
+    let batch_size = request.searches.len();
+
+    let mut result: Vec<Vec<ScoredPoint>> = Vec::with_capacity(batch_size);
+    let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // true if segment have more points to return
     let mut vectors_batch: Vec<&[VectorElementType]> = vec![];
     let mut prev_params = BatchSearchParams::default();
 
@@ -184,15 +397,31 @@ async fn search_in_segment(
             // different params means different batches
             // execute what has been batched so far
             if !vectors_batch.is_empty() {
-                let mut res = segment.get().read().search_batch(
+                let locked_segment = segment.get();
+                let read_segment = locked_segment.read();
+                let segment_points = read_segment.points_count();
+                let top = if use_sampling {
+                    let ef_limit = prev_params
+                        .params
+                        .and_then(|p| p.hnsw_ef)
+                        .or_else(|| config_hnsw_ef_construct(read_segment.config()));
+                    sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
+                } else {
+                    prev_params.top
+                };
+
+                let mut res = read_segment.search_batch(
                     prev_params.vector_name,
                     &vectors_batch,
                     &prev_params.with_payload,
                     &prev_params.with_vector,
                     prev_params.filter,
-                    prev_params.top,
+                    top,
                     prev_params.params,
                 )?;
+                for batch_result in &res {
+                    further_results.push(batch_result.len() == top);
+                }
                 result.append(&mut res);
                 // clear current batch
                 vectors_batch.clear();
@@ -205,27 +434,51 @@ async fn search_in_segment(
 
     // run last batch if any
     if !vectors_batch.is_empty() {
-        let mut res = segment.get().read().search_batch(
+        let locked_segment = segment.get();
+        let read_segment = locked_segment.read();
+        let segment_points = read_segment.points_count();
+        let top = if use_sampling {
+            let ef_limit = prev_params
+                .params
+                .and_then(|p| p.hnsw_ef)
+                .or_else(|| config_hnsw_ef_construct(read_segment.config()));
+            sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
+        } else {
+            prev_params.top
+        };
+        let mut res = read_segment.search_batch(
             prev_params.vector_name,
             &vectors_batch,
             &prev_params.with_payload,
             &prev_params.with_vector,
             prev_params.filter,
-            prev_params.top,
+            top,
             prev_params.params,
         )?;
+        for batch_result in &res {
+            further_results.push(batch_result.len() == top);
+        }
         result.append(&mut res);
     }
 
-    Ok(result)
+    Ok((result, further_results))
+}
+
+/// None if plain index, Some if hnsw.
+fn config_hnsw_ef_construct(config: SegmentConfig) -> Option<usize> {
+    match config.index {
+        Indexes::Plain { .. } => None,
+        Indexes::Hnsw(config) => Some(config.ef_construct),
+    }
 }
 
 #[cfg(test)]
 mod tests {
+    use segment::fixtures::index_fixtures::random_vector;
     use tempfile::Builder;
 
     use super::*;
-    use crate::collection_manager::fixtures::build_test_holder;
+    use crate::collection_manager::fixtures::{build_test_holder, random_segment};
     use crate::operations::types::SearchRequest;
 
     #[tokio::test]
@@ -251,13 +504,17 @@ mod tests {
             searches: vec![req],
         };
 
-        let result =
-            SegmentsSearcher::search(&segment_holder, Arc::new(batch_request), &Handle::current())
-                .await
-                .unwrap()
-                .into_iter()
-                .next()
-                .unwrap();
+        let result = SegmentsSearcher::search(
+            &segment_holder,
+            Arc::new(batch_request),
+            &Handle::current(),
+            true,
+        )
+        .await
+        .unwrap()
+        .into_iter()
+        .next()
+        .unwrap();
 
         // eprintln!("result = {:?}", &result);
 
@@ -267,6 +524,81 @@ mod tests {
         assert!(result[1].id == 3.into() || result[1].id == 11.into());
     }
 
+    #[tokio::test]
+    async fn test_segments_search_sampling() {
+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
+
+        let segment1 = random_segment(dir.path(), 10, 2000, 4);
+        let segment2 = random_segment(dir.path(), 10, 4000, 4);
+
+        let mut holder = SegmentHolder::default();
+
+        let _sid1 = holder.add(segment1);
+        let _sid2 = holder.add(segment2);
+
+        let segment_holder = RwLock::new(holder);
+
+        let mut rnd = rand::thread_rng();
+
+        for _ in 0..100 {
+            let req1 = SearchRequest {
+                vector: random_vector(&mut rnd, 4).into(),
+                limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING
+                offset: 0,
+                with_payload: None,
+                with_vector: None,
+                filter: None,
+                params: None,
+                score_threshold: None,
+            };
+            let req2 = SearchRequest {
+                vector: random_vector(&mut rnd, 4).into(),
+                limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING
+                offset: 0,
+                filter: None,
+                params: None,
+                with_payload: None,
+                with_vector: None,
+                score_threshold: None,
+            };
+
+            let batch_request = SearchRequestBatch {
+                searches: vec![req1, req2],
+            };
+
+            let result_no_sampling = SegmentsSearcher::search(
+                &segment_holder,
+                Arc::new(batch_request.clone()),
+                &Handle::current(),
+                false,
+            )
+            .await
+            .unwrap();
+
+            assert!(!result_no_sampling.is_empty());
+
+            let result_sampling = SegmentsSearcher::search(
+                &segment_holder,
+                Arc::new(batch_request),
+                &Handle::current(),
+                true,
+            )
+            .await
+            .unwrap();
+            assert!(!result_sampling.is_empty());
+
+            // assert equivalence in depth
+            assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());
+            assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());
+
+            for (no_sampling, sampling) in
+                result_no_sampling[0].iter().zip(result_sampling[0].iter())
+            {
+                assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores
+            }
+        }
+    }
+
     #[tokio::test]
     async fn test_retrieve() {
         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
@@ -282,4 +614,19 @@ mod tests {
         .unwrap();
         assert_eq!(records.len(), 3);
     }
+
+    #[test]
+    fn test_sampling_limit() {
+        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 30);
+    }
+
+    #[test]
+    fn test_sampling_limit_ef() {
+        assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);
+    }
+
+    #[test]
+    fn test_sampling_limit_high() {
+        assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);
+    }
 }

commit 9702054127430851aa927b59bdc2926adbe203d0
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Dec 16 10:53:51 2022 +0100

    Clippy for Rust 1.66 (#1284)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index c1ce732e9..06cacb6c2 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -301,7 +301,7 @@ impl SegmentsSearcher {
             }
             Ok(true)
         })?;
-        Ok(point_records.into_iter().map(|(_, r)| r).collect())
+        Ok(point_records.into_values().collect())
     }
 }
 

commit 6eca194f71bc20ca3e945560d47414eb10c14874
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Fri Jan 13 11:44:42 2023 +0100

    Fix segment snapshotting (#1321) (#1334)
    
    * WIP: Fix `Segment::take_snapshot`
    
    TODO:
    - This commit, probably, breaks snapshotting of segments with memmapped vector storage
    - `ProxySegment::take_snapshot` seems to potentially similar bug
    
    * WIP: Fix `Segment::take_snapshot`
    
    - Fix snapshotting of `StructPayloadIndex`
    - Fix snapshotting of segments with memmapped vector storage
    - Temporarily break `ProxySegment::take_snapshot`
    
    * Fix `ProxySegment::take_snapshot`
    
    * Remove `copy_segment_directory` test
    
    * nitpicking
    
    * clippy fixes
    
    * use OperationError::service_error
    
    * Cleanup `TinyMap` trait bounds and derive `Debug`
    
    * Fix `test_snapshot` test
    
    - Derive `Debug` for `NamedVectors`
    
    * Move utility functions from `segment.rs` to `utils` module
    
    * Contextualize `segment::utils::fs::move_all` a bit more carefully
    
    * Fix a typo
    
    * add backward compatibility with old snapshot formats
    
    * fmt
    
    * add snapshot for compatibility test
    
    * git lfs is a piece of shit
    
    * Nitpicking
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 06cacb6c2..f396b612e 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -264,7 +264,7 @@ impl SegmentsSearcher {
 
         segments.read().read_points(points, |id, segment| {
             let version = segment.point_version(id).ok_or_else(|| {
-                OperationError::service_error(&format!("No version for point {}", id))
+                OperationError::service_error(format!("No version for point {}", id))
             })?;
             // If this point was not found yet or this segment have later version
             if !point_version.contains_key(&id) || point_version[&id] < version {

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index f396b612e..523445e57 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -264,7 +264,7 @@ impl SegmentsSearcher {
 
         segments.read().read_points(points, |id, segment| {
             let version = segment.point_version(id).ok_or_else(|| {
-                OperationError::service_error(format!("No version for point {}", id))
+                OperationError::service_error(format!("No version for point {id}"))
             })?;
             // If this point was not found yet or this segment have later version
             if !point_version.contains_key(&id) || point_version[&id] < version {

commit 66ba8f17af136554e5a5a707c31d8d1fd801b70c
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Apr 10 17:16:56 2023 +0200

    Add vector specific HNSW configuration (#1675)
    
    * Validate VectorConfig/VectorParams, remove obsolete validation
    
    * Add HNSW config diff to vector parameters
    
    * Validate params in collection config
    
    * Add HNSW config to segment vector data config
    
    * Add VectorsConfig params iterator for more elegant conversions
    
    * Prefer vector HNSW config over collection config for building HNSW index
    
    * Base segment vector param HNSW config on collection config
    
    * General improvements
    
    * Rewrite HNSW ef_construct extract function to also consider vector configs
    
    * Update OpenAPI specification
    
    * Add test to check if vector specific HNSW config is persisted
    
    * review changes
    
    * review changes
    
    * Regenerate gRPC docs
    
    * Fix test on Windows
    
    * Regenerate OpenAPI specification
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 523445e57..1f38ec668 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,4 +1,3 @@
-use std::cmp::max;
 use std::collections::HashMap;
 use std::sync::Arc;
 
@@ -128,7 +127,7 @@ impl SegmentsSearcher {
                         && retrieved_points < required_limit
                         && segment_lowest_score >= lowest_batch_score
                     {
-                        log::debug!("Search to re-run without sampling on segment_id: {} segment_lowest_score: {}, lowest_batch_score: {}, retrieved_points: {}, required_limit: {}", segment_id, segment_lowest_score, lowest_batch_score, retrieved_points, required_limit);
+                        log::debug!("Search to re-run without sampling on segment_id: {segment_id} segment_lowest_score: {segment_lowest_score}, lowest_batch_score: {lowest_batch_score}, retrieved_points: {retrieved_points}, required_limit: {required_limit}");
                         // It is possible, that current segment can have better results than
                         // the lowest score in the batch. In that case, we need to re-run the search
                         // without sampling on that segment.
@@ -330,21 +329,9 @@ fn sampling_limit(
     let poisson_sampling =
         find_search_sampling_over_point_distribution(limit as f64, segment_probability)
             .unwrap_or(limit);
-    let res = if poisson_sampling > limit {
-        // sampling cannot be greater than limit
-        return limit;
-    } else {
-        // sampling should not be less than ef_limit
-        max(poisson_sampling, ef_limit.unwrap_or(0))
-    };
-    log::trace!(
-        "sampling: {}, poisson: {} segment_probability: {}, segment_points: {}, total_points: {}",
-        res,
-        poisson_sampling,
-        segment_probability,
-        segment_points,
-        total_points
-    );
+    // Sampling cannot be greater than limit, cannot be less than ef_limit
+    let res = poisson_sampling.clamp(ef_limit.unwrap_or(0), limit);
+    log::trace!("sampling: {res}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
     res
 }
 
@@ -401,10 +388,9 @@ async fn search_in_segment(
                 let read_segment = locked_segment.read();
                 let segment_points = read_segment.points_count();
                 let top = if use_sampling {
-                    let ef_limit = prev_params
-                        .params
-                        .and_then(|p| p.hnsw_ef)
-                        .or_else(|| config_hnsw_ef_construct(read_segment.config()));
+                    let ef_limit = prev_params.params.and_then(|p| p.hnsw_ef).or_else(|| {
+                        get_hnsw_ef_construct(read_segment.config(), prev_params.vector_name)
+                    });
                     sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
                 } else {
                     prev_params.top
@@ -441,7 +427,7 @@ async fn search_in_segment(
             let ef_limit = prev_params
                 .params
                 .and_then(|p| p.hnsw_ef)
-                .or_else(|| config_hnsw_ef_construct(read_segment.config()));
+                .or_else(|| get_hnsw_ef_construct(read_segment.config(), prev_params.vector_name));
             sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
         } else {
             prev_params.top
@@ -464,11 +450,20 @@ async fn search_in_segment(
     Ok((result, further_results))
 }
 
-/// None if plain index, Some if hnsw.
-fn config_hnsw_ef_construct(config: SegmentConfig) -> Option<usize> {
+/// Find the maximum segment or vector specific HNSW ef_construct in this config
+///
+/// If the index is `Plain`, `None` is returned.
+fn get_hnsw_ef_construct(config: SegmentConfig, vector_name: &str) -> Option<usize> {
     match config.index {
-        Indexes::Plain { .. } => None,
-        Indexes::Hnsw(config) => Some(config.ef_construct),
+        Indexes::Plain {} => None,
+        Indexes::Hnsw(hnsw_config) => Some(
+            config
+                .vector_data
+                .get(vector_name)
+                .and_then(|c| c.hnsw_config)
+                .map(|c| c.ef_construct)
+                .unwrap_or(hnsw_config.ef_construct),
+        ),
     }
 }
 

commit 044ccf57e9de5aad16d1c6968bd3b6aba8bc2796
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Apr 11 10:13:01 2023 +0200

    Revert clamp usage to prevent panic at runtime with high ef_limit values (#1692)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 1f38ec668..3df29bdc1 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -329,8 +329,13 @@ fn sampling_limit(
     let poisson_sampling =
         find_search_sampling_over_point_distribution(limit as f64, segment_probability)
             .unwrap_or(limit);
-    // Sampling cannot be greater than limit, cannot be less than ef_limit
-    let res = poisson_sampling.clamp(ef_limit.unwrap_or(0), limit);
+    let res = if poisson_sampling > limit {
+        // sampling cannot be greater than limit
+        return limit;
+    } else {
+        // sampling should not be less than ef_limit
+        poisson_sampling.max(ef_limit.unwrap_or(0))
+    };
     log::trace!("sampling: {res}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
     res
 }

commit bd113559b52a41509d3f7b071afb2ac7a76b751b
Author: Tim Visée <tim+github@visee.me>
Date:   Sun Apr 16 10:53:41 2023 +0200

    Fix and test effective ef_limit with poisson sampling (#1694)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 3df29bdc1..afad39f99 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -329,15 +329,15 @@ fn sampling_limit(
     let poisson_sampling =
         find_search_sampling_over_point_distribution(limit as f64, segment_probability)
             .unwrap_or(limit);
-    let res = if poisson_sampling > limit {
-        // sampling cannot be greater than limit
-        return limit;
-    } else {
-        // sampling should not be less than ef_limit
-        poisson_sampling.max(ef_limit.unwrap_or(0))
-    };
-    log::trace!("sampling: {res}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
-    res
+    let effective = effective_limit(limit, ef_limit.unwrap_or(0), poisson_sampling);
+    log::trace!("sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
+    effective
+}
+
+/// Determines the effective ef limit value for the given parameters.
+fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {
+    // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit
+    poisson_sampling.max(ef_limit).min(limit)
 }
 
 /// Process sequentially contiguous batches
@@ -629,4 +629,32 @@ mod tests {
     fn test_sampling_limit_high() {
         assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);
     }
+
+    /// Tests whether calculating the effective ef limit value is correct.
+    ///
+    /// Because there was confustion about what the effective value should be for some imput
+    /// combinations, we decided to write this tests to ensure correctness.
+    ///
+    /// See: <https://github.com/qdrant/qdrant/pull/1694>
+    #[test]
+    fn test_effective_limit() {
+        // Test cases to assert: (limit, ef_limit, poisson_sampling, effective)
+        let tests = [
+            (1000, 128, 150, 150),
+            (1000, 128, 110, 128),
+            (130, 128, 150, 130),
+            (130, 128, 110, 128),
+            (50, 128, 150, 50),
+            (50, 128, 110, 50),
+            (500, 1000, 300, 500),
+            (500, 400, 300, 400),
+            (1000, 0, 150, 150),
+            (1000, 0, 110, 110),
+        ];
+        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective)| assert_eq!(
+            effective_limit(limit, ef_limit, poisson_sampling),
+            effective,
+            "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",
+        ));
+    }
 }

commit 7edf599d73cd65b47476be72009684451b7533a9
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Apr 25 14:31:04 2023 +0200

    Make query planner aware of deleted points and vectors (#1757)
    
    * Exclude deleted vectors from HNSW graph building stage
    
    * When estimating query cardinality, use available points as baseline
    
    We should not use the total number of points in a segment, because a
    portion of it may be soft deleted. Instead, we use the available
    (non-deleted) points as baseline.
    
    * Add plain search check to unfiltered HNSW search due to deleted points
    
    * Cardinality sampling on available points, ignore deleted named vectors
    
    * Estimate available vectors in query planner, now consider deleted points
    
    In the query planner, we want to know the number of available points as
    accurately as possible. This isn't possible because we only know the
    number of deletions and vectors can be deleted in two places: as point
    or as vector. These deletions may overlap. This now estimates the number
    of deleted vectors based on the segment state. It assumes that point and
    vector deletions have an overlap of 20%. This is an arbitrary
    percentage, but reflects an almost-worst scenario.
    
    This improves because the number of deleted points wasn't considered at
    all before.
    
    * Remove unused function from trait
    
    * Fix bench compilation error
    
    * Fix typo in docs
    
    * Base whether to do plain search in HNSW upon full scan threshold
    
    * Remove index threshold from HNSW config, only use full scan threshold
    
    * Simplify timer aggregator assignment in HNSW search
    
    * Remove vector storage type from cardinality function parameters
    
    * Propagate point deletes to all its vectors
    
    * Check for deleted vectors first, this makes early return possible
    
    Since point deletes are now propagated to vectors, deleted points are
    included in vector deletions. Because of that we can check if the vector
    is deleted first so we can return early and skip the point deletion
    check.
    
    For integrity we also check if the point is deleted, if the vector was
    not. That is because it may happen that point deletions are not properly
    propagated to vectors.
    
    * Don't use arbitrary vector count estimation, use vector count directly
    
    Before we had to estimate the number of vectors (for a named vector)
    because vectors could be deleted as point or vector. Point deletes are
    now propagated to vector deletes, that means we can simply use the
    deleted vector count which is now much more accurate.
    
    * When sampling IDs, check deleted vecs before deleted points
    
    * On segment consistency check, delete vectors for deleted points
    
    * Fix vector delete state not being kept when updating storage from other
    
    * Fix segment builder skipping deleted vectors breaking offsets
    
    * update segment to handle optional vectors + add test (#1781)
    
    * update segment to handle optional vectors + add test
    
    * Only update stored record when deleting if it wasn't deleted already
    
    * Reformat comment
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    
    * Fix missed vector name test, these are now marked as deleted
    
    * upd test
    
    * upd test
    
    * Update consensus test
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index afad39f99..e1b21f518 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -286,10 +286,19 @@ impl SegmentsSearcher {
                             WithVector::Selector(vector_names) => {
                                 let mut selected_vectors = NamedVectors::default();
                                 for vector_name in vector_names {
-                                    selected_vectors.insert(
-                                        vector_name.clone(),
-                                        segment.vector(vector_name, id)?,
-                                    );
+                                    let vector_opt = segment.vector(vector_name, id)?;
+                                    match vector_opt {
+                                        Some(vector) => {
+                                            selected_vectors.insert(vector_name.clone(), vector);
+                                        }
+                                        None => {
+                                            // ToDo: Allow to return partial result
+                                            return Err(OperationError::service_error(format!(
+                                                "Vector {} not found for point {}",
+                                                vector_name, id
+                                            )));
+                                        }
+                                    }
                                 }
                                 Some(selected_vectors.into())
                             }

commit 1c85c9b2359c81897da57ea7dd5e9f0bdbf67791
Author: Tim Visée <tim+github@visee.me>
Date:   Fri Apr 28 10:36:58 2023 +0200

    Add optimizer for many deleted points, make aware of deleted points and vectors (#1758)
    
    * Minor collection optimizer cleanup
    
    * Make optimizers better aware of available vs soft deleted points
    
    * Fix incorrect deleted state on proxy segment for double delete
    
    * Rename upsert_vector to upsert_point, because we work with points
    
    * Refactor point methods for more clear and consistent naming
    
    * Replace internal_size in IdTracker with total_point_count
    
    * Keep track of vector deletion count on storage creation
    
    * Add sparse index optimizer, to optimize indexes with high deletion count
    
    * Add minimum vector count threshold to sparse index optimizer
    
    * Add sparse index optimizer test
    
    * Use consistent naming, write vector in full everywhere
    
    * Simplify vacuum optimizer a bit
    
    * Merge sparse index optimizer into vacuum optimizer
    
    * Improve update_from in segment builder by returning early
    
    * More accurately count vectors in segment optimizer
    
    * Remove random from vacuum optimizer tests to make them more reliable
    
    * Don't expose the total points in segment info, use available points
    
    * Process review feedback
    
    * Compare available vectors against indexed ones in vacuum optimizer
    
    This is much better than using the number of soft-deleted vectors when
    the segment was created for calculations. Not to mention that value had
    other problems as well.
    
    * Remove create_deleted_vector_count field, update vacuum test parameters
    
    * Potentially solve out of bound panic when building index
    
    * Review fixes:
    
    - Propagate deleted flags into payload hnsw building
    - Use `total` number of points for building HNSW instead of number of
      available points
    - minor refactoring of `hnsw_config` copy -> clone
    - Better detection of `indexed_points` in HNSW
    
    * fix assert condition
    
    * Optional named vectors optimizer reveiw 2 (#1794)
    
    * review with Ivan
    
    * fmt
    
    * remove available_vector_count from segment entry
    
    * remove total_point_count from segment entry
    
    ---------
    
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>
    
    * rollback changes in deleted count in proxy segment
    
    * improve vector threshold detection logic in optimized_segment_builder
    
    * style changes
    
    * fix propagate deleted points to vectors
    
    * Fix typo in method name
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Ivan Pleshkov <pleshkov.ivan@gmail.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index e1b21f518..34daa791a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -156,7 +156,6 @@ impl SegmentsSearcher {
             let segments = segments.read();
 
             let some_segment = segments.iter().next();
-
             if some_segment.is_none() {
                 return Ok(vec![]);
             }
@@ -168,11 +167,12 @@ impl SegmentsSearcher {
             // - sampling is enabled
             // - more than 1 segment
             // - segments are not empty
-            let total_points_segments = segments
+            let available_points_segments = segments
                 .iter()
-                .map(|(_, segment)| segment.get().read().points_count())
+                .map(|(_, segment)| segment.get().read().available_point_count())
                 .sum();
-            let use_sampling = sampling_enabled && segments.len() > 1 && total_points_segments > 0;
+            let use_sampling =
+                sampling_enabled && segments.len() > 1 && available_points_segments > 0;
 
             segments
                 .iter()
@@ -182,7 +182,7 @@ impl SegmentsSearcher {
                         search_in_segment(
                             segment.clone(),
                             batch_request.clone(),
-                            total_points_segments,
+                            available_points_segments,
                             use_sampling,
                         ),
                     )
@@ -372,7 +372,7 @@ async fn search_in_segment(
     let batch_size = request.searches.len();
 
     let mut result: Vec<Vec<ScoredPoint>> = Vec::with_capacity(batch_size);
-    let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // true if segment have more points to return
+    let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // if segment have more points to return
     let mut vectors_batch: Vec<&[VectorElementType]> = vec![];
     let mut prev_params = BatchSearchParams::default();
 
@@ -400,7 +400,7 @@ async fn search_in_segment(
             if !vectors_batch.is_empty() {
                 let locked_segment = segment.get();
                 let read_segment = locked_segment.read();
-                let segment_points = read_segment.points_count();
+                let segment_points = read_segment.available_point_count();
                 let top = if use_sampling {
                     let ef_limit = prev_params.params.and_then(|p| p.hnsw_ef).or_else(|| {
                         get_hnsw_ef_construct(read_segment.config(), prev_params.vector_name)
@@ -436,7 +436,7 @@ async fn search_in_segment(
     if !vectors_batch.is_empty() {
         let locked_segment = segment.get();
         let read_segment = locked_segment.read();
-        let segment_points = read_segment.points_count();
+        let segment_points = read_segment.available_point_count();
         let top = if use_sampling {
             let ef_limit = prev_params
                 .params
@@ -474,7 +474,7 @@ fn get_hnsw_ef_construct(config: SegmentConfig, vector_name: &str) -> Option<usi
             config
                 .vector_data
                 .get(vector_name)
-                .and_then(|c| c.hnsw_config)
+                .and_then(|c| c.hnsw_config.as_ref())
                 .map(|c| c.ef_construct)
                 .unwrap_or(hnsw_config.ef_construct),
         ),

commit df711b7c2e64ec4baf9c086fab2ba68dcdf0966e
Author: Tim Visée <tim+github@visee.me>
Date:   Wed May 17 09:49:55 2023 +0200

    Refactor segment config (#1894)
    
    * Clone current segment config to deprecated type
    
    * Remove segment level quantization config from segment config
    
    * Also deprecate current VectorDataConfig
    
    * Update old segment migration to work with new refactoring
    
    * Move index into vector data config
    
    * Move vector data config migration logic into segment level
    
    * Remove hnsw_config from vector data config
    
    * Rename collection params to vector data conversions function
    
    * Move storage type into vector data config
    
    * Set appendable flag correctly
    
    * Clean up and reformat
    
    * Make segment on disk flag not optional
    
    * Add appendable flag to segment config to replace storage type
    
    * Remove storage type from segment config
    
    * Deprecate storage type enum
    
    * Use consistent variable naming
    
    * Cleanup
    
    * Add segment config migration for v0.5.0 to current
    
    * Bump segment to 0.6.0
    
    * Remove serde defaults for new storage and vector data config types
    
    These default value configurations are not needed anymore, because these
    structs are not used to deserialize old data. All current fields should
    always be available in these structs. When new fields are added in new
    functions, the serde default annotation must be set again.
    
    * Cleanup
    
    * Update OpenAPI specification
    
    This updates the returned data structure on telemetry endpoints, as a
    result of segment configuration refactoring.
    
    * Fix quantization configuration not falling back to collection config
    
    * Fix compiler warning when building in release mode
    
    * Move deprecated type structs into compat module
    
    * Update allow deprecated attributes
    
    * Assign quantization config only in segment optimizer
    
    * Remove unsued parameter
    
    * Add vector storage type enum to vector data config
    
    * Remove appendable and on_disk flags from segment and vector config
    
    * Update OpenAPI specification
    
    * add tests
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 34daa791a..906c48120 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -464,21 +464,18 @@ async fn search_in_segment(
     Ok((result, further_results))
 }
 
-/// Find the maximum segment or vector specific HNSW ef_construct in this config
+/// Find the HNSW ef_construct for a named vector
 ///
-/// If the index is `Plain`, `None` is returned.
+/// If the given named vector has no HNSW index, `None` is returned.
 fn get_hnsw_ef_construct(config: SegmentConfig, vector_name: &str) -> Option<usize> {
-    match config.index {
-        Indexes::Plain {} => None,
-        Indexes::Hnsw(hnsw_config) => Some(
-            config
-                .vector_data
-                .get(vector_name)
-                .and_then(|c| c.hnsw_config.as_ref())
-                .map(|c| c.ef_construct)
-                .unwrap_or(hnsw_config.ef_construct),
-        ),
-    }
+    config
+        .vector_data
+        .get(vector_name)
+        .and_then(|config| match &config.index {
+            Indexes::Plain {} => None,
+            Indexes::Hnsw(hnsw) => Some(hnsw),
+        })
+        .map(|hnsw| hnsw.ef_construct)
 }
 
 #[cfg(test)]

commit 3fa77e85b3b2f4d2a07b7e8bc217541ce2f23c5d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu May 18 18:26:40 2023 +0200

    one more test for optional vectors (#1925)
    
    * one more test for optional vectors
    
    * remove check
    
    * clippy
    
    * Add test retrieving non existing vector name
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 906c48120..631bf4197 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -286,18 +286,8 @@ impl SegmentsSearcher {
                             WithVector::Selector(vector_names) => {
                                 let mut selected_vectors = NamedVectors::default();
                                 for vector_name in vector_names {
-                                    let vector_opt = segment.vector(vector_name, id)?;
-                                    match vector_opt {
-                                        Some(vector) => {
-                                            selected_vectors.insert(vector_name.clone(), vector);
-                                        }
-                                        None => {
-                                            // ToDo: Allow to return partial result
-                                            return Err(OperationError::service_error(format!(
-                                                "Vector {} not found for point {}",
-                                                vector_name, id
-                                            )));
-                                        }
+                                    if let Some(vector) = segment.vector(vector_name, id)? {
+                                        selected_vectors.insert(vector_name.into(), vector);
                                     }
                                 }
                                 Some(selected_vectors.into())

commit ab7ab03a327aab401f11e858bb8df400e52b809d
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Jun 9 00:05:00 2023 +0200

    Fix batch request with duplicated filter (#2051)
    
    * fix double usage of iterator
    
    * tests

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 631bf4197..af4cc40e7 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -303,7 +303,7 @@ impl SegmentsSearcher {
     }
 }
 
-#[derive(PartialEq, Default)]
+#[derive(PartialEq, Default, Debug)]
 struct BatchSearchParams<'a> {
     pub vector_name: &'a str,
     pub filter: Option<&'a Filter>,

commit 9c1c4e7d3574c9c4dc0acfaae5e5d0bf02703bdb
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Jul 5 15:24:10 2023 +0200

    SegmentSearcher retrieve is not async (#2210)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index af4cc40e7..c755dda8a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -252,7 +252,7 @@ impl SegmentsSearcher {
         Ok(top_scores)
     }
 
-    pub async fn retrieve(
+    pub fn retrieve(
         segments: &RwLock<SegmentHolder>,
         points: &[PointIdType],
         with_payload: &WithPayload,
@@ -595,8 +595,8 @@ mod tests {
         }
     }
 
-    #[tokio::test]
-    async fn test_retrieve() {
+    #[test]
+    fn test_retrieve() {
         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
         let segment_holder = build_test_holder(dir.path());
 
@@ -606,7 +606,6 @@ mod tests {
             &WithPayload::from(true),
             &true.into(),
         )
-        .await
         .unwrap();
         assert_eq!(records.len(), 3);
     }

commit c1a7157b5fea558bba709c5f90a36f23d0127663
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Jul 10 15:00:04 2023 +0200

    SegmentSearcher search-in-segment is not async (#2211)
    
    * SegmentSearcher search_in_segment is not async
    
    * keep it iterator style

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index c755dda8a..903b7e216 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -177,17 +177,19 @@ impl SegmentsSearcher {
             segments
                 .iter()
                 .map(|(_id, segment)| {
-                    (
-                        segment.clone(),
-                        search_in_segment(
-                            segment.clone(),
-                            batch_request.clone(),
-                            available_points_segments,
-                            use_sampling,
-                        ),
-                    )
+                    let search = runtime_handle.spawn_blocking({
+                        let (segment, batch_request) = (segment.clone(), batch_request.clone());
+                        move || {
+                            search_in_segment(
+                                segment,
+                                batch_request,
+                                available_points_segments,
+                                use_sampling,
+                            )
+                        }
+                    });
+                    (segment.clone(), search)
                 })
-                .map(|(segment, f)| (segment, runtime_handle.spawn(f)))
                 .unzip()
         };
         // perform search on all segments concurrently
@@ -224,8 +226,9 @@ impl SegmentsSearcher {
                             .collect(),
                     });
 
-                    let search = search_in_segment(segment, partial_batch_request, 0, false);
-                    res.push(runtime_handle.spawn(search))
+                    res.push(runtime_handle.spawn_blocking(|| {
+                        search_in_segment(segment, partial_batch_request, 0, false)
+                    }))
                 }
                 res
             };
@@ -353,7 +356,7 @@ fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> us
 /// Collection Result of:
 /// * Vector of ScoredPoints for each request in the batch
 /// * Vector of boolean indicating if the segment have further points to search
-async fn search_in_segment(
+fn search_in_segment(
     segment: LockedSegment,
     request: Arc<SearchRequestBatch>,
     total_points: usize,

commit 462ce6ba051297aac2c32ab0e89de3e1cbb24390
Author: Yaroslav Halchenko <debian@onerussian.com>
Date:   Wed Jul 12 10:30:42 2023 -0400

    codespell: workflow, config, typos fixed (#2248)
    
    * Add github action to codespell master on push and PRs
    
    * Add rudimentary codespell config
    
    * some skips
    
    * fix some ambigous typos
    
    * [DATALAD RUNCMD] run codespell throughout
    
    === Do not change lines below ===
    {
     "chain": [],
     "cmd": "codespell -w",
     "exit": 0,
     "extra_inputs": [],
     "inputs": [],
     "outputs": [],
     "pwd": "."
    }
    ^^^ Do not change lines above ^^^
    
    * Add dev branch as target for the workflow

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 903b7e216..9a307260b 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -630,7 +630,7 @@ mod tests {
 
     /// Tests whether calculating the effective ef limit value is correct.
     ///
-    /// Because there was confustion about what the effective value should be for some imput
+    /// Because there was confustion about what the effective value should be for some input
     /// combinations, we decided to write this tests to ensure correctness.
     ///
     /// See: <https://github.com/qdrant/qdrant/pull/1694>

commit 76f7d2fc68b124d3fe788900fd022b8daee0c60e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jul 24 12:45:33 2023 +0200

    Search timeout (#2293)
    
    * pass atomic bool from local shard to raw scorer
    
    * pass atomic bool from local shard to raw scorer
    
    * is_stopped in async scorer
    
    * fmt
    
    * is_stopped in quantized scorer
    
    * terminating scorer if stopped
    
    * enable timeout in local_shard
    
    * allow timeout configuration
    
    * use tokio spawn to ensure timeout handling if request is dropped
    
    * Revert "use tokio spawn to ensure timeout handling if request is dropped"
    
    This reverts commit 1068cf48d481b8856da41869b71b1f9a361f7e2d.
    
    * use stopping guard instead of task
    
    * report error if search request is stopped
    
    * fmt
    
    * refactor transient error handelling

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 9a307260b..ca8d01dc9 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,4 +1,5 @@
 use std::collections::HashMap;
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use futures::future::try_join_all;
@@ -148,6 +149,7 @@ impl SegmentsSearcher {
         batch_request: Arc<SearchRequestBatch>,
         runtime_handle: &Handle,
         sampling_enabled: bool,
+        is_stopped: Arc<AtomicBool>,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         // Using { } block to ensure segments variable is dropped in the end of it
         // and is not transferred across the all_searches.await? boundary as it
@@ -179,12 +181,14 @@ impl SegmentsSearcher {
                 .map(|(_id, segment)| {
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
+                        let is_stopped_clone = is_stopped.clone();
                         move || {
                             search_in_segment(
                                 segment,
                                 batch_request,
                                 available_points_segments,
                                 use_sampling,
+                                &is_stopped_clone,
                             )
                         }
                     });
@@ -225,9 +229,15 @@ impl SegmentsSearcher {
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
                             .collect(),
                     });
-
-                    res.push(runtime_handle.spawn_blocking(|| {
-                        search_in_segment(segment, partial_batch_request, 0, false)
+                    let is_stopped_clone = is_stopped.clone();
+                    res.push(runtime_handle.spawn_blocking(move || {
+                        search_in_segment(
+                            segment,
+                            partial_batch_request,
+                            0,
+                            false,
+                            &is_stopped_clone,
+                        )
                     }))
                 }
                 res
@@ -361,6 +371,7 @@ fn search_in_segment(
     request: Arc<SearchRequestBatch>,
     total_points: usize,
     use_sampling: bool,
+    is_stopped: &AtomicBool,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -411,6 +422,7 @@ fn search_in_segment(
                     prev_params.filter,
                     top,
                     prev_params.params,
+                    is_stopped,
                 )?;
                 for batch_result in &res {
                     further_results.push(batch_result.len() == top);
@@ -447,6 +459,7 @@ fn search_in_segment(
             prev_params.filter,
             top,
             prev_params.params,
+            is_stopped,
         )?;
         for batch_result in &res {
             further_results.push(batch_result.len() == top);
@@ -508,6 +521,7 @@ mod tests {
             Arc::new(batch_request),
             &Handle::current(),
             true,
+            Arc::new(AtomicBool::new(false)),
         )
         .await
         .unwrap()
@@ -570,6 +584,7 @@ mod tests {
                 Arc::new(batch_request.clone()),
                 &Handle::current(),
                 false,
+                Arc::new(false.into()),
             )
             .await
             .unwrap();
@@ -581,6 +596,7 @@ mod tests {
                 Arc::new(batch_request),
                 &Handle::current(),
                 true,
+                Arc::new(false.into()),
             )
             .await
             .unwrap();

commit ecaff1023de967e0f2e3ea0facf98b80268ff87d
Author: Di Zhao <di.zhao@gmail.com>
Date:   Wed Aug 16 01:56:44 2023 -0700

    Add `indexed_only` to speed up search (#2431)
    
    * add ignore_plain_index to speed up search
    
    * remove unnecessary & for vectors_batch
    
    * format
    
    * add special handle for proxy segments where the wrapped segment is plain
    indexed
    
    * review refactoring
    
    * rollback changes in google.protobuf.rs
    
    ---------
    
    Co-authored-by: Di Zhao <diz@twitter.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index ca8d01dc9..78b6d3419 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,16 +1,18 @@
 use std::collections::HashMap;
+use std::ops::Deref;
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use futures::future::try_join_all;
 use ordered_float::Float;
 use parking_lot::RwLock;
+use segment::common::BYTES_IN_KB;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::VectorElementType;
-use segment::entry::entry_point::OperationError;
+use segment::entry::entry_point::{OperationError, SegmentEntry};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoreType, ScoredPoint, SearchParams, SegmentConfig,
-    SeqNumberType, WithPayload, WithPayloadInterface, WithVector,
+    SeqNumberType, WithPayload, WithPayloadInterface, WithVector, VECTOR_ELEMENT_SIZE,
 };
 use tokio::runtime::Handle;
 use tokio::task::JoinHandle;
@@ -18,7 +20,7 @@ use tokio::task::JoinHandle;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
-use crate::operations::types::{CollectionResult, Record, SearchRequestBatch};
+use crate::operations::types::{CollectionError, CollectionResult, Record, SearchRequestBatch};
 
 type BatchOffset = usize;
 type SegmentOffset = usize;
@@ -150,6 +152,7 @@ impl SegmentsSearcher {
         runtime_handle: &Handle,
         sampling_enabled: bool,
         is_stopped: Arc<AtomicBool>,
+        indexing_threshold_kb: usize,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         // Using { } block to ensure segments variable is dropped in the end of it
         // and is not transferred across the all_searches.await? boundary as it
@@ -189,6 +192,7 @@ impl SegmentsSearcher {
                                 available_points_segments,
                                 use_sampling,
                                 &is_stopped_clone,
+                                indexing_threshold_kb,
                             )
                         }
                     });
@@ -237,6 +241,7 @@ impl SegmentsSearcher {
                             0,
                             false,
                             &is_stopped_clone,
+                            indexing_threshold_kb,
                         )
                     }))
                 }
@@ -360,6 +365,9 @@ fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> us
 /// * `request` - Batch of search requests
 /// * `total_points` - Number of points in all segments combined
 /// * `use_sampling` - If true, try to use probabilistic sampling
+/// * `is_stopped` - Atomic bool to check if search is stopped
+/// * `indexing_threshold` - If `indexed_only` is enabled, the search will skip
+///                          segments with more than this number Kb of un-indexed vectors
 ///
 /// # Returns
 ///
@@ -372,6 +380,7 @@ fn search_in_segment(
     total_points: usize,
     use_sampling: bool,
     is_stopped: &AtomicBool,
+    indexing_threshold_kb: usize,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -402,34 +411,18 @@ fn search_in_segment(
             // different params means different batches
             // execute what has been batched so far
             if !vectors_batch.is_empty() {
-                let locked_segment = segment.get();
-                let read_segment = locked_segment.read();
-                let segment_points = read_segment.available_point_count();
-                let top = if use_sampling {
-                    let ef_limit = prev_params.params.and_then(|p| p.hnsw_ef).or_else(|| {
-                        get_hnsw_ef_construct(read_segment.config(), prev_params.vector_name)
-                    });
-                    sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
-                } else {
-                    prev_params.top
-                };
-
-                let mut res = read_segment.search_batch(
-                    prev_params.vector_name,
+                let (mut res, mut further) = execute_batch_search(
+                    &segment,
                     &vectors_batch,
-                    &prev_params.with_payload,
-                    &prev_params.with_vector,
-                    prev_params.filter,
-                    top,
-                    prev_params.params,
+                    &prev_params,
+                    use_sampling,
+                    total_points,
                     is_stopped,
+                    indexing_threshold_kb,
                 )?;
-                for batch_result in &res {
-                    further_results.push(batch_result.len() == top);
-                }
+                further_results.append(&mut further);
                 result.append(&mut res);
-                // clear current batch
-                vectors_batch.clear();
+                vectors_batch.clear()
             }
             // start new batch for current search query
             vectors_batch.push(search_query.vector.get_vector().as_slice());
@@ -439,41 +432,119 @@ fn search_in_segment(
 
     // run last batch if any
     if !vectors_batch.is_empty() {
-        let locked_segment = segment.get();
-        let read_segment = locked_segment.read();
-        let segment_points = read_segment.available_point_count();
-        let top = if use_sampling {
-            let ef_limit = prev_params
-                .params
-                .and_then(|p| p.hnsw_ef)
-                .or_else(|| get_hnsw_ef_construct(read_segment.config(), prev_params.vector_name));
-            sampling_limit(prev_params.top, ef_limit, segment_points, total_points)
-        } else {
-            prev_params.top
-        };
-        let mut res = read_segment.search_batch(
-            prev_params.vector_name,
+        let (mut res, mut further) = execute_batch_search(
+            &segment,
             &vectors_batch,
-            &prev_params.with_payload,
-            &prev_params.with_vector,
-            prev_params.filter,
-            top,
-            prev_params.params,
+            &prev_params,
+            use_sampling,
+            total_points,
             is_stopped,
+            indexing_threshold_kb,
         )?;
-        for batch_result in &res {
-            further_results.push(batch_result.len() == top);
-        }
+        further_results.append(&mut further);
         result.append(&mut res);
     }
 
     Ok((result, further_results))
 }
 
+fn execute_batch_search(
+    segment: &LockedSegment,
+    vectors_batch: &Vec<&[VectorElementType]>,
+    search_params: &BatchSearchParams,
+    use_sampling: bool,
+    total_points: usize,
+    is_stopped: &AtomicBool,
+    indexing_threshold_kb: usize,
+) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
+    let locked_segment = segment.get();
+    let read_segment = locked_segment.read();
+
+    let segment_points = read_segment.available_point_count();
+    let segment_config = read_segment.config();
+
+    let top = if use_sampling {
+        let ef_limit = search_params
+            .params
+            .and_then(|p| p.hnsw_ef)
+            .or_else(|| get_hnsw_ef_construct(segment_config, search_params.vector_name));
+        sampling_limit(search_params.top, ef_limit, segment_points, total_points)
+    } else {
+        search_params.top
+    };
+
+    let ignore_plain_index = search_params
+        .params
+        .map(|p| p.indexed_only)
+        .unwrap_or(false);
+    if ignore_plain_index
+        && check_is_indexed_condition(
+            read_segment.deref(),
+            indexing_threshold_kb,
+            search_params.vector_name,
+        )?
+    {
+        let batch_len = vectors_batch.len();
+        return Ok((vec![vec![]; batch_len], vec![false; batch_len]));
+    }
+    let res = read_segment.search_batch(
+        search_params.vector_name,
+        vectors_batch,
+        &search_params.with_payload,
+        &search_params.with_vector,
+        search_params.filter,
+        top,
+        search_params.params,
+        is_stopped,
+    )?;
+
+    let further_results = res
+        .iter()
+        .map(|batch_result| batch_result.len() == top)
+        .collect();
+
+    Ok((res, further_results))
+}
+
+/// Check if the segment is indexed enough to be searched with `indexed_only` parameter
+fn check_is_indexed_condition(
+    segment: &dyn SegmentEntry,
+    indexing_threshold_kb: usize,
+    vector_name: &str,
+) -> CollectionResult<bool> {
+    let segment_info = segment.info();
+    let vector_name_error =
+        || CollectionError::bad_request(format!("Vector {} doesn't exist", vector_name));
+
+    let vector_data_info = segment_info
+        .vector_data
+        .get(vector_name)
+        .ok_or_else(vector_name_error)?;
+
+    let vector_size = segment
+        .config()
+        .vector_data
+        .get(vector_name)
+        .ok_or_else(vector_name_error)?
+        .size;
+
+    let vector_size_bytes = vector_size * VECTOR_ELEMENT_SIZE;
+
+    let unindexed_vectors = vector_data_info
+        .num_vectors
+        .saturating_sub(vector_data_info.num_indexed_vectors);
+
+    let unindexed_volume = vector_size_bytes.saturating_mul(unindexed_vectors);
+
+    let indexing_threshold_bytes = indexing_threshold_kb * BYTES_IN_KB;
+
+    Ok(unindexed_volume < indexing_threshold_bytes)
+}
+
 /// Find the HNSW ef_construct for a named vector
 ///
 /// If the given named vector has no HNSW index, `None` is returned.
-fn get_hnsw_ef_construct(config: SegmentConfig, vector_name: &str) -> Option<usize> {
+fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &str) -> Option<usize> {
     config
         .vector_data
         .get(vector_name)
@@ -492,6 +563,7 @@ mod tests {
     use super::*;
     use crate::collection_manager::fixtures::{build_test_holder, random_segment};
     use crate::operations::types::SearchRequest;
+    use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
     #[tokio::test]
     async fn test_segments_search() {
@@ -522,6 +594,7 @@ mod tests {
             &Handle::current(),
             true,
             Arc::new(AtomicBool::new(false)),
+            DEFAULT_INDEXING_THRESHOLD_KB,
         )
         .await
         .unwrap()
@@ -585,6 +658,7 @@ mod tests {
                 &Handle::current(),
                 false,
                 Arc::new(false.into()),
+                DEFAULT_INDEXING_THRESHOLD_KB,
             )
             .await
             .unwrap();
@@ -597,6 +671,7 @@ mod tests {
                 &Handle::current(),
                 true,
                 Arc::new(false.into()),
+                DEFAULT_INDEXING_THRESHOLD_KB,
             )
             .await
             .unwrap();

commit a0fa6015b9e0f3d524bda95b1269807f7785f410
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Aug 22 19:47:44 2023 +0200

    Fix indexed only (#2488)
    
    * fix indexed only condition + tests
    
    * fmt

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 78b6d3419..7ae180278 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -478,7 +478,7 @@ fn execute_batch_search(
         .map(|p| p.indexed_only)
         .unwrap_or(false);
     if ignore_plain_index
-        && check_is_indexed_condition(
+        && !is_search_optimized(
             read_segment.deref(),
             indexing_threshold_kb,
             search_params.vector_name,
@@ -507,7 +507,7 @@ fn execute_batch_search(
 }
 
 /// Check if the segment is indexed enough to be searched with `indexed_only` parameter
-fn check_is_indexed_condition(
+fn is_search_optimized(
     segment: &dyn SegmentEntry,
     indexing_threshold_kb: usize,
     vector_name: &str,
@@ -538,6 +538,18 @@ fn check_is_indexed_condition(
 
     let indexing_threshold_bytes = indexing_threshold_kb * BYTES_IN_KB;
 
+    // Examples:
+    // Threshold = 20_000 Kb
+    // Indexed vectors: 100000
+    // Total vectors: 100010
+    // unindexed_volume = 100010 - 100000 = 10
+    // Result: true
+
+    // Threshold = 20_000 Kb
+    // Indexed vectors: 0
+    // Total vectors: 100000
+    // unindexed_volume = 100000
+    // Result: false
     Ok(unindexed_volume < indexing_threshold_bytes)
 }
 
@@ -558,13 +570,45 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &str) -> Option<us
 #[cfg(test)]
 mod tests {
     use segment::fixtures::index_fixtures::random_vector;
+    use segment::types::SegmentType;
     use tempfile::Builder;
 
     use super::*;
-    use crate::collection_manager::fixtures::{build_test_holder, random_segment};
+    use crate::collection_manager::fixtures::{
+        build_test_holder, optimize_segment, random_segment,
+    };
     use crate::operations::types::SearchRequest;
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
+    #[test]
+    fn test_is_indexed_enough_condition() {
+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
+
+        let segment1 = random_segment(dir.path(), 10, 200, 256);
+
+        let res_1 = is_search_optimized(&segment1, 25, "").unwrap();
+
+        assert!(!res_1);
+
+        let res_2 = is_search_optimized(&segment1, 225, "").unwrap();
+
+        assert!(res_2);
+
+        let indexed_segment = optimize_segment(segment1);
+
+        let indexed_segment_get = indexed_segment.get();
+        let indexed_segment_read = indexed_segment_get.read();
+
+        assert_eq!(
+            indexed_segment_read.info().segment_type,
+            SegmentType::Indexed
+        );
+
+        let res_3 = is_search_optimized(indexed_segment_read.deref(), 25, "").unwrap();
+
+        assert!(res_3);
+    }
+
     #[tokio::test]
     async fn test_segments_search() {
         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();

commit c8bdec7b0616c47e1c3057b3f8ef8435833dc74f
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Sep 5 09:26:24 2023 -0300

    Refactor batch search to allow different scorers (#2529)
    
    * add enum for vector query on segment search
    
    * rename newly introduced types
    
    * fix: handle QueryVector on async scorer
    
    * handle QueryVector in QuantizedVectors impl
    
    * fix async scorer test after refactor
    
    * rebase + refactor on queue_proxy_shard.rs
    
    * constrain refactor propagation to segment_searcher
    
    * fmt
    
    * fix after rebase

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7ae180278..171f6cf8c 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -4,11 +4,12 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use futures::future::try_join_all;
+use itertools::Itertools;
 use ordered_float::Float;
 use parking_lot::RwLock;
 use segment::common::BYTES_IN_KB;
 use segment::data_types::named_vectors::NamedVectors;
-use segment::data_types::vectors::VectorElementType;
+use segment::data_types::vectors::QueryVector;
 use segment::entry::entry_point::{OperationError, SegmentEntry};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoreType, ScoredPoint, SearchParams, SegmentConfig,
@@ -20,7 +21,9 @@ use tokio::task::JoinHandle;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
-use crate::operations::types::{CollectionError, CollectionResult, Record, SearchRequestBatch};
+use crate::operations::types::{
+    CollectionError, CollectionResult, CoreSearchRequestBatch, QueryEnum, Record,
+};
 
 type BatchOffset = usize;
 type SegmentOffset = usize;
@@ -148,7 +151,7 @@ impl SegmentsSearcher {
 
     pub async fn search(
         segments: &RwLock<SegmentHolder>,
-        batch_request: Arc<SearchRequestBatch>,
+        batch_request: Arc<CoreSearchRequestBatch>,
         runtime_handle: &Handle,
         sampling_enabled: bool,
         is_stopped: Arc<AtomicBool>,
@@ -227,7 +230,7 @@ impl SegmentsSearcher {
                 let mut res = vec![];
                 for (segment_id, batch_ids) in searches_to_rerun.iter() {
                     let segment = locked_segments[*segment_id].clone();
-                    let partial_batch_request = Arc::new(SearchRequestBatch {
+                    let partial_batch_request = Arc::new(CoreSearchRequestBatch {
                         searches: batch_ids
                             .iter()
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
@@ -321,8 +324,25 @@ impl SegmentsSearcher {
     }
 }
 
+#[derive(PartialEq, Default, Debug)]
+pub enum SearchType {
+    #[default]
+    Nearest,
+    // Recommend,
+}
+
+impl From<&QueryEnum> for SearchType {
+    fn from(query: &QueryEnum) -> Self {
+        match query {
+            QueryEnum::Nearest(_) => Self::Nearest,
+            // QueryEnum::PositiveNegative { .. } => Self::Recommend,
+        }
+    }
+}
+
 #[derive(PartialEq, Default, Debug)]
 struct BatchSearchParams<'a> {
+    pub search_type: SearchType,
     pub vector_name: &'a str,
     pub filter: Option<&'a Filter>,
     pub with_payload: WithPayload,
@@ -376,7 +396,7 @@ fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> us
 /// * Vector of boolean indicating if the segment have further points to search
 fn search_in_segment(
     segment: LockedSegment,
-    request: Arc<SearchRequestBatch>,
+    request: Arc<CoreSearchRequestBatch>,
     total_points: usize,
     use_sampling: bool,
     is_stopped: &AtomicBool,
@@ -386,7 +406,7 @@ fn search_in_segment(
 
     let mut result: Vec<Vec<ScoredPoint>> = Vec::with_capacity(batch_size);
     let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // if segment have more points to return
-    let mut vectors_batch: Vec<&[VectorElementType]> = vec![];
+    let mut vectors_batch: Vec<QueryVector> = vec![];
     let mut prev_params = BatchSearchParams::default();
 
     for search_query in &request.searches {
@@ -396,7 +416,8 @@ fn search_in_segment(
             .unwrap_or(&WithPayloadInterface::Bool(false));
 
         let params = BatchSearchParams {
-            vector_name: search_query.vector.get_name(),
+            search_type: search_query.query.as_ref().into(),
+            vector_name: search_query.query.get_vector_name(),
             filter: search_query.filter.as_ref(),
             with_payload: WithPayload::from(with_payload_interface),
             with_vector: search_query.with_vector.clone().unwrap_or_default(),
@@ -404,9 +425,11 @@ fn search_in_segment(
             params: search_query.params.as_ref(),
         };
 
+        let query = search_query.query.clone().into();
+
         // same params enables batching
         if params == prev_params {
-            vectors_batch.push(search_query.vector.get_vector().as_slice());
+            vectors_batch.push(query);
         } else {
             // different params means different batches
             // execute what has been batched so far
@@ -425,7 +448,7 @@ fn search_in_segment(
                 vectors_batch.clear()
             }
             // start new batch for current search query
-            vectors_batch.push(search_query.vector.get_vector().as_slice());
+            vectors_batch.push(query);
             prev_params = params;
         }
     }
@@ -450,7 +473,7 @@ fn search_in_segment(
 
 fn execute_batch_search(
     segment: &LockedSegment,
-    vectors_batch: &Vec<&[VectorElementType]>,
+    vectors_batch: &Vec<QueryVector>,
     search_params: &BatchSearchParams,
     use_sampling: bool,
     total_points: usize,
@@ -487,6 +510,7 @@ fn execute_batch_search(
         let batch_len = vectors_batch.len();
         return Ok((vec![vec![]; batch_len], vec![false; batch_len]));
     }
+    let vectors_batch = &vectors_batch.iter().collect_vec();
     let res = read_segment.search_batch(
         search_params.vector_name,
         vectors_batch,
@@ -577,7 +601,7 @@ mod tests {
     use crate::collection_manager::fixtures::{
         build_test_holder, optimize_segment, random_segment,
     };
-    use crate::operations::types::SearchRequest;
+    use crate::operations::types::{CoreSearchRequest, SearchRequest};
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
     #[test]
@@ -617,8 +641,8 @@ mod tests {
 
         let query = vec![1.0, 1.0, 1.0, 1.0];
 
-        let req = SearchRequest {
-            vector: query.into(),
+        let req = CoreSearchRequest {
+            query: query.into(),
             with_payload: None,
             with_vector: None,
             filter: None,
@@ -628,7 +652,7 @@ mod tests {
             offset: 0,
         };
 
-        let batch_request = SearchRequestBatch {
+        let batch_request = CoreSearchRequestBatch {
             searches: vec![req],
         };
 
@@ -692,8 +716,8 @@ mod tests {
                 score_threshold: None,
             };
 
-            let batch_request = SearchRequestBatch {
-                searches: vec![req1, req2],
+            let batch_request = CoreSearchRequestBatch {
+                searches: vec![req1.into(), req2.into()],
             };
 
             let result_no_sampling = SegmentsSearcher::search(

commit 0e54ae7e6a7d2e4c3c816d3c1e8fd4d6385c52b0
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Oct 3 09:15:31 2023 +0200

    Bump urllib3 from 2.0.3 to 2.0.6 in /tests/storage-compat/populate_db (#2757)
    
    * Bump urllib3 from 2.0.3 to 2.0.6 in /tests/storage-compat/populate_db
    
    Bumps [urllib3](https://github.com/urllib3/urllib3) from 2.0.3 to 2.0.6.
    - [Release notes](https://github.com/urllib3/urllib3/releases)
    - [Changelog](https://github.com/urllib3/urllib3/blob/main/CHANGES.rst)
    - [Commits](https://github.com/urllib3/urllib3/compare/2.0.3...2.0.6)
    
    ---
    updated-dependencies:
    - dependency-name: urllib3
      dependency-type: direct:production
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * Fix spelling
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 171f6cf8c..28fc9c069 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -789,7 +789,7 @@ mod tests {
 
     /// Tests whether calculating the effective ef limit value is correct.
     ///
-    /// Because there was confustion about what the effective value should be for some input
+    /// Because there was confusion about what the effective value should be for some input
     /// combinations, we decided to write this tests to ensure correctness.
     ///
     /// See: <https://github.com/qdrant/qdrant/pull/1694>

commit 275320d1e657413de657a3cb79ec14c3ce53bfd5
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Sep 22 17:18:25 2023 -0300

    Expose new recommend scorer via recommend strategy (#2662)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 28fc9c069..73698eabd 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -328,14 +328,14 @@ impl SegmentsSearcher {
 pub enum SearchType {
     #[default]
     Nearest,
-    // Recommend,
+    RecommendBestScore,
 }
 
 impl From<&QueryEnum> for SearchType {
     fn from(query: &QueryEnum) -> Self {
         match query {
             QueryEnum::Nearest(_) => Self::Nearest,
-            // QueryEnum::PositiveNegative { .. } => Self::Recommend,
+            QueryEnum::RecommendBestScore(_) => Self::RecommendBestScore,
         }
     }
 }

commit 702b495911e61cb57e6b99e54becc7bf2d6ab1ee
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Thu Sep 28 11:37:18 2023 +0200

    Implement dynamic read operation fan out on local update (#2717, #2728)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 73698eabd..efdcaebae 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -150,24 +150,43 @@ impl SegmentsSearcher {
     }
 
     pub async fn search(
-        segments: &RwLock<SegmentHolder>,
+        segments: Arc<RwLock<SegmentHolder>>,
         batch_request: Arc<CoreSearchRequestBatch>,
         runtime_handle: &Handle,
         sampling_enabled: bool,
         is_stopped: Arc<AtomicBool>,
         indexing_threshold_kb: usize,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
-        // Using { } block to ensure segments variable is dropped in the end of it
-        // and is not transferred across the all_searches.await? boundary as it
-        // does not impl Send trait
+        // Do blocking calls in a blocking task: `segment.get().read()` calls might block async runtime
+        let task = {
+            let segments = segments.clone();
+
+            tokio::task::spawn_blocking(move || {
+                let segments = segments.read();
+
+                if !segments.is_empty() {
+                    let available_point_count = segments
+                        .iter()
+                        .map(|(_, segment)| segment.get().read().available_point_count())
+                        .sum();
+
+                    Some(available_point_count)
+                } else {
+                    None
+                }
+            })
+        };
+
+        let Some(available_point_count) = task.await? else {
+            return Ok(Vec::new());
+        };
+
+        // Using block to ensure `segments` variable is dropped in the end of it
         let (locked_segments, searches): (Vec<_>, Vec<_>) = {
+            // Unfortunately, we have to do `segments.read()` twice, once in blocking task
+            // and once here, due to `Send` bounds :/
             let segments = segments.read();
 
-            let some_segment = segments.iter().next();
-            if some_segment.is_none() {
-                return Ok(vec![]);
-            }
-
             // Probabilistic sampling for the `limit` parameter avoids over-fetching points from segments.
             // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.
             // With probabilistic sampling we determine a smaller sampling limit for each segment.
@@ -175,12 +194,7 @@ impl SegmentsSearcher {
             // - sampling is enabled
             // - more than 1 segment
             // - segments are not empty
-            let available_points_segments = segments
-                .iter()
-                .map(|(_, segment)| segment.get().read().available_point_count())
-                .sum();
-            let use_sampling =
-                sampling_enabled && segments.len() > 1 && available_points_segments > 0;
+            let use_sampling = sampling_enabled && segments.len() > 1 && available_point_count > 0;
 
             segments
                 .iter()
@@ -192,7 +206,7 @@ impl SegmentsSearcher {
                             search_in_segment(
                                 segment,
                                 batch_request,
-                                available_points_segments,
+                                available_point_count,
                                 use_sampling,
                                 &is_stopped_clone,
                                 indexing_threshold_kb,
@@ -203,6 +217,7 @@ impl SegmentsSearcher {
                 })
                 .unzip()
         };
+
         // perform search on all segments concurrently
         // the resulting Vec is in the same order as the segment searches were provided.
         let (all_search_results_per_segment, further_results) =
@@ -657,7 +672,7 @@ mod tests {
         };
 
         let result = SegmentsSearcher::search(
-            &segment_holder,
+            Arc::new(segment_holder),
             Arc::new(batch_request),
             &Handle::current(),
             true,
@@ -690,7 +705,7 @@ mod tests {
         let _sid1 = holder.add(segment1);
         let _sid2 = holder.add(segment2);
 
-        let segment_holder = RwLock::new(holder);
+        let segment_holder = Arc::new(RwLock::new(holder));
 
         let mut rnd = rand::thread_rng();
 
@@ -720,9 +735,11 @@ mod tests {
                 searches: vec![req1.into(), req2.into()],
             };
 
+            let batch_request = Arc::new(batch_request);
+
             let result_no_sampling = SegmentsSearcher::search(
-                &segment_holder,
-                Arc::new(batch_request.clone()),
+                segment_holder.clone(),
+                batch_request.clone(),
                 &Handle::current(),
                 false,
                 Arc::new(false.into()),
@@ -734,8 +751,8 @@ mod tests {
             assert!(!result_no_sampling.is_empty());
 
             let result_sampling = SegmentsSearcher::search(
-                &segment_holder,
-                Arc::new(batch_request),
+                segment_holder.clone(),
+                batch_request,
                 &Handle::current(),
                 true,
                 Arc::new(false.into()),

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index efdcaebae..cf9804d57 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -3,6 +3,7 @@ use std::ops::Deref;
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
+use common::types::ScoreType;
 use futures::future::try_join_all;
 use itertools::Itertools;
 use ordered_float::Float;
@@ -12,8 +13,8 @@ use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::QueryVector;
 use segment::entry::entry_point::{OperationError, SegmentEntry};
 use segment::types::{
-    Filter, Indexes, PointIdType, ScoreType, ScoredPoint, SearchParams, SegmentConfig,
-    SeqNumberType, WithPayload, WithPayloadInterface, WithVector, VECTOR_ELEMENT_SIZE,
+    Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
+    WithPayload, WithPayloadInterface, WithVector, VECTOR_ELEMENT_SIZE,
 };
 use tokio::runtime::Handle;
 use tokio::task::JoinHandle;

commit 4f983e495db72336b2311dc2abe95a11eab8c620
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Sep 29 16:23:24 2023 +0200

    Promote operation error to dedicated file (#2736)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index cf9804d57..916fbca18 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -8,10 +8,11 @@ use futures::future::try_join_all;
 use itertools::Itertools;
 use ordered_float::Float;
 use parking_lot::RwLock;
+use segment::common::operation_error::OperationError;
 use segment::common::BYTES_IN_KB;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::QueryVector;
-use segment::entry::entry_point::{OperationError, SegmentEntry};
+use segment::entry::entry_point::SegmentEntry;
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
     WithPayload, WithPayloadInterface, WithVector, VECTOR_ELEMENT_SIZE,

commit 325cac67ff4c54d553c2909fe7fb5d0c5ef04786
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Oct 4 12:00:32 2023 +0200

    Fix Clippy lints 1.73 (#2760)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 916fbca18..ccc9b2f9d 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -141,7 +141,7 @@ impl SegmentsSearcher {
                         // without sampling on that segment.
                         searches_to_rerun
                             .entry(segment_id)
-                            .or_insert_with(Vec::new)
+                            .or_default()
                             .push(batch_id);
                     }
                 }

commit 28da79223e64394ac1472461828cd0cd9bb23526
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 1 11:30:08 2023 -0400

    Add `DiscoveryRequest` and preprocessing (#2867)
    
    * add `DiscoverRequest` and batch preprocessing logic
    
    * Add description for DiscoverRequest, use serde(default)  on offset
    
    * review fixes

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index ccc9b2f9d..b74870d3b 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -346,6 +346,8 @@ pub enum SearchType {
     #[default]
     Nearest,
     RecommendBestScore,
+    Discover,
+    Context,
 }
 
 impl From<&QueryEnum> for SearchType {
@@ -353,6 +355,8 @@ impl From<&QueryEnum> for SearchType {
         match query {
             QueryEnum::Nearest(_) => Self::Nearest,
             QueryEnum::RecommendBestScore(_) => Self::RecommendBestScore,
+            QueryEnum::Discover(_) => Self::Discover,
+            QueryEnum::Context(_) => Self::Context,
         }
     }
 }

commit 816b5a7448c7f1e0d81c99e5a31219d00ece6fe5
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Nov 9 15:06:02 2023 +0100

    Shard key routing for update requests (#2909)
    
    * add shard_key into output data structures for points
    
    * fmt
    
    * add shard selector for point update operations
    
    * fix creating index without sharding
    
    * Merge serde attributes
    
    * Code review changes
    
    * review fixes
    
    * upd openapi
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index b74870d3b..2089c8be7 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -331,6 +331,7 @@ impl SegmentsSearcher {
                                 Some(selected_vectors.into())
                             }
                         },
+                        shard_key: None,
                     },
                 );
                 point_version.insert(id, version);

commit 2cfefddfd6d0870add196a1036eb63cf01499671
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sat Nov 11 17:29:49 2023 +0100

    Integrate vector into NamedVectors struct (#2966)
    
    * Integrate vector into NamedVectors struct
    
    * revert into_default_vector
    
    * remove unnecessary functions
    
    * remove unnecessary functions
    
    * remove unneccesary function
    
    * remove unnecessary match
    
    * remove matches
    
    * revert preprocess signature
    
    * remove unnecessary functions

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 2089c8be7..bdc19f240 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -325,7 +325,7 @@ impl SegmentsSearcher {
                                 let mut selected_vectors = NamedVectors::default();
                                 for vector_name in vector_names {
                                     if let Some(vector) = segment.vector(vector_name, id)? {
-                                        selected_vectors.insert(vector_name.into(), vector);
+                                        selected_vectors.insert(vector_name.into(), vector.into());
                                     }
                                 }
                                 Some(selected_vectors.into())

commit 2810672598fcba5aac80077daf469791475d1b5e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 14 16:47:05 2023 +0100

    Huge refactoring to make read requests aware of shard key selector (#3004)
    
    * huge refactoring to make read requests avare of shard key selector
    
    * fix integration test
    
    * review fixes
    
    * allow lookup_from specific shards

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index bdc19f240..91b20ba6a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -623,7 +623,7 @@ mod tests {
     use crate::collection_manager::fixtures::{
         build_test_holder, optimize_segment, random_segment,
     };
-    use crate::operations::types::{CoreSearchRequest, SearchRequest};
+    use crate::operations::types::{CoreSearchRequest, SearchRequestInternal};
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
     #[test]
@@ -717,7 +717,7 @@ mod tests {
         let mut rnd = rand::thread_rng();
 
         for _ in 0..100 {
-            let req1 = SearchRequest {
+            let req1 = SearchRequestInternal {
                 vector: random_vector(&mut rnd, 4).into(),
                 limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING
                 offset: 0,
@@ -727,7 +727,7 @@ mod tests {
                 params: None,
                 score_threshold: None,
             };
-            let req2 = SearchRequest {
+            let req2 = SearchRequestInternal {
                 vector: random_vector(&mut rnd, 4).into(),
                 limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING
                 offset: 0,

commit 13f15955fcc5920aab21c3e1d5a2a81794f3e299
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Tue Nov 21 09:18:15 2023 +0100

    Sparse vectors rest search and upsert (#3051)
    
    * sparse vector sparse search and upsert
    
    are you happy fmt
    
    fix build
    
    update openapi
    
    batch changes
    
    update openapi
    
    named sparse vector
    
    * review remarks
    
    * cowvalue to cowvector

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 91b20ba6a..2b09c2f77 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -325,7 +325,7 @@ impl SegmentsSearcher {
                                 let mut selected_vectors = NamedVectors::default();
                                 for vector_name in vector_names {
                                     if let Some(vector) = segment.vector(vector_name, id)? {
-                                        selected_vectors.insert(vector_name.into(), vector.into());
+                                        selected_vectors.insert(vector_name.into(), vector);
                                     }
                                 }
                                 Some(selected_vectors.into())

commit 3fd3ff215aefede19b7f6ce566f7680b4b53dac3
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Nov 22 15:05:54 2023 -0300

    refactor: turn offset into an option (#3082)
    
    * refactor: make offset optional
    
    * update openapi
    
    * add simple test

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 2b09c2f77..0c84d35c7 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -720,7 +720,7 @@ mod tests {
             let req1 = SearchRequestInternal {
                 vector: random_vector(&mut rnd, 4).into(),
                 limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING
-                offset: 0,
+                offset: None,
                 with_payload: None,
                 with_vector: None,
                 filter: None,
@@ -730,7 +730,7 @@ mod tests {
             let req2 = SearchRequestInternal {
                 vector: random_vector(&mut rnd, 4).into(),
                 limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING
-                offset: 0,
+                offset: None,
                 filter: None,
                 params: None,
                 with_payload: None,

commit 3fc1f9656418995d21d156bd83f6f3611a99ee96
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri Dec 1 13:10:58 2023 +0100

    Sparse index segment and collection config (#2802)
    
    * quantization storage as separate entity
    
    sparse index try to extend segment types
    
    fix build
    
    fix async scorer
    
    codespell
    
    update openapi
    
    update vector index
    
    remove code duplications
    
    more fixes
    
    more fixes
    
    fix build
    
    fix deserialization test
    
    remove transform_into
    
    are you happy clippy
    
    update openapi
    
    update openapi
    
    are you happy clippy
    
    fix build
    
    optional serialize
    
    more defaults
    
    update openapi
    
    fix comments
    
    generic transpose_map_into_named_vector
    
    rename fields in tests
    
    remove obsolete parts
    
    only named sparse config
    
    VectorStruct without unnamed sparse
    
    NamedVectorStruct without unnamed sparse
    
    remove obsolete test
    
    update openapi
    
    mmap index
    
    revert preprocess function
    
    are you happy fmt
    
    update openapi
    
    fix build
    
    fix tests
    
    are you happy fmt
    
    fix for client generation
    
    fix sparse segment creation
    
    fix basic sparse test
    
    fix conflicts
    
    remove obsolete convertion
    
    fix build
    
    config diffs
    
    update openapi
    
    review remarks
    
    update openapi
    
    fix batch upsert
    
    add failing test showing bad ids matching
    
    fix sparse vector insertion
    
    remove on_disk flag
    
    update openapi
    
    revert debug assert
    
    simplify conversions
    
    update openapi
    
    remove on disk storage flag
    
    update openapi
    
    default for vector config
    
    update openapi comment
    
    remove diffs
    
    update openapi
    
    * enable consensus test
    
    * add comment
    
    * update openapi

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 0c84d35c7..68fadfa2d 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -567,6 +567,7 @@ fn is_search_optimized(
         .get(vector_name)
         .ok_or_else(vector_name_error)?;
 
+    // TODO(sparse) do we need some sparse vector check here?
     let vector_size = segment
         .config()
         .vector_data

commit 7f7e42b804f0051d7032acf5edbc545728032476
Author: Di Zhao <di.zhao@gmail.com>
Date:   Mon Dec 4 14:18:25 2023 -0800

    make indexed_only search threshold more lenient (#3155)
    
    * make indexed_only more lenient to use max(indexing_threshold,
    full_scan_threshold) as the threshold to ignore search on un-indexed
    vectors. This way we avoid point disappearing from search when hnsw index is
    being built but still have the protection of indexed_only
    
    * format
    
    ---------
    
    Co-authored-by: Di Zhao <diz@twitter.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 68fadfa2d..5a21dbaa1 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -157,7 +157,7 @@ impl SegmentsSearcher {
         runtime_handle: &Handle,
         sampling_enabled: bool,
         is_stopped: Arc<AtomicBool>,
-        indexing_threshold_kb: usize,
+        search_optimized_threshold_kb: usize,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         // Do blocking calls in a blocking task: `segment.get().read()` calls might block async runtime
         let task = {
@@ -211,7 +211,7 @@ impl SegmentsSearcher {
                                 available_point_count,
                                 use_sampling,
                                 &is_stopped_clone,
-                                indexing_threshold_kb,
+                                search_optimized_threshold_kb,
                             )
                         }
                     });
@@ -261,7 +261,7 @@ impl SegmentsSearcher {
                             0,
                             false,
                             &is_stopped_clone,
-                            indexing_threshold_kb,
+                            search_optimized_threshold_kb,
                         )
                     }))
                 }
@@ -422,7 +422,7 @@ fn search_in_segment(
     total_points: usize,
     use_sampling: bool,
     is_stopped: &AtomicBool,
-    indexing_threshold_kb: usize,
+    search_optimized_threshold_kb: usize,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -463,7 +463,7 @@ fn search_in_segment(
                     use_sampling,
                     total_points,
                     is_stopped,
-                    indexing_threshold_kb,
+                    search_optimized_threshold_kb,
                 )?;
                 further_results.append(&mut further);
                 result.append(&mut res);
@@ -484,7 +484,7 @@ fn search_in_segment(
             use_sampling,
             total_points,
             is_stopped,
-            indexing_threshold_kb,
+            search_optimized_threshold_kb,
         )?;
         further_results.append(&mut further);
         result.append(&mut res);
@@ -500,7 +500,7 @@ fn execute_batch_search(
     use_sampling: bool,
     total_points: usize,
     is_stopped: &AtomicBool,
-    indexing_threshold_kb: usize,
+    search_optimized_threshold_kb: usize,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let locked_segment = segment.get();
     let read_segment = locked_segment.read();
@@ -525,7 +525,7 @@ fn execute_batch_search(
     if ignore_plain_index
         && !is_search_optimized(
             read_segment.deref(),
-            indexing_threshold_kb,
+            search_optimized_threshold_kb,
             search_params.vector_name,
         )?
     {
@@ -555,7 +555,7 @@ fn execute_batch_search(
 /// Check if the segment is indexed enough to be searched with `indexed_only` parameter
 fn is_search_optimized(
     segment: &dyn SegmentEntry,
-    indexing_threshold_kb: usize,
+    search_optimized_threshold_kb: usize,
     vector_name: &str,
 ) -> CollectionResult<bool> {
     let segment_info = segment.info();
@@ -583,7 +583,7 @@ fn is_search_optimized(
 
     let unindexed_volume = vector_size_bytes.saturating_mul(unindexed_vectors);
 
-    let indexing_threshold_bytes = indexing_threshold_kb * BYTES_IN_KB;
+    let indexing_threshold_bytes = search_optimized_threshold_kb * BYTES_IN_KB;
 
     // Examples:
     // Threshold = 20_000 Kb

commit 3889516650693bfa3e7709d71a86878c399dd31d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Dec 5 21:29:19 2023 +0100

    Clean two sparse vectors todos (#3163)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 5a21dbaa1..69b405abd 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -567,7 +567,7 @@ fn is_search_optimized(
         .get(vector_name)
         .ok_or_else(vector_name_error)?;
 
-    // TODO(sparse) do we need some sparse vector check here?
+    // check only dense vectors because sparse vectors are always indexed
     let vector_size = segment
         .config()
         .vector_data

commit 11ebb5d8a7e0cd8afcb78794b184a004de06380b
Author: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
Date:   Tue Mar 5 10:38:41 2024 +0100

    Bump mio from 0.8.9 to 0.8.11 (#3771)
    
    * Bump mio from 0.8.9 to 0.8.11
    
    Bumps [mio](https://github.com/tokio-rs/mio) from 0.8.9 to 0.8.11.
    - [Release notes](https://github.com/tokio-rs/mio/releases)
    - [Changelog](https://github.com/tokio-rs/mio/blob/master/CHANGELOG.md)
    - [Commits](https://github.com/tokio-rs/mio/compare/v0.8.9...v0.8.11)
    
    ---
    updated-dependencies:
    - dependency-name: mio
      dependency-type: indirect
    ...
    
    Signed-off-by: dependabot[bot] <support@github.com>
    
    * Resolve clippy warnings
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 69b405abd..60797a890 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -495,7 +495,7 @@ fn search_in_segment(
 
 fn execute_batch_search(
     segment: &LockedSegment,
-    vectors_batch: &Vec<QueryVector>,
+    vectors_batch: &[QueryVector],
     search_params: &BatchSearchParams,
     use_sampling: bool,
     total_points: usize,

commit 24127fa693d472522cd6114059607ea659ff72f7
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Jan 12 12:20:53 2024 -0300

    Disable large limit optimization for plain indices (#3387)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 60797a890..dc6b3edb2 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -388,7 +388,11 @@ fn sampling_limit(
     let poisson_sampling =
         find_search_sampling_over_point_distribution(limit as f64, segment_probability)
             .unwrap_or(limit);
-    let effective = effective_limit(limit, ef_limit.unwrap_or(0), poisson_sampling);
+
+    // if no ef_limit was found, it is a plain index => sampling optimization is not needed.
+    let effective = ef_limit.map_or(limit, |ef_limit| {
+        effective_limit(limit, ef_limit, poisson_sampling)
+    });
     log::trace!("sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
     effective
 }
@@ -799,7 +803,7 @@ mod tests {
 
     #[test]
     fn test_sampling_limit() {
-        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 30);
+        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);
     }
 
     #[test]

commit 320b7f2621f08d08fa6fbd1e8f82a277610af81c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Sun Feb 4 14:46:22 2024 -0300

    `order_by` in scroll (#3493)
    
    * first PR implementation (#2865)
    
    - fetch offset id
    - restructure tests
    - only let order_by with numeric
    - introduce order_by interface
    
    cargo fmt
    
    update openapi
    
    calculate range to fetch using offset + limit, do some cleanup
    
    enable index validation, fix test
    
    Fix pagination
    
    add e2e tests
    
    make test a little more strict
    
    select numeric index on read_ordered_filtered
    
    add filtering test 🫨
    
    fix filtering on order-by
    
    fix pip requirements
    
    add grpc interface, make read_ordered_filtered fallible
    
    fmt
    
    small optimization of `with_payload` and `with_vector`
    
    refactor common logic of point_ops and local_shard_operations
    
    Make filtering test harder and fix limit for worst case
    
    update openapi
    
    small clarity refactor
    
    avoid extra allocation when sorting with offset
    
    stream from numeric index btree instead of calculating range
    
    use payload to store order-by value, instead of modifying Record interface
    
    various fixes:
    - fix ordering at collection level, when merging shard results
    - fix offset at segment level, to take into account also value offset
    - make rust tests pass
    
    remove unused histogram changes
    
    fix error messages and make has_range_index exhaustive
    
    remove unused From impl
    
    Move OrderBy and Direction to segment::data_types::order_by
    
    Refactor normal scroll_by in local_shard_operations.rs
    
    More cleanup + rename OrderableRead to StreamWithValue
    
    empty commit
    
    optimization for merging results from shards and segments
    
    fix case of multi-valued fields
    
    fix IntegerIndexParams name after rebase
    
    precompute offset key
    
    use extracted `read_by_id_stream`
    
    Expose value_offset to user
    - rename offset -> value_offset
    - extract offset value fetching logic
    
    * remove offset functionality when using order_by
    
    * include order_by in ForwardProxyShard
    
    * extra nits
    
    * remove histogram changes
    
    * more nits
    
    * self review
    
    * resolve conflicts after rebase, not enable order-by with datetime index schema
    
    * make grpc start_from value extendable
    
    * gen grpc docs
    
    ---------
    
    Co-authored-by: kwkr <kawka.maciej.93@gmail.com>
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index dc6b3edb2..2c2ed1827 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -338,7 +338,14 @@ impl SegmentsSearcher {
             }
             Ok(true)
         })?;
-        Ok(point_records.into_values().collect())
+
+        // Restore the order the ids came in
+        let ordered_records = points
+            .iter()
+            .filter_map(|point| point_records.get(point).cloned())
+            .collect();
+
+        Ok(ordered_records)
     }
 }
 

commit db5399f9e47cfe9d740645ec2f27e8751444882b
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Mar 18 13:31:55 2024 +0100

    Use rest vector type as non segment part (#3829)
    
    * use rest vector type as non-segment part
    
    * add todo
    
    * switch into -> from
    
    * review remarks
    
    * review remarks

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 2c2ed1827..3b9228e5c 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -11,7 +11,7 @@ use parking_lot::RwLock;
 use segment::common::operation_error::OperationError;
 use segment::common::BYTES_IN_KB;
 use segment::data_types::named_vectors::NamedVectors;
-use segment::data_types::vectors::QueryVector;
+use segment::data_types::vectors::{QueryVector, VectorStruct};
 use segment::entry::entry_point::SegmentEntry;
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
@@ -318,18 +318,21 @@ impl SegmentsSearcher {
                         } else {
                             None
                         },
-                        vector: match with_vector {
-                            WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
-                            WithVector::Bool(false) => None,
-                            WithVector::Selector(vector_names) => {
-                                let mut selected_vectors = NamedVectors::default();
-                                for vector_name in vector_names {
-                                    if let Some(vector) = segment.vector(vector_name, id)? {
-                                        selected_vectors.insert(vector_name.into(), vector);
+                        vector: {
+                            let vector: Option<VectorStruct> = match with_vector {
+                                WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
+                                WithVector::Bool(false) => None,
+                                WithVector::Selector(vector_names) => {
+                                    let mut selected_vectors = NamedVectors::default();
+                                    for vector_name in vector_names {
+                                        if let Some(vector) = segment.vector(vector_name, id)? {
+                                            selected_vectors.insert(vector_name.into(), vector);
+                                        }
                                     }
+                                    Some(selected_vectors.into())
                                 }
-                                Some(selected_vectors.into())
-                            }
+                            };
+                            vector.map(Into::into)
                         },
                         shard_key: None,
                     },

commit 41c817c2a16f270dcab376e94b2ec0c5e7d8f149
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 4 10:52:59 2024 +0200

    Non-blocking snapshots (#3420)
    
    * Initial non-blocking snapshot implementation
    
    * Minor refactoring
    
    * Add some comments, improve log messages
    
    * Propagate proxy segment changes into wrapped segment when unproxying
    
    * Use upgradable read lock for propagating proxy segment changes
    
    * Extract proxy/unproxy functions for segments, better error handling
    
    * Don't stop early on error, always clean up proxied segments
    
    * Propagate proxy changes in two batches to minimize write locking
    
    * Use upgradable read lock when propagating proxy changes in two batches
    
    * Do not fall back to non-appendable segment configurations
    
    * Resolve remaining TODOs
    
    * Use LockedSegmentHolder type alias everywhere
    
    * Better state handling in method to proxy all segments
    
    * When proxying all segments, lock only after creating temporary segment
    
    * Pass actual proxied segments around to minimize segment holder locking
    
    * Propagate proxy segment changes to wrapped on drop, not to writable
    
    * Minor improvements
    
    * Fix proxy logic returning non-proxied segments
    
    * Share single segment holder lock and upgrade/downgrade it
    
    * Minor improvements
    
    * Make appendable segment check more efficient
    
    * Do not explicitly drop segments lock, it's not necessary
    
    * Add consensus test to assert data consistency while snapshotting
    
    * Fix incorrect documentation
    
    * Extract payload storage type decision logic to collection params function
    
    * Resolve TODO, we always expect to get a shard here
    
    * Only upgrade propagate to wrapped readers if lists are not empty
    
    * Set correct operation versions
    
    * review fixes
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 3b9228e5c..c56246848 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -20,6 +20,7 @@ use segment::types::{
 use tokio::runtime::Handle;
 use tokio::task::JoinHandle;
 
+use super::holders::segment_holder::LockedSegmentHolder;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
@@ -152,7 +153,7 @@ impl SegmentsSearcher {
     }
 
     pub async fn search(
-        segments: Arc<RwLock<SegmentHolder>>,
+        segments: LockedSegmentHolder,
         batch_request: Arc<CoreSearchRequestBatch>,
         runtime_handle: &Handle,
         sampling_enabled: bool,

commit 9c08b426e24d32ec07cc79e4545482cae5ca17c8
Author: Tim Visée <tim+github@visee.me>
Date:   Wed Apr 10 10:42:58 2024 +0200

    On read operations, go over non-appendable segments first (#3996)
    
    * On read operations, go over non-appendable segments first
    
    * Read segments in two "phases" (first non-appendable, then appendable) during read operations
    
    * Resolve clippy warnings
    
    * Collect non-appendable and appendable segments in single pass
    
    * Minor cleanup
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index c56246848..e01a0e3a0 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -167,16 +167,16 @@ impl SegmentsSearcher {
             tokio::task::spawn_blocking(move || {
                 let segments = segments.read();
 
-                if !segments.is_empty() {
-                    let available_point_count = segments
-                        .iter()
-                        .map(|(_, segment)| segment.get().read().available_point_count())
-                        .sum();
-
-                    Some(available_point_count)
-                } else {
-                    None
+                if segments.is_empty() {
+                    return None;
                 }
+
+                let segments = segments.non_appendable_then_appendable_segments();
+                let available_point_count = segments
+                    .into_iter()
+                    .map(|segment| segment.get().read().available_point_count())
+                    .sum();
+                Some(available_point_count)
             })
         };
 
@@ -189,6 +189,7 @@ impl SegmentsSearcher {
             // Unfortunately, we have to do `segments.read()` twice, once in blocking task
             // and once here, due to `Send` bounds :/
             let segments = segments.read();
+            let segments = segments.non_appendable_then_appendable_segments();
 
             // Probabilistic sampling for the `limit` parameter avoids over-fetching points from segments.
             // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.
@@ -200,8 +201,8 @@ impl SegmentsSearcher {
             let use_sampling = sampling_enabled && segments.len() > 1 && available_point_count > 0;
 
             segments
-                .iter()
-                .map(|(_id, segment)| {
+                .into_iter()
+                .map(|segment| {
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         let is_stopped_clone = is_stopped.clone();

commit e54ab8a636ecbfa3fe70f85fce1058ce655099fb
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Thu Apr 11 13:16:56 2024 +0200

    Fix indexed-only behavior for proxy shard (#3998)
    
    * move check for unindexed segment size inside the segment to allow proxy shard decide where to search better
    
    * fmt
    
    * move indexed_only check inside the plain index

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index e01a0e3a0..522b2cf42 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,5 +1,4 @@
 use std::collections::HashMap;
-use std::ops::Deref;
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
@@ -9,13 +8,11 @@ use itertools::Itertools;
 use ordered_float::Float;
 use parking_lot::RwLock;
 use segment::common::operation_error::OperationError;
-use segment::common::BYTES_IN_KB;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::vectors::{QueryVector, VectorStruct};
-use segment::entry::entry_point::SegmentEntry;
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
-    WithPayload, WithPayloadInterface, WithVector, VECTOR_ELEMENT_SIZE,
+    WithPayload, WithPayloadInterface, WithVector,
 };
 use tokio::runtime::Handle;
 use tokio::task::JoinHandle;
@@ -24,9 +21,7 @@ use super::holders::segment_holder::LockedSegmentHolder;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
-use crate::operations::types::{
-    CollectionError, CollectionResult, CoreSearchRequestBatch, QueryEnum, Record,
-};
+use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, QueryEnum, Record};
 
 type BatchOffset = usize;
 type SegmentOffset = usize;
@@ -534,20 +529,6 @@ fn execute_batch_search(
         search_params.top
     };
 
-    let ignore_plain_index = search_params
-        .params
-        .map(|p| p.indexed_only)
-        .unwrap_or(false);
-    if ignore_plain_index
-        && !is_search_optimized(
-            read_segment.deref(),
-            search_optimized_threshold_kb,
-            search_params.vector_name,
-        )?
-    {
-        let batch_len = vectors_batch.len();
-        return Ok((vec![vec![]; batch_len], vec![false; batch_len]));
-    }
     let vectors_batch = &vectors_batch.iter().collect_vec();
     let res = read_segment.search_batch(
         search_params.vector_name,
@@ -558,6 +539,7 @@ fn execute_batch_search(
         top,
         search_params.params,
         is_stopped,
+        search_optimized_threshold_kb,
     )?;
 
     let further_results = res
@@ -568,54 +550,6 @@ fn execute_batch_search(
     Ok((res, further_results))
 }
 
-/// Check if the segment is indexed enough to be searched with `indexed_only` parameter
-fn is_search_optimized(
-    segment: &dyn SegmentEntry,
-    search_optimized_threshold_kb: usize,
-    vector_name: &str,
-) -> CollectionResult<bool> {
-    let segment_info = segment.info();
-    let vector_name_error =
-        || CollectionError::bad_request(format!("Vector {} doesn't exist", vector_name));
-
-    let vector_data_info = segment_info
-        .vector_data
-        .get(vector_name)
-        .ok_or_else(vector_name_error)?;
-
-    // check only dense vectors because sparse vectors are always indexed
-    let vector_size = segment
-        .config()
-        .vector_data
-        .get(vector_name)
-        .ok_or_else(vector_name_error)?
-        .size;
-
-    let vector_size_bytes = vector_size * VECTOR_ELEMENT_SIZE;
-
-    let unindexed_vectors = vector_data_info
-        .num_vectors
-        .saturating_sub(vector_data_info.num_indexed_vectors);
-
-    let unindexed_volume = vector_size_bytes.saturating_mul(unindexed_vectors);
-
-    let indexing_threshold_bytes = search_optimized_threshold_kb * BYTES_IN_KB;
-
-    // Examples:
-    // Threshold = 20_000 Kb
-    // Indexed vectors: 100000
-    // Total vectors: 100010
-    // unindexed_volume = 100010 - 100000 = 10
-    // Result: true
-
-    // Threshold = 20_000 Kb
-    // Indexed vectors: 0
-    // Total vectors: 100000
-    // unindexed_volume = 100000
-    // Result: false
-    Ok(unindexed_volume < indexing_threshold_bytes)
-}
-
 /// Find the HNSW ef_construct for a named vector
 ///
 /// If the given named vector has no HNSW index, `None` is returned.
@@ -632,14 +566,15 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &str) -> Option<us
 
 #[cfg(test)]
 mod tests {
+    use std::collections::HashSet;
+
     use segment::fixtures::index_fixtures::random_vector;
-    use segment::types::SegmentType;
+    use segment::index::VectorIndexEnum;
+    use segment::types::{Condition, HasIdCondition};
     use tempfile::Builder;
 
     use super::*;
-    use crate::collection_manager::fixtures::{
-        build_test_holder, optimize_segment, random_segment,
-    };
+    use crate::collection_manager::fixtures::{build_test_holder, random_segment};
     use crate::operations::types::{CoreSearchRequest, SearchRequestInternal};
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
@@ -649,27 +584,27 @@ mod tests {
 
         let segment1 = random_segment(dir.path(), 10, 200, 256);
 
-        let res_1 = is_search_optimized(&segment1, 25, "").unwrap();
-
-        assert!(!res_1);
-
-        let res_2 = is_search_optimized(&segment1, 225, "").unwrap();
+        let vector_index = segment1.vector_data.get("").unwrap().vector_index.clone();
 
-        assert!(res_2);
+        let vector_index_borrow = vector_index.borrow();
 
-        let indexed_segment = optimize_segment(segment1);
+        match &*vector_index_borrow {
+            VectorIndexEnum::Plain(plain_index) => {
+                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None);
+                assert!(!res_1);
 
-        let indexed_segment_get = indexed_segment.get();
-        let indexed_segment_read = indexed_segment_get.read();
+                let res_2 = plain_index.is_small_enough_for_unindexed_search(225, None);
+                assert!(res_2);
 
-        assert_eq!(
-            indexed_segment_read.info().segment_type,
-            SegmentType::Indexed
-        );
+                let ids: HashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();
 
-        let res_3 = is_search_optimized(indexed_segment_read.deref(), 25, "").unwrap();
+                let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));
 
-        assert!(res_3);
+                let res_3 = plain_index.is_small_enough_for_unindexed_search(25, Some(&ids_filter));
+                assert!(res_3);
+            }
+            _ => panic!("Expected plain index"),
+        }
     }
 
     #[tokio::test]

commit 3862b075ba54f1acd09489fdf54b651fca2360bf
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Apr 17 16:36:40 2024 +0200

    refactor segment holder to separate appendable and non-appendable seg… (#4053)
    
    * refactor segment holder to separate appendable and non-appendable segments in advance
    
    * Minor refactoring
    
    * Remove itertools for just collecting into Vec
    
    * remove _insert method in favor of add_locked
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 522b2cf42..02c813f75 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -168,7 +168,6 @@ impl SegmentsSearcher {
 
                 let segments = segments.non_appendable_then_appendable_segments();
                 let available_point_count = segments
-                    .into_iter()
                     .map(|segment| segment.get().read().available_point_count())
                     .sum();
                 Some(available_point_count)
@@ -183,8 +182,8 @@ impl SegmentsSearcher {
         let (locked_segments, searches): (Vec<_>, Vec<_>) = {
             // Unfortunately, we have to do `segments.read()` twice, once in blocking task
             // and once here, due to `Send` bounds :/
-            let segments = segments.read();
-            let segments = segments.non_appendable_then_appendable_segments();
+            let segments_lock = segments.read();
+            let segments = segments_lock.non_appendable_then_appendable_segments();
 
             // Probabilistic sampling for the `limit` parameter avoids over-fetching points from segments.
             // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.
@@ -193,10 +192,10 @@ impl SegmentsSearcher {
             // - sampling is enabled
             // - more than 1 segment
             // - segments are not empty
-            let use_sampling = sampling_enabled && segments.len() > 1 && available_point_count > 0;
+            let use_sampling =
+                sampling_enabled && segments_lock.len() > 1 && available_point_count > 0;
 
             segments
-                .into_iter()
                 .map(|segment| {
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());

commit 896cfe109d9a6dd5a9a4ab39422899d6d238a5c6
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 29 14:54:14 2024 +0200

    Sparse idf dot (#4126)
    
    * introduce QueryContext, which accumulates runtime info needed for executing search
    
    * fmt
    
    * propagate query context into segment internals
    
    * [WIP] prepare idf stats for search query context
    
    * Split SparseVector and RemmapedSparseVector to guarantee we will not mix them up on the type level
    
    * implement filling of the query context with IDF statistics
    
    * implement re-weighting of the sparse query with idf
    
    * fmt
    
    * update idf param only if explicitly specified (more consistent with diff param update
    
    * replace idf bool with modifier enum, improve further extensibility
    
    * test and fixes
    
    * Update lib/collection/src/operations/types.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    * review fixes
    
    * fmt
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 02c813f75..a4c94f81d 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -9,11 +9,13 @@ use ordered_float::Float;
 use parking_lot::RwLock;
 use segment::common::operation_error::OperationError;
 use segment::data_types::named_vectors::NamedVectors;
+use segment::data_types::query_context::QueryContext;
 use segment::data_types::vectors::{QueryVector, VectorStruct};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
     WithPayload, WithPayloadInterface, WithVector,
 };
+use tinyvec::TinyVec;
 use tokio::runtime::Handle;
 use tokio::task::JoinHandle;
 
@@ -21,7 +23,10 @@ use super::holders::segment_holder::LockedSegmentHolder;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
-use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, QueryEnum, Record};
+use crate::config::CollectionConfig;
+use crate::operations::query_enum::QueryEnum;
+use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, Modifier, Record};
+use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
 type BatchOffset = usize;
 type SegmentOffset = usize;
@@ -147,14 +152,49 @@ impl SegmentsSearcher {
         (result_aggregator, searches_to_rerun)
     }
 
-    pub async fn search(
+    pub async fn prepare_query_context(
         segments: LockedSegmentHolder,
-        batch_request: Arc<CoreSearchRequestBatch>,
-        runtime_handle: &Handle,
-        sampling_enabled: bool,
-        is_stopped: Arc<AtomicBool>,
-        search_optimized_threshold_kb: usize,
-    ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
+        batch_request: &CoreSearchRequestBatch,
+        collection_config: &CollectionConfig,
+    ) -> CollectionResult<Option<QueryContext>> {
+        let indexing_threshold_kb = collection_config
+            .optimizer_config
+            .indexing_threshold
+            .unwrap_or(DEFAULT_INDEXING_THRESHOLD_KB);
+        let full_scan_threshold_kb = collection_config.hnsw_config.full_scan_threshold;
+
+        const DEFAULT_CAPACITY: usize = 3;
+        let mut idf_vectors: TinyVec<[&str; DEFAULT_CAPACITY]> = Default::default();
+
+        // check vector names existing
+        for req in &batch_request.searches {
+            let vector_name = req.query.get_vector_name();
+            collection_config.params.get_distance(vector_name)?;
+            if let Some(sparse_vector_params) = collection_config
+                .params
+                .get_sparse_vector_params_opt(vector_name)
+            {
+                if sparse_vector_params.modifier == Some(Modifier::Idf)
+                    && !idf_vectors.contains(&vector_name)
+                {
+                    idf_vectors.push(vector_name);
+                }
+            }
+        }
+
+        let mut query_context =
+            QueryContext::new(indexing_threshold_kb.max(full_scan_threshold_kb));
+
+        for search_request in &batch_request.searches {
+            search_request
+                .query
+                .iterate_sparse(|vector_name, sparse_vector| {
+                    if idf_vectors.contains(&vector_name) {
+                        query_context.init_idf(vector_name, &sparse_vector.indices);
+                    }
+                })
+        }
+
         // Do blocking calls in a blocking task: `segment.get().read()` calls might block async runtime
         let task = {
             let segments = segments.clone();
@@ -167,16 +207,27 @@ impl SegmentsSearcher {
                 }
 
                 let segments = segments.non_appendable_then_appendable_segments();
-                let available_point_count = segments
-                    .map(|segment| segment.get().read().available_point_count())
-                    .sum();
-                Some(available_point_count)
+                for locked_segment in segments {
+                    let segment = locked_segment.get();
+                    let segment_guard = segment.read();
+                    segment_guard.fill_query_context(&mut query_context);
+                }
+                Some(query_context)
             })
         };
 
-        let Some(available_point_count) = task.await? else {
-            return Ok(Vec::new());
-        };
+        Ok(task.await?)
+    }
+
+    pub async fn search(
+        segments: LockedSegmentHolder,
+        batch_request: Arc<CoreSearchRequestBatch>,
+        runtime_handle: &Handle,
+        sampling_enabled: bool,
+        is_stopped: Arc<AtomicBool>,
+        query_context: QueryContext,
+    ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
+        let query_context_acr = Arc::new(query_context);
 
         // Using block to ensure `segments` variable is dropped in the end of it
         let (locked_segments, searches): (Vec<_>, Vec<_>) = {
@@ -192,11 +243,13 @@ impl SegmentsSearcher {
             // - sampling is enabled
             // - more than 1 segment
             // - segments are not empty
-            let use_sampling =
-                sampling_enabled && segments_lock.len() > 1 && available_point_count > 0;
+            let use_sampling = sampling_enabled
+                && segments_lock.len() > 1
+                && query_context_acr.available_point_count() > 0;
 
             segments
                 .map(|segment| {
+                    let query_context_arc_segment = query_context_acr.clone();
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         let is_stopped_clone = is_stopped.clone();
@@ -204,10 +257,9 @@ impl SegmentsSearcher {
                             search_in_segment(
                                 segment,
                                 batch_request,
-                                available_point_count,
                                 use_sampling,
                                 &is_stopped_clone,
-                                search_optimized_threshold_kb,
+                                query_context_arc_segment,
                             )
                         }
                     });
@@ -242,6 +294,7 @@ impl SegmentsSearcher {
             let secondary_searches: Vec<_> = {
                 let mut res = vec![];
                 for (segment_id, batch_ids) in searches_to_rerun.iter() {
+                    let query_context_arc_segment = query_context_acr.clone();
                     let segment = locked_segments[*segment_id].clone();
                     let partial_batch_request = Arc::new(CoreSearchRequestBatch {
                         searches: batch_ids
@@ -254,10 +307,9 @@ impl SegmentsSearcher {
                         search_in_segment(
                             segment,
                             partial_batch_request,
-                            0,
                             false,
                             &is_stopped_clone,
-                            search_optimized_threshold_kb,
+                            query_context_arc_segment,
                         )
                     }))
                 }
@@ -429,10 +481,9 @@ fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> us
 fn search_in_segment(
     segment: LockedSegment,
     request: Arc<CoreSearchRequestBatch>,
-    total_points: usize,
     use_sampling: bool,
     is_stopped: &AtomicBool,
-    search_optimized_threshold_kb: usize,
+    query_context: Arc<QueryContext>,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -471,9 +522,8 @@ fn search_in_segment(
                     &vectors_batch,
                     &prev_params,
                     use_sampling,
-                    total_points,
                     is_stopped,
-                    search_optimized_threshold_kb,
+                    &query_context,
                 )?;
                 further_results.append(&mut further);
                 result.append(&mut res);
@@ -492,9 +542,8 @@ fn search_in_segment(
             &vectors_batch,
             &prev_params,
             use_sampling,
-            total_points,
             is_stopped,
-            search_optimized_threshold_kb,
+            &query_context,
         )?;
         further_results.append(&mut further);
         result.append(&mut res);
@@ -508,9 +557,8 @@ fn execute_batch_search(
     vectors_batch: &[QueryVector],
     search_params: &BatchSearchParams,
     use_sampling: bool,
-    total_points: usize,
     is_stopped: &AtomicBool,
-    search_optimized_threshold_kb: usize,
+    query_context: &QueryContext,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let locked_segment = segment.get();
     let read_segment = locked_segment.read();
@@ -523,7 +571,12 @@ fn execute_batch_search(
             .params
             .and_then(|p| p.hnsw_ef)
             .or_else(|| get_hnsw_ef_construct(segment_config, search_params.vector_name));
-        sampling_limit(search_params.top, ef_limit, segment_points, total_points)
+        sampling_limit(
+            search_params.top,
+            ef_limit,
+            segment_points,
+            query_context.available_point_count(),
+        )
     } else {
         search_params.top
     };
@@ -538,7 +591,7 @@ fn execute_batch_search(
         top,
         search_params.params,
         is_stopped,
-        search_optimized_threshold_kb,
+        query_context,
     )?;
 
     let further_results = res
@@ -635,7 +688,7 @@ mod tests {
             &Handle::current(),
             true,
             Arc::new(AtomicBool::new(false)),
-            DEFAULT_INDEXING_THRESHOLD_KB,
+            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
         )
         .await
         .unwrap()
@@ -701,7 +754,7 @@ mod tests {
                 &Handle::current(),
                 false,
                 Arc::new(false.into()),
-                DEFAULT_INDEXING_THRESHOLD_KB,
+                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
             )
             .await
             .unwrap();
@@ -714,7 +767,7 @@ mod tests {
                 &Handle::current(),
                 true,
                 Arc::new(false.into()),
-                DEFAULT_INDEXING_THRESHOLD_KB,
+                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
             )
             .await
             .unwrap();

commit e663f8aa8710ad6e5f9c22c151617be7ac0ac6be
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 6 11:51:50 2024 +0200

    Faster deleted filter in proxy segments (#4148)
    
    * [WIP] introduce internal has-id check
    
    * fmt
    
    * update value of the deleted_mask in proxy
    
    * use deleted_points from the context, if present
    
    * fmt
    
    * move stopped flag into query context
    
    * fmt
    
    * segment-specific query context
    
    * enable custom deleted mask in proxy
    
    * remove unused HasIdConditionInternal
    
    * fix tests
    
    * remove debug

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index a4c94f81d..12c79b8f1 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,5 +1,4 @@
 use std::collections::HashMap;
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::types::ScoreType;
@@ -23,6 +22,7 @@ use super::holders::segment_holder::LockedSegmentHolder;
 use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
+use crate::common::stopping_guard::StoppingGuard;
 use crate::config::CollectionConfig;
 use crate::operations::query_enum::QueryEnum;
 use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, Modifier, Record};
@@ -156,6 +156,7 @@ impl SegmentsSearcher {
         segments: LockedSegmentHolder,
         batch_request: &CoreSearchRequestBatch,
         collection_config: &CollectionConfig,
+        is_stopped_guard: &StoppingGuard,
     ) -> CollectionResult<Option<QueryContext>> {
         let indexing_threshold_kb = collection_config
             .optimizer_config
@@ -183,7 +184,8 @@ impl SegmentsSearcher {
         }
 
         let mut query_context =
-            QueryContext::new(indexing_threshold_kb.max(full_scan_threshold_kb));
+            QueryContext::new(indexing_threshold_kb.max(full_scan_threshold_kb))
+                .with_is_stopped(is_stopped_guard.get_is_stopped());
 
         for search_request in &batch_request.searches {
             search_request
@@ -224,7 +226,6 @@ impl SegmentsSearcher {
         batch_request: Arc<CoreSearchRequestBatch>,
         runtime_handle: &Handle,
         sampling_enabled: bool,
-        is_stopped: Arc<AtomicBool>,
         query_context: QueryContext,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         let query_context_acr = Arc::new(query_context);
@@ -252,13 +253,11 @@ impl SegmentsSearcher {
                     let query_context_arc_segment = query_context_acr.clone();
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
-                        let is_stopped_clone = is_stopped.clone();
                         move || {
                             search_in_segment(
                                 segment,
                                 batch_request,
                                 use_sampling,
-                                &is_stopped_clone,
                                 query_context_arc_segment,
                             )
                         }
@@ -302,13 +301,11 @@ impl SegmentsSearcher {
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
                             .collect(),
                     });
-                    let is_stopped_clone = is_stopped.clone();
                     res.push(runtime_handle.spawn_blocking(move || {
                         search_in_segment(
                             segment,
                             partial_batch_request,
                             false,
-                            &is_stopped_clone,
                             query_context_arc_segment,
                         )
                     }))
@@ -482,7 +479,6 @@ fn search_in_segment(
     segment: LockedSegment,
     request: Arc<CoreSearchRequestBatch>,
     use_sampling: bool,
-    is_stopped: &AtomicBool,
     query_context: Arc<QueryContext>,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
@@ -522,7 +518,6 @@ fn search_in_segment(
                     &vectors_batch,
                     &prev_params,
                     use_sampling,
-                    is_stopped,
                     &query_context,
                 )?;
                 further_results.append(&mut further);
@@ -542,7 +537,6 @@ fn search_in_segment(
             &vectors_batch,
             &prev_params,
             use_sampling,
-            is_stopped,
             &query_context,
         )?;
         further_results.append(&mut further);
@@ -557,7 +551,6 @@ fn execute_batch_search(
     vectors_batch: &[QueryVector],
     search_params: &BatchSearchParams,
     use_sampling: bool,
-    is_stopped: &AtomicBool,
     query_context: &QueryContext,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let locked_segment = segment.get();
@@ -582,6 +575,7 @@ fn execute_batch_search(
     };
 
     let vectors_batch = &vectors_batch.iter().collect_vec();
+    let segment_query_context = query_context.get_segment_query_context();
     let res = read_segment.search_batch(
         search_params.vector_name,
         vectors_batch,
@@ -590,8 +584,7 @@ fn execute_batch_search(
         search_params.filter,
         top,
         search_params.params,
-        is_stopped,
-        query_context,
+        segment_query_context,
     )?;
 
     let further_results = res
@@ -687,7 +680,6 @@ mod tests {
             Arc::new(batch_request),
             &Handle::current(),
             true,
-            Arc::new(AtomicBool::new(false)),
             QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
         )
         .await
@@ -753,7 +745,6 @@ mod tests {
                 batch_request.clone(),
                 &Handle::current(),
                 false,
-                Arc::new(false.into()),
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
             )
             .await
@@ -766,7 +757,6 @@ mod tests {
                 batch_request,
                 &Handle::current(),
                 true,
-                Arc::new(false.into()),
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
             )
             .await

commit 456c2ebb20bcbca5c0da7c0d156457e53849a6c3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed May 22 22:20:30 2024 +0200

    Query fetches payload and vector if necessary (#4300)
    
    * Query fetches payload and vector if necessary
    
    * foreach is a better fit
    
    * use hashset
    
    * code review
    
    * deconstruct records to reuse memory

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 12c79b8f1..f466ea326 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -335,6 +335,12 @@ impl SegmentsSearcher {
         Ok(top_scores)
     }
 
+    /// Retrieve records for the given points ids from the segments
+    /// - if payload is enabled, payload will be fetched
+    /// - if vector is enabled, vector will be fetched
+    ///
+    /// The points ids can contain duplicates, the records will be fetched only once
+    /// and returned in the same order as the input points.
     pub fn retrieve(
         segments: &RwLock<SegmentHolder>,
         points: &[PointIdType],

commit a7f2e7a3c9861c90630917b96e5f59db70cedbe5
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Jun 6 20:11:00 2024 +0200

    Fix deadlock caused by concurrent snapshot and optimization (#4402)
    
    * Rename segment addition functions, clarify this generates a new ID
    
    * Don't randomize segment IDs, auto increment to prevent duplicates
    
    * Rename swap to swap_new
    
    * On snapshot unproxy, put segments back with their original segment ID
    
    * Add sanity check to optimizer unproxy, must swap same number of segments
    
    * Clean up
    
    * Extend snapshot test, assert we end up with the same segment IDs

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index f466ea326..b5cc58be2 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -711,8 +711,8 @@ mod tests {
 
         let mut holder = SegmentHolder::default();
 
-        let _sid1 = holder.add(segment1);
-        let _sid2 = holder.add(segment2);
+        let _sid1 = holder.add_new(segment1);
+        let _sid2 = holder.add_new(segment2);
 
         let segment_holder = Arc::new(RwLock::new(holder));
 

commit 803e1b439a018756b19ffe108129a8818343080c
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Jun 14 11:48:04 2024 -0400

    universal-query: Execute batch queries in `LocalShard` (#4459)
    
    Edits the `do_planned_query` function into a `do_planned_query_batch`, to generalize into a handling batch queries.
    
    Most of the function is the same (doing searches and scrolls), but introduces extra complexity when fetching payload and vectors.
    
    This complexity comes from the fact that points may be deleted between search/scroll and after merging, so we now ignore those points which are not there anymore.

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index b5cc58be2..501368aa1 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -341,6 +341,8 @@ impl SegmentsSearcher {
     ///
     /// The points ids can contain duplicates, the records will be fetched only once
     /// and returned in the same order as the input points.
+    ///
+    /// If an id is not found in the segments, it won't be included in the output.
     pub fn retrieve(
         segments: &RwLock<SegmentHolder>,
         points: &[PointIdType],

commit 020da0635696b60a53b0261a0ee111bfc71197c6
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Jun 18 07:54:59 2024 +0200

    universal-query: add lookups to query API definition (#4479)
    
    * universal-query: add with_lookup to query API definition
    
    * fix consistency doc check
    
    * lookup_from and not lookup_with
    
    * clean import
    
    * improve doc for lookup location wrt using
    
    * Suggestions for descriptions
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 501368aa1..9483cab4b 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -621,6 +621,7 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &str) -> Option<us
 mod tests {
     use std::collections::HashSet;
 
+    use api::rest::SearchRequestInternal;
     use segment::fixtures::index_fixtures::random_vector;
     use segment::index::VectorIndexEnum;
     use segment::types::{Condition, HasIdCondition};
@@ -628,7 +629,7 @@ mod tests {
 
     use super::*;
     use crate::collection_manager::fixtures::{build_test_holder, random_segment};
-    use crate::operations::types::{CoreSearchRequest, SearchRequestInternal};
+    use crate::operations::types::CoreSearchRequest;
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
     #[test]

commit 7cf5983b4ffca7cff9fc5040e77db175915bee74
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 18 10:39:25 2024 +0200

    universal-search: local-shard refactoring (#4476)
    
    * rename of PrefetchHolder
    
    * rename MergeSources -> MergePlan
    
    * refactor PlannedQuery, move with_payload nad with_vector into RescoreParams
    
    * rename core_searches -> searches
    
    * decouple ScrollRequest and ScrollRequestInternal
    
    * move offset into RescoreParams
    
    * Revert "decouple ScrollRequest and ScrollRequestInternal"
    
    This reverts commit 704b82f0120d95e15408d919c7257384856b6361.
    
    * minor rename
    
    * Remove `WeakPlannedQuery`, rename vars, de-Option in `QueryScrollRequestInternal`
    
    * Remove `PlannedQueryBatch`, extend `PlannedQuery` to support batches
    
    * cargo clippy --fix
    
    * with_capacity -> new
    
    * Don't ignore with_vector and with_payload for fusion requests
    
    * use depth for debug assertion
    
    * codespell
    
    ---------
    
    Co-authored-by: Luis Cossío <luis.cossio@outlook.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 9483cab4b..0cc0174f6 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -395,6 +395,7 @@ impl SegmentsSearcher {
             Ok(true)
         })?;
 
+        // TODO(luis): remove this property of returning the records in the same order as the input, return the hashmap instead
         // Restore the order the ids came in
         let ordered_records = points
             .iter()

commit 49a9d05e7c180c2a4828686a54b9a7a8fbc946f3
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Jun 18 20:38:24 2024 +0200

    Fix multivector for unnamed vectors (#4482)
    
    * minor conversion improvement
    
    * use NamedVectors in update_vectors
    
    * remove merge from VectorStruct
    
    * rename Multi -> Named in vector struct
    
    * add multi-dense vectors option into VectorStruct
    
    * generate openapi
    
    * rename VectorStruct -> VectorStructInternal
    
    * add conversion for anonymous multivec in grpc
    
    * renames for BatchVectorStruct
    
    * implement multi-dense for batch
    
    * allow multi-dense in batch upserts
    
    * test and fixes

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 0cc0174f6..5e5e380ba 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -9,7 +9,7 @@ use parking_lot::RwLock;
 use segment::common::operation_error::OperationError;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::query_context::QueryContext;
-use segment::data_types::vectors::{QueryVector, VectorStruct};
+use segment::data_types::vectors::{QueryVector, VectorStructInternal};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
     WithPayload, WithPayloadInterface, WithVector,
@@ -372,7 +372,7 @@ impl SegmentsSearcher {
                             None
                         },
                         vector: {
-                            let vector: Option<VectorStruct> = match with_vector {
+                            let vector: Option<VectorStructInternal> = match with_vector {
                                 WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
                                 WithVector::Bool(false) => None,
                                 WithVector::Selector(vector_names) => {

commit 2c651b11477305c581bf5160d8eba0c8ecd26bb1
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Jun 24 08:25:50 2024 -0400

    order_by: Begin migration to `order_value` in `Record` [v1.10] (#4526)
    
    * begin migration to order_value
    
    * gen openapi and grpc docs
    
    * cargo clippy --fix
    
    * fixup

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 5e5e380ba..984de6688 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -388,6 +388,7 @@ impl SegmentsSearcher {
                             vector.map(Into::into)
                         },
                         shard_key: None,
+                        order_value: None,
                     },
                 );
                 point_version.insert(id, version);

commit add22f5ae8078369d93f1ae9b0dbe45df0ac362e
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jun 25 10:37:50 2024 -0400

    Make `SegmentsSearcher::retrieve` return a hashmap (#4539)
    
    Slight improvement. I have modified the return type of `SegmentsSearcher::retrieve` function to return the produced hashmap directly, to let the callers decide how to process it.
    
    Sometimes we were re-collecting it into a hashmap right away, which didn't make much sense

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 984de6688..7d3631464 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -340,7 +340,6 @@ impl SegmentsSearcher {
     /// - if vector is enabled, vector will be fetched
     ///
     /// The points ids can contain duplicates, the records will be fetched only once
-    /// and returned in the same order as the input points.
     ///
     /// If an id is not found in the segments, it won't be included in the output.
     pub fn retrieve(
@@ -348,7 +347,7 @@ impl SegmentsSearcher {
         points: &[PointIdType],
         with_payload: &WithPayload,
         with_vector: &WithVector,
-    ) -> CollectionResult<Vec<Record>> {
+    ) -> CollectionResult<HashMap<PointIdType, Record>> {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
         let mut point_records: HashMap<PointIdType, Record> = Default::default();
 
@@ -396,14 +395,7 @@ impl SegmentsSearcher {
             Ok(true)
         })?;
 
-        // TODO(luis): remove this property of returning the records in the same order as the input, return the hashmap instead
-        // Restore the order the ids came in
-        let ordered_records = points
-            .iter()
-            .filter_map(|point| point_records.get(point).cloned())
-            .collect();
-
-        Ok(ordered_records)
+        Ok(point_records)
     }
 }
 

commit 07c278ad51084c98adf9a7093619ffc5a73f87c9
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Mon Jul 22 08:19:19 2024 +0000

    Enable some of the pedantic clippy lints (#4715)
    
    * Use workspace lints
    
    * Enable lint: manual_let_else
    
    * Enable lint: enum_glob_use
    
    * Enable lint: filter_map_next
    
    * Enable lint: ref_as_ptr
    
    * Enable lint: ref_option_ref
    
    * Enable lint: manual_is_variant_and
    
    * Enable lint: flat_map_option
    
    * Enable lint: inefficient_to_string
    
    * Enable lint: implicit_clone
    
    * Enable lint: inconsistent_struct_constructor
    
    * Enable lint: unnecessary_wraps
    
    * Enable lint: needless_continue
    
    * Enable lint: unused_self
    
    * Enable lint: from_iter_instead_of_collect
    
    * Enable lint: uninlined_format_args
    
    * Enable lint: doc_link_with_quotes
    
    * Enable lint: needless_raw_string_hashes
    
    * Enable lint: used_underscore_binding
    
    * Enable lint: ptr_as_ptr
    
    * Enable lint: explicit_into_iter_loop
    
    * Enable lint: cast_lossless

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7d3631464..4c645c923 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -443,8 +443,7 @@ fn sampling_limit(
     }
     let segment_probability = segment_points as f64 / total_points as f64;
     let poisson_sampling =
-        find_search_sampling_over_point_distribution(limit as f64, segment_probability)
-            .unwrap_or(limit);
+        find_search_sampling_over_point_distribution(limit as f64, segment_probability);
 
     // if no ef_limit was found, it is a plain index => sampling optimization is not needed.
     let effective = ef_limit.map_or(limit, |ef_limit| {

commit 12c5d6b6b606cd5559a6452ef39d802039d02dd6
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Fri Aug 2 12:57:20 2024 -0400

    Support timeout in Facets (#4792)
    
    * nits in segments_searcher
    
    * implement timeout into segment faceting
    
    * Add timeout to internal service api
    
    * refactor iterator_ext, and add test

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 4c645c923..2606c3d3e 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -228,7 +228,7 @@ impl SegmentsSearcher {
         sampling_enabled: bool,
         query_context: QueryContext,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
-        let query_context_acr = Arc::new(query_context);
+        let query_context_arc = Arc::new(query_context);
 
         // Using block to ensure `segments` variable is dropped in the end of it
         let (locked_segments, searches): (Vec<_>, Vec<_>) = {
@@ -246,11 +246,11 @@ impl SegmentsSearcher {
             // - segments are not empty
             let use_sampling = sampling_enabled
                 && segments_lock.len() > 1
-                && query_context_acr.available_point_count() > 0;
+                && query_context_arc.available_point_count() > 0;
 
             segments
                 .map(|segment| {
-                    let query_context_arc_segment = query_context_acr.clone();
+                    let query_context_arc_segment = query_context_arc.clone();
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         move || {
@@ -293,7 +293,7 @@ impl SegmentsSearcher {
             let secondary_searches: Vec<_> = {
                 let mut res = vec![];
                 for (segment_id, batch_ids) in searches_to_rerun.iter() {
-                    let query_context_arc_segment = query_context_acr.clone();
+                    let query_context_arc_segment = query_context_arc.clone();
                     let segment = locked_segments[*segment_id].clone();
                     let partial_batch_request = Arc::new(CoreSearchRequestBatch {
                         searches: batch_ids
@@ -465,11 +465,8 @@ fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> us
 ///
 /// * `segment` - Locked segment to search in
 /// * `request` - Batch of search requests
-/// * `total_points` - Number of points in all segments combined
 /// * `use_sampling` - If true, try to use probabilistic sampling
-/// * `is_stopped` - Atomic bool to check if search is stopped
-/// * `indexing_threshold` - If `indexed_only` is enabled, the search will skip
-///                          segments with more than this number Kb of un-indexed vectors
+/// * `query_context` - Additional context for the search
 ///
 /// # Returns
 ///

commit c7da6ae36c455a67859dbc2a9f1e3ce274645121
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Aug 8 12:41:33 2024 +0200

    Non blocking retrieve with timeout and cancellation support (#4844)
    
    * Non blocking retrieve with timeout and cancellation support
    
    * apply timeout for extra retrieve in rescoring

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 2606c3d3e..3812828a6 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,11 +1,11 @@
 use std::collections::HashMap;
+use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::types::ScoreType;
 use futures::future::try_join_all;
 use itertools::Itertools;
 use ordered_float::Float;
-use parking_lot::RwLock;
 use segment::common::operation_error::OperationError;
 use segment::data_types::named_vectors::NamedVectors;
 use segment::data_types::query_context::QueryContext;
@@ -19,7 +19,7 @@ use tokio::runtime::Handle;
 use tokio::task::JoinHandle;
 
 use super::holders::segment_holder::LockedSegmentHolder;
-use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};
+use crate::collection_manager::holders::segment_holder::LockedSegment;
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
 use crate::common::stopping_guard::StoppingGuard;
@@ -342,58 +342,90 @@ impl SegmentsSearcher {
     /// The points ids can contain duplicates, the records will be fetched only once
     ///
     /// If an id is not found in the segments, it won't be included in the output.
-    pub fn retrieve(
-        segments: &RwLock<SegmentHolder>,
+    pub async fn retrieve(
+        segments: LockedSegmentHolder,
+        points: &[PointIdType],
+        with_payload: &WithPayload,
+        with_vector: &WithVector,
+        runtime_handle: &Handle,
+    ) -> CollectionResult<HashMap<PointIdType, Record>> {
+        let stopping_guard = StoppingGuard::new();
+        runtime_handle
+            .spawn_blocking({
+                let segments = segments.clone();
+                let points = points.to_vec();
+                let with_payload = with_payload.clone();
+                let with_vector = with_vector.clone();
+                let is_stopped = stopping_guard.get_is_stopped();
+                // TODO create one Task per segment level retrieve
+                move || {
+                    Self::retrieve_blocking(
+                        segments,
+                        &points,
+                        &with_payload,
+                        &with_vector,
+                        &is_stopped,
+                    )
+                }
+            })
+            .await?
+    }
+
+    pub fn retrieve_blocking(
+        segments: LockedSegmentHolder,
         points: &[PointIdType],
         with_payload: &WithPayload,
         with_vector: &WithVector,
+        is_stopped: &AtomicBool,
     ) -> CollectionResult<HashMap<PointIdType, Record>> {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
         let mut point_records: HashMap<PointIdType, Record> = Default::default();
 
-        segments.read().read_points(points, |id, segment| {
-            let version = segment.point_version(id).ok_or_else(|| {
-                OperationError::service_error(format!("No version for point {id}"))
-            })?;
-            // If this point was not found yet or this segment have later version
-            if !point_version.contains_key(&id) || point_version[&id] < version {
-                point_records.insert(
-                    id,
-                    Record {
+        segments
+            .read()
+            .read_points(points, is_stopped, |id, segment| {
+                let version = segment.point_version(id).ok_or_else(|| {
+                    OperationError::service_error(format!("No version for point {id}"))
+                })?;
+                // If this point was not found yet or this segment have later version
+                if !point_version.contains_key(&id) || point_version[&id] < version {
+                    point_records.insert(
                         id,
-                        payload: if with_payload.enable {
-                            if let Some(selector) = &with_payload.payload_selector {
-                                Some(selector.process(segment.payload(id)?))
+                        Record {
+                            id,
+                            payload: if with_payload.enable {
+                                if let Some(selector) = &with_payload.payload_selector {
+                                    Some(selector.process(segment.payload(id)?))
+                                } else {
+                                    Some(segment.payload(id)?)
+                                }
                             } else {
-                                Some(segment.payload(id)?)
-                            }
-                        } else {
-                            None
-                        },
-                        vector: {
-                            let vector: Option<VectorStructInternal> = match with_vector {
-                                WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
-                                WithVector::Bool(false) => None,
-                                WithVector::Selector(vector_names) => {
-                                    let mut selected_vectors = NamedVectors::default();
-                                    for vector_name in vector_names {
-                                        if let Some(vector) = segment.vector(vector_name, id)? {
-                                            selected_vectors.insert(vector_name.into(), vector);
+                                None
+                            },
+                            vector: {
+                                let vector: Option<VectorStructInternal> = match with_vector {
+                                    WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
+                                    WithVector::Bool(false) => None,
+                                    WithVector::Selector(vector_names) => {
+                                        let mut selected_vectors = NamedVectors::default();
+                                        for vector_name in vector_names {
+                                            if let Some(vector) = segment.vector(vector_name, id)? {
+                                                selected_vectors.insert(vector_name.into(), vector);
+                                            }
                                         }
+                                        Some(selected_vectors.into())
                                     }
-                                    Some(selected_vectors.into())
-                                }
-                            };
-                            vector.map(Into::into)
+                                };
+                                vector.map(Into::into)
+                            },
+                            shard_key: None,
+                            order_value: None,
                         },
-                        shard_key: None,
-                        order_value: None,
-                    },
-                );
-                point_version.insert(id, version);
-            }
-            Ok(true)
-        })?;
+                    );
+                    point_version.insert(id, version);
+                }
+                Ok(true)
+            })?;
 
         Ok(point_records)
     }
@@ -612,6 +644,7 @@ mod tests {
     use std::collections::HashSet;
 
     use api::rest::SearchRequestInternal;
+    use parking_lot::RwLock;
     use segment::fixtures::index_fixtures::random_vector;
     use segment::index::VectorIndexEnum;
     use segment::types::{Condition, HasIdCondition};
@@ -619,6 +652,7 @@ mod tests {
 
     use super::*;
     use crate::collection_manager::fixtures::{build_test_holder, random_segment};
+    use crate::collection_manager::holders::segment_holder::SegmentHolder;
     use crate::operations::types::CoreSearchRequest;
     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
@@ -778,12 +812,12 @@ mod tests {
     fn test_retrieve() {
         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();
         let segment_holder = build_test_holder(dir.path());
-
-        let records = SegmentsSearcher::retrieve(
-            &segment_holder,
+        let records = SegmentsSearcher::retrieve_blocking(
+            Arc::new(segment_holder),
             &[1.into(), 2.into(), 3.into()],
             &WithPayload::from(true),
             &true.into(),
+            &AtomicBool::new(false),
         )
         .unwrap();
         assert_eq!(records.len(), 3);

commit 8030504514e0a3cbc89e8f7e85c99ed9fc0936d9
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Aug 8 14:47:51 2024 +0200

    Non blocking exact count with timeout and cancellation support (#4849)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 3812828a6..6b8328509 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,4 +1,4 @@
-use std::collections::HashMap;
+use std::collections::{BTreeSet, HashMap};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
@@ -429,6 +429,31 @@ impl SegmentsSearcher {
 
         Ok(point_records)
     }
+
+    pub async fn read_filtered(
+        segments: LockedSegmentHolder,
+        filter: Option<&Filter>,
+        runtime_handle: &Handle,
+    ) -> CollectionResult<BTreeSet<PointIdType>> {
+        let stopping_guard = StoppingGuard::new();
+        let filter = filter.cloned();
+        runtime_handle
+            .spawn_blocking(move || {
+                let is_stopped = stopping_guard.get_is_stopped();
+                let segments = segments.read();
+                let all_points: BTreeSet<_> = segments
+                    .non_appendable_then_appendable_segments()
+                    .flat_map(|segment| {
+                        segment
+                            .get()
+                            .read()
+                            .read_filtered(None, None, filter.as_ref(), &is_stopped)
+                    })
+                    .collect();
+                Ok(all_points)
+            })
+            .await?
+    }
 }
 
 #[derive(PartialEq, Default, Debug)]

commit 1d0ee7ea32043598f8b240e6a3a52be20663fa44
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Oct 9 10:15:46 2024 +0200

    Inference interface in REST and gRPC (#5165)
    
    * include document & image objects into grpc API
    
    * introduce image and object to rest api
    
    * minor refactoring
    
    * rename Vector -> VectorInternal
    
    * decompose vector data structures
    
    * add schema
    
    * fmt
    
    * grpc docs
    
    * fix conversion
    
    * fix clippy
    
    * fix another conversion
    
    * rename VectorInput -> VectorInputInternal
    
    * replace grpc TryFrom with async functions
    
    * fmt
    
    * replace rest TryFrom with async functions
    
    * add image and object into query rest
    
    * separate inference related conversions
    
    * move json-related conversions into a separate file
    
    * move vector-related transformations into a separate file
    
    * move more vector related-conversions into dedicated module

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 6b8328509..5aa9b3324 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -25,7 +25,9 @@ use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
 use crate::common::stopping_guard::StoppingGuard;
 use crate::config::CollectionConfig;
 use crate::operations::query_enum::QueryEnum;
-use crate::operations::types::{CollectionResult, CoreSearchRequestBatch, Modifier, Record};
+use crate::operations::types::{
+    CollectionResult, CoreSearchRequestBatch, Modifier, RecordInternal,
+};
 use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;
 
 type BatchOffset = usize;
@@ -348,7 +350,7 @@ impl SegmentsSearcher {
         with_payload: &WithPayload,
         with_vector: &WithVector,
         runtime_handle: &Handle,
-    ) -> CollectionResult<HashMap<PointIdType, Record>> {
+    ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
         let stopping_guard = StoppingGuard::new();
         runtime_handle
             .spawn_blocking({
@@ -377,9 +379,9 @@ impl SegmentsSearcher {
         with_payload: &WithPayload,
         with_vector: &WithVector,
         is_stopped: &AtomicBool,
-    ) -> CollectionResult<HashMap<PointIdType, Record>> {
+    ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
-        let mut point_records: HashMap<PointIdType, Record> = Default::default();
+        let mut point_records: HashMap<PointIdType, RecordInternal> = Default::default();
 
         segments
             .read()
@@ -391,7 +393,7 @@ impl SegmentsSearcher {
                 if !point_version.contains_key(&id) || point_version[&id] < version {
                     point_records.insert(
                         id,
-                        Record {
+                        RecordInternal {
                             id,
                             payload: if with_payload.enable {
                                 if let Some(selector) = &with_payload.payload_selector {
@@ -403,8 +405,10 @@ impl SegmentsSearcher {
                                 None
                             },
                             vector: {
-                                let vector: Option<VectorStructInternal> = match with_vector {
-                                    WithVector::Bool(true) => Some(segment.all_vectors(id)?.into()),
+                                match with_vector {
+                                    WithVector::Bool(true) => {
+                                        Some(VectorStructInternal::from(segment.all_vectors(id)?))
+                                    }
                                     WithVector::Bool(false) => None,
                                     WithVector::Selector(vector_names) => {
                                         let mut selected_vectors = NamedVectors::default();
@@ -413,10 +417,9 @@ impl SegmentsSearcher {
                                                 selected_vectors.insert(vector_name.into(), vector);
                                             }
                                         }
-                                        Some(selected_vectors.into())
+                                        Some(VectorStructInternal::from(selected_vectors))
                                     }
-                                };
-                                vector.map(Into::into)
+                                }
                             },
                             shard_key: None,
                             order_value: None,

commit e1fb1593d7318742d4bba20aef4ca50e9fd72e7c
Author: Tim Visée <tim+github@visee.me>
Date:   Mon Oct 14 14:05:24 2024 +0200

    Hash/lookup point version only once, not 3 times (#5228)
    
    * Hash and lookup point version only once, not three times
    
    * Update lib/collection/src/collection_manager/segments_searcher.rs
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>
    
    ---------
    
    Co-authored-by: Roman Titov <ffuugoo@users.noreply.github.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 5aa9b3324..7c44097a5 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,3 +1,4 @@
+use std::collections::hash_map::Entry;
 use std::collections::{BTreeSet, HashMap};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
@@ -389,44 +390,49 @@ impl SegmentsSearcher {
                 let version = segment.point_version(id).ok_or_else(|| {
                     OperationError::service_error(format!("No version for point {id}"))
                 })?;
-                // If this point was not found yet or this segment have later version
-                if !point_version.contains_key(&id) || point_version[&id] < version {
-                    point_records.insert(
+
+                // If we already have the latest point version, keep that and continue
+                let version_entry = point_version.entry(id);
+                if matches!(&version_entry, Entry::Occupied(entry) if *entry.get() >= version) {
+                    return Ok(true);
+                }
+
+                point_records.insert(
+                    id,
+                    RecordInternal {
                         id,
-                        RecordInternal {
-                            id,
-                            payload: if with_payload.enable {
-                                if let Some(selector) = &with_payload.payload_selector {
-                                    Some(selector.process(segment.payload(id)?))
-                                } else {
-                                    Some(segment.payload(id)?)
-                                }
+                        payload: if with_payload.enable {
+                            if let Some(selector) = &with_payload.payload_selector {
+                                Some(selector.process(segment.payload(id)?))
                             } else {
-                                None
-                            },
-                            vector: {
-                                match with_vector {
-                                    WithVector::Bool(true) => {
-                                        Some(VectorStructInternal::from(segment.all_vectors(id)?))
-                                    }
-                                    WithVector::Bool(false) => None,
-                                    WithVector::Selector(vector_names) => {
-                                        let mut selected_vectors = NamedVectors::default();
-                                        for vector_name in vector_names {
-                                            if let Some(vector) = segment.vector(vector_name, id)? {
-                                                selected_vectors.insert(vector_name.into(), vector);
-                                            }
+                                Some(segment.payload(id)?)
+                            }
+                        } else {
+                            None
+                        },
+                        vector: {
+                            match with_vector {
+                                WithVector::Bool(true) => {
+                                    Some(VectorStructInternal::from(segment.all_vectors(id)?))
+                                }
+                                WithVector::Bool(false) => None,
+                                WithVector::Selector(vector_names) => {
+                                    let mut selected_vectors = NamedVectors::default();
+                                    for vector_name in vector_names {
+                                        if let Some(vector) = segment.vector(vector_name, id)? {
+                                            selected_vectors.insert(vector_name.into(), vector);
                                         }
-                                        Some(VectorStructInternal::from(selected_vectors))
                                     }
+                                    Some(VectorStructInternal::from(selected_vectors))
                                 }
-                            },
-                            shard_key: None,
-                            order_value: None,
+                            }
                         },
-                    );
-                    point_version.insert(id, version);
-                }
+                        shard_key: None,
+                        order_value: None,
+                    },
+                );
+                *version_entry.or_default() = version;
+
                 Ok(true)
             })?;
 

commit dafe172c4928c7487fc31f88171d27bad42d7147
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Oct 17 16:24:13 2024 +0200

    Add HardwareCounterCell + CPU measurement for sparse vector search (#5239)
    
    * Add HardwareCounterCell and counting for sparse plain search
    
    * Add measurement for indexed sparse vector
    
    * add tests for calculations
    
    * move SegmentQueryContent higher in the call stack
    
    * move hardware counters inside the query context
    
    * fix clippy
    
    * Fix applying hardware measurements and add test for this
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7c44097a5..45293d03a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -9,7 +9,7 @@ use itertools::Itertools;
 use ordered_float::Float;
 use segment::common::operation_error::OperationError;
 use segment::data_types::named_vectors::NamedVectors;
-use segment::data_types::query_context::QueryContext;
+use segment::data_types::query_context::{QueryContext, SegmentQueryContext};
 use segment::data_types::vectors::{QueryVector, VectorStructInternal};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
@@ -257,11 +257,13 @@ impl SegmentsSearcher {
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         move || {
+                            let segment_query_context =
+                                query_context_arc_segment.get_segment_query_context();
                             search_in_segment(
                                 segment,
                                 batch_request,
                                 use_sampling,
-                                query_context_arc_segment,
+                                segment_query_context,
                             )
                         }
                     });
@@ -305,11 +307,13 @@ impl SegmentsSearcher {
                             .collect(),
                     });
                     res.push(runtime_handle.spawn_blocking(move || {
+                        let segment_query_context =
+                            query_context_arc_segment.get_segment_query_context();
                         search_in_segment(
                             segment,
                             partial_batch_request,
                             false,
-                            query_context_arc_segment,
+                            segment_query_context,
                         )
                     }))
                 }
@@ -543,7 +547,7 @@ fn search_in_segment(
     segment: LockedSegment,
     request: Arc<CoreSearchRequestBatch>,
     use_sampling: bool,
-    query_context: Arc<QueryContext>,
+    segment_query_context: SegmentQueryContext,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -582,7 +586,7 @@ fn search_in_segment(
                     &vectors_batch,
                     &prev_params,
                     use_sampling,
-                    &query_context,
+                    &segment_query_context,
                 )?;
                 further_results.append(&mut further);
                 result.append(&mut res);
@@ -601,7 +605,7 @@ fn search_in_segment(
             &vectors_batch,
             &prev_params,
             use_sampling,
-            &query_context,
+            &segment_query_context,
         )?;
         further_results.append(&mut further);
         result.append(&mut res);
@@ -615,7 +619,7 @@ fn execute_batch_search(
     vectors_batch: &[QueryVector],
     search_params: &BatchSearchParams,
     use_sampling: bool,
-    query_context: &QueryContext,
+    segment_query_context: &SegmentQueryContext,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let locked_segment = segment.get();
     let read_segment = locked_segment.read();
@@ -632,14 +636,13 @@ fn execute_batch_search(
             search_params.top,
             ef_limit,
             segment_points,
-            query_context.available_point_count(),
+            segment_query_context.available_point_count(),
         )
     } else {
         search_params.top
     };
 
     let vectors_batch = &vectors_batch.iter().collect_vec();
-    let segment_query_context = query_context.get_segment_query_context();
     let res = read_segment.search_batch(
         search_params.vector_name,
         vectors_batch,

commit cd8efa8f17a6d6b45e6e8b54638ab6976d740aa5
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Oct 25 09:52:18 2024 +0200

    Hw counter utilization checks (#5288)
    
    * Enforce usage of hardware counter values
    
    * improve comments
    
    * log a warning in release mode
    
    * some minor improvements
    
    * avoid cloning for hardware counter
    
    * fmt
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 45293d03a..2f25a21af 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -259,12 +259,20 @@ impl SegmentsSearcher {
                         move || {
                             let segment_query_context =
                                 query_context_arc_segment.get_segment_query_context();
-                            search_in_segment(
+
+                            let result = search_in_segment(
                                 segment,
                                 batch_request,
                                 use_sampling,
-                                segment_query_context,
-                            )
+                                &segment_query_context,
+                            );
+
+                            // TODO: propagate measurements instead of discarding!
+                            segment_query_context
+                                .take_hardware_counter()
+                                .discard_results();
+
+                            result
                         }
                     });
                     (segment.clone(), search)
@@ -309,12 +317,17 @@ impl SegmentsSearcher {
                     res.push(runtime_handle.spawn_blocking(move || {
                         let segment_query_context =
                             query_context_arc_segment.get_segment_query_context();
-                        search_in_segment(
+                        let result = search_in_segment(
                             segment,
                             partial_batch_request,
                             false,
-                            segment_query_context,
-                        )
+                            &segment_query_context,
+                        );
+                        // TODO: propagate measurements instead of discarding!
+                        segment_query_context
+                            .take_hardware_counter()
+                            .discard_results();
+                        result
                     }))
                 }
                 res
@@ -547,7 +560,7 @@ fn search_in_segment(
     segment: LockedSegment,
     request: Arc<CoreSearchRequestBatch>,
     use_sampling: bool,
-    segment_query_context: SegmentQueryContext,
+    segment_query_context: &SegmentQueryContext,
 ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {
     let batch_size = request.searches.len();
 
@@ -586,7 +599,7 @@ fn search_in_segment(
                     &vectors_batch,
                     &prev_params,
                     use_sampling,
-                    &segment_query_context,
+                    segment_query_context,
                 )?;
                 further_results.append(&mut further);
                 result.append(&mut res);
@@ -605,7 +618,7 @@ fn search_in_segment(
             &vectors_batch,
             &prev_params,
             use_sampling,
-            &segment_query_context,
+            segment_query_context,
         )?;
         further_results.append(&mut further);
         result.append(&mut res);

commit c1d0a8d61e2d825770fa65a05cbf085e20a4e7a9
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Oct 29 22:15:37 2024 +0100

    Populate hardware counter to REST API (#5308)
    
    * populate hardware counter
    
    * make consume semantic explicit
    
    * Merge pull request #5328
    
    * add hardware info to more endpoints
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 2f25a21af..d8a20996a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -3,6 +3,7 @@ use std::collections::{BTreeSet, HashMap};
 use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
+use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::types::ScoreType;
 use futures::future::try_join_all;
 use itertools::Itertools;
@@ -230,6 +231,7 @@ impl SegmentsSearcher {
         runtime_handle: &Handle,
         sampling_enabled: bool,
         query_context: QueryContext,
+        hw_measurement_acc: HwMeasurementAcc,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         let query_context_arc = Arc::new(query_context);
 
@@ -254,25 +256,24 @@ impl SegmentsSearcher {
             segments
                 .map(|segment| {
                     let query_context_arc_segment = query_context_arc.clone();
+                    let hw_counter_clone = hw_measurement_acc.clone();
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         move || {
                             let segment_query_context =
                                 query_context_arc_segment.get_segment_query_context();
 
-                            let result = search_in_segment(
+                            let res = search_in_segment(
                                 segment,
                                 batch_request,
                                 use_sampling,
                                 &segment_query_context,
                             );
 
-                            // TODO: propagate measurements instead of discarding!
-                            segment_query_context
-                                .take_hardware_counter()
-                                .discard_results();
+                            hw_counter_clone
+                                .merge_from_cell(segment_query_context.take_hardware_counter());
 
-                            result
+                            res
                         }
                     });
                     (segment.clone(), search)
@@ -314,19 +315,21 @@ impl SegmentsSearcher {
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
                             .collect(),
                     });
+                    let hw_counter_clone = hw_measurement_acc.clone();
                     res.push(runtime_handle.spawn_blocking(move || {
                         let segment_query_context =
                             query_context_arc_segment.get_segment_query_context();
+
                         let result = search_in_segment(
                             segment,
                             partial_batch_request,
                             false,
                             &segment_query_context,
                         );
-                        // TODO: propagate measurements instead of discarding!
-                        segment_query_context
-                            .take_hardware_counter()
-                            .discard_results();
+
+                        hw_counter_clone
+                            .merge_from_cell(segment_query_context.take_hardware_counter());
+
                         result
                     }))
                 }
@@ -764,6 +767,7 @@ mod tests {
             &Handle::current(),
             true,
             QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
+            HwMeasurementAcc::new(),
         )
         .await
         .unwrap()
@@ -823,16 +827,22 @@ mod tests {
 
             let batch_request = Arc::new(batch_request);
 
+            let hw_measurement_acc = HwMeasurementAcc::new();
+
             let result_no_sampling = SegmentsSearcher::search(
                 segment_holder.clone(),
                 batch_request.clone(),
                 &Handle::current(),
                 false,
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
+                hw_measurement_acc.clone(),
             )
             .await
             .unwrap();
 
+            assert_ne!(hw_measurement_acc.get_cpu(), 0);
+            hw_measurement_acc.clear();
+
             assert!(!result_no_sampling.is_empty());
 
             let result_sampling = SegmentsSearcher::search(
@@ -841,11 +851,15 @@ mod tests {
                 &Handle::current(),
                 true,
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
+                hw_measurement_acc.clone(),
             )
             .await
             .unwrap();
             assert!(!result_sampling.is_empty());
 
+            assert_ne!(hw_measurement_acc.get_cpu(), 0);
+            hw_measurement_acc.clear();
+
             // assert equivalence in depth
             assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());
             assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());

commit 28dfb3ef747ca8a2e0f3ab4aef096bcb13c0c835
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Nov 8 13:02:23 2024 +0100

    Remove redundant clones (#5402)
    
    * Remove redundant clones
    
    * fmt

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index d8a20996a..e012df94a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -276,7 +276,7 @@ impl SegmentsSearcher {
                             res
                         }
                     });
-                    (segment.clone(), search)
+                    (segment, search)
                 })
                 .unzip()
         };

commit 98633cbd3fdd01ee3c486a3573ff27dc180e3b6d
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 11 10:26:17 2024 +0100

    Use references for less cloning when possible (#5409)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index e012df94a..fe721fc83 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -77,7 +77,7 @@ impl SegmentsSearcher {
     pub(crate) fn process_search_result_step1(
         search_result: BatchSearchResult,
         limits: Vec<usize>,
-        further_results: Vec<Vec<bool>>,
+        further_results: &[Vec<bool>],
     ) -> (
         BatchResultAggregator,
         HashMap<SegmentOffset, Vec<BatchOffset>>,
@@ -294,7 +294,7 @@ impl SegmentsSearcher {
                 .iter()
                 .map(|request| request.limit + request.offset)
                 .collect(),
-            further_results,
+            &further_results,
         );
         // The second step of the search is to re-run the search without sampling on some segments
         // Expected that this stage will be executed rarely

commit b50c547ceed5a1abaf4ecf5dcc3853e1d149c41c
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Nov 11 18:23:25 2024 +0100

    Optimize serch batch (#5415)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index fe721fc83..935a2dce3 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -590,7 +590,7 @@ fn search_in_segment(
 
         let query = search_query.query.clone().into();
 
-        // same params enables batching
+        // same params enables batching (cmp expensive on large filters)
         if params == prev_params {
             vectors_batch.push(query);
         } else {

commit 87479d19300923e41af420f8a7b8a0c6d3964271
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 12 17:16:12 2024 +0100

    Leverage ahash in search results (#5428)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 935a2dce3..cfe855bec 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -126,7 +126,7 @@ impl SegmentsSearcher {
         let mut searches_to_rerun: HashMap<SegmentOffset, Vec<BatchOffset>> = HashMap::new();
 
         // Check if we want to re-run the search without sampling on some segments
-        for (batch_id, required_limit) in limits.iter().copied().enumerate() {
+        for (batch_id, required_limit) in limits.into_iter().enumerate() {
             let lowest_batch_score_opt = result_aggregator.batch_lowest_scores(batch_id);
 
             // If there are no results, we do not need to re-run the search

commit 9e06d68661402bb2df271134bab5d9aeda995048
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Sat Nov 16 01:03:50 2024 +0700

    Add UUID to collection config (#5378)
    
    * Add UUID to collection...
    
    ...and recreate collection, when applying Raft snapshot, if UUID of collection is different
    
    * fixup! Add UUID to collection...
    
    Remove UUID field from gRPC and exclude it from OpenAPI spec 🤡
    
    * fixup! fixup! Add UUID to collection...
    
    Always generate collection UUID 🤦‍♀️
    
    * Raft snapshot recreate collection no expose UUID (#5452)
    
    * separate colleciton config structure from API
    
    * fmt
    
    * Update lib/collection/src/operations/types.rs
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Tim Visée <tim+github@visee.me>
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    Co-authored-by: Tim Visée <tim+github@visee.me>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index cfe855bec..e118461fa 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -25,7 +25,7 @@ use crate::collection_manager::holders::segment_holder::LockedSegment;
 use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
 use crate::common::stopping_guard::StoppingGuard;
-use crate::config::CollectionConfig;
+use crate::config::CollectionConfigInternal;
 use crate::operations::query_enum::QueryEnum;
 use crate::operations::types::{
     CollectionResult, CoreSearchRequestBatch, Modifier, RecordInternal,
@@ -159,7 +159,7 @@ impl SegmentsSearcher {
     pub async fn prepare_query_context(
         segments: LockedSegmentHolder,
         batch_request: &CoreSearchRequestBatch,
-        collection_config: &CollectionConfig,
+        collection_config: &CollectionConfigInternal,
         is_stopped_guard: &StoppingGuard,
     ) -> CollectionResult<Option<QueryContext>> {
         let indexing_threshold_kb = collection_config

commit b4e30ad6bfff857e212b7d63079783569e572267
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Sun Nov 17 12:46:01 2024 +0100

    Per collection hardware measurements  (#5453)
    
    * Add HwMeasurementCollector
    
    * Add hardware reporting to TOC + RequestHwCounter
    
    * Pass HwMeasurementAcc by reference + Update accumulation
    
    * Update tests and benchmarks
    
    * update REST API
    
    * Update gRPC API
    
    * codespell
    
    * Adjust internal API
    
    * improve docs
    
    * introduce drain to the HwMeasurementAcc
    
    * fmt
    
    * use drain to report to the collection counter
    
    * implement hw metrics drain for internal and external queries
    
    * fix drinage
    
    * refactor rest models: move away from grpc crate
    
    * fmt
    
    * implement usage reporting to collection acc for rest api
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index e118461fa..7030a0d3c 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -231,7 +231,7 @@ impl SegmentsSearcher {
         runtime_handle: &Handle,
         sampling_enabled: bool,
         query_context: QueryContext,
-        hw_measurement_acc: HwMeasurementAcc,
+        hw_measurement_acc: &HwMeasurementAcc,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         let query_context_arc = Arc::new(query_context);
 
@@ -256,7 +256,8 @@ impl SegmentsSearcher {
             segments
                 .map(|segment| {
                     let query_context_arc_segment = query_context_arc.clone();
-                    let hw_counter_clone = hw_measurement_acc.clone();
+                    let hw_collector = hw_measurement_acc.new_collector();
+
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
                         move || {
@@ -270,7 +271,7 @@ impl SegmentsSearcher {
                                 &segment_query_context,
                             );
 
-                            hw_counter_clone
+                            hw_collector
                                 .merge_from_cell(segment_query_context.take_hardware_counter());
 
                             res
@@ -315,7 +316,8 @@ impl SegmentsSearcher {
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
                             .collect(),
                     });
-                    let hw_counter_clone = hw_measurement_acc.clone();
+                    let hw_collector = hw_measurement_acc.new_collector();
+
                     res.push(runtime_handle.spawn_blocking(move || {
                         let segment_query_context =
                             query_context_arc_segment.get_segment_query_context();
@@ -327,8 +329,7 @@ impl SegmentsSearcher {
                             &segment_query_context,
                         );
 
-                        hw_counter_clone
-                            .merge_from_cell(segment_query_context.take_hardware_counter());
+                        hw_collector.merge_from_cell(segment_query_context.take_hardware_counter());
 
                         result
                     }))
@@ -761,19 +762,21 @@ mod tests {
             searches: vec![req],
         };
 
+        let hw_acc = HwMeasurementAcc::new();
         let result = SegmentsSearcher::search(
             Arc::new(segment_holder),
             Arc::new(batch_request),
             &Handle::current(),
             true,
             QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-            HwMeasurementAcc::new(),
+            &hw_acc,
         )
         .await
         .unwrap()
         .into_iter()
         .next()
         .unwrap();
+        hw_acc.discard();
 
         // eprintln!("result = {:?}", &result);
 
@@ -835,13 +838,15 @@ mod tests {
                 &Handle::current(),
                 false,
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-                hw_measurement_acc.clone(),
+                &hw_measurement_acc,
             )
             .await
             .unwrap();
 
             assert_ne!(hw_measurement_acc.get_cpu(), 0);
-            hw_measurement_acc.clear();
+            hw_measurement_acc.discard();
+
+            let hw_measurement_acc = HwMeasurementAcc::new();
 
             assert!(!result_no_sampling.is_empty());
 
@@ -851,14 +856,14 @@ mod tests {
                 &Handle::current(),
                 true,
                 QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-                hw_measurement_acc.clone(),
+                &hw_measurement_acc,
             )
             .await
             .unwrap();
             assert!(!result_sampling.is_empty());
 
             assert_ne!(hw_measurement_acc.get_cpu(), 0);
-            hw_measurement_acc.clear();
+            hw_measurement_acc.discard();
 
             // assert equivalence in depth
             assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());

commit bdce8012542aa90d379b69a2c22c7ccfd540cf46
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Tue Nov 26 17:50:02 2024 +0100

    SegmentSearcher stream results (#5521)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7030a0d3c..cd9f07b20 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -5,7 +5,8 @@ use std::sync::Arc;
 
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::types::ScoreType;
-use futures::future::try_join_all;
+use futures::stream::FuturesUnordered;
+use futures::{FutureExt, TryStreamExt};
 use itertools::Itertools;
 use ordered_float::Float;
 use segment::common::operation_error::OperationError;
@@ -49,19 +50,27 @@ type SegmentSearchExecutedResult = CollectionResult<(SegmentBatchSearchResult, V
 pub struct SegmentsSearcher {}
 
 impl SegmentsSearcher {
+    /// Execute searches in parallel and return results in the same order as the searches were provided
     async fn execute_searches(
         searches: Vec<JoinHandle<SegmentSearchExecutedResult>>,
     ) -> CollectionResult<(BatchSearchResult, Vec<Vec<bool>>)> {
-        let searches = try_join_all(searches);
-        let search_results_per_segment_res = searches.await?;
+        let results_len = searches.len();
 
-        let mut search_results_per_segment = vec![];
-        let mut further_searches_per_segment = vec![];
-        for search_result in search_results_per_segment_res {
+        let mut search_results_per_segment_res = FuturesUnordered::new();
+        for (idx, search) in searches.into_iter().enumerate() {
+            // map the result to include the request index for later reordering
+            let result_with_request_index = search.map(move |res| res.map(|s| (idx, s)));
+            search_results_per_segment_res.push(result_with_request_index);
+        }
+
+        let mut search_results_per_segment = vec![Vec::new(); results_len];
+        let mut further_searches_per_segment = vec![Vec::new(); results_len];
+        // process results as they come in and store them in the correct order
+        while let Some((idx, search_result)) = search_results_per_segment_res.try_next().await? {
             let (search_results, further_searches) = search_result?;
             debug_assert!(search_results.len() == further_searches.len());
-            search_results_per_segment.push(search_results);
-            further_searches_per_segment.push(further_searches);
+            search_results_per_segment[idx] = search_results;
+            further_searches_per_segment[idx] = further_searches;
         }
         Ok((search_results_per_segment, further_searches_per_segment))
     }

commit 5aee24cc089b0ddedacb80c508e33d40fcea1950
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Tue Dec 10 12:12:36 2024 +0100

    Timeout aware hardware counter (#5555)
    
    * Make hardware counting timeout aware
    
    * improve test
    
    * rebuild everything
    
    * fmt
    
    * post-rebase fixes
    
    * upd tests
    
    * fix tests
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index cd9f07b20..765854555 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -170,6 +170,7 @@ impl SegmentsSearcher {
         batch_request: &CoreSearchRequestBatch,
         collection_config: &CollectionConfigInternal,
         is_stopped_guard: &StoppingGuard,
+        hw_measurement_acc: HwMeasurementAcc,
     ) -> CollectionResult<Option<QueryContext>> {
         let indexing_threshold_kb = collection_config
             .optimizer_config
@@ -196,9 +197,11 @@ impl SegmentsSearcher {
             }
         }
 
-        let mut query_context =
-            QueryContext::new(indexing_threshold_kb.max(full_scan_threshold_kb))
-                .with_is_stopped(is_stopped_guard.get_is_stopped());
+        let mut query_context = QueryContext::new(
+            indexing_threshold_kb.max(full_scan_threshold_kb),
+            hw_measurement_acc,
+        )
+        .with_is_stopped(is_stopped_guard.get_is_stopped());
 
         for search_request in &batch_request.searches {
             search_request
@@ -240,7 +243,6 @@ impl SegmentsSearcher {
         runtime_handle: &Handle,
         sampling_enabled: bool,
         query_context: QueryContext,
-        hw_measurement_acc: &HwMeasurementAcc,
     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {
         let query_context_arc = Arc::new(query_context);
 
@@ -265,7 +267,6 @@ impl SegmentsSearcher {
             segments
                 .map(|segment| {
                     let query_context_arc_segment = query_context_arc.clone();
-                    let hw_collector = hw_measurement_acc.new_collector();
 
                     let search = runtime_handle.spawn_blocking({
                         let (segment, batch_request) = (segment.clone(), batch_request.clone());
@@ -273,17 +274,12 @@ impl SegmentsSearcher {
                             let segment_query_context =
                                 query_context_arc_segment.get_segment_query_context();
 
-                            let res = search_in_segment(
+                            search_in_segment(
                                 segment,
                                 batch_request,
                                 use_sampling,
                                 &segment_query_context,
-                            );
-
-                            hw_collector
-                                .merge_from_cell(segment_query_context.take_hardware_counter());
-
-                            res
+                            )
                         }
                     });
                     (segment, search)
@@ -325,22 +321,17 @@ impl SegmentsSearcher {
                             .map(|batch_id| batch_request.searches[*batch_id].clone())
                             .collect(),
                     });
-                    let hw_collector = hw_measurement_acc.new_collector();
 
                     res.push(runtime_handle.spawn_blocking(move || {
                         let segment_query_context =
                             query_context_arc_segment.get_segment_query_context();
 
-                        let result = search_in_segment(
+                        search_in_segment(
                             segment,
                             partial_batch_request,
                             false,
                             &segment_query_context,
-                        );
-
-                        hw_collector.merge_from_cell(segment_query_context.take_hardware_counter());
-
-                        result
+                        )
                     }))
                 }
                 res
@@ -777,15 +768,13 @@ mod tests {
             Arc::new(batch_request),
             &Handle::current(),
             true,
-            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-            &hw_acc,
+            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_acc),
         )
         .await
         .unwrap()
         .into_iter()
         .next()
         .unwrap();
-        hw_acc.discard();
 
         // eprintln!("result = {:?}", &result);
 
@@ -840,22 +829,24 @@ mod tests {
             let batch_request = Arc::new(batch_request);
 
             let hw_measurement_acc = HwMeasurementAcc::new();
+            let query_context =
+                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());
 
             let result_no_sampling = SegmentsSearcher::search(
                 segment_holder.clone(),
                 batch_request.clone(),
                 &Handle::current(),
                 false,
-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-                &hw_measurement_acc,
+                query_context,
             )
             .await
             .unwrap();
 
             assert_ne!(hw_measurement_acc.get_cpu(), 0);
-            hw_measurement_acc.discard();
 
             let hw_measurement_acc = HwMeasurementAcc::new();
+            let query_context =
+                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());
 
             assert!(!result_no_sampling.is_empty());
 
@@ -864,15 +855,13 @@ mod tests {
                 batch_request,
                 &Handle::current(),
                 true,
-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB),
-                &hw_measurement_acc,
+                query_context,
             )
             .await
             .unwrap();
             assert!(!result_sampling.is_empty());
 
             assert_ne!(hw_measurement_acc.get_cpu(), 0);
-            hw_measurement_acc.discard();
 
             // assert equivalence in depth
             assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());

commit 38f478ddf7a9d03a1c783c5599f3b6ae33a05195
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 16 14:25:55 2025 +0100

    Measure payload read IO (#5773)
    
    * Measure read io for payload storage
    
    * Add Hardware Counter to update functions
    
    * Fix tests and benches
    
    * Rename (some) *_measured functions back to original

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 765854555..6b23dad3b 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -4,6 +4,7 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::counter::hardware_accumulator::HwMeasurementAcc;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::ScoreType;
 use futures::stream::FuturesUnordered;
 use futures::{FutureExt, TryStreamExt};
@@ -372,6 +373,7 @@ impl SegmentsSearcher {
         with_payload: &WithPayload,
         with_vector: &WithVector,
         runtime_handle: &Handle,
+        hw_measurement_acc: HwMeasurementAcc,
     ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
         let stopping_guard = StoppingGuard::new();
         runtime_handle
@@ -389,6 +391,7 @@ impl SegmentsSearcher {
                         &with_payload,
                         &with_vector,
                         &is_stopped,
+                        hw_measurement_acc,
                     )
                 }
             })
@@ -401,10 +404,13 @@ impl SegmentsSearcher {
         with_payload: &WithPayload,
         with_vector: &WithVector,
         is_stopped: &AtomicBool,
+        hw_measurement_acc: HwMeasurementAcc,
     ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
         let mut point_records: HashMap<PointIdType, RecordInternal> = Default::default();
 
+        let hw_counter = HardwareCounterCell::new_with_accumulator(hw_measurement_acc);
+
         segments
             .read()
             .read_points(points, is_stopped, |id, segment| {
@@ -424,9 +430,9 @@ impl SegmentsSearcher {
                         id,
                         payload: if with_payload.enable {
                             if let Some(selector) = &with_payload.payload_selector {
-                                Some(selector.process(segment.payload(id)?))
+                                Some(selector.process(segment.payload(id, &hw_counter)?))
                             } else {
-                                Some(segment.payload(id)?)
+                                Some(segment.payload(id, &hw_counter)?)
                             }
                         } else {
                             None
@@ -885,6 +891,7 @@ mod tests {
             &WithPayload::from(true),
             &true.into(),
             &AtomicBool::new(false),
+            HwMeasurementAcc::new(),
         )
         .unwrap();
         assert_eq!(records.len(), 3);

commit eaaa31e34d7a26f52ebc1e12578961d19b92728d
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jan 23 08:37:20 2025 +0000

    Fix cargo doc warnings (#5854)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 6b23dad3b..a82ec0661 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -76,14 +76,14 @@ impl SegmentsSearcher {
         Ok((search_results_per_segment, further_searches_per_segment))
     }
 
-    /// Processes search result of [segment_size x batch_size]
+    /// Processes search result of `[segment_size x batch_size]`.
     ///
     /// # Arguments
-    /// * search_result - [segment_size x batch_size]
-    /// * limits - [batch_size] - how many results to return for each batched request
-    /// * further_searches - [segment_size x batch_size] - whether we can search further in the segment
+    /// * `search_result` - `[segment_size x batch_size]`
+    /// * `limits` - `[batch_size]` - how many results to return for each batched request
+    /// * `further_searches` - `[segment_size x batch_size]` - whether we can search further in the segment
     ///
-    /// Returns batch results aggregated by [batch_size] and list of queries, grouped by segment to re-run
+    /// Returns batch results aggregated by `[batch_size]` and list of queries, grouped by segment to re-run
     pub(crate) fn process_search_result_step1(
         search_result: BatchSearchResult,
         limits: Vec<usize>,

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index a82ec0661..9295911ab 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -16,7 +16,7 @@ use segment::data_types::query_context::{QueryContext, SegmentQueryContext};
 use segment::data_types::vectors::{QueryVector, VectorStructInternal};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
-    WithPayload, WithPayloadInterface, WithVector,
+    VectorName, WithPayload, WithPayloadInterface, WithVector,
 };
 use tinyvec::TinyVec;
 use tokio::runtime::Handle;
@@ -180,7 +180,7 @@ impl SegmentsSearcher {
         let full_scan_threshold_kb = collection_config.hnsw_config.full_scan_threshold;
 
         const DEFAULT_CAPACITY: usize = 3;
-        let mut idf_vectors: TinyVec<[&str; DEFAULT_CAPACITY]> = Default::default();
+        let mut idf_vectors: TinyVec<[&VectorName; DEFAULT_CAPACITY]> = Default::default();
 
         // check vector names existing
         for req in &batch_request.searches {
@@ -447,7 +447,7 @@ impl SegmentsSearcher {
                                     let mut selected_vectors = NamedVectors::default();
                                     for vector_name in vector_names {
                                         if let Some(vector) = segment.vector(vector_name, id)? {
-                                            selected_vectors.insert(vector_name.into(), vector);
+                                            selected_vectors.insert(vector_name.clone(), vector);
                                         }
                                     }
                                     Some(VectorStructInternal::from(selected_vectors))
@@ -515,7 +515,7 @@ impl From<&QueryEnum> for SearchType {
 #[derive(PartialEq, Default, Debug)]
 struct BatchSearchParams<'a> {
     pub search_type: SearchType,
-    pub vector_name: &'a str,
+    pub vector_name: &'a VectorName,
     pub filter: Option<&'a Filter>,
     pub with_payload: WithPayload,
     pub with_vector: WithVector,
@@ -688,7 +688,7 @@ fn execute_batch_search(
 /// Find the HNSW ef_construct for a named vector
 ///
 /// If the given named vector has no HNSW index, `None` is returned.
-fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &str) -> Option<usize> {
+fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Option<usize> {
     config
         .vector_data
         .get(vector_name)
@@ -705,6 +705,7 @@ mod tests {
 
     use api::rest::SearchRequestInternal;
     use parking_lot::RwLock;
+    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;
     use segment::fixtures::index_fixtures::random_vector;
     use segment::index::VectorIndexEnum;
     use segment::types::{Condition, HasIdCondition};
@@ -722,7 +723,12 @@ mod tests {
 
         let segment1 = random_segment(dir.path(), 10, 200, 256);
 
-        let vector_index = segment1.vector_data.get("").unwrap().vector_index.clone();
+        let vector_index = segment1
+            .vector_data
+            .get(DEFAULT_VECTOR_NAME)
+            .unwrap()
+            .vector_index
+            .clone();
 
         let vector_index_borrow = vector_index.borrow();
 

commit 97743b1b625d42f73955ecb32d54ca34ea3a5cb7
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Jan 24 16:33:44 2025 +0100

    Propagate hardware counter for more functions (#5844)
    
    * Propagate hardware counter for more functions
    
    * Minor improvements
    
    * use vector_query_contexts hardware_counter

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 9295911ab..c4396ef6b 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -470,6 +470,7 @@ impl SegmentsSearcher {
         segments: LockedSegmentHolder,
         filter: Option<&Filter>,
         runtime_handle: &Handle,
+        hw_measurement_acc: HwMeasurementAcc,
     ) -> CollectionResult<BTreeSet<PointIdType>> {
         let stopping_guard = StoppingGuard::new();
         let filter = filter.cloned();
@@ -477,13 +478,17 @@ impl SegmentsSearcher {
             .spawn_blocking(move || {
                 let is_stopped = stopping_guard.get_is_stopped();
                 let segments = segments.read();
+                let hw_counter = HardwareCounterCell::new_with_accumulator(hw_measurement_acc);
                 let all_points: BTreeSet<_> = segments
                     .non_appendable_then_appendable_segments()
                     .flat_map(|segment| {
-                        segment
-                            .get()
-                            .read()
-                            .read_filtered(None, None, filter.as_ref(), &is_stopped)
+                        segment.get().read().read_filtered(
+                            None,
+                            None,
+                            filter.as_ref(),
+                            &is_stopped,
+                            &hw_counter,
+                        )
                     })
                     .collect();
                 Ok(all_points)

commit f11032829662bbf68fd2bf3cbd8483152fa92b44
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Tue Jan 28 12:19:11 2025 -0300

    bump and migrate to `rand` 0.9.0 (#5892)
    
    * bump and migrate to rand 0.9.0
    
    also bump rand_distr to 0.5.0 to match it
    
    * Migrate AVX2 and SSE implementations
    
    * Remove unused thread_rng placeholders
    
    * More random migrations
    
    * Migrate GPU tests
    
    * bump seed
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index c4396ef6b..7260d9b5f 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -815,7 +815,7 @@ mod tests {
 
         let segment_holder = Arc::new(RwLock::new(holder));
 
-        let mut rnd = rand::thread_rng();
+        let mut rnd = rand::rng();
 
         for _ in 0..100 {
             let req1 = SearchRequestInternal {

commit 77f65ef95fe83c80c05a947e4f94d35538108d85
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 30 10:23:35 2025 +0100

    HwCounter rename IO metrics (#5898)
    
    * Rename io metrics and add vector_io_write
    
    * Chore: Cleanup obsolete TODOs and simplify retrieving HardwareCounterCells (#5899)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7260d9b5f..993915709 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -4,7 +4,6 @@ use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
 
 use common::counter::hardware_accumulator::HwMeasurementAcc;
-use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::ScoreType;
 use futures::stream::FuturesUnordered;
 use futures::{FutureExt, TryStreamExt};
@@ -409,7 +408,7 @@ impl SegmentsSearcher {
         let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
         let mut point_records: HashMap<PointIdType, RecordInternal> = Default::default();
 
-        let hw_counter = HardwareCounterCell::new_with_accumulator(hw_measurement_acc);
+        let hw_counter = hw_measurement_acc.get_counter_cell();
 
         segments
             .read()
@@ -478,7 +477,7 @@ impl SegmentsSearcher {
             .spawn_blocking(move || {
                 let is_stopped = stopping_guard.get_is_stopped();
                 let segments = segments.read();
-                let hw_counter = HardwareCounterCell::new_with_accumulator(hw_measurement_acc);
+                let hw_counter = hw_measurement_acc.get_counter_cell();
                 let all_points: BTreeSet<_> = segments
                     .non_appendable_then_appendable_segments()
                     .flat_map(|segment| {

commit ec0762a56044324f73c55bf17e26b9f07cd9bf86
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Mon Feb 3 11:56:43 2025 +0100

    Measure IO reads for vectors (#5912)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 993915709..22b7be744 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -439,7 +439,11 @@ impl SegmentsSearcher {
                         vector: {
                             match with_vector {
                                 WithVector::Bool(true) => {
-                                    Some(VectorStructInternal::from(segment.all_vectors(id)?))
+                                    let vectors = segment.all_vectors(id)?;
+                                    hw_counter
+                                        .vector_io_read()
+                                        .incr_delta(vectors.estimate_size_in_bytes());
+                                    Some(VectorStructInternal::from(vectors))
                                 }
                                 WithVector::Bool(false) => None,
                                 WithVector::Selector(vector_names) => {
@@ -449,6 +453,9 @@ impl SegmentsSearcher {
                                             selected_vectors.insert(vector_name.clone(), vector);
                                         }
                                     }
+                                    hw_counter
+                                        .vector_io_read()
+                                        .incr_delta(selected_vectors.estimate_size_in_bytes());
                                     Some(VectorStructInternal::from(selected_vectors))
                                 }
                             }

commit 2cab5192f7c546986f609057d40010418686c1bd
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Wed Feb 19 13:16:02 2025 -0300

    [score boosting] handle rescoring up to local shard (#6019)
    
    * handle rescoring up to local shard
    
    * use heap to keep only best points
    
    * add stopping flag
    
    * handle wrapped segment deletions
    
    * drop ordering, assume always LargeBetter
    
    * use ahash for u32 keys
    
    * micro optimization on update_point_versions
    
    * use Option instead of Vec for error
    
    * clarify comment

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 22b7be744..7c932ec83 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -11,7 +11,7 @@ use itertools::Itertools;
 use ordered_float::Float;
 use segment::common::operation_error::OperationError;
 use segment::data_types::named_vectors::NamedVectors;
-use segment::data_types::query_context::{QueryContext, SegmentQueryContext};
+use segment::data_types::query_context::{FormulaContext, QueryContext, SegmentQueryContext};
 use segment::data_types::vectors::{QueryVector, VectorStructInternal};
 use segment::types::{
     Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,
@@ -47,7 +47,7 @@ type SegmentSearchExecutedResult = CollectionResult<(SegmentBatchSearchResult, V
 /// Simple implementation of segment manager
 ///  - rebuild segment for memory optimization purposes
 #[derive(Default)]
-pub struct SegmentsSearcher {}
+pub struct SegmentsSearcher;
 
 impl SegmentsSearcher {
     /// Execute searches in parallel and return results in the same order as the searches were provided
@@ -105,7 +105,7 @@ impl SegmentsSearcher {
 
         // Initialize result aggregators for each batched request
         let mut result_aggregator = BatchResultAggregator::new(limits.iter().copied());
-        result_aggregator.update_point_versions(&search_result);
+        result_aggregator.update_point_versions(search_result.iter().flatten().flatten());
 
         // Therefore we need to track the lowest scored element per segment for each batch
         let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![
@@ -340,7 +340,12 @@ impl SegmentsSearcher {
             let (secondary_search_results_per_segment, _) =
                 Self::execute_searches(secondary_searches).await?;
 
-            result_aggregator.update_point_versions(&secondary_search_results_per_segment);
+            result_aggregator.update_point_versions(
+                secondary_search_results_per_segment
+                    .iter()
+                    .flatten()
+                    .flatten(),
+            );
 
             for ((_segment_id, batch_ids), segments_result) in searches_to_rerun
                 .into_iter()
@@ -501,6 +506,54 @@ impl SegmentsSearcher {
             })
             .await?
     }
+
+    /// Rescore results with a formula that can reference payload values.
+    ///
+    /// Aggregates rescores from the segments.
+    pub async fn rescore_with_formula(
+        segments: LockedSegmentHolder,
+        arc_ctx: Arc<FormulaContext>,
+        runtime_handle: &Handle,
+        hw_measurement_acc: HwMeasurementAcc,
+    ) -> CollectionResult<Vec<ScoredPoint>> {
+        let limit = arc_ctx.limit;
+
+        let mut futures = {
+            let segments_guard = segments.read();
+            segments_guard
+                .non_appendable_then_appendable_segments()
+                .map(|segment| {
+                    runtime_handle.spawn_blocking({
+                        let segment = segment.clone();
+                        let arc_ctx = arc_ctx.clone();
+                        let hw_counter = hw_measurement_acc.get_counter_cell();
+                        move || {
+                            segment
+                                .get()
+                                .read()
+                                .rescore_with_formula(arc_ctx, None, &hw_counter)
+                        }
+                    })
+                })
+                .collect::<FuturesUnordered<_>>()
+        };
+
+        let mut segments_results = Vec::with_capacity(futures.len());
+        while let Some(result) = futures.try_next().await? {
+            segments_results.push(result?)
+        }
+
+        // use aggregator with only one "batch"
+        let mut aggregator = BatchResultAggregator::new(std::iter::once(limit));
+        aggregator.update_point_versions(segments_results.iter().flatten());
+        aggregator.update_batch_results(0, segments_results.into_iter().flatten());
+        let top =
+            aggregator.into_topk().into_iter().next().ok_or_else(|| {
+                OperationError::service_error("expected first result of aggregator")
+            })?;
+
+        Ok(top)
+    }
 }
 
 #[derive(PartialEq, Default, Debug)]

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Visée <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 7c932ec83..360a8097a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,7 +1,7 @@
 use std::collections::hash_map::Entry;
 use std::collections::{BTreeSet, HashMap};
-use std::sync::atomic::AtomicBool;
 use std::sync::Arc;
+use std::sync::atomic::AtomicBool;
 
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::types::ScoreType;
@@ -149,7 +149,9 @@ impl SegmentsSearcher {
                         && retrieved_points < required_limit
                         && segment_lowest_score >= lowest_batch_score
                     {
-                        log::debug!("Search to re-run without sampling on segment_id: {segment_id} segment_lowest_score: {segment_lowest_score}, lowest_batch_score: {lowest_batch_score}, retrieved_points: {retrieved_points}, required_limit: {required_limit}");
+                        log::debug!(
+                            "Search to re-run without sampling on segment_id: {segment_id} segment_lowest_score: {segment_lowest_score}, lowest_batch_score: {lowest_batch_score}, retrieved_points: {retrieved_points}, required_limit: {required_limit}",
+                        );
                         // It is possible, that current segment can have better results than
                         // the lowest score in the batch. In that case, we need to re-run the search
                         // without sampling on that segment.
@@ -606,7 +608,9 @@ fn sampling_limit(
     let effective = ef_limit.map_or(limit, |ef_limit| {
         effective_limit(limit, ef_limit, poisson_sampling)
     });
-    log::trace!("sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}");
+    log::trace!(
+        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",
+    );
     effective
 }
 

commit 396fab4c1d3a1239757e930f17d11a0ead0d88e8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Feb 26 10:14:46 2025 +0100

    Shard-level limit undersampling (#6056)
    
    * poisson-based undersampling for shard level search
    
    * fmt
    
    * give a bit more ensurance to undersampling
    
    * review fixes
    
    * add debug log in case undersampling can lead to accuracy loss

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 360a8097a..740866d2d 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -23,7 +23,7 @@ use tokio::task::JoinHandle;
 
 use super::holders::segment_holder::LockedSegmentHolder;
 use crate::collection_manager::holders::segment_holder::LockedSegment;
-use crate::collection_manager::probabilistic_segment_search_sampling::find_search_sampling_over_point_distribution;
+use crate::collection_manager::probabilistic_search_sampling::find_search_sampling_over_point_distribution;
 use crate::collection_manager::search_result_aggregator::BatchResultAggregator;
 use crate::common::stopping_guard::StoppingGuard;
 use crate::config::CollectionConfigInternal;

commit 56a7cfdb205f90df28d2816d9e8ef6251fc517a2
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Fri Mar 14 11:05:38 2025 +0100

    Cardinality estimation IO measurements (#6117)
    
    * Cardinality estimation measurements
    
    * Apply hw measurements to latest changes from dev
    
    * Clippy
    
    * Also measure cardinality estimation for geo index
    
    * Make measured units 'bytes'
    
    * Use PointOffsetType instead of u32 for size calculation
    
    * fix memory cost for check_values_any in mmap index
    
    * fix double counting for value reading in mmap, remove hw_counter from mmap hashmap
    
    * fmt
    
    * fix hw measurement for text index
    
    * Remove non necessary lifetime annotations
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 740866d2d..545622ab2 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -772,6 +772,7 @@ mod tests {
     use std::collections::HashSet;
 
     use api::rest::SearchRequestInternal;
+    use common::counter::hardware_counter::HardwareCounterCell;
     use parking_lot::RwLock;
     use segment::data_types::vectors::DEFAULT_VECTOR_NAME;
     use segment::fixtures::index_fixtures::random_vector;
@@ -800,19 +801,26 @@ mod tests {
 
         let vector_index_borrow = vector_index.borrow();
 
+        let hw_counter = HardwareCounterCell::new();
+
         match &*vector_index_borrow {
             VectorIndexEnum::Plain(plain_index) => {
-                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None);
+                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);
                 assert!(!res_1);
 
-                let res_2 = plain_index.is_small_enough_for_unindexed_search(225, None);
+                let res_2 =
+                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);
                 assert!(res_2);
 
                 let ids: HashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();
 
                 let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));
 
-                let res_3 = plain_index.is_small_enough_for_unindexed_search(25, Some(&ids_filter));
+                let res_3 = plain_index.is_small_enough_for_unindexed_search(
+                    25,
+                    Some(&ids_filter),
+                    &hw_counter,
+                );
                 assert!(res_3);
             }
             _ => panic!("Expected plain index"),

commit d289a92a5540945e48aff2eb580b6c64adbfd28a
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Mon Mar 17 09:27:31 2025 -0300

    [score boosting] fix proxy segment leakage (#6170)
    
    * remove deleted bitslice from rescore_with_formula signature
    
    * dont allocate unnecessary ahash
    
    ---------
    
    Co-authored-by: generall <andrey@vasnetsov.com>

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 545622ab2..58faf824a 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -533,7 +533,7 @@ impl SegmentsSearcher {
                             segment
                                 .get()
                                 .read()
-                                .rescore_with_formula(arc_ctx, None, &hw_counter)
+                                .rescore_with_formula(arc_ctx, &hw_counter)
                         }
                     })
                 })

commit e114801ebfde19c080a39aa4fada7b50bafd1248
Author: Luis Cossío <luis.cossio@qdrant.com>
Date:   Thu Apr 3 04:01:39 2025 -0300

    `sum_scores` recommendation strategy (#6256)
    
    * Add in rest and grpc
    
    * add to QueryEnum
    
    * implement Query trait
    
    * connect to scorer creation
    
    * upd tests
    
    * additional changes
    
    * fmt
    
    * gen openapi and grpc docs
    
    * coderabbit fix
    
    * add changes in async scorer
    
    * test sum_scores in more places, refactor to remove repetition

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 58faf824a..1047c73a7 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -563,6 +563,7 @@ pub enum SearchType {
     #[default]
     Nearest,
     RecommendBestScore,
+    RecommendSumScores,
     Discover,
     Context,
 }
@@ -572,6 +573,7 @@ impl From<&QueryEnum> for SearchType {
         match query {
             QueryEnum::Nearest(_) => Self::Nearest,
             QueryEnum::RecommendBestScore(_) => Self::RecommendBestScore,
+            QueryEnum::RecommendSumScores(_) => Self::RecommendSumScores,
             QueryEnum::Discover(_) => Self::Discover,
             QueryEnum::Context(_) => Self::Context,
         }

commit e59d395d80ade92eef58c220adb576548e5e21a7
Author: Tim Visée <tim+github@visee.me>
Date:   Thu Apr 17 23:11:35 2025 +0200

    Use ahash for maps/sets holding point IDs, offsets or similar (#6388)

diff --git a/lib/collection/src/collection_manager/segments_searcher.rs b/lib/collection/src/collection_manager/segments_searcher.rs
index 1047c73a7..a617447f2 100644
--- a/lib/collection/src/collection_manager/segments_searcher.rs
+++ b/lib/collection/src/collection_manager/segments_searcher.rs
@@ -1,8 +1,9 @@
+use std::collections::BTreeSet;
 use std::collections::hash_map::Entry;
-use std::collections::{BTreeSet, HashMap};
 use std::sync::Arc;
 use std::sync::atomic::AtomicBool;
 
+use ahash::AHashMap;
 use common::counter::hardware_accumulator::HwMeasurementAcc;
 use common::types::ScoreType;
 use futures::stream::FuturesUnordered;
@@ -89,7 +90,7 @@ impl SegmentsSearcher {
         further_results: &[Vec<bool>],
     ) -> (
         BatchResultAggregator,
-        HashMap<SegmentOffset, Vec<BatchOffset>>,
+        AHashMap<SegmentOffset, Vec<BatchOffset>>,
     ) {
         let number_segments = search_result.len();
         let batch_size = limits.len();
@@ -132,7 +133,7 @@ impl SegmentsSearcher {
         }
 
         // segment id -> list of batch ids
-        let mut searches_to_rerun: HashMap<SegmentOffset, Vec<BatchOffset>> = HashMap::new();
+        let mut searches_to_rerun: AHashMap<SegmentOffset, Vec<BatchOffset>> = AHashMap::new();
 
         // Check if we want to re-run the search without sampling on some segments
         for (batch_id, required_limit) in limits.into_iter().enumerate() {
@@ -380,7 +381,7 @@ impl SegmentsSearcher {
         with_vector: &WithVector,
         runtime_handle: &Handle,
         hw_measurement_acc: HwMeasurementAcc,
-    ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
+    ) -> CollectionResult<AHashMap<PointIdType, RecordInternal>> {
         let stopping_guard = StoppingGuard::new();
         runtime_handle
             .spawn_blocking({
@@ -411,9 +412,9 @@ impl SegmentsSearcher {
         with_vector: &WithVector,
         is_stopped: &AtomicBool,
         hw_measurement_acc: HwMeasurementAcc,
-    ) -> CollectionResult<HashMap<PointIdType, RecordInternal>> {
-        let mut point_version: HashMap<PointIdType, SeqNumberType> = Default::default();
-        let mut point_records: HashMap<PointIdType, RecordInternal> = Default::default();
+    ) -> CollectionResult<AHashMap<PointIdType, RecordInternal>> {
+        let mut point_version: AHashMap<PointIdType, SeqNumberType> = Default::default();
+        let mut point_records: AHashMap<PointIdType, RecordInternal> = Default::default();
 
         let hw_counter = hw_measurement_acc.get_counter_cell();
 
@@ -771,8 +772,7 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Op
 
 #[cfg(test)]
 mod tests {
-    use std::collections::HashSet;
-
+    use ahash::AHashSet;
     use api::rest::SearchRequestInternal;
     use common::counter::hardware_counter::HardwareCounterCell;
     use parking_lot::RwLock;
@@ -814,7 +814,7 @@ mod tests {
                     plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);
                 assert!(res_2);
 
-                let ids: HashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();
+                let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();
 
                 let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));
 

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    