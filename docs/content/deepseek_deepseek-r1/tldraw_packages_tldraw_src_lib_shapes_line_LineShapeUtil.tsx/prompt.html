<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx - DeepSeek R1</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx</h1>
        <p><a href="../../../cases/deepseek_deepseek-r1/tldraw_packages_tldraw_src_lib_shapes_line_LineShapeUtil.tsx.html">← Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
new file mode 100644
index 000000000..25ec2b994
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -0,0 +1,374 @@
+/* eslint-disable react-hooks/rules-of-hooks */
+import {
+	SVGContainer,
+	ShapeUtil,
+	TLHandle,
+	TLLineShape,
+	TLOnHandleChangeHandler,
+	TLOnResizeHandler,
+	Vec2d,
+	VecLike,
+	WeakMapCache,
+	deepCopy,
+	getDefaultColorTheme,
+	getIndexBetween,
+	intersectLineSegmentPolyline,
+	lineShapeMigrations,
+	lineShapeProps,
+	pointNearToPolyline,
+	sortByIndex,
+} from '@tldraw/editor'
+
+import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
+import { STROKE_SIZES } from '../shared/default-shape-constants'
+import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { getDrawLinePathData } from '../shared/polygon-helpers'
+import { CubicSpline2d } from '../shared/splines/CubicSpline2d'
+import { Polyline2d } from '../shared/splines/Polyline2d'
+import { useForceSolid } from '../shared/useForceSolid'
+import { getLineDrawPath, getLineIndicatorPath, getLinePoints } from './components/getLinePath'
+import { getLineSvg } from './components/getLineSvg'
+
+const splinesCache = new WeakMapCache<TLLineShape['props'], CubicSpline2d | Polyline2d>()
+const handlesCache = new WeakMapCache<TLLineShape['props'], TLHandle[]>()
+
+/** @public */
+export class LineShapeUtil extends ShapeUtil<TLLineShape> {
+	static override type = 'line' as const
+	static override props = lineShapeProps
+	static override migrations = lineShapeMigrations
+
+	override hideResizeHandles = () => true
+	override hideRotateHandle = () => true
+	override hideSelectionBoundsBg = () => true
+	override hideSelectionBoundsFg = () => true
+	override isClosed = () => false
+
+	override getDefaultProps(): TLLineShape['props'] {
+		return {
+			dash: 'draw',
+			size: 'm',
+			color: 'black',
+			spline: 'line',
+			handles: {
+				start: {
+					id: 'start',
+					type: 'vertex',
+					canBind: false,
+					index: 'a1',
+					x: 0,
+					y: 0,
+				},
+				end: {
+					id: 'end',
+					type: 'vertex',
+					canBind: false,
+					index: 'a2',
+					x: 0,
+					y: 0,
+				},
+			},
+		}
+	}
+
+	getBounds(shape: TLLineShape) {
+		// todo: should we have min size?
+		const spline = getSplineForLineShape(shape)
+		return spline.bounds
+	}
+
+	override getHandles(shape: TLLineShape) {
+		return handlesCache.get(shape.props, () => {
+			const handles = shape.props.handles
+
+			const spline = getSplineForLineShape(shape)
+
+			const sortedHandles = Object.values(handles).sort(sortByIndex)
+			const results = sortedHandles.slice()
+
+			// Add "create" handles between each vertex handle
+			for (let i = 0; i < spline.segments.length; i++) {
+				const segment = spline.segments[i]
+				const point = segment.midPoint
+				const index = getIndexBetween(sortedHandles[i].index, sortedHandles[i + 1].index)
+
+				results.push({
+					id: `mid-${i}`,
+					type: 'create',
+					index,
+					x: point.x,
+					y: point.y,
+				})
+			}
+			return results.sort(sortByIndex)
+		})
+	}
+
+	override getOutline(shape: TLLineShape) {
+		return getLinePoints(getSplineForLineShape(shape))
+	}
+
+	override getOutlineSegments(shape: TLLineShape) {
+		const spline = getSplineForLineShape(shape)
+		return shape.props.spline === 'cubic'
+			? spline.segments.map((s) => s.lut)
+			: spline.segments.map((s) => [s.getPoint(0), s.getPoint(1)])
+	}
+
+	//   Events
+
+	override onResize: TLOnResizeHandler<TLLineShape> = (shape, info) => {
+		const { scaleX, scaleY } = info
+
+		const handles = deepCopy(shape.props.handles)
+
+		Object.values(shape.props.handles).forEach(({ id, x, y }) => {
+			handles[id].x = x * scaleX
+			handles[id].y = y * scaleY
+		})
+
+		return {
+			props: {
+				handles,
+			},
+		}
+	}
+
+	override onHandleChange: TLOnHandleChangeHandler<TLLineShape> = (shape, { handle }) => {
+		const next = deepCopy(shape)
+
+		switch (handle.id) {
+			case 'start':
+			case 'end': {
+				next.props.handles[handle.id] = {
+					...next.props.handles[handle.id],
+					x: handle.x,
+					y: handle.y,
+				}
+				break
+			}
+
+			default: {
+				const id = 'handle:' + handle.index
+				const existing = shape.props.handles[id]
+
+				if (existing) {
+					next.props.handles[id] = {
+						...existing,
+						x: handle.x,
+						y: handle.y,
+					}
+				} else {
+					next.props.handles[id] = {
+						id,
+						type: 'vertex',
+						canBind: false,
+						index: handle.index,
+						x: handle.x,
+						y: handle.y,
+					}
+				}
+
+				break
+			}
+		}
+
+		return next
+	}
+
+	override hitTestPoint(shape: TLLineShape, point: Vec2d): boolean {
+		const zoomLevel = this.editor.zoomLevel
+		const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
+		return pointNearToPolyline(point, this.editor.getOutline(shape), offsetDist)
+	}
+
+	override hitTestLineSegment(shape: TLLineShape, A: VecLike, B: VecLike): boolean {
+		return intersectLineSegmentPolyline(A, B, this.editor.getOutline(shape)) !== null
+	}
+
+	component(shape: TLLineShape) {
+		const theme = useDefaultColorTheme()
+		const forceSolid = useForceSolid()
+		const spline = getSplineForLineShape(shape)
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+
+		const { dash, color } = shape.props
+
+		// Line style lines
+		if (shape.props.spline === 'line') {
+			if (dash === 'solid') {
+				const outline = spline.points
+				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
+
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={pathData} fill={'none'} color={color} />
+						<path d={pathData} stroke={theme[color].solid} strokeWidth={strokeWidth} fill="none" />
+					</SVGContainer>
+				)
+			}
+
+			if (dash === 'dashed' || dash === 'dotted') {
+				const outline = spline.points
+				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
+
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={pathData} fill={'none'} color={color} />
+						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
+							{spline.segments.map((segment, i) => {
+								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+									segment.length,
+									strokeWidth,
+									{
+										style: dash,
+										start: i > 0 ? 'outset' : 'none',
+										end: i < spline.segments.length - 1 ? 'outset' : 'none',
+									}
+								)
+
+								return (
+									<path
+										key={i}
+										strokeDasharray={strokeDasharray}
+										strokeDashoffset={strokeDashoffset}
+										d={segment.path}
+										fill="none"
+									/>
+								)
+							})}
+						</g>
+					</SVGContainer>
+				)
+			}
+
+			if (dash === 'draw') {
+				const outline = spline.points
+				const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
+
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={innerPathData} fill={'none'} color={color} />
+						<path
+							d={outerPathData}
+							stroke={theme[color].solid}
+							strokeWidth={strokeWidth}
+							fill="none"
+						/>
+					</SVGContainer>
+				)
+			}
+		}
+
+		// Cubic style spline
+		if (shape.props.spline === 'cubic') {
+			const splinePath = spline.path
+
+			if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<path
+							strokeWidth={strokeWidth}
+							stroke={theme[color].solid}
+							fill="none"
+							d={splinePath}
+						/>
+					</SVGContainer>
+				)
+			}
+
+			if (dash === 'dashed' || dash === 'dotted') {
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
+							{spline.segments.map((segment, i) => {
+								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+									segment.length,
+									strokeWidth,
+									{
+										style: dash,
+										start: i > 0 ? 'outset' : 'none',
+										end: i < spline.segments.length - 1 ? 'outset' : 'none',
+									}
+								)
+
+								return (
+									<path
+										key={i}
+										strokeDasharray={strokeDasharray}
+										strokeDashoffset={strokeDashoffset}
+										d={segment.path}
+										fill="none"
+									/>
+								)
+							})}
+						</g>
+					</SVGContainer>
+				)
+			}
+
+			if (dash === 'draw') {
+				return (
+					<SVGContainer id={shape.id}>
+						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<path
+							d={getLineDrawPath(shape, spline, strokeWidth)}
+							strokeWidth={1}
+							stroke={theme[color].solid}
+							fill={theme[color].solid}
+						/>
+					</SVGContainer>
+				)
+			}
+		}
+	}
+
+	indicator(shape: TLLineShape) {
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+		const spline = getSplineForLineShape(shape)
+		const { dash } = shape.props
+
+		let path: string
+
+		if (shape.props.spline === 'line') {
+			const outline = spline.points
+			if (dash === 'solid' || dash === 'dotted' || dash === 'dashed') {
+				path = 'M' + outline[0] + 'L' + outline.slice(1)
+			} else {
+				const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
+				path = innerPathData
+			}
+		} else {
+			path = getLineIndicatorPath(shape, spline, strokeWidth)
+		}
+
+		return <path d={path} />
+	}
+
+	override toSvg(shape: TLLineShape) {
+		const theme = getDefaultColorTheme(this.editor)
+		const color = theme[shape.props.color].solid
+		const spline = getSplineForLineShape(shape)
+		return getLineSvg(shape, spline, color, STROKE_SIZES[shape.props.size])
+	}
+}
+
+/** @public */
+export function getSplineForLineShape(shape: TLLineShape) {
+	return splinesCache.get(shape.props, () => {
+		const { spline, handles } = shape.props
+
+		const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From)
+
+		switch (spline) {
+			case 'cubic': {
+				return new CubicSpline2d(handlePoints, handlePoints.length === 2 ? 2 : 1.2, 20)
+			}
+			case 'line': {
+				return new Polyline2d(handlePoints)
+			}
+		}
+	})
+}

commit 3e31ef2a7d01467ef92ca4f7aed13ee708db73ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 18 22:50:23 2023 +0100

    Remove helpers / extraneous API methods. (#1745)
    
    This PR removes several extraneous computed values from the editor. It
    adds some silly instance state onto the instance state record and
    unifies a few methods which were inconsistent. This is fit and finish
    work 🧽
    
    ## Computed Values
    
    In general, where once we had a getter and setter for `isBlahMode`,
    which really masked either an `_isBlahMode` atom on the editor or
    `instanceState.isBlahMode`, these are merged into `instanceState`; they
    can be accessed / updated via `editor.instanceState` /
    `editor.updateInstanceState`.
    
    ## tldraw select tool specific things
    
    This PR also removes some tldraw specific state checks and creates new
    component overrides to allow us to include them in tldraw/tldraw.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [tldraw] rename `useReadonly` to `useReadOnly`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isChangingStyle`
    - [editor] remove `Editor.isCoarsePointer`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isFocused`
    - [editor] remove `Editor.isGridMode`
    - [editor] remove `Editor.isPenMode`
    - [editor] remove `Editor.isReadOnly`
    - [editor] remove `Editor.isSnapMode`
    - [editor] remove `Editor.isToolLocked`
    - [editor] remove `Editor.locale`
    - [editor] rename `Editor.pageState` to `Editor.currentPageState`
    - [editor] add `Editor.pageStates`
    - [editor] add `Editor.setErasingIds`
    - [editor] add `Editor.setEditingId`
    - [editor] add several new component overrides

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 25ec2b994..d39a7f63d 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -348,7 +348,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override toSvg(shape: TLLineShape) {
-		const theme = getDefaultColorTheme(this.editor)
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
 		const color = theme[shape.props.color].solid
 		const spline = getSplineForLineShape(shape)
 		return getLineSvg(shape, spline, color, STROKE_SIZES[shape.props.size])

commit 0323ee1f6b6ece000b0c1e35cd259a986f852aad
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 20 12:38:55 2023 +0100

    [fix] dark mode (#1754)
    
    This PR fixes a bug where dark mode would not immediately cause shapes
    to update their colors. Previously, we got the current theme during
    render but not in a way that hooked into the change. In this update, we
    hook into the change. We also pass the change down to shape fills as
    props rather than getting the theme from deeper down.
    
    ### Change Type
    
    - [x] `patch`
    
    ### Test Plan
    
    1. Use dark mode.
    2. Switch colors
    
    ### Release Notes
    
    - [fix] dark mode colors not updating

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index d39a7f63d..657acd463 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -202,7 +202,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={pathData} fill={'none'} color={color} />
+						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
 						<path d={pathData} stroke={theme[color].solid} strokeWidth={strokeWidth} fill="none" />
 					</SVGContainer>
 				)
@@ -214,7 +214,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={pathData} fill={'none'} color={color} />
+						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
 						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
 							{spline.segments.map((segment, i) => {
 								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
@@ -248,7 +248,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={innerPathData} fill={'none'} color={color} />
+						<ShapeFill d={innerPathData} fill={'none'} color={color} theme={theme} />
 						<path
 							d={outerPathData}
 							stroke={theme[color].solid}
@@ -267,7 +267,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
 						<path
 							strokeWidth={strokeWidth}
 							stroke={theme[color].solid}
@@ -281,7 +281,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			if (dash === 'dashed' || dash === 'dotted') {
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
 						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
 							{spline.segments.map((segment, i) => {
 								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
@@ -312,7 +312,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			if (dash === 'draw') {
 				return (
 					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} />
+						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
 						<path
 							d={getLineDrawPath(shape, spline, strokeWidth)}
 							strokeWidth={1}

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 657acd463..9dfac0df4 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -1,5 +1,7 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
+	CubicSpline2d,
+	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
 	TLHandle,
@@ -7,15 +9,12 @@ import {
 	TLOnHandleChangeHandler,
 	TLOnResizeHandler,
 	Vec2d,
-	VecLike,
 	WeakMapCache,
 	deepCopy,
 	getDefaultColorTheme,
 	getIndexBetween,
-	intersectLineSegmentPolyline,
 	lineShapeMigrations,
 	lineShapeProps,
-	pointNearToPolyline,
 	sortByIndex,
 } from '@tldraw/editor'
 
@@ -23,13 +22,15 @@ import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { STROKE_SIZES } from '../shared/default-shape-constants'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
 import { getDrawLinePathData } from '../shared/polygon-helpers'
-import { CubicSpline2d } from '../shared/splines/CubicSpline2d'
-import { Polyline2d } from '../shared/splines/Polyline2d'
 import { useForceSolid } from '../shared/useForceSolid'
-import { getLineDrawPath, getLineIndicatorPath, getLinePoints } from './components/getLinePath'
+import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getLineSvg } from './components/getLineSvg'
+import {
+	getSvgPathForBezierCurve,
+	getSvgPathForEdge,
+	getSvgPathForLineGeometry,
+} from './components/svg'
 
-const splinesCache = new WeakMapCache<TLLineShape['props'], CubicSpline2d | Polyline2d>()
 const handlesCache = new WeakMapCache<TLLineShape['props'], TLHandle[]>()
 
 /** @public */
@@ -40,9 +41,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	override hideResizeHandles = () => true
 	override hideRotateHandle = () => true
-	override hideSelectionBoundsBg = () => true
 	override hideSelectionBoundsFg = () => true
-	override isClosed = () => false
 
 	override getDefaultProps(): TLLineShape['props'] {
 		return {
@@ -71,17 +70,16 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
-	getBounds(shape: TLLineShape) {
+	getGeometry(shape: TLLineShape) {
 		// todo: should we have min size?
-		const spline = getSplineForLineShape(shape)
-		return spline.bounds
+		return getGeometryForLineShape(shape)
 	}
 
 	override getHandles(shape: TLLineShape) {
 		return handlesCache.get(shape.props, () => {
 			const handles = shape.props.handles
 
-			const spline = getSplineForLineShape(shape)
+			const spline = getGeometryForLineShape(shape)
 
 			const sortedHandles = Object.values(handles).sort(sortByIndex)
 			const results = sortedHandles.slice()
@@ -89,7 +87,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			// Add "create" handles between each vertex handle
 			for (let i = 0; i < spline.segments.length; i++) {
 				const segment = spline.segments[i]
-				const point = segment.midPoint
+				const point = segment.midPoint()
 				const index = getIndexBetween(sortedHandles[i].index, sortedHandles[i + 1].index)
 
 				results.push({
@@ -100,19 +98,14 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					y: point.y,
 				})
 			}
+
 			return results.sort(sortByIndex)
 		})
 	}
 
-	override getOutline(shape: TLLineShape) {
-		return getLinePoints(getSplineForLineShape(shape))
-	}
-
 	override getOutlineSegments(shape: TLLineShape) {
-		const spline = getSplineForLineShape(shape)
-		return shape.props.spline === 'cubic'
-			? spline.segments.map((s) => s.lut)
-			: spline.segments.map((s) => [s.getPoint(0), s.getPoint(1)])
+		const spline = this.editor.getGeometry(shape) as Polyline2d | CubicSpline2d
+		return spline.segments.map((s) => s.vertices)
 	}
 
 	//   Events
@@ -176,20 +169,10 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		return next
 	}
 
-	override hitTestPoint(shape: TLLineShape, point: Vec2d): boolean {
-		const zoomLevel = this.editor.zoomLevel
-		const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
-		return pointNearToPolyline(point, this.editor.getOutline(shape), offsetDist)
-	}
-
-	override hitTestLineSegment(shape: TLLineShape, A: VecLike, B: VecLike): boolean {
-		return intersectLineSegmentPolyline(A, B, this.editor.getOutline(shape)) !== null
-	}
-
 	component(shape: TLLineShape) {
 		const theme = useDefaultColorTheme()
 		const forceSolid = useForceSolid()
-		const spline = getSplineForLineShape(shape)
+		const spline = getGeometryForLineShape(shape)
 		const strokeWidth = STROKE_SIZES[shape.props.size]
 
 		const { dash, color } = shape.props
@@ -212,6 +195,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 				const outline = spline.points
 				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
 
+				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
+
 				return (
 					<SVGContainer id={shape.id}>
 						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
@@ -232,7 +217,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 										key={i}
 										strokeDasharray={strokeDasharray}
 										strokeDashoffset={strokeDashoffset}
-										d={segment.path}
+										d={fn(segment as any, i === 0)}
 										fill="none"
 									/>
 								)
@@ -262,7 +247,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 		// Cubic style spline
 		if (shape.props.spline === 'cubic') {
-			const splinePath = spline.path
+			const splinePath = getSvgPathForLineGeometry(spline)
 
 			if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
 				return (
@@ -279,6 +264,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			}
 
 			if (dash === 'dashed' || dash === 'dotted') {
+				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
+
 				return (
 					<SVGContainer id={shape.id}>
 						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
@@ -299,7 +286,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 										key={i}
 										strokeDasharray={strokeDasharray}
 										strokeDashoffset={strokeDashoffset}
-										d={segment.path}
+										d={fn(segment as any, i === 0)}
 										fill="none"
 									/>
 								)
@@ -327,7 +314,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	indicator(shape: TLLineShape) {
 		const strokeWidth = STROKE_SIZES[shape.props.size]
-		const spline = getSplineForLineShape(shape)
+		const spline = getGeometryForLineShape(shape)
 		const { dash } = shape.props
 
 		let path: string
@@ -350,25 +337,22 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override toSvg(shape: TLLineShape) {
 		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
 		const color = theme[shape.props.color].solid
-		const spline = getSplineForLineShape(shape)
+		const spline = getGeometryForLineShape(shape)
 		return getLineSvg(shape, spline, color, STROKE_SIZES[shape.props.size])
 	}
 }
 
 /** @public */
-export function getSplineForLineShape(shape: TLLineShape) {
-	return splinesCache.get(shape.props, () => {
-		const { spline, handles } = shape.props
+export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
+	const { spline, handles } = shape.props
+	const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From)
 
-		const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From)
-
-		switch (spline) {
-			case 'cubic': {
-				return new CubicSpline2d(handlePoints, handlePoints.length === 2 ? 2 : 1.2, 20)
-			}
-			case 'line': {
-				return new Polyline2d(handlePoints)
-			}
+	switch (spline) {
+		case 'cubic': {
+			return new CubicSpline2d({ points: handlePoints })
+		}
+		case 'line': {
+			return new Polyline2d({ points: handlePoints })
 		}
-	})
+	}
 }

commit 18f5a1d9d2c3ff589cab76bd2afe18eb1162c50b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 27 18:18:44 2023 +0100

    remove useForceSolid effect for geo / line shapes (#1769)
    
    These shapes no longer use perfect freehand for their rendering, so we
    can drop the effect of `useForceSolid` for them.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Zoom out
    2. Draw style draw shapes should not change
    
    ### Release Notes
    
    - Remove the force solid switching for geo / line shapes

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 9dfac0df4..596a60b2b 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -22,7 +22,6 @@ import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { STROKE_SIZES } from '../shared/default-shape-constants'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
 import { getDrawLinePathData } from '../shared/polygon-helpers'
-import { useForceSolid } from '../shared/useForceSolid'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getLineSvg } from './components/getLineSvg'
 import {
@@ -171,7 +170,6 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	component(shape: TLLineShape) {
 		const theme = useDefaultColorTheme()
-		const forceSolid = useForceSolid()
 		const spline = getGeometryForLineShape(shape)
 		const strokeWidth = STROKE_SIZES[shape.props.size]
 
@@ -249,7 +247,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		if (shape.props.spline === 'cubic') {
 			const splinePath = getSvgPathForLineGeometry(spline)
 
-			if (dash === 'solid' || (dash === 'draw' && forceSolid)) {
+			if (dash === 'solid') {
 				return (
 					<SVGContainer id={shape.id}>
 						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 596a60b2b..1ed664de7 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -103,7 +103,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override getOutlineSegments(shape: TLLineShape) {
-		const spline = this.editor.getGeometry(shape) as Polyline2d | CubicSpline2d
+		const spline = this.editor.getShapeGeometry(shape) as Polyline2d | CubicSpline2d
 		return spline.segments.map((s) => s.vertices)
 	}
 

commit ba7a95d5f0f84fb7c3e8ef03a6d00e8ef07247f1
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Aug 25 19:24:30 2023 +0200

    [fix] Line shape rendering (#1825)
    
    This PR fixes several bugs in the line shape, both rendering in the app
    and in SVG exports.
    
    <img width="634" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/473db62f-2f18-40ef-992a-f5dac895d4ae">
    <img width="525" alt="image"
    src="https://github.com/tldraw/tldraw/assets/23072548/0673767c-b0e5-415c-962c-92bb1249261e">
    
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Make line shapes.
    2. Export them as SVGs.

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 1ed664de7..9408dd100 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -23,9 +23,9 @@ import { STROKE_SIZES } from '../shared/default-shape-constants'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
 import { getDrawLinePathData } from '../shared/polygon-helpers'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
-import { getLineSvg } from './components/getLineSvg'
 import {
 	getSvgPathForBezierCurve,
+	getSvgPathForCubicSpline,
 	getSvgPathForEdge,
 	getSvgPathForLineGeometry,
 } from './components/svg'
@@ -193,8 +193,6 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 				const outline = spline.points
 				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
 
-				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
-
 				return (
 					<SVGContainer id={shape.id}>
 						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
@@ -215,7 +213,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 										key={i}
 										strokeDasharray={strokeDasharray}
 										strokeDashoffset={strokeDashoffset}
-										d={fn(segment as any, i === 0)}
+										d={getSvgPathForEdge(segment as any, true)}
 										fill="none"
 									/>
 								)
@@ -262,8 +260,6 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			}
 
 			if (dash === 'dashed' || dash === 'dotted') {
-				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
-
 				return (
 					<SVGContainer id={shape.id}>
 						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
@@ -284,7 +280,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 										key={i}
 										strokeDasharray={strokeDasharray}
 										strokeDashoffset={strokeDashoffset}
-										d={fn(segment as any, i === 0)}
+										d={getSvgPathForBezierCurve(segment as any, true)}
 										fill="none"
 									/>
 								)
@@ -336,7 +332,75 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
 		const color = theme[shape.props.color].solid
 		const spline = getGeometryForLineShape(shape)
-		return getLineSvg(shape, spline, color, STROKE_SIZES[shape.props.size])
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+
+		switch (shape.props.dash) {
+			case 'draw': {
+				let pathData: string
+				if (spline instanceof CubicSpline2d) {
+					pathData = getLineDrawPath(shape, spline, strokeWidth)
+				} else {
+					const [_, outerPathData] = getDrawLinePathData(shape.id, spline.points, strokeWidth)
+					pathData = outerPathData
+				}
+
+				const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+				p.setAttribute('stroke-width', strokeWidth + 'px')
+				p.setAttribute('stroke', color)
+				p.setAttribute('fill', 'none')
+				p.setAttribute('d', pathData)
+
+				return p
+			}
+			case 'solid': {
+				let pathData: string
+
+				if (spline instanceof CubicSpline2d) {
+					pathData = getSvgPathForCubicSpline(spline, false)
+				} else {
+					const outline = spline.points
+					pathData = 'M' + outline[0] + 'L' + outline.slice(1)
+				}
+
+				const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+				p.setAttribute('stroke-width', strokeWidth + 'px')
+				p.setAttribute('stroke', color)
+				p.setAttribute('fill', 'none')
+				p.setAttribute('d', pathData)
+
+				return p
+			}
+			default: {
+				const { segments } = spline
+
+				const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+				g.setAttribute('stroke', color)
+				g.setAttribute('stroke-width', strokeWidth.toString())
+
+				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
+
+				segments.forEach((segment, i) => {
+					const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+					const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+						segment.length,
+						strokeWidth,
+						{
+							style: shape.props.dash,
+							start: i > 0 ? 'outset' : 'none',
+							end: i < segments.length - 1 ? 'outset' : 'none',
+						}
+					)
+
+					path.setAttribute('stroke-dasharray', strokeDasharray.toString())
+					path.setAttribute('stroke-dashoffset', strokeDashoffset.toString())
+					path.setAttribute('d', fn(segment as any, true))
+					path.setAttribute('fill', 'none')
+					g.appendChild(path)
+				})
+
+				return g
+			}
+		}
 	}
 }
 

commit beb9db8eb7aa38e8473ba48a3b4021fbba151d43
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Sep 18 15:59:27 2023 +0100

    Fix arrow handle snapping, snapping to text labels, selection of text labels (#1910)
    
    This PR:
    - adds `canSnap` as a property to handle and ignores snapping when
    dragging a handle that does not have `canSnap` set to true. Arrows no
    longer snap.
    - adds `isLabel` to Geometry2d
    - fixes selection on empty text labels
    - fixes vertices / snapping for empty text labels
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 9408dd100..370235c05 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -53,6 +53,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					id: 'start',
 					type: 'vertex',
 					canBind: false,
+					canSnap: true,
 					index: 'a1',
 					x: 0,
 					y: 0,
@@ -61,6 +62,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					id: 'end',
 					type: 'vertex',
 					canBind: false,
+					canSnap: true,
 					index: 'a2',
 					x: 0,
 					y: 0,

commit 5dc1436d808ce40013bda693cf6b754a3d49771c
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Tue Sep 19 13:16:38 2023 +0100

    Fix lines being draggable via their background (#1920)
    
    Fixes #1914
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Draw a line shape at a 45 degree angle.
    2. Select the line.
    3. Click and drag the empty space next to the line.
    4. It should select the canvas.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - None - unreleased bug

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 370235c05..01a394d23 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -41,6 +41,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override hideResizeHandles = () => true
 	override hideRotateHandle = () => true
 	override hideSelectionBoundsFg = () => true
+	override hideSelectionBoundsBg = () => true
 
 	override getDefaultProps(): TLLineShape['props'] {
 		return {

commit 73e61727cc0679993d0bf5293892bf045c8e101c
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Fri Sep 29 16:07:14 2023 +0100

    fix line bugs (#1936)
    
    closes #1913
    
    Some lines aren't rendering:
    <img width="500" alt="shapes"
    src="https://github.com/tldraw/tldraw/assets/98838967/bd01bb0f-a967-46ce-9056-a81421224931">
    
    When we begin drawing a line it's nice for the user to be able to see a
    dot, so we put down two points. The end point for a new line was set to
    the same position as the first point, which was causing a bunch of
    divide by zero errors. Offsetting it slightly fixes that.
    
    Now when two handles are too close together we extend the second one
    instead of drawing a third. This will probably only ever happen with the
    first two points of a line.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Select the Line tool and set spline to line and dash to draw
    2. Click around the canvas
    3. You should now be able to actually see a line
    4. Now set spline to cubic and dash to solid
    5. shift click around the canvas
    6. You should be able to see a line!
    
    ### Release Notes
    
    - This PR patches a couple of bugs which led to straight draw lines and
    beziered dash lines not rendering on the canvas
    
    Before & After:
    
    <image width="250"
    src="https://github.com/tldraw/tldraw/assets/98838967/e0ca7d54-506f-4014-b65a-6b61a98e3665"
    />
    <image width="250"
    src="https://github.com/tldraw/tldraw/assets/98838967/90c9fa12-1bcb-430d-80c7-97e1faacea16"
    />
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 01a394d23..fb667a897 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -65,8 +65,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					canBind: false,
 					canSnap: true,
 					index: 'a2',
-					x: 0,
-					y: 0,
+					x: 0.1,
+					y: 0.1,
 				},
 			},
 		}
@@ -243,11 +243,9 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 				)
 			}
 		}
-
 		// Cubic style spline
 		if (shape.props.spline === 'cubic') {
 			const splinePath = getSvgPathForLineGeometry(spline)
-
 			if (dash === 'solid') {
 				return (
 					<SVGContainer id={shape.id}>

commit d683cc09432197e89bddacf2b706b5eaad40e399
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 17:07:35 2023 +0000

    No impure getters pt9 (#2222)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index fb667a897..008d4a052 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -330,7 +330,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override toSvg(shape: TLLineShape) {
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
 		const color = theme[shape.props.color].solid
 		const spline = getGeometryForLineShape(shape)
 		const strokeWidth = STROKE_SIZES[shape.props.size]

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 008d4a052..b74136be6 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -8,7 +8,7 @@ import {
 	TLLineShape,
 	TLOnHandleChangeHandler,
 	TLOnResizeHandler,
-	Vec2d,
+	Vec,
 	WeakMapCache,
 	deepCopy,
 	getDefaultColorTheme,
@@ -408,7 +408,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 /** @public */
 export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
 	const { spline, handles } = shape.props
-	const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec2d.From)
+	const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec.From)
 
 	switch (spline) {
 		case 'cubic': {

commit 07cda7ef9fd9008c2feebce20659e2d087ddbdd3
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jan 24 10:19:20 2024 +0000

    arrows: add ability to change label placement (#2557)
    
    This adds the ability to drag the label on an arrow to a different
    location within the line segment/arc.
    
    
    https://github.com/tldraw/tldraw/assets/469604/dbd2ee35-bebc-48d6-b8ee-fcf12ce91fa5
    
    - A lot of the complexity lay in ensuring a fixed distance from the ends
    of the arrowheads.
    - I added a new type of handle `text-adjust` that makes the text box the
    very handle itself.
    - I added a `ARROW_HANDLES` enum - we should use more enums!
    - The bulk of the changes are in ArrowShapeUtil — check that out in
    particular obviously :)
    
    Along the way, I tried to improve a couple spots as I touched them:
    - added some more documentation to Vec.ts because some of the functions
    in there were obscure/new to me. (at least the naming, hah)
    - added `getPointOnCircle` which was being done in a couple places
    independently and refactored those places.
    
    ### Questions
    - the `getPointOnCircle` API changed. Is this considered breaking and/or
    should I leave the signature the same? Wasn't sure if it was a big deal
    or not.
    - I made `labelPosition` in the schema always but I guess it could have
    been optional? Lemme know if there's a preference.
    - Any feedback on tests? Happy to expand those if necessary.
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [x] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. For arrow in [straightArrow, curvedArrow] test the following:
       a. Label in the middle
       b. Label at both ends of the arrow
       c. Test arrows in different directions
    d. Rotating the endpoints and seeing that the label stays at the end of
    the arrow at a fixed width.
       e. Test different stroke widths.
       f. Test with different arrowheads.
    2. Also, test arcs that are more circle like than arc-like.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Adds ability to change label position on arrows.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index b74136be6..fef360338 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -6,7 +6,7 @@ import {
 	ShapeUtil,
 	TLHandle,
 	TLLineShape,
-	TLOnHandleChangeHandler,
+	TLOnHandleDragHandler,
 	TLOnResizeHandler,
 	Vec,
 	WeakMapCache,
@@ -129,7 +129,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
-	override onHandleChange: TLOnHandleChangeHandler<TLLineShape> = (shape, { handle }) => {
+	override onHandleDrag: TLOnHandleDragHandler<TLLineShape> = (shape, { handle }) => {
 		const next = deepCopy(shape)
 
 		switch (handle.id) {

commit 93c2ed615c61f09a3d4936c2ed06bcebd85cf363
Author: alex <alex@dytry.ch>
Date:   Wed Feb 14 17:53:30 2024 +0000

    [Snapping 1/5] Validation & strict types for fractional indexes  (#2827)
    
    Currently, we type our fractional index keys as `string` and don't have
    any validation for them. I'm touching some of this code for my work on
    line handles and wanted to change that:
    - fractional indexes are now `IndexKey`s, not `string`s. `IndexKey`s
    have a brand property so can't be used interchangeably with strings
    (like our IDs)
    - There's a new `T.indexKey` validator which we can use in our
    validations to make sure we don't end up with nonsense keys.
    
    This PR is part of a series - please don't merge it until the things
    before it have landed!
    1. #2827 (you are here)
    2. #2831
    3. #2793
    4. #2841
    5. #2845
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Mostly relying on unit & end to end tests here - no user facing
    changes.
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index fef360338..186eaa0f8 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -1,6 +1,7 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	CubicSpline2d,
+	IndexKey,
 	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
@@ -55,7 +56,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					type: 'vertex',
 					canBind: false,
 					canSnap: true,
-					index: 'a1',
+					index: 'a1' as IndexKey,
 					x: 0,
 					y: 0,
 				},
@@ -64,7 +65,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					type: 'vertex',
 					canBind: false,
 					canSnap: true,
-					index: 'a2',
+					index: 'a2' as IndexKey,
 					x: 0.1,
 					y: 0.1,
 				},

commit 4bfea7649d91fe15134e5028efd3439b703c6625
Author: alex <alex@dytry.ch>
Date:   Thu Feb 15 10:27:55 2024 +0000

    [Snapping 2/5] Fix line-handle mid-point snapping (#2831)
    
    Currently, only the end handles of the line tool snap. It should be all
    of them.
    
    Line handles work kind of weirdly at the moment: instead of just storing
    the positions, we store full `TLHandle` objects complete with IDs,
    `canSnap`/`canBind` properties, etc. Currently, all the handles get
    written to the store with `canSnap: false`, when really it should be up
    to the shape util to decide which handles are snappable.
    
    This diff replaces the current handles map (from arbitrary ID to
    `TLHandle`) with just the data we need: a map from index to x/y. The
    extra information that the `Editor` needs for `TLHandle` is hydrated at
    runtime (with `canSnap` set to `true` this time!)
    
    Fixes TLD-2200
    
    This PR is part of a series - please don't merge it until the things
    before it have landed!
    1. #2827
    2. #2831 (you are here)
    3. #2793
    4. #2841
    5. #2845
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Create a funky line shape on tldraw.com
    2. Paste it into staging and make sure it comes across ok
    3. Make some funky line shape in staging - make sure you use dragging,
    mid-point creation, and shift-clicking
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Simplify the contents of `TLLineShape.props.handles`

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 186eaa0f8..5f2e4c0e6 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -1,7 +1,6 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	CubicSpline2d,
-	IndexKey,
 	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
@@ -14,8 +13,10 @@ import {
 	deepCopy,
 	getDefaultColorTheme,
 	getIndexBetween,
+	getIndices,
 	lineShapeMigrations,
 	lineShapeProps,
+	objectMapEntries,
 	sortByIndex,
 } from '@tldraw/editor'
 
@@ -45,27 +46,18 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override hideSelectionBoundsBg = () => true
 
 	override getDefaultProps(): TLLineShape['props'] {
+		const [startIndex, endIndex] = getIndices(2)
 		return {
 			dash: 'draw',
 			size: 'm',
 			color: 'black',
 			spline: 'line',
 			handles: {
-				start: {
-					id: 'start',
-					type: 'vertex',
-					canBind: false,
-					canSnap: true,
-					index: 'a1' as IndexKey,
+				[startIndex]: {
 					x: 0,
 					y: 0,
 				},
-				end: {
-					id: 'end',
-					type: 'vertex',
-					canBind: false,
-					canSnap: true,
-					index: 'a2' as IndexKey,
+				[endIndex]: {
 					x: 0.1,
 					y: 0.1,
 				},
@@ -84,7 +76,18 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 			const spline = getGeometryForLineShape(shape)
 
-			const sortedHandles = Object.values(handles).sort(sortByIndex)
+			const sortedHandles = objectMapEntries(handles)
+				.map(
+					([index, handle]): TLHandle => ({
+						id: index,
+						index,
+						...handle,
+						type: 'vertex',
+						canBind: false,
+						canSnap: true,
+					})
+				)
+				.sort(sortByIndex)
 			const results = sortedHandles.slice()
 
 			// Add "create" handles between each vertex handle
@@ -99,6 +102,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 					index,
 					x: point.x,
 					y: point.y,
+					canSnap: true,
+					canBind: false,
 				})
 			}
 
@@ -118,9 +123,9 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 		const handles = deepCopy(shape.props.handles)
 
-		Object.values(shape.props.handles).forEach(({ id, x, y }) => {
-			handles[id].x = x * scaleX
-			handles[id].y = y * scaleY
+		objectMapEntries(shape.props.handles).forEach(([index, { x, y }]) => {
+			handles[index].x = x * scaleX
+			handles[index].y = y * scaleY
 		})
 
 		return {
@@ -131,45 +136,16 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override onHandleDrag: TLOnHandleDragHandler<TLLineShape> = (shape, { handle }) => {
-		const next = deepCopy(shape)
-
-		switch (handle.id) {
-			case 'start':
-			case 'end': {
-				next.props.handles[handle.id] = {
-					...next.props.handles[handle.id],
-					x: handle.x,
-					y: handle.y,
-				}
-				break
-			}
-
-			default: {
-				const id = 'handle:' + handle.index
-				const existing = shape.props.handles[id]
-
-				if (existing) {
-					next.props.handles[id] = {
-						...existing,
-						x: handle.x,
-						y: handle.y,
-					}
-				} else {
-					next.props.handles[id] = {
-						id,
-						type: 'vertex',
-						canBind: false,
-						index: handle.index,
-						x: handle.x,
-						y: handle.y,
-					}
-				}
-
-				break
-			}
+		return {
+			...shape,
+			props: {
+				...shape.props,
+				handles: {
+					...shape.props.handles,
+					[handle.index]: { x: handle.x, y: handle.y },
+				},
+			},
 		}
-
-		return next
 	}
 
 	component(shape: TLLineShape) {
@@ -409,7 +385,10 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 /** @public */
 export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
 	const { spline, handles } = shape.props
-	const handlePoints = Object.values(handles).sort(sortByIndex).map(Vec.From)
+	const handlePoints = objectMapEntries(handles)
+		.map(([index, position]) => ({ index, ...position }))
+		.sort(sortByIndex)
+		.map(Vec.From)
 
 	switch (spline) {
 		case 'cubic': {

commit 89881397b51281bc48e213ee081fdd22dd4232fe
Author: alex <alex@dytry.ch>
Date:   Thu Feb 15 15:22:48 2024 +0000

    [Snapping 4/5] Add handle-point snapping (#2841)
    
    Currently, when dragging line handles they'll snap to the outlines of
    other shapes, but not to their vertices. This can make it hard to snap
    precisely to certain key places, like the handles of other lines, or the
    corners of `geo` shapes.
    
    This diff adds a new snap type for handles - snapping to points:
    
    ![Kapture 2024-02-14 at 16 30
    41](https://github.com/tldraw/tldraw/assets/1489520/046109d3-2961-463f-bf71-9350ea1204bc)
    
    This adds to the new snapping API so the snapping points can very easily
    be customised on a shape-by-shape basis. Closes TLD-2198
    
    This PR is part of a series - please don't merge it until the things
    before it have landed!
    1. #2827
    2. #2831
    3. #2793
    4. #2841 (you are here)
    5. #2845
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. create a line shape
    2. drag its handles whilst holding command
    3. it should snap to the outlines of other shapes, vertices of other
    line shapes, and the bounding box corners/center of most 'boxy' shapes
    (geo, embed, etc)
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Line handles

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 5f2e4c0e6..2461de820 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -380,6 +380,12 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			}
 		}
 	}
+
+	override getHandleSnapGeometry(shape: TLLineShape) {
+		return {
+			points: Object.values(shape.props.handles),
+		}
+	}
 }
 
 /** @public */

commit 212eb88480bd66b5b2930768e1594f814b8da150
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Fri Feb 16 13:54:48 2024 +0000

    Add component for viewing an image of a snapshot  (#2804)
    
    This PR adds the `TldrawImage` component that displays a tldraw snapshot
    as an SVG image.
    
    ![2024-02-15 at 12 29 52 - Coral
    Cod](https://github.com/tldraw/tldraw/assets/15892272/14140e9e-7d6d-4dd3-88a3-86a6786325c5)
    
    ## Why
    
    We've seen requests for this kind of thing from users. eg: GitBook, and
    on discord:
    
    <img width="710" alt="image"
    src="https://github.com/tldraw/tldraw/assets/15892272/3d3a3e9d-66b9-42e7-81de-a70aa7165bdc">
    
    The component provides a way to do that.
    This PR also untangles various bits of editor state from image
    exporting, which makes it easier for library users to export images more
    agnostically. (ie: they can now export any shapes on any page in any
    theme. previously, they had to change the user's state to do that).
    
    ## What else
    
    - This PR also adds an **Image snapshot** example to demonstrate the new
    component.
    - We now pass an `isDarkMode` property to the `toSvg` method (inside the
    `ctx` argument). This means that `toSvg` doesn't have to rely on editor
    state anymore. I updated all our `toSvg` methods to use it.
    - See code comments for more info.
    
    ## Any issues?
    
    When you toggle to editing mode in the new example, text measurements
    are initially wrong (until you edit the size of a text shape). Click on
    the text shape to see how its indicator is wrong. Not sure why this is,
    or if it's even related. Does it ring a bell with anyone? If not, I'll
    take a closer look. (fixed, see comments --steve)
    
    ## Future work
    
    Now that we've untangled image exporting from editor state, we could
    expose some more helpful helpers for making this easier.
    
    Fixes tld-2122
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Open the **Image snapshot** example.
    2. Try editing the image, saving the image, and making sure the image
    updates.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Dev: Added the `TldrawImage` component.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 2461de820..509e26833 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -4,6 +4,7 @@ import {
 	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
+	SvgExportContext,
 	TLHandle,
 	TLLineShape,
 	TLOnHandleDragHandler,
@@ -306,8 +307,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		return <path d={path} />
 	}
 
-	override toSvg(shape: TLLineShape) {
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
+	override toSvg(shape: TLLineShape, ctx: SvgExportContext) {
+		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
 		const color = theme[shape.props.color].solid
 		const spline = getGeometryForLineShape(shape)
 		const strokeWidth = STROKE_SIZES[shape.props.size]

commit 31ce1c1a89bea4adf96b14708a6c8993993724d5
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Feb 19 17:10:31 2024 +0000

    [handles] Line shape handles -> points (#2856)
    
    This PR replaces the line shape's `handles` prop with `points`, an array
    of `VecModel`s.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    - [x] Unit Tests
    - [ ] End to end tests

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 509e26833..4e9ba62e7 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -11,13 +11,11 @@ import {
 	TLOnResizeHandler,
 	Vec,
 	WeakMapCache,
-	deepCopy,
+	ZERO_INDEX_KEY,
 	getDefaultColorTheme,
-	getIndexBetween,
-	getIndices,
+	getIndexAbove,
 	lineShapeMigrations,
 	lineShapeProps,
-	objectMapEntries,
 	sortByIndex,
 } from '@tldraw/editor'
 
@@ -47,22 +45,21 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override hideSelectionBoundsBg = () => true
 
 	override getDefaultProps(): TLLineShape['props'] {
-		const [startIndex, endIndex] = getIndices(2)
 		return {
 			dash: 'draw',
 			size: 'm',
 			color: 'black',
 			spline: 'line',
-			handles: {
-				[startIndex]: {
+			points: [
+				{
 					x: 0,
 					y: 0,
 				},
-				[endIndex]: {
+				{
 					x: 0.1,
 					y: 0.1,
 				},
-			},
+			],
 		}
 	}
 
@@ -73,39 +70,40 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	override getHandles(shape: TLLineShape) {
 		return handlesCache.get(shape.props, () => {
-			const handles = shape.props.handles
-
 			const spline = getGeometryForLineShape(shape)
 
-			const sortedHandles = objectMapEntries(handles)
-				.map(
-					([index, handle]): TLHandle => ({
-						id: index,
-						index,
-						...handle,
-						type: 'vertex',
-						canBind: false,
-						canSnap: true,
-					})
-				)
-				.sort(sortByIndex)
-			const results = sortedHandles.slice()
+			const results: TLHandle[] = []
+
+			const { points } = shape.props
 
-			// Add "create" handles between each vertex handle
-			for (let i = 0; i < spline.segments.length; i++) {
-				const segment = spline.segments[i]
-				const point = segment.midPoint()
-				const index = getIndexBetween(sortedHandles[i].index, sortedHandles[i + 1].index)
+			let index = ZERO_INDEX_KEY
 
+			for (let i = 0; i < points.length; i++) {
+				const handle = points[i]
 				results.push({
-					id: `mid-${i}`,
-					type: 'create',
+					...handle,
+					id: index,
 					index,
-					x: point.x,
-					y: point.y,
-					canSnap: true,
+					type: 'vertex',
 					canBind: false,
+					canSnap: true,
 				})
+				index = getIndexAbove(index)
+
+				if (i < points.length - 1) {
+					const segment = spline.segments[i]
+					const point = segment.midPoint()
+					results.push({
+						id: index,
+						type: 'create',
+						index,
+						x: point.x,
+						y: point.y,
+						canSnap: true,
+						canBind: false,
+					})
+					index = getIndexAbove(index)
+				}
 			}
 
 			return results.sort(sortByIndex)
@@ -122,29 +120,38 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override onResize: TLOnResizeHandler<TLLineShape> = (shape, info) => {
 		const { scaleX, scaleY } = info
 
-		const handles = deepCopy(shape.props.handles)
-
-		objectMapEntries(shape.props.handles).forEach(([index, { x, y }]) => {
-			handles[index].x = x * scaleX
-			handles[index].y = y * scaleY
-		})
-
 		return {
 			props: {
-				handles,
+				points: shape.props.points.map(({ x, y }) => {
+					return {
+						x: x * scaleX,
+						y: y * scaleY,
+					}
+				}),
 			},
 		}
 	}
 
 	override onHandleDrag: TLOnHandleDragHandler<TLLineShape> = (shape, { handle }) => {
+		// we should only ever be dragging vertex handles
+		if (handle.type !== 'vertex') {
+			return shape
+		}
+
+		// get the index of the point to which the vertex handle corresponds
+		const index = this.getHandles(shape)
+			.filter((h) => h.type === 'vertex')
+			.findIndex((h) => h.id === handle.id)!
+
+		// splice in the new point
+		const points = [...shape.props.points]
+		points[index] = { x: handle.x, y: handle.y }
+
 		return {
 			...shape,
 			props: {
 				...shape.props,
-				handles: {
-					...shape.props.handles,
-					[handle.index]: { x: handle.x, y: handle.y },
-				},
+				points,
 			},
 		}
 	}
@@ -384,18 +391,15 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	override getHandleSnapGeometry(shape: TLLineShape) {
 		return {
-			points: Object.values(shape.props.handles),
+			points: shape.props.points,
 		}
 	}
 }
 
 /** @public */
 export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
-	const { spline, handles } = shape.props
-	const handlePoints = objectMapEntries(handles)
-		.map(([index, position]) => ({ index, ...position }))
-		.sort(sortByIndex)
-		.map(Vec.From)
+	const { spline, points } = shape.props
+	const handlePoints = points.map(Vec.From)
 
 	switch (spline) {
 		case 'cubic': {

commit 50f77fe75c5962e61a628e58faa52ef218e68d14
Author: alex <alex@dytry.ch>
Date:   Mon Feb 19 17:27:29 2024 +0000

    [Snapping 6/6] Self-snapping API (#2869)
    
    This diff adds a self-snapping API for handles. Self-snapping is used
    when a shape's handles want to snap to the shape itself. By default,
    this isn't allowed because moving the handle might move the snap point,
    which creates a janky user experience.
    
    Now, shapes can return customised versions of their normal handle
    snapping geometry in these cases. As a bonus, line shapes now snap to
    other handles on their own line!
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Line handles should snap to other handles on the same line when
    holding command
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Line handles now snap to other handles on the same line when holding
    command
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 4e9ba62e7..9c580cc41 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -1,6 +1,8 @@
 /* eslint-disable react-hooks/rules-of-hooks */
 import {
 	CubicSpline2d,
+	Group2d,
+	HandleSnapGeometry,
 	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
@@ -110,11 +112,6 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		})
 	}
 
-	override getOutlineSegments(shape: TLLineShape) {
-		const spline = this.editor.getShapeGeometry(shape) as Polyline2d | CubicSpline2d
-		return spline.segments.map((s) => s.vertices)
-	}
-
 	//   Events
 
 	override onResize: TLOnResizeHandler<TLLineShape> = (shape, info) => {
@@ -389,9 +386,34 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
-	override getHandleSnapGeometry(shape: TLLineShape) {
+	override getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {
+		const { points } = shape.props
 		return {
-			points: shape.props.points,
+			points,
+			getSelfSnapPoints: (handle) => {
+				const index = this.getHandles(shape)
+					.filter((h) => h.type === 'vertex')
+					.findIndex((h) => h.id === handle.id)!
+
+				// We want to skip the current and adjacent handles
+				return points.filter((_, i) => Math.abs(i - index) > 1).map(Vec.From)
+			},
+			getSelfSnapOutline: (handle) => {
+				// We want to skip the segments that include the handle, so
+				// find the index of the handle that shares the same index property
+				// as the initial dragging handle; this catches a quirk of create handles
+				const index = this.getHandles(shape)
+					.filter((h) => h.type === 'vertex')
+					.findIndex((h) => h.id === handle.id)!
+
+				// Get all the outline segments from the shape that don't include the handle
+				const segments = getGeometryForLineShape(shape).segments.filter(
+					(_, i) => i !== index - 1 && i !== index
+				)
+
+				if (!segments.length) return null
+				return new Group2d({ children: segments })
+			},
 		}
 	}
 }

commit fd4b5c6291bd3efe8ad461e4b546953737ad5dc9
Author: alex <alex@dytry.ch>
Date:   Wed Feb 21 10:06:14 2024 +0000

    Add line IDs & fractional indexes (#2890)
    
    In #2856, we moved changed line handles into an array of points. This
    introduced an issue where some concurrent operations wouldn't work
    because they array indexes change. We need some sort of stable way of
    referring to these points. Our existing fractional indexing system is a
    good fit.
    
    In this version, instead of making the points be a map from index to
    x/y, we make the points be a map from id (the index) to
    x/y/index/id(also index). This is "kinda silly" (steve's words) but
    might be more familiar to devs who are expecting maps to be keyed on IDs
    rather than anything else.
    
    ### Change Type
    
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 9c580cc41..635c393f9 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -13,11 +13,12 @@ import {
 	TLOnResizeHandler,
 	Vec,
 	WeakMapCache,
-	ZERO_INDEX_KEY,
 	getDefaultColorTheme,
-	getIndexAbove,
+	getIndexBetween,
+	getIndices,
 	lineShapeMigrations,
 	lineShapeProps,
+	mapObjectMapValues,
 	sortByIndex,
 } from '@tldraw/editor'
 
@@ -47,21 +48,16 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override hideSelectionBoundsBg = () => true
 
 	override getDefaultProps(): TLLineShape['props'] {
+		const [start, end] = getIndices(2)
 		return {
 			dash: 'draw',
 			size: 'm',
 			color: 'black',
 			spline: 'line',
-			points: [
-				{
-					x: 0,
-					y: 0,
-				},
-				{
-					x: 0.1,
-					y: 0.1,
-				},
-			],
+			points: {
+				[start]: { id: start, index: start, x: 0, y: 0 },
+				[end]: { id: end, index: end, x: 0.1, y: 0.1 },
+			},
 		}
 	}
 
@@ -74,38 +70,26 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		return handlesCache.get(shape.props, () => {
 			const spline = getGeometryForLineShape(shape)
 
-			const results: TLHandle[] = []
-
-			const { points } = shape.props
-
-			let index = ZERO_INDEX_KEY
-
-			for (let i = 0; i < points.length; i++) {
-				const handle = points[i]
+			const points = linePointsToArray(shape)
+			const results: TLHandle[] = points.map((point) => ({
+				...point,
+				id: point.index,
+				type: 'vertex',
+				canSnap: true,
+			}))
+
+			for (let i = 0; i < points.length - 1; i++) {
+				const index = getIndexBetween(points[i].index, points[i + 1].index)
+				const segment = spline.segments[i]
+				const point = segment.midPoint()
 				results.push({
-					...handle,
 					id: index,
+					type: 'create',
 					index,
-					type: 'vertex',
-					canBind: false,
+					x: point.x,
+					y: point.y,
 					canSnap: true,
 				})
-				index = getIndexAbove(index)
-
-				if (i < points.length - 1) {
-					const segment = spline.segments[i]
-					const point = segment.midPoint()
-					results.push({
-						id: index,
-						type: 'create',
-						index,
-						x: point.x,
-						y: point.y,
-						canSnap: true,
-						canBind: false,
-					})
-					index = getIndexAbove(index)
-				}
 			}
 
 			return results.sort(sortByIndex)
@@ -119,36 +103,28 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 		return {
 			props: {
-				points: shape.props.points.map(({ x, y }) => {
-					return {
-						x: x * scaleX,
-						y: y * scaleY,
-					}
-				}),
+				points: mapObjectMapValues(shape.props.points, (_, { id, index, x, y }) => ({
+					id,
+					index,
+					x: x * scaleX,
+					y: y * scaleY,
+				})),
 			},
 		}
 	}
 
 	override onHandleDrag: TLOnHandleDragHandler<TLLineShape> = (shape, { handle }) => {
 		// we should only ever be dragging vertex handles
-		if (handle.type !== 'vertex') {
-			return shape
-		}
-
-		// get the index of the point to which the vertex handle corresponds
-		const index = this.getHandles(shape)
-			.filter((h) => h.type === 'vertex')
-			.findIndex((h) => h.id === handle.id)!
-
-		// splice in the new point
-		const points = [...shape.props.points]
-		points[index] = { x: handle.x, y: handle.y }
+		if (handle.type !== 'vertex') return
 
 		return {
 			...shape,
 			props: {
 				...shape.props,
-				points,
+				points: {
+					...shape.props.points,
+					[handle.id]: { id: handle.id, index: handle.index, x: handle.x, y: handle.y },
+				},
 			},
 		}
 	}
@@ -387,7 +363,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {
-		const { points } = shape.props
+		const points = linePointsToArray(shape)
 		return {
 			points,
 			getSelfSnapPoints: (handle) => {
@@ -418,17 +394,20 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 }
 
+function linePointsToArray(shape: TLLineShape) {
+	return Object.values(shape.props.points).sort(sortByIndex)
+}
+
 /** @public */
 export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Polyline2d {
-	const { spline, points } = shape.props
-	const handlePoints = points.map(Vec.From)
+	const points = linePointsToArray(shape).map(Vec.From)
 
-	switch (spline) {
+	switch (shape.props.spline) {
 		case 'cubic': {
-			return new CubicSpline2d({ points: handlePoints })
+			return new CubicSpline2d({ points })
 		}
 		case 'line': {
-			return new Polyline2d({ points: handlePoints })
+			return new Polyline2d({ points })
 		}
 	}
 }

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 635c393f9..03158d50e 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -1,4 +1,3 @@
-/* eslint-disable react-hooks/rules-of-hooks */
 import {
 	CubicSpline2d,
 	Group2d,
@@ -6,14 +5,12 @@ import {
 	Polyline2d,
 	SVGContainer,
 	ShapeUtil,
-	SvgExportContext,
 	TLHandle,
 	TLLineShape,
 	TLOnHandleDragHandler,
 	TLOnResizeHandler,
 	Vec,
 	WeakMapCache,
-	getDefaultColorTheme,
 	getIndexBetween,
 	getIndices,
 	lineShapeMigrations,
@@ -29,7 +26,6 @@ import { getDrawLinePathData } from '../shared/polygon-helpers'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import {
 	getSvgPathForBezierCurve,
-	getSvgPathForCubicSpline,
 	getSvgPathForEdge,
 	getSvgPathForLineGeometry,
 } from './components/svg'
@@ -130,139 +126,11 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	component(shape: TLLineShape) {
-		const theme = useDefaultColorTheme()
-		const spline = getGeometryForLineShape(shape)
-		const strokeWidth = STROKE_SIZES[shape.props.size]
-
-		const { dash, color } = shape.props
-
-		// Line style lines
-		if (shape.props.spline === 'line') {
-			if (dash === 'solid') {
-				const outline = spline.points
-				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
-						<path d={pathData} stroke={theme[color].solid} strokeWidth={strokeWidth} fill="none" />
-					</SVGContainer>
-				)
-			}
-
-			if (dash === 'dashed' || dash === 'dotted') {
-				const outline = spline.points
-				const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
-						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
-							{spline.segments.map((segment, i) => {
-								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-									segment.length,
-									strokeWidth,
-									{
-										style: dash,
-										start: i > 0 ? 'outset' : 'none',
-										end: i < spline.segments.length - 1 ? 'outset' : 'none',
-									}
-								)
-
-								return (
-									<path
-										key={i}
-										strokeDasharray={strokeDasharray}
-										strokeDashoffset={strokeDashoffset}
-										d={getSvgPathForEdge(segment as any, true)}
-										fill="none"
-									/>
-								)
-							})}
-						</g>
-					</SVGContainer>
-				)
-			}
-
-			if (dash === 'draw') {
-				const outline = spline.points
-				const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
-
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={innerPathData} fill={'none'} color={color} theme={theme} />
-						<path
-							d={outerPathData}
-							stroke={theme[color].solid}
-							strokeWidth={strokeWidth}
-							fill="none"
-						/>
-					</SVGContainer>
-				)
-			}
-		}
-		// Cubic style spline
-		if (shape.props.spline === 'cubic') {
-			const splinePath = getSvgPathForLineGeometry(spline)
-			if (dash === 'solid') {
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-						<path
-							strokeWidth={strokeWidth}
-							stroke={theme[color].solid}
-							fill="none"
-							d={splinePath}
-						/>
-					</SVGContainer>
-				)
-			}
-
-			if (dash === 'dashed' || dash === 'dotted') {
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-						<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
-							{spline.segments.map((segment, i) => {
-								const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-									segment.length,
-									strokeWidth,
-									{
-										style: dash,
-										start: i > 0 ? 'outset' : 'none',
-										end: i < spline.segments.length - 1 ? 'outset' : 'none',
-									}
-								)
-
-								return (
-									<path
-										key={i}
-										strokeDasharray={strokeDasharray}
-										strokeDashoffset={strokeDashoffset}
-										d={getSvgPathForBezierCurve(segment as any, true)}
-										fill="none"
-									/>
-								)
-							})}
-						</g>
-					</SVGContainer>
-				)
-			}
-
-			if (dash === 'draw') {
-				return (
-					<SVGContainer id={shape.id}>
-						<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-						<path
-							d={getLineDrawPath(shape, spline, strokeWidth)}
-							strokeWidth={1}
-							stroke={theme[color].solid}
-							fill={theme[color].solid}
-						/>
-					</SVGContainer>
-				)
-			}
-		}
+		return (
+			<SVGContainer id={shape.id}>
+				<LineShapeSvg shape={shape} />
+			</SVGContainer>
+		)
 	}
 
 	indicator(shape: TLLineShape) {
@@ -287,79 +155,8 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		return <path d={path} />
 	}
 
-	override toSvg(shape: TLLineShape, ctx: SvgExportContext) {
-		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
-		const color = theme[shape.props.color].solid
-		const spline = getGeometryForLineShape(shape)
-		const strokeWidth = STROKE_SIZES[shape.props.size]
-
-		switch (shape.props.dash) {
-			case 'draw': {
-				let pathData: string
-				if (spline instanceof CubicSpline2d) {
-					pathData = getLineDrawPath(shape, spline, strokeWidth)
-				} else {
-					const [_, outerPathData] = getDrawLinePathData(shape.id, spline.points, strokeWidth)
-					pathData = outerPathData
-				}
-
-				const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-				p.setAttribute('stroke-width', strokeWidth + 'px')
-				p.setAttribute('stroke', color)
-				p.setAttribute('fill', 'none')
-				p.setAttribute('d', pathData)
-
-				return p
-			}
-			case 'solid': {
-				let pathData: string
-
-				if (spline instanceof CubicSpline2d) {
-					pathData = getSvgPathForCubicSpline(spline, false)
-				} else {
-					const outline = spline.points
-					pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-				}
-
-				const p = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-				p.setAttribute('stroke-width', strokeWidth + 'px')
-				p.setAttribute('stroke', color)
-				p.setAttribute('fill', 'none')
-				p.setAttribute('d', pathData)
-
-				return p
-			}
-			default: {
-				const { segments } = spline
-
-				const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-				g.setAttribute('stroke', color)
-				g.setAttribute('stroke-width', strokeWidth.toString())
-
-				const fn = spline instanceof CubicSpline2d ? getSvgPathForBezierCurve : getSvgPathForEdge
-
-				segments.forEach((segment, i) => {
-					const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-					const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-						segment.length,
-						strokeWidth,
-						{
-							style: shape.props.dash,
-							start: i > 0 ? 'outset' : 'none',
-							end: i < segments.length - 1 ? 'outset' : 'none',
-						}
-					)
-
-					path.setAttribute('stroke-dasharray', strokeDasharray.toString())
-					path.setAttribute('stroke-dashoffset', strokeDashoffset.toString())
-					path.setAttribute('d', fn(segment as any, true))
-					path.setAttribute('fill', 'none')
-					g.appendChild(path)
-				})
-
-				return g
-			}
-		}
+	override toSvg(shape: TLLineShape) {
+		return <LineShapeSvg shape={shape} />
 	}
 
 	override getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {
@@ -411,3 +208,134 @@ export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Pol
 		}
 	}
 }
+
+function LineShapeSvg({ shape }: { shape: TLLineShape }) {
+	const theme = useDefaultColorTheme()
+	const spline = getGeometryForLineShape(shape)
+	const strokeWidth = STROKE_SIZES[shape.props.size]
+
+	const { dash, color } = shape.props
+
+	// Line style lines
+	if (shape.props.spline === 'line') {
+		if (dash === 'solid') {
+			const outline = spline.points
+			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
+
+			return (
+				<>
+					<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
+					<path d={pathData} stroke={theme[color].solid} strokeWidth={strokeWidth} fill="none" />
+				</>
+			)
+		}
+
+		if (dash === 'dashed' || dash === 'dotted') {
+			const outline = spline.points
+			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
+
+			return (
+				<>
+					<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
+					<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
+						{spline.segments.map((segment, i) => {
+							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+								segment.length,
+								strokeWidth,
+								{
+									style: dash,
+									start: i > 0 ? 'outset' : 'none',
+									end: i < spline.segments.length - 1 ? 'outset' : 'none',
+								}
+							)
+
+							return (
+								<path
+									key={i}
+									strokeDasharray={strokeDasharray}
+									strokeDashoffset={strokeDashoffset}
+									d={getSvgPathForEdge(segment as any, true)}
+									fill="none"
+								/>
+							)
+						})}
+					</g>
+				</>
+			)
+		}
+
+		if (dash === 'draw') {
+			const outline = spline.points
+			const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
+
+			return (
+				<>
+					<ShapeFill d={innerPathData} fill={'none'} color={color} theme={theme} />
+					<path
+						d={outerPathData}
+						stroke={theme[color].solid}
+						strokeWidth={strokeWidth}
+						fill="none"
+					/>
+				</>
+			)
+		}
+	}
+	// Cubic style spline
+	if (shape.props.spline === 'cubic') {
+		const splinePath = getSvgPathForLineGeometry(spline)
+		if (dash === 'solid') {
+			return (
+				<>
+					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
+					<path strokeWidth={strokeWidth} stroke={theme[color].solid} fill="none" d={splinePath} />
+				</>
+			)
+		}
+
+		if (dash === 'dashed' || dash === 'dotted') {
+			return (
+				<>
+					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
+					<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
+						{spline.segments.map((segment, i) => {
+							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+								segment.length,
+								strokeWidth,
+								{
+									style: dash,
+									start: i > 0 ? 'outset' : 'none',
+									end: i < spline.segments.length - 1 ? 'outset' : 'none',
+								}
+							)
+
+							return (
+								<path
+									key={i}
+									strokeDasharray={strokeDasharray}
+									strokeDashoffset={strokeDashoffset}
+									d={getSvgPathForBezierCurve(segment as any, true)}
+									fill="none"
+								/>
+							)
+						})}
+					</g>
+				</>
+			)
+		}
+
+		if (dash === 'draw') {
+			return (
+				<>
+					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
+					<path
+						d={getLineDrawPath(shape, spline, strokeWidth)}
+						strokeWidth={1}
+						stroke={theme[color].solid}
+						fill={theme[color].solid}
+					/>
+				</>
+			)
+		}
+	}
+}

commit 91903c97614f3645dcbdcf6986fd5e4ca3dd95dc
Author: alex <alex@dytry.ch>
Date:   Thu May 9 10:48:01 2024 +0100

    Move arrow helpers from editor to tldraw (#3721)
    
    With the new work on bindings, we no longer need to keep any arrows
    stuff hard-coded in `editor`, so let's move it to `tldraw` with the rest
    of the shapes.
    
    Couple other changes as part of this:
    - We had two different types of `WeakMap` backed cache, but we now only
    have one
    - There's a new free-standing version of `createComputedCache` that
    doesn't need access to the editor/store in order to create the cache.
    instead, it returns a `{get(editor, id)}` object and instantiates the
    cache on a per-editor basis for each call.
    - Fixed a bug in `createSelectedComputedCache` where the selector
    derivation would get re-created on every call to `get`
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `improvement` — Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    - `editor.getArrowInfo(shape)` has been replaced with
    `getArrowInfo(editor, shape)`
    - `editor.getArrowsBoundTo(shape)` has been removed. Instead, use
    `editor.getBindingsToShape(shape, 'arrow')` and follow the `fromId` of
    each binding to the corresponding arrow shape
    - These types have moved from `@tldraw/editor` to `tldraw`:
        - `TLArcInfo`
        - `TLArrowInfo`
        - `TLArrowPoint`
    - `WeakMapCache` has been removed

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 03158d50e..fd1f970a6 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -10,7 +10,7 @@ import {
 	TLOnHandleDragHandler,
 	TLOnResizeHandler,
 	Vec,
-	WeakMapCache,
+	WeakCache,
 	getIndexBetween,
 	getIndices,
 	lineShapeMigrations,
@@ -30,7 +30,7 @@ import {
 	getSvgPathForLineGeometry,
 } from './components/svg'
 
-const handlesCache = new WeakMapCache<TLLineShape['props'], TLHandle[]>()
+const handlesCache = new WeakCache<TLLineShape['props'], TLHandle[]>()
 
 /** @public */
 export class LineShapeUtil extends ShapeUtil<TLLineShape> {

commit ef44d71ee2a83bb3d6d61cac7717c4254941019d
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri May 24 14:04:28 2024 +0100

    Add heart geo shape (#3787)
    
    This PR adds a heart geo shape. ❤️
    
    It also:
    - adds `toSvgPathData` to geometry2d
    - uses geometry2d in places where previously we recalculated things like
    perimeter of ellipse
    - flattens geo shape util components
    
    - [x] Calculate the path length for the DashStyleHeart
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Release Notes
    
    - Adds a heart shape to the geo shape set.

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index fd1f970a6..a4ac1f0dd 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -22,13 +22,8 @@ import {
 import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { STROKE_SIZES } from '../shared/default-shape-constants'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
-import { getDrawLinePathData } from '../shared/polygon-helpers'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
-import {
-	getSvgPathForBezierCurve,
-	getSvgPathForEdge,
-	getSvgPathForLineGeometry,
-} from './components/svg'
+import { getDrawLinePathData } from './line-helpers'
 
 const handlesCache = new WeakCache<TLLineShape['props'], TLHandle[]>()
 
@@ -254,7 +249,7 @@ function LineShapeSvg({ shape }: { shape: TLLineShape }) {
 									key={i}
 									strokeDasharray={strokeDasharray}
 									strokeDashoffset={strokeDashoffset}
-									d={getSvgPathForEdge(segment as any, true)}
+									d={segment.getSvgPathData(true)}
 									fill="none"
 								/>
 							)
@@ -283,7 +278,7 @@ function LineShapeSvg({ shape }: { shape: TLLineShape }) {
 	}
 	// Cubic style spline
 	if (shape.props.spline === 'cubic') {
-		const splinePath = getSvgPathForLineGeometry(spline)
+		const splinePath = spline.getSvgPathData()
 		if (dash === 'solid') {
 			return (
 				<>
@@ -314,7 +309,7 @@ function LineShapeSvg({ shape }: { shape: TLLineShape }) {
 									key={i}
 									strokeDasharray={strokeDasharray}
 									strokeDashoffset={strokeDashoffset}
-									d={getSvgPathForBezierCurve(segment as any, true)}
+									d={segment.getSvgPathData()}
 									fill="none"
 								/>
 							)

commit ac149c1014fb5f0539d7c55f0f10ce2a05a23f74
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jun 16 19:58:13 2024 +0300

    Dynamic size mode + fill fill (#3835)
    
    This PR adds a user preference for "dynamic size mode" where the scale
    of shapes (text size, stroke width) is relative to the current zoom
    level. This means that the stroke width in screen pixels (or text size
    in screen pixels) is identical regardless of zoom level.
    
    ![Kapture 2024-05-27 at 05 23
    21](https://github.com/tldraw/tldraw/assets/23072548/f247ecce-bfcd-4f85-b7a5-d7677b38e4d8)
    
    - [x] Draw shape
    - [x] Text shape
    - [x] Highlighter shape
    - [x] Geo shape
    - [x] Arrow shape
    - [x] Note shape
    - [x] Line shape
    
    Embed shape?
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    1. Use the tools.
    2. Change zoom
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - Adds a dynamic size user preferences.
    - Removes double click to reset scale on text shapes.
    - Removes double click to reset autosize on text shapes.
    
    ---------
    
    Co-authored-by: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index a4ac1f0dd..2cf0a7b5f 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -19,9 +19,9 @@ import {
 	sortByIndex,
 } from '@tldraw/editor'
 
-import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { STROKE_SIZES } from '../shared/default-shape-constants'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getDrawLinePathData } from './line-helpers'
 
@@ -49,6 +49,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 				[start]: { id: start, index: start, x: 0, y: 0 },
 				[end]: { id: end, index: end, x: 0.1, y: 0.1 },
 			},
+			scale: 1,
 		}
 	}
 
@@ -129,7 +130,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	indicator(shape: TLLineShape) {
-		const strokeWidth = STROKE_SIZES[shape.props.size]
+		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 		const spline = getGeometryForLineShape(shape)
 		const { dash } = shape.props
 
@@ -151,7 +152,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	}
 
 	override toSvg(shape: TLLineShape) {
-		return <LineShapeSvg shape={shape} />
+		return <LineShapeSvg shouldScale shape={shape} />
 	}
 
 	override getHandleSnapGeometry(shape: TLLineShape): HandleSnapGeometry {
@@ -204,12 +205,23 @@ export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Pol
 	}
 }
 
-function LineShapeSvg({ shape }: { shape: TLLineShape }) {
+function LineShapeSvg({
+	shape,
+	shouldScale = false,
+}: {
+	shape: TLLineShape
+	shouldScale?: boolean
+}) {
 	const theme = useDefaultColorTheme()
+
 	const spline = getGeometryForLineShape(shape)
-	const strokeWidth = STROKE_SIZES[shape.props.size]
+	const { dash, color, size } = shape.props
+
+	const scaleFactor = 1 / shape.props.scale
+
+	const scale = shouldScale ? scaleFactor : 1
 
-	const { dash, color } = shape.props
+	const strokeWidth = STROKE_SIZES[size] * shape.props.scale
 
 	// Line style lines
 	if (shape.props.spline === 'line') {
@@ -218,61 +230,56 @@ function LineShapeSvg({ shape }: { shape: TLLineShape }) {
 			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
 
 			return (
-				<>
-					<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
-					<path d={pathData} stroke={theme[color].solid} strokeWidth={strokeWidth} fill="none" />
-				</>
+				<path
+					d={pathData}
+					stroke={theme[color].solid}
+					strokeWidth={strokeWidth}
+					fill="none"
+					transform={`scale(${scale})`}
+				/>
 			)
 		}
 
 		if (dash === 'dashed' || dash === 'dotted') {
-			const outline = spline.points
-			const pathData = 'M' + outline[0] + 'L' + outline.slice(1)
-
 			return (
-				<>
-					<ShapeFill d={pathData} fill={'none'} color={color} theme={theme} />
-					<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
-						{spline.segments.map((segment, i) => {
-							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-								segment.length,
-								strokeWidth,
-								{
-									style: dash,
-									start: i > 0 ? 'outset' : 'none',
-									end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								}
-							)
-
-							return (
-								<path
-									key={i}
-									strokeDasharray={strokeDasharray}
-									strokeDashoffset={strokeDashoffset}
-									d={segment.getSvgPathData(true)}
-									fill="none"
-								/>
-							)
-						})}
-					</g>
-				</>
+				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
+					{spline.segments.map((segment, i) => {
+						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+							segment.length,
+							strokeWidth,
+							{
+								style: dash,
+								start: i > 0 ? 'outset' : 'none',
+								end: i < spline.segments.length - 1 ? 'outset' : 'none',
+							}
+						)
+
+						return (
+							<path
+								key={i}
+								strokeDasharray={strokeDasharray}
+								strokeDashoffset={strokeDashoffset}
+								d={segment.getSvgPathData(true)}
+								fill="none"
+							/>
+						)
+					})}
+				</g>
 			)
 		}
 
 		if (dash === 'draw') {
 			const outline = spline.points
-			const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
+			const [_, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth)
 
 			return (
-				<>
-					<ShapeFill d={innerPathData} fill={'none'} color={color} theme={theme} />
-					<path
-						d={outerPathData}
-						stroke={theme[color].solid}
-						strokeWidth={strokeWidth}
-						fill="none"
-					/>
-				</>
+				<path
+					d={outerPathData}
+					stroke={theme[color].solid}
+					strokeWidth={strokeWidth}
+					fill="none"
+					transform={`scale(${scale})`}
+				/>
 			)
 		}
 	}
@@ -281,55 +288,53 @@ function LineShapeSvg({ shape }: { shape: TLLineShape }) {
 		const splinePath = spline.getSvgPathData()
 		if (dash === 'solid') {
 			return (
-				<>
-					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-					<path strokeWidth={strokeWidth} stroke={theme[color].solid} fill="none" d={splinePath} />
-				</>
+				<path
+					strokeWidth={strokeWidth}
+					stroke={theme[color].solid}
+					fill="none"
+					d={splinePath}
+					transform={`scale(${scale})`}
+				/>
 			)
 		}
 
 		if (dash === 'dashed' || dash === 'dotted') {
 			return (
-				<>
-					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-					<g stroke={theme[color].solid} strokeWidth={strokeWidth}>
-						{spline.segments.map((segment, i) => {
-							const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-								segment.length,
-								strokeWidth,
-								{
-									style: dash,
-									start: i > 0 ? 'outset' : 'none',
-									end: i < spline.segments.length - 1 ? 'outset' : 'none',
-								}
-							)
-
-							return (
-								<path
-									key={i}
-									strokeDasharray={strokeDasharray}
-									strokeDashoffset={strokeDashoffset}
-									d={segment.getSvgPathData()}
-									fill="none"
-								/>
-							)
-						})}
-					</g>
-				</>
+				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
+					{spline.segments.map((segment, i) => {
+						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+							segment.length,
+							strokeWidth,
+							{
+								style: dash,
+								start: i > 0 ? 'outset' : 'none',
+								end: i < spline.segments.length - 1 ? 'outset' : 'none',
+							}
+						)
+
+						return (
+							<path
+								key={i}
+								strokeDasharray={strokeDasharray}
+								strokeDashoffset={strokeDashoffset}
+								d={segment.getSvgPathData()}
+								fill="none"
+							/>
+						)
+					})}
+				</g>
 			)
 		}
 
 		if (dash === 'draw') {
 			return (
-				<>
-					<ShapeFill d={splinePath} fill={'none'} color={color} theme={theme} />
-					<path
-						d={getLineDrawPath(shape, spline, strokeWidth)}
-						strokeWidth={1}
-						stroke={theme[color].solid}
-						fill={theme[color].solid}
-					/>
-				</>
+				<path
+					d={getLineDrawPath(shape, spline, strokeWidth)}
+					strokeWidth={1}
+					stroke={theme[color].solid}
+					fill={theme[color].solid}
+					transform={`scale(${scale})`}
+				/>
 			)
 		}
 	}

commit 66ae584e070dfcb10dad71d23e1a08c8bcc02681
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Jul 22 10:46:40 2024 +0100

    Interpolated line points (#4188)
    
    Line shape points animate pretty nicely
    
    ![2024-07-16 at 12 21 17 - Blush
    Limpet](https://github.com/user-attachments/assets/6918cfdb-448c-49e4-b8da-36f9cae13f22)
    
    I wanted to do the same for the spline, but I think it would require
    messing around with how the props are structured. My idea would be to
    turn spline into a number between 0 and 1, and have the SVG render
    lerped points between the Cubic Bezier and Line edges.
    
    It seemed like quite an intense change for a feature that would rarely
    be used so I decided to skip it.
    
    If there's a better way, let me know!
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fixed a bug with…
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 2cf0a7b5f..a470fac52 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -7,12 +7,16 @@ import {
 	ShapeUtil,
 	TLHandle,
 	TLLineShape,
+	TLLineShapePoint,
 	TLOnHandleDragHandler,
 	TLOnResizeHandler,
 	Vec,
 	WeakCache,
+	ZERO_INDEX_KEY,
+	getIndexAbove,
 	getIndexBetween,
 	getIndices,
+	lerp,
 	lineShapeMigrations,
 	lineShapeProps,
 	mapObjectMapValues,
@@ -185,6 +189,69 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 			},
 		}
 	}
+	override getInterpolatedProps(
+		startShape: TLLineShape,
+		endShape: TLLineShape,
+		progress: number
+	): TLLineShape['props'] {
+		const startPoints = linePointsToArray(startShape)
+		const endPoints = linePointsToArray(endShape)
+
+		const pointsToUseStart: TLLineShapePoint[] = []
+		const pointsToUseEnd: TLLineShapePoint[] = []
+
+		let index = ZERO_INDEX_KEY
+
+		if (startPoints.length > endPoints.length) {
+			// we'll need to expand points
+			for (let i = 0; i < startPoints.length; i++) {
+				pointsToUseStart[i] = { ...startPoints[i] }
+				if (endPoints[i] === undefined) {
+					pointsToUseEnd[i] = { ...endPoints[endPoints.length - 1], id: index }
+				} else {
+					pointsToUseEnd[i] = { ...endPoints[i], id: index }
+				}
+				index = getIndexAbove(index)
+			}
+		} else if (endPoints.length > startPoints.length) {
+			// we'll need to converge points
+			for (let i = 0; i < endPoints.length; i++) {
+				pointsToUseEnd[i] = { ...endPoints[i] }
+				if (startPoints[i] === undefined) {
+					pointsToUseStart[i] = {
+						...startPoints[startPoints.length - 1],
+						id: index,
+					}
+				} else {
+					pointsToUseStart[i] = { ...startPoints[i], id: index }
+				}
+				index = getIndexAbove(index)
+			}
+		} else {
+			// noop, easy
+			for (let i = 0; i < endPoints.length; i++) {
+				pointsToUseStart[i] = startPoints[i]
+				pointsToUseEnd[i] = endPoints[i]
+			}
+		}
+
+		return {
+			...endShape.props,
+			points: Object.fromEntries(
+				pointsToUseStart.map((point, i) => {
+					const endPoint = pointsToUseEnd[i]
+					return [
+						point.id,
+						{
+							...point,
+							x: lerp(point.x, endPoint.x, progress),
+							y: lerp(point.y, endPoint.y, progress),
+						},
+					]
+				})
+			),
+		}
+	}
 }
 
 function linePointsToArray(shape: TLLineShape) {

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index a470fac52..4a5b27fa9 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -6,10 +6,10 @@ import {
 	SVGContainer,
 	ShapeUtil,
 	TLHandle,
+	TLHandleDragInfo,
 	TLLineShape,
 	TLLineShapePoint,
-	TLOnHandleDragHandler,
-	TLOnResizeHandler,
+	TLResizeInfo,
 	Vec,
 	WeakCache,
 	ZERO_INDEX_KEY,
@@ -37,10 +37,18 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	static override props = lineShapeProps
 	static override migrations = lineShapeMigrations
 
-	override hideResizeHandles = () => true
-	override hideRotateHandle = () => true
-	override hideSelectionBoundsFg = () => true
-	override hideSelectionBoundsBg = () => true
+	override hideResizeHandles() {
+		return true
+	}
+	override hideRotateHandle() {
+		return true
+	}
+	override hideSelectionBoundsFg() {
+		return true
+	}
+	override hideSelectionBoundsBg() {
+		return true
+	}
 
 	override getDefaultProps(): TLLineShape['props'] {
 		const [start, end] = getIndices(2)
@@ -94,7 +102,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	//   Events
 
-	override onResize: TLOnResizeHandler<TLLineShape> = (shape, info) => {
+	override onResize(shape: TLLineShape, info: TLResizeInfo<TLLineShape>) {
 		const { scaleX, scaleY } = info
 
 		return {
@@ -109,7 +117,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
-	override onHandleDrag: TLOnHandleDragHandler<TLLineShape> = (shape, { handle }) => {
+	override onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {
 		// we should only ever be dragging vertex handles
 		if (handle.type !== 'vertex') return
 

commit 306c5c0204cfc3ed838b5f3378219a410d32b458
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Jul 29 15:58:59 2024 +0100

    draw: fix dotted line rendering when zoomed out (#4261)
    
    Fixes https://github.com/tldraw/tldraw/issues/1995
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Draw: fix dotted line shape rendering when zoomed out greatly.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 4a5b27fa9..2748042f8 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -23,8 +23,8 @@ import {
 	sortByIndex,
 } from '@tldraw/editor'
 
+import { getPerfectDashProps } from '../../..'
 import { STROKE_SIZES } from '../shared/default-shape-constants'
-import { getPerfectDashProps } from '../shared/getPerfectDashProps'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getDrawLinePathData } from './line-helpers'
@@ -283,9 +283,11 @@ export function getGeometryForLineShape(shape: TLLineShape): CubicSpline2d | Pol
 function LineShapeSvg({
 	shape,
 	shouldScale = false,
+	forceSolid = false,
 }: {
 	shape: TLLineShape
 	shouldScale?: boolean
+	forceSolid?: boolean
 }) {
 	const theme = useDefaultColorTheme()
 
@@ -319,15 +321,13 @@ function LineShapeSvg({
 			return (
 				<g stroke={theme[color].solid} strokeWidth={strokeWidth} transform={`scale(${scale})`}>
 					{spline.segments.map((segment, i) => {
-						const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-							segment.length,
-							strokeWidth,
-							{
-								style: dash,
-								start: i > 0 ? 'outset' : 'none',
-								end: i < spline.segments.length - 1 ? 'outset' : 'none',
-							}
-						)
+						const { strokeDasharray, strokeDashoffset } = forceSolid
+							? { strokeDasharray: 'none', strokeDashoffset: 'none' }
+							: getPerfectDashProps(segment.length, strokeWidth, {
+									style: dash,
+									start: i > 0 ? 'outset' : 'none',
+									end: i < spline.segments.length - 1 ? 'outset' : 'none',
+								})
 
 						return (
 							<path
@@ -384,6 +384,7 @@ function LineShapeSvg({
 								style: dash,
 								start: i > 0 ? 'outset' : 'none',
 								end: i < spline.segments.length - 1 ? 'outset' : 'none',
+								forceSolid,
 							}
 						)
 

commit 46fec0b2ee8230c3f943e8f26ffaacf45aa21f17
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Sat Aug 3 13:06:02 2024 +0100

    Interpolation: draw/highlight points, discrete props (#4241)
    
    Draw shapes and highlighter shape points now animate between states.
    
    ![2024-07-22 at 13 44 45 - Teal
    Sparrow](https://github.com/user-attachments/assets/92de6f2c-7b84-415e-b81b-94264a1341d9)
    
    There is some repetition of logic between the function that animates
    draw points and the one that animates lines. However, I felt that the
    structure of draw shapes and lines is different enough that generalising
    the function would add complexity and sacrifice readability, and didn't
    seem worth it just to remove a small amount of repetition. Very happy to
    change that should anyone disagree.
    
    Image shape crop property animates to the new position
    
    ![2024-07-22 at 15 39 30 - Purple
    Cattle](https://github.com/user-attachments/assets/fb108a48-6ed0-4f49-a232-fa806c78aa97)
    
    
    Discrete props (props that don't have continuous values to animate
    along) now change in the middle of the animation. It's likely that
    continuous animation will be happening at the same time, making the
    change in the middle of that movement helps smooth over the abruptness
    of that change.
    
    This is what it looks like if they change at the start:
    
    ![2024-07-18 at 13 11 32 - Amaranth
    Primate](https://github.com/user-attachments/assets/50570507-0b0a-4f61-a710-a180b7ddb00f)
    
    
    This is what it looks like when the props change halfway:
    
    ![2024-07-18 at 13 12 40 - Teal
    Gerbil](https://github.com/user-attachments/assets/48a28e62-901a-45db-8d30-4a5a18b5960f)
    
    
    The text usually changes at the halfway mark, but if there's no text to
    begin with, then any text in the end shape is streamed in:
    
    ![2024-07-18 at 15 18 34 - Tan
    Catshark](https://github.com/user-attachments/assets/ed59122c-7f52-4f57-94d5-9382ff8d62b1)
    
    Question: Do we want tests for this?
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Animate a shape between different states
    2. It should change its discrete props at the midway point of the
    animation, and animate smoothly for continuous values such as dimension
    or position.
    
    ### Release notes
    
    - Added getInterpolated props method for all shapes, including draw and
    highlighter.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 2748042f8..7b26eeff5 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -16,6 +16,7 @@ import {
 	getIndexAbove,
 	getIndexBetween,
 	getIndices,
+	getPerfectDashProps,
 	lerp,
 	lineShapeMigrations,
 	lineShapeProps,
@@ -23,8 +24,7 @@ import {
 	sortByIndex,
 } from '@tldraw/editor'
 
-import { getPerfectDashProps } from '../../..'
-import { STROKE_SIZES } from '../shared/default-shape-constants'
+import { STROKE_SIZES } from '../arrow/shared'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getLineDrawPath, getLineIndicatorPath } from './components/getLinePath'
 import { getDrawLinePathData } from './line-helpers'
@@ -200,7 +200,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override getInterpolatedProps(
 		startShape: TLLineShape,
 		endShape: TLLineShape,
-		progress: number
+		t: number
 	): TLLineShape['props'] {
 		const startPoints = linePointsToArray(startShape)
 		const endPoints = linePointsToArray(endShape)
@@ -244,7 +244,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 
 		return {
-			...endShape.props,
+			...(t > 0.5 ? endShape.props : startShape.props),
 			points: Object.fromEntries(
 				pointsToUseStart.map((point, i) => {
 					const endPoint = pointsToUseEnd[i]
@@ -252,12 +252,13 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 						point.id,
 						{
 							...point,
-							x: lerp(point.x, endPoint.x, progress),
-							y: lerp(point.y, endPoint.y, progress),
+							x: lerp(point.x, endPoint.x, t),
+							y: lerp(point.y, endPoint.y, t),
 						},
 					]
 				})
 			),
+			scale: lerp(startShape.props.scale, endShape.props.scale, t),
 		}
 	}
 }

commit f060f35c57f75946a5914083c1dcac8344727e4e
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Oct 3 23:02:46 2024 +0200

    Fix an issue with nearest point and lines that start and end at the same point (#4650)
    
    This fixes an issue with getting the nearest point to a line for lines
    that start and end at the same point.
    
    Not sure how those lines got created though. Programatically we seem to
    allow that, so I also added a `onBeforeHandler` to line shape util that
    will nudge the end point just slightly if we try to create a line like
    that. We could also avoid creating it completely?
    
    [Example sentry
    report](https://tldraw.sentry.io/issues/5936469482/?alert_rule_id=12855294&alert_timestamp=1727804797951&alert_type=email&environment=production&notification_uuid=3482b5d8-ad95-48ca-be09-40c77af5fcf2&project=4504203639193600&referrer=alert_email)
    for this issue.
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a line shape programatically and make the start and end point
    be the same. Think it has to start and end at (0,0) but not sure.
    2. Brush select.
    3. This used to throw an error since we could not get the distance to
    line, but that should no longer be happening.
    
    ### Release notes
    
    - Fix a bug with nearest points for lines that start and end at the same
    point.

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 7b26eeff5..e2fd26c12 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -117,6 +117,33 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 		}
 	}
 
+	override onBeforeCreate(next: TLLineShape): void | TLLineShape {
+		const {
+			props: { points },
+		} = next
+		const pointKeys = Object.keys(points)
+
+		if (pointKeys.length < 2) {
+			return
+		}
+
+		const firstPoint = points[pointKeys[0]]
+		const allSame = pointKeys.every((key) => {
+			const point = points[key]
+			return point.x === firstPoint.x && point.y === firstPoint.y
+		})
+		if (allSame) {
+			const lastKey = pointKeys[pointKeys.length - 1]
+			points[lastKey] = {
+				...points[lastKey],
+				x: points[lastKey].x + 0.1,
+				y: points[lastKey].y + 0.1,
+			}
+			return next
+		}
+		return
+	}
+
 	override onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {
 		// we should only ever be dragging vertex handles
 		if (handle.type !== 'vertex') return

commit d5f4c1d05bb834ab5623d19d418e31e4ab5afa66
Author: alex <alex@dytry.ch>
Date:   Wed Oct 9 15:55:15 2024 +0100

    make sure DOM IDs are globally unique (#4694)
    
    There are a lot of places where we currently derive a DOM ID from a
    shape ID. This works fine (ish) on tldraw.com, but doesn't work for a
    lot of developer use-cases: if there are multiple tldraw instances or
    exports happening, for example. This is because the DOM expects IDs to
    be globally unique. If there are multiple elements with the same ID in
    the dom, only the first is ever used. This can cause issues if e.g.
    
    1. i have a shape with a clip-path determined by the shape ID
    2. i export that shape and add the resulting SVG to the dom. now, there
    are two clip paths with the same ID, but they're the same
    3. I change the shape - and now, the ID is referring to the export, so i
    get weird rendering issues.
    
    This diff attempts to resolve this issue and prevent it from happening
    again by introducing a new `SafeId` type, and helpers for generating and
    working with `SafeId`s. in tldraw, jsx using the `id` attribute will now
    result in a type error if the value isn't a safe ID. This doesn't affect
    library consumers writing JSX.
    
    As part of this, I've removed the ID that were added to certain shapes.
    Instead, all shapes now have a `data-shape-id` attribute on their
    wrapper.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Exports and other tldraw instances no longer can affect how each other
    are rendered
    - **BREAKING:** the `id` attribute that was present on some shapes in
    the dom has been removed. there's now a data-shape-id attribute on every
    shape wrapper instead though.

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index e2fd26c12..b1d625e51 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -162,7 +162,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	component(shape: TLLineShape) {
 		return (
-			<SVGContainer id={shape.id}>
+			<SVGContainer>
 				<LineShapeSvg shape={shape} />
 			</SVGContainer>
 		)

commit 106c984c74945d5cba15176dff695ec2a8746308
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Wed Nov 13 11:51:30 2024 +0000

    Snap to grid when creating shapes (#4875)
    
    TLD-2817
    
    TLD-2816
    
    This PR makes sure that shapes snap to the grid when created. It adds a
    ```maybeSnapToGrid``` function, which can be used to push a shape onto
    the grid if grid mode is enabled, both when click-creating and when
    drag-creating.
    
    1. Any shapes using the basebox shape tool (i.e frames)
    2. Geo shapes
    3. Both arrow handles
    4. Line shapes, including shift-clicking
    5. Note shapes (when translating, note shapes prefer adjacent note
    positions over grid)
    6. Text shapes
    7. Aligns uploaded assets using the top left of the selection bounds.
    8. Does not snap to the grid when snap indicators are being shown
    
    It also adds tests for this behaviour
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Enable grid
    9. Click-create a note shape off the grid
    10. It should snap to the grid
    11. Add an asset, it should align with the grid
    
    - [x] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Shapes snap to grid on creation, or when adding points.
    
    ---------
    
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index b1d625e51..1a92a7061 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -21,6 +21,7 @@ import {
 	lineShapeMigrations,
 	lineShapeProps,
 	mapObjectMapValues,
+	maybeSnapToGrid,
 	sortByIndex,
 } from '@tldraw/editor'
 
@@ -147,14 +148,14 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	override onHandleDrag(shape: TLLineShape, { handle }: TLHandleDragInfo<TLLineShape>) {
 		// we should only ever be dragging vertex handles
 		if (handle.type !== 'vertex') return
-
+		const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 		return {
 			...shape,
 			props: {
 				...shape.props,
 				points: {
 					...shape.props.points,
-					[handle.id]: { id: handle.id, index: handle.index, x: handle.x, y: handle.y },
+					[handle.id]: { id: handle.id, index: handle.index, x: newPoint.x, y: newPoint.y },
 				},
 			},
 		}

commit 092eed678ca40cb7b3f51ee9c839019034409342
Author: James Vaughan <james@jamesbvaughan.com>
Date:   Wed Jan 29 06:07:59 2025 -0500

    Fix line wobble issue (#5281)
    
    This fixes an issue where line shapes would wobble if you dragged points
    in a way that changes the shape's overall size after moving the first
    point away from the shape's origin point.
    
    ![2025-01-24 09 51
    21](https://github.com/user-attachments/assets/1509bc85-3e8e-41ad-98c5-2d8e4391b865)
    
    This re-introduces part of this fix from #1915

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index 1a92a7061..edbc1399e 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -163,7 +163,7 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 
 	component(shape: TLLineShape) {
 		return (
-			<SVGContainer>
+			<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>
 				<LineShapeSvg shape={shape} />
 			</SVGContainer>
 		)

commit 629125a2e474effa3536411584aaac8f77657673
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Apr 3 16:07:49 2025 +0100

    a11y: navigable shapes (#5761)
    
    As part of a [larger push](https://github.com/tldraw/tldraw/issues/5215)
    to add accessibility to our SDK, a big piece of that work is being able
    to navigate through our shapes in some kind of predictable fashion. This
    builds upon @Taha-Hassan-Git 's great work and knowledge in this area,
    thanks man. :tip-o-the-hat:
    
    Things that were tackled in this PR:
    - navigating shapes using the Tab key, when in the Select tool.
    - navigating shapes using Cmd/Ctrl+Arrow keys, when in the Select tool.
    - only allowing certain shapes to be navigated to. We ignore
    draw/highlighter/arrow/group/line. Groups need exploration and will be
    tackled later.
    - panning the camera to the selected shape, but avoiding doing so in a
    jarring way. We don't center the shape to avoid too much whiplashy-ness.
    
    An initial foray into this was relaying purely on DOM but it had a bunch
    of browser quirks which forced making this purely a programmatic control
    on our end. Things like ensuring culled shapes are still accessible even
    though they're not rendered was one of the issues but also tab order
    became unpredictable at times which steered me away from that direction.
    
    We coud have considered using something like rbush for some spatial
    indexing of the shapes. For the intents and purposes of this PR, it
    seemed like overkill at the moment. But we might cross that bridge down
    the line, we'll see.
    
    The reading-direction heuristics are a combination of dividing the pages
    into rows and then looking at distance and angles to see what is the
    spatially "next" shape to be read. It takes _all_ of the shapes and
    sorts them into a logical order so that nothing is missed/skipped when
    tabbing around.
    The directional-arrow heuristics don't divide things into rows and don't
    create a sorted set of shapes. Instead, they decide based on the current
    shape and direction which is the next spatially to go to, depending on
    distance+angle.
    
    There's a decent amount of nuance in this kind of navigation but it's
    not all covered in this PR, for separate PRs, we'll look at:
    - [x] adding a "skipping to content" button
    - [ ] question whether maybe directional navigation visits ‘canTabTo’
    shapes, maybe yes?
    - [ ] tackling what Enter/Escape should do when on the canvas shapes
    - [ ] how to deal with hierarchy / parent-child / frame / group shapes
    - [ ] and more
    
    
    
    https://github.com/user-attachments/assets/49b6b34e-2553-4047-846f-5d3383e1e3c6
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - a11y: navigable shapes using Tab and Cmd/Ctrl+Arrow

diff --git a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
index edbc1399e..f5abb1807 100644
--- a/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/line/LineShapeUtil.tsx
@@ -38,6 +38,9 @@ export class LineShapeUtil extends ShapeUtil<TLLineShape> {
 	static override props = lineShapeProps
 	static override migrations = lineShapeMigrations
 
+	override canTabTo() {
+		return false
+	}
 	override hideResizeHandles() {
 		return true
 	}

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    