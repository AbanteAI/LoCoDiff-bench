<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx - Grok 3</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx</h1>
        <p><a href="../../../cases/x-ai_grok-3-beta/tldraw_packages_tldraw_src_lib_shapes_arrow_ArrowShapeUtil.tsx.html">← Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx

commit b7d9c8684cb6cf7bd710af5420135ea3516cc3bf
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jul 17 22:22:34 2023 +0100

    tldraw zero - package shuffle (#1710)
    
    This PR moves code between our packages so that:
    - @tldraw/editor is a “core” library with the engine and canvas but no
    shapes, tools, or other things
    - @tldraw/tldraw contains everything particular to the experience we’ve
    built for tldraw
    
    At first look, this might seem like a step away from customization and
    configuration, however I believe it greatly increases the configuration
    potential of the @tldraw/editor while also providing a more accurate
    reflection of what configuration options actually exist for
    @tldraw/tldraw.
    
    ## Library changes
    
    @tldraw/editor re-exports its dependencies and @tldraw/tldraw re-exports
    @tldraw/editor.
    
    - users of @tldraw/editor WITHOUT @tldraw/tldraw should almost always
    only import things from @tldraw/editor.
    - users of @tldraw/tldraw should almost always only import things from
    @tldraw/tldraw.
    
    - @tldraw/polyfills is merged into @tldraw/editor
    - @tldraw/indices is merged into @tldraw/editor
    - @tldraw/primitives is merged mostly into @tldraw/editor, partially
    into @tldraw/tldraw
    - @tldraw/file-format is merged into @tldraw/tldraw
    - @tldraw/ui is merged into @tldraw/tldraw
    
    Many (many) utils and other code is moved from the editor to tldraw. For
    example, embeds now are entirely an feature of @tldraw/tldraw. The only
    big chunk of code left in core is related to arrow handling.
    
    ## API Changes
    
    The editor can now be used without tldraw's assets. We load them in
    @tldraw/tldraw instead, so feel free to use whatever fonts or images or
    whatever that you like with the editor.
    
    All tools and shapes (except for the `Group` shape) are moved to
    @tldraw/tldraw. This includes the `select` tool.
    
    You should use the editor with at least one tool, however, so you now
    also need to send in an `initialState` prop to the Editor /
    <TldrawEditor> component indicating which state the editor should begin
    in.
    
    The `components` prop now also accepts `SelectionForeground`.
    
    The complex selection component that we use for tldraw is moved to
    @tldraw/tldraw. The default component is quite basic but can easily be
    replaced via the `components` prop. We pass down our tldraw-flavored
    SelectionFg via `components`.
    
    Likewise with the `Scribble` component: the `DefaultScribble` no longer
    uses our freehand tech and is a simple path instead. We pass down the
    tldraw-flavored scribble via `components`.
    
    The `ExternalContentManager` (`Editor.externalContentManager`) is
    removed and replaced with a mapping of types to handlers.
    
    - Register new content handlers with
    `Editor.registerExternalContentHandler`.
    - Register new asset creation handlers (for files and URLs) with
    `Editor.registerExternalAssetHandler`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [@tldraw/editor] lots, wip
    - [@tldraw/ui] gone, merged to tldraw/tldraw
    - [@tldraw/polyfills] gone, merged to tldraw/editor
    - [@tldraw/primitives] gone, merged to tldraw/editor / tldraw/tldraw
    - [@tldraw/indices] gone, merged to tldraw/editor
    - [@tldraw/file-format] gone, merged to tldraw/tldraw
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
new file mode 100644
index 000000000..c149bee87
--- /dev/null
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -0,0 +1,1145 @@
+import {
+	Box2d,
+	ComputedCache,
+	DefaultFontFamilies,
+	EMPTY_ARRAY,
+	Matrix2d,
+	SVGContainer,
+	ShapeUtil,
+	SvgExportContext,
+	TLArrowShape,
+	TLArrowShapeArrowheadStyle,
+	TLDefaultColorStyle,
+	TLDefaultColorTheme,
+	TLDefaultFillStyle,
+	TLHandle,
+	TLOnEditEndHandler,
+	TLOnHandleChangeHandler,
+	TLOnResizeHandler,
+	TLOnTranslateStartHandler,
+	TLShapeId,
+	TLShapePartial,
+	TLShapeUtilCanvasSvgDef,
+	TLShapeUtilFlag,
+	Vec2d,
+	Vec2dModel,
+	VecLike,
+	arrowShapeMigrations,
+	arrowShapeProps,
+	computed,
+	deepCopy,
+	getArrowTerminalsInArrowSpace,
+	getArrowheadPathForType,
+	getCurvedArrowHandlePath,
+	getDefaultColorTheme,
+	getPointOnCircle,
+	getSolidCurvedArrowPath,
+	getSolidStraightArrowPath,
+	getStraightArrowHandlePath,
+	last,
+	linesIntersect,
+	longAngleDist,
+	minBy,
+	pointInPolygon,
+	shortAngleDist,
+	toDomPrecision,
+} from '@tldraw/editor'
+import React from 'react'
+import { ShapeFill, getShapeFillSvg, useDefaultColorTheme } from '../shared/ShapeFill'
+import { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'
+import {
+	ARROW_LABEL_FONT_SIZES,
+	FONT_FAMILIES,
+	STROKE_SIZES,
+	TEXT_PROPS,
+} from '../shared/default-shape-constants'
+import {
+	getFillDefForCanvas,
+	getFillDefForExport,
+	getFontDefForExport,
+} from '../shared/defaultStyleDefs'
+import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { ArrowTextLabel } from './components/ArrowTextLabel'
+
+let globalRenderIndex = 0
+
+/** @public */
+export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
+	static override type = 'arrow' as const
+	static override props = arrowShapeProps
+	static override migrations = arrowShapeMigrations
+
+	override canEdit = () => true
+	override canBind = () => false
+	override isClosed = () => false
+	override canSnap = () => true
+	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
+
+	override getDefaultProps(): TLArrowShape['props'] {
+		return {
+			dash: 'draw',
+			size: 'm',
+			fill: 'none',
+			color: 'black',
+			labelColor: 'black',
+			bend: 0,
+			start: { type: 'point', x: 0, y: 0 },
+			end: { type: 'point', x: 0, y: 0 },
+			arrowheadStart: 'none',
+			arrowheadEnd: 'arrow',
+			text: '',
+			font: 'draw',
+		}
+	}
+
+	getBounds(shape: TLArrowShape) {
+		return Box2d.FromPoints(this.getOutlineWithoutLabel(shape))
+	}
+
+	getOutlineWithoutLabel(shape: TLArrowShape): Vec2d[] {
+		const info = this.editor.getArrowInfo(shape)
+
+		if (!info) {
+			return []
+		}
+
+		if (info.isStraight) {
+			if (info.isValid) {
+				return [Vec2d.From(info.start.point), Vec2d.From(info.end.point)]
+			} else {
+				return [new Vec2d(0, 0), new Vec2d(1, 1)]
+			}
+		}
+
+		if (!info.isValid) {
+			return [new Vec2d(0, 0), new Vec2d(1, 1)]
+		}
+
+		const pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16))
+
+		if (pointsToPush <= 0 && !isFinite(pointsToPush)) {
+			return [new Vec2d(0, 0), new Vec2d(1, 1)]
+		}
+
+		const results: Vec2d[] = Array(pointsToPush)
+
+		const startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point)
+		const endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point)
+
+		const a = info.bodyArc.sweepFlag ? endAngle : startAngle
+		const b = info.bodyArc.sweepFlag ? startAngle : endAngle
+		const l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b)
+
+		const r = Math.max(1, info.bodyArc.radius)
+
+		for (let i = 0; i < pointsToPush; i++) {
+			const t = i / (pointsToPush - 1)
+			const angle = a + l * t
+			const point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle)
+			results[i] = point
+		}
+
+		return results
+	}
+
+	override getOutline(shape: TLArrowShape): Vec2d[] {
+		const outlineWithoutLabel = this.getOutlineWithoutLabel(shape)
+
+		const labelBounds = this.getLabelBounds(shape)
+		if (!labelBounds) {
+			return outlineWithoutLabel
+		}
+
+		const sides = labelBounds.sides
+		const sideIndexes = [0, 1, 2, 3]
+
+		// start with the first point...
+		let prevPoint = outlineWithoutLabel[0]
+		let didAddLabel = false
+		const result = [prevPoint]
+		for (let i = 1; i < outlineWithoutLabel.length; i++) {
+			// ...and use the next point to form a line segment for the outline.
+			const nextPoint = outlineWithoutLabel[i]
+
+			if (!didAddLabel) {
+				// find the index of the side of the label bounds that intersects the line segment
+				const nearestIntersectingSideIndex = minBy(
+					sideIndexes.filter((sideIndex) =>
+						linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)
+					),
+					(sideIndex) =>
+						Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)
+				)
+
+				// if we've found one, start at that index and trace around all four corners of the label bounds
+				if (nearestIntersectingSideIndex !== undefined) {
+					const intersectingPoint = Vec2d.NearestPointOnLineSegment(
+						sides[nearestIntersectingSideIndex][0],
+						sides[nearestIntersectingSideIndex][1],
+						prevPoint
+					)
+
+					result.push(intersectingPoint)
+					for (let j = 0; j < 4; j++) {
+						const sideIndex = (nearestIntersectingSideIndex + j) % 4
+						result.push(sides[sideIndex][1])
+					}
+					result.push(intersectingPoint)
+
+					// we've added the label, so we can just continue with the rest of the outline as normal
+					didAddLabel = true
+				}
+			}
+
+			result.push(nextPoint)
+			prevPoint = nextPoint
+		}
+
+		return result
+	}
+
+	override snapPoints(_shape: TLArrowShape): Vec2d[] {
+		return EMPTY_ARRAY
+	}
+
+	override getHandles(shape: TLArrowShape): TLHandle[] {
+		const info = this.editor.getArrowInfo(shape)!
+		return [
+			{
+				id: 'start',
+				type: 'vertex',
+				index: 'a0',
+				x: info.start.handle.x,
+				y: info.start.handle.y,
+				canBind: true,
+			},
+			{
+				id: 'middle',
+				type: 'vertex',
+				index: 'a2',
+				x: info.middle.x,
+				y: info.middle.y,
+				canBind: false,
+			},
+			{
+				id: 'end',
+				type: 'vertex',
+				index: 'a3',
+				x: info.end.handle.x,
+				y: info.end.handle.y,
+				canBind: true,
+			},
+		]
+	}
+
+	override onHandleChange: TLOnHandleChangeHandler<TLArrowShape> = (
+		shape,
+		{ handle, isPrecise }
+	) => {
+		const next = deepCopy(shape)
+
+		switch (handle.id) {
+			case 'start':
+			case 'end': {
+				const pageTransform = this.editor.getPageTransformById(next.id)!
+				const pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle)
+
+				if (this.editor.inputs.ctrlKey) {
+					next.props[handle.id] = {
+						type: 'point',
+						x: handle.x,
+						y: handle.y,
+					}
+				} else {
+					const target = last(
+						this.editor.sortedShapesArray.filter((hitShape) => {
+							if (hitShape.id === shape.id) {
+								// We're testing against the arrow
+								return
+							}
+
+							const util = this.editor.getShapeUtil(hitShape)
+							if (!util.canBind(hitShape)) {
+								// The shape can't be bound to
+								return
+							}
+
+							// Check the page mask
+							const pageMask = this.editor.getPageMaskById(hitShape.id)
+							if (pageMask) {
+								if (!pointInPolygon(pointInPageSpace, pageMask)) return
+							}
+
+							const pointInTargetSpace = this.editor.getPointInShapeSpace(
+								hitShape,
+								pointInPageSpace
+							)
+
+							if (util.isClosed(hitShape)) {
+								// Test the polygon
+								return pointInPolygon(pointInTargetSpace, this.editor.getOutline(hitShape))
+							}
+
+							// Test the point using the shape's idea of what a hit is
+							return util.hitTestPoint(hitShape, pointInTargetSpace)
+						})
+					)
+
+					if (target) {
+						const targetBounds = this.editor.getBounds(target)
+						const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
+
+						const prevHandle = next.props[handle.id]
+
+						const startBindingId =
+							shape.props.start.type === 'binding' && shape.props.start.boundShapeId
+						const endBindingId = shape.props.end.type === 'binding' && shape.props.end.boundShapeId
+
+						let precise =
+							// If externally precise, then always precise
+							isPrecise ||
+							// If the other handle is bound to the same shape, then precise
+							((startBindingId || endBindingId) && startBindingId === endBindingId) ||
+							// If the other shape is not closed, then precise
+							!this.editor.getShapeUtil(target).isClosed(next)
+
+						if (
+							// If we're switching to a new bound shape, then precise only if moving slowly
+							prevHandle.type === 'point' ||
+							(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)
+						) {
+							precise = this.editor.inputs.pointerVelocity.len() < 0.5
+						}
+
+						if (precise) {
+							// Funky math but we want the snap distance to be 4 at the minimum and either
+							// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
+							precise =
+								Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
+								Math.max(
+									4,
+									Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)
+								) /
+									this.editor.zoomLevel
+						}
+
+						next.props[handle.id] = {
+							type: 'binding',
+							boundShapeId: target.id,
+							normalizedAnchor: precise
+								? {
+										x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
+										y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
+								  }
+								: { x: 0.5, y: 0.5 },
+							isExact: this.editor.inputs.altKey,
+						}
+					} else {
+						next.props[handle.id] = {
+							type: 'point',
+							x: handle.x,
+							y: handle.y,
+						}
+					}
+				}
+				break
+			}
+
+			case 'middle': {
+				const { start, end } = getArrowTerminalsInArrowSpace(this.editor, next)
+
+				const delta = Vec2d.Sub(end, start)
+				const v = Vec2d.Per(delta)
+
+				const med = Vec2d.Med(end, start)
+				const A = Vec2d.Sub(med, v)
+				const B = Vec2d.Add(med, v)
+
+				const point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)
+				let bend = Vec2d.Dist(point, med)
+				if (Vec2d.Clockwise(point, end, med)) bend *= -1
+				next.props.bend = bend
+				break
+			}
+		}
+
+		return next
+	}
+
+	override onTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {
+		let startBinding: TLShapeId | null =
+			shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null
+		let endBinding: TLShapeId | null =
+			shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
+
+		// If at least one bound shape is in the selection, do nothing;
+		// If no bound shapes are in the selection, unbind any bound shapes
+
+		if (
+			(startBinding &&
+				(this.editor.isSelected(startBinding) || this.editor.isAncestorSelected(startBinding))) ||
+			(endBinding &&
+				(this.editor.isSelected(endBinding) || this.editor.isAncestorSelected(endBinding)))
+		) {
+			return
+		}
+
+		startBinding = null
+		endBinding = null
+
+		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
+
+		return {
+			id: shape.id,
+			type: shape.type,
+			props: {
+				...shape.props,
+				start: {
+					type: 'point',
+					x: start.x,
+					y: start.y,
+				},
+				end: {
+					type: 'point',
+					x: end.x,
+					y: end.y,
+				},
+			},
+		}
+	}
+
+	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
+		const { scaleX, scaleY } = info
+
+		const terminals = getArrowTerminalsInArrowSpace(this.editor, shape)
+
+		const { start, end } = deepCopy<TLArrowShape['props']>(shape.props)
+		let { bend } = shape.props
+
+		// Rescale start handle if it's not bound to a shape
+		if (start.type === 'point') {
+			start.x = terminals.start.x * scaleX
+			start.y = terminals.start.y * scaleY
+		}
+
+		// Rescale end handle if it's not bound to a shape
+		if (end.type === 'point') {
+			end.x = terminals.end.x * scaleX
+			end.y = terminals.end.y * scaleY
+		}
+
+		// todo: we should only change the normalized anchor positions
+		// of the shape's handles if the bound shape is also being resized
+
+		const mx = Math.abs(scaleX)
+		const my = Math.abs(scaleY)
+
+		if (scaleX < 0 && scaleY >= 0) {
+			if (bend !== 0) {
+				bend *= -1
+				bend *= Math.max(mx, my)
+			}
+
+			if (start.type === 'binding') {
+				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
+			}
+
+			if (end.type === 'binding') {
+				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
+			}
+		} else if (scaleX >= 0 && scaleY < 0) {
+			if (bend !== 0) {
+				bend *= -1
+				bend *= Math.max(mx, my)
+			}
+
+			if (start.type === 'binding') {
+				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
+			}
+
+			if (end.type === 'binding') {
+				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
+			}
+		} else if (scaleX >= 0 && scaleY >= 0) {
+			if (bend !== 0) {
+				bend *= Math.max(mx, my)
+			}
+		} else if (scaleX < 0 && scaleY < 0) {
+			if (bend !== 0) {
+				bend *= Math.max(mx, my)
+			}
+
+			if (start.type === 'binding') {
+				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
+				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
+			}
+
+			if (end.type === 'binding') {
+				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
+				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
+			}
+		}
+
+		const next = {
+			props: {
+				start,
+				end,
+				bend,
+			},
+		}
+
+		return next
+	}
+
+	override onDoubleClickHandle = (
+		shape: TLArrowShape,
+		handle: TLHandle
+	): TLShapePartial<TLArrowShape> | void => {
+		switch (handle.id) {
+			case 'start': {
+				return {
+					id: shape.id,
+					type: shape.type,
+					props: {
+						...shape.props,
+						arrowheadStart: shape.props.arrowheadStart === 'none' ? 'arrow' : 'none',
+					},
+				}
+			}
+			case 'end': {
+				return {
+					id: shape.id,
+					type: shape.type,
+					props: {
+						...shape.props,
+						arrowheadEnd: shape.props.arrowheadEnd === 'none' ? 'arrow' : 'none',
+					},
+				}
+			}
+		}
+	}
+
+	override hitTestPoint(shape: TLArrowShape, point: VecLike): boolean {
+		const outline = this.editor.getOutline(shape)
+		const zoomLevel = this.editor.zoomLevel
+		const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
+
+		for (let i = 0; i < outline.length - 1; i++) {
+			const C = outline[i]
+			const D = outline[i + 1]
+
+			if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
+		}
+
+		return false
+	}
+
+	override hitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean {
+		const outline = this.editor.getOutline(shape)
+
+		for (let i = 0; i < outline.length - 1; i++) {
+			const C = outline[i]
+			const D = outline[i + 1]
+			if (linesIntersect(A, B, C, D)) return true
+		}
+
+		return false
+	}
+
+	component(shape: TLArrowShape) {
+		// Not a class component, but eslint can't tell that :(
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const theme = useDefaultColorTheme()
+		const onlySelectedShape = this.editor.onlySelectedShape
+		const shouldDisplayHandles =
+			this.editor.isInAny(
+				'select.idle',
+				'select.pointing_handle',
+				'select.dragging_handle',
+				'arrow.dragging'
+			) && !this.editor.isReadOnly
+
+		const info = this.editor.getArrowInfo(shape)
+		const bounds = this.editor.getBounds(shape)
+		const labelSize = this.getLabelBounds(shape)
+
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const changeIndex = React.useMemo<number>(() => {
+			return this.editor.isSafari ? (globalRenderIndex += 1) : 0
+			// eslint-disable-next-line react-hooks/exhaustive-deps
+		}, [shape])
+
+		if (!info?.isValid) return null
+
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+
+		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
+
+		let handlePath: null | JSX.Element = null
+
+		if (onlySelectedShape === shape && shouldDisplayHandles) {
+			const sw = 2
+			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+				info.isStraight
+					? Vec2d.Dist(info.start.handle, info.end.handle)
+					: Math.abs(info.handleArc.length),
+				sw,
+				{
+					end: 'skip',
+					start: 'skip',
+					lengthRatio: 2.5,
+				}
+			)
+
+			handlePath =
+				shape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (
+					<path
+						className="tl-arrow-hint"
+						d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
+						strokeDasharray={strokeDasharray}
+						strokeDashoffset={strokeDashoffset}
+						strokeWidth={sw}
+						markerStart={
+							shape.props.start.type === 'binding'
+								? shape.props.start.isExact
+									? ''
+									: isPrecise(shape.props.start.normalizedAnchor)
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
+								: ''
+						}
+						markerEnd={
+							shape.props.end.type === 'binding'
+								? shape.props.end.isExact
+									? ''
+									: isPrecise(shape.props.end.normalizedAnchor)
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
+								: ''
+						}
+						opacity={0.16}
+					/>
+				) : null
+		}
+
+		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
+			strokeWidth,
+			{
+				style: shape.props.dash,
+			}
+		)
+
+		const maskStartArrowhead = !(
+			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
+		)
+		const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+		const includeMask = maskStartArrowhead || maskEndArrowhead || labelSize
+
+		// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
+		// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
+		const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
+
+		return (
+			<>
+				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
+					{includeMask && (
+						<defs>
+							<mask id={maskId}>
+								<rect
+									x={toDomPrecision(-100 + bounds.minX)}
+									y={toDomPrecision(-100 + bounds.minY)}
+									width={toDomPrecision(bounds.width + 200)}
+									height={toDomPrecision(bounds.height + 200)}
+									fill="white"
+								/>
+								{labelSize && (
+									<rect
+										x={toDomPrecision(labelSize.x)}
+										y={toDomPrecision(labelSize.y)}
+										width={toDomPrecision(labelSize.w)}
+										height={toDomPrecision(labelSize.h)}
+										fill="black"
+										rx={4}
+										ry={4}
+									/>
+								)}
+								{as && maskStartArrowhead && (
+									<path
+										d={as}
+										fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
+										stroke="none"
+									/>
+								)}
+								{ae && maskEndArrowhead && (
+									<path
+										d={ae}
+										fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
+										stroke="none"
+									/>
+								)}
+							</mask>
+						</defs>
+					)}
+					<g
+						fill="none"
+						stroke={theme[shape.props.color].solid}
+						strokeWidth={strokeWidth}
+						strokeLinejoin="round"
+						strokeLinecap="round"
+						pointerEvents="none"
+					>
+						{handlePath}
+						{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
+						<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>
+							{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
+							{includeMask && (
+								<rect
+									x={toDomPrecision(bounds.minX - 100)}
+									y={toDomPrecision(bounds.minY - 100)}
+									width={toDomPrecision(bounds.width + 200)}
+									height={toDomPrecision(bounds.height + 200)}
+									opacity={0}
+								/>
+							)}
+							<path
+								d={path}
+								strokeDasharray={strokeDasharray}
+								strokeDashoffset={strokeDashoffset}
+							/>
+						</g>
+						{as && maskStartArrowhead && shape.props.fill !== 'none' && (
+							<ShapeFill d={as} color={shape.props.color} fill={shape.props.fill} />
+						)}
+						{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
+							<ShapeFill d={ae} color={shape.props.color} fill={shape.props.fill} />
+						)}
+						{as && <path d={as} />}
+						{ae && <path d={ae} />}
+					</g>
+					<path d={path} className="tl-hitarea-stroke" />
+				</SVGContainer>
+				<ArrowTextLabel
+					id={shape.id}
+					text={shape.props.text}
+					font={shape.props.font}
+					size={shape.props.size}
+					position={info.middle}
+					width={labelSize?.w ?? 0}
+					labelColor={shape.props.labelColor}
+				/>
+			</>
+		)
+	}
+
+	indicator(shape: TLArrowShape) {
+		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
+
+		const info = this.editor.getArrowInfo(shape)
+		const bounds = this.editor.getBounds(shape)
+		const labelSize = this.getLabelBounds(shape)
+
+		if (!info) return null
+		if (Vec2d.Equals(start, end)) return null
+
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+
+		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
+
+		const includeMask =
+			(as && info.start.arrowhead !== 'arrow') ||
+			(ae && info.end.arrowhead !== 'arrow') ||
+			labelSize !== null
+
+		const maskId = (shape.id + '_clip').replace(':', '_')
+
+		return (
+			<g>
+				{includeMask && (
+					<defs>
+						<mask id={maskId}>
+							<rect
+								x={bounds.minX - 100}
+								y={bounds.minY - 100}
+								width={bounds.w + 200}
+								height={bounds.h + 200}
+								fill="white"
+							/>
+							{labelSize && (
+								<rect
+									x={labelSize.x}
+									y={labelSize.y}
+									width={labelSize.w}
+									height={labelSize.h}
+									fill="black"
+									rx={4}
+									ry={4}
+								/>
+							)}
+							{as && (
+								<path
+									d={as}
+									fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+							{ae && (
+								<path
+									d={ae}
+									fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+						</mask>
+					</defs>
+				)}
+				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
+				<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>
+					{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
+					{includeMask && (
+						<rect
+							x={bounds.minX - 100}
+							y={bounds.minY - 100}
+							width={bounds.width + 200}
+							height={bounds.height + 200}
+							opacity={0}
+						/>
+					)}
+
+					<path d={path} />
+				</g>
+				{as && <path d={as} />}
+				{ae && <path d={ae} />}
+				{labelSize && (
+					<rect
+						x={labelSize.x}
+						y={labelSize.y}
+						width={labelSize.w}
+						height={labelSize.h}
+						rx={4}
+						ry={4}
+					/>
+				)}
+			</g>
+		)
+	}
+
+	@computed get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape> {
+		return this.editor.store.createComputedCache('labelBoundsCache', (shape) => {
+			const info = this.editor.getArrowInfo(shape)
+			const bounds = this.editor.getBounds(shape)
+			const { text, font, size } = shape.props
+
+			if (!info) return null
+			if (!text.trim()) return null
+
+			const { w, h } = this.editor.textMeasure.measureText(text, {
+				...TEXT_PROPS,
+				fontFamily: FONT_FAMILIES[font],
+				fontSize: ARROW_LABEL_FONT_SIZES[size],
+				width: 'fit-content',
+			})
+
+			let width = w
+			let height = h
+
+			if (bounds.width > bounds.height) {
+				width = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w))
+
+				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
+					...TEXT_PROPS,
+					fontFamily: FONT_FAMILIES[font],
+					fontSize: ARROW_LABEL_FONT_SIZES[size],
+					width: width + 'px',
+				})
+
+				width = squishedWidth
+				height = squishedHeight
+			}
+
+			if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {
+				width = 16 * ARROW_LABEL_FONT_SIZES[size]
+
+				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
+					...TEXT_PROPS,
+					fontFamily: FONT_FAMILIES[font],
+					fontSize: ARROW_LABEL_FONT_SIZES[size],
+					width: width + 'px',
+				})
+
+				width = squishedWidth
+				height = squishedHeight
+			}
+
+			return new Box2d(
+				info.middle.x - (width + 8) / 2,
+				info.middle.y - (height + 8) / 2,
+				width + 8,
+				height + 8
+			)
+		})
+	}
+
+	getLabelBounds(shape: TLArrowShape): Box2d | null {
+		return this.labelBoundsCache.get(shape.id) || null
+	}
+
+	override onEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {
+		const {
+			id,
+			type,
+			props: { text },
+		} = shape
+
+		if (text.trimEnd() !== shape.props.text) {
+			this.editor.updateShapes<TLArrowShape>([
+				{
+					id,
+					type,
+					props: {
+						text: text.trimEnd(),
+					},
+				},
+			])
+		}
+	}
+
+	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
+		const theme = getDefaultColorTheme(this.editor)
+		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
+
+		const color = theme[shape.props.color].solid
+
+		const info = this.editor.getArrowInfo(shape)
+
+		const strokeWidth = STROKE_SIZES[shape.props.size]
+
+		// Group for arrow
+		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		if (!info) return g
+
+		// Arrowhead start path
+		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+		// Arrowhead end path
+		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+		const bounds = this.editor.getBounds(shape)
+		const labelSize = this.getLabelBounds(shape)
+
+		const maskId = (shape.id + '_clip').replace(':', '_')
+
+		// If we have any arrowheads, then mask the arrowheads
+		if (as || ae || labelSize) {
+			// Create mask for arrowheads
+
+			// Create defs
+			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')
+
+			// Create mask
+			const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask')
+			mask.id = maskId
+
+			// Create large white shape for mask
+			const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
+			rect.setAttribute('x', bounds.minX - 100 + '')
+			rect.setAttribute('y', bounds.minY - 100 + '')
+			rect.setAttribute('width', bounds.width + 200 + '')
+			rect.setAttribute('height', bounds.height + 200 + '')
+			rect.setAttribute('fill', 'white')
+			mask.appendChild(rect)
+
+			// add arrowhead start mask
+			if (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead))
+
+			// add arrowhead end mask
+			if (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))
+
+			// Mask out text label if text is present
+			if (labelSize) {
+				const labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
+				labelMask.setAttribute('x', labelSize.x + '')
+				labelMask.setAttribute('y', labelSize.y + '')
+				labelMask.setAttribute('width', labelSize.w + '')
+				labelMask.setAttribute('height', labelSize.h + '')
+				labelMask.setAttribute('fill', 'black')
+
+				mask.appendChild(labelMask)
+			}
+
+			defs.appendChild(mask)
+			g.appendChild(defs)
+		}
+
+		const g2 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		g2.setAttribute('mask', `url(#${maskId})`)
+		g.appendChild(g2)
+
+		// Dumb mask fix thing
+		const rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
+		rect2.setAttribute('x', '-100')
+		rect2.setAttribute('y', '-100')
+		rect2.setAttribute('width', bounds.width + 200 + '')
+		rect2.setAttribute('height', bounds.height + 200 + '')
+		rect2.setAttribute('fill', 'transparent')
+		rect2.setAttribute('stroke', 'none')
+		g2.appendChild(rect2)
+
+		// Arrowhead body path
+		const path = getArrowSvgPath(
+			info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),
+			color,
+			strokeWidth
+		)
+
+		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
+			strokeWidth,
+			{
+				style: shape.props.dash,
+			}
+		)
+
+		path.setAttribute('stroke-dasharray', strokeDasharray)
+		path.setAttribute('stroke-dashoffset', strokeDashoffset)
+
+		g2.appendChild(path)
+
+		// Arrowhead start path
+		if (as) {
+			g.appendChild(
+				getArrowheadSvgPath(
+					as,
+					shape.props.color,
+					strokeWidth,
+					shape.props.arrowheadStart === 'arrow' ? 'none' : shape.props.fill,
+					theme
+				)
+			)
+		}
+		// Arrowhead end path
+		if (ae) {
+			g.appendChild(
+				getArrowheadSvgPath(
+					ae,
+					shape.props.color,
+					strokeWidth,
+					shape.props.arrowheadEnd === 'arrow' ? 'none' : shape.props.fill,
+					theme
+				)
+			)
+		}
+
+		// Text Label
+		if (labelSize) {
+			ctx.addExportDef(getFontDefForExport(shape.props.font))
+
+			const opts = {
+				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+				lineHeight: TEXT_PROPS.lineHeight,
+				fontFamily: DefaultFontFamilies[shape.props.font],
+				padding: 0,
+				textAlign: 'middle' as const,
+				width: labelSize.w - 8,
+				verticalTextAlign: 'middle' as const,
+				height: labelSize.h,
+				fontStyle: 'normal',
+				fontWeight: 'normal',
+				overflow: 'wrap' as const,
+			}
+
+			const textElm = createTextSvgElementFromSpans(
+				this.editor,
+				this.editor.textMeasure.measureTextSpans(shape.props.text, opts),
+				opts
+			)
+			textElm.setAttribute('fill', theme[shape.props.labelColor].solid)
+
+			const children = Array.from(textElm.children) as unknown as SVGTSpanElement[]
+
+			children.forEach((child) => {
+				const x = parseFloat(child.getAttribute('x') || '0')
+				const y = parseFloat(child.getAttribute('y') || '0')
+
+				child.setAttribute('x', x + 4 + labelSize!.x + 'px')
+				child.setAttribute('y', y + labelSize!.y + 'px')
+			})
+
+			const textBgEl = textElm.cloneNode(true) as SVGTextElement
+			textBgEl.setAttribute('stroke-width', '2')
+			textBgEl.setAttribute('fill', theme.background)
+			textBgEl.setAttribute('stroke', theme.background)
+
+			g.appendChild(textBgEl)
+			g.appendChild(textElm)
+		}
+
+		return g
+	}
+
+	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
+		return [getFillDefForCanvas()]
+	}
+}
+
+function getArrowheadSvgMask(d: string, arrowhead: TLArrowShapeArrowheadStyle) {
+	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+	path.setAttribute('d', d)
+	path.setAttribute('fill', arrowhead === 'arrow' ? 'none' : 'black')
+	path.setAttribute('stroke', 'none')
+	return path
+}
+
+function getArrowSvgPath(d: string, color: string, strokeWidth: number) {
+	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+	path.setAttribute('d', d)
+	path.setAttribute('fill', 'none')
+	path.setAttribute('stroke', color)
+	path.setAttribute('stroke-width', strokeWidth + '')
+	return path
+}
+
+function getArrowheadSvgPath(
+	d: string,
+	color: TLDefaultColorStyle,
+	strokeWidth: number,
+	fill: TLDefaultFillStyle,
+	theme: TLDefaultColorTheme
+) {
+	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
+	path.setAttribute('d', d)
+	path.setAttribute('fill', 'none')
+	path.setAttribute('stroke', theme[color].solid)
+	path.setAttribute('stroke-width', strokeWidth + '')
+
+	// Get the fill element, if any
+	const shapeFill = getShapeFillSvg({
+		d,
+		fill,
+		color,
+		theme,
+	})
+
+	if (shapeFill) {
+		// If there is a fill element, return a group containing the fill and the path
+		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
+		g.appendChild(shapeFill)
+		g.appendChild(path)
+		return g
+	} else {
+		// Otherwise, just return the path
+		return path
+	}
+}
+
+function isPrecise(normalizedAnchor: Vec2dModel) {
+	return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5
+}

commit f63ddc7ecc71f498a7cddf6bc4611c7013c454dd
Author: Gabriel Lee <chihonglee777@gmail.com>
Date:   Mon Jul 17 22:58:05 2023 +0100

    fix: arrow label dark mode color (#1733)
    
    This PR fixes the issue where the arrow label was black in dark mode
    instead of white.
    
    light mode (normal):
    <img width="600" alt="Screenshot 2023-07-12 at 00 21 35"
    src="https://github.com/tldraw/tldraw/assets/5616556/2ac5e951-7777-4e96-9dde-a410a754aa01">
    
    dark mode (before):
    <img width="600" alt="Screenshot 2023-07-12 at 00 21 52"
    src="https://github.com/tldraw/tldraw/assets/5616556/c67c3309-2847-4499-b4ef-6ba686e1382e">
    
    dark mode (after):
    <img width="600" alt="Screenshot 2023-07-12 at 00 21 44"
    src="https://github.com/tldraw/tldraw/assets/5616556/244987c0-4570-410b-8975-43db47b786fa">
    
    Fixes #1716
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Add an arrow with label
    2. Switch between dark and light mode and notice that the label color
    adapts correctly
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - fixed arrow label dark mode color
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index c149bee87..d28902c4f 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -732,7 +732,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					size={shape.props.size}
 					position={info.middle}
 					width={labelSize?.w ?? 0}
-					labelColor={shape.props.labelColor}
+					labelColor={theme[shape.props.labelColor].solid}
 				/>
 			</>
 		)

commit 3e31ef2a7d01467ef92ca4f7aed13ee708db73ef
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 18 22:50:23 2023 +0100

    Remove helpers / extraneous API methods. (#1745)
    
    This PR removes several extraneous computed values from the editor. It
    adds some silly instance state onto the instance state record and
    unifies a few methods which were inconsistent. This is fit and finish
    work 🧽
    
    ## Computed Values
    
    In general, where once we had a getter and setter for `isBlahMode`,
    which really masked either an `_isBlahMode` atom on the editor or
    `instanceState.isBlahMode`, these are merged into `instanceState`; they
    can be accessed / updated via `editor.instanceState` /
    `editor.updateInstanceState`.
    
    ## tldraw select tool specific things
    
    This PR also removes some tldraw specific state checks and creates new
    component overrides to allow us to include them in tldraw/tldraw.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests
    - [x] End to end tests
    
    ### Release Notes
    
    - [tldraw] rename `useReadonly` to `useReadOnly`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isChangingStyle`
    - [editor] remove `Editor.isCoarsePointer`
    - [editor] remove `Editor.isDarkMode`
    - [editor] remove `Editor.isFocused`
    - [editor] remove `Editor.isGridMode`
    - [editor] remove `Editor.isPenMode`
    - [editor] remove `Editor.isReadOnly`
    - [editor] remove `Editor.isSnapMode`
    - [editor] remove `Editor.isToolLocked`
    - [editor] remove `Editor.locale`
    - [editor] rename `Editor.pageState` to `Editor.currentPageState`
    - [editor] add `Editor.pageStates`
    - [editor] add `Editor.setErasingIds`
    - [editor] add `Editor.setEditingId`
    - [editor] add several new component overrides

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index d28902c4f..6fdb7d29f 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -17,7 +17,6 @@ import {
 	TLOnHandleChangeHandler,
 	TLOnResizeHandler,
 	TLOnTranslateStartHandler,
-	TLShapeId,
 	TLShapePartial,
 	TLShapeUtilCanvasSvgDef,
 	TLShapeUtilFlag,
@@ -370,26 +369,24 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override onTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {
-		let startBinding: TLShapeId | null =
+		const startBindingId =
 			shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null
-		let endBinding: TLShapeId | null =
-			shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
+		const endBindingId = shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
 
 		// If at least one bound shape is in the selection, do nothing;
 		// If no bound shapes are in the selection, unbind any bound shapes
 
+		const { selectedIds } = this.editor
+
 		if (
-			(startBinding &&
-				(this.editor.isSelected(startBinding) || this.editor.isAncestorSelected(startBinding))) ||
-			(endBinding &&
-				(this.editor.isSelected(endBinding) || this.editor.isAncestorSelected(endBinding)))
+			(startBindingId &&
+				(selectedIds.includes(startBindingId) || this.editor.isAncestorSelected(startBindingId))) ||
+			(endBindingId &&
+				(selectedIds.includes(endBindingId) || this.editor.isAncestorSelected(endBindingId)))
 		) {
 			return
 		}
 
-		startBinding = null
-		endBinding = null
-
 		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
 		return {
@@ -560,7 +557,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.pointing_handle',
 				'select.dragging_handle',
 				'arrow.dragging'
-			) && !this.editor.isReadOnly
+			) && !this.editor.instanceState.isReadOnly
 
 		const info = this.editor.getArrowInfo(shape)
 		const bounds = this.editor.getBounds(shape)
@@ -914,7 +911,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
-		const theme = getDefaultColorTheme(this.editor)
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		const color = theme[shape.props.color].solid

commit b22ea7cd4e6c27dcebd6615daa07116ecacbf554
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jul 19 11:52:21 2023 +0100

    More cleanup, focus bug fixes (#1749)
    
    This PR is another grab bag:
    - renames `readOnly` to `readonly` throughout editor
    - fixes a regression related to focus and keyboard shortcuts
    - adds a small outline for focused editors
    
    ### Change Type
    
    - [x] `major`
    
    ### Test Plan
    
    - [x] End to end tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 6fdb7d29f..e77d203c0 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -557,7 +557,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.pointing_handle',
 				'select.dragging_handle',
 				'arrow.dragging'
-			) && !this.editor.instanceState.isReadOnly
+			) && !this.editor.instanceState.isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
 		const bounds = this.editor.getBounds(shape)

commit 0323ee1f6b6ece000b0c1e35cd259a986f852aad
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Jul 20 12:38:55 2023 +0100

    [fix] dark mode (#1754)
    
    This PR fixes a bug where dark mode would not immediately cause shapes
    to update their colors. Previously, we got the current theme during
    render but not in a way that hooked into the change. In this update, we
    hook into the change. We also pass the change down to shape fills as
    props rather than getting the theme from deeper down.
    
    ### Change Type
    
    - [x] `patch`
    
    ### Test Plan
    
    1. Use dark mode.
    2. Switch colors
    
    ### Release Notes
    
    - [fix] dark mode colors not updating

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index e77d203c0..f495feadd 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -712,10 +712,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 							/>
 						</g>
 						{as && maskStartArrowhead && shape.props.fill !== 'none' && (
-							<ShapeFill d={as} color={shape.props.color} fill={shape.props.fill} />
+							<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} />
 						)}
 						{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
-							<ShapeFill d={ae} color={shape.props.color} fill={shape.props.fill} />
+							<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} />
 						)}
 						{as && <path d={as} />}
 						{ae && <path d={ae} />}

commit fc36d5b577594dad0a1af2695930b825b7aa1c6a
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sat Jul 22 06:19:16 2023 +0100

    [fix] arrow snapping bug (#1756)
    
    This PR fixes snapping for arrow shapes. Previously, the middle handle
    of an arrow was marked as a vertex, causing the arrow to have to
    segments (one of which would be snapped to). In this PR we make the
    second handle a "virtual" handle and tweak how we display handles to
    preserve the same appearance.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Drag an arrow while snapping.
    
    ### Release Notes
    
    - [fix] arrow snapping

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index f495feadd..b7515e7a8 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -217,7 +217,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			},
 			{
 				id: 'middle',
-				type: 'vertex',
+				type: 'virtual',
 				index: 'a2',
 				x: info.middle.x,
 				y: info.middle.y,

commit d750da8f40efda4b011a91962ef8f30c63d1e5da
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Jul 25 17:10:15 2023 +0100

    `ShapeUtil.getGeometry`, selection rewrite (#1751)
    
    This PR is a significant rewrite of our selection / hit testing logic.
    
    It
    - replaces our current geometric helpers (`getBounds`, `getOutline`,
    `hitTestPoint`, and `hitTestLineSegment`) with a new geometry API
    - moves our hit testing entirely to JS using geometry
    - improves selection logic, especially around editing shapes, groups and
    frames
    - fixes many minor selection bugs (e.g. shapes behind frames)
    - removes hit-testing DOM elements from ShapeFill etc.
    - adds many new tests around selection
    - adds new tests around selection
    - makes several superficial changes to surface editor APIs
    
    This PR is hard to evaluate. The `selection-omnibus` test suite is
    intended to describe all of the selection behavior, however all existing
    tests are also either here preserved and passing or (in a few cases
    around editing shapes) are modified to reflect the new behavior.
    
    ## Geometry
    
    All `ShapeUtils` implement `getGeometry`, which returns a single
    geometry primitive (`Geometry2d`). For example:
    
    ```ts
    class BoxyShapeUtil {
      getGeometry(shape: BoxyShape) {
        return new Rectangle2d({
            width: shape.props.width,
            height: shape.props.height,
            isFilled: true,
            margin: shape.props.strokeWidth
          })
        }
    }
    ```
    
    This geometric primitive is used for all bounds calculation, hit
    testing, intersection with arrows, etc.
    
    There are several geometric primitives that extend `Geometry2d`:
    - `Arc2d`
    - `Circle2d`
    - `CubicBezier2d`
    - `CubicSpline2d`
    - `Edge2d`
    - `Ellipse2d`
    - `Group2d`
    - `Polygon2d`
    - `Rectangle2d`
    - `Stadium2d`
    
    For shapes that have more complicated geometric representations, such as
    an arrow with a label, the `Group2d` can accept other primitives as its
    children.
    
    ## Hit testing
    
    Previously, we did all hit testing via events set on shapes and other
    elements. In this PR, I've replaced those hit tests with our own
    calculation for hit tests in JavaScript. This removed the need for many
    DOM elements, such as hit test area borders and fills which only existed
    to trigger pointer events.
    
    ## Selection
    
    We now support selecting "hollow" shapes by clicking inside of them.
    This involves a lot of new logic but it should work intuitively. See
    `Editor.getShapeAtPoint` for the (thoroughly commented) implementation.
    
    ![Kapture 2023-07-23 at 23 27
    27](https://github.com/tldraw/tldraw/assets/23072548/a743275c-acdb-42d9-a3fe-b3e20dce86b6)
    
    every sunset is actually the sun hiding in fear and respect of tldraw's
    quality of interactions
    
    This PR also fixes several bugs with scribble selection, in particular
    around the shift key modifier.
    
    ![Kapture 2023-07-24 at 23 34
    07](https://github.com/tldraw/tldraw/assets/23072548/871d67d0-8d06-42ae-a2b2-021effba37c5)
    
    ...as well as issues with labels and editing.
    
    There are **over 100 new tests** for selection covering groups, frames,
    brushing, scribbling, hovering, and editing. I'll add a few more before
    I feel comfortable merging this PR.
    
    ## Arrow binding
    
    Using the same "hollow shape" logic as selection, arrow binding is
    significantly improved.
    
    ![Kapture 2023-07-22 at 07 46
    25](https://github.com/tldraw/tldraw/assets/23072548/5aa724b3-b57d-4fb7-92d0-80e34246753c)
    
    a thousand wise men could not improve on this
    
    ## Moving focus between editing shapes
    
    Previously, this was handled in the `editing_shapes` state. This is
    moved to `useEditableText`, and should generally be considered an
    advanced implementation detail on a shape-by-shape basis. This addresses
    a bug that I'd never noticed before, but which can be reproduced by
    selecting an shape—but not focusing its input—while editing a different
    shape. Previously, the new shape became the editing shape but its input
    did not focus.
    
    ![Kapture 2023-07-23 at 23 19
    09](https://github.com/tldraw/tldraw/assets/23072548/a5e157fb-24a8-42bd-a692-04ce769b1a9c)
    
    In this PR, you can select a shape by clicking on its edge or body, or
    select its input to transfer editing / focus.
    
    ![Kapture 2023-07-23 at 23 22
    21](https://github.com/tldraw/tldraw/assets/23072548/7384e7ea-9777-4e1a-8f63-15de2166a53a)
    
    tldraw, glorious tldraw
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    1. Erase shapes
    2. Select shapes
    3. Calculate their bounding boxes
    
    - [ ] Unit Tests // todo
    - [ ] End to end tests // todo
    
    ### Release Notes
    
    - [editor] Remove `ShapeUtil.getBounds`, `ShapeUtil.getOutline`,
    `ShapeUtil.hitTestPoint`, `ShapeUtil.hitTestLineSegment`
    - [editor] Add `ShapeUtil.getGeometry`
    - [editor] Add `Editor.getShapeGeometry`

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index b7515e7a8..d04fb6131 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1,9 +1,9 @@
 import {
-	Box2d,
-	ComputedCache,
+	Arc2d,
 	DefaultFontFamilies,
-	EMPTY_ARRAY,
-	Matrix2d,
+	Edge2d,
+	Group2d,
+	Rectangle2d,
 	SVGContainer,
 	ShapeUtil,
 	SvgExportContext,
@@ -22,25 +22,16 @@ import {
 	TLShapeUtilFlag,
 	Vec2d,
 	Vec2dModel,
-	VecLike,
 	arrowShapeMigrations,
 	arrowShapeProps,
-	computed,
 	deepCopy,
 	getArrowTerminalsInArrowSpace,
 	getArrowheadPathForType,
 	getCurvedArrowHandlePath,
 	getDefaultColorTheme,
-	getPointOnCircle,
 	getSolidCurvedArrowPath,
 	getSolidStraightArrowPath,
 	getStraightArrowHandlePath,
-	last,
-	linesIntersect,
-	longAngleDist,
-	minBy,
-	pointInPolygon,
-	shortAngleDist,
 	toDomPrecision,
 } from '@tldraw/editor'
 import React from 'react'
@@ -70,12 +61,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	override canEdit = () => true
 	override canBind = () => false
-	override isClosed = () => false
 	override canSnap = () => true
 	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
-	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
 
 	override getDefaultProps(): TLArrowShape['props'] {
 		return {
@@ -94,114 +83,86 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 	}
 
-	getBounds(shape: TLArrowShape) {
-		return Box2d.FromPoints(this.getOutlineWithoutLabel(shape))
-	}
-
-	getOutlineWithoutLabel(shape: TLArrowShape): Vec2d[] {
-		const info = this.editor.getArrowInfo(shape)
-
-		if (!info) {
-			return []
-		}
-
-		if (info.isStraight) {
-			if (info.isValid) {
-				return [Vec2d.From(info.start.point), Vec2d.From(info.end.point)]
-			} else {
-				return [new Vec2d(0, 0), new Vec2d(1, 1)]
-			}
-		}
-
-		if (!info.isValid) {
-			return [new Vec2d(0, 0), new Vec2d(1, 1)]
-		}
-
-		const pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16))
+	getGeometry(shape: TLArrowShape) {
+		const info = this.editor.getArrowInfo(shape)!
 
-		if (pointsToPush <= 0 && !isFinite(pointsToPush)) {
-			return [new Vec2d(0, 0), new Vec2d(1, 1)]
+		const bodyGeom = info.isStraight
+			? new Edge2d({
+					start: Vec2d.From(info.start.point),
+					end: Vec2d.From(info.end.point),
+			  })
+			: new Arc2d({
+					center: Vec2d.Cast(info.handleArc.center),
+					radius: info.handleArc.radius,
+					start: Vec2d.Cast(info.start.point),
+					end: Vec2d.Cast(info.end.point),
+					sweepFlag: info.bodyArc.sweepFlag,
+					largeArcFlag: info.bodyArc.largeArcFlag,
+			  })
+
+		if (!shape.props.text.trim()) {
+			return bodyGeom
 		}
 
-		const results: Vec2d[] = Array(pointsToPush)
-
-		const startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point)
-		const endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point)
+		const bodyBounds = bodyGeom.bounds
 
-		const a = info.bodyArc.sweepFlag ? endAngle : startAngle
-		const b = info.bodyArc.sweepFlag ? startAngle : endAngle
-		const l = info.bodyArc.largeArcFlag ? -longAngleDist(a, b) : shortAngleDist(a, b)
-
-		const r = Math.max(1, info.bodyArc.radius)
+		const { w, h } = this.editor.textMeasure.measureText(shape.props.text, {
+			...TEXT_PROPS,
+			fontFamily: FONT_FAMILIES[shape.props.font],
+			fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+			width: 'fit-content',
+		})
 
-		for (let i = 0; i < pointsToPush; i++) {
-			const t = i / (pointsToPush - 1)
-			const angle = a + l * t
-			const point = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r, angle)
-			results[i] = point
-		}
+		let width = w
+		let height = h
 
-		return results
-	}
+		if (bodyBounds.width > bodyBounds.height) {
+			width = Math.max(Math.min(w, 64), Math.min(bodyBounds.width - 64, w))
 
-	override getOutline(shape: TLArrowShape): Vec2d[] {
-		const outlineWithoutLabel = this.getOutlineWithoutLabel(shape)
+			const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
+				shape.props.text,
+				{
+					...TEXT_PROPS,
+					fontFamily: FONT_FAMILIES[shape.props.font],
+					fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+					width: width + 'px',
+				}
+			)
 
-		const labelBounds = this.getLabelBounds(shape)
-		if (!labelBounds) {
-			return outlineWithoutLabel
+			width = squishedWidth
+			height = squishedHeight
 		}
 
-		const sides = labelBounds.sides
-		const sideIndexes = [0, 1, 2, 3]
-
-		// start with the first point...
-		let prevPoint = outlineWithoutLabel[0]
-		let didAddLabel = false
-		const result = [prevPoint]
-		for (let i = 1; i < outlineWithoutLabel.length; i++) {
-			// ...and use the next point to form a line segment for the outline.
-			const nextPoint = outlineWithoutLabel[i]
-
-			if (!didAddLabel) {
-				// find the index of the side of the label bounds that intersects the line segment
-				const nearestIntersectingSideIndex = minBy(
-					sideIndexes.filter((sideIndex) =>
-						linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)
-					),
-					(sideIndex) =>
-						Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)
-				)
+		if (width > 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]) {
+			width = 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]
 
-				// if we've found one, start at that index and trace around all four corners of the label bounds
-				if (nearestIntersectingSideIndex !== undefined) {
-					const intersectingPoint = Vec2d.NearestPointOnLineSegment(
-						sides[nearestIntersectingSideIndex][0],
-						sides[nearestIntersectingSideIndex][1],
-						prevPoint
-					)
-
-					result.push(intersectingPoint)
-					for (let j = 0; j < 4; j++) {
-						const sideIndex = (nearestIntersectingSideIndex + j) % 4
-						result.push(sides[sideIndex][1])
-					}
-					result.push(intersectingPoint)
-
-					// we've added the label, so we can just continue with the rest of the outline as normal
-					didAddLabel = true
+			const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
+				shape.props.text,
+				{
+					...TEXT_PROPS,
+					fontFamily: FONT_FAMILIES[shape.props.font],
+					fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+					width: width + 'px',
 				}
-			}
+			)
 
-			result.push(nextPoint)
-			prevPoint = nextPoint
+			width = squishedWidth
+			height = squishedHeight
 		}
 
-		return result
-	}
+		const labelGeom = new Rectangle2d({
+			x: info.middle.x - width / 2 - 4.25,
+			y: info.middle.y - height / 2 - 4.25,
+			width: width + 8.5,
+			height: height + 8.5,
+			isFilled: true,
+		})
 
-	override snapPoints(_shape: TLArrowShape): Vec2d[] {
-		return EMPTY_ARRAY
+		return new Group2d({
+			children: [bodyGeom, labelGeom],
+			operation: 'union',
+			isSnappable: false,
+		})
 	}
 
 	override getHandles(shape: TLArrowShape): TLHandle[] {
@@ -238,130 +199,125 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		shape,
 		{ handle, isPrecise }
 	) => {
-		const next = deepCopy(shape)
+		const handleId = handle.id as 'start' | 'middle' | 'end'
 
-		switch (handle.id) {
-			case 'start':
-			case 'end': {
-				const pageTransform = this.editor.getPageTransformById(next.id)!
-				const pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle)
-
-				if (this.editor.inputs.ctrlKey) {
-					next.props[handle.id] = {
-						type: 'point',
-						x: handle.x,
-						y: handle.y,
-					}
-				} else {
-					const target = last(
-						this.editor.sortedShapesArray.filter((hitShape) => {
-							if (hitShape.id === shape.id) {
-								// We're testing against the arrow
-								return
-							}
-
-							const util = this.editor.getShapeUtil(hitShape)
-							if (!util.canBind(hitShape)) {
-								// The shape can't be bound to
-								return
-							}
-
-							// Check the page mask
-							const pageMask = this.editor.getPageMaskById(hitShape.id)
-							if (pageMask) {
-								if (!pointInPolygon(pointInPageSpace, pageMask)) return
-							}
-
-							const pointInTargetSpace = this.editor.getPointInShapeSpace(
-								hitShape,
-								pointInPageSpace
-							)
-
-							if (util.isClosed(hitShape)) {
-								// Test the polygon
-								return pointInPolygon(pointInTargetSpace, this.editor.getOutline(hitShape))
-							}
-
-							// Test the point using the shape's idea of what a hit is
-							return util.hitTestPoint(hitShape, pointInTargetSpace)
-						})
-					)
-
-					if (target) {
-						const targetBounds = this.editor.getBounds(target)
-						const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
-
-						const prevHandle = next.props[handle.id]
-
-						const startBindingId =
-							shape.props.start.type === 'binding' && shape.props.start.boundShapeId
-						const endBindingId = shape.props.end.type === 'binding' && shape.props.end.boundShapeId
-
-						let precise =
-							// If externally precise, then always precise
-							isPrecise ||
-							// If the other handle is bound to the same shape, then precise
-							((startBindingId || endBindingId) && startBindingId === endBindingId) ||
-							// If the other shape is not closed, then precise
-							!this.editor.getShapeUtil(target).isClosed(next)
-
-						if (
-							// If we're switching to a new bound shape, then precise only if moving slowly
-							prevHandle.type === 'point' ||
-							(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)
-						) {
-							precise = this.editor.inputs.pointerVelocity.len() < 0.5
-						}
+		if (handleId === 'middle') {
+			// Bending the arrow...
+			const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
-						if (precise) {
-							// Funky math but we want the snap distance to be 4 at the minimum and either
-							// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
-							precise =
-								Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
-								Math.max(
-									4,
-									Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)
-								) /
-									this.editor.zoomLevel
-						}
+			const delta = Vec2d.Sub(end, start)
+			const v = Vec2d.Per(delta)
 
-						next.props[handle.id] = {
-							type: 'binding',
-							boundShapeId: target.id,
-							normalizedAnchor: precise
-								? {
-										x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
-										y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
-								  }
-								: { x: 0.5, y: 0.5 },
-							isExact: this.editor.inputs.altKey,
-						}
-					} else {
-						next.props[handle.id] = {
-							type: 'point',
-							x: handle.x,
-							y: handle.y,
-						}
-					}
-				}
-				break
+			const med = Vec2d.Med(end, start)
+			const A = Vec2d.Sub(med, v)
+			const B = Vec2d.Add(med, v)
+
+			const point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)
+			let bend = Vec2d.Dist(point, med)
+			if (Vec2d.Clockwise(point, end, med)) bend *= -1
+			return { id: shape.id, type: shape.type, props: { bend } }
+		}
+
+		// Start or end, pointing the arrow...
+
+		const next = deepCopy(shape) as TLArrowShape
+
+		const pageTransform = this.editor.getPageTransform(next.id)!
+		const pointInPageSpace = pageTransform.applyToPoint(handle)
+
+		if (this.editor.inputs.ctrlKey) {
+			// todo: maybe double check that this isn't equal to the other handle too?
+			// Skip binding
+			next.props[handleId] = {
+				type: 'point',
+				x: handle.x,
+				y: handle.y,
+			}
+			return next
+		}
+
+		const point = this.editor.getPageTransform(shape.id)!.applyToPoint(handle)
+
+		const target = this.editor.getShapeAtPoint(point, {
+			filter: (shape) => this.editor.getShapeUtil(shape).canBind(shape),
+			hitInside: true,
+			hitFrameInside: true,
+			margin: 0,
+		})
+
+		if (!target) {
+			// todo: maybe double check that this isn't equal to the other handle too?
+			next.props[handleId] = {
+				type: 'point',
+				x: handle.x,
+				y: handle.y,
 			}
+			return next
+		}
 
-			case 'middle': {
-				const { start, end } = getArrowTerminalsInArrowSpace(this.editor, next)
+		// we've got a target! the handle is being dragged over a shape, bind to it
 
-				const delta = Vec2d.Sub(end, start)
-				const v = Vec2d.Per(delta)
+		const targetGeometry = this.editor.getGeometry(target)
+		const targetBounds = targetGeometry.bounds
+		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
-				const med = Vec2d.Med(end, start)
-				const A = Vec2d.Sub(med, v)
-				const B = Vec2d.Add(med, v)
+		let precise = isPrecise
 
-				const point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)
-				let bend = Vec2d.Dist(point, med)
-				if (Vec2d.Clockwise(point, end, med)) bend *= -1
-				next.props.bend = bend
-				break
+		if (!precise) {
+			// If we're switching to a new bound shape, then precise only if moving slowly
+			const prevHandle = next.props[handleId]
+			if (
+				prevHandle.type === 'point' ||
+				(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)
+			) {
+				precise = this.editor.inputs.pointerVelocity.len() < 0.5
+			}
+		}
+
+		if (precise) {
+			// Turn off precision if we're within a certain distance to the center of the shape.
+			// Funky math but we want the snap distance to be 4 at the minimum and either
+			// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
+			precise =
+				Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
+				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
+					this.editor.zoomLevel
+		}
+
+		if (!isPrecise) {
+			if (!targetGeometry.isClosed) {
+				precise = true
+			}
+
+			// Double check that we're not going to be doing an imprecise snap on
+			// the same shape twice, as this would result in a zero length line
+			const otherHandle = next.props[handleId === 'start' ? 'end' : 'start']
+			if (
+				otherHandle.type === 'binding' &&
+				target.id === otherHandle.boundShapeId &&
+				Vec2d.Equals(otherHandle.normalizedAnchor, { x: 0.5, y: 0.5 })
+			) {
+				precise = true
+			}
+		}
+
+		next.props[handleId] = {
+			type: 'binding',
+			boundShapeId: target.id,
+			normalizedAnchor: precise
+				? {
+						x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
+						y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
+				  }
+				: { x: 0.5, y: 0.5 },
+			isExact: this.editor.inputs.altKey,
+		}
+
+		if (next.props.start.type === 'binding' && next.props.end.type === 'binding') {
+			if (next.props.start.boundShapeId === next.props.end.boundShapeId) {
+				if (Vec2d.Equals(next.props.start.normalizedAnchor, next.props.end.normalizedAnchor)) {
+					next.props.end.normalizedAnchor.x += 0.05
+				}
 			}
 		}
 
@@ -376,13 +332,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// If at least one bound shape is in the selection, do nothing;
 		// If no bound shapes are in the selection, unbind any bound shapes
 
-		const { selectedIds } = this.editor
+		const { selectedShapeIds } = this.editor
 
 		if (
 			(startBindingId &&
-				(selectedIds.includes(startBindingId) || this.editor.isAncestorSelected(startBindingId))) ||
+				(selectedShapeIds.includes(startBindingId) ||
+					this.editor.isAncestorSelected(startBindingId))) ||
 			(endBindingId &&
-				(selectedIds.includes(endBindingId) || this.editor.isAncestorSelected(endBindingId)))
+				(selectedShapeIds.includes(endBindingId) || this.editor.isAncestorSelected(endBindingId)))
 		) {
 			return
 		}
@@ -519,33 +476,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 	}
 
-	override hitTestPoint(shape: TLArrowShape, point: VecLike): boolean {
-		const outline = this.editor.getOutline(shape)
-		const zoomLevel = this.editor.zoomLevel
-		const offsetDist = STROKE_SIZES[shape.props.size] / zoomLevel
-
-		for (let i = 0; i < outline.length - 1; i++) {
-			const C = outline[i]
-			const D = outline[i + 1]
-
-			if (Vec2d.DistanceToLineSegment(C, D, point) < offsetDist) return true
-		}
-
-		return false
-	}
-
-	override hitTestLineSegment(shape: TLArrowShape, A: VecLike, B: VecLike): boolean {
-		const outline = this.editor.getOutline(shape)
-
-		for (let i = 0; i < outline.length - 1; i++) {
-			const C = outline[i]
-			const D = outline[i + 1]
-			if (linesIntersect(A, B, C, D)) return true
-		}
-
-		return false
-	}
-
 	component(shape: TLArrowShape) {
 		// Not a class component, but eslint can't tell that :(
 		// eslint-disable-next-line react-hooks/rules-of-hooks
@@ -560,8 +490,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			) && !this.editor.instanceState.isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = this.editor.getBounds(shape)
-		const labelSize = this.getLabelBounds(shape)
+		const bounds = this.editor.getGeometry(shape).bounds
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
@@ -633,11 +562,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		)
 
+		const labelGeometry = shape.props.text.trim()
+			? (this.editor.getGeometry<Group2d>(shape).children[1] as Rectangle2d)
+			: null
+
 		const maskStartArrowhead = !(
 			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
 		)
 		const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-		const includeMask = maskStartArrowhead || maskEndArrowhead || labelSize
+		const includeMask = maskStartArrowhead || maskEndArrowhead || !!labelGeometry
 
 		// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
 		// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
@@ -656,12 +589,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 									height={toDomPrecision(bounds.height + 200)}
 									fill="white"
 								/>
-								{labelSize && (
+								{labelGeometry && (
 									<rect
-										x={toDomPrecision(labelSize.x)}
-										y={toDomPrecision(labelSize.y)}
-										width={toDomPrecision(labelSize.w)}
-										height={toDomPrecision(labelSize.h)}
+										x={labelGeometry.x}
+										y={labelGeometry.y}
+										width={labelGeometry.w}
+										height={labelGeometry.h}
 										fill="black"
 										rx={4}
 										ry={4}
@@ -720,7 +653,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						{as && <path d={as} />}
 						{ae && <path d={ae} />}
 					</g>
-					<path d={path} className="tl-hitarea-stroke" />
 				</SVGContainer>
 				<ArrowTextLabel
 					id={shape.id}
@@ -728,7 +660,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					font={shape.props.font}
 					size={shape.props.size}
 					position={info.middle}
-					width={labelSize?.w ?? 0}
+					width={labelGeometry?.w ?? 0}
 					labelColor={theme[shape.props.labelColor].solid}
 				/>
 			</>
@@ -739,8 +671,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = this.editor.getBounds(shape)
-		const labelSize = this.getLabelBounds(shape)
+		const geometry = this.editor.getGeometry<Group2d>(shape)
+		const bounds = geometry.bounds
+
+		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
 
 		if (!info) return null
 		if (Vec2d.Equals(start, end)) return null
@@ -755,7 +689,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const includeMask =
 			(as && info.start.arrowhead !== 'arrow') ||
 			(ae && info.end.arrowhead !== 'arrow') ||
-			labelSize !== null
+			!!labelGeometry
 
 		const maskId = (shape.id + '_clip').replace(':', '_')
 
@@ -771,15 +705,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								height={bounds.h + 200}
 								fill="white"
 							/>
-							{labelSize && (
+							{labelGeometry && (
 								<rect
-									x={labelSize.x}
-									y={labelSize.y}
-									width={labelSize.w}
-									height={labelSize.h}
+									x={toDomPrecision(labelGeometry.x)}
+									y={toDomPrecision(labelGeometry.y)}
+									width={labelGeometry.w}
+									height={labelGeometry.h}
 									fill="black"
-									rx={4}
-									ry={4}
+									rx={3.5}
+									ry={3.5}
 								/>
 							)}
 							{as && (
@@ -816,80 +750,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				</g>
 				{as && <path d={as} />}
 				{ae && <path d={ae} />}
-				{labelSize && (
+				{labelGeometry && (
 					<rect
-						x={labelSize.x}
-						y={labelSize.y}
-						width={labelSize.w}
-						height={labelSize.h}
-						rx={4}
-						ry={4}
+						x={toDomPrecision(labelGeometry.x)}
+						y={toDomPrecision(labelGeometry.y)}
+						width={labelGeometry.w}
+						height={labelGeometry.h}
+						rx={3.5}
+						ry={3.5}
 					/>
 				)}
 			</g>
 		)
 	}
 
-	@computed get labelBoundsCache(): ComputedCache<Box2d | null, TLArrowShape> {
-		return this.editor.store.createComputedCache('labelBoundsCache', (shape) => {
-			const info = this.editor.getArrowInfo(shape)
-			const bounds = this.editor.getBounds(shape)
-			const { text, font, size } = shape.props
-
-			if (!info) return null
-			if (!text.trim()) return null
-
-			const { w, h } = this.editor.textMeasure.measureText(text, {
-				...TEXT_PROPS,
-				fontFamily: FONT_FAMILIES[font],
-				fontSize: ARROW_LABEL_FONT_SIZES[size],
-				width: 'fit-content',
-			})
-
-			let width = w
-			let height = h
-
-			if (bounds.width > bounds.height) {
-				width = Math.max(Math.min(w, 64), Math.min(bounds.width - 64, w))
-
-				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
-					...TEXT_PROPS,
-					fontFamily: FONT_FAMILIES[font],
-					fontSize: ARROW_LABEL_FONT_SIZES[size],
-					width: width + 'px',
-				})
-
-				width = squishedWidth
-				height = squishedHeight
-			}
-
-			if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {
-				width = 16 * ARROW_LABEL_FONT_SIZES[size]
-
-				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(text, {
-					...TEXT_PROPS,
-					fontFamily: FONT_FAMILIES[font],
-					fontSize: ARROW_LABEL_FONT_SIZES[size],
-					width: width + 'px',
-				})
-
-				width = squishedWidth
-				height = squishedHeight
-			}
-
-			return new Box2d(
-				info.middle.x - (width + 8) / 2,
-				info.middle.y - (height + 8) / 2,
-				width + 8,
-				height + 8
-			)
-		})
-	}
-
-	getLabelBounds(shape: TLArrowShape): Box2d | null {
-		return this.labelBoundsCache.get(shape.id) || null
-	}
-
 	override onEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {
 		const {
 			id,
@@ -929,13 +803,15 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// Arrowhead end path
 		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
 
-		const bounds = this.editor.getBounds(shape)
-		const labelSize = this.getLabelBounds(shape)
+		const geometry = this.editor.getGeometry<Group2d>(shape)
+		const bounds = geometry.bounds
+
+		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
 
 		const maskId = (shape.id + '_clip').replace(':', '_')
 
 		// If we have any arrowheads, then mask the arrowheads
-		if (as || ae || labelSize) {
+		if (as || ae || !!labelGeometry) {
 			// Create mask for arrowheads
 
 			// Create defs
@@ -961,12 +837,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			if (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))
 
 			// Mask out text label if text is present
-			if (labelSize) {
+			if (labelGeometry) {
 				const labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
-				labelMask.setAttribute('x', labelSize.x + '')
-				labelMask.setAttribute('y', labelSize.y + '')
-				labelMask.setAttribute('width', labelSize.w + '')
-				labelMask.setAttribute('height', labelSize.h + '')
+				labelMask.setAttribute('x', labelGeometry.x + '')
+				labelMask.setAttribute('y', labelGeometry.y + '')
+				labelMask.setAttribute('width', labelGeometry.w + '')
+				labelMask.setAttribute('height', labelGeometry.h + '')
 				labelMask.setAttribute('fill', 'black')
 
 				mask.appendChild(labelMask)
@@ -1036,7 +912,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 
 		// Text Label
-		if (labelSize) {
+		if (labelGeometry) {
 			ctx.addExportDef(getFontDefForExport(shape.props.font))
 
 			const opts = {
@@ -1045,9 +921,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				fontFamily: DefaultFontFamilies[shape.props.font],
 				padding: 0,
 				textAlign: 'middle' as const,
-				width: labelSize.w - 8,
+				width: labelGeometry.w - 8,
 				verticalTextAlign: 'middle' as const,
-				height: labelSize.h,
+				height: labelGeometry.h,
 				fontStyle: 'normal',
 				fontWeight: 'normal',
 				overflow: 'wrap' as const,
@@ -1066,8 +942,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				const x = parseFloat(child.getAttribute('x') || '0')
 				const y = parseFloat(child.getAttribute('y') || '0')
 
-				child.setAttribute('x', x + 4 + labelSize!.x + 'px')
-				child.setAttribute('y', y + labelSize!.y + 'px')
+				child.setAttribute('x', x + 4 + labelGeometry.x + 'px')
+				child.setAttribute('y', y + labelGeometry.y + 'px')
 			})
 
 			const textBgEl = textElm.cloneNode(true) as SVGTextElement

commit 28b92c5e764ac8ce8dc1a66cd1d6248e3ddda085
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jul 26 16:32:33 2023 +0100

    [fix] restore bg option, fix calculations (#1765)
    
    This PR fixes a bug introduced with #1751 where pointing the bounds of
    rotated selections would not correctly hit the bounds background.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create a rotated selection.
    2. Point into the bounds background
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index d04fb6131..3d3dde724 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -64,6 +64,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override canSnap = () => true
 	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
+	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
 
 	override getDefaultProps(): TLArrowShape['props'] {

commit e3f4cac78656e872eddf2a12cdd214f59413de75
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jul 26 17:58:20 2023 +0100

    [fix] arrow rendering safari (#1767)
    
    This PR fixes an arrow rendering bug in Safari.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create arrows in safari
    2. Drag them

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 3d3dde724..c328e2cc2 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -571,7 +571,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
 		)
 		const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-		const includeMask = maskStartArrowhead || maskEndArrowhead || !!labelGeometry
 
 		// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
 		// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
@@ -580,44 +579,43 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return (
 			<>
 				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
-					{includeMask && (
-						<defs>
-							<mask id={maskId}>
+					{/* Yep */}
+					<defs>
+						<mask id={maskId}>
+							<rect
+								x={toDomPrecision(-100 + bounds.minX)}
+								y={toDomPrecision(-100 + bounds.minY)}
+								width={toDomPrecision(bounds.width + 200)}
+								height={toDomPrecision(bounds.height + 200)}
+								fill="white"
+							/>
+							{labelGeometry && (
 								<rect
-									x={toDomPrecision(-100 + bounds.minX)}
-									y={toDomPrecision(-100 + bounds.minY)}
-									width={toDomPrecision(bounds.width + 200)}
-									height={toDomPrecision(bounds.height + 200)}
-									fill="white"
+									x={labelGeometry.x}
+									y={labelGeometry.y}
+									width={labelGeometry.w}
+									height={labelGeometry.h}
+									fill="black"
+									rx={4}
+									ry={4}
 								/>
-								{labelGeometry && (
-									<rect
-										x={labelGeometry.x}
-										y={labelGeometry.y}
-										width={labelGeometry.w}
-										height={labelGeometry.h}
-										fill="black"
-										rx={4}
-										ry={4}
-									/>
-								)}
-								{as && maskStartArrowhead && (
-									<path
-										d={as}
-										fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
-										stroke="none"
-									/>
-								)}
-								{ae && maskEndArrowhead && (
-									<path
-										d={ae}
-										fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
-										stroke="none"
-									/>
-								)}
-							</mask>
-						</defs>
-					)}
+							)}
+							{as && maskStartArrowhead && (
+								<path
+									d={as}
+									fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+							{ae && maskEndArrowhead && (
+								<path
+									d={ae}
+									fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
+									stroke="none"
+								/>
+							)}
+						</mask>
+					</defs>
 					<g
 						fill="none"
 						stroke={theme[shape.props.color].solid}
@@ -628,17 +626,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					>
 						{handlePath}
 						{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
-						<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>
-							{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
-							{includeMask && (
-								<rect
-									x={toDomPrecision(bounds.minX - 100)}
-									y={toDomPrecision(bounds.minY - 100)}
-									width={toDomPrecision(bounds.width + 200)}
-									height={toDomPrecision(bounds.height + 200)}
-									opacity={0}
-								/>
-							)}
+						<g mask={`url(#${maskId})`}>
+							<rect
+								x={toDomPrecision(bounds.minX - 100)}
+								y={toDomPrecision(bounds.minY - 100)}
+								width={toDomPrecision(bounds.width + 200)}
+								height={toDomPrecision(bounds.height + 200)}
+								opacity={0}
+							/>
 							<path
 								d={path}
 								strokeDasharray={strokeDasharray}

commit e17074a8b3a60d26a2e54ca5b5d47622db7676be
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 14:21:14 2023 +0100

    Editor commands API / effects (#1778)
    
    This PR shrinks the commands API surface and adds a manager
    (`CleanupManager`) for side effects.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    Use the app! Especially undo and redo. Our tests are passing but I've
    found more cases where our coverage fails to catch issues.
    
    ### Release Notes
    
    - tbd

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index c328e2cc2..d1d68cf47 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -495,7 +495,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
-			return this.editor.isSafari ? (globalRenderIndex += 1) : 0
+			return this.editor.environment.isSafari ? (globalRenderIndex += 1) : 0
 			// eslint-disable-next-line react-hooks/exhaustive-deps
 		}, [shape])
 

commit 79fae186e4816f4b60f336fa80c2d85ef1debc21
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Aug 1 18:03:31 2023 +0100

    Revert "Editor commands API / effects" (#1783)
    
    Reverts tldraw/tldraw#1778.
    
    Fuzz testing picked up errors related to deleting pages and undo/redo
    which may doom this PR.
    
    ### Change Type
    
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index d1d68cf47..c328e2cc2 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -495,7 +495,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
-			return this.editor.environment.isSafari ? (globalRenderIndex += 1) : 0
+			return this.editor.isSafari ? (globalRenderIndex += 1) : 0
 			// eslint-disable-next-line react-hooks/exhaustive-deps
 		}, [shape])
 

commit c478d75117172a6b1aa7e615efa22ef54ce6e453
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 12:05:09 2023 +0100

    environment manager (#1784)
    
    This PR extracts the environment manager from #1778.
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - [editor] Move environment flags to environment manager

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index c328e2cc2..d1d68cf47 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -495,7 +495,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
-			return this.editor.isSafari ? (globalRenderIndex += 1) : 0
+			return this.editor.environment.isSafari ? (globalRenderIndex += 1) : 0
 			// eslint-disable-next-line react-hooks/exhaustive-deps
 		}, [shape])
 

commit bf277435951a1e7fa5689414670ff1866e721b50
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Aug 2 19:12:25 2023 +0100

    Rename shapes apis (#1787)
    
    This PR updates APIs related to shapes in the Editor.
    
    - removes the requirement for an `id` when creating shapes
    - `shapesOnCurrentPage` -> `currentPageShapes`
    - `findAncestor` -> `findShapeAncestor`
    - `findCommonAncestor` -> `findCommonShapeAncestor`
    - Adds `getCurrentPageShapeIds`
    - `getAncestors` -> `getShapeAncestors`
    - `getClipPath` -> `getShapeClipPath`
    - `getGeometry` -> `getShapeGeometry`
    - `getHandles` -> `getShapeHandles`
    - `getTransform` -> `getShapeLocalTransform`
    - `getPageTransform` -> `getShapePageTransform`
    - `getOutlineSegments` -> `getShapeOutlineSegments`
    - `getPageBounds` -> `getShapePageBounds`
    - `getPageTransform` -> `getShapePageTransform`
    - `getParentTransform` -> `getShapeParentTransform`
    - `selectionBounds` -> `selectionRotatedPageBounds`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index d1d68cf47..39f08825c 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -223,7 +223,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const next = deepCopy(shape) as TLArrowShape
 
-		const pageTransform = this.editor.getPageTransform(next.id)!
+		const pageTransform = this.editor.getShapePageTransform(next.id)!
 		const pointInPageSpace = pageTransform.applyToPoint(handle)
 
 		if (this.editor.inputs.ctrlKey) {
@@ -237,7 +237,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			return next
 		}
 
-		const point = this.editor.getPageTransform(shape.id)!.applyToPoint(handle)
+		const point = this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle)
 
 		const target = this.editor.getShapeAtPoint(point, {
 			filter: (shape) => this.editor.getShapeUtil(shape).canBind(shape),
@@ -258,7 +258,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// we've got a target! the handle is being dragged over a shape, bind to it
 
-		const targetGeometry = this.editor.getGeometry(target)
+		const targetGeometry = this.editor.getShapeGeometry(target)
 		const targetBounds = targetGeometry.bounds
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
@@ -491,7 +491,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			) && !this.editor.instanceState.isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = this.editor.getGeometry(shape).bounds
+		const bounds = this.editor.getShapeGeometry(shape).bounds
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
@@ -564,7 +564,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		)
 
 		const labelGeometry = shape.props.text.trim()
-			? (this.editor.getGeometry<Group2d>(shape).children[1] as Rectangle2d)
+			? (this.editor.getShapeGeometry<Group2d>(shape).children[1] as Rectangle2d)
 			: null
 
 		const maskStartArrowhead = !(
@@ -667,7 +667,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
 		const info = this.editor.getArrowInfo(shape)
-		const geometry = this.editor.getGeometry<Group2d>(shape)
+		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
 		const bounds = geometry.bounds
 
 		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
@@ -799,7 +799,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// Arrowhead end path
 		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
 
-		const geometry = this.editor.getGeometry<Group2d>(shape)
+		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
 		const bounds = geometry.bounds
 
 		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null

commit c7ae756c0b81e5ed591a884899756e1d0e635f31
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Aug 3 16:22:40 2023 +0100

    [fix] Don't make arrows shapes to arrows (#1793)
    
    This PR turns off snapping between shapes and arrows.
    
    ### Change Type
    
    - [x] `patch`
    
    ### Test Plan
    
    1. Drag a shape while snapping
    2. The shape should not snap to the position of arrows

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 39f08825c..5f0f8f57c 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -61,7 +61,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	override canEdit = () => true
 	override canBind = () => false
-	override canSnap = () => true
+	override canSnap = () => false
 	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true

commit 22329c51fcdb41111c7adf0fa4522cc675150738
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Aug 13 16:55:24 2023 +0100

    [improvement] More selection logic (#1806)
    
    This PR includes further UX improvements to selection.
    
    - clicking inside of a hollow shape will no longer select it on pointer
    up
    - clicking a shape's filled label will select it on pointer down
    - clicking a shape's empty label will select it on pointer up
    - clicking and dragging a selected arrow is now better limited to its
    body, not its bounds
    - arrows will no longer bind to labels
    
    ### Text labels
    
    A big change here relates to text labels. Previously, we had listeners
    set on the text label elements; I've removed these and we now check the
    actual label bounds geometry for a hit. For geo shapes, this geometry is
    now placed correctly based on the alignment / vertical alignment of the
    label.
    
    - Clicking on a label with text in it will select the shape on pointer
    down.
    - Clicking on an empty text label will select the shape on pointer up.
    
    ## Hollow shapes
    
    Previously, shapes with `fill: none` were also being selected on pointer
    up. I've removed that logic because it was producing wrong-feeling
    selections too often. We now select these shapes only when clicking on
    the label (as mentioned above) or when clicking on the edges of the
    shape. This is in line with the original behavior (currently on
    tldraw.com, prior to the earlier PR that updated selection logic).
    
    ## Arrows
    
    Arrows still hit the inside of hollow shapes, using the "smallest
    hovered" logic previously used for pointer-up selection on hollow
    shapes. They also now correctly do so while ignoring text labels.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. try selecting geo shapes, nested geo shapes, arrows and shapes with
    labels or without labels
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 5f0f8f57c..44ce0f524 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -101,67 +101,66 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					largeArcFlag: info.bodyArc.largeArcFlag,
 			  })
 
-		if (!shape.props.text.trim()) {
-			return bodyGeom
-		}
+		let labelGeom: Rectangle2d | undefined
 
-		const bodyBounds = bodyGeom.bounds
+		if (shape.props.text.trim()) {
+			const bodyBounds = bodyGeom.bounds
 
-		const { w, h } = this.editor.textMeasure.measureText(shape.props.text, {
-			...TEXT_PROPS,
-			fontFamily: FONT_FAMILIES[shape.props.font],
-			fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-			width: 'fit-content',
-		})
+			const { w, h } = this.editor.textMeasure.measureText(shape.props.text, {
+				...TEXT_PROPS,
+				fontFamily: FONT_FAMILIES[shape.props.font],
+				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+				width: 'fit-content',
+			})
 
-		let width = w
-		let height = h
+			let width = w
+			let height = h
 
-		if (bodyBounds.width > bodyBounds.height) {
-			width = Math.max(Math.min(w, 64), Math.min(bodyBounds.width - 64, w))
+			if (bodyBounds.width > bodyBounds.height) {
+				width = Math.max(Math.min(w, 64), Math.min(bodyBounds.width - 64, w))
 
-			const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
-				shape.props.text,
-				{
-					...TEXT_PROPS,
-					fontFamily: FONT_FAMILIES[shape.props.font],
-					fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-					width: width + 'px',
-				}
-			)
+				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
+					shape.props.text,
+					{
+						...TEXT_PROPS,
+						fontFamily: FONT_FAMILIES[shape.props.font],
+						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+						width: width + 'px',
+					}
+				)
 
-			width = squishedWidth
-			height = squishedHeight
-		}
+				width = squishedWidth
+				height = squishedHeight
+			}
 
-		if (width > 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]) {
-			width = 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]
+			if (width > 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]) {
+				width = 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]
+
+				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
+					shape.props.text,
+					{
+						...TEXT_PROPS,
+						fontFamily: FONT_FAMILIES[shape.props.font],
+						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
+						width: width + 'px',
+					}
+				)
 
-			const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
-				shape.props.text,
-				{
-					...TEXT_PROPS,
-					fontFamily: FONT_FAMILIES[shape.props.font],
-					fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-					width: width + 'px',
-				}
-			)
+				width = squishedWidth
+				height = squishedHeight
+			}
 
-			width = squishedWidth
-			height = squishedHeight
+			labelGeom = new Rectangle2d({
+				x: info.middle.x - width / 2 - 4.25,
+				y: info.middle.y - height / 2 - 4.25,
+				width: width + 8.5,
+				height: height + 8.5,
+				isFilled: true,
+			})
 		}
 
-		const labelGeom = new Rectangle2d({
-			x: info.middle.x - width / 2 - 4.25,
-			y: info.middle.y - height / 2 - 4.25,
-			width: width + 8.5,
-			height: height + 8.5,
-			isFilled: true,
-		})
-
 		return new Group2d({
-			children: [bodyGeom, labelGeom],
-			operation: 'union',
+			children: labelGeom ? [bodyGeom, labelGeom] : [bodyGeom],
 			isSnappable: false,
 		})
 	}

commit a3a780414a0734e7cfae5262e5f4fe3edd06b57d
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Thu Aug 31 10:48:39 2023 +0200

    [fix] arrows bind to locked shapes (#1833)
    
    This PR fixes a bug where arrows would bind to locked shapes.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Lock a shape.
    2. Confirm that an arrow can neither begin bound to the shape
    3. Confirm that an arrow cannot bind to the shape
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 44ce0f524..4ac4d19f0 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -239,10 +239,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const point = this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle)
 
 		const target = this.editor.getShapeAtPoint(point, {
-			filter: (shape) => this.editor.getShapeUtil(shape).canBind(shape),
 			hitInside: true,
 			hitFrameInside: true,
 			margin: 0,
+			filter: (targetShape) => {
+				return !targetShape.isLocked && this.editor.getShapeUtil(targetShape).canBind(targetShape)
+			},
 		})
 
 		if (!target) {

commit f21eaeb4d803da95d12aeaa29e810a0d588b8709
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Sep 8 15:45:30 2023 +0100

    [fix] zero width / height bounds (#1840)
    
    This PR fixes zero width or height on Geometry2d bounds. It adds the
    `zeroFix` helper to the `Box2d` class.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create a straight line
    2. Create a straight arrow that binds to the straight line
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Fix bug with straight lines / arrows

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 4ac4d19f0..507b2eef1 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1,5 +1,6 @@
 import {
 	Arc2d,
+	Box2d,
 	DefaultFontFamilies,
 	Edge2d,
 	Group2d,
@@ -260,7 +261,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// we've got a target! the handle is being dragged over a shape, bind to it
 
 		const targetGeometry = this.editor.getShapeGeometry(target)
-		const targetBounds = targetGeometry.bounds
+		const targetBounds = Box2d.ZeroFix(targetGeometry.bounds)
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
 		let precise = isPrecise
@@ -492,7 +493,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			) && !this.editor.instanceState.isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = this.editor.getShapeGeometry(shape).bounds
+		const bounds = Box2d.ZeroFix(this.editor.getShapeGeometry(shape).bounds)
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {

commit beb9db8eb7aa38e8473ba48a3b4021fbba151d43
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Sep 18 15:59:27 2023 +0100

    Fix arrow handle snapping, snapping to text labels, selection of text labels (#1910)
    
    This PR:
    - adds `canSnap` as a property to handle and ignores snapping when
    dragging a handle that does not have `canSnap` set to true. Arrows no
    longer snap.
    - adds `isLabel` to Geometry2d
    - fixes selection on empty text labels
    - fixes vertices / snapping for empty text labels
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    - [x] Unit Tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 507b2eef1..502376b58 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -157,6 +157,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				width: width + 8.5,
 				height: height + 8.5,
 				isFilled: true,
+				isLabel: true,
 			})
 		}
 

commit 9e4dbd19013ccbae28a112929cf5e50474e5028f
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Sep 26 09:05:05 2023 -0500

    [fix] geo shape text label placement (#1927)
    
    This PR fixes the text label placement for geo shapes. (It also fixes
    the way an ellipse renders when set to dash or dotted).
    
    There's still the slightest offset of the text label's outline when you
    begin editing. Maybe we should keep the indicator instead?
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    Create a hexagon shape
    hit enter to type
    indicator is offset, text label is no longer offset
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 502376b58..cd5ce2559 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -34,6 +34,7 @@ import {
 	getSolidStraightArrowPath,
 	getStraightArrowHandlePath,
 	toDomPrecision,
+	useIsEditing,
 } from '@tldraw/editor'
 import React from 'react'
 import { ShapeFill, getShapeFillSvg, useDefaultColorTheme } from '../shared/ShapeFill'
@@ -692,6 +693,22 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const maskId = (shape.id + '_clip').replace(':', '_')
 
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const isEditing = useIsEditing(shape.id)
+
+		if (isEditing && labelGeometry) {
+			return (
+				<rect
+					x={toDomPrecision(labelGeometry.x)}
+					y={toDomPrecision(labelGeometry.y)}
+					width={labelGeometry.w}
+					height={labelGeometry.h}
+					rx={3.5}
+					ry={3.5}
+				/>
+			)
+		}
+
 		return (
 			<g>
 				{includeMask && (

commit f73bf9a7fea4ca6922b8effa10412fbb9f77c288
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Mon Oct 2 12:30:53 2023 +0100

    Fix text-wrapping on Safari (#1980)
    
    Co-authored-by: Alex Alex@dytry.ch
    
    closes [#1978](https://github.com/tldraw/tldraw/issues/1978)
    
    Text was wrapping on Safari because the measure text div was rendered
    differently on different browsers. Interestingly, when forcing the
    text-measure div to be visible and on-screen in Chrome, the same
    text-wrapping behaviour was apparent. By setting white-space to 'pre'
    when width hasn't been set by the user, we can ensure that only line
    breaks the user has inputted are rendered by default on all browsers.
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. On Safari
    2. Make a new text shape and start typing
    3. At a certain point the text starts to wrap without the width having
    been set
    
    
    ### Release Notes
    
    - Fix text wrapping differently on Safari and Chrome/Firefox
    
    Before/After
    
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/320171b4-61e0-4a41-b8d3-830bd90bea65">
    <image width="350"
    src="https://github.com/tldraw/tldraw/assets/98838967/b42d7156-0ce9-4894-9692-9338dc931b79">

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index cd5ce2559..2f3dc7215 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -112,7 +112,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				...TEXT_PROPS,
 				fontFamily: FONT_FAMILIES[shape.props.font],
 				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-				width: 'fit-content',
+				width: null,
 			})
 
 			let width = w
@@ -127,7 +127,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						...TEXT_PROPS,
 						fontFamily: FONT_FAMILIES[shape.props.font],
 						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						width: width + 'px',
+						width: width,
 					}
 				)
 
@@ -144,7 +144,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						...TEXT_PROPS,
 						fontFamily: FONT_FAMILIES[shape.props.font],
 						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						width: width + 'px',
+						width: width,
 					}
 				)
 

commit 4ca4aeebe4c10b514a6995476d15bf08a8289534
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Oct 3 14:08:59 2023 +0200

    Fix hooks error. (#2000)
    
    We were conditionally using hooks, which caused the minified error when
    running the prod build of React. We now use hooks before the early
    returns.
    
    Fixes [#2001](https://github.com/tldraw/tldraw/issues/2001)
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 2f3dc7215..a7587311b 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -676,6 +676,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
 
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const isEditing = useIsEditing(shape.id)
+
 		if (!info) return null
 		if (Vec2d.Equals(start, end)) return null
 
@@ -693,9 +696,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const maskId = (shape.id + '_clip').replace(':', '_')
 
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const isEditing = useIsEditing(shape.id)
-
 		if (isEditing && labelGeometry) {
 			return (
 				<rect

commit f7b325c48c354d4a07bf431c67ad4f934a74c96b
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Oct 3 16:21:07 2023 +0200

    Fix an issue with arrow creation. (#2004)
    
    Fixes an issue with creating arrows. Currently we create an arrow that
    has both `start` and `end` handles set to the same point. This causes
    `NaN` issues in some of our functions / svg rendering. After this change
    we only create the arrow after we start dragging, which ensures the
    start and the end handle won't have the same coordinates. This probably
    feels the best way to approach it: arrow of length 0 doesn't really make
    sense.
    
    Resolves [#2005](https://github.com/tldraw/tldraw/issues/2005)
    
    Before
    
    
    https://github.com/tldraw/tldraw/assets/2523721/6e83c17e-21bd-4e0a-826b-02fad9c21ec6
    
    
    
    After
    
    
    https://github.com/tldraw/tldraw/assets/2523721/29359936-b673-4583-89c8-6d1728ab338c
    
    
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    - [ ] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Create an arrow.
    2. You should not see any errors in the console.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index a7587311b..43b1cf69a 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -55,6 +55,8 @@ import { ArrowTextLabel } from './components/ArrowTextLabel'
 
 let globalRenderIndex = 0
 
+export const ARROW_END_OFFSET = 0.1
+
 /** @public */
 export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	static override type = 'arrow' as const
@@ -78,7 +80,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			labelColor: 'black',
 			bend: 0,
 			start: { type: 'point', x: 0, y: 0 },
-			end: { type: 'point', x: 0, y: 0 },
+			end: { type: 'point', x: 2, y: 0 },
 			arrowheadStart: 'none',
 			arrowheadEnd: 'arrow',
 			text: '',

commit 92886e1f40670018589d2c14dced119e47f8e6d1
Author: alex <alex@dytry.ch>
Date:   Tue Oct 3 15:26:13 2023 +0100

    fix text in geo shapes not causing its container to grow (#2003)
    
    We got things sliggghhhtly wrong in #1980. That diff was attempting to
    fix a bug where the text measurement element would refuse to go above
    the viewport size in safari. This was most obvious in the case where
    there was no fixed width on a text shape, and that diff fixed that case,
    but it was also happening when a fixed width text shape was wider than
    viewport - which wasn't covered by that fix. It turned out that that fix
    also introduced a bug where shapes would no longer grow along the y-axis
    - in part because the relationship between `width`, `maxWidth`, and
    `minWidth` is very confusing.
    
    The one-liner fix is to just use `max-content` instead of `fit-content`
    - that way, the div ignores the size of its container. But I also
    cleared up the API for text measurement to remove the `width` property
    entirely in favour of `maxWidth`. I think this makes things much clearer
    and as far as I can tell doesn't affect anything.
    
    Closes #1998
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Test Plan
    
    1. Create an arrow & geo shape with labels, plus a note and text shape
    2. Try to break text measurement - overflow the bounds, make very wide
    text, experiment with fixed/auto-size text, etc.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 43b1cf69a..b69c7baaf 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -114,7 +114,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				...TEXT_PROPS,
 				fontFamily: FONT_FAMILIES[shape.props.font],
 				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-				width: null,
+				maxWidth: null,
 			})
 
 			let width = w
@@ -129,7 +129,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						...TEXT_PROPS,
 						fontFamily: FONT_FAMILIES[shape.props.font],
 						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						width: width,
+						maxWidth: width,
 					}
 				)
 
@@ -146,7 +146,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						...TEXT_PROPS,
 						fontFamily: FONT_FAMILIES[shape.props.font],
 						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						width: width,
+						maxWidth: width,
 					}
 				)
 

commit 5db3c1553e14edd14aa5f7c0fc85fc5efc352335
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Nov 13 11:51:22 2023 +0000

    Replace Atom.value with Atom.get() (#2189)
    
    This PR replaces the `.value` getter for the atom with `.get()`
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index b69c7baaf..603834a67 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -494,7 +494,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.pointing_handle',
 				'select.dragging_handle',
 				'arrow.dragging'
-			) && !this.editor.instanceState.isReadonly
+			) && !this.editor.getInstanceState().isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
 		const bounds = Box2d.ZeroFix(this.editor.getShapeGeometry(shape).bounds)

commit 2ca2f81f2aac16790c73bd334eda53a35a9d9f45
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 12:42:07 2023 +0000

    No impure getters pt2 (#2202)
    
    follow up to #2189

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 603834a67..99246c590 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -339,7 +339,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// If at least one bound shape is in the selection, do nothing;
 		// If no bound shapes are in the selection, unbind any bound shapes
 
-		const { selectedShapeIds } = this.editor
+		const selectedShapeIds = this.editor.getSelectedShapeIds()
 
 		if (
 			(startBindingId &&

commit 7ffda2335ce1c9b20e453436db438b08d03e9a87
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Nov 13 14:31:27 2023 +0000

    No impure getters pt3 (#2203)
    
    Follow up to #2189 and #2202
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 99246c590..c237fb0a9 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -487,7 +487,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// Not a class component, but eslint can't tell that :(
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const theme = useDefaultColorTheme()
-		const onlySelectedShape = this.editor.onlySelectedShape
+		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
 				'select.idle',

commit 6f872c796afd6cf538ce81d35c5a40dcccbe7013
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 11:57:43 2023 +0000

    No impure getters pt6 (#2218)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index c237fb0a9..ff474ef5e 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -288,7 +288,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			precise =
 				Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
 				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
-					this.editor.zoomLevel
+					this.editor.getZoomLevel()
 		}
 
 		if (!isPrecise) {

commit d683cc09432197e89bddacf2b706b5eaad40e399
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Tue Nov 14 17:07:35 2023 +0000

    No impure getters pt9 (#2222)
    
    follow up to #2189
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index ff474ef5e..3392d064e 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -803,7 +803,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.isDarkMode })
+		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		const color = theme[shape.props.color].solid

commit 7d699a749f6b384910a1e4361d477790f0658262
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri Dec 1 22:34:12 2023 +0100

    [improvements] arrows x enclosing shapes x precision. (#2265)
    
    This PR makes several improvements to the behavior of arrows as they
    relate to precision and container relationships.
    
    - an arrow's terminals are always "true" and are never snapped to { x:
    .5, y: .5 } as they were previously when not precise
    - instead, a new `isPrecise` boolean is added to the arrow terminal
    - when an arrow terminal renders "imprecisely" it will be placed to the
    center of the bound shape
    - when an arrow terminal renders "precisely" it will be placed at the
    normalized location within the bound shape
    
    ![Kapture 2023-11-29 at 23 12
    12](https://github.com/tldraw/tldraw/assets/23072548/e94e1594-75fa-4c94-86f3-7d911bf25f7f)
    
    The logic now is...
    - if the user has indicated precision by "pausing" while drawing the
    arrow, it will be precise
    - otherwise...
    - if both of an arrow's terminals are bound to the same shape, both will
    be precise
    - if a terminal is bound to a shape that contains the shape that its
    opposite terminal is bound to, it will be precise
    - if a terminal is bound to a shape that contains the shape that its
    opposite terminal is bound to, it will be precise
    - or else it will be imprecise
    
    If the spatial relationships change, the precision may change as well.
    
    Fixes https://github.com/tldraw/tldraw/issues/2204
    
    Note: a previous version of this PR was based around ancestry but that's
    not actually important.
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Test Plan
    
    1. Draw an arrow between a frame and its descendant
    2. Draw an arrow inside of a shape to another shape contained within the
    bounds of the big shape
    3. Vis versa
    4. Vis versa
    
    - [x] Unit Tests
    
    ### Release Notes
    
    - Improves the logic about when to draw "precise" arrows between the
    center of bound shapes.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 3392d064e..e0175e4f7 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -22,7 +22,6 @@ import {
 	TLShapeUtilCanvasSvgDef,
 	TLShapeUtilFlag,
 	Vec2d,
-	Vec2dModel,
 	arrowShapeMigrations,
 	arrowShapeProps,
 	deepCopy,
@@ -281,16 +280,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 
-		if (precise) {
-			// Turn off precision if we're within a certain distance to the center of the shape.
-			// Funky math but we want the snap distance to be 4 at the minimum and either
-			// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
-			precise =
-				Vec2d.Dist(pointInTargetSpace, targetBounds.center) >
-				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
-					this.editor.getZoomLevel()
-		}
-
 		if (!isPrecise) {
 			if (!targetGeometry.isClosed) {
 				precise = true
@@ -302,21 +291,36 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			if (
 				otherHandle.type === 'binding' &&
 				target.id === otherHandle.boundShapeId &&
-				Vec2d.Equals(otherHandle.normalizedAnchor, { x: 0.5, y: 0.5 })
+				otherHandle.isPrecise
 			) {
 				precise = true
 			}
 		}
 
+		const normalizedAnchor = {
+			x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
+			y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
+		}
+
+		if (precise) {
+			// Turn off precision if we're within a certain distance to the center of the shape.
+			// Funky math but we want the snap distance to be 4 at the minimum and either
+			// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
+			if (
+				Vec2d.Dist(pointInTargetSpace, targetBounds.center) <
+				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
+					this.editor.getZoomLevel()
+			) {
+				normalizedAnchor.x = 0.5
+				normalizedAnchor.y = 0.5
+			}
+		}
+
 		next.props[handleId] = {
 			type: 'binding',
 			boundShapeId: target.id,
-			normalizedAnchor: precise
-				? {
-						x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
-						y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
-				  }
-				: { x: 0.5, y: 0.5 },
+			normalizedAnchor: normalizedAnchor,
+			isPrecise: precise,
 			isExact: this.editor.inputs.altKey,
 		}
 
@@ -542,7 +546,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 							shape.props.start.type === 'binding'
 								? shape.props.start.isExact
 									? ''
-									: isPrecise(shape.props.start.normalizedAnchor)
+									: shape.props.start.isPrecise
 									? 'url(#arrowhead-cross)'
 									: 'url(#arrowhead-dot)'
 								: ''
@@ -551,7 +555,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 							shape.props.end.type === 'binding'
 								? shape.props.end.isExact
 									? ''
-									: isPrecise(shape.props.end.normalizedAnchor)
+									: shape.props.end.isPrecise
 									? 'url(#arrowhead-cross)'
 									: 'url(#arrowhead-dot)'
 								: ''
@@ -1030,7 +1034,3 @@ function getArrowheadSvgPath(
 		return path
 	}
 }
-
-function isPrecise(normalizedAnchor: Vec2dModel) {
-	return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5
-}

commit 6b1005ef71a63613a09606310f666487547d5f23
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Wed Jan 3 12:13:15 2024 +0000

    [tech debt] Primitives renaming party / cleanup (#2396)
    
    This PR:
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers
    - removes unused exports
    - removes a few redundant tests in dgreensp
    
    ### Change Type
    
    - [x] `major` — Breaking change
    
    ### Release Notes
    
    - renames Vec2d to Vec
    - renames Vec2dModel to VecModel
    - renames Box2d to Box
    - renames Box2dModel to BoxModel
    - renames Matrix2d to Mat
    - renames Matrix2dModel to MatModel
    - removes unused primitive helpers

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index e0175e4f7..8334720b9 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1,6 +1,6 @@
 import {
 	Arc2d,
-	Box2d,
+	Box,
 	DefaultFontFamilies,
 	Edge2d,
 	Group2d,
@@ -21,17 +21,12 @@ import {
 	TLShapePartial,
 	TLShapeUtilCanvasSvgDef,
 	TLShapeUtilFlag,
-	Vec2d,
+	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
 	deepCopy,
 	getArrowTerminalsInArrowSpace,
-	getArrowheadPathForType,
-	getCurvedArrowHandlePath,
 	getDefaultColorTheme,
-	getSolidCurvedArrowPath,
-	getSolidStraightArrowPath,
-	getStraightArrowHandlePath,
 	toDomPrecision,
 	useIsEditing,
 } from '@tldraw/editor'
@@ -50,6 +45,13 @@ import {
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { getArrowheadPathForType } from './arrowheads'
+import {
+	getCurvedArrowHandlePath,
+	getSolidCurvedArrowPath,
+	getSolidStraightArrowPath,
+	getStraightArrowHandlePath,
+} from './arrowpaths'
 import { ArrowTextLabel } from './components/ArrowTextLabel'
 
 let globalRenderIndex = 0
@@ -92,14 +94,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const bodyGeom = info.isStraight
 			? new Edge2d({
-					start: Vec2d.From(info.start.point),
-					end: Vec2d.From(info.end.point),
+					start: Vec.From(info.start.point),
+					end: Vec.From(info.end.point),
 			  })
 			: new Arc2d({
-					center: Vec2d.Cast(info.handleArc.center),
+					center: Vec.Cast(info.handleArc.center),
 					radius: info.handleArc.radius,
-					start: Vec2d.Cast(info.start.point),
-					end: Vec2d.Cast(info.end.point),
+					start: Vec.Cast(info.start.point),
+					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
 			  })
@@ -209,16 +211,16 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			// Bending the arrow...
 			const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
-			const delta = Vec2d.Sub(end, start)
-			const v = Vec2d.Per(delta)
+			const delta = Vec.Sub(end, start)
+			const v = Vec.Per(delta)
 
-			const med = Vec2d.Med(end, start)
-			const A = Vec2d.Sub(med, v)
-			const B = Vec2d.Add(med, v)
+			const med = Vec.Med(end, start)
+			const A = Vec.Sub(med, v)
+			const B = Vec.Add(med, v)
 
-			const point = Vec2d.NearestPointOnLineSegment(A, B, handle, false)
-			let bend = Vec2d.Dist(point, med)
-			if (Vec2d.Clockwise(point, end, med)) bend *= -1
+			const point = Vec.NearestPointOnLineSegment(A, B, handle, false)
+			let bend = Vec.Dist(point, med)
+			if (Vec.Clockwise(point, end, med)) bend *= -1
 			return { id: shape.id, type: shape.type, props: { bend } }
 		}
 
@@ -264,7 +266,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// we've got a target! the handle is being dragged over a shape, bind to it
 
 		const targetGeometry = this.editor.getShapeGeometry(target)
-		const targetBounds = Box2d.ZeroFix(targetGeometry.bounds)
+		const targetBounds = Box.ZeroFix(targetGeometry.bounds)
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
 		let precise = isPrecise
@@ -307,7 +309,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			// Funky math but we want the snap distance to be 4 at the minimum and either
 			// 16 or 15% of the smaller dimension of the target shape, whichever is smaller
 			if (
-				Vec2d.Dist(pointInTargetSpace, targetBounds.center) <
+				Vec.Dist(pointInTargetSpace, targetBounds.center) <
 				Math.max(4, Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)) /
 					this.editor.getZoomLevel()
 			) {
@@ -326,7 +328,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (next.props.start.type === 'binding' && next.props.end.type === 'binding') {
 			if (next.props.start.boundShapeId === next.props.end.boundShapeId) {
-				if (Vec2d.Equals(next.props.start.normalizedAnchor, next.props.end.normalizedAnchor)) {
+				if (Vec.Equals(next.props.start.normalizedAnchor, next.props.end.normalizedAnchor)) {
 					next.props.end.normalizedAnchor.x += 0.05
 				}
 			}
@@ -501,7 +503,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			) && !this.editor.getInstanceState().isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = Box2d.ZeroFix(this.editor.getShapeGeometry(shape).bounds)
+		const bounds = Box.ZeroFix(this.editor.getShapeGeometry(shape).bounds)
 
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const changeIndex = React.useMemo<number>(() => {
@@ -524,7 +526,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			const sw = 2
 			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
 				info.isStraight
-					? Vec2d.Dist(info.start.handle, info.end.handle)
+					? Vec.Dist(info.start.handle, info.end.handle)
 					: Math.abs(info.handleArc.length),
 				sw,
 				{
@@ -686,7 +688,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const isEditing = useIsEditing(shape.id)
 
 		if (!info) return null
-		if (Vec2d.Equals(start, end)) return null
+		if (Vec.Equals(start, end)) return null
 
 		const strokeWidth = STROKE_SIZES[shape.props.size]
 

commit 231354d93c521c12071105fce1ae486c96aa862d
Author: alex <alex@dytry.ch>
Date:   Sat Jan 13 20:09:05 2024 +0000

    Maintain bindings whilst translating arrows (#2424)
    
    This diff tries to maintain bindings whilst translating arrows. It looks
    at where the terminal of the arrow ends up, and if it's still over the
    same shape, it updates the binding to a precise one at that location
    rather than removing the binding entirely.
    
    ![Kapture 2024-01-08 at 18 22
    12](https://github.com/tldraw/tldraw/assets/1489520/b97ce5d9-ac02-456e-aaa6-ffe06825ed1d)
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Create an arrow with bindings
    2. Move the arrow (translation, stacking, nudging, distribution, etc)
    3. Make sure that the end point of the arrow remains bound if
    appropriate
    
    - [x] Unit Tests
    
    
    ### Release Notes
    
    - You can now move arrows without them becoming unattached the shapes
    they're pointing to
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8334720b9..99a54ef61 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -10,6 +10,7 @@ import {
 	SvgExportContext,
 	TLArrowShape,
 	TLArrowShapeArrowheadStyle,
+	TLArrowShapeProps,
 	TLDefaultColorStyle,
 	TLDefaultColorTheme,
 	TLDefaultFillStyle,
@@ -17,6 +18,7 @@ import {
 	TLOnEditEndHandler,
 	TLOnHandleChangeHandler,
 	TLOnResizeHandler,
+	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
 	TLShapePartial,
 	TLShapeUtilCanvasSvgDef,
@@ -27,6 +29,8 @@ import {
 	deepCopy,
 	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
+	mapObjectMapValues,
+	objectMapEntries,
 	toDomPrecision,
 	useIsEditing,
 } from '@tldraw/editor'
@@ -342,6 +346,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null
 		const endBindingId = shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
 
+		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape)
+		const shapePageTransform = this.editor.getShapePageTransform(shape.id)!
+
 		// If at least one bound shape is in the selection, do nothing;
 		// If no bound shapes are in the selection, unbind any bound shapes
 
@@ -357,25 +364,91 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			return
 		}
 
-		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
+		let result = shape
 
-		return {
-			id: shape.id,
-			type: shape.type,
-			props: {
-				...shape.props,
-				start: {
-					type: 'point',
-					x: start.x,
-					y: start.y,
-				},
-				end: {
-					type: 'point',
-					x: end.x,
-					y: end.y,
+		// When we start translating shapes, record where their bindings were in page space so we
+		// can maintain them as we translate the arrow
+		shapeAtTranslationStart.set(shape, {
+			pagePosition: shapePageTransform.applyToPoint(shape),
+			terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
+				const terminal = shape.props[terminalName]
+				if (terminal.type !== 'binding') return null
+				return {
+					binding: terminal,
+					shapePosition: point,
+					pagePosition: shapePageTransform.applyToPoint(point),
+				}
+			}),
+		})
+
+		for (const handleName of ['start', 'end'] as const) {
+			const terminal = shape.props[handleName]
+			if (terminal.type !== 'binding') continue
+			result = {
+				...shape,
+				props: { ...shape.props, [handleName]: { ...terminal, isPrecise: true } },
+			}
+		}
+
+		return result
+	}
+
+	override onTranslate?: TLOnTranslateHandler<TLArrowShape> = (initialShape, shape) => {
+		const atTranslationStart = shapeAtTranslationStart.get(initialShape)
+		if (!atTranslationStart) return
+
+		const shapePageTransform = this.editor.getShapePageTransform(shape.id)!
+		const pageDelta = Vec.Sub(
+			shapePageTransform.applyToPoint(shape),
+			atTranslationStart.pagePosition
+		)
+
+		let result = shape
+		for (const [terminalName, terminalBinding] of objectMapEntries(
+			atTranslationStart.terminalBindings
+		)) {
+			if (!terminalBinding) continue
+
+			const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5))
+			const newTarget = this.editor.getShapeAtPoint(newPagePoint, {
+				hitInside: true,
+				hitFrameInside: true,
+				margin: 0,
+				filter: (targetShape) => {
+					return !targetShape.isLocked && this.editor.getShapeUtil(targetShape).canBind(targetShape)
 				},
-			},
+			})
+
+			if (newTarget?.id === terminalBinding.binding.boundShapeId) {
+				const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds)
+				const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint)
+				const normalizedAnchor = {
+					x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
+					y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
+				}
+				result = {
+					...result,
+					props: {
+						...result.props,
+						[terminalName]: { ...terminalBinding.binding, isPrecise: true, normalizedAnchor },
+					},
+				}
+			} else {
+				result = {
+					...result,
+					props: {
+						...result.props,
+						[terminalName]: {
+							type: 'point',
+							x: terminalBinding.shapePosition.x,
+							y: terminalBinding.shapePosition.y,
+						},
+					},
+				}
+			}
 		}
+
+		return result
 	}
 
 	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
@@ -499,6 +572,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.idle',
 				'select.pointing_handle',
 				'select.dragging_handle',
+				'select.translating',
 				'arrow.dragging'
 			) && !this.editor.getInstanceState().isReadonly
 
@@ -1036,3 +1110,18 @@ function getArrowheadSvgPath(
 		return path
 	}
 }
+
+const shapeAtTranslationStart = new WeakMap<
+	TLArrowShape,
+	{
+		pagePosition: Vec
+		terminalBindings: Record<
+			'start' | 'end',
+			{
+				pagePosition: Vec
+				shapePosition: Vec
+				binding: Extract<TLArrowShapeProps['start'], { type: 'binding' }>
+			} | null
+		>
+	}
+>()

commit 1f425dcab314aef1d672cb3b357275e26c5abf21
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jan 14 16:27:16 2024 +0000

    [tweak] dark mode colors (#2469)
    
    This PR fixes a few dark mode colors and removes some unused styles.
    
    ### Change Type
    
    - [x] `patch` — Bug fix

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 99a54ef61..186b2c55c 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -567,6 +567,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
+
 		const shouldDisplayHandles =
 			this.editor.isInAny(
 				'select.idle',

commit 29044867dd2e49a3711e95c547fa9352e66720b9
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Jan 15 12:33:15 2024 +0000

    Add docs (#2470)
    
    This PR adds the docs app back into the tldraw monorepo.
    
    ## Deploying
    
    We'll want to update our deploy script to update the SOURCE_SHA to the
    newest release sha... and then deploy the docs pulling api.json files
    from that release. We _could_ update the docs on every push to main, but
    we don't have to unless something has changed. Right now there's no
    automated deployments from this repo.
    
    ## Side effects
    
    To make this one work, I needed to update the lock file. This might be
    ok (new year new lock file), and everything builds as expected, though
    we may want to spend some time with our scripts to be sure that things
    are all good.
    
    I also updated our prettier installation, which decided to add trailing
    commas to every generic type. Which is, I suppose, [correct
    behavior](https://github.com/prettier/prettier-vscode/issues/955)? But
    that caused diffs in every file, which is unfortunate.
    
    ### Change Type
    
    - [x] `internal` — Any other changes that don't affect the published
    package[^2]

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 186b2c55c..5697e0193 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -100,7 +100,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-			  })
+				})
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
 					radius: info.handleArc.radius,
@@ -108,7 +108,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-			  })
+				})
 
 		let labelGeom: Rectangle2d | undefined
 
@@ -595,7 +595,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
 
-		let handlePath: null | JSX.Element = null
+		let handlePath: null | React.JSX.Element = null
 
 		if (onlySelectedShape === shape && shouldDisplayHandles) {
 			const sw = 2
@@ -624,8 +624,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.start.isExact
 									? ''
 									: shape.props.start.isPrecise
-									? 'url(#arrowhead-cross)'
-									: 'url(#arrowhead-dot)'
+										? 'url(#arrowhead-cross)'
+										: 'url(#arrowhead-dot)'
 								: ''
 						}
 						markerEnd={
@@ -633,8 +633,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.end.isExact
 									? ''
 									: shape.props.end.isPrecise
-									? 'url(#arrowhead-cross)'
-									: 'url(#arrowhead-dot)'
+										? 'url(#arrowhead-cross)'
+										: 'url(#arrowhead-dot)'
 								: ''
 						}
 						opacity={0.16}

commit 07cda7ef9fd9008c2feebce20659e2d087ddbdd3
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jan 24 10:19:20 2024 +0000

    arrows: add ability to change label placement (#2557)
    
    This adds the ability to drag the label on an arrow to a different
    location within the line segment/arc.
    
    
    https://github.com/tldraw/tldraw/assets/469604/dbd2ee35-bebc-48d6-b8ee-fcf12ce91fa5
    
    - A lot of the complexity lay in ensuring a fixed distance from the ends
    of the arrowheads.
    - I added a new type of handle `text-adjust` that makes the text box the
    very handle itself.
    - I added a `ARROW_HANDLES` enum - we should use more enums!
    - The bulk of the changes are in ArrowShapeUtil — check that out in
    particular obviously :)
    
    Along the way, I tried to improve a couple spots as I touched them:
    - added some more documentation to Vec.ts because some of the functions
    in there were obscure/new to me. (at least the naming, hah)
    - added `getPointOnCircle` which was being done in a couple places
    independently and refactored those places.
    
    ### Questions
    - the `getPointOnCircle` API changed. Is this considered breaking and/or
    should I leave the signature the same? Wasn't sure if it was a big deal
    or not.
    - I made `labelPosition` in the schema always but I guess it could have
    been optional? Lemme know if there's a preference.
    - Any feedback on tests? Happy to expand those if necessary.
    
    ### Change Type
    
    - [ ] `patch` — Bug fix
    - [x] `minor` — New feature
    - [ ] `major` — Breaking change
    - [ ] `dependencies` — Changes to package dependencies[^1]
    - [ ] `documentation` — Changes to the documentation only[^2]
    - [ ] `tests` — Changes to any test code only[^2]
    - [ ] `internal` — Any other changes that don't affect the published
    package[^2]
    - [ ] I don't know
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. For arrow in [straightArrow, curvedArrow] test the following:
       a. Label in the middle
       b. Label at both ends of the arrow
       c. Test arrows in different directions
    d. Rotating the endpoints and seeing that the label stays at the end of
    the arrow at a fixed width.
       e. Test different stroke widths.
       f. Test with different arrowheads.
    2. Also, test arcs that are more circle like than arc-like.
    
    - [x] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Adds ability to change label position on arrows.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 5697e0193..05231db7b 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -3,6 +3,7 @@ import {
 	Box,
 	DefaultFontFamilies,
 	Edge2d,
+	Geometry2d,
 	Group2d,
 	Rectangle2d,
 	SVGContainer,
@@ -16,7 +17,8 @@ import {
 	TLDefaultFillStyle,
 	TLHandle,
 	TLOnEditEndHandler,
-	TLOnHandleChangeHandler,
+	TLOnHandleDragHandler,
+	TLOnHandleDragStartHandler,
 	TLOnResizeHandler,
 	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
@@ -26,7 +28,10 @@ import {
 	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
+	clockwiseAngleDist,
+	counterClockwiseAngleDist,
 	deepCopy,
+	featureFlags,
 	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
 	mapObjectMapValues,
@@ -37,18 +42,14 @@ import {
 import React from 'react'
 import { ShapeFill, getShapeFillSvg, useDefaultColorTheme } from '../shared/ShapeFill'
 import { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'
-import {
-	ARROW_LABEL_FONT_SIZES,
-	FONT_FAMILIES,
-	STROKE_SIZES,
-	TEXT_PROPS,
-} from '../shared/default-shape-constants'
+import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
 import {
 	getFillDefForCanvas,
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
+import { getArrowLabelPosition } from './arrowLabel'
 import { getArrowheadPathForType } from './arrowheads'
 import {
 	getCurvedArrowHandlePath,
@@ -60,7 +61,12 @@ import { ArrowTextLabel } from './components/ArrowTextLabel'
 
 let globalRenderIndex = 0
 
-export const ARROW_END_OFFSET = 0.1
+enum ARROW_HANDLES {
+	START = 'start',
+	MIDDLE = 'middle',
+	LABEL = 'middle-text',
+	END = 'end',
+}
 
 /** @public */
 export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
@@ -89,6 +95,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			arrowheadStart: 'none',
 			arrowheadEnd: 'arrow',
 			text: '',
+			labelPosition: 0.5,
 			font: 'draw',
 		}
 	}
@@ -96,6 +103,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	getGeometry(shape: TLArrowShape) {
 		const info = this.editor.getArrowInfo(shape)!
 
+		const debugGeom: Geometry2d[] = []
+
 		const bodyGeom = info.isStraight
 			? new Edge2d({
 					start: Vec.From(info.start.point),
@@ -110,76 +119,45 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					largeArcFlag: info.bodyArc.largeArcFlag,
 				})
 
-		let labelGeom: Rectangle2d | undefined
-
+		let labelGeom
 		if (shape.props.text.trim()) {
-			const bodyBounds = bodyGeom.bounds
-
-			const { w, h } = this.editor.textMeasure.measureText(shape.props.text, {
-				...TEXT_PROPS,
-				fontFamily: FONT_FAMILIES[shape.props.font],
-				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-				maxWidth: null,
-			})
-
-			let width = w
-			let height = h
-
-			if (bodyBounds.width > bodyBounds.height) {
-				width = Math.max(Math.min(w, 64), Math.min(bodyBounds.width - 64, w))
-
-				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
-					shape.props.text,
-					{
-						...TEXT_PROPS,
-						fontFamily: FONT_FAMILIES[shape.props.font],
-						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						maxWidth: width,
-					}
-				)
-
-				width = squishedWidth
-				height = squishedHeight
-			}
-
-			if (width > 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]) {
-				width = 16 * ARROW_LABEL_FONT_SIZES[shape.props.size]
-
-				const { w: squishedWidth, h: squishedHeight } = this.editor.textMeasure.measureText(
-					shape.props.text,
-					{
-						...TEXT_PROPS,
-						fontFamily: FONT_FAMILIES[shape.props.font],
-						fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-						maxWidth: width,
-					}
-				)
-
-				width = squishedWidth
-				height = squishedHeight
-			}
-
+			const labelPosition = getArrowLabelPosition(this.editor, shape)
+			debugGeom.push(...labelPosition.debugGeom)
 			labelGeom = new Rectangle2d({
-				x: info.middle.x - width / 2 - 4.25,
-				y: info.middle.y - height / 2 - 4.25,
-				width: width + 8.5,
-				height: height + 8.5,
+				x: labelPosition.box.x,
+				y: labelPosition.box.y,
+				width: labelPosition.box.w,
+				height: labelPosition.box.h,
 				isFilled: true,
 				isLabel: true,
 			})
 		}
 
 		return new Group2d({
-			children: labelGeom ? [bodyGeom, labelGeom] : [bodyGeom],
+			children: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],
 			isSnappable: false,
 		})
 	}
 
+	private getLength(shape: TLArrowShape): number {
+		const info = this.editor.getArrowInfo(shape)!
+
+		return info.isStraight
+			? Vec.Dist(info.start.handle, info.end.handle)
+			: Math.abs(info.handleArc.length)
+	}
+
 	override getHandles(shape: TLArrowShape): TLHandle[] {
 		const info = this.editor.getArrowInfo(shape)!
+
+		const hasText = shape.props.text.trim()
+		const labelGeometry = hasText
+			? (this.editor.getShapeGeometry<Group2d>(shape).children[1] as Rectangle2d)
+			: null
+
 		return [
 			{
-				id: 'start',
+				id: ARROW_HANDLES.START,
 				type: 'vertex',
 				index: 'a0',
 				x: info.start.handle.x,
@@ -187,31 +165,52 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				canBind: true,
 			},
 			{
-				id: 'middle',
+				id: ARROW_HANDLES.MIDDLE,
 				type: 'virtual',
 				index: 'a2',
 				x: info.middle.x,
 				y: info.middle.y,
 				canBind: false,
 			},
+			featureFlags.canMoveArrowLabel.get() &&
+				labelGeometry && {
+					id: ARROW_HANDLES.LABEL,
+					type: 'text-adjust',
+					index: 'a4',
+					x: labelGeometry.x,
+					y: labelGeometry.y,
+					w: labelGeometry.w,
+					h: labelGeometry.h,
+					canBind: false,
+				},
 			{
-				id: 'end',
+				id: ARROW_HANDLES.END,
 				type: 'vertex',
 				index: 'a3',
 				x: info.end.handle.x,
 				y: info.end.handle.y,
 				canBind: true,
 			},
-		]
+		].filter(Boolean) as TLHandle[]
 	}
 
-	override onHandleChange: TLOnHandleChangeHandler<TLArrowShape> = (
-		shape,
-		{ handle, isPrecise }
-	) => {
-		const handleId = handle.id as 'start' | 'middle' | 'end'
+	private _labelDragOffset = new Vec(0, 0)
+	override onHandleDragStart: TLOnHandleDragStartHandler<TLArrowShape> = (shape) => {
+		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
+		const labelGeometry = geometry.children[1] as Rectangle2d
+		if (labelGeometry) {
+			const pointInShapeSpace = this.editor.getPointInShapeSpace(
+				shape,
+				this.editor.inputs.currentPagePoint
+			)
+			this._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace)
+		}
+	}
+
+	override onHandleDrag: TLOnHandleDragHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {
+		const handleId = handle.id as ARROW_HANDLES
 
-		if (handleId === 'middle') {
+		if (handleId === ARROW_HANDLES.MIDDLE) {
 			// Bending the arrow...
 			const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
 
@@ -228,13 +227,46 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			return { id: shape.id, type: shape.type, props: { bend } }
 		}
 
+		// This is for moving the text label to a different position on the arrow.
+		if (handleId === ARROW_HANDLES.LABEL) {
+			const next = deepCopy(shape) as TLArrowShape
+			const info = this.editor.getArrowInfo(shape)!
+
+			const geometry = this.editor.getShapeGeometry<Group2d>(shape)
+			const lineGeometry = geometry.children[0] as Geometry2d
+			const pointInShapeSpace = this.editor.getPointInShapeSpace(
+				shape,
+				this.editor.inputs.currentPagePoint
+			)
+			const nearestPoint = lineGeometry.nearestPoint(
+				Vec.Add(pointInShapeSpace, this._labelDragOffset)
+			)
+
+			let nextLabelPosition
+			if (info.isStraight) {
+				const lineLength = Vec.Dist(info.start.point, info.end.point)
+				const segmentLength = Vec.Dist(info.end.point, nearestPoint)
+				nextLabelPosition = 1 - segmentLength / lineLength
+			} else {
+				const isClockwise = shape.props.bend < 0
+				const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist
+
+				const angleCenterNearestPoint = Vec.Angle(info.handleArc.center, nearestPoint)
+				const angleCenterStart = Vec.Angle(info.handleArc.center, info.start.point)
+				const angleCenterEnd = Vec.Angle(info.handleArc.center, info.end.point)
+				const arcLength = distFn(angleCenterStart, angleCenterEnd)
+				const segmentLength = distFn(angleCenterNearestPoint, angleCenterEnd)
+				nextLabelPosition = 1 - segmentLength / arcLength
+			}
+			next.props.labelPosition = nextLabelPosition
+
+			return next
+		}
+
 		// Start or end, pointing the arrow...
 
 		const next = deepCopy(shape) as TLArrowShape
 
-		const pageTransform = this.editor.getShapePageTransform(next.id)!
-		const pointInPageSpace = pageTransform.applyToPoint(handle)
-
 		if (this.editor.inputs.ctrlKey) {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			// Skip binding
@@ -271,6 +303,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const targetGeometry = this.editor.getShapeGeometry(target)
 		const targetBounds = Box.ZeroFix(targetGeometry.bounds)
+		const pageTransform = this.editor.getShapePageTransform(next.id)!
+		const pointInPageSpace = pageTransform.applyToPoint(handle)
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
 		let precise = isPrecise
@@ -293,7 +327,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 			// Double check that we're not going to be doing an imprecise snap on
 			// the same shape twice, as this would result in a zero length line
-			const otherHandle = next.props[handleId === 'start' ? 'end' : 'start']
+			const otherHandle =
+				next.props[handleId === ARROW_HANDLES.START ? ARROW_HANDLES.END : ARROW_HANDLES.START]
 			if (
 				otherHandle.type === 'binding' &&
 				target.id === otherHandle.boundShapeId &&
@@ -381,7 +416,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}),
 		})
 
-		for (const handleName of ['start', 'end'] as const) {
+		for (const handleName of [ARROW_HANDLES.START, ARROW_HANDLES.END] as const) {
 			const terminal = shape.props[handleName]
 			if (terminal.type !== 'binding') continue
 			result = {
@@ -539,7 +574,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		handle: TLHandle
 	): TLShapePartial<TLArrowShape> | void => {
 		switch (handle.id) {
-			case 'start': {
+			case ARROW_HANDLES.START: {
 				return {
 					id: shape.id,
 					type: shape.type,
@@ -549,7 +584,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					},
 				}
 			}
-			case 'end': {
+			case ARROW_HANDLES.END: {
 				return {
 					id: shape.id,
 					type: shape.type,
@@ -599,17 +634,11 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (onlySelectedShape === shape && shouldDisplayHandles) {
 			const sw = 2
-			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-				info.isStraight
-					? Vec.Dist(info.start.handle, info.end.handle)
-					: Math.abs(info.handleArc.length),
-				sw,
-				{
-					end: 'skip',
-					start: 'skip',
-					lengthRatio: 2.5,
-				}
-			)
+			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(this.getLength(shape), sw, {
+				end: 'skip',
+				start: 'skip',
+				lengthRatio: 2.5,
+			})
 
 			handlePath =
 				shape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (
@@ -650,9 +679,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		)
 
-		const labelGeometry = shape.props.text.trim()
-			? (this.editor.getShapeGeometry<Group2d>(shape).children[1] as Rectangle2d)
-			: null
+		const labelPosition = getArrowLabelPosition(this.editor, shape)
 
 		const maskStartArrowhead = !(
 			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
@@ -676,12 +703,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								height={toDomPrecision(bounds.height + 200)}
 								fill="white"
 							/>
-							{labelGeometry && (
+							{shape.props.text.trim() && (
 								<rect
-									x={labelGeometry.x}
-									y={labelGeometry.y}
-									width={labelGeometry.w}
-									height={labelGeometry.h}
+									x={labelPosition.box.x}
+									y={labelPosition.box.y}
+									width={labelPosition.box.w}
+									height={labelPosition.box.h}
 									fill="black"
 									rx={4}
 									ry={4}
@@ -742,8 +769,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					text={shape.props.text}
 					font={shape.props.font}
 					size={shape.props.size}
-					position={info.middle}
-					width={labelGeometry?.w ?? 0}
+					position={labelPosition.box.center}
+					width={labelPosition.box.w}
 					labelColor={theme[shape.props.labelColor].solid}
 				/>
 			</>

commit 34a95b2ec8811fc50eaf74a9a4139909e9b834b7
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Jan 31 11:17:03 2024 +0000

    arrows: separate out handle behavior from labels (#2621)
    
    This is a followup on the arrows work.
    - allow labels to go to the ends if no arrowhead is present
    - avoid using / overloading TLHandle and use a new PointingLabel state
    to specifically address label movement
    - removes the feature flag to launch this feature!
    
    ### Change Type
    
    - [x] `patch` — Bug fix
    
    ### Release Notes
    
    - Arrow labels: provide more polish on label placement
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 05231db7b..fc7d7013d 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -18,7 +18,6 @@ import {
 	TLHandle,
 	TLOnEditEndHandler,
 	TLOnHandleDragHandler,
-	TLOnHandleDragStartHandler,
 	TLOnResizeHandler,
 	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
@@ -28,10 +27,7 @@ import {
 	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
-	clockwiseAngleDist,
-	counterClockwiseAngleDist,
 	deepCopy,
-	featureFlags,
 	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
 	mapObjectMapValues,
@@ -64,7 +60,6 @@ let globalRenderIndex = 0
 enum ARROW_HANDLES {
 	START = 'start',
 	MIDDLE = 'middle',
-	LABEL = 'middle-text',
 	END = 'end',
 }
 
@@ -150,11 +145,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override getHandles(shape: TLArrowShape): TLHandle[] {
 		const info = this.editor.getArrowInfo(shape)!
 
-		const hasText = shape.props.text.trim()
-		const labelGeometry = hasText
-			? (this.editor.getShapeGeometry<Group2d>(shape).children[1] as Rectangle2d)
-			: null
-
 		return [
 			{
 				id: ARROW_HANDLES.START,
@@ -172,17 +162,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				y: info.middle.y,
 				canBind: false,
 			},
-			featureFlags.canMoveArrowLabel.get() &&
-				labelGeometry && {
-					id: ARROW_HANDLES.LABEL,
-					type: 'text-adjust',
-					index: 'a4',
-					x: labelGeometry.x,
-					y: labelGeometry.y,
-					w: labelGeometry.w,
-					h: labelGeometry.h,
-					canBind: false,
-				},
 			{
 				id: ARROW_HANDLES.END,
 				type: 'vertex',
@@ -194,19 +173,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		].filter(Boolean) as TLHandle[]
 	}
 
-	private _labelDragOffset = new Vec(0, 0)
-	override onHandleDragStart: TLOnHandleDragStartHandler<TLArrowShape> = (shape) => {
-		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
-		const labelGeometry = geometry.children[1] as Rectangle2d
-		if (labelGeometry) {
-			const pointInShapeSpace = this.editor.getPointInShapeSpace(
-				shape,
-				this.editor.inputs.currentPagePoint
-			)
-			this._labelDragOffset = Vec.Sub(labelGeometry.center, pointInShapeSpace)
-		}
-	}
-
 	override onHandleDrag: TLOnHandleDragHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {
 		const handleId = handle.id as ARROW_HANDLES
 
@@ -227,42 +193,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			return { id: shape.id, type: shape.type, props: { bend } }
 		}
 
-		// This is for moving the text label to a different position on the arrow.
-		if (handleId === ARROW_HANDLES.LABEL) {
-			const next = deepCopy(shape) as TLArrowShape
-			const info = this.editor.getArrowInfo(shape)!
-
-			const geometry = this.editor.getShapeGeometry<Group2d>(shape)
-			const lineGeometry = geometry.children[0] as Geometry2d
-			const pointInShapeSpace = this.editor.getPointInShapeSpace(
-				shape,
-				this.editor.inputs.currentPagePoint
-			)
-			const nearestPoint = lineGeometry.nearestPoint(
-				Vec.Add(pointInShapeSpace, this._labelDragOffset)
-			)
-
-			let nextLabelPosition
-			if (info.isStraight) {
-				const lineLength = Vec.Dist(info.start.point, info.end.point)
-				const segmentLength = Vec.Dist(info.end.point, nearestPoint)
-				nextLabelPosition = 1 - segmentLength / lineLength
-			} else {
-				const isClockwise = shape.props.bend < 0
-				const distFn = isClockwise ? clockwiseAngleDist : counterClockwiseAngleDist
-
-				const angleCenterNearestPoint = Vec.Angle(info.handleArc.center, nearestPoint)
-				const angleCenterStart = Vec.Angle(info.handleArc.center, info.start.point)
-				const angleCenterEnd = Vec.Angle(info.handleArc.center, info.end.point)
-				const arcLength = distFn(angleCenterStart, angleCenterEnd)
-				const segmentLength = distFn(angleCenterNearestPoint, angleCenterEnd)
-				nextLabelPosition = 1 - segmentLength / arcLength
-			}
-			next.props.labelPosition = nextLabelPosition
-
-			return next
-		}
-
 		// Start or end, pointing the arrow...
 
 		const next = deepCopy(shape) as TLArrowShape

commit e6e4e7f6cbac1cb72c0f530dae703c657dc8b6bf
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Feb 5 17:54:02 2024 +0000

    [dx] use Biome instead of Prettier, part 2 (#2731)
    
    Biome seems to be MUCH faster than Prettier. Unfortunately, it
    introduces some formatting changes around the ternary operator, so we
    have to update files in the repo. To make revert easier if we need it,
    the change is split into two PRs. This PR introduces a Biome CI check
    and reformats all files accordingly.
    
    ## Change Type
    - [x] `minor` — New feature

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index fc7d7013d..ac125e04c 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -104,7 +104,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-				})
+			  })
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
 					radius: info.handleArc.radius,
@@ -112,7 +112,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-				})
+			  })
 
 		let labelGeom
 		if (shape.props.text.trim()) {
@@ -583,8 +583,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.start.isExact
 									? ''
 									: shape.props.start.isPrecise
-										? 'url(#arrowhead-cross)'
-										: 'url(#arrowhead-dot)'
+									  ? 'url(#arrowhead-cross)'
+									  : 'url(#arrowhead-dot)'
 								: ''
 						}
 						markerEnd={
@@ -592,8 +592,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.end.isExact
 									? ''
 									: shape.props.end.isPrecise
-										? 'url(#arrowhead-cross)'
-										: 'url(#arrowhead-dot)'
+									  ? 'url(#arrowhead-cross)'
+									  : 'url(#arrowhead-dot)'
 								: ''
 						}
 						opacity={0.16}

commit 86cce6d161e2018f02fc4271bbcff803d07fa339
Author: Dan Groshev <git@dgroshev.com>
Date:   Wed Feb 7 16:02:22 2024 +0000

    Unbiome (#2776)
    
    Biome as it is now didn't work out for us 😢
    
    Summary for posterity:
    
    * it IS much, much faster, fast enough to skip any sort of caching
    * we couldn't fully replace Prettier just yet. We use Prettier
    programmatically to format code in docs, and Biome's JS interface is
    officially alpha and [had legacy peer deps
    set](https://github.com/biomejs/biome/pull/1756) (which would fail our
    CI build as we don't allow installation warnings)
    * ternary formatting differs from Prettier, leading to a large diff
    https://github.com/biomejs/biome/issues/1661
    * import sorting differs from Prettier's
    `prettier-plugin-organize-imports`, making the diff even bigger
    * the deal breaker is a multi-second delay on saving large files (for us
    it's
    [Editor.ts](https://github.com/tldraw/tldraw/blob/main/packages/editor/src/lib/editor/Editor.ts))
    in VSCode when import sorting is enabled. There is a seemingly relevant
    Biome issue where I posted a small summary of our findings:
    https://github.com/biomejs/biome/issues/1569#issuecomment-1930411623
    
    Further actions:
    
    * reevaluate in a few months as Biome matures
    
    ### Change Type
    
    - [x] `internal` — Any other changes that don't affect the published
    package

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index ac125e04c..fc7d7013d 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -104,7 +104,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			? new Edge2d({
 					start: Vec.From(info.start.point),
 					end: Vec.From(info.end.point),
-			  })
+				})
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
 					radius: info.handleArc.radius,
@@ -112,7 +112,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,
 					largeArcFlag: info.bodyArc.largeArcFlag,
-			  })
+				})
 
 		let labelGeom
 		if (shape.props.text.trim()) {
@@ -583,8 +583,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.start.isExact
 									? ''
 									: shape.props.start.isPrecise
-									  ? 'url(#arrowhead-cross)'
-									  : 'url(#arrowhead-dot)'
+										? 'url(#arrowhead-cross)'
+										: 'url(#arrowhead-dot)'
 								: ''
 						}
 						markerEnd={
@@ -592,8 +592,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 								? shape.props.end.isExact
 									? ''
 									: shape.props.end.isPrecise
-									  ? 'url(#arrowhead-cross)'
-									  : 'url(#arrowhead-dot)'
+										? 'url(#arrowhead-cross)'
+										: 'url(#arrowhead-dot)'
 								: ''
 						}
 						opacity={0.16}

commit 056481899c191de41c69d778c1a6d20dd139839b
Author: alex <alex@dytry.ch>
Date:   Thu Feb 8 17:08:57 2024 +0000

    Remove Geometry2d.isSnappable (#2768)
    
    `Geometry2d.isSnappable` isn't used. There's some intended behaviour
    here around making it so you can't snap handles to text labels, but it's
    not actually working.
    
    This is a breaking change, but given this property doesn't do anything I
    don't think it's likely to be heavily depended upon
    
    ### Change Type
    - [x] `major` — Breaking change

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index fc7d7013d..713315610 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -130,7 +130,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return new Group2d({
 			children: [...(labelGeom ? [bodyGeom, labelGeom] : [bodyGeom]), ...debugGeom],
-			isSnappable: false,
 		})
 	}
 

commit 212eb88480bd66b5b2930768e1594f814b8da150
Author: Lu Wilson <l2wilson94@gmail.com>
Date:   Fri Feb 16 13:54:48 2024 +0000

    Add component for viewing an image of a snapshot  (#2804)
    
    This PR adds the `TldrawImage` component that displays a tldraw snapshot
    as an SVG image.
    
    ![2024-02-15 at 12 29 52 - Coral
    Cod](https://github.com/tldraw/tldraw/assets/15892272/14140e9e-7d6d-4dd3-88a3-86a6786325c5)
    
    ## Why
    
    We've seen requests for this kind of thing from users. eg: GitBook, and
    on discord:
    
    <img width="710" alt="image"
    src="https://github.com/tldraw/tldraw/assets/15892272/3d3a3e9d-66b9-42e7-81de-a70aa7165bdc">
    
    The component provides a way to do that.
    This PR also untangles various bits of editor state from image
    exporting, which makes it easier for library users to export images more
    agnostically. (ie: they can now export any shapes on any page in any
    theme. previously, they had to change the user's state to do that).
    
    ## What else
    
    - This PR also adds an **Image snapshot** example to demonstrate the new
    component.
    - We now pass an `isDarkMode` property to the `toSvg` method (inside the
    `ctx` argument). This means that `toSvg` doesn't have to rely on editor
    state anymore. I updated all our `toSvg` methods to use it.
    - See code comments for more info.
    
    ## Any issues?
    
    When you toggle to editing mode in the new example, text measurements
    are initially wrong (until you edit the size of a text shape). Click on
    the text shape to see how its indicator is wrong. Not sure why this is,
    or if it's even related. Does it ring a bell with anyone? If not, I'll
    take a closer look. (fixed, see comments --steve)
    
    ## Future work
    
    Now that we've untangled image exporting from editor state, we could
    expose some more helpful helpers for making this easier.
    
    Fixes tld-2122
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    [^1]: publishes a `patch` release, for devDependencies use `internal`
    [^2]: will not publish a new version
    
    ### Test Plan
    
    1. Open the **Image snapshot** example.
    2. Try editing the image, saving the image, and making sure the image
    updates.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Dev: Added the `TldrawImage` component.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 713315610..cce97a310 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -840,7 +840,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
-		const theme = getDefaultColorTheme({ isDarkMode: this.editor.user.getIsDarkMode() })
+		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
 		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
 
 		const color = theme[shape.props.color].solid

commit 4801b35768108b0569b054e762b5b12c9f488d83
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Mar 17 21:37:37 2024 +0000

    [tinyish] Simplify / skip some work in Shape (#3176)
    
    This PR is a minor cleanup of the Shape component.
    
    Here we:
    - use some dumb memoized info to avoid unnecessary style changes
    - move the dpr check up out of the shapes themselves, avoiding renders
    on instance state changes
    
    Culled shapes:
    - move the props setting on the culled shape component to a layout
    reactor
    - no longer set the height / width on the culled shape component
    - no longer update the culled shape component when the shape changes
    
    Random:
    - move the arrow shape defs to the arrow shape util (using that neat API
    we didn't used to have)
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Use shapes
    2. Use culled shapes
    
    ### Release Notes
    
    - SDK: minor improvements to the Shape component

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index cce97a310..8f63fcacf 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1014,7 +1014,17 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
-		return [getFillDefForCanvas()]
+		return [
+			getFillDefForCanvas(),
+			{
+				key: `arrow:dot`,
+				component: ArrowheadDotDef,
+			},
+			{
+				key: `arrow:cross`,
+				component: ArrowheadCrossDef,
+			},
+		]
 	}
 }
 
@@ -1082,3 +1092,20 @@ const shapeAtTranslationStart = new WeakMap<
 		>
 	}
 >()
+
+function ArrowheadDotDef() {
+	return (
+		<marker id="arrowhead-dot" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
+			<circle cx="3" cy="3" r="2" strokeDasharray="100%" />
+		</marker>
+	)
+}
+
+function ArrowheadCrossDef() {
+	return (
+		<marker id="arrowhead-cross" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
+			<line x1="1.5" y1="1.5" x2="4.5" y2="4.5" strokeDasharray="100%" />
+			<line x1="1.5" y1="4.5" x2="4.5" y2="1.5" strokeDasharray="100%" />
+		</marker>
+	)
+}

commit d7b80baa316237ee2ad982d4ae96df2ecc795065
Author: Dan Groshev <git@dgroshev.com>
Date:   Mon Mar 18 17:16:09 2024 +0000

    use native structuredClone on node, cloudflare workers, and in tests (#3166)
    
    Currently, we only use native `structuredClone` in the browser, falling
    back to `JSON.parse(JSON.stringify(...))` elsewhere, despite Node
    supporting `structuredClone` [since
    v17](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone)
    and Cloudflare Workers supporting it [since
    2022](https://blog.cloudflare.com/standards-compliant-workers-api/).
    This PR adjusts our shim to use the native `structuredClone` on all
    platforms, if available.
    
    Additionally, `jsdom` doesn't implement `structuredClone`, a bug [open
    since 2022](https://github.com/jsdom/jsdom/issues/3363). This PR patches
    `jsdom` environment in all packages/apps that use it for tests.
    
    Also includes a driveby removal of `deepCopy`, a function that is
    strictly inferior to `structuredClone`.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [x] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. A smoke test would be enough
    
    - [ ] Unit Tests
    - [x] End to end tests

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8f63fcacf..8b4acb359 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -27,11 +27,11 @@ import {
 	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
-	deepCopy,
 	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
 	mapObjectMapValues,
 	objectMapEntries,
+	structuredClone,
 	toDomPrecision,
 	useIsEditing,
 } from '@tldraw/editor'
@@ -194,7 +194,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// Start or end, pointing the arrow...
 
-		const next = deepCopy(shape) as TLArrowShape
+		const next = structuredClone(shape) as TLArrowShape
 
 		if (this.editor.inputs.ctrlKey) {
 			// todo: maybe double check that this isn't equal to the other handle too?
@@ -420,7 +420,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const terminals = getArrowTerminalsInArrowSpace(this.editor, shape)
 
-		const { start, end } = deepCopy<TLArrowShape['props']>(shape.props)
+		const { start, end } = structuredClone<TLArrowShape['props']>(shape.props)
 		let { bend } = shape.props
 
 		// Rescale start handle if it's not bound to a shape

commit 05f58f7c2a16ba3860471f8188beba930567c818
Author: alex <alex@dytry.ch>
Date:   Mon Mar 25 14:16:55 2024 +0000

    React-powered SVG exports (#3117)
    
    ## Migration path
    1. If any of your shapes implement `toSvg` for exports, you'll need to
    replace your implementation with a new version that returns JSX (it's a
    react component) instead of manually constructing SVG DOM nodes
    2. `editor.getSvg` is deprecated. It still works, but will be going away
    in a future release. If you still need SVGs as DOM elements rather than
    strings, use `new DOMParser().parseFromString(svgString,
    'image/svg+xml').firstElementChild`
    
    ## The change in detail
    At the moment, our SVG exports very carefully try to recreate the
    visuals of our shapes by manually constructing SVG DOM nodes. On its own
    this is really painful, but it also results in a lot of duplicated logic
    between the `component` and `getSvg` methods of shape utils.
    
    In #3020, we looked at using string concatenation & DOMParser to make
    this a bit less painful. This works, but requires specifying namespaces
    everywhere, is still pretty painful (no syntax highlighting or
    formatting), and still results in all that duplicated logic.
    
    I briefly experimented with creating my own version of the javascript
    language that let you embed XML like syntax directly. I was going to
    call it EXTREME JAVASCRIPT or XJS for short, but then I noticed that we
    already wrote the whole of tldraw in this thing called react and a (imo
    much worse named) version of the javascript xml thing already existed.
    
    Given the entire library already depends on react, what would it look
    like if we just used react directly for these exports? Turns out things
    get a lot simpler! Take a look at lmk what you think
    
    This diff was intended as a proof of concept, but is actually pretty
    close to being landable. The main thing is that here, I've deliberately
    leant into this being a big breaking change to see just how much code we
    could delete (turns out: lots). We could if we wanted to make this
    without making it a breaking change at all, but it would add back a lot
    of complexity on our side and run a fair bit slower
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8b4acb359..cbe043bad 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1,8 +1,8 @@
 import {
 	Arc2d,
 	Box,
-	DefaultFontFamilies,
 	Edge2d,
+	Editor,
 	Geometry2d,
 	Group2d,
 	Rectangle2d,
@@ -10,11 +10,7 @@ import {
 	ShapeUtil,
 	SvgExportContext,
 	TLArrowShape,
-	TLArrowShapeArrowheadStyle,
 	TLArrowShapeProps,
-	TLDefaultColorStyle,
-	TLDefaultColorTheme,
-	TLDefaultFillStyle,
 	TLHandle,
 	TLOnEditEndHandler,
 	TLOnHandleDragHandler,
@@ -28,17 +24,18 @@ import {
 	arrowShapeMigrations,
 	arrowShapeProps,
 	getArrowTerminalsInArrowSpace,
-	getDefaultColorTheme,
 	mapObjectMapValues,
 	objectMapEntries,
 	structuredClone,
 	toDomPrecision,
+	track,
+	useEditor,
 	useIsEditing,
 } from '@tldraw/editor'
 import React from 'react'
-import { ShapeFill, getShapeFillSvg, useDefaultColorTheme } from '../shared/ShapeFill'
-import { createTextSvgElementFromSpans } from '../shared/createTextSvgElementFromSpans'
-import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
+import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
+import { SvgTextLabel } from '../shared/SvgTextLabel'
+import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES } from '../shared/default-shape-constants'
 import {
 	getFillDefForCanvas,
 	getFillDefForExport,
@@ -133,14 +130,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		})
 	}
 
-	private getLength(shape: TLArrowShape): number {
-		const info = this.editor.getArrowInfo(shape)!
-
-		return info.isStraight
-			? Vec.Dist(info.start.handle, info.end.handle)
-			: Math.abs(info.handleArc.length)
-	}
-
 	override getHandles(shape: TLArrowShape): TLHandle[] {
 		const info = this.editor.getArrowInfo(shape)!
 
@@ -531,7 +520,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
-
 		const shouldDisplayHandles =
 			this.editor.isInAny(
 				'select.idle',
@@ -542,156 +530,17 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			) && !this.editor.getInstanceState().isReadonly
 
 		const info = this.editor.getArrowInfo(shape)
-		const bounds = Box.ZeroFix(this.editor.getShapeGeometry(shape).bounds)
-
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const changeIndex = React.useMemo<number>(() => {
-			return this.editor.environment.isSafari ? (globalRenderIndex += 1) : 0
-			// eslint-disable-next-line react-hooks/exhaustive-deps
-		}, [shape])
-
 		if (!info?.isValid) return null
 
-		const strokeWidth = STROKE_SIZES[shape.props.size]
-
-		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
-		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
-
-		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
-
-		let handlePath: null | React.JSX.Element = null
-
-		if (onlySelectedShape === shape && shouldDisplayHandles) {
-			const sw = 2
-			const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(this.getLength(shape), sw, {
-				end: 'skip',
-				start: 'skip',
-				lengthRatio: 2.5,
-			})
-
-			handlePath =
-				shape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (
-					<path
-						className="tl-arrow-hint"
-						d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
-						strokeDasharray={strokeDasharray}
-						strokeDashoffset={strokeDashoffset}
-						strokeWidth={sw}
-						markerStart={
-							shape.props.start.type === 'binding'
-								? shape.props.start.isExact
-									? ''
-									: shape.props.start.isPrecise
-										? 'url(#arrowhead-cross)'
-										: 'url(#arrowhead-dot)'
-								: ''
-						}
-						markerEnd={
-							shape.props.end.type === 'binding'
-								? shape.props.end.isExact
-									? ''
-									: shape.props.end.isPrecise
-										? 'url(#arrowhead-cross)'
-										: 'url(#arrowhead-dot)'
-								: ''
-						}
-						opacity={0.16}
-					/>
-				) : null
-		}
-
-		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
-			strokeWidth,
-			{
-				style: shape.props.dash,
-			}
-		)
-
 		const labelPosition = getArrowLabelPosition(this.editor, shape)
 
-		const maskStartArrowhead = !(
-			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
-		)
-		const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
-
-		// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
-		// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
-		const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
-
 		return (
 			<>
 				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
-					{/* Yep */}
-					<defs>
-						<mask id={maskId}>
-							<rect
-								x={toDomPrecision(-100 + bounds.minX)}
-								y={toDomPrecision(-100 + bounds.minY)}
-								width={toDomPrecision(bounds.width + 200)}
-								height={toDomPrecision(bounds.height + 200)}
-								fill="white"
-							/>
-							{shape.props.text.trim() && (
-								<rect
-									x={labelPosition.box.x}
-									y={labelPosition.box.y}
-									width={labelPosition.box.w}
-									height={labelPosition.box.h}
-									fill="black"
-									rx={4}
-									ry={4}
-								/>
-							)}
-							{as && maskStartArrowhead && (
-								<path
-									d={as}
-									fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
-									stroke="none"
-								/>
-							)}
-							{ae && maskEndArrowhead && (
-								<path
-									d={ae}
-									fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
-									stroke="none"
-								/>
-							)}
-						</mask>
-					</defs>
-					<g
-						fill="none"
-						stroke={theme[shape.props.color].solid}
-						strokeWidth={strokeWidth}
-						strokeLinejoin="round"
-						strokeLinecap="round"
-						pointerEvents="none"
-					>
-						{handlePath}
-						{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
-						<g mask={`url(#${maskId})`}>
-							<rect
-								x={toDomPrecision(bounds.minX - 100)}
-								y={toDomPrecision(bounds.minY - 100)}
-								width={toDomPrecision(bounds.width + 200)}
-								height={toDomPrecision(bounds.height + 200)}
-								opacity={0}
-							/>
-							<path
-								d={path}
-								strokeDasharray={strokeDasharray}
-								strokeDashoffset={strokeDashoffset}
-							/>
-						</g>
-						{as && maskStartArrowhead && shape.props.fill !== 'none' && (
-							<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} />
-						)}
-						{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
-							<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} />
-						)}
-						{as && <path d={as} />}
-						{ae && <path d={ae} />}
-					</g>
+					<ArrowSvg
+						shape={shape}
+						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape === shape}
+					/>
 				</SVGContainer>
 				<ArrowTextLabel
 					id={shape.id}
@@ -840,177 +689,24 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
-		const theme = getDefaultColorTheme({ isDarkMode: ctx.isDarkMode })
-		ctx.addExportDef(getFillDefForExport(shape.props.fill, theme))
-
-		const color = theme[shape.props.color].solid
-
-		const info = this.editor.getArrowInfo(shape)
-
-		const strokeWidth = STROKE_SIZES[shape.props.size]
-
-		// Group for arrow
-		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		if (!info) return g
-
-		// Arrowhead start path
-		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
-		// Arrowhead end path
-		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
-
-		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
-		const bounds = geometry.bounds
-
-		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
-
-		const maskId = (shape.id + '_clip').replace(':', '_')
+		ctx.addExportDef(getFillDefForExport(shape.props.fill))
+		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
 
-		// If we have any arrowheads, then mask the arrowheads
-		if (as || ae || !!labelGeometry) {
-			// Create mask for arrowheads
-
-			// Create defs
-			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs')
-
-			// Create mask
-			const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask')
-			mask.id = maskId
-
-			// Create large white shape for mask
-			const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
-			rect.setAttribute('x', bounds.minX - 100 + '')
-			rect.setAttribute('y', bounds.minY - 100 + '')
-			rect.setAttribute('width', bounds.width + 200 + '')
-			rect.setAttribute('height', bounds.height + 200 + '')
-			rect.setAttribute('fill', 'white')
-			mask.appendChild(rect)
-
-			// add arrowhead start mask
-			if (as) mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead))
-
-			// add arrowhead end mask
-			if (ae) mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead))
-
-			// Mask out text label if text is present
-			if (labelGeometry) {
-				const labelMask = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
-				labelMask.setAttribute('x', labelGeometry.x + '')
-				labelMask.setAttribute('y', labelGeometry.y + '')
-				labelMask.setAttribute('width', labelGeometry.w + '')
-				labelMask.setAttribute('height', labelGeometry.h + '')
-				labelMask.setAttribute('fill', 'black')
-
-				mask.appendChild(labelMask)
-			}
-
-			defs.appendChild(mask)
-			g.appendChild(defs)
-		}
-
-		const g2 = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		g2.setAttribute('mask', `url(#${maskId})`)
-		g.appendChild(g2)
-
-		// Dumb mask fix thing
-		const rect2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
-		rect2.setAttribute('x', '-100')
-		rect2.setAttribute('y', '-100')
-		rect2.setAttribute('width', bounds.width + 200 + '')
-		rect2.setAttribute('height', bounds.height + 200 + '')
-		rect2.setAttribute('fill', 'transparent')
-		rect2.setAttribute('stroke', 'none')
-		g2.appendChild(rect2)
-
-		// Arrowhead body path
-		const path = getArrowSvgPath(
-			info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),
-			color,
-			strokeWidth
-		)
-
-		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-			info.isStraight ? info.length : Math.abs(info.bodyArc.length),
-			strokeWidth,
-			{
-				style: shape.props.dash,
-			}
+		return (
+			<>
+				<ArrowSvg shape={shape} shouldDisplayHandles={false} />
+				<SvgTextLabel
+					fontSize={ARROW_LABEL_FONT_SIZES[shape.props.size]}
+					font={shape.props.font}
+					align="middle"
+					verticalAlign="middle"
+					text={shape.props.text}
+					labelColor={shape.props.labelColor}
+					bounds={getArrowLabelPosition(this.editor, shape).box}
+					padding={4}
+				/>
+			</>
 		)
-
-		path.setAttribute('stroke-dasharray', strokeDasharray)
-		path.setAttribute('stroke-dashoffset', strokeDashoffset)
-
-		g2.appendChild(path)
-
-		// Arrowhead start path
-		if (as) {
-			g.appendChild(
-				getArrowheadSvgPath(
-					as,
-					shape.props.color,
-					strokeWidth,
-					shape.props.arrowheadStart === 'arrow' ? 'none' : shape.props.fill,
-					theme
-				)
-			)
-		}
-		// Arrowhead end path
-		if (ae) {
-			g.appendChild(
-				getArrowheadSvgPath(
-					ae,
-					shape.props.color,
-					strokeWidth,
-					shape.props.arrowheadEnd === 'arrow' ? 'none' : shape.props.fill,
-					theme
-				)
-			)
-		}
-
-		// Text Label
-		if (labelGeometry) {
-			ctx.addExportDef(getFontDefForExport(shape.props.font))
-
-			const opts = {
-				fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
-				lineHeight: TEXT_PROPS.lineHeight,
-				fontFamily: DefaultFontFamilies[shape.props.font],
-				padding: 0,
-				textAlign: 'middle' as const,
-				width: labelGeometry.w - 8,
-				verticalTextAlign: 'middle' as const,
-				height: labelGeometry.h,
-				fontStyle: 'normal',
-				fontWeight: 'normal',
-				overflow: 'wrap' as const,
-			}
-
-			const textElm = createTextSvgElementFromSpans(
-				this.editor,
-				this.editor.textMeasure.measureTextSpans(shape.props.text, opts),
-				opts
-			)
-			textElm.setAttribute('fill', theme[shape.props.labelColor].solid)
-
-			const children = Array.from(textElm.children) as unknown as SVGTSpanElement[]
-
-			children.forEach((child) => {
-				const x = parseFloat(child.getAttribute('x') || '0')
-				const y = parseFloat(child.getAttribute('y') || '0')
-
-				child.setAttribute('x', x + 4 + labelGeometry.x + 'px')
-				child.setAttribute('y', y + labelGeometry.y + 'px')
-			})
-
-			const textBgEl = textElm.cloneNode(true) as SVGTextElement
-			textBgEl.setAttribute('stroke-width', '2')
-			textBgEl.setAttribute('fill', theme.background)
-			textBgEl.setAttribute('stroke', theme.background)
-
-			g.appendChild(textBgEl)
-			g.appendChild(textElm)
-		}
-
-		return g
 	}
 
 	override getCanvasSvgDefs(): TLShapeUtilCanvasSvgDef[] {
@@ -1028,55 +724,165 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 }
 
-function getArrowheadSvgMask(d: string, arrowhead: TLArrowShapeArrowheadStyle) {
-	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-	path.setAttribute('d', d)
-	path.setAttribute('fill', arrowhead === 'arrow' ? 'none' : 'black')
-	path.setAttribute('stroke', 'none')
-	return path
-}
+function getLength(editor: Editor, shape: TLArrowShape): number {
+	const info = editor.getArrowInfo(shape)!
 
-function getArrowSvgPath(d: string, color: string, strokeWidth: number) {
-	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-	path.setAttribute('d', d)
-	path.setAttribute('fill', 'none')
-	path.setAttribute('stroke', color)
-	path.setAttribute('stroke-width', strokeWidth + '')
-	return path
+	return info.isStraight
+		? Vec.Dist(info.start.handle, info.end.handle)
+		: Math.abs(info.handleArc.length)
 }
 
-function getArrowheadSvgPath(
-	d: string,
-	color: TLDefaultColorStyle,
-	strokeWidth: number,
-	fill: TLDefaultFillStyle,
-	theme: TLDefaultColorTheme
-) {
-	const path = document.createElementNS('http://www.w3.org/2000/svg', 'path')
-	path.setAttribute('d', d)
-	path.setAttribute('fill', 'none')
-	path.setAttribute('stroke', theme[color].solid)
-	path.setAttribute('stroke-width', strokeWidth + '')
-
-	// Get the fill element, if any
-	const shapeFill = getShapeFillSvg({
-		d,
-		fill,
-		color,
-		theme,
-	})
-
-	if (shapeFill) {
-		// If there is a fill element, return a group containing the fill and the path
-		const g = document.createElementNS('http://www.w3.org/2000/svg', 'g')
-		g.appendChild(shapeFill)
-		g.appendChild(path)
-		return g
-	} else {
-		// Otherwise, just return the path
-		return path
+const ArrowSvg = track(function ArrowSvg({
+	shape,
+	shouldDisplayHandles,
+}: {
+	shape: TLArrowShape
+	shouldDisplayHandles: boolean
+}) {
+	const editor = useEditor()
+	const theme = useDefaultColorTheme()
+	const info = editor.getArrowInfo(shape)
+	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
+
+	const changeIndex = React.useMemo<number>(() => {
+		return editor.environment.isSafari ? (globalRenderIndex += 1) : 0
+		// eslint-disable-next-line react-hooks/exhaustive-deps
+	}, [shape])
+
+	if (!info?.isValid) return null
+
+	const strokeWidth = STROKE_SIZES[shape.props.size]
+
+	const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
+	const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
+
+	const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
+
+	let handlePath: null | React.JSX.Element = null
+
+	if (shouldDisplayHandles) {
+		const sw = 2
+		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+			getLength(editor, shape),
+			sw,
+			{
+				end: 'skip',
+				start: 'skip',
+				lengthRatio: 2.5,
+			}
+		)
+
+		handlePath =
+			shape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (
+				<path
+					className="tl-arrow-hint"
+					d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
+					strokeDasharray={strokeDasharray}
+					strokeDashoffset={strokeDashoffset}
+					strokeWidth={sw}
+					markerStart={
+						shape.props.start.type === 'binding'
+							? shape.props.start.isExact
+								? ''
+								: shape.props.start.isPrecise
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
+							: ''
+					}
+					markerEnd={
+						shape.props.end.type === 'binding'
+							? shape.props.end.isExact
+								? ''
+								: shape.props.end.isPrecise
+									? 'url(#arrowhead-cross)'
+									: 'url(#arrowhead-dot)'
+							: ''
+					}
+					opacity={0.16}
+				/>
+			) : null
 	}
-}
+
+	const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
+		info.isStraight ? info.length : Math.abs(info.bodyArc.length),
+		strokeWidth,
+		{
+			style: shape.props.dash,
+		}
+	)
+
+	const labelPosition = getArrowLabelPosition(editor, shape)
+
+	const maskStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
+	const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+
+	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
+	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
+	const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
+
+	return (
+		<>
+			{/* Yep */}
+			<defs>
+				<mask id={maskId}>
+					<rect
+						x={toDomPrecision(-100 + bounds.minX)}
+						y={toDomPrecision(-100 + bounds.minY)}
+						width={toDomPrecision(bounds.width + 200)}
+						height={toDomPrecision(bounds.height + 200)}
+						fill="white"
+					/>
+					{shape.props.text.trim() && (
+						<rect
+							x={labelPosition.box.x}
+							y={labelPosition.box.y}
+							width={labelPosition.box.w}
+							height={labelPosition.box.h}
+							fill="black"
+							rx={4}
+							ry={4}
+						/>
+					)}
+					{as && maskStartArrowhead && (
+						<path d={as} fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
+					)}
+					{ae && maskEndArrowhead && (
+						<path d={ae} fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
+					)}
+				</mask>
+			</defs>
+			<g
+				fill="none"
+				stroke={theme[shape.props.color].solid}
+				strokeWidth={strokeWidth}
+				strokeLinejoin="round"
+				strokeLinecap="round"
+				pointerEvents="none"
+			>
+				{handlePath}
+				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
+				<g mask={`url(#${maskId})`}>
+					<rect
+						x={toDomPrecision(bounds.minX - 100)}
+						y={toDomPrecision(bounds.minY - 100)}
+						width={toDomPrecision(bounds.width + 200)}
+						height={toDomPrecision(bounds.height + 200)}
+						opacity={0}
+					/>
+					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
+				</g>
+				{as && maskStartArrowhead && shape.props.fill !== 'none' && (
+					<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} />
+				)}
+				{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
+					<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} />
+				)}
+				{as && <path d={as} />}
+				{ae && <path d={ae} />}
+			</g>
+		</>
+	)
+})
 
 const shapeAtTranslationStart = new WeakMap<
 	TLArrowShape,

commit d76d53db95146c24d35caeca41c2f6d348dbcc06
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Wed Mar 27 09:33:48 2024 +0000

    textfields [1 of 3]: add text into speech bubble; also add rich text example (#3050)
    
    This is the first of three textfield changes. This starts with making
    the speech bubble actually have text. Also, it creates a TipTap example
    and how that would be wired up.
    
    🎵 this is dangerous, I walk through textfields so watch your head rock 🎵
    
    ### Change Type
    
    - [x] `minor` — New feature
    
    ### Release Notes
    
    - Refactor textfields be composable/swappable.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index cbe043bad..09a616bfc 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -516,9 +516,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	component(shape: TLArrowShape) {
-		// Not a class component, but eslint can't tell that :(
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
@@ -549,7 +546,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					size={shape.props.size}
 					position={labelPosition.box.center}
 					width={labelPosition.box.w}
-					labelColor={theme[shape.props.labelColor].solid}
+					labelColor={shape.props.labelColor}
 				/>
 			</>
 		)

commit 41b5fffa2ef17ff852c1efc227a5ad5c37dc5c7a
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Mar 28 10:49:29 2024 +0100

    Decrease the number of elements by 3. (#3283)
    
    When geo shape has no url or text we don't show the html container
    containing the label and link. This results in 3 fewer dom nodes per
    empty geo shape (going from 7 to 4). Similarly for an arrow without the
    text label we go from 13 to 10.
    
    First paint experience with 2000 empty rectangle shapes
    Before: 1.5-1.6s
    After: 1.2-1.3s
    
    2000 rectangles shapes with text is similar between the two, around
    3.6s.
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [ ] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    ### Release Notes
    
    - Reduce the number of rendered dom nodes for geo shapes and arrows
    without text.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 09a616bfc..2895c5337 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -530,6 +530,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		if (!info?.isValid) return null
 
 		const labelPosition = getArrowLabelPosition(this.editor, shape)
+		const isEditing = this.editor.getEditingShapeId() === shape.id
+		const showArrowLabel = isEditing || shape.props.text
 
 		return (
 			<>
@@ -539,15 +541,17 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape === shape}
 					/>
 				</SVGContainer>
-				<ArrowTextLabel
-					id={shape.id}
-					text={shape.props.text}
-					font={shape.props.font}
-					size={shape.props.size}
-					position={labelPosition.box.center}
-					width={labelPosition.box.w}
-					labelColor={shape.props.labelColor}
-				/>
+				{showArrowLabel && (
+					<ArrowTextLabel
+						id={shape.id}
+						text={shape.props.text}
+						font={shape.props.font}
+						size={shape.props.size}
+						position={labelPosition.box.center}
+						width={labelPosition.box.w}
+						labelColor={shape.props.labelColor}
+					/>
+				)}
 			</>
 		)
 	}

commit 41601ac61ec7d4fad715bd67a9df077ee1576a7b
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Apr 14 19:40:02 2024 +0100

    Stickies: release candidate (#3249)
    
    This PR is the target for the stickies PRs that are moving forward. It
    should collect changes.
    
    - [x] New icon
    - [x] Improved shadows
    - [x] Shadow LOD
    - [x] New colors / theme options
    - [x] Shrink text size to avoid word breaks on the x axis
    - [x] Hide indicator whilst typing (reverted)
    - [x] Adjacent note positions
      - [x] buttons / clone handles
      - [x] position helpers for creating / translating (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
      - [x] multiple shape translating
    - [x] Text editing
      - [x] Edit on type (feature flagged)
      - [x] click goes in correct place
    - [x] Notes as parents (reverted)
    - [x] Update colors
    - [x] Update SVG appearance
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    Todo: fold in test plans for child PRs
    
    ### Unit tests:
    
    - [ ] Shrink text size to avoid word breaks on the x axis
    - [x] Adjacent notes
      - [x] buttons (clone handles)
      - [x] position helpers (pits)
    - [x] keyboard shortcuts: (Tab, Shift+tab (RTL aware), Cmd-Enter,
    Shift+Cmd+enter)
    - [ ] Text editing
      - [ ] Edit on type
      - [ ] click goes in correct place
    
    ### Release Notes
    
    - Improves sticky notes (see list)
    
    ---------
    
    Signed-off-by: dependabot[bot] <support@github.com>
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>
    Co-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>
    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>
    Co-authored-by: Lu[ke] Wilson <l2wilson94@gmail.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 2895c5337..7036ee1b6 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -24,6 +24,7 @@ import {
 	arrowShapeMigrations,
 	arrowShapeProps,
 	getArrowTerminalsInArrowSpace,
+	getDefaultColorTheme,
 	mapObjectMapValues,
 	objectMapEntries,
 	structuredClone,
@@ -306,15 +307,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// If no bound shapes are in the selection, unbind any bound shapes
 
 		const selectedShapeIds = this.editor.getSelectedShapeIds()
-
-		if (
-			(startBindingId &&
-				(selectedShapeIds.includes(startBindingId) ||
-					this.editor.isAncestorSelected(startBindingId))) ||
-			(endBindingId &&
-				(selectedShapeIds.includes(endBindingId) || this.editor.isAncestorSelected(endBindingId)))
-		) {
-			return
+		const shapesToCheck = new Set<string>()
+		if (startBindingId) {
+			// Add shape and all ancestors to set
+			shapesToCheck.add(startBindingId)
+			this.editor.getShapeAncestors(startBindingId).forEach((a) => shapesToCheck.add(a.id))
+		}
+		if (endBindingId) {
+			// Add shape and all ancestors to set
+			shapesToCheck.add(endBindingId)
+			this.editor.getShapeAncestors(endBindingId).forEach((a) => shapesToCheck.add(a.id))
+		}
+		// If any of the shapes are selected, return
+		for (const id of selectedShapeIds) {
+			if (shapesToCheck.has(id)) return
 		}
 
 		let result = shape
@@ -530,6 +536,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		if (!info?.isValid) return null
 
 		const labelPosition = getArrowLabelPosition(this.editor, shape)
+		const isSelected = shape.id === this.editor.getOnlySelectedShapeId()
 		const isEditing = this.editor.getEditingShapeId() === shape.id
 		const showArrowLabel = isEditing || shape.props.text
 
@@ -549,6 +556,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						size={shape.props.size}
 						position={labelPosition.box.center}
 						width={labelPosition.box.w}
+						isSelected={isSelected}
 						labelColor={shape.props.labelColor}
 					/>
 				)}
@@ -692,6 +700,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
 		ctx.addExportDef(getFillDefForExport(shape.props.fill))
 		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
+		const theme = getDefaultColorTheme(ctx)
 
 		return (
 			<>
@@ -702,7 +711,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					align="middle"
 					verticalAlign="middle"
 					text={shape.props.text}
-					labelColor={shape.props.labelColor}
+					labelColor={theme[shape.props.labelColor].solid}
 					bounds={getArrowLabelPosition(this.editor, shape).box}
 					padding={4}
 				/>

commit da35f2bd75e43fd48d11a9a74f60ee01c84a41d1
Author: alex <alex@dytry.ch>
Date:   Wed May 8 13:37:31 2024 +0100

    Bindings (#3326)
    
    First draft of the new bindings API. We'll follow this up with some API
    refinements, tests, documentation, and examples.
    
    Bindings are a new record type for establishing relationships between
    two shapes so they can update at the same time.
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Release Notes
    
    #### Breaking changes
    - The `start` and `end` properties on `TLArrowShape` no longer have
    `type: point | binding`. Instead, they're always a point, which may be
    out of date if a binding exists. To check for & retrieve arrow bindings,
    use `getArrowBindings(editor, shape)` instead.
    - `getArrowTerminalsInArrowSpace` must be passed a `TLArrowBindings` as
    a third argument: `getArrowTerminalsInArrowSpace(editor, shape,
    getArrowBindings(editor, shape))`
    - The following types have been renamed:
        - `ShapeProps` -> `RecordProps`
        - `ShapePropsType` -> `RecordPropsType`
        - `TLShapePropsMigrations` -> `TLPropsMigrations`
        - `SchemaShapeInfo` -> `SchemaPropsInfo`
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 7036ee1b6..a5378b47b 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -9,12 +9,14 @@ import {
 	SVGContainer,
 	ShapeUtil,
 	SvgExportContext,
+	TLArrowBinding,
+	TLArrowBindings,
 	TLArrowShape,
-	TLArrowShapeProps,
 	TLHandle,
 	TLOnEditEndHandler,
 	TLOnHandleDragHandler,
 	TLOnResizeHandler,
+	TLOnResizeStartHandler,
 	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
 	TLShapePartial,
@@ -23,10 +25,12 @@ import {
 	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
+	createOrUpdateArrowBinding,
+	getArrowBindings,
 	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
 	mapObjectMapValues,
-	objectMapEntries,
+	removeArrowBinding,
 	structuredClone,
 	toDomPrecision,
 	track,
@@ -75,6 +79,11 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
 
+	override canBeLaidOut: TLShapeUtilFlag<TLArrowShape> = (shape) => {
+		const bindings = getArrowBindings(this.editor, shape)
+		return !bindings.start && !bindings.end
+	}
+
 	override getDefaultProps(): TLArrowShape['props'] {
 		return {
 			dash: 'draw',
@@ -83,8 +92,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			color: 'black',
 			labelColor: 'black',
 			bend: 0,
-			start: { type: 'point', x: 0, y: 0 },
-			end: { type: 'point', x: 2, y: 0 },
+			start: { x: 0, y: 0 },
+			end: { x: 2, y: 0 },
 			arrowheadStart: 'none',
 			arrowheadEnd: 'arrow',
 			text: '',
@@ -164,10 +173,11 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	override onHandleDrag: TLOnHandleDragHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {
 		const handleId = handle.id as ARROW_HANDLES
+		const bindings = getArrowBindings(this.editor, shape)
 
 		if (handleId === ARROW_HANDLES.MIDDLE) {
 			// Bending the arrow...
-			const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
+			const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
 
 			const delta = Vec.Sub(end, start)
 			const v = Vec.Per(delta)
@@ -184,17 +194,23 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		// Start or end, pointing the arrow...
 
-		const next = structuredClone(shape) as TLArrowShape
+		const update: TLShapePartial<TLArrowShape> = { id: shape.id, type: 'arrow', props: {} }
+
+		const currentBinding = bindings[handleId]
+
+		const otherHandleId = handleId === ARROW_HANDLES.START ? ARROW_HANDLES.END : ARROW_HANDLES.START
+		const otherBinding = bindings[otherHandleId]
 
 		if (this.editor.inputs.ctrlKey) {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			// Skip binding
-			next.props[handleId] = {
-				type: 'point',
+			removeArrowBinding(this.editor, shape, handleId)
+
+			update.props![handleId] = {
 				x: handle.x,
 				y: handle.y,
 			}
-			return next
+			return update
 		}
 
 		const point = this.editor.getShapePageTransform(shape.id)!.applyToPoint(handle)
@@ -210,19 +226,20 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (!target) {
 			// todo: maybe double check that this isn't equal to the other handle too?
-			next.props[handleId] = {
-				type: 'point',
+			removeArrowBinding(this.editor, shape, handleId)
+
+			update.props![handleId] = {
 				x: handle.x,
 				y: handle.y,
 			}
-			return next
+			return update
 		}
 
 		// we've got a target! the handle is being dragged over a shape, bind to it
 
 		const targetGeometry = this.editor.getShapeGeometry(target)
 		const targetBounds = Box.ZeroFix(targetGeometry.bounds)
-		const pageTransform = this.editor.getShapePageTransform(next.id)!
+		const pageTransform = this.editor.getShapePageTransform(update.id)!
 		const pointInPageSpace = pageTransform.applyToPoint(handle)
 		const pointInTargetSpace = this.editor.getPointInShapeSpace(target, pointInPageSpace)
 
@@ -230,11 +247,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (!precise) {
 			// If we're switching to a new bound shape, then precise only if moving slowly
-			const prevHandle = next.props[handleId]
-			if (
-				prevHandle.type === 'point' ||
-				(prevHandle.type === 'binding' && target.id !== prevHandle.boundShapeId)
-			) {
+			if (!currentBinding || (currentBinding && target.id !== currentBinding.toId)) {
 				precise = this.editor.inputs.pointerVelocity.len() < 0.5
 			}
 		}
@@ -246,13 +259,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 			// Double check that we're not going to be doing an imprecise snap on
 			// the same shape twice, as this would result in a zero length line
-			const otherHandle =
-				next.props[handleId === ARROW_HANDLES.START ? ARROW_HANDLES.END : ARROW_HANDLES.START]
-			if (
-				otherHandle.type === 'binding' &&
-				target.id === otherHandle.boundShapeId &&
-				otherHandle.isPrecise
-			) {
+			if (otherBinding && target.id === otherBinding.toId && otherBinding.props.isPrecise) {
 				precise = true
 			}
 		}
@@ -276,64 +283,66 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}
 		}
 
-		next.props[handleId] = {
-			type: 'binding',
-			boundShapeId: target.id,
-			normalizedAnchor: normalizedAnchor,
+		const b = {
+			terminal: handleId,
+			normalizedAnchor,
 			isPrecise: precise,
 			isExact: this.editor.inputs.altKey,
 		}
 
-		if (next.props.start.type === 'binding' && next.props.end.type === 'binding') {
-			if (next.props.start.boundShapeId === next.props.end.boundShapeId) {
-				if (Vec.Equals(next.props.start.normalizedAnchor, next.props.end.normalizedAnchor)) {
-					next.props.end.normalizedAnchor.x += 0.05
-				}
+		createOrUpdateArrowBinding(this.editor, shape, target.id, b)
+
+		this.editor.setHintingShapes([target.id])
+
+		const newBindings = getArrowBindings(this.editor, shape)
+		if (newBindings.start && newBindings.end && newBindings.start.toId === newBindings.end.toId) {
+			if (
+				Vec.Equals(newBindings.start.props.normalizedAnchor, newBindings.end.props.normalizedAnchor)
+			) {
+				createOrUpdateArrowBinding(this.editor, shape, newBindings.end.toId, {
+					...newBindings.end.props,
+					normalizedAnchor: {
+						x: newBindings.end.props.normalizedAnchor.x + 0.05,
+						y: newBindings.end.props.normalizedAnchor.y,
+					},
+				})
 			}
 		}
 
-		return next
+		return update
 	}
 
 	override onTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {
-		const startBindingId =
-			shape.props.start.type === 'binding' ? shape.props.start.boundShapeId : null
-		const endBindingId = shape.props.end.type === 'binding' ? shape.props.end.boundShapeId : null
+		const bindings = getArrowBindings(this.editor, shape)
 
-		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape)
+		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
 		const shapePageTransform = this.editor.getShapePageTransform(shape.id)!
 
 		// If at least one bound shape is in the selection, do nothing;
 		// If no bound shapes are in the selection, unbind any bound shapes
 
 		const selectedShapeIds = this.editor.getSelectedShapeIds()
-		const shapesToCheck = new Set<string>()
-		if (startBindingId) {
-			// Add shape and all ancestors to set
-			shapesToCheck.add(startBindingId)
-			this.editor.getShapeAncestors(startBindingId).forEach((a) => shapesToCheck.add(a.id))
-		}
-		if (endBindingId) {
-			// Add shape and all ancestors to set
-			shapesToCheck.add(endBindingId)
-			this.editor.getShapeAncestors(endBindingId).forEach((a) => shapesToCheck.add(a.id))
-		}
-		// If any of the shapes are selected, return
-		for (const id of selectedShapeIds) {
-			if (shapesToCheck.has(id)) return
-		}
 
-		let result = shape
+		if (
+			(bindings.start &&
+				(selectedShapeIds.includes(bindings.start.toId) ||
+					this.editor.isAncestorSelected(bindings.start.toId))) ||
+			(bindings.end &&
+				(selectedShapeIds.includes(bindings.end.toId) ||
+					this.editor.isAncestorSelected(bindings.end.toId)))
+		) {
+			return
+		}
 
 		// When we start translating shapes, record where their bindings were in page space so we
 		// can maintain them as we translate the arrow
 		shapeAtTranslationStart.set(shape, {
 			pagePosition: shapePageTransform.applyToPoint(shape),
 			terminalBindings: mapObjectMapValues(terminalsInArrowSpace, (terminalName, point) => {
-				const terminal = shape.props[terminalName]
-				if (terminal.type !== 'binding') return null
+				const binding = bindings[terminalName]
+				if (!binding) return null
 				return {
-					binding: terminal,
+					binding,
 					shapePosition: point,
 					pagePosition: shapePageTransform.applyToPoint(point),
 				}
@@ -341,15 +350,16 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		})
 
 		for (const handleName of [ARROW_HANDLES.START, ARROW_HANDLES.END] as const) {
-			const terminal = shape.props[handleName]
-			if (terminal.type !== 'binding') continue
-			result = {
-				...shape,
-				props: { ...shape.props, [handleName]: { ...terminal, isPrecise: true } },
-			}
+			const binding = bindings[handleName]
+			if (!binding) continue
+
+			this.editor.updateBinding({
+				...binding,
+				props: { ...binding.props, isPrecise: true },
+			})
 		}
 
-		return result
+		return
 	}
 
 	override onTranslate?: TLOnTranslateHandler<TLArrowShape> = (initialShape, shape) => {
@@ -362,10 +372,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			atTranslationStart.pagePosition
 		)
 
-		let result = shape
-		for (const [terminalName, terminalBinding] of objectMapEntries(
-			atTranslationStart.terminalBindings
-		)) {
+		for (const terminalBinding of Object.values(atTranslationStart.terminalBindings)) {
 			if (!terminalBinding) continue
 
 			const newPagePoint = Vec.Add(terminalBinding.pagePosition, Vec.Mul(pageDelta, 0.5))
@@ -378,54 +385,46 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				},
 			})
 
-			if (newTarget?.id === terminalBinding.binding.boundShapeId) {
+			if (newTarget?.id === terminalBinding.binding.toId) {
 				const targetBounds = Box.ZeroFix(this.editor.getShapeGeometry(newTarget).bounds)
 				const pointInTargetSpace = this.editor.getPointInShapeSpace(newTarget, newPagePoint)
 				const normalizedAnchor = {
 					x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
 					y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height,
 				}
-				result = {
-					...result,
-					props: {
-						...result.props,
-						[terminalName]: { ...terminalBinding.binding, isPrecise: true, normalizedAnchor },
-					},
-				}
+				createOrUpdateArrowBinding(this.editor, shape, newTarget.id, {
+					...terminalBinding.binding.props,
+					normalizedAnchor,
+					isPrecise: true,
+				})
 			} else {
-				result = {
-					...result,
-					props: {
-						...result.props,
-						[terminalName]: {
-							type: 'point',
-							x: terminalBinding.shapePosition.x,
-							y: terminalBinding.shapePosition.y,
-						},
-					},
-				}
+				removeArrowBinding(this.editor, shape, terminalBinding.binding.props.terminal)
 			}
 		}
-
-		return result
 	}
 
+	// replace this with memo bag?
+	private _resizeInitialBindings: TLArrowBindings = { start: undefined, end: undefined }
+	override onResizeStart?: TLOnResizeStartHandler<TLArrowShape> = (shape) => {
+		this._resizeInitialBindings = getArrowBindings(this.editor, shape)
+	}
 	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
 		const { scaleX, scaleY } = info
 
-		const terminals = getArrowTerminalsInArrowSpace(this.editor, shape)
+		const bindings = this._resizeInitialBindings
+		const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
 
 		const { start, end } = structuredClone<TLArrowShape['props']>(shape.props)
 		let { bend } = shape.props
 
 		// Rescale start handle if it's not bound to a shape
-		if (start.type === 'point') {
+		if (!bindings.start) {
 			start.x = terminals.start.x * scaleX
 			start.y = terminals.start.y * scaleY
 		}
 
 		// Rescale end handle if it's not bound to a shape
-		if (end.type === 'point') {
+		if (!bindings.end) {
 			end.x = terminals.end.x * scaleX
 			end.y = terminals.end.y * scaleY
 		}
@@ -436,18 +435,23 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		const mx = Math.abs(scaleX)
 		const my = Math.abs(scaleY)
 
+		const startNormalizedAnchor = bindings?.start
+			? Vec.From(bindings.start.props.normalizedAnchor)
+			: null
+		const endNormalizedAnchor = bindings?.end ? Vec.From(bindings.end.props.normalizedAnchor) : null
+
 		if (scaleX < 0 && scaleY >= 0) {
 			if (bend !== 0) {
 				bend *= -1
 				bend *= Math.max(mx, my)
 			}
 
-			if (start.type === 'binding') {
-				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
+			if (startNormalizedAnchor) {
+				startNormalizedAnchor.x = 1 - startNormalizedAnchor.x
 			}
 
-			if (end.type === 'binding') {
-				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
+			if (endNormalizedAnchor) {
+				endNormalizedAnchor.x = 1 - endNormalizedAnchor.x
 			}
 		} else if (scaleX >= 0 && scaleY < 0) {
 			if (bend !== 0) {
@@ -455,12 +459,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				bend *= Math.max(mx, my)
 			}
 
-			if (start.type === 'binding') {
-				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
+			if (startNormalizedAnchor) {
+				startNormalizedAnchor.y = 1 - startNormalizedAnchor.y
 			}
 
-			if (end.type === 'binding') {
-				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
+			if (endNormalizedAnchor) {
+				endNormalizedAnchor.y = 1 - endNormalizedAnchor.y
 			}
 		} else if (scaleX >= 0 && scaleY >= 0) {
 			if (bend !== 0) {
@@ -471,17 +475,30 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				bend *= Math.max(mx, my)
 			}
 
-			if (start.type === 'binding') {
-				start.normalizedAnchor.x = 1 - start.normalizedAnchor.x
-				start.normalizedAnchor.y = 1 - start.normalizedAnchor.y
+			if (startNormalizedAnchor) {
+				startNormalizedAnchor.x = 1 - startNormalizedAnchor.x
+				startNormalizedAnchor.y = 1 - startNormalizedAnchor.y
 			}
 
-			if (end.type === 'binding') {
-				end.normalizedAnchor.x = 1 - end.normalizedAnchor.x
-				end.normalizedAnchor.y = 1 - end.normalizedAnchor.y
+			if (endNormalizedAnchor) {
+				endNormalizedAnchor.x = 1 - endNormalizedAnchor.x
+				endNormalizedAnchor.y = 1 - endNormalizedAnchor.y
 			}
 		}
 
+		if (bindings.start && startNormalizedAnchor) {
+			createOrUpdateArrowBinding(this.editor, shape, bindings.start.toId, {
+				...bindings.start.props,
+				normalizedAnchor: startNormalizedAnchor.toJson(),
+			})
+		}
+		if (bindings.end && endNormalizedAnchor) {
+			createOrUpdateArrowBinding(this.editor, shape, bindings.end.toId, {
+				...bindings.end.props,
+				normalizedAnchor: endNormalizedAnchor.toJson(),
+			})
+		}
+
 		const next = {
 			props: {
 				start,
@@ -565,18 +582,18 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	indicator(shape: TLArrowShape) {
-		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape)
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const isEditing = useIsEditing(shape.id)
 
 		const info = this.editor.getArrowInfo(shape)
+		if (!info) return null
+
+		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)
 		const geometry = this.editor.getShapeGeometry<Group2d>(shape)
 		const bounds = geometry.bounds
 
 		const labelGeometry = shape.props.text.trim() ? (geometry.children[1] as Rectangle2d) : null
 
-		// eslint-disable-next-line react-hooks/rules-of-hooks
-		const isEditing = useIsEditing(shape.id)
-
-		if (!info) return null
 		if (Vec.Equals(start, end)) return null
 
 		const strokeWidth = STROKE_SIZES[shape.props.size]
@@ -753,6 +770,7 @@ const ArrowSvg = track(function ArrowSvg({
 	const theme = useDefaultColorTheme()
 	const info = editor.getArrowInfo(shape)
 	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
+	const bindings = getArrowBindings(editor, shape)
 
 	const changeIndex = React.useMemo<number>(() => {
 		return editor.environment.isSafari ? (globalRenderIndex += 1) : 0
@@ -783,7 +801,7 @@ const ArrowSvg = track(function ArrowSvg({
 		)
 
 		handlePath =
-			shape.props.start.type === 'binding' || shape.props.end.type === 'binding' ? (
+			bindings.start || bindings.end ? (
 				<path
 					className="tl-arrow-hint"
 					d={info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info)}
@@ -791,19 +809,19 @@ const ArrowSvg = track(function ArrowSvg({
 					strokeDashoffset={strokeDashoffset}
 					strokeWidth={sw}
 					markerStart={
-						shape.props.start.type === 'binding'
-							? shape.props.start.isExact
+						bindings.start
+							? bindings.start.props.isExact
 								? ''
-								: shape.props.start.isPrecise
+								: bindings.start.props.isPrecise
 									? 'url(#arrowhead-cross)'
 									: 'url(#arrowhead-dot)'
 							: ''
 					}
 					markerEnd={
-						shape.props.end.type === 'binding'
-							? shape.props.end.isExact
+						bindings.end
+							? bindings.end.props.isExact
 								? ''
-								: shape.props.end.isPrecise
+								: bindings.end.props.isPrecise
 									? 'url(#arrowhead-cross)'
 									: 'url(#arrowhead-dot)'
 							: ''
@@ -903,7 +921,7 @@ const shapeAtTranslationStart = new WeakMap<
 			{
 				pagePosition: Vec
 				shapePosition: Vec
-				binding: Extract<TLArrowShapeProps['start'], { type: 'binding' }>
+				binding: TLArrowBinding
 			} | null
 		>
 	}

commit 91903c97614f3645dcbdcf6986fd5e4ca3dd95dc
Author: alex <alex@dytry.ch>
Date:   Thu May 9 10:48:01 2024 +0100

    Move arrow helpers from editor to tldraw (#3721)
    
    With the new work on bindings, we no longer need to keep any arrows
    stuff hard-coded in `editor`, so let's move it to `tldraw` with the rest
    of the shapes.
    
    Couple other changes as part of this:
    - We had two different types of `WeakMap` backed cache, but we now only
    have one
    - There's a new free-standing version of `createComputedCache` that
    doesn't need access to the editor/store in order to create the cache.
    instead, it returns a `{get(editor, id)}` object and instantiates the
    cache on a per-editor basis for each call.
    - Fixed a bug in `createSelectedComputedCache` where the selector
    derivation would get re-created on every call to `get`
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `improvement` — Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    - `editor.getArrowInfo(shape)` has been replaced with
    `getArrowInfo(editor, shape)`
    - `editor.getArrowsBoundTo(shape)` has been removed. Instead, use
    `editor.getBindingsToShape(shape, 'arrow')` and follow the `fromId` of
    each binding to the corresponding arrow shape
    - These types have moved from `@tldraw/editor` to `tldraw`:
        - `TLArcInfo`
        - `TLArrowInfo`
        - `TLArrowPoint`
    - `WeakMapCache` has been removed

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index a5378b47b..8168f0158 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -10,7 +10,6 @@ import {
 	ShapeUtil,
 	SvgExportContext,
 	TLArrowBinding,
-	TLArrowBindings,
 	TLArrowShape,
 	TLHandle,
 	TLOnEditEndHandler,
@@ -25,12 +24,8 @@ import {
 	Vec,
 	arrowShapeMigrations,
 	arrowShapeProps,
-	createOrUpdateArrowBinding,
-	getArrowBindings,
-	getArrowTerminalsInArrowSpace,
 	getDefaultColorTheme,
 	mapObjectMapValues,
-	removeArrowBinding,
 	structuredClone,
 	toDomPrecision,
 	track,
@@ -56,6 +51,14 @@ import {
 	getStraightArrowHandlePath,
 } from './arrowpaths'
 import { ArrowTextLabel } from './components/ArrowTextLabel'
+import {
+	TLArrowBindings,
+	createOrUpdateArrowBinding,
+	getArrowBindings,
+	getArrowInfo,
+	getArrowTerminalsInArrowSpace,
+	removeArrowBinding,
+} from './shared'
 
 let globalRenderIndex = 0
 
@@ -103,7 +106,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	getGeometry(shape: TLArrowShape) {
-		const info = this.editor.getArrowInfo(shape)!
+		const info = getArrowInfo(this.editor, shape)!
 
 		const debugGeom: Geometry2d[] = []
 
@@ -141,7 +144,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	override getHandles(shape: TLArrowShape): TLHandle[] {
-		const info = this.editor.getArrowInfo(shape)!
+		const info = getArrowInfo(this.editor, shape)!
 
 		return [
 			{
@@ -549,7 +552,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'arrow.dragging'
 			) && !this.editor.getInstanceState().isReadonly
 
-		const info = this.editor.getArrowInfo(shape)
+		const info = getArrowInfo(this.editor, shape)
 		if (!info?.isValid) return null
 
 		const labelPosition = getArrowLabelPosition(this.editor, shape)
@@ -585,7 +588,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const isEditing = useIsEditing(shape.id)
 
-		const info = this.editor.getArrowInfo(shape)
+		const info = getArrowInfo(this.editor, shape)
 		if (!info) return null
 
 		const { start, end } = getArrowTerminalsInArrowSpace(this.editor, shape, info?.bindings)
@@ -752,7 +755,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 }
 
 function getLength(editor: Editor, shape: TLArrowShape): number {
-	const info = editor.getArrowInfo(shape)!
+	const info = getArrowInfo(editor, shape)!
 
 	return info.isStraight
 		? Vec.Dist(info.start.handle, info.end.handle)
@@ -768,7 +771,7 @@ const ArrowSvg = track(function ArrowSvg({
 }) {
 	const editor = useEditor()
 	const theme = useDefaultColorTheme()
-	const info = editor.getArrowInfo(shape)
+	const info = getArrowInfo(editor, shape)
 	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
 	const bindings = getArrowBindings(editor, shape)
 

commit 16ba1eb2c2a7032271cda5fd2786c72a4c7876cc
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon May 20 13:52:02 2024 +0100

    fix flipping for arrows (#3780)
    
    @SomeHats and me fixed arrow flipping, which was a little bit broken
    after the bindings things
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [ ] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.
    
    ---------
    
    Co-authored-by: Alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8168f0158..8e7e2f189 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -15,13 +15,13 @@ import {
 	TLOnEditEndHandler,
 	TLOnHandleDragHandler,
 	TLOnResizeHandler,
-	TLOnResizeStartHandler,
 	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
 	TLShapePartial,
 	TLShapeUtilCanvasSvgDef,
 	TLShapeUtilFlag,
 	Vec,
+	WeakCache,
 	arrowShapeMigrations,
 	arrowShapeProps,
 	getDefaultColorTheme,
@@ -406,15 +406,14 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		}
 	}
 
-	// replace this with memo bag?
-	private _resizeInitialBindings: TLArrowBindings = { start: undefined, end: undefined }
-	override onResizeStart?: TLOnResizeStartHandler<TLArrowShape> = (shape) => {
-		this._resizeInitialBindings = getArrowBindings(this.editor, shape)
-	}
+	private readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()
+
 	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
 		const { scaleX, scaleY } = info
 
-		const bindings = this._resizeInitialBindings
+		const bindings = this._resizeInitialBindings.get(shape, () =>
+			getArrowBindings(this.editor, shape)
+		)
 		const terminals = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
 
 		const { start, end } = structuredClone<TLArrowShape['props']>(shape.props)

commit 87e3d60c9008e91dec81297f327fa5c6a8b76c6f
Author: alex <alex@dytry.ch>
Date:   Thu May 23 14:32:02 2024 +0100

    rework canBind callback (#3797)
    
    This PR reworks the `canBind` callback to work with customizable
    bindings. It now accepts an object with a the shape, the other shape
    (optional - it may not exist yet), the direction, and the type of the
    binding. Devs can use this to create shapes that only participate in
    certain binding types, can have bindings from but not to them, etc.
    
    If you're implementing a binding, you can see if binding two shapes is
    allowed using `editor.canBindShapes(fromShape, toShape, 'my binding
    type')`
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `improvement` — Improving existing features
    
    ### Release Notes
    
    #### Breaking changes
    The `canBind` flag now accepts an options object instead of just the
    shape in question. If you're relying on its arguments, you need to
    change from `canBind(shape) {}` to `canBind({shape}) {}`.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8e7e2f189..f18ee01d3 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -18,6 +18,7 @@ import {
 	TLOnTranslateHandler,
 	TLOnTranslateStartHandler,
 	TLShapePartial,
+	TLShapeUtilCanBindOpts,
 	TLShapeUtilCanvasSvgDef,
 	TLShapeUtilFlag,
 	Vec,
@@ -75,7 +76,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	static override migrations = arrowShapeMigrations
 
 	override canEdit = () => true
-	override canBind = () => false
+	override canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {
+		// bindings can go from arrows to shapes, but not from shapes to arrows
+		return toShapeType !== 'arrow'
+	}
 	override canSnap = () => false
 	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
 	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
@@ -153,7 +157,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a0',
 				x: info.start.handle.x,
 				y: info.start.handle.y,
-				canBind: true,
 			},
 			{
 				id: ARROW_HANDLES.MIDDLE,
@@ -161,7 +164,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a2',
 				x: info.middle.x,
 				y: info.middle.y,
-				canBind: false,
 			},
 			{
 				id: ARROW_HANDLES.END,
@@ -169,7 +171,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				index: 'a3',
 				x: info.end.handle.x,
 				y: info.end.handle.y,
-				canBind: true,
 			},
 		].filter(Boolean) as TLHandle[]
 	}
@@ -223,7 +224,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			hitFrameInside: true,
 			margin: 0,
 			filter: (targetShape) => {
-				return !targetShape.isLocked && this.editor.getShapeUtil(targetShape).canBind(targetShape)
+				return (
+					!targetShape.isLocked &&
+					this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })
+				)
 			},
 		})
 
@@ -384,7 +388,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				hitFrameInside: true,
 				margin: 0,
 				filter: (targetShape) => {
-					return !targetShape.isLocked && this.editor.getShapeUtil(targetShape).canBind(targetShape)
+					return (
+						!targetShape.isLocked &&
+						this.editor.canBindShapes({ fromShape: shape, toShape: targetShape, binding: 'arrow' })
+					)
 				},
 			})
 

commit ef44d71ee2a83bb3d6d61cac7717c4254941019d
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Fri May 24 14:04:28 2024 +0100

    Add heart geo shape (#3787)
    
    This PR adds a heart geo shape. ❤️
    
    It also:
    - adds `toSvgPathData` to geometry2d
    - uses geometry2d in places where previously we recalculated things like
    perimeter of ellipse
    - flattens geo shape util components
    
    - [x] Calculate the path length for the DashStyleHeart
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Release Notes
    
    - Adds a heart shape to the geo shape set.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index f18ee01d3..65847e430 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -121,7 +121,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				})
 			: new Arc2d({
 					center: Vec.Cast(info.handleArc.center),
-					radius: info.handleArc.radius,
 					start: Vec.Cast(info.start.point),
 					end: Vec.Cast(info.end.point),
 					sweepFlag: info.bodyArc.sweepFlag,

commit d47fd56d829a7b096d98cbc9ca8f2cdfdd77f9b9
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Thu Jun 6 10:48:23 2024 +0100

    Bindings onBeforeShapeIsolate? (#3871)
    
    So we were kinda bending over backwards to capture the use case where we
    update the arrow's terminal x,y coords when unbinding, copy-pasting, and
    duplicating.
    
    - At first we abused the `onBeforeShapeDelete` callbacks, but that was
    footgunny.
    - Then we created a `onBeforeUnbind` callback, which was less footgunny
    but still subtly footgunny.
    
    This PR proposes reverting the `onBeforeUnbind` stuff, taking us back to
    having `onBeforeShapeDelete` stuff. But at the same time it adds
    `onBeforeShapeIsolate` callbacks which are triggered at the following
    times:
    
    - When you delete the other shape in a bound shape pair
    - When you copy/paste or duplicate one shape in a bound shape pair but
    not the other one
    - When you opt-in while deleting bindings e.g. `deleteBindings([...],
    {isolateShapes: true})`
    
    This PR also fixes the bound arrow drag interaction. We can probably
    extract that out to a separate PR if needed.
    
    
    ![Kapture 2024-06-04 at 12 42
    40](https://github.com/tldraw/tldraw/assets/1242537/95b51e14-1119-4dad-91e4-8b19fdb5e862)
    
    ### Change Type
    
    <!-- ❗ Please select a 'Scope' label ❗️ -->
    
    - [x] `sdk` — Changes the tldraw SDK
    - [ ] `dotcom` — Changes the tldraw.com web app
    - [ ] `docs` — Changes to the documentation, examples, or templates.
    - [ ] `vs code` — Changes to the vscode plugin
    - [ ] `internal` — Does not affect user-facing stuff
    
    <!-- ❗ Please select a 'Type' label ❗️ -->
    
    - [x] `bugfix` — Bug fix
    - [ ] `feature` — New feature
    - [x] `improvement` — Improving existing features
    - [ ] `chore` — Updating dependencies, other boring stuff
    - [ ] `galaxy brain` — Architectural changes
    - [ ] `tests` — Changes to any test code
    - [ ] `tools` — Changes to infrastructure, CI, internal scripts,
    debugging tools, etc.
    - [ ] `dunno` — I don't know
    
    
    ### Test Plan
    
    1. Add a step-by-step description of how to test your PR here.
    2.
    
    - [ ] Unit Tests
    - [ ] End to end tests
    
    ### Release Notes
    
    - Add a brief release note for your PR here.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 65847e430..5dcac83f7 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -34,6 +34,7 @@ import {
 	useIsEditing,
 } from '@tldraw/editor'
 import React from 'react'
+import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
 import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES } from '../shared/default-shape-constants'
@@ -355,6 +356,25 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			}),
 		})
 
+		// update arrow terminal bindings eagerly to make sure the arrows unbind nicely when translating
+		if (bindings.start) {
+			updateArrowTerminal({
+				editor: this.editor,
+				arrow: shape,
+				terminal: 'start',
+				useHandle: true,
+			})
+			shape = this.editor.getShape(shape.id) as TLArrowShape
+		}
+		if (bindings.end) {
+			updateArrowTerminal({
+				editor: this.editor,
+				arrow: shape,
+				terminal: 'end',
+				useHandle: true,
+			})
+		}
+
 		for (const handleName of [ARROW_HANDLES.START, ARROW_HANDLES.END] as const) {
 			const binding = bindings[handleName]
 			if (!binding) continue
@@ -570,7 +590,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
 					<ArrowSvg
 						shape={shape}
-						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape === shape}
+						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape?.id === shape.id}
 					/>
 				</SVGContainer>
 				{showArrowLabel && (

commit ac149c1014fb5f0539d7c55f0f10ce2a05a23f74
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Sun Jun 16 19:58:13 2024 +0300

    Dynamic size mode + fill fill (#3835)
    
    This PR adds a user preference for "dynamic size mode" where the scale
    of shapes (text size, stroke width) is relative to the current zoom
    level. This means that the stroke width in screen pixels (or text size
    in screen pixels) is identical regardless of zoom level.
    
    ![Kapture 2024-05-27 at 05 23
    21](https://github.com/tldraw/tldraw/assets/23072548/f247ecce-bfcd-4f85-b7a5-d7677b38e4d8)
    
    - [x] Draw shape
    - [x] Text shape
    - [x] Highlighter shape
    - [x] Geo shape
    - [x] Arrow shape
    - [x] Note shape
    - [x] Line shape
    
    Embed shape?
    
    ### Change Type
    
    - [x] `sdk` — Changes the tldraw SDK
    - [x] `feature` — New feature
    
    ### Test Plan
    
    1. Use the tools.
    2. Change zoom
    
    - [ ] Unit Tests
    
    ### Release Notes
    
    - Adds a dynamic size user preferences.
    - Removes double click to reset scale on text shapes.
    - Removes double click to reset autosize on text shapes.
    
    ---------
    
    Co-authored-by: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 5dcac83f7..046ea9556 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -35,16 +35,18 @@ import {
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
-import { ShapeFill, useDefaultColorTheme } from '../shared/ShapeFill'
+import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
-import { ARROW_LABEL_FONT_SIZES, STROKE_SIZES } from '../shared/default-shape-constants'
+import { TextLabel } from '../shared/TextLabel'
+import { STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
 import {
 	getFillDefForCanvas,
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
 import { getPerfectDashProps } from '../shared/getPerfectDashProps'
-import { getArrowLabelPosition } from './arrowLabel'
+import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
+import { getArrowLabelFontSize, getArrowLabelPosition } from './arrowLabel'
 import { getArrowheadPathForType } from './arrowheads'
 import {
 	getCurvedArrowHandlePath,
@@ -52,7 +54,6 @@ import {
 	getSolidStraightArrowPath,
 	getStraightArrowHandlePath,
 } from './arrowpaths'
-import { ArrowTextLabel } from './components/ArrowTextLabel'
 import {
 	TLArrowBindings,
 	createOrUpdateArrowBinding,
@@ -107,6 +108,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			text: '',
 			labelPosition: 0.5,
 			font: 'draw',
+			scale: 1,
 		}
 	}
 
@@ -567,6 +569,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 
 	component(shape: TLArrowShape) {
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const theme = useDefaultColorTheme()
 		const onlySelectedShape = this.editor.getOnlySelectedShape()
 		const shouldDisplayHandles =
 			this.editor.isInAny(
@@ -594,15 +598,23 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					/>
 				</SVGContainer>
 				{showArrowLabel && (
-					<ArrowTextLabel
+					<TextLabel
 						id={shape.id}
-						text={shape.props.text}
+						classNamePrefix="tl-arrow"
+						type="arrow"
 						font={shape.props.font}
-						size={shape.props.size}
-						position={labelPosition.box.center}
-						width={labelPosition.box.w}
+						fontSize={getArrowLabelFontSize(shape)}
+						lineHeight={TEXT_PROPS.lineHeight}
+						align="middle"
+						verticalAlign="middle"
+						text={shape.props.text}
+						labelColor={theme[shape.props.labelColor].solid}
+						textWidth={labelPosition.box.w}
 						isSelected={isSelected}
-						labelColor={shape.props.labelColor}
+						padding={0}
+						style={{
+							transform: `translate(${labelPosition.box.center.x}px, ${labelPosition.box.center.y}px)`,
+						}}
 					/>
 				)}
 			</>
@@ -624,7 +636,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		if (Vec.Equals(start, end)) return null
 
-		const strokeWidth = STROKE_SIZES[shape.props.size]
+		const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 
 		const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
 		const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
@@ -645,8 +657,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					y={toDomPrecision(labelGeometry.y)}
 					width={labelGeometry.w}
 					height={labelGeometry.h}
-					rx={3.5}
-					ry={3.5}
+					rx={3.5 * shape.props.scale}
+					ry={3.5 * shape.props.scale}
 				/>
 			)
 		}
@@ -670,8 +682,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 									width={labelGeometry.w}
 									height={labelGeometry.h}
 									fill="black"
-									rx={3.5}
-									ry={3.5}
+									rx={3.5 * shape.props.scale}
+									ry={3.5 * shape.props.scale}
 								/>
 							)}
 							{as && (
@@ -746,21 +758,22 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		ctx.addExportDef(getFillDefForExport(shape.props.fill))
 		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
 		const theme = getDefaultColorTheme(ctx)
+		const scaleFactor = 1 / shape.props.scale
 
 		return (
-			<>
+			<g transform={`scale(${scaleFactor})`}>
 				<ArrowSvg shape={shape} shouldDisplayHandles={false} />
 				<SvgTextLabel
-					fontSize={ARROW_LABEL_FONT_SIZES[shape.props.size]}
+					fontSize={getArrowLabelFontSize(shape)}
 					font={shape.props.font}
 					align="middle"
 					verticalAlign="middle"
 					text={shape.props.text}
 					labelColor={theme[shape.props.labelColor].solid}
 					bounds={getArrowLabelPosition(this.editor, shape).box}
-					padding={4}
+					padding={4 * shape.props.scale}
 				/>
-			</>
+			</g>
 		)
 	}
 
@@ -807,7 +820,7 @@ const ArrowSvg = track(function ArrowSvg({
 
 	if (!info?.isValid) return null
 
-	const strokeWidth = STROKE_SIZES[shape.props.size]
+	const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
 
 	const as = info.start.arrowhead && getArrowheadPathForType(info, 'start', strokeWidth)
 	const ae = info.end.arrowhead && getArrowheadPathForType(info, 'end', strokeWidth)
@@ -817,7 +830,7 @@ const ArrowSvg = track(function ArrowSvg({
 	let handlePath: null | React.JSX.Element = null
 
 	if (shouldDisplayHandles) {
-		const sw = 2
+		const sw = 2 / editor.getZoomLevel()
 		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
 			getLength(editor, shape),
 			sw,
@@ -928,10 +941,22 @@ const ArrowSvg = track(function ArrowSvg({
 					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
 				</g>
 				{as && maskStartArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill theme={theme} d={as} color={shape.props.color} fill={shape.props.fill} />
+					<ShapeFill
+						theme={theme}
+						d={as}
+						color={shape.props.color}
+						fill={shape.props.fill}
+						scale={shape.props.scale}
+					/>
 				)}
 				{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
-					<ShapeFill theme={theme} d={ae} color={shape.props.color} fill={shape.props.fill} />
+					<ShapeFill
+						theme={theme}
+						d={ae}
+						color={shape.props.color}
+						fill={shape.props.fill}
+						scale={shape.props.scale}
+					/>
 				)}
 				{as && <path d={as} />}
 				{ae && <path d={ae} />}

commit a85d37dfa5e4ad716a737365c87afbf08774a35b
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Thu Jul 18 12:35:32 2024 +0100

    Interpolate arrow props (#4213)
    
    Interpolates handles, bend and label position. I tested this in a few
    different ways and it works well!
    
    I thought dealing with bindings would be tricky but bindings code is
    very clever! Thanks for the good work Alex and David.
    
    ![2024-07-18 at 12 21 32 - Tan
    Swift](https://github.com/user-attachments/assets/83919565-87b5-4a44-b21f-1946bf4c6e86)
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create an arrow shape, optionally create other shapes and bindings
    2. Animate the arrow shape's, bend, start and label position props
    3. It should animate smoothly from one position to the next
    
    ### Release notes
    
    - Added interpolated props for arrow shapes

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 046ea9556..dfb4faae5 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -11,6 +11,7 @@ import {
 	SvgExportContext,
 	TLArrowBinding,
 	TLArrowShape,
+	TLArrowShapeProps,
 	TLHandle,
 	TLOnEditEndHandler,
 	TLOnHandleDragHandler,
@@ -26,6 +27,7 @@ import {
 	arrowShapeMigrations,
 	arrowShapeProps,
 	getDefaultColorTheme,
+	lerp,
 	mapObjectMapValues,
 	structuredClone,
 	toDomPrecision,
@@ -790,6 +792,25 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			},
 		]
 	}
+	override getInterpolatedProps(
+		startShape: TLArrowShape,
+		endShape: TLArrowShape,
+		progress: number
+	): TLArrowShapeProps {
+		return {
+			...endShape.props,
+			start: {
+				x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
+				y: lerp(startShape.props.start.y, endShape.props.start.y, progress),
+			},
+			end: {
+				x: lerp(startShape.props.end.x, endShape.props.end.x, progress),
+				y: lerp(startShape.props.end.y, endShape.props.end.y, progress),
+			},
+			bend: lerp(startShape.props.bend, endShape.props.bend, progress),
+			labelPosition: lerp(startShape.props.labelPosition, endShape.props.labelPosition, progress),
+		}
+	}
 }
 
 function getLength(editor: Editor, shape: TLArrowShape): number {

commit f46caeb7d05236591d319982fb549195ade2f47d
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Thu Jul 25 14:54:38 2024 +0100

    Improve arrow label snapping (#4265)
    
    closes TLD-2242 , #2901
    
    I tried scaling snapping behaviour with zoom, but then changing zoom
    levels changed the snap distance and caused some arrow labels to shift
    positions, which looked bad. Now the snap distance changes depending on
    the length of the arrow. Labels on longer arrows do still snap over
    longer distances, but the difference is less pronounced.
    
    Labels do now snap to new positions sometimes when being resized.
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a very long arrow
    3. Label should now snap across a shorter distance
    
    ### Release notes
    
    - Improved snapping distances on very long arrows

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index dfb4faae5..883a5531a 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -813,7 +813,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	}
 }
 
-function getLength(editor: Editor, shape: TLArrowShape): number {
+export function getArrowLength(editor: Editor, shape: TLArrowShape): number {
 	const info = getArrowInfo(editor, shape)!
 
 	return info.isStraight
@@ -853,7 +853,7 @@ const ArrowSvg = track(function ArrowSvg({
 	if (shouldDisplayHandles) {
 		const sw = 2 / editor.getZoomLevel()
 		const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
-			getLength(editor, shape),
+			getArrowLength(editor, shape),
 			sw,
 			{
 				end: 'skip',

commit f05d102cd44ec3ab3ac84b51bf8669ef3b825481
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Jul 29 15:40:18 2024 +0200

    Move from function properties to methods (#4288)
    
    Things left to do
    - [x] Update docs (things like the [tools
    page](https://tldraw-docs-fqnvru1os-tldraw.vercel.app/docs/tools),
    possibly more)
    - [x] Write a list of breaking changes and how to upgrade.
    - [x] Do another pass and check if we can update any lines that have
    `@typescript-eslint/method-signature-style` and
    `local/prefer-class-methods` disabled
    - [x] Thinks about what to do with `TLEventHandlers`. Edit: Feels like
    keeping them is the best way to go.
    - [x] Remove `override` keyword where it's not needed. Not sure if it's
    worth the effort. Edit: decided not to spend time here.
    - [ ] What about possible detached / destructured uses?
    
    Fixes https://github.com/tldraw/tldraw/issues/2799
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Adds eslint rules for enforcing the use of methods instead of function
    properties and fixes / disables all the resulting errors.
    
    # Breaking changes
    
    This change affects the syntax of how the event handlers for shape tools
    and utils are defined.
    
    ## Shape utils
    **Before**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit = () => true
    
       // Defining event handlers
       override onResize: TLOnResizeHandler<CustomShape> = (shape, info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeUtil extends ShapeUtil<CustomShape> {
       // Defining flags
       override canEdit() {
          return true
       }
    
       // Defining event handlers
       override onResize(shape: CustomShape, info: TLResizeInfo<CustomShape>) {
          ...
       }
    }
    ```
    
    ## Tools
    
    **Before**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children = (): TLStateNodeConstructor[] => [Idle, Pointing]
    
       // Defining event handlers
       override onKeyDown: TLEventHandlers['onKeyDown'] = (info) => {
          ...
       }
    }
    ```
    
    
    **After**
    ```ts
    export class CustomShapeTool extends StateNode {
       // Defining child states
       static override children(): TLStateNodeConstructor[] {
          return [Idle, Pointing]
       }
    
       // Defining event handlers
       override onKeyDown(info: TLKeyboardEventInfo) {
          ...
       }
    }
    ```
    
    ---------
    
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 883a5531a..57505ef8d 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -13,15 +13,11 @@ import {
 	TLArrowShape,
 	TLArrowShapeProps,
 	TLHandle,
-	TLOnEditEndHandler,
-	TLOnHandleDragHandler,
-	TLOnResizeHandler,
-	TLOnTranslateHandler,
-	TLOnTranslateStartHandler,
+	TLHandleDragInfo,
+	TLResizeInfo,
 	TLShapePartial,
 	TLShapeUtilCanBindOpts,
 	TLShapeUtilCanvasSvgDef,
-	TLShapeUtilFlag,
 	Vec,
 	WeakCache,
 	arrowShapeMigrations,
@@ -79,18 +75,30 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	static override props = arrowShapeProps
 	static override migrations = arrowShapeMigrations
 
-	override canEdit = () => true
+	override canEdit() {
+		return true
+	}
 	override canBind({ toShapeType }: TLShapeUtilCanBindOpts<TLArrowShape>): boolean {
 		// bindings can go from arrows to shapes, but not from shapes to arrows
 		return toShapeType !== 'arrow'
 	}
-	override canSnap = () => false
-	override hideResizeHandles: TLShapeUtilFlag<TLArrowShape> = () => true
-	override hideRotateHandle: TLShapeUtilFlag<TLArrowShape> = () => true
-	override hideSelectionBoundsBg: TLShapeUtilFlag<TLArrowShape> = () => true
-	override hideSelectionBoundsFg: TLShapeUtilFlag<TLArrowShape> = () => true
+	override canSnap() {
+		return false
+	}
+	override hideResizeHandles() {
+		return true
+	}
+	override hideRotateHandle() {
+		return true
+	}
+	override hideSelectionBoundsBg() {
+		return true
+	}
+	override hideSelectionBoundsFg() {
+		return true
+	}
 
-	override canBeLaidOut: TLShapeUtilFlag<TLArrowShape> = (shape) => {
+	override canBeLaidOut(shape: TLArrowShape) {
 		const bindings = getArrowBindings(this.editor, shape)
 		return !bindings.start && !bindings.end
 	}
@@ -179,7 +187,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		].filter(Boolean) as TLHandle[]
 	}
 
-	override onHandleDrag: TLOnHandleDragHandler<TLArrowShape> = (shape, { handle, isPrecise }) => {
+	override onHandleDrag(
+		shape: TLArrowShape,
+		{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>
+	) {
 		const handleId = handle.id as ARROW_HANDLES
 		const bindings = getArrowBindings(this.editor, shape)
 
@@ -323,7 +334,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return update
 	}
 
-	override onTranslateStart: TLOnTranslateStartHandler<TLArrowShape> = (shape) => {
+	override onTranslateStart(shape: TLArrowShape) {
 		const bindings = getArrowBindings(this.editor, shape)
 
 		const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(this.editor, shape, bindings)
@@ -392,7 +403,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return
 	}
 
-	override onTranslate?: TLOnTranslateHandler<TLArrowShape> = (initialShape, shape) => {
+	override onTranslate(initialShape: TLArrowShape, shape: TLArrowShape) {
 		const atTranslationStart = shapeAtTranslationStart.get(initialShape)
 		if (!atTranslationStart) return
 
@@ -438,7 +449,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	private readonly _resizeInitialBindings = new WeakCache<TLArrowShape, TLArrowBindings>()
 
-	override onResize: TLOnResizeHandler<TLArrowShape> = (shape, info) => {
+	override onResize(shape: TLArrowShape, info: TLResizeInfo<TLArrowShape>) {
 		const { scaleX, scaleY } = info
 
 		const bindings = this._resizeInitialBindings.get(shape, () =>
@@ -542,10 +553,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return next
 	}
 
-	override onDoubleClickHandle = (
+	override onDoubleClickHandle(
 		shape: TLArrowShape,
 		handle: TLHandle
-	): TLShapePartial<TLArrowShape> | void => {
+	): TLShapePartial<TLArrowShape> | void {
 		switch (handle.id) {
 			case ARROW_HANDLES.START: {
 				return {
@@ -736,7 +747,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		)
 	}
 
-	override onEditEnd: TLOnEditEndHandler<TLArrowShape> = (shape) => {
+	override onEditEnd(shape: TLArrowShape) {
 		const {
 			id,
 			type,

commit 306c5c0204cfc3ed838b5f3378219a410d32b458
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Jul 29 15:58:59 2024 +0100

    draw: fix dotted line rendering when zoomed out (#4261)
    
    Fixes https://github.com/tldraw/tldraw/issues/1995
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Draw: fix dotted line shape rendering when zoomed out greatly.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 57505ef8d..e91d7e0d1 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -23,6 +23,7 @@ import {
 	arrowShapeMigrations,
 	arrowShapeProps,
 	getDefaultColorTheme,
+	getPerfectDashProps,
 	lerp,
 	mapObjectMapValues,
 	structuredClone,
@@ -30,6 +31,7 @@ import {
 	track,
 	useEditor,
 	useIsEditing,
+	useValue,
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
@@ -42,7 +44,6 @@ import {
 	getFillDefForExport,
 	getFontDefForExport,
 } from '../shared/defaultStyleDefs'
-import { getPerfectDashProps } from '../shared/getPerfectDashProps'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getArrowLabelFontSize, getArrowLabelPosition } from './arrowLabel'
 import { getArrowheadPathForType } from './arrowheads'
@@ -844,6 +845,13 @@ const ArrowSvg = track(function ArrowSvg({
 	const info = getArrowInfo(editor, shape)
 	const bounds = Box.ZeroFix(editor.getShapeGeometry(shape).bounds)
 	const bindings = getArrowBindings(editor, shape)
+	const isForceSolid = useValue(
+		'force solid',
+		() => {
+			return editor.getZoomLevel() < 0.2
+		},
+		[editor]
+	)
 
 	const changeIndex = React.useMemo<number>(() => {
 		return editor.environment.isSafari ? (globalRenderIndex += 1) : 0
@@ -909,6 +917,7 @@ const ArrowSvg = track(function ArrowSvg({
 		strokeWidth,
 		{
 			style: shape.props.dash,
+			forceSolid: isForceSolid,
 		}
 	)
 

commit e0f36407d9b8297ed77e5507c52b88949cdfc745
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Thu Aug 1 16:47:01 2024 +0200

    [Feature, Example] Text search example and `getText` API (#4306)
    
    Motivated by #3495
    
    An example of how to add custom search via`⌘+f` keyboard shortcuts. This
    also adds `getText` method to `ShapeUtil`, which allows the users to
    query the shapes for text.
    
    Down the line we could choose to add something like `getShapesWithText`
    to the editor and maybe even add some UI to dotcom. For now, let's just
    expose the API.
    
    
    https://github.com/user-attachments/assets/5631301c-a02a-4b66-8dbf-09571e67a46c
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Adds `getText` to the `ShapeUtil` api so that we can allow searching
    for text in a nicely extensible way.
    - Adds an example of how to add text search.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index e91d7e0d1..a26a9915f 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -188,6 +188,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		].filter(Boolean) as TLHandle[]
 	}
 
+	override getText(shape: TLArrowShape) {
+		return shape.props.text
+	}
+
 	override onHandleDrag(
 		shape: TLArrowShape,
 		{ handle, isPrecise }: TLHandleDragInfo<TLArrowShape>

commit 46fec0b2ee8230c3f943e8f26ffaacf45aa21f17
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Sat Aug 3 13:06:02 2024 +0100

    Interpolation: draw/highlight points, discrete props (#4241)
    
    Draw shapes and highlighter shape points now animate between states.
    
    ![2024-07-22 at 13 44 45 - Teal
    Sparrow](https://github.com/user-attachments/assets/92de6f2c-7b84-415e-b81b-94264a1341d9)
    
    There is some repetition of logic between the function that animates
    draw points and the one that animates lines. However, I felt that the
    structure of draw shapes and lines is different enough that generalising
    the function would add complexity and sacrifice readability, and didn't
    seem worth it just to remove a small amount of repetition. Very happy to
    change that should anyone disagree.
    
    Image shape crop property animates to the new position
    
    ![2024-07-22 at 15 39 30 - Purple
    Cattle](https://github.com/user-attachments/assets/fb108a48-6ed0-4f49-a232-fa806c78aa97)
    
    
    Discrete props (props that don't have continuous values to animate
    along) now change in the middle of the animation. It's likely that
    continuous animation will be happening at the same time, making the
    change in the middle of that movement helps smooth over the abruptness
    of that change.
    
    This is what it looks like if they change at the start:
    
    ![2024-07-18 at 13 11 32 - Amaranth
    Primate](https://github.com/user-attachments/assets/50570507-0b0a-4f61-a710-a180b7ddb00f)
    
    
    This is what it looks like when the props change halfway:
    
    ![2024-07-18 at 13 12 40 - Teal
    Gerbil](https://github.com/user-attachments/assets/48a28e62-901a-45db-8d30-4a5a18b5960f)
    
    
    The text usually changes at the halfway mark, but if there's no text to
    begin with, then any text in the end shape is streamed in:
    
    ![2024-07-18 at 15 18 34 - Tan
    Catshark](https://github.com/user-attachments/assets/ed59122c-7f52-4f57-94d5-9382ff8d62b1)
    
    Question: Do we want tests for this?
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [x] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Animate a shape between different states
    2. It should change its discrete props at the midway point of the
    animation, and animate smoothly for continuous values such as dimension
    or position.
    
    ### Release notes
    
    - Added getInterpolated props method for all shapes, including draw and
    highlighter.
    
    ---------
    
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index a26a9915f..ada7bb222 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -814,7 +814,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		progress: number
 	): TLArrowShapeProps {
 		return {
-			...endShape.props,
+			...(progress > 0.5 ? endShape.props : startShape.props),
+			scale: lerp(startShape.props.scale, endShape.props.scale, progress),
 			start: {
 				x: lerp(startShape.props.start.x, endShape.props.start.x, progress),
 				y: lerp(startShape.props.start.y, endShape.props.start.y, progress),

commit a061eff028f7aaeb42ddac0ea23aeca9a3eb9472
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Mon Sep 23 20:52:57 2024 +0200

    Fix collaboration shape indicator showing a line through the arrow's label (#4580)
    
    Masks for the collaborator indicators where somehow not getting
    correctly applied. First I played around with adding a random string to
    the end of the mask id which fixed it. But then I also found out this
    works.
    
    I think there's some issue with ids for inline defined masks 🤷‍♂️ Was
    able to find a few similar issues online (but not exactly the same
    though).
    
    Fixes #4562
    
    ### Before
    
    
    https://github.com/user-attachments/assets/6a6982d6-7984-4b4e-beb2-48c3094dce9d
    
    ### After
    
    
    https://github.com/user-attachments/assets/0340fd96-c55e-4d61-a42d-8f1207b3c15c
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create an arrow with a label in a multiplayer project.
    2. Select the arrow.
    3. Open the same project in another browser / incognito.
    4. The collaborator indicator should not be shown on top of the arrow's
    label.
    
    ### Release notes
    
    - Fix an issue with arrow collaborator indicator showing on top of the
    arrow's label.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index ada7bb222..1f863226e 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -933,7 +933,11 @@ const ArrowSvg = track(function ArrowSvg({
 
 	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
 	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
-	const maskId = (shape.id + '_clip_' + changeIndex).replace(':', '_')
+	const maskId = (
+		shape.id +
+		'_clip' +
+		(editor.environment.isSafari ? `_${changeIndex}` : '')
+	).replace(':', '_')
 
 	return (
 		<>

commit 31f12d24b66e8ef4356d9b766f5fc247f1088095
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Sep 23 19:53:16 2024 +0100

    Fix label wrapping (#4571)
    
    This PR fixes a bug that was causing broken wrapping on arrow labels.
    
    We were calculating the bounds of the arrow label with an included
    padding when measuring the arrow label, but not removing that padding
    from the arrow label text.
    
    Before:
    <img width="257" alt="image"
    src="https://github.com/user-attachments/assets/498abb3f-c5b3-4ab6-a407-710c205b249a">
    
    After:
    <img width="312" alt="image"
    src="https://github.com/user-attachments/assets/11389205-b5e2-4c9d-bf08-e0aafdb719bf">
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Test plan
    
    1. Use the text arrow labels
    2. Check for weird line breaks
    
    ### Release notes
    
    - Fixed a bug with arrow label text measurements.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 1f863226e..eb5a67a5a 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -38,7 +38,7 @@ import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { TextLabel } from '../shared/TextLabel'
-import { STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
+import { ARROW_LABEL_PADDING, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
 import {
 	getFillDefForCanvas,
 	getFillDefForExport,
@@ -627,7 +627,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 						verticalAlign="middle"
 						text={shape.props.text}
 						labelColor={theme[shape.props.labelColor].solid}
-						textWidth={labelPosition.box.w}
+						textWidth={labelPosition.box.w - ARROW_LABEL_PADDING * 2 * shape.props.scale}
 						isSelected={isSelected}
 						padding={0}
 						style={{
@@ -788,8 +788,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					verticalAlign="middle"
 					text={shape.props.text}
 					labelColor={theme[shape.props.labelColor].solid}
-					bounds={getArrowLabelPosition(this.editor, shape).box}
-					padding={4 * shape.props.scale}
+					bounds={getArrowLabelPosition(this.editor, shape)
+						.box.clone()
+						.expandBy(-ARROW_LABEL_PADDING * shape.props.scale)}
+					padding={0}
 				/>
 			</g>
 		)

commit 804a87fe10dee58d8fb0b4ef1182ce49790e8e1f
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Sep 30 14:24:10 2024 +0100

    chore: refactor safe id (#4618)
    
    just a little thing that was driving me nuts :P
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [x] `other`

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index eb5a67a5a..dda5972cc 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -26,6 +26,7 @@ import {
 	getPerfectDashProps,
 	lerp,
 	mapObjectMapValues,
+	sanitizeId,
 	structuredClone,
 	toDomPrecision,
 	track,
@@ -666,7 +667,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			(ae && info.end.arrowhead !== 'arrow') ||
 			!!labelGeometry
 
-		const maskId = (shape.id + '_clip').replace(':', '_')
+		const maskId = sanitizeId(shape.id + '_clip')
 
 		if (isEditing && labelGeometry) {
 			return (
@@ -935,11 +936,9 @@ const ArrowSvg = track(function ArrowSvg({
 
 	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
 	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
-	const maskId = (
-		shape.id +
-		'_clip' +
-		(editor.environment.isSafari ? `_${changeIndex}` : '')
-	).replace(':', '_')
+	const maskId = sanitizeId(
+		shape.id + '_clip' + (editor.environment.isSafari ? `_${changeIndex}` : '')
+	)
 
 	return (
 		<>

commit 09f89a60f403ff704c1372eff9fecba6cd5ce361
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Mon Sep 30 16:27:45 2024 -0400

    [dotcom] Menus, dialogs, toasts, etc. (#4624)
    
    This PR brings tldraw's ui into the application layer: dialogs, menus,
    etc.
    
    It:
    - brings our dialogs to the application layer
    - brings our toasts to the application layer
    - brings our translations to the application layer
    - brings our assets to the application layer
    - creates a "file menu"
    - creates a "rename file" dialog
    - creates the UI for changing the title of a file in the header
    - adjusts some text sizes
    
    In order to do that, I've had to:
    - create a global `tlmenus` system for menus
    - create a global `tltime` system for timers
    - create a global `tlenv` for environment"
    - create a `useMaybeEditor` hook
    
    ### Change type
    
    - [x] `other`
    
    ### Release notes
    - exports dialogs system
    - exports toasts system
    - exports translations system
    - create a global `tlmenus` system for menus
    - create a global `tltime` system for timers
    - create a global `tlenv` for environment"
    - create a `useMaybeEditor` hook
    
    ---------
    
    Co-authored-by: Mitja Bezenšek <mitja.bezensek@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index dda5972cc..9ce22d5a1 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -28,6 +28,7 @@ import {
 	mapObjectMapValues,
 	sanitizeId,
 	structuredClone,
+	tlenv,
 	toDomPrecision,
 	track,
 	useEditor,
@@ -862,7 +863,7 @@ const ArrowSvg = track(function ArrowSvg({
 	)
 
 	const changeIndex = React.useMemo<number>(() => {
-		return editor.environment.isSafari ? (globalRenderIndex += 1) : 0
+		return tlenv.isSafari ? (globalRenderIndex += 1) : 0
 		// eslint-disable-next-line react-hooks/exhaustive-deps
 	}, [shape])
 
@@ -936,9 +937,7 @@ const ArrowSvg = track(function ArrowSvg({
 
 	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
 	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
-	const maskId = sanitizeId(
-		shape.id + '_clip' + (editor.environment.isSafari ? `_${changeIndex}` : '')
-	)
+	const maskId = sanitizeId(shape.id + '_clip' + (tlenv.isSafari ? `_${changeIndex}` : ''))
 
 	return (
 		<>

commit b19fcc399eda223b76ffe17509e7aa19c5b40f9d
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Tue Oct 1 14:58:38 2024 +0200

    Improve perf for safari (#4636)
    
    Looks like safari has some issue with using masks. This PR switches from
    using masks to clipPaths.
    
    Might be worth hotfixing.
    
    Reported
    [here](https://discord.com/channels/859816885297741824/1290288009492824065/1290288009492824065).
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create some arrows.
    2. Add labels to some of them.
    3. Zoom in significantly (especially in Safari) and pan around. You
    should not see a drop in perf. You can turn on perf measurement in the
    debug panel to see the fps for panning.
    4. Make sure the clip paths worth correctly (ie no arrow bodies behind
    arrow labels).
    
    ### Release notes
    
    - Fix a performance issue with panning when zoomed in on arrows in
    Safari.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 9ce22d5a1..9579bc17a 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -28,7 +28,6 @@ import {
 	mapObjectMapValues,
 	sanitizeId,
 	structuredClone,
-	tlenv,
 	toDomPrecision,
 	track,
 	useEditor,
@@ -64,8 +63,6 @@ import {
 	removeArrowBinding,
 } from './shared'
 
-let globalRenderIndex = 0
-
 enum ARROW_HANDLES {
 	START = 'start',
 	MIDDLE = 'middle',
@@ -862,11 +859,6 @@ const ArrowSvg = track(function ArrowSvg({
 		[editor]
 	)
 
-	const changeIndex = React.useMemo<number>(() => {
-		return tlenv.isSafari ? (globalRenderIndex += 1) : 0
-		// eslint-disable-next-line react-hooks/exhaustive-deps
-	}, [shape])
-
 	if (!info?.isValid) return null
 
 	const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
@@ -935,40 +927,26 @@ const ArrowSvg = track(function ArrowSvg({
 	const maskStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
 	const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
 
-	// NOTE: I know right setting `changeIndex` hacky-as right! But we need this because otherwise safari loses
-	// the mask, see <https://linear.app/tldraw/issue/TLD-1500/changing-arrow-color-makes-line-pass-through-text>
-	const maskId = sanitizeId(shape.id + '_clip' + (tlenv.isSafari ? `_${changeIndex}` : ''))
+	const clipPathId = sanitizeId(shape.id + '_clip')
 
 	return (
 		<>
 			{/* Yep */}
 			<defs>
-				<mask id={maskId}>
-					<rect
-						x={toDomPrecision(-100 + bounds.minX)}
-						y={toDomPrecision(-100 + bounds.minY)}
-						width={toDomPrecision(bounds.width + 200)}
-						height={toDomPrecision(bounds.height + 200)}
-						fill="white"
+				<clipPath id={clipPathId}>
+					<ArrowClipPath
+						hasText={shape.props.text.trim().length > 0}
+						bounds={bounds}
+						labelPositionBounds={labelPosition.box}
 					/>
-					{shape.props.text.trim() && (
-						<rect
-							x={labelPosition.box.x}
-							y={labelPosition.box.y}
-							width={labelPosition.box.w}
-							height={labelPosition.box.h}
-							fill="black"
-							rx={4}
-							ry={4}
-						/>
-					)}
+
 					{as && maskStartArrowhead && (
 						<path d={as} fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
 					)}
 					{ae && maskEndArrowhead && (
 						<path d={ae} fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
 					)}
-				</mask>
+				</clipPath>
 			</defs>
 			<g
 				fill="none"
@@ -980,7 +958,12 @@ const ArrowSvg = track(function ArrowSvg({
 			>
 				{handlePath}
 				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
-				<g mask={`url(#${maskId})`}>
+				<g
+					style={{
+						clipPath: `url(#${clipPathId})`,
+						WebkitClipPath: `url(#${clipPathId})`,
+					}}
+				>
 					<rect
 						x={toDomPrecision(bounds.minX - 100)}
 						y={toDomPrecision(bounds.minY - 100)}
@@ -1015,6 +998,62 @@ const ArrowSvg = track(function ArrowSvg({
 	)
 })
 
+function ArrowClipPath({
+	hasText,
+	bounds,
+	labelPositionBounds,
+}: {
+	hasText: boolean
+	bounds: Box
+	labelPositionBounds: Box
+}) {
+	if (hasText) {
+		// There doesn't seem to be an easy way to invert a clipPath, so we instead create this complex polygon.
+		// We create the three sides of the outer rectangle in the clockwise direction, then move to the inside rectangle
+		// and create that one in the counterclockwise direction (so we don't intersect and complete the path).
+		// We then finish with the outer rectangle. Diagram shows the order of the points.
+		//
+		//    (1, 11)--------------------------(2)
+		//       |                              |
+		//       |         Outer Rect           |
+		//       |                            	|
+		//       |  (8)-------------------(7)   |
+		//       |    |                    |    |
+		//       |    |                    |    |
+		//       |    |    Inner Rect      |    |
+		//       |    |                    |    |
+		//       |    |                    |    |
+		//       |  (5,9)-----------------(6)   |
+		//    (4, 10)--------------------------(3)
+
+		return (
+			<polygon
+				points={`
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
+        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY - 100)} 
+        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${labelPositionBounds.x},${labelPositionBounds.y + labelPositionBounds.h}
+        ${labelPositionBounds.x + labelPositionBounds.w},${labelPositionBounds.y + labelPositionBounds.h}
+        ${labelPositionBounds.x + labelPositionBounds.w},${labelPositionBounds.y}
+        ${labelPositionBounds.x},${labelPositionBounds.y}
+        ${labelPositionBounds.x},${labelPositionBounds.y + labelPositionBounds.h}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
+        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
+      `}
+			/>
+		)
+	}
+	return (
+		<rect
+			x={toDomPrecision(bounds.minX - 100)}
+			y={toDomPrecision(bounds.minY - 100)}
+			width={toDomPrecision(bounds.width + 200)}
+			height={toDomPrecision(bounds.height + 200)}
+		/>
+	)
+}
+
 const shapeAtTranslationStart = new WeakMap<
 	TLArrowShape,
 	{

commit 3273821b003f5f24bd80ce6d5567cae7d23248e8
Author: Mitja Bezenšek <mitja.bezensek@gmail.com>
Date:   Fri Oct 4 09:35:06 2024 +0200

    Arrowhead clipping fix (#4646)
    
    Fixes issues with arrowheads not correctly clipping the arrow's body.
    The main issue was when we used the fill none option. There was also a
    difference in how it worked if arrows had labels vs if they didn't.
    
    Also transitions the arrow indicator form using masks to using clip
    paths so that we also improve the performance of panning when we have
    arrows selected.
    
    [Related
    discussion](https://discord.com/channels/859816885297741824/1290288009492824065/1290906937797640273).
    
    ### Before
    
    
    ![image](https://github.com/user-attachments/assets/1669fc2a-e3a3-4496-ab19-2a48bd6c8bee)
    
    ### After
    
    
    ![image](https://github.com/user-attachments/assets/c191e83c-b8c9-4974-a599-71bc49a2490b)
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - Fix an issue introduced with #4636. The arrowheads did not correctly
    clip the arrow body.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 9579bc17a..002351e86 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -660,12 +660,12 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info)
 
-		const includeMask =
+		const includeClipPath =
 			(as && info.start.arrowhead !== 'arrow') ||
 			(ae && info.end.arrowhead !== 'arrow') ||
 			!!labelGeometry
 
-		const maskId = sanitizeId(shape.id + '_clip')
+		const clipPathId = sanitizeId(shape.id + '_clip')
 
 		if (isEditing && labelGeometry) {
 			return (
@@ -679,51 +679,32 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				/>
 			)
 		}
+		const clipStartArrowhead = !(
+			info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow'
+		)
+		const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
 
 		return (
 			<g>
-				{includeMask && (
+				{includeClipPath && (
 					<defs>
-						<mask id={maskId}>
-							<rect
-								x={bounds.minX - 100}
-								y={bounds.minY - 100}
-								width={bounds.w + 200}
-								height={bounds.h + 200}
-								fill="white"
-							/>
-							{labelGeometry && (
-								<rect
-									x={toDomPrecision(labelGeometry.x)}
-									y={toDomPrecision(labelGeometry.y)}
-									width={labelGeometry.w}
-									height={labelGeometry.h}
-									fill="black"
-									rx={3.5 * shape.props.scale}
-									ry={3.5 * shape.props.scale}
-								/>
-							)}
-							{as && (
-								<path
-									d={as}
-									fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'}
-									stroke="none"
-								/>
-							)}
-							{ae && (
-								<path
-									d={ae}
-									fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'}
-									stroke="none"
-								/>
-							)}
-						</mask>
+						<ArrowClipPath
+							hasText={shape.props.text.trim().length > 0}
+							bounds={bounds}
+							labelBounds={labelGeometry ? labelGeometry.getBounds() : new Box(0, 0, 0, 0)}
+							as={clipStartArrowhead && as ? as : ''}
+							ae={clipEndArrowhead && ae ? ae : ''}
+						/>
 					</defs>
 				)}
-				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
-				<g {...(includeMask ? { mask: `url(#${maskId})` } : undefined)}>
+				<g
+					style={{
+						clipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
+						WebkitClipPath: includeClipPath ? `url(#${clipPathId})` : undefined,
+					}}
+				>
 					{/* This rect needs to be here if we're creating a mask due to an svg quirk on Chrome */}
-					{includeMask && (
+					{includeClipPath && (
 						<rect
 							x={bounds.minX - 100}
 							y={bounds.minY - 100}
@@ -924,8 +905,8 @@ const ArrowSvg = track(function ArrowSvg({
 
 	const labelPosition = getArrowLabelPosition(editor, shape)
 
-	const maskStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
-	const maskEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
+	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
+	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
 
 	const clipPathId = sanitizeId(shape.id + '_clip')
 
@@ -937,15 +918,10 @@ const ArrowSvg = track(function ArrowSvg({
 					<ArrowClipPath
 						hasText={shape.props.text.trim().length > 0}
 						bounds={bounds}
-						labelPositionBounds={labelPosition.box}
+						labelBounds={labelPosition.box}
+						as={clipStartArrowhead && as ? as : ''}
+						ae={clipEndArrowhead && ae ? ae : ''}
 					/>
-
-					{as && maskStartArrowhead && (
-						<path d={as} fill={info.start.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
-					)}
-					{ae && maskEndArrowhead && (
-						<path d={ae} fill={info.end.arrowhead === 'arrow' ? 'none' : 'black'} stroke="none" />
-					)}
 				</clipPath>
 			</defs>
 			<g
@@ -957,7 +933,6 @@ const ArrowSvg = track(function ArrowSvg({
 				pointerEvents="none"
 			>
 				{handlePath}
-				{/* firefox will clip if you provide a maskURL even if there is no mask matching that URL in the DOM */}
 				<g
 					style={{
 						clipPath: `url(#${clipPathId})`,
@@ -973,7 +948,7 @@ const ArrowSvg = track(function ArrowSvg({
 					/>
 					<path d={path} strokeDasharray={strokeDasharray} strokeDashoffset={strokeDashoffset} />
 				</g>
-				{as && maskStartArrowhead && shape.props.fill !== 'none' && (
+				{as && clipStartArrowhead && shape.props.fill !== 'none' && (
 					<ShapeFill
 						theme={theme}
 						d={as}
@@ -982,7 +957,7 @@ const ArrowSvg = track(function ArrowSvg({
 						scale={shape.props.scale}
 					/>
 				)}
-				{ae && maskEndArrowhead && shape.props.fill !== 'none' && (
+				{ae && clipEndArrowhead && shape.props.fill !== 'none' && (
 					<ShapeFill
 						theme={theme}
 						d={ae}
@@ -1001,57 +976,25 @@ const ArrowSvg = track(function ArrowSvg({
 function ArrowClipPath({
 	hasText,
 	bounds,
-	labelPositionBounds,
+	labelBounds,
+	as,
+	ae,
 }: {
 	hasText: boolean
 	bounds: Box
-	labelPositionBounds: Box
+	labelBounds: Box
+	as: string
+	ae: string
 }) {
-	if (hasText) {
-		// There doesn't seem to be an easy way to invert a clipPath, so we instead create this complex polygon.
-		// We create the three sides of the outer rectangle in the clockwise direction, then move to the inside rectangle
-		// and create that one in the counterclockwise direction (so we don't intersect and complete the path).
-		// We then finish with the outer rectangle. Diagram shows the order of the points.
-		//
-		//    (1, 11)--------------------------(2)
-		//       |                              |
-		//       |         Outer Rect           |
-		//       |                            	|
-		//       |  (8)-------------------(7)   |
-		//       |    |                    |    |
-		//       |    |                    |    |
-		//       |    |    Inner Rect      |    |
-		//       |    |                    |    |
-		//       |    |                    |    |
-		//       |  (5,9)-----------------(6)   |
-		//    (4, 10)--------------------------(3)
-
-		return (
-			<polygon
-				points={`
-        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
-        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY - 100)} 
-        ${toDomPrecision(bounds.minX + bounds.width + 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
-        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
-        ${labelPositionBounds.x},${labelPositionBounds.y + labelPositionBounds.h}
-        ${labelPositionBounds.x + labelPositionBounds.w},${labelPositionBounds.y + labelPositionBounds.h}
-        ${labelPositionBounds.x + labelPositionBounds.w},${labelPositionBounds.y}
-        ${labelPositionBounds.x},${labelPositionBounds.y}
-        ${labelPositionBounds.x},${labelPositionBounds.y + labelPositionBounds.h}
-        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY + bounds.height + 100)}
-        ${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} 
-      `}
-			/>
-		)
-	}
-	return (
-		<rect
-			x={toDomPrecision(bounds.minX - 100)}
-			y={toDomPrecision(bounds.minY - 100)}
-			width={toDomPrecision(bounds.width + 200)}
-			height={toDomPrecision(bounds.height + 200)}
-		/>
-	)
+	// The direction in which we create the different path parts is important, as it determines what gets clipped.
+	// See the description on the directions in the non-zero fill rule example:
+	// https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule#nonzero
+	// We create this one in the clockwise direction
+	const boundingBoxPath = `M${toDomPrecision(bounds.minX - 100)},${toDomPrecision(bounds.minY - 100)} h${bounds.width + 200} v${bounds.height + 200} h-${bounds.width + 200} Z`
+	// We create this one in the counter-clockwise direction, which cuts out the label box
+	const labelBoxPath = `M${toDomPrecision(labelBounds.minX)},${toDomPrecision(labelBounds.minY)} v${labelBounds.height} h${labelBounds.width} v-${labelBounds.height} Z`
+	// We also append the arrowhead paths to the clip path, so that we also clip the arrowheads
+	return <path d={`${boundingBoxPath}${hasText ? labelBoxPath : ''}${as}${ae}`} />
 }
 
 const shapeAtTranslationStart = new WeakMap<

commit 9c14e0f1f9db3c37ac58d6df33b5404658132a9f
Author: David Sheldrick <d.j.sheldrick@gmail.com>
Date:   Mon Oct 7 09:35:01 2024 +0100

    [sync] Set instance.isReadonly automatically  (#4673)
    
    Follow up to #4648 , extracted from #4660
    
    This PR adds a TLStore prop that contains a signal for setting the
    readonly mode. This allows the readonlyness to change on the fly, which
    is necessary for botcom. it's also just nice for tlsync users to be able
    to decide on the server whether something is readonly.
    
    ### Change type
    
    - [x] `improvement`
    
    ### Release notes
    
    - Puts the editor into readonly mode automatically when the tlsync
    server responds in readonly mode.
    - Adds the `editor.getIsReadonly()` method.
    - Fixes a bug where arrow labels could be edited in readonly mode.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 002351e86..1fe562905 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -596,7 +596,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				'select.dragging_handle',
 				'select.translating',
 				'arrow.dragging'
-			) && !this.editor.getInstanceState().isReadonly
+			) && !this.editor.getIsReadonly()
 
 		const info = getArrowInfo(this.editor, shape)
 		if (!info?.isValid) return null

commit d5f4c1d05bb834ab5623d19d418e31e4ab5afa66
Author: alex <alex@dytry.ch>
Date:   Wed Oct 9 15:55:15 2024 +0100

    make sure DOM IDs are globally unique (#4694)
    
    There are a lot of places where we currently derive a DOM ID from a
    shape ID. This works fine (ish) on tldraw.com, but doesn't work for a
    lot of developer use-cases: if there are multiple tldraw instances or
    exports happening, for example. This is because the DOM expects IDs to
    be globally unique. If there are multiple elements with the same ID in
    the dom, only the first is ever used. This can cause issues if e.g.
    
    1. i have a shape with a clip-path determined by the shape ID
    2. i export that shape and add the resulting SVG to the dom. now, there
    are two clip paths with the same ID, but they're the same
    3. I change the shape - and now, the ID is referring to the export, so i
    get weird rendering issues.
    
    This diff attempts to resolve this issue and prevent it from happening
    again by introducing a new `SafeId` type, and helpers for generating and
    working with `SafeId`s. in tldraw, jsx using the `id` attribute will now
    result in a type error if the value isn't a safe ID. This doesn't affect
    library consumers writing JSX.
    
    As part of this, I've removed the ID that were added to certain shapes.
    Instead, all shapes now have a `data-shape-id` attribute on their
    wrapper.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Exports and other tldraw instances no longer can affect how each other
    are rendered
    - **BREAKING:** the `id` attribute that was present on some shapes in
    the dom has been removed. there's now a data-shape-id attribute on every
    shape wrapper instead though.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 1fe562905..662a2a11b 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -32,6 +32,8 @@ import {
 	track,
 	useEditor,
 	useIsEditing,
+	useSharedSafeId,
+	useUniqueSafeId,
 	useValue,
 } from '@tldraw/editor'
 import React from 'react'
@@ -608,7 +610,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 		return (
 			<>
-				<SVGContainer id={shape.id} style={{ minWidth: 50, minHeight: 50 }}>
+				<SVGContainer style={{ minWidth: 50, minHeight: 50 }}>
 					<ArrowSvg
 						shape={shape}
 						shouldDisplayHandles={shouldDisplayHandles && onlySelectedShape?.id === shape.id}
@@ -616,7 +618,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 				</SVGContainer>
 				{showArrowLabel && (
 					<TextLabel
-						id={shape.id}
+						shapeId={shape.id}
 						classNamePrefix="tl-arrow"
 						type="arrow"
 						font={shape.props.font}
@@ -840,6 +842,10 @@ const ArrowSvg = track(function ArrowSvg({
 		[editor]
 	)
 
+	const clipPathId = useUniqueSafeId()
+	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
+	const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
+
 	if (!info?.isValid) return null
 
 	const strokeWidth = STROKE_SIZES[shape.props.size] * shape.props.scale
@@ -876,8 +882,8 @@ const ArrowSvg = track(function ArrowSvg({
 							? bindings.start.props.isExact
 								? ''
 								: bindings.start.props.isPrecise
-									? 'url(#arrowhead-cross)'
-									: 'url(#arrowhead-dot)'
+									? `url(#${arrowheadCrossId})`
+									: `url(#${arrowheadDotId})`
 							: ''
 					}
 					markerEnd={
@@ -885,8 +891,8 @@ const ArrowSvg = track(function ArrowSvg({
 							? bindings.end.props.isExact
 								? ''
 								: bindings.end.props.isPrecise
-									? 'url(#arrowhead-cross)'
-									: 'url(#arrowhead-dot)'
+									? `url(#${arrowheadCrossId})`
+									: `url(#${arrowheadDotId})`
 							: ''
 					}
 					opacity={0.16}
@@ -908,8 +914,6 @@ const ArrowSvg = track(function ArrowSvg({
 	const clipStartArrowhead = !(info.start.arrowhead === 'none' || info.start.arrowhead === 'arrow')
 	const clipEndArrowhead = !(info.end.arrowhead === 'none' || info.end.arrowhead === 'arrow')
 
-	const clipPathId = sanitizeId(shape.id + '_clip')
-
 	return (
 		<>
 			{/* Yep */}
@@ -1013,16 +1017,18 @@ const shapeAtTranslationStart = new WeakMap<
 >()
 
 function ArrowheadDotDef() {
+	const id = useSharedSafeId('arrowhead-dot')
 	return (
-		<marker id="arrowhead-dot" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
+		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="0">
 			<circle cx="3" cy="3" r="2" strokeDasharray="100%" />
 		</marker>
 	)
 }
 
 function ArrowheadCrossDef() {
+	const id = useSharedSafeId('arrowhead-cross')
 	return (
-		<marker id="arrowhead-cross" className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
+		<marker id={id} className="tl-arrow-hint" refX="3.0" refY="3.0" orient="auto">
 			<line x1="1.5" y1="1.5" x2="4.5" y2="4.5" strokeDasharray="100%" />
 			<line x1="1.5" y1="4.5" x2="4.5" y2="1.5" strokeDasharray="100%" />
 		</marker>

commit 2a9d05c6fac6e8533ebaedd9ad13b9021d0c7d1b
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Tue Oct 22 12:28:34 2024 +0100

    arrows: fix up label indicator showing up (#4749)
    
    ### Change type
    
    - [x] `bugfix`
    - [ ] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Create a shape...
    2.
    
    - [ ] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Fix labels on arrows having indicators show up behind them.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 662a2a11b..34be234db 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -7,6 +7,7 @@ import {
 	Group2d,
 	Rectangle2d,
 	SVGContainer,
+	SafeId,
 	ShapeUtil,
 	SvgExportContext,
 	TLArrowBinding,
@@ -33,7 +34,6 @@ import {
 	useEditor,
 	useIsEditing,
 	useSharedSafeId,
-	useUniqueSafeId,
 	useValue,
 } from '@tldraw/editor'
 import React from 'react'
@@ -842,7 +842,7 @@ const ArrowSvg = track(function ArrowSvg({
 		[editor]
 	)
 
-	const clipPathId = useUniqueSafeId()
+	const clipPathId = sanitizeId(shape.id + '_clip') as SafeId
 	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
 	const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
 

commit 8641081114ab56cc6ac9a35c7843c102637aed8b
Author: alex <alex@dytry.ch>
Date:   Mon Nov 4 11:38:29 2024 +0000

    fix id regression (#4849)
    
    #4694 introduced a regression whilst fixing a bug. #4749 fixed that
    regression whilst regressing the bug that #4694 was meant to fix. this
    diff fixes both bugs.
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Release notes
    
    - Prevent arrows being clipped incorrectly when multiple tldraw
    instances or exports are present in the dom.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 34be234db..163b40b96 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -7,7 +7,6 @@ import {
 	Group2d,
 	Rectangle2d,
 	SVGContainer,
-	SafeId,
 	ShapeUtil,
 	SvgExportContext,
 	TLArrowBinding,
@@ -27,7 +26,6 @@ import {
 	getPerfectDashProps,
 	lerp,
 	mapObjectMapValues,
-	sanitizeId,
 	structuredClone,
 	toDomPrecision,
 	track,
@@ -643,6 +641,8 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	indicator(shape: TLArrowShape) {
 		// eslint-disable-next-line react-hooks/rules-of-hooks
 		const isEditing = useIsEditing(shape.id)
+		// eslint-disable-next-line react-hooks/rules-of-hooks
+		const clipPathId = useSharedSafeId(shape.id + '_clip')
 
 		const info = getArrowInfo(this.editor, shape)
 		if (!info) return null
@@ -667,8 +667,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 			(ae && info.end.arrowhead !== 'arrow') ||
 			!!labelGeometry
 
-		const clipPathId = sanitizeId(shape.id + '_clip')
-
 		if (isEditing && labelGeometry) {
 			return (
 				<rect
@@ -842,7 +840,7 @@ const ArrowSvg = track(function ArrowSvg({
 		[editor]
 	)
 
-	const clipPathId = sanitizeId(shape.id + '_clip') as SafeId
+	const clipPathId = useSharedSafeId(shape.id + '_clip')
 	const arrowheadDotId = useSharedSafeId('arrowhead-dot')
 	const arrowheadCrossId = useSharedSafeId('arrowhead-cross')
 

commit 106c984c74945d5cba15176dff695ec2a8746308
Author: Taha <98838967+Taha-Hassan-Git@users.noreply.github.com>
Date:   Wed Nov 13 11:51:30 2024 +0000

    Snap to grid when creating shapes (#4875)
    
    TLD-2817
    
    TLD-2816
    
    This PR makes sure that shapes snap to the grid when created. It adds a
    ```maybeSnapToGrid``` function, which can be used to push a shape onto
    the grid if grid mode is enabled, both when click-creating and when
    drag-creating.
    
    1. Any shapes using the basebox shape tool (i.e frames)
    2. Geo shapes
    3. Both arrow handles
    4. Line shapes, including shift-clicking
    5. Note shapes (when translating, note shapes prefer adjacent note
    positions over grid)
    6. Text shapes
    7. Aligns uploaded assets using the top left of the selection bounds.
    8. Does not snap to the grid when snap indicators are being shown
    
    It also adds tests for this behaviour
    
    ### Change type
    
    - [ ] `bugfix`
    - [x] `improvement`
    - [ ] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. Enable grid
    9. Click-create a note shape off the grid
    10. It should snap to the grid
    11. Add an asset, it should align with the grid
    
    - [x] Unit tests
    - [ ] End to end tests
    
    ### Release notes
    
    - Shapes snap to grid on creation, or when adding points.
    
    ---------
    
    Co-authored-by: Mime Čuvalo <mimecuvalo@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 163b40b96..8b2e59153 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -26,6 +26,7 @@ import {
 	getPerfectDashProps,
 	lerp,
 	mapObjectMapValues,
+	maybeSnapToGrid,
 	structuredClone,
 	toDomPrecision,
 	track,
@@ -36,6 +37,7 @@ import {
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
+
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
 import { TextLabel } from '../shared/TextLabel'
@@ -253,10 +255,10 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		if (!target) {
 			// todo: maybe double check that this isn't equal to the other handle too?
 			removeArrowBinding(this.editor, shape, handleId)
-
+			const newPoint = maybeSnapToGrid(new Vec(handle.x, handle.y), this.editor)
 			update.props![handleId] = {
-				x: handle.x,
-				y: handle.y,
+				x: newPoint.x,
+				y: newPoint.y,
 			}
 			return update
 		}

commit 54b645dd9728bc7629b4a451dc96867a39cf98f6
Author: Steve Ruiz <steveruizok@gmail.com>
Date:   Tue Feb 25 16:05:20 2025 +0000

    Improve / fix layout methods: alignment, distribute, flip, stack. (#5479)
    
    This PR fixes various bugs in our layout methods: align, distribute,
    flip, stack, pack, etc.
    
    There are a lot of small changes and fixes in this PR but the main one
    is **shape clustering**.
    
    ## Shape clustering
    
    Previously, all of our layout options had bugs related to arrows. Our
    early solution was to ignore arrows, however this only partially solved
    the problem. Often the results would not be anywhere near
    expectations—obviously wrong—but there wasn't a clear idea of what would
    be correct.
    
    While working on this problem, I had the idea to try treating networks
    of bound-and-selected shapes as "clusters" that would move together.
    This was specifically to solve a problem that could occur when aligning
    a shape that had an arrow bound to it and the other end not bound to
    anything.
    
    In this PR, all of our layout functions (except flip) move "clusters"
    rather than individual shapes—though most clusters only contain a single
    shape.
    
    <img width="553" alt="image"
    src="https://github.com/user-attachments/assets/7245689c-80bd-4ae0-85df-d42d00251d44"
    />
    
    This fixes many problems which were previously impossible to solve. A
    use can bail out of the behavior by not selecting the arrows, just as
    they could before.
    
    ## Alignment
    
    Alignment now works correctly with clusters of bound shapes.
    
    ![Kapture 2025-02-23 at 09 41
    23](https://github.com/user-attachments/assets/de75ae58-17ab-430d-871f-cd8a0f3ad05e)
    
    ![Kapture 2025-02-23 at 18 19
    47](https://github.com/user-attachments/assets/10cc8841-8ec0-4d98-9872-545edcc1002d)
    
    ![Kapture 2025-02-23 at 18 21
    57](https://github.com/user-attachments/assets/fee0d432-5242-45dd-a47c-c659326f91fa)
    
    ## Distribution
    
    Distribution now works correctly with clusters of bound shapes.
    
    Adjusts the logic for distribution so that the result will **space
    shapes out evenly between** the first and last shapes, rather than
    spacing out the centers of the shapes.
    
    Fixes a bug when distributing shapes if the same shape constituted the
    first and last shape.
    
    Fixes a bug when distributing shapes if the last shape would change the
    dimensions of the selection.
    
    ![Kapture 2025-02-23 at 09 44
    11](https://github.com/user-attachments/assets/9991a149-9eb1-43e7-bc7c-0dcc6f1a087b)
    
    ![Kapture 2025-02-23 at 18 24
    40](https://github.com/user-attachments/assets/2dd815a1-7e0c-424f-b1d5-5377fbe41ddb)
    
    ## Flip
    
    I fixed a minor bug with arrows in flipping.
    
    ![Kapture 2025-02-23 at 15 03
    04](https://github.com/user-attachments/assets/59a1d7cc-6956-4f1b-a772-a4ae1fd4414c)
    
    ## Stretch
    
    Stretch now works with clusters of shapes.
    
    Fixed a limitation with rotated shapes. Previously, stretching did not
    support any page-rotated shapes unless their page rotation was a
    multiple of PI2. It now supports shapes with any rotation equal to PI /
    2 (e.g. 90, 180, 270, or 360 degrees, and so on).
    
    ## Pack
    
    Pack not works with clusters of shapes.
    
    ![Kapture 2025-02-23 at 17 48
    12](https://github.com/user-attachments/assets/2b9a35d4-1387-42db-97d1-80966a3822b0)
    
    ### Change type
    
    - [x] `bugfix`
    
    ### Test plan
    
    1. Align a shape to an edge where that edge in the shape bounds is
    defined by an arrow
    2. Distribute overlapping or irregular shapes
    
    - [x] Unit tests
    
    ### Release notes
    
    - Fixes several bugs when aligning / flipping / distributing /
    stretching / stacking a selection that included with arrows.
    - Fixed a bug with distribution with overlapping shapes
    - Fixed a bug with distribution that could lead to changed selection.
    - Fixed a bug preventing rotated shapes from being stretched.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 8b2e59153..25b04d6be 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -16,6 +16,7 @@ import {
 	TLHandleDragInfo,
 	TLResizeInfo,
 	TLShapePartial,
+	TLShapeUtilCanBeLaidOutOpts,
 	TLShapeUtilCanBindOpts,
 	TLShapeUtilCanvasSvgDef,
 	Vec,
@@ -100,9 +101,16 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return true
 	}
 
-	override canBeLaidOut(shape: TLArrowShape) {
-		const bindings = getArrowBindings(this.editor, shape)
-		return !bindings.start && !bindings.end
+	override canBeLaidOut(shape: TLArrowShape, info: TLShapeUtilCanBeLaidOutOpts) {
+		if (info.type === 'flip') {
+			// If we don't have this then the flip will be non-idempotent; that is, the flip will be multipotent, varipotent, or perhaps even omni-potent... and we can't have that
+			const bindings = getArrowBindings(this.editor, shape)
+			const { start, end } = bindings
+			const { shapes = [] } = info
+			if (start && !shapes.find((s) => s.id === start.toId)) return false
+			if (end && !shapes.find((s) => s.id === end.toId)) return false
+		}
+		return true
 	}
 
 	override getDefaultProps(): TLArrowShape['props'] {

commit 3bf31007c5a7274f3f7926a84c96c89a4cc2c278
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Mar 3 14:23:09 2025 +0000

    [feature] add rich text and contextual toolbar (#4895)
    
    We're looking to add rich text to the editor!
    
    We originally started with ProseMirror but it became quickly clear that
    since it's more down-to-the-metal we'd have to rebuild a bunch of
    functionality, effectively managing a rich text editor in addition to a
    2D canvas. Examples of this include behaviors around lists where people
    expect certain behaviors around combination of lists next to each other,
    tabbing, etc.
    On top of those product expectations, we'd need to provide a
    higher-level API that provided better DX around things like
    transactions, switching between lists↔headers, and more.
    
    Given those considerations, a very natural fit was to use TipTap. Much
    like tldraw, they provide a great experience around manipulating a rich
    text editor. And, we want to pass on those product/DX benefits
    downstream to our SDK users.
    
    Some high-level notes:
    - the data is stored as the TipTap stringified JSON, it's lightly
    validated at the moment, but not stringently.
    - there was originally going to be a short-circuit path for plaintext
    but it ended up being error-prone with richtext/plaintext living
    side-by-side. (this meant there were two separate fields)
    - We could still add a way to render faster — I just want to avoid it
    being two separate fields, too many footguns.
    - things like arrow labels are only plain text (debatable though).
    
    Other related efforts:
    - https://github.com/tldraw/tldraw/pull/3051
    - https://github.com/tldraw/tldraw/pull/2825
    
    Todo
    - [ ] figure out whether we should have a migration or not. This is what
    we discussed cc @ds300 and @SomeHats - and whether older clients would
    start messing up newer clients. The data becomes lossy if older clients
    overwrite with plaintext.
    
    <img width="427" alt="Screenshot 2024-12-09 at 14 43 51"
    src="https://github.com/user-attachments/assets/f9dddaee-bfd3-4746-8016-d4247e417e80">
    <img width="378" alt="Screenshot 2024-12-09 at 14 42 59"
    src="https://github.com/user-attachments/assets/95e016d3-ab4d-4d34-afd3-b3ef511d2d77">
    
    Current discussion list:
    - [x] positioning: discuss toolbar position (selection bounds vs cursor
    bounds, toolbar is going in center weirdly sometimes)
    - [x] artificial delay: latest updates make it feel slow/unresponsive?
    e.g. list toggle, changing selection
    - [x] keyboard selection: discuss toolbar logic around "mousing around"
    vs. being present when keyboard selecting (which is annoying)
    - [x] mobile: discuss concerns around mobile toolbar
    - [x] mobile, precision tap: discuss / rm tap into text (and sticky
    notes?) - disable precision editing on mobile
    - [x] discuss
    useContextualToolbar/useContextualToolbarPosition/ContextualToolbar/TldrawUiContextualToolbar
    example
    - [x] existing code: middle alignment for pasted text - keep?
    - [x] existing code: should text replace the shape content when pasted?
    keep?
    - [x] discuss animation, we had it, nixed it, it's back again; why the
    0.08s animation? imperceptible?
    - [x] hide during camera move?
    - [x] short form content - hard to make a different selection b/c
    toolbar is in the way of content
    - [x] check 'overflow: hidden' on tl-text-input (update: this is needed
    to avoid scrollbars)
    - [x] decide on toolbar set: italic, underline, strikethrough, highlight
    - [x] labelColor w/ highlighted text - steve has a commit here to tweak
    highlighting
    
    todos:
    - [x] font rebuild (bold, randomization tweaks) - david looking into
    this
    
    check bugs raised:
    - [x] can't do selection on list item
    - [x] mobile: b/c of the blur/Done logic, doesn't work if you dbl-click
    on geo shape (it's a plaintext problem too)
    - [x] mobile: No cursor when using the text tool - specifically for the
    Text tool — can't repro?
    - [x] VSCode html pasting, whitespace issue?
    - [x] Link toolbar make it extend to the widest size of the current tool
    set
    - [x] code has mutual exclusivity (this is a design choice by the Code
    plugin - we could fork)
    - [x] Text is copied to the clipboard with paragraphs rather than line
    breaks.
    - [x] multi-line plaintext for arrows busted
    
    nixed/outdated
    - [ ] ~link: on mobile should be in modal?~
    - [ ] ~link: back button?~
    - [ ] ~list button toggling? (can't repro)~
    - [ ] ~double/triple-clicking is now wonky with the new logic~
    - [ ] ~move blur() code into useEditableRichText - for Done on iOS~
    - [ ] ~toolbar when shape is rotated~
    - [ ] ~"The "isMousingDown" logic doesn't work, the events aren't
    reaching the window. Not sure how we get those from the editor element."
    (can't repro?)~
    - [ ] ~toolbar position bug when toggling code on and off (can't
    repro?)~
    - [ ] ~some issue around "Something's up with the initial size
    calculated from the text selection bounds."~
    - [ ] ~mobile: Context bar still visible out if user presses "Done" to
    end editing~
    - [ ] ~mobile: toolbar when switching between text fields~
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    1. TODO: write a bunch more tests
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - Rich text using ProseMirror as a first-class supported option in the
    Editor.
    
    ---------
    
    Co-authored-by: huppy-bot[bot] <128400622+huppy-bot[bot]@users.noreply.github.com>
    Co-authored-by: alex <alex@dytry.ch>
    Co-authored-by: David Sheldrick <d.j.sheldrick@gmail.com>
    Co-authored-by: Steve Ruiz <steveruizok@gmail.com>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index 25b04d6be..b02b20f65 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -1,6 +1,7 @@
 import {
 	Arc2d,
 	Box,
+	EMPTY_ARRAY,
 	Edge2d,
 	Editor,
 	Geometry2d,
@@ -12,6 +13,7 @@ import {
 	TLArrowBinding,
 	TLArrowShape,
 	TLArrowShapeProps,
+	TLFontFace,
 	TLHandle,
 	TLHandleDragInfo,
 	TLResizeInfo,
@@ -39,15 +41,12 @@ import {
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
 
+import { PlainTextLabel } from '../shared/PlainTextLabel'
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
-import { TextLabel } from '../shared/TextLabel'
 import { ARROW_LABEL_PADDING, STROKE_SIZES, TEXT_PROPS } from '../shared/default-shape-constants'
-import {
-	getFillDefForCanvas,
-	getFillDefForExport,
-	getFontDefForExport,
-} from '../shared/defaultStyleDefs'
+import { DefaultFontFaces } from '../shared/defaultFonts'
+import { getFillDefForCanvas, getFillDefForExport } from '../shared/defaultStyleDefs'
 import { useDefaultColorTheme } from '../shared/useDefaultColorTheme'
 import { getArrowLabelFontSize, getArrowLabelPosition } from './arrowLabel'
 import { getArrowheadPathForType } from './arrowheads'
@@ -113,6 +112,11 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		return true
 	}
 
+	override getFontFaces(shape: TLArrowShape): TLFontFace[] {
+		if (!shape.props.text) return EMPTY_ARRAY
+		return [DefaultFontFaces[`tldraw_${shape.props.font}`].normal.normal]
+	}
+
 	override getDefaultProps(): TLArrowShape['props'] {
 		return {
 			dash: 'draw',
@@ -625,7 +629,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 					/>
 				</SVGContainer>
 				{showArrowLabel && (
-					<TextLabel
+					<PlainTextLabel
 						shapeId={shape.id}
 						classNamePrefix="tl-arrow"
 						type="arrow"
@@ -764,7 +768,6 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 
 	override toSvg(shape: TLArrowShape, ctx: SvgExportContext) {
 		ctx.addExportDef(getFillDefForExport(shape.props.fill))
-		if (shape.props.text) ctx.addExportDef(getFontDefForExport(shape.props.font))
 		const theme = getDefaultColorTheme(ctx)
 		const scaleFactor = 1 / shape.props.scale
 

commit 3e2ed74b5e86028fc8b858893821ce2ba1f64c3f
Author: alex <alex@dytry.ch>
Date:   Thu Apr 3 14:15:59 2025 +0100

    Geometry2d Improvements (#5754)
    
    This diff adds a number of `Geometry2d` improvements back-ported from my
    work on elbow arrows.
    
    1. Intersection helpers. We have hit tests, distance to, nearest point
    etc. on geometry, but no intersections. This diff adds support for
    `Geometry2d.intersectLineSegment` and `Geometry2d.intersectCircle`. We
    previously were using these downstream in kind of a hack way, but having
    them directly on the geometry and able to play nicer with groups etc. is
    very helpful.
    2. Transformation. `Geometry2d.transform` allows you to efficiently
    transform a geometry by some matrix. Where possible, we avoid
    transforming every single point and instead forward the methods to the
    original untransformed geometry. This also allows for some efficiency
    gains by e.g. caching geometries in page space. For now, I've only
    ported some really obvious / simple use-cases over to using this, but
    there are many parts of the code that could now be simplified by
    switching to transformed geometries.
    3. Filters. Almost all geometry methods do some sort of filtering - e.g.
    to ignore labels, etc. Sometimes this was hard-coded, sometimes method
    accepted an optional boolean `includeFilters` parameter. Now, all
    methods than can have filters applied accept a filters argument which
    determines which parts do/don't get included in the shape. New here (&
    motivating this change) is a new way of designating parts of a group as
    "internal" geometry - e.g. the lines within a geo shape that we might
    not want to partake in arrow binding.
    
    ### Change type
    
    - [x] `api`
    
    ### Release notes
    
    - It's now easier to work with `Geometry2d` objects, with methods for
    intersections, transforming geometries, and filtering.

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index b02b20f65..edc4f2545 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -25,6 +25,7 @@ import {
 	WeakCache,
 	arrowShapeMigrations,
 	arrowShapeProps,
+	debugFlags,
 	getDefaultColorTheme,
 	getPerfectDashProps,
 	lerp,
@@ -40,7 +41,6 @@ import {
 } from '@tldraw/editor'
 import React from 'react'
 import { updateArrowTerminal } from '../../bindings/arrow/ArrowBindingUtil'
-
 import { PlainTextLabel } from '../shared/PlainTextLabel'
 import { ShapeFill } from '../shared/ShapeFill'
 import { SvgTextLabel } from '../shared/SvgTextLabel'
@@ -157,7 +157,7 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 		let labelGeom
 		if (shape.props.text.trim()) {
 			const labelPosition = getArrowLabelPosition(this.editor, shape)
-			debugGeom.push(...labelPosition.debugGeom)
+			if (debugFlags.debugGeometry.get()) debugGeom.push(...labelPosition.debugGeom)
 			labelGeom = new Rectangle2d({
 				x: labelPosition.box.x,
 				y: labelPosition.box.y,

commit 629125a2e474effa3536411584aaac8f77657673
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Thu Apr 3 16:07:49 2025 +0100

    a11y: navigable shapes (#5761)
    
    As part of a [larger push](https://github.com/tldraw/tldraw/issues/5215)
    to add accessibility to our SDK, a big piece of that work is being able
    to navigate through our shapes in some kind of predictable fashion. This
    builds upon @Taha-Hassan-Git 's great work and knowledge in this area,
    thanks man. :tip-o-the-hat:
    
    Things that were tackled in this PR:
    - navigating shapes using the Tab key, when in the Select tool.
    - navigating shapes using Cmd/Ctrl+Arrow keys, when in the Select tool.
    - only allowing certain shapes to be navigated to. We ignore
    draw/highlighter/arrow/group/line. Groups need exploration and will be
    tackled later.
    - panning the camera to the selected shape, but avoiding doing so in a
    jarring way. We don't center the shape to avoid too much whiplashy-ness.
    
    An initial foray into this was relaying purely on DOM but it had a bunch
    of browser quirks which forced making this purely a programmatic control
    on our end. Things like ensuring culled shapes are still accessible even
    though they're not rendered was one of the issues but also tab order
    became unpredictable at times which steered me away from that direction.
    
    We coud have considered using something like rbush for some spatial
    indexing of the shapes. For the intents and purposes of this PR, it
    seemed like overkill at the moment. But we might cross that bridge down
    the line, we'll see.
    
    The reading-direction heuristics are a combination of dividing the pages
    into rows and then looking at distance and angles to see what is the
    spatially "next" shape to be read. It takes _all_ of the shapes and
    sorts them into a logical order so that nothing is missed/skipped when
    tabbing around.
    The directional-arrow heuristics don't divide things into rows and don't
    create a sorted set of shapes. Instead, they decide based on the current
    shape and direction which is the next spatially to go to, depending on
    distance+angle.
    
    There's a decent amount of nuance in this kind of navigation but it's
    not all covered in this PR, for separate PRs, we'll look at:
    - [x] adding a "skipping to content" button
    - [ ] question whether maybe directional navigation visits ‘canTabTo’
    shapes, maybe yes?
    - [ ] tackling what Enter/Escape should do when on the canvas shapes
    - [ ] how to deal with hierarchy / parent-child / frame / group shapes
    - [ ] and more
    
    
    
    https://github.com/user-attachments/assets/49b6b34e-2553-4047-846f-5d3383e1e3c6
    
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Test plan
    
    - [x] Unit tests
    - [x] End to end tests
    
    ### Release notes
    
    - a11y: navigable shapes using Tab and Cmd/Ctrl+Arrow

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index edc4f2545..c9581a2c1 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -87,6 +87,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override canSnap() {
 		return false
 	}
+	override canTabTo() {
+		return false
+	}
 	override hideResizeHandles() {
 		return true
 	}

commit 4ecb34d3434dbd9ad3119d4dfc66b7af4e598faf
Author: Mime Čuvalo <mimecuvalo@gmail.com>
Date:   Mon Apr 7 22:05:44 2025 +0100

    a11y: announce shapes as they're visited (#5773)
    
    Building off of https://github.com/tldraw/tldraw/pull/5634 and
    https://github.com/tldraw/tldraw/pull/5761 this is adding a11y live text
    to be read aloud when visiting a shape.
    
    We add an overridable method for shapes to customize this called
    `getAriaLiveText`.
    Furthermore, we lay the groundwork here to start letting media shapes
    have `altText`.
    Drive-by fix of `heart` being missing in `geo-styles` list.
    Also, drive-by fix of us calling our Image button "Asset" (what are we
    selling financial instruments here? :P) "Media" is a better word for
    this button, more human.
    
    Some of the i18n translation is funky. It's a shortcoming of our current
    system that we don't support interpolation :-/
    It sucks, and we'll revisit in the future.
    
    ### Change type
    
    - [ ] `bugfix`
    - [ ] `improvement`
    - [x] `feature`
    - [ ] `api`
    - [ ] `other`
    
    ### Release notes
    
    - a11y: announce shapes as they're visited
    
    ---------
    
    Co-authored-by: alex <alex@dytry.ch>

diff --git a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
index c9581a2c1..83bac677b 100644
--- a/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
+++ b/packages/tldraw/src/lib/shapes/arrow/ArrowShapeUtil.tsx
@@ -87,8 +87,9 @@ export class ArrowShapeUtil extends ShapeUtil<TLArrowShape> {
 	override canSnap() {
 		return false
 	}
-	override canTabTo() {
-		return false
+	override canTabTo(shape: TLArrowShape) {
+		const bindings = getArrowBindings(this.editor, shape)
+		return !!(bindings.start || bindings.end || shape.props.text)
 	}
 	override hideResizeHandles() {
 		return true

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    