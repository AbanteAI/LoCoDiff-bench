<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt: lib/segment/src/payload_storage/query_checker.rs - Grok 3</title>
    <link rel="stylesheet" href="../../../../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <h1>Prompt: lib/segment/src/payload_storage/query_checker.rs</h1>
        <p><a href="../../../cases/x-ai_grok-3-beta/qdrant_lib_segment_src_payload_storage_query_checker.rs.html">‚Üê Back to Case</a> | <a href="../../../index.html">Home</a></p>
    </header>
    <main>
        <section>
            <h2>Prompt Content</h2>
            <pre><code class="language-plaintext"># Instructions

You are being benchmarked. You will see the output of a git log command, and from that must infer the current state of a file. Think carefully, as you must output the exact state of the file to earn full marks.

**Important:** Your goal is to reproduce the file's content *exactly* as it exists at the final commit, even if the code appears broken, buggy, or contains obvious errors. Do **not** try to "fix" the code. Attempting to correct issues will result in a poor score, as this benchmark evaluates your ability to reproduce the precise state of the file based on its history.

# Required Response Format

Wrap the content of the file in triple backticks (```). Any text outside the final closing backticks will be ignored. End your response after outputting the closing backticks.

# Example Response

```python
#!/usr/bin/env python
print('Hello, world!')
```

# File History

> git log -p --cc --topo-order --reverse -- lib/segment/src/payload_storage/query_checker.rs

commit 60624be5c2d17a164bbaf7cddaac9c2839cbd839
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 29 12:43:30 2020 +0200

    query checker

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
new file mode 100644
index 000000000..8fa1298d7
--- /dev/null
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -0,0 +1,98 @@
+use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage, TheMap};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match};
+
+
+fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
+    match payload {
+        PayloadType::Keyword(payload_kw) => condition_match.keyword
+            .as_ref().map(|x| x == payload_kw).unwrap_or(false),
+        &PayloadType::Integer(payload_int) => condition_match.integer
+            .map(|x| x == payload_int).unwrap_or(false),
+        _ => false
+    }
+}
+
+fn match_range(
+    payload: &PayloadType,
+    num_range: &Range
+) -> bool {
+    let number: Option<f64> = match payload {
+        &PayloadType::Float(num) => Some(num),
+        &PayloadType::Integer(num) => Some(num as f64),
+        _ => None
+    };
+
+    match number {
+        Some(number) => num_range.lt.map_or(true, |x| number < x)
+            && num_range.gt.map_or(true, |x| number > x)
+            && num_range.lte.map_or(true, |x| number <= x)
+            && num_range.gte.map_or(true, |x| number >= x),
+        None => false
+    }
+}
+
+fn match_geo(
+    payload: &PayloadType,
+    geo_bounding_box: &GeoBoundingBox
+) -> bool {
+    return match payload {
+        PayloadType::Geo(geo_point) => {
+            (geo_bounding_box.top_left.lon < geo_point.lon) && (geo_point.lon < geo_bounding_box.bottom_right.lon)
+            && (geo_bounding_box.bottom_right.lat < geo_point.lat) && (geo_point.lat < geo_bounding_box.top_left.lat)
+        },
+        _ => false,
+    }
+}
+
+
+fn check_condition(payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
+    match condition {
+        Condition::Filter(filter) => check_filter(payload, filter),
+        Condition::Match (condition_match) => {
+            payload.get(&condition_match.key)
+                .map(|p| match_payload(p, condition_match))
+                .unwrap_or(false)
+        },
+        Condition::Range (range) => {
+            payload.get(&range.key)
+                .map(|p| match_range(p, range))
+                .unwrap_or(false)
+        },
+        Condition::GeoBoundingBox (geo_bounding_box) => {
+            payload.get(&geo_bounding_box.key)
+                .map(|p| match_geo(p, geo_bounding_box))
+                .unwrap_or(false)
+        }
+    }
+}
+
+fn check_filter(payload: &TheMap<PayloadKeyType, PayloadType>, filter: &Filter) -> bool {
+    return check_must(payload, &filter.must) && check_must_not(payload, &filter.must_not);
+}
+
+fn check_must(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
+    let check = |x| check_condition(payload, x);
+    match must {
+        None => true,
+        Some(conditions) => conditions.iter().all(check)
+    }
+}
+
+fn check_must_not(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
+    let check = |x| !check_condition(payload, x);
+    match must {
+        None => true,
+        Some(conditions) => conditions.iter().all(check)
+    }
+}
+
+impl<T> ConditionChecker for T
+    where T: PayloadStorage
+{
+    fn check(&self, point_id: usize, query: &Filter) -> bool {
+        let payload = self.payload(point_id);
+        let mut result = true;
+
+        return result;
+    }
+}
\ No newline at end of file

commit 5e4aa36b78f38278570135688e0415c2f3be2b9e
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 29 13:04:43 2020 +0200

    cargo fix

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 8fa1298d7..0ca5e536d 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -89,9 +89,9 @@ fn check_must_not(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<V
 impl<T> ConditionChecker for T
     where T: PayloadStorage
 {
-    fn check(&self, point_id: usize, query: &Filter) -> bool {
-        let payload = self.payload(point_id);
-        let mut result = true;
+    fn check(&self, point_id: usize, _query: &Filter) -> bool {
+        let _payload = self.payload(point_id);
+        let result = true;
 
         return result;
     }

commit 1af3b825cb28562d73ea4ffb43cbdbc9cb6ca36f
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jun 29 14:19:13 2020 +0200

    implement plain storage index

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 0ca5e536d..8d3bec451 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -89,10 +89,8 @@ fn check_must_not(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<V
 impl<T> ConditionChecker for T
     where T: PayloadStorage
 {
-    fn check(&self, point_id: usize, _query: &Filter) -> bool {
-        let _payload = self.payload(point_id);
-        let result = true;
-
-        return result;
+    fn check(&self, point_id: usize, query: &Filter) -> bool {
+        let payload = self.payload(point_id);
+        return check_filter(&payload, query);
     }
 }
\ No newline at end of file

commit 798c38c088dff7a0545b2b7a372a49a2578c98ea
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 30 14:32:33 2020 +0200

    add should clouse + test for condition checker

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 8d3bec451..19314d7ff 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -14,7 +14,7 @@ fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
 
 fn match_range(
     payload: &PayloadType,
-    num_range: &Range
+    num_range: &Range,
 ) -> bool {
     let number: Option<f64> = match payload {
         &PayloadType::Float(num) => Some(num),
@@ -33,32 +33,36 @@ fn match_range(
 
 fn match_geo(
     payload: &PayloadType,
-    geo_bounding_box: &GeoBoundingBox
+    geo_bounding_box: &GeoBoundingBox,
 ) -> bool {
     return match payload {
         PayloadType::Geo(geo_point) => {
+            // let max_lon = max(geo_bounding_box.top_left.lon, geo_bounding_box.bottom_right.lon);
+            // let min_lon = min(geo_bounding_box.top_left.lon, geo_bounding_box.bottom_right.lon);
+            // let max_lat = max(geo_bounding_box.top_left.lat, geo_bounding_box.bottom_right.lat);
+            // let min_lat = min(geo_bounding_box.top_left.lat, geo_bounding_box.bottom_right.lat);
             (geo_bounding_box.top_left.lon < geo_point.lon) && (geo_point.lon < geo_bounding_box.bottom_right.lon)
-            && (geo_bounding_box.bottom_right.lat < geo_point.lat) && (geo_point.lat < geo_bounding_box.top_left.lat)
-        },
+                && (geo_bounding_box.bottom_right.lat < geo_point.lat) && (geo_point.lat < geo_bounding_box.top_left.lat)
+        }
         _ => false,
-    }
+    };
 }
 
 
 fn check_condition(payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
     match condition {
         Condition::Filter(filter) => check_filter(payload, filter),
-        Condition::Match (condition_match) => {
+        Condition::Match(condition_match) => {
             payload.get(&condition_match.key)
                 .map(|p| match_payload(p, condition_match))
                 .unwrap_or(false)
-        },
-        Condition::Range (range) => {
+        }
+        Condition::Range(range) => {
             payload.get(&range.key)
                 .map(|p| match_range(p, range))
                 .unwrap_or(false)
-        },
-        Condition::GeoBoundingBox (geo_bounding_box) => {
+        }
+        Condition::GeoBoundingBox(geo_bounding_box) => {
             payload.get(&geo_bounding_box.key)
                 .map(|p| match_geo(p, geo_bounding_box))
                 .unwrap_or(false)
@@ -67,9 +71,20 @@ fn check_condition(payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Co
 }
 
 fn check_filter(payload: &TheMap<PayloadKeyType, PayloadType>, filter: &Filter) -> bool {
-    return check_must(payload, &filter.must) && check_must_not(payload, &filter.must_not);
+    return check_should(payload, &filter.should)
+        && check_must(payload, &filter.must)
+        && check_must_not(payload, &filter.must_not);
+}
+
+fn check_should(payload: &TheMap<PayloadKeyType, PayloadType>, should: &Option<Vec<Condition>>) -> bool {
+    let check = |x| check_condition(payload, x);
+    match should {
+        None => true,
+        Some(conditions) => conditions.iter().any(check)
+    }
 }
 
+
 fn check_must(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
     let check = |x| check_condition(payload, x);
     match must {
@@ -93,4 +108,131 @@ impl<T> ConditionChecker for T
         let payload = self.payload(point_id);
         return check_filter(&payload, query);
     }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::types::PayloadType;
+    use crate::types::GeoPoint;
+
+    #[test]
+    fn test_condition_checker() {
+        let payload: TheMap<PayloadKeyType, PayloadType> = [
+            ("location".to_owned(), PayloadType::Geo(GeoPoint { lon: 13.404954, lat: 52.520008 })),
+            ("price".to_owned(), PayloadType::Float(499.90)),
+            ("amount".to_owned(), PayloadType::Integer(10)),
+            ("rating".to_owned(), PayloadType::Integer(9)),
+            ("color".to_owned(), PayloadType::Keyword("red".to_owned())),
+            ("has_delivery".to_owned(), PayloadType::Integer(1)),
+        ].iter().cloned().collect();
+
+        let match_red = Condition::Match(Match {
+            key: "color".to_owned(),
+            keyword: Some("red".to_owned()),
+            integer: None,
+        });
+
+        let match_blue = Condition::Match(Match {
+            key: "color".to_owned(),
+            keyword: Some("blue".to_owned()),
+            integer: None,
+        });
+
+        let with_delivery = Condition::Match(Match {
+            key: "has_delivery".to_owned(),
+            keyword: None,
+            integer: Some(1),
+        });
+
+        let in_berlin = Condition::GeoBoundingBox(GeoBoundingBox {
+            key: "location".to_string(),
+            top_left: GeoPoint { lon: 13.08835, lat: 52.67551 },
+            bottom_right: GeoPoint { lon: 13.76116, lat: 52.33826 },
+        });
+
+        let in_moscow = Condition::GeoBoundingBox(GeoBoundingBox {
+            key: "location".to_string(),
+            top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
+            bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
+        });
+
+        let query = Filter {
+            should: None,
+            must: Some(vec![match_red.clone()]),
+            must_not: None,
+        };
+        assert!(check_filter(&payload, &query));
+
+        let query = Filter {
+            should: None,
+            must: Some(vec![match_blue.clone()]),
+            must_not: None,
+        };
+        assert!(!check_filter(&payload, &query));
+
+        let query = Filter {
+            should: None,
+            must: None,
+            must_not: Some(vec![match_blue.clone()]),
+        };
+        assert!(check_filter(&payload, &query));
+
+        let query = Filter {
+            should: None,
+            must: None,
+            must_not: Some(vec![match_red.clone()]),
+        };
+        assert!(!check_filter(&payload, &query));
+
+        let query = Filter {
+            should: Some(vec![match_red.clone(), match_blue.clone()]),
+            must: Some(vec![with_delivery.clone(), in_berlin.clone()]),
+            must_not: None,
+        };
+        assert!(check_filter(&payload, &query));
+
+        let query = Filter {
+            should: Some(vec![match_red.clone(), match_blue.clone()]),
+            must: Some(vec![with_delivery.clone(), in_moscow.clone()]),
+            must_not: None,
+        };
+        assert!(!check_filter(&payload, &query));
+
+        let query = Filter {
+            should: Some(vec![
+                Condition::Filter(Filter {
+                    should: None,
+                    must: Some(vec![match_red.clone(), in_moscow.clone()]),
+                    must_not: None,
+                }),
+                Condition::Filter(Filter {
+                    should: None,
+                    must: Some(vec![match_blue.clone(), in_berlin.clone()]),
+                    must_not: None,
+                }),
+            ]),
+            must: None,
+            must_not: None,
+        };
+        assert!(!check_filter(&payload, &query));
+
+        let query = Filter {
+            should: Some(vec![
+                Condition::Filter(Filter {
+                    should: None,
+                    must: Some(vec![match_blue.clone(), in_moscow.clone()]),
+                    must_not: None,
+                }),
+                Condition::Filter(Filter {
+                    should: None,
+                    must: Some(vec![match_red.clone(), in_berlin.clone()]),
+                    must_not: None,
+                }),
+            ]),
+            must: None,
+            must_not: None,
+        };
+        assert!(check_filter(&payload, &query));
+    }
 }
\ No newline at end of file

commit 7cb939d6e04b3666aafca15e9432e282b7a7ef95
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Tue Jun 30 22:03:39 2020 +0200

    store multiple values of payload

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 19314d7ff..d7d3437c2 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -4,10 +4,17 @@ use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBo
 
 fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
     match payload {
-        PayloadType::Keyword(payload_kw) => condition_match.keyword
-            .as_ref().map(|x| x == payload_kw).unwrap_or(false),
-        &PayloadType::Integer(payload_int) => condition_match.integer
-            .map(|x| x == payload_int).unwrap_or(false),
+        PayloadType::Keyword(payload_kws) => payload_kws
+            .iter()
+            .any(|payload_kw| condition_match.keyword
+                .as_ref()
+                .map(|x| x == payload_kw).unwrap_or(false)
+            ),
+        PayloadType::Integer(payload_ints) => payload_ints
+            .iter()
+            .cloned()
+            .any(|payload_int| condition_match.integer
+                .map(|x| x == payload_int).unwrap_or(false)),
         _ => false
     }
 }
@@ -16,18 +23,16 @@ fn match_range(
     payload: &PayloadType,
     num_range: &Range,
 ) -> bool {
-    let number: Option<f64> = match payload {
-        &PayloadType::Float(num) => Some(num),
-        &PayloadType::Integer(num) => Some(num as f64),
-        _ => None
-    };
-
-    match number {
-        Some(number) => num_range.lt.map_or(true, |x| number < x)
+    let condition =
+        |number| num_range.lt.map_or(true, |x| number < x)
             && num_range.gt.map_or(true, |x| number > x)
             && num_range.lte.map_or(true, |x| number <= x)
-            && num_range.gte.map_or(true, |x| number >= x),
-        None => false
+            && num_range.gte.map_or(true, |x| number >= x);
+
+    match payload {
+        PayloadType::Float(num) => num.iter().cloned().any(condition),
+        PayloadType::Integer(num) => num.iter().cloned().any(|x| condition(x as f64)),
+        _ => false
     }
 }
 
@@ -36,14 +41,12 @@ fn match_geo(
     geo_bounding_box: &GeoBoundingBox,
 ) -> bool {
     return match payload {
-        PayloadType::Geo(geo_point) => {
-            // let max_lon = max(geo_bounding_box.top_left.lon, geo_bounding_box.bottom_right.lon);
-            // let min_lon = min(geo_bounding_box.top_left.lon, geo_bounding_box.bottom_right.lon);
-            // let max_lat = max(geo_bounding_box.top_left.lat, geo_bounding_box.bottom_right.lat);
-            // let min_lat = min(geo_bounding_box.top_left.lat, geo_bounding_box.bottom_right.lat);
-            (geo_bounding_box.top_left.lon < geo_point.lon) && (geo_point.lon < geo_bounding_box.bottom_right.lon)
-                && (geo_bounding_box.bottom_right.lat < geo_point.lat) && (geo_point.lat < geo_bounding_box.top_left.lat)
-        }
+        PayloadType::Geo(geo_points) => geo_points
+            .iter()
+            .any(|geo_point| (geo_bounding_box.top_left.lon < geo_point.lon)
+                && (geo_point.lon < geo_bounding_box.bottom_right.lon)
+                && (geo_bounding_box.bottom_right.lat < geo_point.lat)
+                && (geo_point.lat < geo_bounding_box.top_left.lat)),
         _ => false,
     };
 }
@@ -119,12 +122,12 @@ mod tests {
     #[test]
     fn test_condition_checker() {
         let payload: TheMap<PayloadKeyType, PayloadType> = [
-            ("location".to_owned(), PayloadType::Geo(GeoPoint { lon: 13.404954, lat: 52.520008 })),
-            ("price".to_owned(), PayloadType::Float(499.90)),
-            ("amount".to_owned(), PayloadType::Integer(10)),
-            ("rating".to_owned(), PayloadType::Integer(9)),
-            ("color".to_owned(), PayloadType::Keyword("red".to_owned())),
-            ("has_delivery".to_owned(), PayloadType::Integer(1)),
+            ("location".to_owned(), PayloadType::Geo(vec![GeoPoint { lon: 13.404954, lat: 52.520008 }])),
+            ("price".to_owned(), PayloadType::Float(vec![499.90])),
+            ("amount".to_owned(), PayloadType::Integer(vec![10])),
+            ("rating".to_owned(), PayloadType::Integer(vec![3, 7, 9, 9])),
+            ("color".to_owned(), PayloadType::Keyword(vec!["red".to_owned()])),
+            ("has_delivery".to_owned(), PayloadType::Integer(vec![1])),
         ].iter().cloned().collect();
 
         let match_red = Condition::Match(Match {
@@ -157,6 +160,14 @@ mod tests {
             bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
         });
 
+        let with_bad_rating = Condition::Range(Range{
+            key: "rating".to_string(),
+            lt: None,
+            gt: None,
+            gte: None,
+            lte: Some(5.)
+        });
+
         let query = Filter {
             should: None,
             must: Some(vec![match_red.clone()]),
@@ -234,5 +245,13 @@ mod tests {
             must_not: None,
         };
         assert!(check_filter(&payload, &query));
+
+
+        let query = Filter {
+            should: None,
+            must: None,
+            must_not: Some(vec![with_bad_rating.clone()]),
+        };
+        assert!(!check_filter(&payload, &query));
     }
 }
\ No newline at end of file

commit a5bb6487686a115aa1934fd4f02634feb79a5519
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Jul 27 14:17:32 2020 +0200

    implement points retrieval + refactor updater

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index d7d3437c2..49000c705 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,5 +1,5 @@
-use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage, TheMap};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match};
+use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap};
 
 
 fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {

commit 358f2a6609cc29c0c0870997764b9b6485ad96c8
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sat Aug 15 21:57:50 2020 +0200

    add id filter

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 49000c705..0067c1229 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,5 +1,6 @@
 use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, PointIdType};
+use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 
 
 fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
@@ -52,35 +53,38 @@ fn match_geo(
 }
 
 
-fn check_condition(payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
+fn check_condition(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
     match condition {
-        Condition::Filter(filter) => check_filter(payload, filter),
+        Condition::Filter(filter) => check_filter(point_id, payload, filter),
         Condition::Match(condition_match) => {
             payload.get(&condition_match.key)
                 .map(|p| match_payload(p, condition_match))
                 .unwrap_or(false)
-        }
+        },
         Condition::Range(range) => {
             payload.get(&range.key)
                 .map(|p| match_range(p, range))
                 .unwrap_or(false)
-        }
+        },
         Condition::GeoBoundingBox(geo_bounding_box) => {
             payload.get(&geo_bounding_box.key)
                 .map(|p| match_geo(p, geo_bounding_box))
                 .unwrap_or(false)
+        },
+        Condition::HasId(ids) => {
+            ids.contains(&point_id)
         }
     }
 }
 
-fn check_filter(payload: &TheMap<PayloadKeyType, PayloadType>, filter: &Filter) -> bool {
-    return check_should(payload, &filter.should)
-        && check_must(payload, &filter.must)
-        && check_must_not(payload, &filter.must_not);
+fn check_filter(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, filter: &Filter) -> bool {
+    return check_should(point_id, payload, &filter.should)
+        && check_must(point_id, payload, &filter.must)
+        && check_must_not(point_id, payload, &filter.must_not);
 }
 
-fn check_should(payload: &TheMap<PayloadKeyType, PayloadType>, should: &Option<Vec<Condition>>) -> bool {
-    let check = |x| check_condition(payload, x);
+fn check_should(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, should: &Option<Vec<Condition>>) -> bool {
+    let check = |x| check_condition(point_id, payload, x);
     match should {
         None => true,
         Some(conditions) => conditions.iter().any(check)
@@ -88,28 +92,28 @@ fn check_should(payload: &TheMap<PayloadKeyType, PayloadType>, should: &Option<V
 }
 
 
-fn check_must(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
-    let check = |x| check_condition(payload, x);
+fn check_must(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
+    let check = |x| check_condition(point_id, payload, x);
     match must {
         None => true,
         Some(conditions) => conditions.iter().all(check)
     }
 }
 
-fn check_must_not(payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
-    let check = |x| !check_condition(payload, x);
+fn check_must_not(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
+    let check = |x| !check_condition(point_id, payload, x);
     match must {
         None => true,
         Some(conditions) => conditions.iter().all(check)
     }
 }
 
-impl<T> ConditionChecker for T
-    where T: PayloadStorage
+impl ConditionChecker for SimplePayloadStorage
 {
-    fn check(&self, point_id: usize, query: &Filter) -> bool {
+    fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
+        let external_id = self.point_external_id(point_id).unwrap();
         let payload = self.payload(point_id);
-        return check_filter(&payload, query);
+        return check_filter(external_id, &payload, query);
     }
 }
 
@@ -118,6 +122,7 @@ mod tests {
     use super::*;
     use crate::types::PayloadType;
     use crate::types::GeoPoint;
+    use std::collections::HashSet;
 
     #[test]
     fn test_condition_checker() {
@@ -173,42 +178,42 @@ mod tests {
             must: Some(vec![match_red.clone()]),
             must_not: None,
         };
-        assert!(check_filter(&payload, &query));
+        assert!(check_filter(0, &payload, &query));
 
         let query = Filter {
             should: None,
             must: Some(vec![match_blue.clone()]),
             must_not: None,
         };
-        assert!(!check_filter(&payload, &query));
+        assert!(!check_filter(0, &payload, &query));
 
         let query = Filter {
             should: None,
             must: None,
             must_not: Some(vec![match_blue.clone()]),
         };
-        assert!(check_filter(&payload, &query));
+        assert!(check_filter(0, &payload, &query));
 
         let query = Filter {
             should: None,
             must: None,
             must_not: Some(vec![match_red.clone()]),
         };
-        assert!(!check_filter(&payload, &query));
+        assert!(!check_filter(0, &payload, &query));
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
             must: Some(vec![with_delivery.clone(), in_berlin.clone()]),
             must_not: None,
         };
-        assert!(check_filter(&payload, &query));
+        assert!(check_filter(0, &payload, &query));
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
             must: Some(vec![with_delivery.clone(), in_moscow.clone()]),
             must_not: None,
         };
-        assert!(!check_filter(&payload, &query));
+        assert!(!check_filter(0, &payload, &query));
 
         let query = Filter {
             should: Some(vec![
@@ -226,7 +231,7 @@ mod tests {
             must: None,
             must_not: None,
         };
-        assert!(!check_filter(&payload, &query));
+        assert!(!check_filter(0, &payload, &query));
 
         let query = Filter {
             should: Some(vec![
@@ -244,7 +249,7 @@ mod tests {
             must: None,
             must_not: None,
         };
-        assert!(check_filter(&payload, &query));
+        assert!(check_filter(0, &payload, &query));
 
 
         let query = Filter {
@@ -252,6 +257,36 @@ mod tests {
             must: None,
             must_not: Some(vec![with_bad_rating.clone()]),
         };
-        assert!(!check_filter(&payload, &query));
+        assert!(!check_filter(0, &payload, &query));
+
+
+        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+
+
+        let query = Filter {
+            should: None,
+            must: None,
+            must_not: Some(vec![Condition::HasId(ids)]),
+        };
+        assert!(!check_filter(2, &payload, &query));
+
+        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+
+
+        let query = Filter {
+            should: None,
+            must: None,
+            must_not: Some(vec![Condition::HasId(ids)]),
+        };
+        assert!(check_filter(10, &payload, &query));
+
+        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+
+        let query = Filter {
+            should: None,
+            must: Some(vec![Condition::HasId(ids)]),
+            must_not: None,
+        };
+        assert!(check_filter(2, &payload, &query));
     }
 }
\ No newline at end of file

commit 57dcaad4994578fdbc886642604ec53b4edf24d8
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Mon Aug 31 23:23:29 2020 +0200

    refactor segment optimizer

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 0067c1229..88e77ccf3 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -60,17 +60,17 @@ fn check_condition(point_id: PointIdType, payload: &TheMap<PayloadKeyType, Paylo
             payload.get(&condition_match.key)
                 .map(|p| match_payload(p, condition_match))
                 .unwrap_or(false)
-        },
+        }
         Condition::Range(range) => {
             payload.get(&range.key)
                 .map(|p| match_range(p, range))
                 .unwrap_or(false)
-        },
+        }
         Condition::GeoBoundingBox(geo_bounding_box) => {
             payload.get(&geo_bounding_box.key)
                 .map(|p| match_geo(p, geo_bounding_box))
                 .unwrap_or(false)
-        },
+        }
         Condition::HasId(ids) => {
             ids.contains(&point_id)
         }
@@ -111,7 +111,10 @@ fn check_must_not(point_id: PointIdType, payload: &TheMap<PayloadKeyType, Payloa
 impl ConditionChecker for SimplePayloadStorage
 {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let external_id = self.point_external_id(point_id).unwrap();
+        let external_id = match self.point_external_id(point_id) {
+            None => return false,
+            Some(id) => id,
+        };
         let payload = self.payload(point_id);
         return check_filter(external_id, &payload, query);
     }
@@ -165,12 +168,12 @@ mod tests {
             bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
         });
 
-        let with_bad_rating = Condition::Range(Range{
+        let with_bad_rating = Condition::Range(Range {
             key: "rating".to_string(),
             lt: None,
             gt: None,
             gte: None,
-            lte: Some(5.)
+            lte: Some(5.),
         });
 
         let query = Filter {
@@ -260,7 +263,7 @@ mod tests {
         assert!(!check_filter(0, &payload, &query));
 
 
-        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
 
         let query = Filter {
@@ -270,7 +273,7 @@ mod tests {
         };
         assert!(!check_filter(2, &payload, &query));
 
-        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
 
         let query = Filter {
@@ -280,7 +283,7 @@ mod tests {
         };
         assert!(check_filter(10, &payload, &query));
 
-        let ids: HashSet<_> = vec![1,2,3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
         let query = Filter {
             should: None,

commit e51d8bfec50751e7cf3f62268ddc532fc750ec2a
Author: Andrey Vasnetsov <vasnetsov93@gmail.com>
Date:   Sun Sep 20 20:59:58 2020 +0200

    WIP: persistace

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 88e77ccf3..636da6a4c 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,6 +1,9 @@
-use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};
+use crate::payload_storage::payload_storage::{ConditionChecker};
 use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, PointIdType};
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
+use std::sync::Arc;
+use atomic_refcell::AtomicRefCell;
+use crate::id_mapper::id_mapper::IdMapper;
 
 
 fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
@@ -108,15 +111,36 @@ fn check_must_not(point_id: PointIdType, payload: &TheMap<PayloadKeyType, Payloa
     }
 }
 
-impl ConditionChecker for SimplePayloadStorage
+
+pub struct SimpleConditionChecker {
+    payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
+    id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+}
+
+impl SimpleConditionChecker {
+    pub fn new(payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
+               id_mapper: Arc<AtomicRefCell<dyn IdMapper>>) -> Self {
+        SimpleConditionChecker {
+            payload_storage,
+            id_mapper,
+        }
+    }
+}
+
+
+impl ConditionChecker for SimpleConditionChecker
 {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let external_id = match self.point_external_id(point_id) {
+        let external_id = match self.id_mapper.borrow().external_id(point_id) {
             None => return false,
             Some(id) => id,
         };
-        let payload = self.payload(point_id);
-        return check_filter(external_id, &payload, query);
+        let payload_storage_guard = self.payload_storage.borrow();
+
+        return match payload_storage_guard.payload_ptr(point_id) {
+            None => check_filter(external_id, &TheMap::new(), query),
+            Some(x) => check_filter(external_id, x, query),
+        };
     }
 }
 

commit 5c2afdc5b9977504c41454af26a983720af7c7f7
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Jan 24 17:16:06 2021 +0100

    geo-radius + update wiki

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 636da6a4c..92c3ab0f3 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,9 +1,11 @@
 use crate::payload_storage::payload_storage::{ConditionChecker};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, PointIdType};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, PointIdType, GeoRadius};
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use crate::id_mapper::id_mapper::IdMapper;
+use geo::Point;
+use geo::algorithm::haversine_distance::HaversineDistance;
 
 
 fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
@@ -55,6 +57,28 @@ fn match_geo(
     };
 }
 
+fn match_geo_radius(
+    payload: &PayloadType,
+    geo_radius_query: &GeoRadius,
+) -> bool {
+    return match payload {
+        PayloadType::Geo(geo_points) => {
+            let query_center = Point::new(
+                geo_radius_query.center.lon,
+                geo_radius_query.center.lat);
+
+            geo_points
+                .iter()
+                .any(|geo_point|
+                    query_center.haversine_distance(
+                        &Point::new(geo_point.lon, geo_point.lat)
+                    ) < geo_radius_query.radius
+                )
+        },
+        _ => false,
+    };
+}
+
 
 fn check_condition(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
     match condition {
@@ -74,6 +98,11 @@ fn check_condition(point_id: PointIdType, payload: &TheMap<PayloadKeyType, Paylo
                 .map(|p| match_geo(p, geo_bounding_box))
                 .unwrap_or(false)
         }
+        Condition::GeoRadius(geo_radius) => {
+            payload.get(&geo_radius.key)
+                .map(|p| match_geo_radius(p, geo_radius))
+                .unwrap_or(false)
+        }
         Condition::HasId(ids) => {
             ids.contains(&point_id)
         }
@@ -151,6 +180,28 @@ mod tests {
     use crate::types::GeoPoint;
     use std::collections::HashSet;
 
+    #[test]
+    fn test_geo_matching() {
+        let berlin_and_moscow = PayloadType::Geo(vec![
+            GeoPoint{lat: 52.52197645, lon: 13.413637435864272 },
+            GeoPoint{lat: 55.7536283, lon: 37.62137960067377 }
+        ]);
+        let near_berlin_query = GeoRadius {
+            key: "test".to_string(),
+            center: GeoPoint{lat: 52.511, lon: 13.423637 },
+            radius: 2000.0
+        };
+        let miss_geo_query = GeoRadius {
+            key: "test".to_string(),
+            center: GeoPoint{lat: 52.511, lon: 20.423637 },
+            radius: 2000.0
+        };
+
+        assert!(match_geo_radius(&berlin_and_moscow, &near_berlin_query));
+        assert!(!match_geo_radius(&berlin_and_moscow, &miss_geo_query));
+    }
+
+
     #[test]
     fn test_condition_checker() {
         let payload: TheMap<PayloadKeyType, PayloadType> = [

commit 5a2985c6f7b8aaab038081d649dd394947396d21
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Nov 3 23:37:46 2020 +0100

    refactor condition checking for better column storage support

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 92c3ab0f3..efbef7825 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,5 +1,5 @@
 use crate::payload_storage::payload_storage::{ConditionChecker};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, PointIdType, GeoRadius};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, GeoRadius};
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
@@ -74,49 +74,30 @@ fn match_geo_radius(
                         &Point::new(geo_point.lon, geo_point.lat)
                     ) < geo_radius_query.radius
                 )
-        },
+        }
         _ => false,
     };
 }
 
 
-fn check_condition(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, condition: &Condition) -> bool {
+fn check_condition<F>(checker: &F, condition: &Condition) -> bool
+    where F: Fn(&Condition) -> bool {
     match condition {
-        Condition::Filter(filter) => check_filter(point_id, payload, filter),
-        Condition::Match(condition_match) => {
-            payload.get(&condition_match.key)
-                .map(|p| match_payload(p, condition_match))
-                .unwrap_or(false)
-        }
-        Condition::Range(range) => {
-            payload.get(&range.key)
-                .map(|p| match_range(p, range))
-                .unwrap_or(false)
-        }
-        Condition::GeoBoundingBox(geo_bounding_box) => {
-            payload.get(&geo_bounding_box.key)
-                .map(|p| match_geo(p, geo_bounding_box))
-                .unwrap_or(false)
-        }
-        Condition::GeoRadius(geo_radius) => {
-            payload.get(&geo_radius.key)
-                .map(|p| match_geo_radius(p, geo_radius))
-                .unwrap_or(false)
-        }
-        Condition::HasId(ids) => {
-            ids.contains(&point_id)
-        }
+        Condition::Filter(filter) => check_filter(checker, filter),
+        _ => checker(condition)
     }
 }
 
-fn check_filter(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, filter: &Filter) -> bool {
-    return check_should(point_id, payload, &filter.should)
-        && check_must(point_id, payload, &filter.must)
-        && check_must_not(point_id, payload, &filter.must_not);
+fn check_filter<F>(checker: &F, filter: &Filter) -> bool
+    where F: Fn(&Condition) -> bool {
+    return check_should(checker, &filter.should)
+        && check_must(checker, &filter.must)
+        && check_must_not(checker, &filter.must_not);
 }
 
-fn check_should(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, should: &Option<Vec<Condition>>) -> bool {
-    let check = |x| check_condition(point_id, payload, x);
+fn check_should<F>(checker: &F, should: &Option<Vec<Condition>>) -> bool
+    where F: Fn(&Condition) -> bool {
+    let check = |x| check_condition(checker, x);
     match should {
         None => true,
         Some(conditions) => conditions.iter().any(check)
@@ -124,16 +105,18 @@ fn check_should(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadT
 }
 
 
-fn check_must(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
-    let check = |x| check_condition(point_id, payload, x);
+fn check_must<F>(checker: &F, must: &Option<Vec<Condition>>) -> bool
+    where F: Fn(&Condition) -> bool {
+    let check = |x| check_condition(checker, x);
     match must {
         None => true,
         Some(conditions) => conditions.iter().all(check)
     }
 }
 
-fn check_must_not(point_id: PointIdType, payload: &TheMap<PayloadKeyType, PayloadType>, must: &Option<Vec<Condition>>) -> bool {
-    let check = |x| !check_condition(point_id, payload, x);
+fn check_must_not<F>(checker: &F, must: &Option<Vec<Condition>>) -> bool
+    where F: Fn(&Condition) -> bool {
+    let check = |x| !check_condition(checker, x);
     match must {
         None => true,
         Some(conditions) => conditions.iter().all(check)
@@ -156,20 +139,56 @@ impl SimpleConditionChecker {
     }
 }
 
+// Uncomment when stabilized
+// const EMPTY_PAYLOAD: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
 
 impl ConditionChecker for SimpleConditionChecker
 {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let external_id = match self.id_mapper.borrow().external_id(point_id) {
-            None => return false,
-            Some(id) => id,
-        };
+        let empty_map: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
+
         let payload_storage_guard = self.payload_storage.borrow();
+        let payload_ptr = payload_storage_guard.payload_ptr(point_id);
 
-        return match payload_storage_guard.payload_ptr(point_id) {
-            None => check_filter(external_id, &TheMap::new(), query),
-            Some(x) => check_filter(external_id, x, query),
+        let payload = match payload_ptr {
+            None => &empty_map,
+            Some(x) => x
         };
+
+        let checker = |condition: &Condition| {
+            match condition {
+                Condition::Match(condition_match) => {
+                    payload.get(&condition_match.key)
+                        .map(|p| match_payload(p, condition_match))
+                        .unwrap_or(false)
+                }
+                Condition::Range(range) => {
+                    payload.get(&range.key)
+                        .map(|p| match_range(p, range))
+                        .unwrap_or(false)
+                }
+                Condition::GeoBoundingBox(geo_bounding_box) => {
+                    payload.get(&geo_bounding_box.key)
+                        .map(|p| match_geo(p, geo_bounding_box))
+                        .unwrap_or(false)
+                }
+                Condition::GeoRadius(geo_radius) => {
+                    payload.get(&geo_radius.key)
+                        .map(|p| match_geo_radius(p, geo_radius))
+                        .unwrap_or(false)
+                }
+                Condition::HasId(ids) => {
+                    let external_id = match self.id_mapper.borrow().external_id(point_id) {
+                        None => return false,
+                        Some(id) => id,
+                    };
+                    ids.contains(&external_id)
+                }
+                Condition::Filter(_) => panic!("Unexpected branching!")
+            }
+        };
+
+        check_filter(&checker, query)
     }
 }
 
@@ -179,22 +198,25 @@ mod tests {
     use crate::types::PayloadType;
     use crate::types::GeoPoint;
     use std::collections::HashSet;
+    use tempdir::TempDir;
+    use crate::payload_storage::payload_storage::PayloadStorage;
+    use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
 
     #[test]
     fn test_geo_matching() {
         let berlin_and_moscow = PayloadType::Geo(vec![
-            GeoPoint{lat: 52.52197645, lon: 13.413637435864272 },
-            GeoPoint{lat: 55.7536283, lon: 37.62137960067377 }
+            GeoPoint { lat: 52.52197645, lon: 13.413637435864272 },
+            GeoPoint { lat: 55.7536283, lon: 37.62137960067377 }
         ]);
         let near_berlin_query = GeoRadius {
             key: "test".to_string(),
-            center: GeoPoint{lat: 52.511, lon: 13.423637 },
-            radius: 2000.0
+            center: GeoPoint { lat: 52.511, lon: 13.423637 },
+            radius: 2000.0,
         };
         let miss_geo_query = GeoRadius {
             key: "test".to_string(),
-            center: GeoPoint{lat: 52.511, lon: 20.423637 },
-            radius: 2000.0
+            center: GeoPoint { lat: 52.511, lon: 20.423637 },
+            radius: 2000.0,
         };
 
         assert!(match_geo_radius(&berlin_and_moscow, &near_berlin_query));
@@ -204,6 +226,9 @@ mod tests {
 
     #[test]
     fn test_condition_checker() {
+        let dir = TempDir::new("payload_dir").unwrap();
+        let dir_id_mapper = TempDir::new("id_mapper_dir").unwrap();
+
         let payload: TheMap<PayloadKeyType, PayloadType> = [
             ("location".to_owned(), PayloadType::Geo(vec![GeoPoint { lon: 13.404954, lat: 52.520008 }])),
             ("price".to_owned(), PayloadType::Float(vec![499.90])),
@@ -213,6 +238,20 @@ mod tests {
             ("has_delivery".to_owned(), PayloadType::Integer(vec![1])),
         ].iter().cloned().collect();
 
+        let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
+        let mut id_mapper = SimpleIdMapper::open(dir_id_mapper.path()).unwrap();
+
+        id_mapper.set_link(0, 0).unwrap();
+        id_mapper.set_link(1, 1).unwrap();
+        id_mapper.set_link(2, 2).unwrap();
+        id_mapper.set_link(10, 10).unwrap();
+        payload_storage.assign_all(0, payload).unwrap();
+
+        let payload_checker = SimpleConditionChecker::new(
+            Arc::new(AtomicRefCell::new(payload_storage)),
+            Arc::new(AtomicRefCell::new(id_mapper)),
+        );
+
         let match_red = Condition::Match(Match {
             key: "color".to_owned(),
             keyword: Some("red".to_owned()),
@@ -256,42 +295,42 @@ mod tests {
             must: Some(vec![match_red.clone()]),
             must_not: None,
         };
-        assert!(check_filter(0, &payload, &query));
+        assert!(payload_checker.check(0, &query));
 
         let query = Filter {
             should: None,
             must: Some(vec![match_blue.clone()]),
             must_not: None,
         };
-        assert!(!check_filter(0, &payload, &query));
+        assert!(!payload_checker.check(0, &query));
 
         let query = Filter {
             should: None,
             must: None,
             must_not: Some(vec![match_blue.clone()]),
         };
-        assert!(check_filter(0, &payload, &query));
+        assert!(payload_checker.check(0, &query));
 
         let query = Filter {
             should: None,
             must: None,
             must_not: Some(vec![match_red.clone()]),
         };
-        assert!(!check_filter(0, &payload, &query));
+        assert!(!payload_checker.check(0, &query));
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
             must: Some(vec![with_delivery.clone(), in_berlin.clone()]),
             must_not: None,
         };
-        assert!(check_filter(0, &payload, &query));
+        assert!(payload_checker.check(0, &query));
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
             must: Some(vec![with_delivery.clone(), in_moscow.clone()]),
             must_not: None,
         };
-        assert!(!check_filter(0, &payload, &query));
+        assert!(!payload_checker.check(0, &query));
 
         let query = Filter {
             should: Some(vec![
@@ -309,7 +348,7 @@ mod tests {
             must: None,
             must_not: None,
         };
-        assert!(!check_filter(0, &payload, &query));
+        assert!(!payload_checker.check(0, &query));
 
         let query = Filter {
             should: Some(vec![
@@ -327,7 +366,7 @@ mod tests {
             must: None,
             must_not: None,
         };
-        assert!(check_filter(0, &payload, &query));
+        assert!(payload_checker.check(0, &query));
 
 
         let query = Filter {
@@ -335,7 +374,7 @@ mod tests {
             must: None,
             must_not: Some(vec![with_bad_rating.clone()]),
         };
-        assert!(!check_filter(0, &payload, &query));
+        assert!(!payload_checker.check(0, &query));
 
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
@@ -346,7 +385,7 @@ mod tests {
             must: None,
             must_not: Some(vec![Condition::HasId(ids)]),
         };
-        assert!(!check_filter(2, &payload, &query));
+        assert!(!payload_checker.check(2, &query));
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
@@ -356,7 +395,7 @@ mod tests {
             must: None,
             must_not: Some(vec![Condition::HasId(ids)]),
         };
-        assert!(check_filter(10, &payload, &query));
+        assert!(payload_checker.check(10, &query));
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
@@ -365,6 +404,6 @@ mod tests {
             must: Some(vec![Condition::HasId(ids)]),
             must_not: None,
         };
-        assert!(check_filter(2, &payload, &query));
+        assert!(payload_checker.check(2, &query));
     }
 }
\ No newline at end of file

commit fe44c4e00eefa60bbb11e49beab5c6fc584314b8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 2 19:06:10 2021 +0100

    WIP: FieldCondition

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index efbef7825..390a1de31 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,83 +1,10 @@
 use crate::payload_storage::payload_storage::{ConditionChecker};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, GeoBoundingBox, Range, Match, TheMap, PointOffsetType, GeoRadius};
+use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, TheMap, PointOffsetType};
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use crate::id_mapper::id_mapper::IdMapper;
-use geo::Point;
-use geo::algorithm::haversine_distance::HaversineDistance;
-
-
-fn match_payload(payload: &PayloadType, condition_match: &Match) -> bool {
-    match payload {
-        PayloadType::Keyword(payload_kws) => payload_kws
-            .iter()
-            .any(|payload_kw| condition_match.keyword
-                .as_ref()
-                .map(|x| x == payload_kw).unwrap_or(false)
-            ),
-        PayloadType::Integer(payload_ints) => payload_ints
-            .iter()
-            .cloned()
-            .any(|payload_int| condition_match.integer
-                .map(|x| x == payload_int).unwrap_or(false)),
-        _ => false
-    }
-}
-
-fn match_range(
-    payload: &PayloadType,
-    num_range: &Range,
-) -> bool {
-    let condition =
-        |number| num_range.lt.map_or(true, |x| number < x)
-            && num_range.gt.map_or(true, |x| number > x)
-            && num_range.lte.map_or(true, |x| number <= x)
-            && num_range.gte.map_or(true, |x| number >= x);
-
-    match payload {
-        PayloadType::Float(num) => num.iter().cloned().any(condition),
-        PayloadType::Integer(num) => num.iter().cloned().any(|x| condition(x as f64)),
-        _ => false
-    }
-}
-
-fn match_geo(
-    payload: &PayloadType,
-    geo_bounding_box: &GeoBoundingBox,
-) -> bool {
-    return match payload {
-        PayloadType::Geo(geo_points) => geo_points
-            .iter()
-            .any(|geo_point| (geo_bounding_box.top_left.lon < geo_point.lon)
-                && (geo_point.lon < geo_bounding_box.bottom_right.lon)
-                && (geo_bounding_box.bottom_right.lat < geo_point.lat)
-                && (geo_point.lat < geo_bounding_box.top_left.lat)),
-        _ => false,
-    };
-}
-
-fn match_geo_radius(
-    payload: &PayloadType,
-    geo_radius_query: &GeoRadius,
-) -> bool {
-    return match payload {
-        PayloadType::Geo(geo_points) => {
-            let query_center = Point::new(
-                geo_radius_query.center.lon,
-                geo_radius_query.center.lat);
-
-            geo_points
-                .iter()
-                .any(|geo_point|
-                    query_center.haversine_distance(
-                        &Point::new(geo_point.lon, geo_point.lat)
-                    ) < geo_radius_query.radius
-                )
-        }
-        _ => false,
-    };
-}
+use crate::payload_storage::condition_checker::{match_payload, match_range, match_geo_radius, match_geo};
 
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
@@ -157,25 +84,16 @@ impl ConditionChecker for SimpleConditionChecker
 
         let checker = |condition: &Condition| {
             match condition {
-                Condition::Match(condition_match) => {
-                    payload.get(&condition_match.key)
-                        .map(|p| match_payload(p, condition_match))
-                        .unwrap_or(false)
-                }
-                Condition::Range(range) => {
-                    payload.get(&range.key)
-                        .map(|p| match_range(p, range))
-                        .unwrap_or(false)
-                }
-                Condition::GeoBoundingBox(geo_bounding_box) => {
-                    payload.get(&geo_bounding_box.key)
-                        .map(|p| match_geo(p, geo_bounding_box))
-                        .unwrap_or(false)
-                }
-                Condition::GeoRadius(geo_radius) => {
-                    payload.get(&geo_radius.key)
-                        .map(|p| match_geo_radius(p, geo_radius))
-                        .unwrap_or(false)
+                Condition::Field(field_condition) => {
+                    payload.get(&field_condition.key).map(|p| {
+                        let mut res = false;
+                        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+                        res = res || field_condition.r#match.as_ref().map(|condition| match_payload(p, condition)).unwrap_or(false);
+                        res = res || field_condition.range.as_ref().map(|condition| match_range(p, condition)).unwrap_or(false);
+                        res = res || field_condition.geo_radius.as_ref().map(|condition| match_geo_radius(p, condition)).unwrap_or(false);
+                        res = res || field_condition.geo_bounding_box.as_ref().map(|condition| match_geo(p, condition)).unwrap_or(false);
+                        res
+                    }).unwrap_or(false)
                 }
                 Condition::HasId(ids) => {
                     let external_id = match self.id_mapper.borrow().external_id(point_id) {
@@ -195,35 +113,13 @@ impl ConditionChecker for SimpleConditionChecker
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::types::PayloadType;
+    use crate::types::{PayloadType, FieldCondition, Match, GeoBoundingBox, Range};
     use crate::types::GeoPoint;
     use std::collections::HashSet;
     use tempdir::TempDir;
     use crate::payload_storage::payload_storage::PayloadStorage;
     use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
 
-    #[test]
-    fn test_geo_matching() {
-        let berlin_and_moscow = PayloadType::Geo(vec![
-            GeoPoint { lat: 52.52197645, lon: 13.413637435864272 },
-            GeoPoint { lat: 55.7536283, lon: 37.62137960067377 }
-        ]);
-        let near_berlin_query = GeoRadius {
-            key: "test".to_string(),
-            center: GeoPoint { lat: 52.511, lon: 13.423637 },
-            radius: 2000.0,
-        };
-        let miss_geo_query = GeoRadius {
-            key: "test".to_string(),
-            center: GeoPoint { lat: 52.511, lon: 20.423637 },
-            radius: 2000.0,
-        };
-
-        assert!(match_geo_radius(&berlin_and_moscow, &near_berlin_query));
-        assert!(!match_geo_radius(&berlin_and_moscow, &miss_geo_query));
-    }
-
-
     #[test]
     fn test_condition_checker() {
         let dir = TempDir::new("payload_dir").unwrap();
@@ -252,42 +148,83 @@ mod tests {
             Arc::new(AtomicRefCell::new(id_mapper)),
         );
 
-        let match_red = Condition::Match(Match {
-            key: "color".to_owned(),
-            keyword: Some("red".to_owned()),
-            integer: None,
+        let match_red = Condition::Field(FieldCondition {
+            key: "color".to_string(),
+            r#match: Some(Match {
+                keyword: Some("red".to_owned()),
+                integer: None,
+            }),
+            range: None,
+            geo_bounding_box: None,
+            geo_radius: None,
         });
 
-        let match_blue = Condition::Match(Match {
-            key: "color".to_owned(),
-            keyword: Some("blue".to_owned()),
-            integer: None,
+        let match_blue = Condition::Field(FieldCondition {
+            key: "color".to_string(),
+            r#match: Some(Match {
+                keyword: Some("blue".to_owned()),
+                integer: None,
+            }),
+            range: None,
+            geo_bounding_box: None,
+            geo_radius: None,
         });
 
-        let with_delivery = Condition::Match(Match {
-            key: "has_delivery".to_owned(),
-            keyword: None,
-            integer: Some(1),
+        let with_delivery = Condition::Field(FieldCondition {
+            key: "has_delivery".to_string(),
+            r#match: Some(Match {
+                keyword: None,
+                integer: Some(1),
+            }),
+            range: None,
+            geo_bounding_box: None,
+            geo_radius: None,
+        });
+
+        let in_berlin = Condition::Field(FieldCondition {
+            key: "location".to_string(),
+            r#match: None,
+            range: None,
+            geo_bounding_box: Some(GeoBoundingBox {
+                top_left: GeoPoint { lon: 13.08835, lat: 52.67551 },
+                bottom_right: GeoPoint { lon: 13.76116, lat: 52.33826 },
+            }),
+            geo_radius: None,
         });
 
-        let in_berlin = Condition::GeoBoundingBox(GeoBoundingBox {
+        let in_moscow = Condition::Field(FieldCondition {
             key: "location".to_string(),
-            top_left: GeoPoint { lon: 13.08835, lat: 52.67551 },
-            bottom_right: GeoPoint { lon: 13.76116, lat: 52.33826 },
+            r#match: None,
+            range: None,
+            geo_bounding_box: Some(GeoBoundingBox {
+                top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
+                bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
+            }),
+            geo_radius: None,
         });
 
-        let in_moscow = Condition::GeoBoundingBox(GeoBoundingBox {
+        let in_moscow = Condition::Field(FieldCondition {
             key: "location".to_string(),
-            top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
-            bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
+            r#match: None,
+            range: None,
+            geo_bounding_box: Some(GeoBoundingBox {
+                top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
+                bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
+            }),
+            geo_radius: None,
         });
 
-        let with_bad_rating = Condition::Range(Range {
+        let with_bad_rating = Condition::Field(FieldCondition {
             key: "rating".to_string(),
-            lt: None,
-            gt: None,
-            gte: None,
-            lte: Some(5.),
+            r#match: None,
+            range: Some(Range {
+                lt: None,
+                gt: None,
+                gte: None,
+                lte: Some(5.),
+            }),
+            geo_bounding_box: None,
+            geo_radius: None,
         });
 
         let query = Filter {

commit cd2acd5dac4807334fccb5df8650a4a8fdcfa0b4
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Mar 14 17:55:50 2021 +0100

    test for cardinality estimation

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 390a1de31..ec8dac379 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -203,17 +203,6 @@ mod tests {
             geo_radius: None,
         });
 
-        let in_moscow = Condition::Field(FieldCondition {
-            key: "location".to_string(),
-            r#match: None,
-            range: None,
-            geo_bounding_box: Some(GeoBoundingBox {
-                top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
-                bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
-            }),
-            geo_radius: None,
-        });
-
         let with_bad_rating = Condition::Field(FieldCondition {
             key: "rating".to_string(),
             r#match: None,

commit 46ba12a198a2c83c78ed04d23c78f131ed6bb41a
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Mar 31 01:28:00 2021 +0200

    update readme + change filter structure

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index ec8dac379..3dadc5c35 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -95,12 +95,12 @@ impl ConditionChecker for SimpleConditionChecker
                         res
                     }).unwrap_or(false)
                 }
-                Condition::HasId(ids) => {
+                Condition::HasId(has_id) => {
                     let external_id = match self.id_mapper.borrow().external_id(point_id) {
                         None => return false,
                         Some(id) => id,
                     };
-                    ids.contains(&external_id)
+                    has_id.has_id.contains(&external_id)
                 }
                 Condition::Filter(_) => panic!("Unexpected branching!")
             }
@@ -309,7 +309,7 @@ mod tests {
         let query = Filter {
             should: None,
             must: None,
-            must_not: Some(vec![Condition::HasId(ids)]),
+            must_not: Some(vec![Condition::HasId(ids.into())]),
         };
         assert!(!payload_checker.check(2, &query));
 
@@ -319,7 +319,7 @@ mod tests {
         let query = Filter {
             should: None,
             must: None,
-            must_not: Some(vec![Condition::HasId(ids)]),
+            must_not: Some(vec![Condition::HasId(ids.into())]),
         };
         assert!(payload_checker.check(10, &query));
 
@@ -327,7 +327,7 @@ mod tests {
 
         let query = Filter {
             should: None,
-            must: Some(vec![Condition::HasId(ids)]),
+            must: Some(vec![Condition::HasId(ids.into())]),
             must_not: None,
         };
         assert!(payload_checker.check(2, &query));

commit a667747369deabec7ef719bad17b0941619b46b1
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Tue Jun 29 09:17:50 2021 +0100

    Applied and enforced rust fmt code formatting tool (#48)
    
    * Apply cargo fmt command
    
    * Enabled cargo fmt on build

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 3dadc5c35..7df055695 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,64 +1,75 @@
-use crate::payload_storage::payload_storage::{ConditionChecker};
-use crate::types::{Filter, PayloadKeyType, PayloadType, Condition, TheMap, PointOffsetType};
+use crate::id_mapper::id_mapper::IdMapper;
+use crate::payload_storage::condition_checker::{
+    match_geo, match_geo_radius, match_payload, match_range,
+};
+use crate::payload_storage::payload_storage::ConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
-use std::sync::Arc;
+use crate::types::{Condition, Filter, PayloadKeyType, PayloadType, PointOffsetType, TheMap};
 use atomic_refcell::AtomicRefCell;
-use crate::id_mapper::id_mapper::IdMapper;
-use crate::payload_storage::condition_checker::{match_payload, match_range, match_geo_radius, match_geo};
-
+use std::sync::Arc;
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
-    where F: Fn(&Condition) -> bool {
+where
+    F: Fn(&Condition) -> bool,
+{
     match condition {
         Condition::Filter(filter) => check_filter(checker, filter),
-        _ => checker(condition)
+        _ => checker(condition),
     }
 }
 
 fn check_filter<F>(checker: &F, filter: &Filter) -> bool
-    where F: Fn(&Condition) -> bool {
+where
+    F: Fn(&Condition) -> bool,
+{
     return check_should(checker, &filter.should)
         && check_must(checker, &filter.must)
         && check_must_not(checker, &filter.must_not);
 }
 
 fn check_should<F>(checker: &F, should: &Option<Vec<Condition>>) -> bool
-    where F: Fn(&Condition) -> bool {
+where
+    F: Fn(&Condition) -> bool,
+{
     let check = |x| check_condition(checker, x);
     match should {
         None => true,
-        Some(conditions) => conditions.iter().any(check)
+        Some(conditions) => conditions.iter().any(check),
     }
 }
 
-
 fn check_must<F>(checker: &F, must: &Option<Vec<Condition>>) -> bool
-    where F: Fn(&Condition) -> bool {
+where
+    F: Fn(&Condition) -> bool,
+{
     let check = |x| check_condition(checker, x);
     match must {
         None => true,
-        Some(conditions) => conditions.iter().all(check)
+        Some(conditions) => conditions.iter().all(check),
     }
 }
 
 fn check_must_not<F>(checker: &F, must: &Option<Vec<Condition>>) -> bool
-    where F: Fn(&Condition) -> bool {
+where
+    F: Fn(&Condition) -> bool,
+{
     let check = |x| !check_condition(checker, x);
     match must {
         None => true,
-        Some(conditions) => conditions.iter().all(check)
+        Some(conditions) => conditions.iter().all(check),
     }
 }
 
-
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
     id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
 }
 
 impl SimpleConditionChecker {
-    pub fn new(payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
-               id_mapper: Arc<AtomicRefCell<dyn IdMapper>>) -> Self {
+    pub fn new(
+        payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
+        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+    ) -> Self {
         SimpleConditionChecker {
             payload_storage,
             id_mapper,
@@ -69,8 +80,7 @@ impl SimpleConditionChecker {
 // Uncomment when stabilized
 // const EMPTY_PAYLOAD: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
 
-impl ConditionChecker for SimpleConditionChecker
-{
+impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
         let empty_map: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
 
@@ -79,21 +89,44 @@ impl ConditionChecker for SimpleConditionChecker
 
         let payload = match payload_ptr {
             None => &empty_map,
-            Some(x) => x
+            Some(x) => x,
         };
 
         let checker = |condition: &Condition| {
             match condition {
                 Condition::Field(field_condition) => {
-                    payload.get(&field_condition.key).map(|p| {
-                        let mut res = false;
-                        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-                        res = res || field_condition.r#match.as_ref().map(|condition| match_payload(p, condition)).unwrap_or(false);
-                        res = res || field_condition.range.as_ref().map(|condition| match_range(p, condition)).unwrap_or(false);
-                        res = res || field_condition.geo_radius.as_ref().map(|condition| match_geo_radius(p, condition)).unwrap_or(false);
-                        res = res || field_condition.geo_bounding_box.as_ref().map(|condition| match_geo(p, condition)).unwrap_or(false);
-                        res
-                    }).unwrap_or(false)
+                    payload
+                        .get(&field_condition.key)
+                        .map(|p| {
+                            let mut res = false;
+                            // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+                            res = res
+                                || field_condition
+                                    .r#match
+                                    .as_ref()
+                                    .map(|condition| match_payload(p, condition))
+                                    .unwrap_or(false);
+                            res = res
+                                || field_condition
+                                    .range
+                                    .as_ref()
+                                    .map(|condition| match_range(p, condition))
+                                    .unwrap_or(false);
+                            res = res
+                                || field_condition
+                                    .geo_radius
+                                    .as_ref()
+                                    .map(|condition| match_geo_radius(p, condition))
+                                    .unwrap_or(false);
+                            res = res
+                                || field_condition
+                                    .geo_bounding_box
+                                    .as_ref()
+                                    .map(|condition| match_geo(p, condition))
+                                    .unwrap_or(false);
+                            res
+                        })
+                        .unwrap_or(false)
                 }
                 Condition::HasId(has_id) => {
                     let external_id = match self.id_mapper.borrow().external_id(point_id) {
@@ -102,7 +135,7 @@ impl ConditionChecker for SimpleConditionChecker
                     };
                     has_id.has_id.contains(&external_id)
                 }
-                Condition::Filter(_) => panic!("Unexpected branching!")
+                Condition::Filter(_) => panic!("Unexpected branching!"),
             }
         };
 
@@ -113,12 +146,12 @@ impl ConditionChecker for SimpleConditionChecker
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::types::{PayloadType, FieldCondition, Match, GeoBoundingBox, Range};
+    use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
+    use crate::payload_storage::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
+    use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};
     use std::collections::HashSet;
     use tempdir::TempDir;
-    use crate::payload_storage::payload_storage::PayloadStorage;
-    use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
 
     #[test]
     fn test_condition_checker() {
@@ -126,13 +159,25 @@ mod tests {
         let dir_id_mapper = TempDir::new("id_mapper_dir").unwrap();
 
         let payload: TheMap<PayloadKeyType, PayloadType> = [
-            ("location".to_owned(), PayloadType::Geo(vec![GeoPoint { lon: 13.404954, lat: 52.520008 }])),
+            (
+                "location".to_owned(),
+                PayloadType::Geo(vec![GeoPoint {
+                    lon: 13.404954,
+                    lat: 52.520008,
+                }]),
+            ),
             ("price".to_owned(), PayloadType::Float(vec![499.90])),
             ("amount".to_owned(), PayloadType::Integer(vec![10])),
             ("rating".to_owned(), PayloadType::Integer(vec![3, 7, 9, 9])),
-            ("color".to_owned(), PayloadType::Keyword(vec!["red".to_owned()])),
+            (
+                "color".to_owned(),
+                PayloadType::Keyword(vec!["red".to_owned()]),
+            ),
             ("has_delivery".to_owned(), PayloadType::Integer(vec![1])),
-        ].iter().cloned().collect();
+        ]
+        .iter()
+        .cloned()
+        .collect();
 
         let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
         let mut id_mapper = SimpleIdMapper::open(dir_id_mapper.path()).unwrap();
@@ -186,8 +231,14 @@ mod tests {
             r#match: None,
             range: None,
             geo_bounding_box: Some(GeoBoundingBox {
-                top_left: GeoPoint { lon: 13.08835, lat: 52.67551 },
-                bottom_right: GeoPoint { lon: 13.76116, lat: 52.33826 },
+                top_left: GeoPoint {
+                    lon: 13.08835,
+                    lat: 52.67551,
+                },
+                bottom_right: GeoPoint {
+                    lon: 13.76116,
+                    lat: 52.33826,
+                },
             }),
             geo_radius: None,
         });
@@ -197,8 +248,14 @@ mod tests {
             r#match: None,
             range: None,
             geo_bounding_box: Some(GeoBoundingBox {
-                top_left: GeoPoint { lon: 37.0366, lat: 56.1859 },
-                bottom_right: GeoPoint { lon: 38.2532, lat: 55.317 },
+                top_left: GeoPoint {
+                    lon: 37.0366,
+                    lat: 56.1859,
+                },
+                bottom_right: GeoPoint {
+                    lon: 38.2532,
+                    lat: 55.317,
+                },
             }),
             geo_radius: None,
         });
@@ -294,7 +351,6 @@ mod tests {
         };
         assert!(payload_checker.check(0, &query));
 
-
         let query = Filter {
             should: None,
             must: None,
@@ -302,10 +358,8 @@ mod tests {
         };
         assert!(!payload_checker.check(0, &query));
 
-
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
-
         let query = Filter {
             should: None,
             must: None,
@@ -315,7 +369,6 @@ mod tests {
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
 
-
         let query = Filter {
             should: None,
             must: None,
@@ -332,4 +385,4 @@ mod tests {
         };
         assert!(payload_checker.check(2, &query));
     }
-}
\ No newline at end of file
+}

commit 0e1a6e17507d56e7f6a7f764e7fa56a494753d4d
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Fri Jul 2 16:51:54 2021 +0100

    [Clippy] Fix a range of warnings (#52)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 7df055695..d0f227de7 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -22,9 +22,9 @@ fn check_filter<F>(checker: &F, filter: &Filter) -> bool
 where
     F: Fn(&Condition) -> bool,
 {
-    return check_should(checker, &filter.should)
+    check_should(checker, &filter.should)
         && check_must(checker, &filter.must)
-        && check_must_not(checker, &filter.must_not);
+        && check_must_not(checker, &filter.must_not)
 }
 
 fn check_should<F>(checker: &F, should: &Option<Vec<Condition>>) -> bool

commit 93e0fb5c2c8f85f232bef82f48ab2b80c43f76cc
Author: Konstantin <kgrech@users.noreply.github.com>
Date:   Sat Jul 3 12:12:21 2021 +0100

    [CLIPPY] Fix the last portion of rules and enable CI check (#53)
    
    * [CLIPPY] Fixed the warning for references of the user defined types
    
    * [CLIPPY] Fix module naming issue
    
    * [CLIPPY] Fix the last set of warnings and enable clippy check during CI
    
    * Moved cargo fmt and cargo clippy into it's own action

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index d0f227de7..81f68d0fc 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,9 +1,9 @@
-use crate::id_mapper::id_mapper::IdMapper;
+use crate::id_mapper::IdMapper;
 use crate::payload_storage::condition_checker::{
     match_geo, match_geo_radius, match_payload, match_range,
 };
-use crate::payload_storage::payload_storage::ConditionChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
+use crate::payload_storage::ConditionChecker;
 use crate::types::{Condition, Filter, PayloadKeyType, PayloadType, PointOffsetType, TheMap};
 use atomic_refcell::AtomicRefCell;
 use std::sync::Arc;
@@ -147,7 +147,7 @@ impl ConditionChecker for SimpleConditionChecker {
 mod tests {
     use super::*;
     use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
-    use crate::payload_storage::payload_storage::PayloadStorage;
+    use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
     use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};
     use std::collections::HashSet;

commit bf3d8c25753188b4ca5e69a13c7f26e3c383f05b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Oct 24 18:10:39 2021 +0200

    data consistency fixes and updates (#112)
    
    * update segment version after completed update only
    
    * more stable updates: check pre-existing points on update, fail recovery, WAL proper ack. check_unprocessed_points WIP
    
    * switch to async channel
    
    * perform update operations in a separate thread (#111)
    
    * perform update operations in a separate thread
    
    * ordered sending update signal
    
    * locate a segment merging versioning bug
    
    * rename id_mapper -> id_tracker
    
    * per-record versioning
    
    * clippy fixes
    
    * cargo fmt
    
    * rm limit of open files
    
    * fail recovery test
    
    * cargo fmt
    
    * wait for worker stops befor dropping the runtime

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 81f68d0fc..67e236418 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,4 +1,4 @@
-use crate::id_mapper::IdMapper;
+use crate::id_tracker::IdTracker;
 use crate::payload_storage::condition_checker::{
     match_geo, match_geo_radius, match_payload, match_range,
 };
@@ -62,17 +62,17 @@ where
 
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
-    id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+    id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
 }
 
 impl SimpleConditionChecker {
     pub fn new(
         payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
-        id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,
+        id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
     ) -> Self {
         SimpleConditionChecker {
             payload_storage,
-            id_mapper,
+            id_tracker,
         }
     }
 }
@@ -129,7 +129,7 @@ impl ConditionChecker for SimpleConditionChecker {
                         .unwrap_or(false)
                 }
                 Condition::HasId(has_id) => {
-                    let external_id = match self.id_mapper.borrow().external_id(point_id) {
+                    let external_id = match self.id_tracker.borrow().external_id(point_id) {
                         None => return false,
                         Some(id) => id,
                     };
@@ -146,7 +146,7 @@ impl ConditionChecker for SimpleConditionChecker {
 #[cfg(test)]
 mod tests {
     use super::*;
-    use crate::id_mapper::simple_id_mapper::SimpleIdMapper;
+    use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
     use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};
@@ -156,7 +156,7 @@ mod tests {
     #[test]
     fn test_condition_checker() {
         let dir = TempDir::new("payload_dir").unwrap();
-        let dir_id_mapper = TempDir::new("id_mapper_dir").unwrap();
+        let dir_id_tracker = TempDir::new("id_tracker_dir").unwrap();
 
         let payload: TheMap<PayloadKeyType, PayloadType> = [
             (
@@ -180,17 +180,17 @@ mod tests {
         .collect();
 
         let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
-        let mut id_mapper = SimpleIdMapper::open(dir_id_mapper.path()).unwrap();
+        let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
 
-        id_mapper.set_link(0, 0).unwrap();
-        id_mapper.set_link(1, 1).unwrap();
-        id_mapper.set_link(2, 2).unwrap();
-        id_mapper.set_link(10, 10).unwrap();
+        id_tracker.set_link(0, 0).unwrap();
+        id_tracker.set_link(1, 1).unwrap();
+        id_tracker.set_link(2, 2).unwrap();
+        id_tracker.set_link(10, 10).unwrap();
         payload_storage.assign_all(0, payload).unwrap();
 
         let payload_checker = SimpleConditionChecker::new(
             Arc::new(AtomicRefCell::new(payload_storage)),
-            Arc::new(AtomicRefCell::new(id_mapper)),
+            Arc::new(AtomicRefCell::new(id_tracker)),
         );
 
         let match_red = Condition::Field(FieldCondition {

commit c603f0075e9b546afee57522cdbd8ad28c0da27f
Author: Marcin Puc <5671049+tranzystorek-io@users.noreply.github.com>
Date:   Wed Nov 10 21:32:25 2021 +0100

    Add various refactorings (#118)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 67e236418..59f85f565 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -310,7 +310,7 @@ mod tests {
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
-            must: Some(vec![with_delivery.clone(), in_moscow.clone()]),
+            must: Some(vec![with_delivery, in_moscow.clone()]),
             must_not: None,
         };
         assert!(!payload_checker.check(0, &query));
@@ -337,12 +337,12 @@ mod tests {
             should: Some(vec![
                 Condition::Filter(Filter {
                     should: None,
-                    must: Some(vec![match_blue.clone(), in_moscow.clone()]),
+                    must: Some(vec![match_blue, in_moscow]),
                     must_not: None,
                 }),
                 Condition::Filter(Filter {
                     should: None,
-                    must: Some(vec![match_red.clone(), in_berlin.clone()]),
+                    must: Some(vec![match_red, in_berlin]),
                     must_not: None,
                 }),
             ]),
@@ -354,7 +354,7 @@ mod tests {
         let query = Filter {
             should: None,
             must: None,
-            must_not: Some(vec![with_bad_rating.clone()]),
+            must_not: Some(vec![with_bad_rating]),
         };
         assert!(!payload_checker.check(0, &query));
 

commit cb0a1b6bbc3b5275e48ca987a193012582b31d1d
Author: Anton Kaliaev <anton.kalyaev@gmail.com>
Date:   Mon Jan 3 20:28:56 2022 +0400

    use map_or instead of map & unwrap_or (#172)
    
    https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 59f85f565..c5e16cfa6 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -95,38 +95,31 @@ impl ConditionChecker for SimpleConditionChecker {
         let checker = |condition: &Condition| {
             match condition {
                 Condition::Field(field_condition) => {
-                    payload
-                        .get(&field_condition.key)
-                        .map(|p| {
-                            let mut res = false;
-                            // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-                            res = res
-                                || field_condition
-                                    .r#match
-                                    .as_ref()
-                                    .map(|condition| match_payload(p, condition))
-                                    .unwrap_or(false);
-                            res = res
-                                || field_condition
-                                    .range
-                                    .as_ref()
-                                    .map(|condition| match_range(p, condition))
-                                    .unwrap_or(false);
-                            res = res
-                                || field_condition
-                                    .geo_radius
-                                    .as_ref()
-                                    .map(|condition| match_geo_radius(p, condition))
-                                    .unwrap_or(false);
-                            res = res
-                                || field_condition
-                                    .geo_bounding_box
-                                    .as_ref()
-                                    .map(|condition| match_geo(p, condition))
-                                    .unwrap_or(false);
-                            res
-                        })
-                        .unwrap_or(false)
+                    payload.get(&field_condition.key).map_or(false, |p| {
+                        let mut res = false;
+                        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+                        res = res
+                            || field_condition
+                                .r#match
+                                .as_ref()
+                                .map_or(false, |condition| match_payload(p, condition));
+                        res = res
+                            || field_condition
+                                .range
+                                .as_ref()
+                                .map_or(false, |condition| match_range(p, condition));
+                        res = res
+                            || field_condition
+                                .geo_radius
+                                .as_ref()
+                                .map_or(false, |condition| match_geo_radius(p, condition));
+                        res = res
+                            || field_condition
+                                .geo_bounding_box
+                                .as_ref()
+                                .map_or(false, |condition| match_geo(p, condition));
+                        res
+                    })
                 }
                 Condition::HasId(has_id) => {
                     let external_id = match self.id_tracker.borrow().external_id(point_id) {

commit ee461ce0a6cc031e8289bc7a238bb2e807e85b20
Author: Prokudin Alexander <prok20@inbox.ru>
Date:   Tue Jan 18 01:33:26 2022 +0300

    Extend clippy to workspace and fix some warnings (#199)
    
    * Fix clippy in linting workflow
    
    * Add toolchain override flag
    
    * Add components to toolchain installation explicitly
    
    * Add --workspace flag to clippy to check all packages
    
    * Remove unnecessary clones
    
    * remove redundant .clone() calls
    
    * fix wrong arguments order in tests (typo)
    
    * Fix vec! macro usage in test
    
    * Correct redundant assert! usages
    
    * Provide a quick fix for 'unused' test function lint
    
    * fix unsound Send + Sync
    
    * fix clippy complains
    
    * fmt
    
    * fix clippy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index c5e16cfa6..5204fd304 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,4 +1,4 @@
-use crate::id_tracker::IdTracker;
+use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::{
     match_geo, match_geo_radius, match_payload, match_range,
 };
@@ -62,13 +62,13 @@ where
 
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
-    id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
+    id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
 }
 
 impl SimpleConditionChecker {
     pub fn new(
         payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
-        id_tracker: Arc<AtomicRefCell<dyn IdTracker>>,
+        id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     ) -> Self {
         SimpleConditionChecker {
             payload_storage,
@@ -140,6 +140,7 @@ impl ConditionChecker for SimpleConditionChecker {
 mod tests {
     use super::*;
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
+    use crate::id_tracker::IdTracker;
     use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
     use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};

commit 65787f7f556b309ffbfc733c0e3e01433e87e92b
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Jan 31 13:18:07 2022 +0100

    UUID as point id (#265)
    
    * wip: u64 -> u128 + serialization tests
    
    * breaking: use more flexible structure for saving point ids
    
    * replace u64 external id type with enum
    
    * update openapi definitions for uuid + fix retrieve point api + bash script tests

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 5204fd304..1743fbd66 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -176,10 +176,10 @@ mod tests {
         let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
         let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
 
-        id_tracker.set_link(0, 0).unwrap();
-        id_tracker.set_link(1, 1).unwrap();
-        id_tracker.set_link(2, 2).unwrap();
-        id_tracker.set_link(10, 10).unwrap();
+        id_tracker.set_link(0.into(), 0).unwrap();
+        id_tracker.set_link(1.into(), 1).unwrap();
+        id_tracker.set_link(2.into(), 2).unwrap();
+        id_tracker.set_link(10.into(), 10).unwrap();
         payload_storage.assign_all(0, payload).unwrap();
 
         let payload_checker = SimpleConditionChecker::new(
@@ -352,7 +352,7 @@ mod tests {
         };
         assert!(!payload_checker.check(0, &query));
 
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter {
             should: None,
@@ -361,7 +361,7 @@ mod tests {
         };
         assert!(!payload_checker.check(2, &query));
 
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter {
             should: None,
@@ -370,7 +370,7 @@ mod tests {
         };
         assert!(payload_checker.check(10, &query));
 
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().collect();
+        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter {
             should: None,

commit 4483ea0d60bb4cf97df1267de6299556674d83fa
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Wed Feb 9 11:46:01 2022 -0300

    fix: #101 Payload type consistency is not enforced.

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 1743fbd66..d3bfc167f 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -141,6 +141,7 @@ mod tests {
     use super::*;
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
+    use crate::payload_storage::schema_storage::SchemaStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
     use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};
@@ -173,7 +174,8 @@ mod tests {
         .cloned()
         .collect();
 
-        let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
+        let mut payload_storage =
+            SimplePayloadStorage::open(dir.path(), Arc::new(SchemaStorage::new())).unwrap();
         let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
 
         id_tracker.set_link(0.into(), 0).unwrap();

commit 02a50212e516a8601829c97b7b8facf388ad7c49
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Feb 14 09:58:23 2022 +0100

    Refactor proto & rest (#302)
    
    * reorder points.proto
    
    * simplify grpc + replace match with enum (backward compatible)
    
    * fmt
    
    * remove try_match
    
    * upd openapi schema
    
    * fix grpc test
    
    * fix grpc readme

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index d3bfc167f..ec200cc1b 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -144,7 +144,7 @@ mod tests {
     use crate::payload_storage::schema_storage::SchemaStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
-    use crate::types::{FieldCondition, GeoBoundingBox, Match, PayloadType, Range};
+    use crate::types::{FieldCondition, GeoBoundingBox, PayloadType, Range};
     use std::collections::HashSet;
     use tempdir::TempDir;
 
@@ -191,10 +191,7 @@ mod tests {
 
         let match_red = Condition::Field(FieldCondition {
             key: "color".to_string(),
-            r#match: Some(Match {
-                keyword: Some("red".to_owned()),
-                integer: None,
-            }),
+            r#match: Some("red".to_owned().into()),
             range: None,
             geo_bounding_box: None,
             geo_radius: None,
@@ -202,10 +199,7 @@ mod tests {
 
         let match_blue = Condition::Field(FieldCondition {
             key: "color".to_string(),
-            r#match: Some(Match {
-                keyword: Some("blue".to_owned()),
-                integer: None,
-            }),
+            r#match: Some("blue".to_owned().into()),
             range: None,
             geo_bounding_box: None,
             geo_radius: None,
@@ -213,10 +207,7 @@ mod tests {
 
         let with_delivery = Condition::Field(FieldCondition {
             key: "has_delivery".to_string(),
-            r#match: Some(Match {
-                keyword: None,
-                integer: Some(1),
-            }),
+            r#match: Some(1.into()),
             range: None,
             geo_bounding_box: None,
             geo_radius: None,

commit f69a7b740fb57da8ed887f36afb173a3f3846c66
Author: Gabriel Velo <gabriel.velo@gmail.com>
Date:   Mon Mar 21 07:09:10 2022 -0300

    json as payload (#306)
    
    add json as payload
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index ec200cc1b..460e2fb45 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,12 +1,12 @@
+use std::sync::Arc;
+
+use atomic_refcell::AtomicRefCell;
+
 use crate::id_tracker::IdTrackerSS;
-use crate::payload_storage::condition_checker::{
-    match_geo, match_geo_radius, match_payload, match_range,
-};
+use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::payload_storage::ConditionChecker;
-use crate::types::{Condition, Filter, PayloadKeyType, PayloadType, PointOffsetType, TheMap};
-use atomic_refcell::AtomicRefCell;
-use std::sync::Arc;
+use crate::types::{Condition, Filter, Payload, PointOffsetType};
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
 where
@@ -82,42 +82,42 @@ impl SimpleConditionChecker {
 
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let empty_map: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
+        let empty_payload: Payload = Default::default();
 
         let payload_storage_guard = self.payload_storage.borrow();
         let payload_ptr = payload_storage_guard.payload_ptr(point_id);
 
         let payload = match payload_ptr {
-            None => &empty_map,
+            None => &empty_payload,
             Some(x) => x,
         };
 
         let checker = |condition: &Condition| {
             match condition {
                 Condition::Field(field_condition) => {
-                    payload.get(&field_condition.key).map_or(false, |p| {
+                    payload.get_value(&field_condition.key).map_or(false, |p| {
                         let mut res = false;
                         // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
                         res = res
                             || field_condition
                                 .r#match
                                 .as_ref()
-                                .map_or(false, |condition| match_payload(p, condition));
+                                .map_or(false, |condition| condition.check(p));
                         res = res
                             || field_condition
                                 .range
                                 .as_ref()
-                                .map_or(false, |condition| match_range(p, condition));
+                                .map_or(false, |condition| condition.check(p));
                         res = res
                             || field_condition
                                 .geo_radius
                                 .as_ref()
-                                .map_or(false, |condition| match_geo_radius(p, condition));
+                                .map_or(false, |condition| condition.check(p));
                         res = res
                             || field_condition
                                 .geo_bounding_box
                                 .as_ref()
-                                .map_or(false, |condition| match_geo(p, condition));
+                                .map_or(false, |condition| condition.check(p));
                         res
                     })
                 }
@@ -138,51 +138,46 @@ impl ConditionChecker for SimpleConditionChecker {
 
 #[cfg(test)]
 mod tests {
-    use super::*;
+    use std::collections::HashSet;
+
+    use serde_json::json;
+    use tempdir::TempDir;
+
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
-    use crate::payload_storage::schema_storage::SchemaStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::GeoPoint;
-    use crate::types::{FieldCondition, GeoBoundingBox, PayloadType, Range};
-    use std::collections::HashSet;
-    use tempdir::TempDir;
+    use crate::types::{FieldCondition, GeoBoundingBox, Range};
+
+    use super::*;
 
     #[test]
     fn test_condition_checker() {
         let dir = TempDir::new("payload_dir").unwrap();
         let dir_id_tracker = TempDir::new("id_tracker_dir").unwrap();
 
-        let payload: TheMap<PayloadKeyType, PayloadType> = [
-            (
-                "location".to_owned(),
-                PayloadType::Geo(vec![GeoPoint {
-                    lon: 13.404954,
-                    lat: 52.520008,
-                }]),
-            ),
-            ("price".to_owned(), PayloadType::Float(vec![499.90])),
-            ("amount".to_owned(), PayloadType::Integer(vec![10])),
-            ("rating".to_owned(), PayloadType::Integer(vec![3, 7, 9, 9])),
-            (
-                "color".to_owned(),
-                PayloadType::Keyword(vec!["red".to_owned()]),
-            ),
-            ("has_delivery".to_owned(), PayloadType::Integer(vec![1])),
-        ]
-        .iter()
-        .cloned()
-        .collect();
-
-        let mut payload_storage =
-            SimplePayloadStorage::open(dir.path(), Arc::new(SchemaStorage::new())).unwrap();
+        let payload: Payload = json!(
+            {
+                "location":{
+                    "lon": 13.404954,
+                    "lat": 52.520008,
+            },
+            "price":499.90,
+            "amount":10,
+            "rating":vec![3, 7, 9, 9],
+            "color":"red",
+            "has_delivery":1,
+        })
+        .into();
+
+        let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
         let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
 
         id_tracker.set_link(0.into(), 0).unwrap();
         id_tracker.set_link(1.into(), 1).unwrap();
         id_tracker.set_link(2.into(), 2).unwrap();
         id_tracker.set_link(10.into(), 10).unwrap();
-        payload_storage.assign_all(0, payload).unwrap();
+        payload_storage.assign_all(0, &payload).unwrap();
 
         let payload_checker = SimpleConditionChecker::new(
             Arc::new(AtomicRefCell::new(payload_storage)),

commit adc1f4ad9711f889877cb5ad9ac073fb01d6e75c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Apr 3 16:08:34 2022 +0200

    Bool filter (#421)
    
    * bool match condition
    
    * use generic values for match requests
    
    * fmt
    
    * upd grpc interface
    
    * upd grpc docs

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 460e2fb45..b093f2401 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -162,11 +162,11 @@ mod tests {
                     "lon": 13.404954,
                     "lat": 52.520008,
             },
-            "price":499.90,
-            "amount":10,
-            "rating":vec![3, 7, 9, 9],
-            "color":"red",
-            "has_delivery":1,
+            "price": 499.90,
+            "amount": 10,
+            "rating": vec![3, 7, 9, 9],
+            "color": "red",
+            "has_delivery": true,
         })
         .into();
 
@@ -202,7 +202,7 @@ mod tests {
 
         let with_delivery = Condition::Field(FieldCondition {
             key: "has_delivery".to_string(),
-            r#match: Some(1.into()),
+            r#match: Some(true.into()),
             range: None,
             geo_bounding_box: None,
             geo_radius: None,

commit b07428f62011602b78567225026633592df4cc3c
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Sun Apr 3 16:55:51 2022 +0200

    Is empty condition (#423)
    
    * is-empty condition
    
    * fmt
    
    * better assert
    
    * fmt

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index b093f2401..0dc1899e1 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,12 +1,13 @@
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use serde_json::Value;
 
 use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
 use crate::payload_storage::ConditionChecker;
-use crate::types::{Condition, Filter, Payload, PointOffsetType};
+use crate::types::{Condition, Filter, IsEmptyCondition, Payload, PointOffsetType};
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
 where
@@ -129,6 +130,16 @@ impl ConditionChecker for SimpleConditionChecker {
                     has_id.has_id.contains(&external_id)
                 }
                 Condition::Filter(_) => panic!("Unexpected branching!"),
+                Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
+                    match payload.get_value(&field.key) {
+                        None => true,
+                        Some(value) => match value {
+                            Value::Null => true,
+                            Value::Array(array) => array.is_empty(),
+                            _ => false,
+                        },
+                    }
+                }
             }
         };
 
@@ -146,8 +157,8 @@ mod tests {
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::PayloadStorage;
-    use crate::types::GeoPoint;
     use crate::types::{FieldCondition, GeoBoundingBox, Range};
+    use crate::types::{GeoPoint, PayloadField};
 
     use super::*;
 
@@ -184,6 +195,21 @@ mod tests {
             Arc::new(AtomicRefCell::new(id_tracker)),
         );
 
+        let is_empty_condition_1 = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+            is_empty: PayloadField {
+                key: "price".to_string(),
+            },
+        }));
+
+        let is_empty_condition_2 = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+            is_empty: PayloadField {
+                key: "something_new".to_string(),
+            },
+        }));
+
+        assert!(!payload_checker.check(0, &is_empty_condition_1));
+        assert!(payload_checker.check(0, &is_empty_condition_2));
+
         let match_red = Condition::Field(FieldCondition {
             key: "color".to_string(),
             r#match: Some("red".to_owned().into()),

commit ce21abf033293f6b8a076e297c3397131ae421e4
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 5 14:31:53 2022 +0200

    Values count condition (#439)
    
    * add values_count condition
    
    * fmt
    
    * fix tests and clippy
    
    * fmt

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 0dc1899e1..b8c1e015b 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -119,6 +119,11 @@ impl ConditionChecker for SimpleConditionChecker {
                                 .geo_bounding_box
                                 .as_ref()
                                 .map_or(false, |condition| condition.check(p));
+                        res = res
+                            || field_condition
+                                .values_count
+                                .as_ref()
+                                .map_or(false, |condition| condition.check(p));
                         res
                     })
                 }
@@ -157,7 +162,7 @@ mod tests {
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::PayloadStorage;
-    use crate::types::{FieldCondition, GeoBoundingBox, Range};
+    use crate::types::{FieldCondition, GeoBoundingBox, Range, ValuesCount};
     use crate::types::{GeoPoint, PayloadField};
 
     use super::*;
@@ -167,11 +172,10 @@ mod tests {
         let dir = TempDir::new("payload_dir").unwrap();
         let dir_id_tracker = TempDir::new("id_tracker_dir").unwrap();
 
-        let payload: Payload = json!(
-            {
-                "location":{
-                    "lon": 13.404954,
-                    "lat": 52.520008,
+        let payload: Payload = json!({
+            "location":{
+                "lon": 13.404954,
+                "lat": 52.520008,
             },
             "price": 499.90,
             "amount": 10,
@@ -210,35 +214,49 @@ mod tests {
         assert!(!payload_checker.check(0, &is_empty_condition_1));
         assert!(payload_checker.check(0, &is_empty_condition_2));
 
-        let match_red = Condition::Field(FieldCondition {
-            key: "color".to_string(),
-            r#match: Some("red".to_owned().into()),
-            range: None,
-            geo_bounding_box: None,
-            geo_radius: None,
-        });
-
-        let match_blue = Condition::Field(FieldCondition {
-            key: "color".to_string(),
-            r#match: Some("blue".to_owned().into()),
-            range: None,
-            geo_bounding_box: None,
-            geo_radius: None,
-        });
-
-        let with_delivery = Condition::Field(FieldCondition {
-            key: "has_delivery".to_string(),
-            r#match: Some(true.into()),
-            range: None,
-            geo_bounding_box: None,
-            geo_radius: None,
-        });
-
-        let in_berlin = Condition::Field(FieldCondition {
-            key: "location".to_string(),
-            r#match: None,
-            range: None,
-            geo_bounding_box: Some(GeoBoundingBox {
+        let many_value_count_condition =
+            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
+                "rating".to_string(),
+                ValuesCount {
+                    lt: None,
+                    gt: None,
+                    gte: Some(10),
+                    lte: None,
+                },
+            )));
+
+        let few_value_count_condition =
+            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
+                "rating".to_string(),
+                ValuesCount {
+                    lt: Some(5),
+                    gt: None,
+                    gte: None,
+                    lte: None,
+                },
+            )));
+
+        assert!(!payload_checker.check(0, &many_value_count_condition));
+        assert!(payload_checker.check(0, &few_value_count_condition));
+
+        let match_red = Condition::Field(FieldCondition::new_match(
+            "color".to_string(),
+            "red".to_owned().into(),
+        ));
+
+        let match_blue = Condition::Field(FieldCondition::new_match(
+            "color".to_string(),
+            "blue".to_owned().into(),
+        ));
+
+        let with_delivery = Condition::Field(FieldCondition::new_match(
+            "has_delivery".to_string(),
+            true.into(),
+        ));
+
+        let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(
+            "location".to_string(),
+            GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 13.08835,
                     lat: 52.67551,
@@ -247,15 +265,12 @@ mod tests {
                     lon: 13.76116,
                     lat: 52.33826,
                 },
-            }),
-            geo_radius: None,
-        });
-
-        let in_moscow = Condition::Field(FieldCondition {
-            key: "location".to_string(),
-            r#match: None,
-            range: None,
-            geo_bounding_box: Some(GeoBoundingBox {
+            },
+        ));
+
+        let in_moscow = Condition::Field(FieldCondition::new_geo_bounding_box(
+            "location".to_string(),
+            GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 37.0366,
                     lat: 56.1859,
@@ -264,22 +279,18 @@ mod tests {
                     lon: 38.2532,
                     lat: 55.317,
                 },
-            }),
-            geo_radius: None,
-        });
-
-        let with_bad_rating = Condition::Field(FieldCondition {
-            key: "rating".to_string(),
-            r#match: None,
-            range: Some(Range {
+            },
+        ));
+
+        let with_bad_rating = Condition::Field(FieldCondition::new_range(
+            "rating".to_string(),
+            Range {
                 lt: None,
                 gt: None,
                 gte: None,
                 lte: Some(5.),
-            }),
-            geo_bounding_box: None,
-            geo_radius: None,
-        });
+            },
+        ));
 
         let query = Filter {
             should: None,

commit ef67a2ec59180ca599b0c61cc957c45a56454410
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:43:02 2022 +0200

    Condition search benchmark (#435)
    
    * decouple payload index and vector storage
    
    * wip: test fixtures
    
    * conditional search benchmark
    
    * fmt
    
    * use arc iterator for filtered queries
    
    * fmt
    
    * enable all benches
    
    * fix warn
    
    * upd tests
    
    * fmt
    
    * Update lib/segment/src/fixtures/payload_context_fixture.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>
    
    Co-authored-by: Egor Ivkov <e.o.ivkov@gmail.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index b8c1e015b..b3e38a9a1 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,3 +1,4 @@
+use std::ops::Deref;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
@@ -61,9 +62,74 @@ where
     }
 }
 
+pub fn check_payload(
+    payload: &Payload,
+    id_tracker: &IdTrackerSS,
+    query: &Filter,
+    point_id: PointOffsetType,
+) -> bool {
+    let checker = |condition: &Condition| {
+        match condition {
+            Condition::Field(field_condition) => {
+                payload.get_value(&field_condition.key).map_or(false, |p| {
+                    let mut res = false;
+                    // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+                    res = res
+                        || field_condition
+                            .r#match
+                            .as_ref()
+                            .map_or(false, |condition| condition.check(p));
+                    res = res
+                        || field_condition
+                            .range
+                            .as_ref()
+                            .map_or(false, |condition| condition.check(p));
+                    res = res
+                        || field_condition
+                            .geo_radius
+                            .as_ref()
+                            .map_or(false, |condition| condition.check(p));
+                    res = res
+                        || field_condition
+                            .geo_bounding_box
+                            .as_ref()
+                            .map_or(false, |condition| condition.check(p));
+                    res = res
+                        || field_condition
+                            .values_count
+                            .as_ref()
+                            .map_or(false, |condition| condition.check(p));
+                    res
+                })
+            }
+            Condition::HasId(has_id) => {
+                let external_id = match id_tracker.external_id(point_id) {
+                    None => return false,
+                    Some(id) => id,
+                };
+                has_id.has_id.contains(&external_id)
+            }
+            Condition::Filter(_) => unreachable!(),
+            Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
+                match payload.get_value(&field.key) {
+                    None => true,
+                    Some(value) => match value {
+                        Value::Null => true,
+                        Value::Array(array) => array.is_empty(),
+                        _ => false,
+                    },
+                }
+            }
+        }
+    };
+
+    check_filter(&checker, query)
+}
+
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    empty_payload: Payload,
 }
 
 impl SimpleConditionChecker {
@@ -74,81 +140,22 @@ impl SimpleConditionChecker {
         SimpleConditionChecker {
             payload_storage,
             id_tracker,
+            empty_payload: Default::default(),
         }
     }
 }
 
-// Uncomment when stabilized
-// const EMPTY_PAYLOAD: TheMap<PayloadKeyType, PayloadType> = TheMap::new();
-
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let empty_payload: Payload = Default::default();
-
         let payload_storage_guard = self.payload_storage.borrow();
         let payload_ptr = payload_storage_guard.payload_ptr(point_id);
 
         let payload = match payload_ptr {
-            None => &empty_payload,
+            None => &self.empty_payload,
             Some(x) => x,
         };
 
-        let checker = |condition: &Condition| {
-            match condition {
-                Condition::Field(field_condition) => {
-                    payload.get_value(&field_condition.key).map_or(false, |p| {
-                        let mut res = false;
-                        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-                        res = res
-                            || field_condition
-                                .r#match
-                                .as_ref()
-                                .map_or(false, |condition| condition.check(p));
-                        res = res
-                            || field_condition
-                                .range
-                                .as_ref()
-                                .map_or(false, |condition| condition.check(p));
-                        res = res
-                            || field_condition
-                                .geo_radius
-                                .as_ref()
-                                .map_or(false, |condition| condition.check(p));
-                        res = res
-                            || field_condition
-                                .geo_bounding_box
-                                .as_ref()
-                                .map_or(false, |condition| condition.check(p));
-                        res = res
-                            || field_condition
-                                .values_count
-                                .as_ref()
-                                .map_or(false, |condition| condition.check(p));
-                        res
-                    })
-                }
-                Condition::HasId(has_id) => {
-                    let external_id = match self.id_tracker.borrow().external_id(point_id) {
-                        None => return false,
-                        Some(id) => id,
-                    };
-                    has_id.has_id.contains(&external_id)
-                }
-                Condition::Filter(_) => panic!("Unexpected branching!"),
-                Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
-                    match payload.get_value(&field.key) {
-                        None => true,
-                        Some(value) => match value {
-                            Value::Null => true,
-                            Value::Array(array) => array.is_empty(),
-                            _ => false,
-                        },
-                    }
-                }
-            }
-        };
-
-        check_filter(&checker, query)
+        check_payload(payload, self.id_tracker.borrow().deref(), query, point_id)
     }
 }
 
@@ -162,7 +169,7 @@ mod tests {
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::PayloadStorage;
-    use crate::types::{FieldCondition, GeoBoundingBox, Range, ValuesCount};
+    use crate::types::{FieldCondition, GeoBoundingBox, Range};
     use crate::types::{GeoPoint, PayloadField};
 
     use super::*;
@@ -172,10 +179,11 @@ mod tests {
         let dir = TempDir::new("payload_dir").unwrap();
         let dir_id_tracker = TempDir::new("id_tracker_dir").unwrap();
 
-        let payload: Payload = json!({
-            "location":{
-                "lon": 13.404954,
-                "lat": 52.520008,
+        let payload: Payload = json!(
+            {
+                "location":{
+                    "lon": 13.404954,
+                    "lat": 52.520008,
             },
             "price": 499.90,
             "amount": 10,
@@ -214,41 +222,14 @@ mod tests {
         assert!(!payload_checker.check(0, &is_empty_condition_1));
         assert!(payload_checker.check(0, &is_empty_condition_2));
 
-        let many_value_count_condition =
-            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                "rating".to_string(),
-                ValuesCount {
-                    lt: None,
-                    gt: None,
-                    gte: Some(10),
-                    lte: None,
-                },
-            )));
-
-        let few_value_count_condition =
-            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                "rating".to_string(),
-                ValuesCount {
-                    lt: Some(5),
-                    gt: None,
-                    gte: None,
-                    lte: None,
-                },
-            )));
-
-        assert!(!payload_checker.check(0, &many_value_count_condition));
-        assert!(payload_checker.check(0, &few_value_count_condition));
-
         let match_red = Condition::Field(FieldCondition::new_match(
             "color".to_string(),
             "red".to_owned().into(),
         ));
-
         let match_blue = Condition::Field(FieldCondition::new_match(
             "color".to_string(),
             "blue".to_owned().into(),
         ));
-
         let with_delivery = Condition::Field(FieldCondition::new_match(
             "has_delivery".to_string(),
             true.into(),

commit f7d52244a72bf0f49a662c05a8562d726260b906
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon Apr 11 17:48:07 2022 +0200

    Column oriented filter context (#456)
    
    * [WIP] column oriented filter context
    
    * suggestion
    
    * [WIP] fix lifetimes and add more checkers
    
    * refactor and externd struct filter context
    
    * fmt
    
    * add type alias for the condition checker
    
    * fmt
    
    Co-authored-by: gabriel velo <gabriel.velo@gmail.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index b3e38a9a1..7e9e573fc 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -20,7 +20,7 @@ where
     }
 }
 
-fn check_filter<F>(checker: &F, filter: &Filter) -> bool
+pub fn check_filter<F>(checker: &F, filter: &Filter) -> bool
 where
     F: Fn(&Condition) -> bool,
 {

commit bc6df8bd12327ea3a88aecf94a0a2a26b3b70506
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 19 16:04:55 2022 +0200

    Better use of column index (#461)
    
    * fmt
    
    * remove redundent condition checker
    
    * remove condition_checker from test
    
    * fmt
    
    * enum_dispatch for payload storage
    
    * rm unused imports
    
    * fmt
    
    * replace enum_dispatch with manual stuff
    
    * fmt
    
    * filter optiizer
    
    * cargo fix
    
    * fmt
    
    * refactor callback approach to payload checking
    
    * cargo fix
    
    * cargo fix
    
    * fix
    
    * fmt
    
    * more filtering condition random fixture types
    
    * clippy
    
    * fmt
    
    * restore lost value counts test
    
    * Update lib/segment/src/index/query_optimization/optimized_filter.rs
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 7e9e573fc..d0183c2ff 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,3 +1,4 @@
+use std::cell::RefCell;
 use std::ops::Deref;
 use std::sync::Arc;
 
@@ -6,9 +7,9 @@ use serde_json::Value;
 
 use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::ValueChecker;
-use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
+use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
-use crate::types::{Condition, Filter, IsEmptyCondition, Payload, PointOffsetType};
+use crate::types::{Condition, FieldCondition, Filter, IsEmptyCondition, Payload, PointOffsetType};
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
 where
@@ -62,79 +63,84 @@ where
     }
 }
 
-pub fn check_payload(
-    payload: &Payload,
+pub fn check_payload<'a, F>(
+    get_payload: F,
     id_tracker: &IdTrackerSS,
     query: &Filter,
     point_id: PointOffsetType,
-) -> bool {
-    let checker = |condition: &Condition| {
-        match condition {
-            Condition::Field(field_condition) => {
-                payload.get_value(&field_condition.key).map_or(false, |p| {
-                    let mut res = false;
-                    // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-                    res = res
-                        || field_condition
-                            .r#match
-                            .as_ref()
-                            .map_or(false, |condition| condition.check(p));
-                    res = res
-                        || field_condition
-                            .range
-                            .as_ref()
-                            .map_or(false, |condition| condition.check(p));
-                    res = res
-                        || field_condition
-                            .geo_radius
-                            .as_ref()
-                            .map_or(false, |condition| condition.check(p));
-                    res = res
-                        || field_condition
-                            .geo_bounding_box
-                            .as_ref()
-                            .map_or(false, |condition| condition.check(p));
-                    res = res
-                        || field_condition
-                            .values_count
-                            .as_ref()
-                            .map_or(false, |condition| condition.check(p));
-                    res
-                })
-            }
-            Condition::HasId(has_id) => {
-                let external_id = match id_tracker.external_id(point_id) {
-                    None => return false,
-                    Some(id) => id,
-                };
-                has_id.has_id.contains(&external_id)
-            }
-            Condition::Filter(_) => unreachable!(),
-            Condition::IsEmpty(IsEmptyCondition { is_empty: field }) => {
-                match payload.get_value(&field.key) {
-                    None => true,
-                    Some(value) => match value {
-                        Value::Null => true,
-                        Value::Array(array) => array.is_empty(),
-                        _ => false,
-                    },
-                }
-            }
+) -> bool
+where
+    F: Fn() -> &'a Payload,
+{
+    let checker = |condition: &Condition| match condition {
+        Condition::Field(field_condition) => check_field_condition(field_condition, get_payload()),
+        Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload()),
+        Condition::HasId(has_id) => {
+            let external_id = match id_tracker.external_id(point_id) {
+                None => return false,
+                Some(id) => id,
+            };
+            has_id.has_id.contains(&external_id)
         }
+        Condition::Filter(_) => unreachable!(),
     };
 
     check_filter(&checker, query)
 }
 
+pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload) -> bool {
+    match payload.get_value(&is_empty.is_empty.key) {
+        None => true,
+        Some(value) => match value {
+            Value::Null => true,
+            Value::Array(array) => array.is_empty(),
+            _ => false,
+        },
+    }
+}
+
+pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
+    payload.get_value(&field_condition.key).map_or(false, |p| {
+        let mut res = false;
+        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+        res = res
+            || field_condition
+                .r#match
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .range
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .geo_radius
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .geo_bounding_box
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .values_count
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res
+    })
+}
+
 pub struct SimpleConditionChecker {
-    payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
+    payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     empty_payload: Payload,
 }
 
 impl SimpleConditionChecker {
     pub fn new(
-        payload_storage: Arc<AtomicRefCell<SimplePayloadStorage>>,
+        payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     ) -> Self {
         SimpleConditionChecker {
@@ -148,14 +154,27 @@ impl SimpleConditionChecker {
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
         let payload_storage_guard = self.payload_storage.borrow();
-        let payload_ptr = payload_storage_guard.payload_ptr(point_id);
 
-        let payload = match payload_ptr {
-            None => &self.empty_payload,
-            Some(x) => x,
-        };
-
-        check_payload(payload, self.id_tracker.borrow().deref(), query, point_id)
+        let payload_cell: RefCell<Option<&Payload>> = RefCell::new(None);
+        check_payload(
+            || {
+                if payload_cell.borrow().is_none() {
+                    let payload_ptr = match payload_storage_guard.deref() {
+                        PayloadStorageEnum::InMemoryPayloadStorage(s) => s.payload_ptr(point_id),
+                        PayloadStorageEnum::SimplePayloadStorage(s) => s.payload_ptr(point_id),
+                    };
+
+                    payload_cell.replace(Some(match payload_ptr {
+                        None => &self.empty_payload,
+                        Some(x) => x,
+                    }));
+                }
+                payload_cell.borrow().unwrap()
+            },
+            self.id_tracker.borrow().deref(),
+            query,
+            point_id,
+        )
     }
 }
 
@@ -168,8 +187,9 @@ mod tests {
 
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
+    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
-    use crate::types::{FieldCondition, GeoBoundingBox, Range};
+    use crate::types::{FieldCondition, GeoBoundingBox, Range, ValuesCount};
     use crate::types::{GeoPoint, PayloadField};
 
     use super::*;
@@ -193,7 +213,8 @@ mod tests {
         })
         .into();
 
-        let mut payload_storage = SimplePayloadStorage::open(dir.path()).unwrap();
+        let mut payload_storage: PayloadStorageEnum =
+            SimplePayloadStorage::open(dir.path()).unwrap().into();
         let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
 
         id_tracker.set_link(0.into(), 0).unwrap();
@@ -235,6 +256,31 @@ mod tests {
             true.into(),
         ));
 
+        let many_value_count_condition =
+            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
+                "rating".to_string(),
+                ValuesCount {
+                    lt: None,
+                    gt: None,
+                    gte: Some(10),
+                    lte: None,
+                },
+            )));
+
+        let few_value_count_condition =
+            Filter::new_must(Condition::Field(FieldCondition::new_values_count(
+                "rating".to_string(),
+                ValuesCount {
+                    lt: Some(5),
+                    gt: None,
+                    gte: None,
+                    lte: None,
+                },
+            )));
+
+        assert!(!payload_checker.check(0, &many_value_count_condition));
+        assert!(payload_checker.check(0, &few_value_count_condition));
+
         let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(
             "location".to_string(),
             GeoBoundingBox {

commit effb79733d8936b5a1afb4ab45dba4b355f75999
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Fri May 13 17:06:07 2022 +0400

    Unite rocksdb of segment (#585)
    
    unite rocksdb for segment

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index d0183c2ff..008169bd7 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -185,6 +185,7 @@ mod tests {
     use serde_json::json;
     use tempdir::TempDir;
 
+    use crate::common::rocksdb_operations::open_db;
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
@@ -196,8 +197,8 @@ mod tests {
 
     #[test]
     fn test_condition_checker() {
-        let dir = TempDir::new("payload_dir").unwrap();
-        let dir_id_tracker = TempDir::new("id_tracker_dir").unwrap();
+        let dir = TempDir::new("db_dir").unwrap();
+        let db = open_db(dir.path()).unwrap();
 
         let payload: Payload = json!(
             {
@@ -214,8 +215,8 @@ mod tests {
         .into();
 
         let mut payload_storage: PayloadStorageEnum =
-            SimplePayloadStorage::open(dir.path()).unwrap().into();
-        let mut id_tracker = SimpleIdTracker::open(dir_id_tracker.path()).unwrap();
+            SimplePayloadStorage::open(db.clone()).unwrap().into();
+        let mut id_tracker = SimpleIdTracker::open(db).unwrap();
 
         id_tracker.set_link(0.into(), 0).unwrap();
         id_tracker.set_link(1.into(), 1).unwrap();

commit 1b458780eb196ebbbd7fb1f6c5d85ce3b15adb64
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Wed Jun 1 17:23:34 2022 +0200

    On disk payload storage (#634)
    
    * implement on-disk payload storage
    
    * fmt + clippy
    
    * config param for on-disk payload storage
    
    * upd openapi definitions
    
    * add integration test with on-disk payload
    
    * fix clippy
    
    * review fixes
    
    * fmt

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 008169bd7..93eae9220 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -9,7 +9,9 @@ use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
-use crate::types::{Condition, FieldCondition, Filter, IsEmptyCondition, Payload, PointOffsetType};
+use crate::types::{
+    Condition, FieldCondition, Filter, IsEmptyCondition, OwnedPayloadRef, Payload, PointOffsetType,
+};
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
 where
@@ -70,11 +72,13 @@ pub fn check_payload<'a, F>(
     point_id: PointOffsetType,
 ) -> bool
 where
-    F: Fn() -> &'a Payload,
+    F: Fn() -> OwnedPayloadRef<'a>,
 {
     let checker = |condition: &Condition| match condition {
-        Condition::Field(field_condition) => check_field_condition(field_condition, get_payload()),
-        Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload()),
+        Condition::Field(field_condition) => {
+            check_field_condition(field_condition, get_payload().deref())
+        }
+        Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload().deref()),
         Condition::HasId(has_id) => {
             let external_id = match id_tracker.external_id(point_id) {
                 None => return false,
@@ -155,21 +159,45 @@ impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
         let payload_storage_guard = self.payload_storage.borrow();
 
-        let payload_cell: RefCell<Option<&Payload>> = RefCell::new(None);
+        let payload_ref_cell: RefCell<Option<OwnedPayloadRef>> = RefCell::new(None);
         check_payload(
             || {
-                if payload_cell.borrow().is_none() {
+                if payload_ref_cell.borrow().is_none() {
                     let payload_ptr = match payload_storage_guard.deref() {
-                        PayloadStorageEnum::InMemoryPayloadStorage(s) => s.payload_ptr(point_id),
-                        PayloadStorageEnum::SimplePayloadStorage(s) => s.payload_ptr(point_id),
+                        PayloadStorageEnum::InMemoryPayloadStorage(s) => {
+                            s.payload_ptr(point_id).map(|x| x.into())
+                        }
+                        PayloadStorageEnum::SimplePayloadStorage(s) => {
+                            s.payload_ptr(point_id).map(|x| x.into())
+                        }
+                        PayloadStorageEnum::OnDiskPayloadStorage(s) => {
+                            // Warn: Possible panic here
+                            // Currently, it is possible that `read_payload` fails with Err,
+                            // but it seems like a very rare possibility which might only happen
+                            // if something is wrong with disk or storage is corrupted.
+                            //
+                            // In both cases it means that service can't be of use any longer.
+                            // It is as good as dead. Therefore it is tolerable to just panic here.
+                            // Downside is - API user won't be notified of the failure.
+                            // It will just timeout.
+                            //
+                            // The alternative:
+                            // Rewrite condition checking code to support error reporting.
+                            // Which may lead to slowdown and assumes a lot of changes.
+                            s.read_payload(point_id)
+                                .unwrap_or_else(|err| {
+                                    panic!("Payload storage is corrupted: {}", err)
+                                })
+                                .map(|x| x.into())
+                        }
                     };
 
-                    payload_cell.replace(Some(match payload_ptr {
-                        None => &self.empty_payload,
+                    payload_ref_cell.replace(Some(match payload_ptr {
+                        None => (&self.empty_payload).into(),
                         Some(x) => x,
                     }));
                 }
-                payload_cell.borrow().unwrap()
+                payload_ref_cell.borrow().as_ref().cloned().unwrap()
             },
             self.id_tracker.borrow().deref(),
             query,

commit 026bd040b001f1c66e16fc911322f1f182d1cf0f
Author: Egor Ivkov <e.o.ivkov@gmail.com>
Date:   Fri Jul 15 15:42:25 2022 +0300

    Add import formatting rules (#820)
    
    * Add import formatting rules
    
    * Review fix: update rusty hook

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 93eae9220..15240037c 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -213,15 +213,15 @@ mod tests {
     use serde_json::json;
     use tempdir::TempDir;
 
+    use super::*;
     use crate::common::rocksdb_operations::open_db;
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
-    use crate::types::{FieldCondition, GeoBoundingBox, Range, ValuesCount};
-    use crate::types::{GeoPoint, PayloadField};
-
-    use super::*;
+    use crate::types::{
+        FieldCondition, GeoBoundingBox, GeoPoint, PayloadField, Range, ValuesCount,
+    };
 
     #[test]
     fn test_condition_checker() {

commit 8e1f2ca35322cc699232ec8d8177fe05baae3f98
Author: Russ Cam <russ.cam@forloop.co.uk>
Date:   Wed Aug 10 17:39:21 2022 +1000

    Use tempfile (#922)
    
    This commit replaces tempdir with tempfile.
    tempdir is archived.
    
    Closes #544

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 15240037c..f4a554da1 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -211,7 +211,7 @@ mod tests {
     use std::collections::HashSet;
 
     use serde_json::json;
-    use tempdir::TempDir;
+    use tempfile::Builder;
 
     use super::*;
     use crate::common::rocksdb_operations::open_db;
@@ -225,7 +225,7 @@ mod tests {
 
     #[test]
     fn test_condition_checker() {
-        let dir = TempDir::new("db_dir").unwrap();
+        let dir = Builder::new().prefix("db_dir").tempdir().unwrap();
         let db = open_db(dir.path()).unwrap();
 
         let payload: Payload = json!(

commit f9fb0777a0fa67f3b297140493a3c71a4ef42064
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Mon Aug 22 10:41:08 2022 +0300

    Wrap rocksdb column usages (#951)
    
    * wrap rocksdb column usages
    
    * remove obsolete comments
    
    * are you happy clippy

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index f4a554da1..fd74c5e5a 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -214,7 +214,7 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
-    use crate::common::rocksdb_operations::open_db;
+    use crate::common::rocksdb_wrapper::open_db;
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;

commit f6b21861939744e054a861d9771608b7e6b614e7
Author: Ivan Pleshkov <pleshkov.ivan@gmail.com>
Date:   Sun Sep 11 22:59:23 2022 +0400

    [WIP] Many named vectors per point (#958)
    
    * many named vectors per point (segment-level)
    
    * operation result for dim function
    
    * beautifulized vector name
    
    * fix naming bug
    
    * segment version migration
    
    * fmt
    
    * add segment tests
    
    * are you happy clippy
    
    * fix build
    
    * [WIP] many named vectors per point (collection-level) (#975)
    
    * config and search
    
    * fix placeholders for proxy segment move
    
    * remove VectorType from collection
    
    * are you happy fmt
    
    * vectors in grps messages
    
    * create collections with vectors
    
    * segment holder fixes
    
    * are you happy fmt
    
    * remove default vector name placeholders
    
    * are you happy fmt
    
    * are you happy clippy
    
    * fix build
    
    * fix web api
    
    * are you happy clippy
    
    * are you happy fmt
    
    * record vector&vectors
    
    * openapi update
    
    * fix openapi integration tests
    
    * segment builder fix todo
    
    * vector names for update from segment
    
    * remove unwrap
    
    * backward compatibility
    
    * upd openapi
    
    * backward compatible PointStruct
    
    * upd openapi
    
    * fix record back-comp
    
    * fmt
    
    * vector configuration backward compatibility
    
    * fix vetor storage size estimation
    
    * fmt
    
    * multi-vec segment test + index test
    
    * fmt
    
    * api integration tests
    
    * [WIP] Named vectors struct (#1002)
    
    * move to separate file
    
    * named vectors as struct
    
    * use cow
    
    * fix build
    
    * keys iterator
    
    * avoid copy in PointStruct -> get_vectors
    
    * avoid another copy
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index fd74c5e5a..39f7da243 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -214,7 +214,7 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
-    use crate::common::rocksdb_wrapper::open_db;
+    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
@@ -226,7 +226,7 @@ mod tests {
     #[test]
     fn test_condition_checker() {
         let dir = Builder::new().prefix("db_dir").tempdir().unwrap();
-        let db = open_db(dir.path()).unwrap();
+        let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
 
         let payload: Payload = json!(
             {

commit 66aa2c99cedbdc31648feb0b28cb469d7021bef4
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Jan 26 17:48:52 2023 +0100

    Clippy rust 1.67 (#1406)
    
    * inline format! args
    
    * inline format! args
    
    * explicit lifetime could be elided
    
    * fmt

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 39f7da243..c9f09fdf0 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -185,9 +185,7 @@ impl ConditionChecker for SimpleConditionChecker {
                             // Rewrite condition checking code to support error reporting.
                             // Which may lead to slowdown and assumes a lot of changes.
                             s.read_payload(point_id)
-                                .unwrap_or_else(|err| {
-                                    panic!("Payload storage is corrupted: {}", err)
-                                })
+                                .unwrap_or_else(|err| panic!("Payload storage is corrupted: {err}"))
                                 .map(|x| x.into())
                         }
                     };

commit 3ad2e86e5ec314145e806c4def21a96632e3d298
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Fri Feb 17 17:41:28 2023 +0100

    Access payload key through nested Array (#1465)
    
    * Access payload key through nested Array
    
    * support removal through array index
    
    * propagate type changes
    
    * fmt
    
    * avoid allocating Vec of one element

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index c9f09fdf0..f1a8bf583 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -93,7 +93,8 @@ where
 }
 
 pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload) -> bool {
-    match payload.get_value(&is_empty.is_empty.key) {
+    // TODO handle more than first value
+    match payload.get_value(&is_empty.is_empty.key).first() {
         None => true,
         Some(value) => match value {
             Value::Null => true,
@@ -104,36 +105,39 @@ pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload)
 }
 
 pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
-    payload.get_value(&field_condition.key).map_or(false, |p| {
-        let mut res = false;
-        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-        res = res
-            || field_condition
-                .r#match
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .range
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .geo_radius
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .geo_bounding_box
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .values_count
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res
-    })
+    payload
+        .get_value(&field_condition.key)
+        .first() // TODO handle more than first value
+        .map_or(false, |p| {
+            let mut res = false;
+            // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+            res = res
+                || field_condition
+                    .r#match
+                    .as_ref()
+                    .map_or(false, |condition| condition.check(p));
+            res = res
+                || field_condition
+                    .range
+                    .as_ref()
+                    .map_or(false, |condition| condition.check(p));
+            res = res
+                || field_condition
+                    .geo_radius
+                    .as_ref()
+                    .map_or(false, |condition| condition.check(p));
+            res = res
+                || field_condition
+                    .geo_bounding_box
+                    .as_ref()
+                    .map_or(false, |condition| condition.check(p));
+            res = res
+                || field_condition
+                    .values_count
+                    .as_ref()
+                    .map_or(false, |condition| condition.check(p));
+            res
+        })
 }
 
 pub struct SimpleConditionChecker {

commit 3d8b5131bd54079a534f840eaf0f69e570a68517
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Feb 23 15:57:12 2023 +0100

    Nested payload filters (#1487)
    
    * Nested payload filters
    
    * close ToDo + add parsing of multuiple array values
    
    * fmt
    
    * improve testing nested arrays
    
    * fix NumericIndex to accumulate points_to_values mapping
    
    * revert numberic index + strict array field access
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index f1a8bf583..7d1948b60 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -3,7 +3,6 @@ use std::ops::Deref;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
-use serde_json::Value;
 
 use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::ValueChecker;
@@ -93,51 +92,45 @@ where
 }
 
 pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload) -> bool {
-    // TODO handle more than first value
-    match payload.get_value(&is_empty.is_empty.key).first() {
-        None => true,
-        Some(value) => match value {
-            Value::Null => true,
-            Value::Array(array) => array.is_empty(),
-            _ => false,
-        },
-    }
+    payload.get_value(&is_empty.is_empty.key).is_empty()
 }
 
 pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
-    payload
-        .get_value(&field_condition.key)
-        .first() // TODO handle more than first value
-        .map_or(false, |p| {
-            let mut res = false;
-            // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-            res = res
-                || field_condition
-                    .r#match
-                    .as_ref()
-                    .map_or(false, |condition| condition.check(p));
-            res = res
-                || field_condition
-                    .range
-                    .as_ref()
-                    .map_or(false, |condition| condition.check(p));
-            res = res
-                || field_condition
-                    .geo_radius
-                    .as_ref()
-                    .map_or(false, |condition| condition.check(p));
-            res = res
-                || field_condition
-                    .geo_bounding_box
-                    .as_ref()
-                    .map_or(false, |condition| condition.check(p));
-            res = res
-                || field_condition
-                    .values_count
-                    .as_ref()
-                    .map_or(false, |condition| condition.check(p));
-            res
-        })
+    let field_values = payload.get_value(&field_condition.key);
+    if field_values.is_empty() {
+        return false;
+    }
+
+    let mut res = false;
+    for p in field_values {
+        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
+        res = res
+            || field_condition
+                .r#match
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .range
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .geo_radius
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .geo_bounding_box
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+        res = res
+            || field_condition
+                .values_count
+                .as_ref()
+                .map_or(false, |condition| condition.check(p));
+    }
+    res
 }
 
 pub struct SimpleConditionChecker {

commit 2ddce557b247226dc0c4872d50851aebb95ec562
Author: Ibrahim M. Akrab <ibrahim.m.akrab@gmail.com>
Date:   Sat Apr 1 20:46:50 2023 +0200

    add `isNull` condition for payload filtering (#1617)
    
    * add minimal working is_null filter
    
    * add is_null condition to grpc api (backward compatible)
    
    * add unit tests is_null and is_empty conditions
    
    * add is_null to  points.proto file
    
    * add some failing OpenAPI tests
    
    * fix a failing test due to change in collection data
    
    * refactor MultiValue's check for is_null
    
    * fix is_empty condition not picking up "key":[]
    
    * remove duplicate OpenAPI integration test
    
    * reuse same variable in condition checker tests
    
    * update grpc docs
    
    * fix is_null cardinality estimation to match is_empty
    
    * update openapi specs
    
    * remove unused debug statements
    
    * add new test points to original test_collection
    
    * fix failing tests according to newly added points
    
    * add the `"key":[null]` test_case

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 7d1948b60..3b704bbdb 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -9,7 +9,8 @@ use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
-    Condition, FieldCondition, Filter, IsEmptyCondition, OwnedPayloadRef, Payload, PointOffsetType,
+    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, OwnedPayloadRef, Payload,
+    PointOffsetType,
 };
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
@@ -78,6 +79,7 @@ where
             check_field_condition(field_condition, get_payload().deref())
         }
         Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload().deref()),
+        Condition::IsNull(is_null) => check_is_null_condition(is_null, get_payload().deref()),
         Condition::HasId(has_id) => {
             let external_id = match id_tracker.external_id(point_id) {
                 None => return false,
@@ -92,7 +94,11 @@ where
 }
 
 pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload) -> bool {
-    payload.get_value(&is_empty.is_empty.key).is_empty()
+    payload.get_value(&is_empty.is_empty.key).check_is_empty()
+}
+
+pub fn check_is_null_condition(is_null: &IsNullCondition, payload: &Payload) -> bool {
+    payload.get_value(&is_null.is_null.key).check_is_null()
 }
 
 pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
@@ -234,6 +240,9 @@ mod tests {
             "rating": vec![3, 7, 9, 9],
             "color": "red",
             "has_delivery": true,
+            "parts": [],
+            "packaging": null,
+            "not_null": [null]
         })
         .into();
 
@@ -252,20 +261,68 @@ mod tests {
             Arc::new(AtomicRefCell::new(id_tracker)),
         );
 
-        let is_empty_condition_1 = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
                 key: "price".to_string(),
             },
         }));
+        assert!(!payload_checker.check(0, &is_empty_condition));
 
-        let is_empty_condition_2 = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
                 key: "something_new".to_string(),
             },
         }));
+        assert!(payload_checker.check(0, &is_empty_condition));
+
+        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+            is_empty: PayloadField {
+                key: "parts".to_string(),
+            },
+        }));
+        assert!(payload_checker.check(0, &is_empty_condition));
+
+        let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
+            is_empty: PayloadField {
+                key: "not_null".to_string(),
+            },
+        }));
+        assert!(!payload_checker.check(0, &is_empty_condition));
 
-        assert!(!payload_checker.check(0, &is_empty_condition_1));
-        assert!(payload_checker.check(0, &is_empty_condition_2));
+        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
+            is_null: PayloadField {
+                key: "amount".to_string(),
+            },
+        }));
+        assert!(!payload_checker.check(0, &is_null_condition));
+
+        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
+            is_null: PayloadField {
+                key: "parts".to_string(),
+            },
+        }));
+        assert!(!payload_checker.check(0, &is_null_condition));
+
+        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
+            is_null: PayloadField {
+                key: "something_else".to_string(),
+            },
+        }));
+        assert!(!payload_checker.check(0, &is_null_condition));
+
+        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
+            is_null: PayloadField {
+                key: "packaging".to_string(),
+            },
+        }));
+        assert!(payload_checker.check(0, &is_null_condition));
+
+        let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
+            is_null: PayloadField {
+                key: "not_null".to_string(),
+            },
+        }));
+        assert!(!payload_checker.check(0, &is_null_condition));
 
         let match_red = Condition::Field(FieldCondition::new_match(
             "color".to_string(),
@@ -290,6 +347,7 @@ mod tests {
                     lte: None,
                 },
             )));
+        assert!(!payload_checker.check(0, &many_value_count_condition));
 
         let few_value_count_condition =
             Filter::new_must(Condition::Field(FieldCondition::new_values_count(
@@ -301,8 +359,6 @@ mod tests {
                     lte: None,
                 },
             )));
-
-        assert!(!payload_checker.check(0, &many_value_count_condition));
         assert!(payload_checker.check(0, &few_value_count_condition));
 
         let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(

commit 0a8973c85df89161dc774b33fa9c01f99abf41ba
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Apr 11 18:19:28 2023 +0200

    make is-empty condition consistent with all other conditions (#1698)
    
    * make is-empty condition consistent with all other conditions
    
    * review and clippy

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 3b704bbdb..fbb6b4f87 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -103,9 +103,6 @@ pub fn check_is_null_condition(is_null: &IsNullCondition, payload: &Payload) ->
 
 pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
     let field_values = payload.get_value(&field_condition.key);
-    if field_values.is_empty() {
-        return false;
-    }
 
     let mut res = false;
     for p in field_values {

commit 0f0c213c2a94ee387a40e5309c3ae15e0e2c7c96
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed May 10 14:20:12 2023 +0200

    Nested object filter (#1602)
    
    * nested object filter
    
    * code review
    
    * add support for must_not in nested
    
    * extract functions
    
    * support and test must_not in SimpleConditionChecker
    
    * add index matching unit test (to be continued)
    
    * remove extra clone
    
    * test with should
    
    * WIP: Nested object filter suggestions (#1855)
    
    * switch to bitvec
    
    * fix clippy
    
    * more tests
    
    * fmt
    
    * fix some tests
    
    * add test with text
    
    * support for nested should
    
    * do not rely on indexes for nested queries & fix test
    
    * use index to make index-aware checks in nested payload
    
    * fix value-count tests
    
    * re-fa-cto-ring
    
    * fmt
    
    ---------
    
    Co-authored-by: Arnaud Gourlay <arnaud.gourlay@gmail.com>
    
    ---------
    
    Co-authored-by: Andrey Vasnetsov <andrey@vasnetsov.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index fbb6b4f87..490fadc9f 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -4,8 +4,10 @@ use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 
+use crate::common::utils::JsonPathPayload;
 use crate::id_tracker::IdTrackerSS;
 use crate::payload_storage::condition_checker::ValueChecker;
+use crate::payload_storage::nested_query_checker::check_nested_filter;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
@@ -87,6 +89,11 @@ where
             };
             has_id.has_id.contains(&external_id)
         }
+        Condition::Nested(nested) => {
+            let nested_filter = nested.filter();
+            let nested_path = JsonPathPayload::new(nested.array_key());
+            check_nested_filter(&nested_path, nested_filter, &get_payload)
+        }
         Condition::Filter(_) => unreachable!(),
     };
 
@@ -106,36 +113,12 @@ pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload
 
     let mut res = false;
     for p in field_values {
-        // ToDo: Convert onto iterator over checkers, so it would be impossible to forget a condition
-        res = res
-            || field_condition
-                .r#match
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .range
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .geo_radius
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .geo_bounding_box
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
-        res = res
-            || field_condition
-                .values_count
-                .as_ref()
-                .map_or(false, |condition| condition.check(p));
+        res |= field_condition.check(p);
     }
     res
 }
 
+/// Only used for testing
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,

commit 2e5e0292cceb8fa23e8952568892029bf7a6a16e
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Mon May 22 20:08:12 2023 +0200

    Rewrite nested filters again (#1935)
    
    * working nested filters
    
    * rm unused file
    
    * add comment example
    
    * todo
    
    * remove nester checkers
    
    * Box recursive generic Fn types
    
    * Box recursive generic Fn types [2/2]
    
    * Add optional ID tracker to check_payload, remove boxed closure (#1939)
    
    * Add optional ID tracker to check_payload, remove boxed closure
    
    * Replace some match with or_else
    
    * Some nested filter improvements (#1940)
    
    * Replace starts_with/substring with strip_prefix
    
    * Transform for-if-let-check-return into any iterator
    
    * Transform for-if-return into any iterator
    
    * Add comment to describe why check_payload has no ID tracker
    
    See: https://github.com/qdrant/qdrant/pull/1935#discussion_r1200437675
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Luis Coss√≠o <luis.cossio@qdrant.com>
    
    * Update lib/segment/src/payload_storage/query_checker.rs
    
    Co-authored-by: Luis Coss√≠o <luis.cossio@qdrant.com>
    
    * fix clippy
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>
    Co-authored-by: Tim Vis√©e <tim+github@visee.me>
    Co-authored-by: Luis Coss√≠o <luis.cossio@qdrant.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 490fadc9f..2ecec4b37 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,18 +1,19 @@
 use std::cell::RefCell;
+use std::collections::HashMap;
 use std::ops::Deref;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
 
-use crate::common::utils::JsonPathPayload;
+use crate::common::utils::IndexesMap;
 use crate::id_tracker::IdTrackerSS;
+use crate::index::field_index::FieldIndex;
 use crate::payload_storage::condition_checker::ValueChecker;
-use crate::payload_storage::nested_query_checker::check_nested_filter;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, OwnedPayloadRef, Payload,
-    PointOffsetType,
+    PayloadContainer, PayloadKeyType, PointOffsetType,
 };
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
@@ -67,32 +68,60 @@ where
     }
 }
 
-pub fn check_payload<'a, F>(
-    get_payload: F,
-    id_tracker: &IdTrackerSS,
+pub fn select_nested_indexes<'a, R>(
+    nested_path: &str,
+    field_indexes: &'a HashMap<PayloadKeyType, R>,
+) -> HashMap<PayloadKeyType, &'a Vec<FieldIndex>>
+where
+    R: AsRef<Vec<FieldIndex>>,
+{
+    let nested_prefix = format!("{}.", nested_path);
+    let nested_indexes: HashMap<_, _> = field_indexes
+        .iter()
+        .filter_map(|(key, indexes)| {
+            key.strip_prefix(&nested_prefix)
+                .map(|key| (key.into(), indexes.as_ref()))
+        })
+        .collect();
+    nested_indexes
+}
+
+pub fn check_payload<'a, R>(
+    get_payload: Box<dyn Fn() -> OwnedPayloadRef<'a> + 'a>,
+    id_tracker: Option<&IdTrackerSS>,
     query: &Filter,
     point_id: PointOffsetType,
+    field_indexes: &HashMap<PayloadKeyType, R>,
 ) -> bool
 where
-    F: Fn() -> OwnedPayloadRef<'a>,
+    R: AsRef<Vec<FieldIndex>>,
 {
     let checker = |condition: &Condition| match condition {
         Condition::Field(field_condition) => {
-            check_field_condition(field_condition, get_payload().deref())
+            check_field_condition(field_condition, get_payload().deref(), field_indexes)
         }
         Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload().deref()),
         Condition::IsNull(is_null) => check_is_null_condition(is_null, get_payload().deref()),
-        Condition::HasId(has_id) => {
-            let external_id = match id_tracker.external_id(point_id) {
-                None => return false,
-                Some(id) => id,
-            };
-            has_id.has_id.contains(&external_id)
-        }
+        Condition::HasId(has_id) => id_tracker
+            .and_then(|id_tracker| id_tracker.external_id(point_id))
+            .map_or(false, |id| has_id.has_id.contains(&id)),
         Condition::Nested(nested) => {
-            let nested_filter = nested.filter();
-            let nested_path = JsonPathPayload::new(nested.array_key());
-            check_nested_filter(&nested_path, nested_filter, &get_payload)
+            let nested_path = nested.array_key();
+            let nested_indexes = select_nested_indexes(&nested_path, field_indexes);
+            get_payload()
+                .get_value(&nested_path)
+                .values()
+                .iter()
+                .filter_map(|value| value.as_object())
+                .any(|object| {
+                    check_payload(
+                        Box::new(|| OwnedPayloadRef::from(object)),
+                        None,
+                        &nested.nested.filter,
+                        point_id,
+                        &nested_indexes,
+                    )
+                })
         }
         Condition::Filter(_) => unreachable!(),
     };
@@ -100,22 +129,57 @@ where
     check_filter(&checker, query)
 }
 
-pub fn check_is_empty_condition(is_empty: &IsEmptyCondition, payload: &Payload) -> bool {
+pub fn check_is_empty_condition(
+    is_empty: &IsEmptyCondition,
+    payload: &impl PayloadContainer,
+) -> bool {
     payload.get_value(&is_empty.is_empty.key).check_is_empty()
 }
 
-pub fn check_is_null_condition(is_null: &IsNullCondition, payload: &Payload) -> bool {
+pub fn check_is_null_condition(is_null: &IsNullCondition, payload: &impl PayloadContainer) -> bool {
     payload.get_value(&is_null.is_null.key).check_is_null()
 }
 
-pub fn check_field_condition(field_condition: &FieldCondition, payload: &Payload) -> bool {
+pub fn check_field_condition<R>(
+    field_condition: &FieldCondition,
+    payload: &impl PayloadContainer,
+    field_indexes: &HashMap<PayloadKeyType, R>,
+) -> bool
+where
+    R: AsRef<Vec<FieldIndex>>,
+{
     let field_values = payload.get_value(&field_condition.key);
-
-    let mut res = false;
-    for p in field_values {
-        res |= field_condition.check(p);
+    let field_indexes = field_indexes.get(&field_condition.key);
+
+    // This covers a case, when a field index affects the result of the condition.
+    if let Some(field_indexes) = field_indexes {
+        for p in field_values {
+            let mut index_checked = false;
+            for index in field_indexes.as_ref() {
+                if let Some(index_check_res) = index.check_condition(field_condition, p) {
+                    if index_check_res {
+                        // If at least one object matches the condition, we can return true
+                        return true;
+                    }
+                    index_checked = true;
+                    // If index check of the condition returned something, we don't need to check
+                    // other indexes
+                    break;
+                }
+            }
+            if !index_checked {
+                // If none of the indexes returned anything, we need to check the condition
+                // against the payload
+                if field_condition.check(p) {
+                    return true;
+                }
+            }
+        }
+        false
+    } else {
+        // Fallback to regular condition check if there are no indexes for the field
+        field_values.into_iter().any(|p| field_condition.check(p))
     }
-    res
 }
 
 /// Only used for testing
@@ -143,8 +207,10 @@ impl ConditionChecker for SimpleConditionChecker {
         let payload_storage_guard = self.payload_storage.borrow();
 
         let payload_ref_cell: RefCell<Option<OwnedPayloadRef>> = RefCell::new(None);
+        let id_tracker = self.id_tracker.borrow();
+
         check_payload(
-            || {
+            Box::new(|| {
                 if payload_ref_cell.borrow().is_none() {
                     let payload_ptr = match payload_storage_guard.deref() {
                         PayloadStorageEnum::InMemoryPayloadStorage(s) => {
@@ -173,16 +239,15 @@ impl ConditionChecker for SimpleConditionChecker {
                         }
                     };
 
-                    payload_ref_cell.replace(Some(match payload_ptr {
-                        None => (&self.empty_payload).into(),
-                        Some(x) => x,
-                    }));
+                    payload_ref_cell
+                        .replace(payload_ptr.or_else(|| Some((&self.empty_payload).into())));
                 }
                 payload_ref_cell.borrow().as_ref().cloned().unwrap()
-            },
-            self.id_tracker.borrow().deref(),
+            }),
+            Some(id_tracker.deref()),
             query,
             point_id,
+            &IndexesMap::new(),
         )
     }
 }

commit 0d4a3736590dc33b39db2aeea0a799c05ec632f3
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Thu Sep 28 12:11:29 2023 +0200

    Move ScoredPointOffset into common (#2734)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 2ecec4b37..a3d0fcc96 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -4,6 +4,7 @@ use std::ops::Deref;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::types::PointOffsetType;
 
 use crate::common::utils::IndexesMap;
 use crate::id_tracker::IdTrackerSS;
@@ -13,7 +14,7 @@ use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, OwnedPayloadRef, Payload,
-    PayloadContainer, PayloadKeyType, PointOffsetType,
+    PayloadContainer, PayloadKeyType,
 };
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool

commit 2f76603ddfbe5f995443c1e5e85c2d9345a55db0
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Wed Jan 31 10:14:31 2024 +0000

    DateTime payload index (#3395)
    
    * Datetime payload index
    
    * Introduce IndexMapItem
    
    * Drop FieldIndex::DatetimeIndex
    
    * Rename OpenAPI struct names
    
    * Switch to microseconds
    
    * Validate and serialize grpc timestamps
    
    * Add tests with different timezones
    
    * minor review fixes
    
    * Revert "Drop FieldIndex::DatetimeIndex"
    
    This reverts commit d55f251afdbb418ef732a3e6799b92f924fc3035.
    
    * Revert "Introduce IndexMapItem"
    
    This reverts commit c5255f6b1aafa2b9552bac5d1811f9e826eb8d61.
    
    * fix: back to microseconds after reverts
    
    * extract range conversion from boxed checker fn
    
    * add log to deps
    
    * don't run macro doctest
    
    * no_run -> ignore
    
    * remove prost-types in favor of prost-wkt-types
    
    * better assertion on test_payload_indexing.py
    
    * propagate unparsable datetime
    
    ---------
    
    Co-authored-by: Luis Coss√≠o <luis.cossio@outlook.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index a3d0fcc96..c1811496d 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -286,6 +286,7 @@ mod tests {
             "rating": vec![3, 7, 9, 9],
             "color": "red",
             "has_delivery": true,
+            "shipped_at": "2020-02-15T00:00:00Z",
             "parts": [],
             "packaging": null,
             "not_null": [null]
@@ -378,6 +379,40 @@ mod tests {
             "color".to_string(),
             "blue".to_owned().into(),
         ));
+        let shipped_in_february = Condition::Field(FieldCondition::new_datetime_range(
+            "shipped_at".to_string(),
+            Range {
+                lt: Some(
+                    chrono::DateTime::parse_from_rfc3339("2020-03-01T00:00:00Z")
+                        .unwrap()
+                        .into(),
+                ),
+                gt: None,
+                gte: Some(
+                    chrono::DateTime::parse_from_rfc3339("2020-02-01T00:00:00Z")
+                        .unwrap()
+                        .into(),
+                ),
+                lte: None,
+            },
+        ));
+        let shipped_in_march = Condition::Field(FieldCondition::new_datetime_range(
+            "shipped_at".to_string(),
+            Range {
+                lt: Some(
+                    chrono::DateTime::parse_from_rfc3339("2020-04-01T00:00:00Z")
+                        .unwrap()
+                        .into(),
+                ),
+                gt: None,
+                gte: Some(
+                    chrono::DateTime::parse_from_rfc3339("2020-03-01T00:00:00Z")
+                        .unwrap()
+                        .into(),
+                ),
+                lte: None,
+            },
+        ));
         let with_delivery = Condition::Field(FieldCondition::new_match(
             "has_delivery".to_string(),
             true.into(),
@@ -523,6 +558,19 @@ mod tests {
         };
         assert!(payload_checker.check(0, &query));
 
+        let query = Filter {
+            should: None,
+            must: Some(vec![shipped_in_february]),
+            must_not: None,
+        };
+        assert!(payload_checker.check(0, &query));
+        let query = Filter {
+            should: None,
+            must: Some(vec![shipped_in_march]),
+            must_not: None,
+        };
+        assert!(!payload_checker.check(0, &query));
+
         let query = Filter {
             should: None,
             must: None,

commit 112b5d66f32d24dd9a064e286567fa7aa810eac5
Author: ding-young <lsyhime@snu.ac.kr>
Date:   Mon Feb 12 00:43:43 2024 +0900

    Support Min should clause (#3331) (#3466)
    
    * Add min_should field in Filter struct
    
    * min_should clause checks whether at least given number (min_count) of conditions are met
    * modify test cases due to change in Filter struct (set min_should: None)
    * add simple condition check unit test
    * docs, cardinality estimation, grpc not implemented yet
    
    * Add min_should field in Filter struct
    
    * min_should clause checks whether at least given number (min_count) of conditions are met
    * modify test cases due to change in Filter struct (set min_should: None)
    * add simple condition check unit test
    
    * Impl min_should clause in REST API
    
    * perform cardinality estimation by estimating cardinalities of intersection and combining as union
    * add openapi spec with docs update
    * add integration test
    
    * Impl min_should clause in gRPC
    
    * Cargo fmt & clippy
    
    * Fix minor comments
    
    * add equivalence test between min_should and must
    
    * shortcut at min_count matches
    
    * use `Filter::new_*` whenever possible
    
    * Add missing min_should field
    
    * Fix gRPC field ordering & remove deny_unknown_fields
    
    * Empty commit
    
    ---------
    
    Co-authored-by: Luis Coss√≠o <luis.cossio@outlook.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index c1811496d..1748e3bc3 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -13,8 +13,8 @@ use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
-    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, OwnedPayloadRef, Payload,
-    PayloadContainer, PayloadKeyType,
+    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, MinShould,
+    OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType,
 };
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
@@ -32,6 +32,7 @@ where
     F: Fn(&Condition) -> bool,
 {
     check_should(checker, &filter.should)
+        && check_min_should(checker, &filter.min_should)
         && check_must(checker, &filter.must)
         && check_must_not(checker, &filter.must_not)
 }
@@ -47,6 +48,27 @@ where
     }
 }
 
+fn check_min_should<F>(checker: &F, min_should: &Option<MinShould>) -> bool
+where
+    F: Fn(&Condition) -> bool,
+{
+    let check = |x| check_condition(checker, x);
+    match min_should {
+        None => true,
+        Some(MinShould {
+            conditions,
+            min_count,
+        }) => {
+            conditions
+                .iter()
+                .filter(|cond| check(cond))
+                .take(*min_count)
+                .count()
+                == *min_count
+        }
+    }
+}
+
 fn check_must<F>(checker: &F, must: &Option<Vec<Condition>>) -> bool
 where
     F: Fn(&Condition) -> bool,
@@ -480,36 +502,21 @@ mod tests {
             },
         ));
 
-        let query = Filter {
-            should: None,
-            must: Some(vec![match_red.clone()]),
-            must_not: None,
-        };
+        let query = Filter::new_must(match_red.clone());
         assert!(payload_checker.check(0, &query));
 
-        let query = Filter {
-            should: None,
-            must: Some(vec![match_blue.clone()]),
-            must_not: None,
-        };
+        let query = Filter::new_must(match_blue.clone());
         assert!(!payload_checker.check(0, &query));
 
-        let query = Filter {
-            should: None,
-            must: None,
-            must_not: Some(vec![match_blue.clone()]),
-        };
+        let query = Filter::new_must_not(match_blue.clone());
         assert!(payload_checker.check(0, &query));
 
-        let query = Filter {
-            should: None,
-            must: None,
-            must_not: Some(vec![match_red.clone()]),
-        };
+        let query = Filter::new_must_not(match_red.clone());
         assert!(!payload_checker.check(0, &query));
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
+            min_should: None,
             must: Some(vec![with_delivery.clone(), in_berlin.clone()]),
             must_not: None,
         };
@@ -517,6 +524,7 @@ mod tests {
 
         let query = Filter {
             should: Some(vec![match_red.clone(), match_blue.clone()]),
+            min_should: None,
             must: Some(vec![with_delivery, in_moscow.clone()]),
             must_not: None,
         };
@@ -526,15 +534,18 @@ mod tests {
             should: Some(vec![
                 Condition::Filter(Filter {
                     should: None,
+                    min_should: None,
                     must: Some(vec![match_red.clone(), in_moscow.clone()]),
                     must_not: None,
                 }),
                 Condition::Filter(Filter {
                     should: None,
+                    min_should: None,
                     must: Some(vec![match_blue.clone(), in_berlin.clone()]),
                     must_not: None,
                 }),
             ]),
+            min_should: None,
             must: None,
             must_not: None,
         };
@@ -544,65 +555,79 @@ mod tests {
             should: Some(vec![
                 Condition::Filter(Filter {
                     should: None,
-                    must: Some(vec![match_blue, in_moscow]),
+                    min_should: None,
+                    must: Some(vec![match_blue.clone(), in_moscow.clone()]),
                     must_not: None,
                 }),
                 Condition::Filter(Filter {
                     should: None,
-                    must: Some(vec![match_red, in_berlin]),
+                    min_should: None,
+                    must: Some(vec![match_red.clone(), in_berlin.clone()]),
                     must_not: None,
                 }),
             ]),
+            min_should: None,
             must: None,
             must_not: None,
         };
         assert!(payload_checker.check(0, &query));
 
-        let query = Filter {
-            should: None,
-            must: Some(vec![shipped_in_february]),
-            must_not: None,
-        };
-        assert!(payload_checker.check(0, &query));
-        let query = Filter {
-            should: None,
-            must: Some(vec![shipped_in_march]),
-            must_not: None,
-        };
+        let query = Filter::new_must_not(with_bad_rating);
         assert!(!payload_checker.check(0, &query));
 
-        let query = Filter {
-            should: None,
-            must: None,
-            must_not: Some(vec![with_bad_rating]),
-        };
+        // min_should
+        let query = Filter::new_min_should(MinShould {
+            conditions: vec![match_blue.clone(), in_moscow.clone()],
+            min_count: 1,
+        });
+        assert!(!payload_checker.check(0, &query));
+
+        let query = Filter::new_min_should(MinShould {
+            conditions: vec![match_red.clone(), in_berlin.clone(), in_moscow.clone()],
+            min_count: 2,
+        });
+        assert!(payload_checker.check(0, &query));
+
+        let query = Filter::new_min_should(MinShould {
+            conditions: vec![
+                Condition::Filter(Filter {
+                    should: None,
+                    min_should: None,
+                    must: Some(vec![match_blue, in_moscow]),
+                    must_not: None,
+                }),
+                Condition::Filter(Filter {
+                    should: None,
+                    min_should: None,
+                    must: Some(vec![match_red, in_berlin]),
+                    must_not: None,
+                }),
+            ],
+            min_count: 1,
+        });
+        assert!(payload_checker.check(0, &query));
+
+        // DateTime payload index
+        let query = Filter::new_must(shipped_in_february);
+        assert!(payload_checker.check(0, &query));
+
+        let query = Filter::new_must(shipped_in_march);
         assert!(!payload_checker.check(0, &query));
 
+        // id Filter
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
-        let query = Filter {
-            should: None,
-            must: None,
-            must_not: Some(vec![Condition::HasId(ids.into())]),
-        };
+        let query = Filter::new_must_not(Condition::HasId(ids.into()));
         assert!(!payload_checker.check(2, &query));
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
-        let query = Filter {
-            should: None,
-            must: None,
-            must_not: Some(vec![Condition::HasId(ids.into())]),
-        };
+        let query = Filter::new_must_not(Condition::HasId(ids.into()));
         assert!(payload_checker.check(10, &query));
 
         let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
-        let query = Filter {
-            should: None,
-            must: Some(vec![Condition::HasId(ids.into())]),
-            must_not: None,
-        };
+        let query = Filter::new_must(Condition::HasId(ids.into()));
         assert!(payload_checker.check(2, &query));
     }
 }

commit 475c1aadf6fa457212b3e6ed3665c79a88878b4a
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Mon Feb 12 06:24:18 2024 -0300

    refactor: add DateTime wrapper (#3578)
    
    * Refactor datetime deserialization and timestamp representation into newtype
    
    * implement `FromStr` instead of custom fn

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 1748e3bc3..ae5df873c 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -278,6 +278,7 @@ impl ConditionChecker for SimpleConditionChecker {
 #[cfg(test)]
 mod tests {
     use std::collections::HashSet;
+    use std::str::FromStr;
 
     use serde_json::json;
     use tempfile::Builder;
@@ -289,7 +290,7 @@ mod tests {
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::{
-        FieldCondition, GeoBoundingBox, GeoPoint, PayloadField, Range, ValuesCount,
+        DateTimeWrapper, FieldCondition, GeoBoundingBox, GeoPoint, PayloadField, Range, ValuesCount,
     };
 
     #[test]
@@ -404,34 +405,18 @@ mod tests {
         let shipped_in_february = Condition::Field(FieldCondition::new_datetime_range(
             "shipped_at".to_string(),
             Range {
-                lt: Some(
-                    chrono::DateTime::parse_from_rfc3339("2020-03-01T00:00:00Z")
-                        .unwrap()
-                        .into(),
-                ),
+                lt: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
                 gt: None,
-                gte: Some(
-                    chrono::DateTime::parse_from_rfc3339("2020-02-01T00:00:00Z")
-                        .unwrap()
-                        .into(),
-                ),
+                gte: Some(DateTimeWrapper::from_str("2020-02-01T00:00:00Z").unwrap()),
                 lte: None,
             },
         ));
         let shipped_in_march = Condition::Field(FieldCondition::new_datetime_range(
             "shipped_at".to_string(),
             Range {
-                lt: Some(
-                    chrono::DateTime::parse_from_rfc3339("2020-04-01T00:00:00Z")
-                        .unwrap()
-                        .into(),
-                ),
+                lt: Some(DateTimeWrapper::from_str("2020-04-01T00:00:00Z").unwrap()),
                 gt: None,
-                gte: Some(
-                    chrono::DateTime::parse_from_rfc3339("2020-03-01T00:00:00Z")
-                        .unwrap()
-                        .into(),
-                ),
+                gte: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
                 lte: None,
             },
         ));

commit 395a19f2c1fc0266406f23bda3c6f77434188c7a
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Feb 20 23:07:15 2024 +0000

    Use SmallVec instead of MultiValue (#3639)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index ae5df873c..fbff5aed8 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -6,7 +6,7 @@ use std::sync::Arc;
 use atomic_refcell::AtomicRefCell;
 use common::types::PointOffsetType;
 
-use crate::common::utils::IndexesMap;
+use crate::common::utils::{check_is_empty, check_is_null, IndexesMap};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::FieldIndex;
 use crate::payload_storage::condition_checker::ValueChecker;
@@ -133,7 +133,6 @@ where
             let nested_indexes = select_nested_indexes(&nested_path, field_indexes);
             get_payload()
                 .get_value(&nested_path)
-                .values()
                 .iter()
                 .filter_map(|value| value.as_object())
                 .any(|object| {
@@ -156,11 +155,11 @@ pub fn check_is_empty_condition(
     is_empty: &IsEmptyCondition,
     payload: &impl PayloadContainer,
 ) -> bool {
-    payload.get_value(&is_empty.is_empty.key).check_is_empty()
+    check_is_empty(payload.get_value(&is_empty.is_empty.key).iter().copied())
 }
 
 pub fn check_is_null_condition(is_null: &IsNullCondition, payload: &impl PayloadContainer) -> bool {
-    payload.get_value(&is_null.is_null.key).check_is_null()
+    check_is_null(payload.get_value(&is_null.is_null.key).iter().copied())
 }
 
 pub fn check_field_condition<R>(

commit 3beb4e3b4ff4b3f9585337f4e5b0826a14e247b6
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Feb 23 14:38:40 2024 +0000

    Introduce JsonPathString (#3674)
    
    * Introduce JsonPathString
    
    * Fix fomatting

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index fbff5aed8..c8dcaaa73 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -9,6 +9,7 @@ use common::types::PointOffsetType;
 use crate::common::utils::{check_is_empty, check_is_null, IndexesMap};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::FieldIndex;
+use crate::json_path::JsonPathInterface as _;
 use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
@@ -92,18 +93,17 @@ where
 }
 
 pub fn select_nested_indexes<'a, R>(
-    nested_path: &str,
+    nested_path: &PayloadKeyType,
     field_indexes: &'a HashMap<PayloadKeyType, R>,
 ) -> HashMap<PayloadKeyType, &'a Vec<FieldIndex>>
 where
     R: AsRef<Vec<FieldIndex>>,
 {
-    let nested_prefix = format!("{}.", nested_path);
     let nested_indexes: HashMap<_, _> = field_indexes
         .iter()
         .filter_map(|(key, indexes)| {
-            key.strip_prefix(&nested_prefix)
-                .map(|key| (key.into(), indexes.as_ref()))
+            key.strip_prefix(nested_path)
+                .map(|key| (key, indexes.as_ref()))
         })
         .collect();
     nested_indexes
@@ -286,6 +286,7 @@ mod tests {
     use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
+    use crate::json_path::path;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::{
@@ -331,78 +332,72 @@ mod tests {
         );
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: "price".to_string(),
-            },
+            is_empty: PayloadField { key: path("price") },
         }));
         assert!(!payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
-                key: "something_new".to_string(),
+                key: path("something_new"),
             },
         }));
         assert!(payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField {
-                key: "parts".to_string(),
-            },
+            is_empty: PayloadField { key: path("parts") },
         }));
         assert!(payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
-                key: "not_null".to_string(),
+                key: path("not_null"),
             },
         }));
         assert!(!payload_checker.check(0, &is_empty_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: "amount".to_string(),
+                key: path("amount"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField {
-                key: "parts".to_string(),
-            },
+            is_null: PayloadField { key: path("parts") },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: "something_else".to_string(),
+                key: path("something_else"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: "packaging".to_string(),
+                key: path("packaging"),
             },
         }));
         assert!(payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: "not_null".to_string(),
+                key: path("not_null"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let match_red = Condition::Field(FieldCondition::new_match(
-            "color".to_string(),
+            path("color"),
             "red".to_owned().into(),
         ));
         let match_blue = Condition::Field(FieldCondition::new_match(
-            "color".to_string(),
+            path("color"),
             "blue".to_owned().into(),
         ));
         let shipped_in_february = Condition::Field(FieldCondition::new_datetime_range(
-            "shipped_at".to_string(),
+            path("shipped_at"),
             Range {
                 lt: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
                 gt: None,
@@ -411,7 +406,7 @@ mod tests {
             },
         ));
         let shipped_in_march = Condition::Field(FieldCondition::new_datetime_range(
-            "shipped_at".to_string(),
+            path("shipped_at"),
             Range {
                 lt: Some(DateTimeWrapper::from_str("2020-04-01T00:00:00Z").unwrap()),
                 gt: None,
@@ -419,14 +414,12 @@ mod tests {
                 lte: None,
             },
         ));
-        let with_delivery = Condition::Field(FieldCondition::new_match(
-            "has_delivery".to_string(),
-            true.into(),
-        ));
+        let with_delivery =
+            Condition::Field(FieldCondition::new_match(path("has_delivery"), true.into()));
 
         let many_value_count_condition =
             Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                "rating".to_string(),
+                path("rating"),
                 ValuesCount {
                     lt: None,
                     gt: None,
@@ -438,7 +431,7 @@ mod tests {
 
         let few_value_count_condition =
             Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                "rating".to_string(),
+                path("rating"),
                 ValuesCount {
                     lt: Some(5),
                     gt: None,
@@ -449,7 +442,7 @@ mod tests {
         assert!(payload_checker.check(0, &few_value_count_condition));
 
         let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(
-            "location".to_string(),
+            path("location"),
             GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 13.08835,
@@ -463,7 +456,7 @@ mod tests {
         ));
 
         let in_moscow = Condition::Field(FieldCondition::new_geo_bounding_box(
-            "location".to_string(),
+            path("location"),
             GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 37.0366,
@@ -477,7 +470,7 @@ mod tests {
         ));
 
         let with_bad_rating = Condition::Field(FieldCondition::new_range(
-            "rating".to_string(),
+            path("rating"),
             Range {
                 lt: None,
                 gt: None,

commit 8fe5e43764a517b36e1ab013c2dc6505b132a51c
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue May 7 16:14:46 2024 +0000

    Introduce Cargo feature "testing" (#4192)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index c8dcaaa73..3f3fb8365 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -1,3 +1,5 @@
+#![cfg_attr(not(feature = "testing"), allow(unused_imports))]
+
 use std::cell::RefCell;
 use std::collections::HashMap;
 use std::ops::Deref;
@@ -205,12 +207,14 @@ where
 }
 
 /// Only used for testing
+#[cfg(feature = "testing")]
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
     empty_payload: Payload,
 }
 
+#[cfg(feature = "testing")]
 impl SimpleConditionChecker {
     pub fn new(
         payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
@@ -224,6 +228,7 @@ impl SimpleConditionChecker {
     }
 }
 
+#[cfg(feature = "testing")]
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
         let payload_storage_guard = self.payload_storage.borrow();

commit ed4e2fd10679953e9424688d5eb135eb0ab263bd
Author: Roman Titov <ffuugoo@users.noreply.github.com>
Date:   Wed Jun 19 12:14:26 2024 +0200

    Rework `CommitHashRing` consensus message into `CommitRead`/`CommitWrite`/`Finish` (#4417)
    
    * Refactor `CommitHashRing` into `CommitRead`/`CommitWrite`/`Finish`
    
    * Add `Resharding` filter condition
    
    * Filter "resharded" points from search, scroll by, count and retrieve request results
    
    * fixup! Refactor `CommitHashRing` into `CommitRead`/`CommitWrite`/`Finish`
    
    `cargo clippy --fix`
    
    * Apply suggestions from code review
    
    * fixup! Filter "resharded" points from search, scroll by, count and retrieve request results
    
    Add `Condition::is_local_only` method
    
    * fixup! Add `Resharding` filter condition
    
    * fixup! Filter "resharded" points from search, scroll by, count and retrieve request results
    
    Clarified a few `TODO`s
    
    * Fix clippy suggestions
    
    ---------
    
    Co-authored-by: Tim Vis√©e <tim+github@visee.me>
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 3f3fb8365..7b9703257 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -147,6 +147,11 @@ where
                     )
                 })
         }
+
+        Condition::Resharding(cond) => id_tracker
+            .and_then(|id_tracker| id_tracker.external_id(point_id))
+            .map_or(false, |point_id| cond.check(point_id)),
+
         Condition::Filter(_) => unreachable!(),
     };
 

commit 4fdf7152f0977adc07bdf9258109ed8600c13f9f
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Thu Jul 11 04:06:40 2024 +0000

    Drop JsonPathString (#4621)
    
    * drop some code
    
    * Drop JsonPathString
    
    * Fix test_remove_key
    
    Drop failing tests:
    - Deleting array indices is not idempotent, so we don't support it.
    - Empty JSONPath is not supported.
    
    * Make json_path::path() non-generic
    
    * Remove references to JsonPathV2
    
    * Drop JsonPathInterface
    
    * Move json_path::v2 code into json_path
    
    * Drop validate_not_empty
    
    * Drop JsonPath::head() as being unused
    
    * Replace path() with JsonPath::new()
    
    * Restore comments
    
    * Move tests to json_path
    
    * Use json() consistently in tests
    
    * Replace many into calls with Into trait
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 7b9703257..628c95a68 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -11,7 +11,6 @@ use common::types::PointOffsetType;
 use crate::common::utils::{check_is_empty, check_is_null, IndexesMap};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::FieldIndex;
-use crate::json_path::JsonPathInterface as _;
 use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
@@ -296,7 +295,7 @@ mod tests {
     use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
-    use crate::json_path::path;
+    use crate::json_path::JsonPath;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::{
@@ -342,72 +341,78 @@ mod tests {
         );
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField { key: path("price") },
+            is_empty: PayloadField {
+                key: JsonPath::new("price"),
+            },
         }));
         assert!(!payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
-                key: path("something_new"),
+                key: JsonPath::new("something_new"),
             },
         }));
         assert!(payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
-            is_empty: PayloadField { key: path("parts") },
+            is_empty: PayloadField {
+                key: JsonPath::new("parts"),
+            },
         }));
         assert!(payload_checker.check(0, &is_empty_condition));
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {
             is_empty: PayloadField {
-                key: path("not_null"),
+                key: JsonPath::new("not_null"),
             },
         }));
         assert!(!payload_checker.check(0, &is_empty_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: path("amount"),
+                key: JsonPath::new("amount"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
-            is_null: PayloadField { key: path("parts") },
+            is_null: PayloadField {
+                key: JsonPath::new("parts"),
+            },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: path("something_else"),
+                key: JsonPath::new("something_else"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: path("packaging"),
+                key: JsonPath::new("packaging"),
             },
         }));
         assert!(payload_checker.check(0, &is_null_condition));
 
         let is_null_condition = Filter::new_must(Condition::IsNull(IsNullCondition {
             is_null: PayloadField {
-                key: path("not_null"),
+                key: JsonPath::new("not_null"),
             },
         }));
         assert!(!payload_checker.check(0, &is_null_condition));
 
         let match_red = Condition::Field(FieldCondition::new_match(
-            path("color"),
+            JsonPath::new("color"),
             "red".to_owned().into(),
         ));
         let match_blue = Condition::Field(FieldCondition::new_match(
-            path("color"),
+            JsonPath::new("color"),
             "blue".to_owned().into(),
         ));
         let shipped_in_february = Condition::Field(FieldCondition::new_datetime_range(
-            path("shipped_at"),
+            JsonPath::new("shipped_at"),
             Range {
                 lt: Some(DateTimeWrapper::from_str("2020-03-01T00:00:00Z").unwrap()),
                 gt: None,
@@ -416,7 +421,7 @@ mod tests {
             },
         ));
         let shipped_in_march = Condition::Field(FieldCondition::new_datetime_range(
-            path("shipped_at"),
+            JsonPath::new("shipped_at"),
             Range {
                 lt: Some(DateTimeWrapper::from_str("2020-04-01T00:00:00Z").unwrap()),
                 gt: None,
@@ -424,12 +429,14 @@ mod tests {
                 lte: None,
             },
         ));
-        let with_delivery =
-            Condition::Field(FieldCondition::new_match(path("has_delivery"), true.into()));
+        let with_delivery = Condition::Field(FieldCondition::new_match(
+            JsonPath::new("has_delivery"),
+            true.into(),
+        ));
 
         let many_value_count_condition =
             Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                path("rating"),
+                JsonPath::new("rating"),
                 ValuesCount {
                     lt: None,
                     gt: None,
@@ -441,7 +448,7 @@ mod tests {
 
         let few_value_count_condition =
             Filter::new_must(Condition::Field(FieldCondition::new_values_count(
-                path("rating"),
+                JsonPath::new("rating"),
                 ValuesCount {
                     lt: Some(5),
                     gt: None,
@@ -452,7 +459,7 @@ mod tests {
         assert!(payload_checker.check(0, &few_value_count_condition));
 
         let in_berlin = Condition::Field(FieldCondition::new_geo_bounding_box(
-            path("location"),
+            JsonPath::new("location"),
             GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 13.08835,
@@ -466,7 +473,7 @@ mod tests {
         ));
 
         let in_moscow = Condition::Field(FieldCondition::new_geo_bounding_box(
-            path("location"),
+            JsonPath::new("location"),
             GeoBoundingBox {
                 top_left: GeoPoint {
                     lon: 37.0366,
@@ -480,7 +487,7 @@ mod tests {
         ));
 
         let with_bad_rating = Condition::Field(FieldCondition::new_range(
-            path("rating"),
+            JsonPath::new("rating"),
             Range {
                 lt: None,
                 gt: None,

commit 0c23f81e52a62f3a37816a3bdafdc7f82e062d90
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Aug 2 13:48:45 2024 +0200

    Refactor resharding filter (#4799)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 628c95a68..d05d5a239 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -147,7 +147,7 @@ where
                 })
         }
 
-        Condition::Resharding(cond) => id_tracker
+        Condition::CustomIdChecker(cond) => id_tracker
             .and_then(|id_tracker| id_tracker.external_id(point_id))
             .map_or(false, |point_id| cond.check(point_id)),
 

commit 4f59f72c02e6b62f027c88888831c1bf60f24019
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Mon Sep 16 12:42:11 2024 +0200

    Rename payload storage operations for consistency (#5087)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index d05d5a239..91ace212d 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -333,7 +333,7 @@ mod tests {
         id_tracker.set_link(1.into(), 1).unwrap();
         id_tracker.set_link(2.into(), 2).unwrap();
         id_tracker.set_link(10.into(), 10).unwrap();
-        payload_storage.assign_all(0, &payload).unwrap();
+        payload_storage.overwrite(0, &payload).unwrap();
 
         let payload_checker = SimpleConditionChecker::new(
             Arc::new(AtomicRefCell::new(payload_storage)),

commit bcf05d9e231d55f0c4317081c36d3ebc0a2de8c8
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Fri Oct 25 18:47:03 2024 +0200

    HasVector filtering condition (#5303)
    
    * include vector storage into struct vector index
    
    * implement has_vector
    
    * generate schemas
    
    * refactor query filter optimizer so avoid too many function arguments
    
    * test + fix for sparse vectors
    
    * Update lib/segment/src/index/struct_payload_index.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * Update lib/segment/src/index/query_optimization/optimizer.rs
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
    
    * fmt
    
    ---------
    
    Co-authored-by: Jojii <15957865+JojiiOfficial@users.noreply.github.com>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 91ace212d..1a1fa236b 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -16,8 +16,9 @@ use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::ConditionChecker;
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, MinShould,
-    OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType,
+    OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType, VectorName,
 };
+use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
 fn check_condition<F>(checker: &F, condition: &Condition) -> bool
 where
@@ -113,6 +114,7 @@ where
 pub fn check_payload<'a, R>(
     get_payload: Box<dyn Fn() -> OwnedPayloadRef<'a> + 'a>,
     id_tracker: Option<&IdTrackerSS>,
+    vector_storages: &HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
     query: &Filter,
     point_id: PointOffsetType,
     field_indexes: &HashMap<PayloadKeyType, R>,
@@ -129,6 +131,13 @@ where
         Condition::HasId(has_id) => id_tracker
             .and_then(|id_tracker| id_tracker.external_id(point_id))
             .map_or(false, |id| has_id.has_id.contains(&id)),
+        Condition::HasVector(has_vector) => {
+            if let Some(vector_storage) = vector_storages.get(&has_vector.has_vector) {
+                !vector_storage.borrow().is_deleted_vector(point_id)
+            } else {
+                false
+            }
+        }
         Condition::Nested(nested) => {
             let nested_path = nested.array_key();
             let nested_indexes = select_nested_indexes(&nested_path, field_indexes);
@@ -139,7 +148,8 @@ where
                 .any(|object| {
                     check_payload(
                         Box::new(|| OwnedPayloadRef::from(object)),
-                        None,
+                        None,            // HasId check in nested fields is not supported
+                        &HashMap::new(), // HasVector check in nested fields is not supported
                         &nested.nested.filter,
                         point_id,
                         &nested_indexes,
@@ -215,6 +225,7 @@ where
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+    vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
     empty_payload: Payload,
 }
 
@@ -223,10 +234,12 @@ impl SimpleConditionChecker {
     pub fn new(
         payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
+        vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
     ) -> Self {
         SimpleConditionChecker {
             payload_storage,
             id_tracker,
+            vector_storages,
             empty_payload: Default::default(),
         }
     }
@@ -240,6 +253,8 @@ impl ConditionChecker for SimpleConditionChecker {
         let payload_ref_cell: RefCell<Option<OwnedPayloadRef>> = RefCell::new(None);
         let id_tracker = self.id_tracker.borrow();
 
+        let vector_storages = &self.vector_storages;
+
         check_payload(
             Box::new(|| {
                 if payload_ref_cell.borrow().is_none() {
@@ -276,6 +291,7 @@ impl ConditionChecker for SimpleConditionChecker {
                 payload_ref_cell.borrow().as_ref().cloned().unwrap()
             }),
             Some(id_tracker.deref()),
+            vector_storages,
             query,
             point_id,
             &IndexesMap::new(),
@@ -338,6 +354,7 @@ mod tests {
         let payload_checker = SimpleConditionChecker::new(
             Arc::new(AtomicRefCell::new(payload_storage)),
             Arc::new(AtomicRefCell::new(id_tracker)),
+            HashMap::new(),
         );
 
         let is_empty_condition = Filter::new_must(Condition::IsEmpty(IsEmptyCondition {

commit 6c162656f3a23a6e6601a58cf69f44bdcea0ab00
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Wed Nov 13 08:49:42 2024 -0600

    Backward compatibility for mmap payload storage (#5398)
    
    * support mmap storage backward compat
    
    * fix clippy
    
    * review fixes + bump + restore Cargo.lock
    
    * fix clippy
    
    * map_err instead of match
    
    * add sanity tests for payload storage trait
    
    * fix clippy
    
    * error conversion
    
    * test persistance too
    
    * add config to enable mmap storage (#5434)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 1a1fa236b..2de327b25 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -13,7 +13,7 @@ use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::FieldIndex;
 use crate::payload_storage::condition_checker::ValueChecker;
 use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
-use crate::payload_storage::ConditionChecker;
+use crate::payload_storage::{ConditionChecker, PayloadStorage};
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, MinShould,
     OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType, VectorName,
@@ -283,6 +283,12 @@ impl ConditionChecker for SimpleConditionChecker {
                                 .unwrap_or_else(|err| panic!("Payload storage is corrupted: {err}"))
                                 .map(|x| x.into())
                         }
+                        PayloadStorageEnum::MmapPayloadStorage(s) => {
+                            let payload = s.get(point_id).unwrap_or_else(|err| {
+                                panic!("Payload storage is corrupted: {err}")
+                            });
+                            Some(OwnedPayloadRef::from(payload))
+                        }
                     };
 
                     payload_ref_cell

commit f416f2b98f08fc7749814b0725f9035459b5c057
Author: Arnaud Gourlay <arnaud.gourlay@gmail.com>
Date:   Wed Nov 27 11:24:58 2024 +0100

    Clippy 1.83 (#5513)
    
    * Clippy 1.83
    
    * there is more

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 2de327b25..44d3abc4c 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -130,7 +130,7 @@ where
         Condition::IsNull(is_null) => check_is_null_condition(is_null, get_payload().deref()),
         Condition::HasId(has_id) => id_tracker
             .and_then(|id_tracker| id_tracker.external_id(point_id))
-            .map_or(false, |id| has_id.has_id.contains(&id)),
+            .is_some_and(|id| has_id.has_id.contains(&id)),
         Condition::HasVector(has_vector) => {
             if let Some(vector_storage) = vector_storages.get(&has_vector.has_vector) {
                 !vector_storage.borrow().is_deleted_vector(point_id)
@@ -159,7 +159,7 @@ where
 
         Condition::CustomIdChecker(cond) => id_tracker
             .and_then(|id_tracker| id_tracker.external_id(point_id))
-            .map_or(false, |point_id| cond.check(point_id)),
+            .is_some_and(|point_id| cond.check(point_id)),
 
         Condition::Filter(_) => unreachable!(),
     };

commit 681506cea7bd6bf7ae80114775f39580ee8392e8
Author: Luis Coss√≠o <luis.cossio@qdrant.com>
Date:   Mon Dec 16 23:35:10 2024 +0000

    Integrate mmap bool index (#5571)
    
    * add on_disk option for bool index
    
    * test that all files are covered
    
    * generate openapi and docs
    
    * clippy
    
    * remove `populate` changes
    
    * use `walkdir` crate
    
    * Apply clippy suggestions
    
    ---------
    
    Co-authored-by: timvisee <tim@visee.me>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 44d3abc4c..358f7ad31 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -194,7 +194,7 @@ where
         for p in field_values {
             let mut index_checked = false;
             for index in field_indexes.as_ref() {
-                if let Some(index_check_res) = index.check_condition(field_condition, p) {
+                if let Some(index_check_res) = index.special_check_condition(field_condition, p) {
                     if index_check_res {
                         // If at least one object matches the condition, we can return true
                         return true;

commit b0eb8d3431b19ed8beaeb1ceee7872d07d620314
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 10:58:25 2025 +0100

    Io measurement rename functions (#5816)
    
    * replace _measured functions with original name
    
    * Rename more functions

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 358f7ad31..70ca3a3f6 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -6,6 +6,7 @@ use std::ops::Deref;
 use std::sync::Arc;
 
 use atomic_refcell::AtomicRefCell;
+use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 
 use crate::common::utils::{check_is_empty, check_is_null, IndexesMap};
@@ -248,6 +249,7 @@ impl SimpleConditionChecker {
 #[cfg(feature = "testing")]
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
+        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Propagate this value to caller!
         let payload_storage_guard = self.payload_storage.borrow();
 
         let payload_ref_cell: RefCell<Option<OwnedPayloadRef>> = RefCell::new(None);
@@ -284,7 +286,7 @@ impl ConditionChecker for SimpleConditionChecker {
                                 .map(|x| x.into())
                         }
                         PayloadStorageEnum::MmapPayloadStorage(s) => {
-                            let payload = s.get(point_id).unwrap_or_else(|err| {
+                            let payload = s.get(point_id, &hw_counter).unwrap_or_else(|err| {
                                 panic!("Payload storage is corrupted: {err}")
                             });
                             Some(OwnedPayloadRef::from(payload))

commit c815a1bd43fb326ad2c100b72e9d916b1f3b616e
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Jan 23 12:23:47 2025 +0100

    Implement more IO measurements for PayloadStorage (#5822)
    
    * Finish io measurement for payload storage
    
    * Remove done TODOs
    
    * review remarks
    
    * make signature of `wipe()` consistent
    
    * Remove hardware_counter from tracker.rs and make interfaces consistent
    
    * Add hw_counter to payloads update_storage function from dev

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 70ca3a3f6..8e6b6c493 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -249,7 +249,8 @@ impl SimpleConditionChecker {
 #[cfg(feature = "testing")]
 impl ConditionChecker for SimpleConditionChecker {
     fn check(&self, point_id: PointOffsetType, query: &Filter) -> bool {
-        let hw_counter = HardwareCounterCell::disposable(); // TODO(io_measurement): Propagate this value to caller!
+        let hw_counter = HardwareCounterCell::new(); // No measurements needed as this is only for test!
+
         let payload_storage_guard = self.payload_storage.borrow();
 
         let payload_ref_cell: RefCell<Option<OwnedPayloadRef>> = RefCell::new(None);
@@ -281,7 +282,7 @@ impl ConditionChecker for SimpleConditionChecker {
                             // The alternative:
                             // Rewrite condition checking code to support error reporting.
                             // Which may lead to slowdown and assumes a lot of changes.
-                            s.read_payload(point_id)
+                            s.read_payload(point_id, &hw_counter)
                                 .unwrap_or_else(|err| panic!("Payload storage is corrupted: {err}"))
                                 .map(|x| x.into())
                         }
@@ -349,6 +350,8 @@ mod tests {
         })
         .into();
 
+        let hw_counter = HardwareCounterCell::new();
+
         let mut payload_storage: PayloadStorageEnum =
             SimplePayloadStorage::open(db.clone()).unwrap().into();
         let mut id_tracker = SimpleIdTracker::open(db).unwrap();
@@ -357,7 +360,7 @@ mod tests {
         id_tracker.set_link(1.into(), 1).unwrap();
         id_tracker.set_link(2.into(), 2).unwrap();
         id_tracker.set_link(10.into(), 10).unwrap();
-        payload_storage.overwrite(0, &payload).unwrap();
+        payload_storage.overwrite(0, &payload, &hw_counter).unwrap();
 
         let payload_checker = SimpleConditionChecker::new(
             Arc::new(AtomicRefCell::new(payload_storage)),

commit e85a9f18b4f5219799c3625c2d3d19c5b3be4ed5
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Fri Jan 24 01:29:01 2025 +0000

    Add `VectorName` type alias (#5763)
    
    * Add VectorName/VectorNameBuf type aliases [1/2]
    
    * Add VectorName/VectorNameBuf type aliases [2/2]

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 8e6b6c493..fe03f88c4 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -17,7 +17,7 @@ use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;
 use crate::payload_storage::{ConditionChecker, PayloadStorage};
 use crate::types::{
     Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, MinShould,
-    OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType, VectorName,
+    OwnedPayloadRef, Payload, PayloadContainer, PayloadKeyType, VectorNameBuf,
 };
 use crate::vector_storage::{VectorStorage, VectorStorageEnum};
 
@@ -115,7 +115,7 @@ where
 pub fn check_payload<'a, R>(
     get_payload: Box<dyn Fn() -> OwnedPayloadRef<'a> + 'a>,
     id_tracker: Option<&IdTrackerSS>,
-    vector_storages: &HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
+    vector_storages: &HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,
     query: &Filter,
     point_id: PointOffsetType,
     field_indexes: &HashMap<PayloadKeyType, R>,
@@ -226,7 +226,7 @@ where
 pub struct SimpleConditionChecker {
     payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
     id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-    vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
+    vector_storages: HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,
     empty_payload: Payload,
 }
 
@@ -235,7 +235,7 @@ impl SimpleConditionChecker {
     pub fn new(
         payload_storage: Arc<AtomicRefCell<PayloadStorageEnum>>,
         id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,
-        vector_storages: HashMap<VectorName, Arc<AtomicRefCell<VectorStorageEnum>>>,
+        vector_storages: HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,
     ) -> Self {
         SimpleConditionChecker {
             payload_storage,

commit 6e1316bfb5e916378e41a4776a0205b555e950cd
Author: xzfc <5121426+xzfc@users.noreply.github.com>
Date:   Tue Jan 28 09:35:02 2025 +0000

    Add payload_json! macro (#5881)
    
    * Add payload_json! macro
    
    * Replace usage of `json!({...})` with `payload_json! {...}`
    
    * Drop `impl From<Value> for Payload`

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index fe03f88c4..901f01299 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -313,7 +313,6 @@ mod tests {
     use std::collections::HashSet;
     use std::str::FromStr;
 
-    use serde_json::json;
     use tempfile::Builder;
 
     use super::*;
@@ -321,6 +320,7 @@ mod tests {
     use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::id_tracker::IdTracker;
     use crate::json_path::JsonPath;
+    use crate::payload_json;
     use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
     use crate::types::{
@@ -332,11 +332,10 @@ mod tests {
         let dir = Builder::new().prefix("db_dir").tempdir().unwrap();
         let db = open_db(dir.path(), &[DB_VECTOR_CF]).unwrap();
 
-        let payload: Payload = json!(
-            {
-                "location":{
-                    "lon": 13.404954,
-                    "lat": 52.520008,
+        let payload = payload_json! {
+            "location": {
+                "lon": 13.404954,
+                "lat": 52.520008,
             },
             "price": 499.90,
             "amount": 10,
@@ -346,9 +345,8 @@ mod tests {
             "shipped_at": "2020-02-15T00:00:00Z",
             "parts": [],
             "packaging": null,
-            "not_null": [null]
-        })
-        .into();
+            "not_null": [null],
+        };
 
         let hw_counter = HardwareCounterCell::new();
 

commit 8ad2b34265448ec01b89d4093de5fbb1a86dcd4d
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Tue Feb 25 11:21:25 2025 +0100

    Bump Rust edition to 2024 (#6042)
    
    * Bump Rust edition to 2024
    
    * gen is a reserved keyword now
    
    * Remove ref mut on references
    
    * Mark extern C as unsafe
    
    * Wrap unsafe function bodies in unsafe block
    
    * Geo hash implements Copy, don't reference but pass by value instead
    
    * Replace secluded self import with parent
    
    * Update execute_cluster_read_operation with new match semantics
    
    * Fix lifetime issue
    
    * Replace map_or with is_none_or
    
    * set_var is unsafe now
    
    * Reformat

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 901f01299..075a142c5 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -9,7 +9,7 @@ use atomic_refcell::AtomicRefCell;
 use common::counter::hardware_counter::HardwareCounterCell;
 use common::types::PointOffsetType;
 
-use crate::common::utils::{check_is_empty, check_is_null, IndexesMap};
+use crate::common::utils::{IndexesMap, check_is_empty, check_is_null};
 use crate::id_tracker::IdTrackerSS;
 use crate::index::field_index::FieldIndex;
 use crate::payload_storage::condition_checker::ValueChecker;
@@ -316,13 +316,13 @@ mod tests {
     use tempfile::Builder;
 
     use super::*;
-    use crate::common::rocksdb_wrapper::{open_db, DB_VECTOR_CF};
-    use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
+    use crate::common::rocksdb_wrapper::{DB_VECTOR_CF, open_db};
     use crate::id_tracker::IdTracker;
+    use crate::id_tracker::simple_id_tracker::SimpleIdTracker;
     use crate::json_path::JsonPath;
     use crate::payload_json;
-    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::payload_storage::PayloadStorage;
+    use crate::payload_storage::simple_payload_storage::SimplePayloadStorage;
     use crate::types::{
         DateTimeWrapper, FieldCondition, GeoBoundingBox, GeoPoint, PayloadField, Range, ValuesCount,
     };

commit 706b1a31665ee4a2e44a0a20845bb8065b0dbc28
Author: Andrey Vasnetsov <andrey@vasnetsov.com>
Date:   Tue Mar 4 13:19:50 2025 +0100

    IsEmpty/IsNull index (#6088)
    
    * create initial strucutres
    
    * clippy
    
    * start field-query refactoring
    
    * start field-query refactoring (2/N)
    
    * start field-query refactoring (3/N): duplicate is_empty/null condiftions as field condition
    
    * start field-query refactoring (4/N): re-instate is_empty fallback in case new index is not built yet
    
    * filter for is_empty/is_null
    
    * implement add/remove point
    
    * upd schema
    
    * open and create of null-index
    
    * create null-index
    
    * fix test
    
    * Update lib/segment/src/index/query_optimization/condition_converter.rs
    
    Co-authored-by: Tim Vis√©e <tim+github@visee.me>
    
    * unit test for null-index
    
    * more unit tests
    
    * add openapi tests
    
    * fmt
    
    * fix for integartion tests
    
    * rabbit review fix
    
    * make [null] non-empty
    
    ---------
    
    Co-authored-by: Tim Vis√©e <tim+github@visee.me>

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 075a142c5..83b5881b9 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -190,6 +190,10 @@ where
     let field_values = payload.get_value(&field_condition.key);
     let field_indexes = field_indexes.get(&field_condition.key);
 
+    if field_values.is_empty() {
+        return field_condition.check_empty();
+    }
+
     // This covers a case, when a field index affects the result of the condition.
     if let Some(field_indexes) = field_indexes {
         for p in field_values {

commit 9554383a1e455dffa21d713b8622d0c991e24582
Author: Jojii <15957865+JojiiOfficial@users.noreply.github.com>
Date:   Thu Mar 13 09:32:24 2025 +0100

    Payload fulltext index IO read measurements (#5954)
    
    * FullTextIndex filter measurements
    
    * Clippy
    
    * Add test for `new_accumulator`

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 83b5881b9..0aa9571e4 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -119,14 +119,18 @@ pub fn check_payload<'a, R>(
     query: &Filter,
     point_id: PointOffsetType,
     field_indexes: &HashMap<PayloadKeyType, R>,
+    hw_counter: &HardwareCounterCell,
 ) -> bool
 where
     R: AsRef<Vec<FieldIndex>>,
 {
     let checker = |condition: &Condition| match condition {
-        Condition::Field(field_condition) => {
-            check_field_condition(field_condition, get_payload().deref(), field_indexes)
-        }
+        Condition::Field(field_condition) => check_field_condition(
+            field_condition,
+            get_payload().deref(),
+            field_indexes,
+            hw_counter,
+        ),
         Condition::IsEmpty(is_empty) => check_is_empty_condition(is_empty, get_payload().deref()),
         Condition::IsNull(is_null) => check_is_null_condition(is_null, get_payload().deref()),
         Condition::HasId(has_id) => id_tracker
@@ -154,6 +158,7 @@ where
                         &nested.nested.filter,
                         point_id,
                         &nested_indexes,
+                        hw_counter,
                     )
                 })
         }
@@ -183,6 +188,7 @@ pub fn check_field_condition<R>(
     field_condition: &FieldCondition,
     payload: &impl PayloadContainer,
     field_indexes: &HashMap<PayloadKeyType, R>,
+    hw_counter: &HardwareCounterCell,
 ) -> bool
 where
     R: AsRef<Vec<FieldIndex>>,
@@ -199,7 +205,9 @@ where
         for p in field_values {
             let mut index_checked = false;
             for index in field_indexes.as_ref() {
-                if let Some(index_check_res) = index.special_check_condition(field_condition, p) {
+                if let Some(index_check_res) =
+                    index.special_check_condition(field_condition, p, hw_counter)
+                {
                     if index_check_res {
                         // If at least one object matches the condition, we can return true
                         return true;
@@ -308,6 +316,7 @@ impl ConditionChecker for SimpleConditionChecker {
             query,
             point_id,
             &IndexesMap::new(),
+            &HardwareCounterCell::new(),
         )
     }
 }

commit e59d395d80ade92eef58c220adb576548e5e21a7
Author: Tim Vis√©e <tim+github@visee.me>
Date:   Thu Apr 17 23:11:35 2025 +0200

    Use ahash for maps/sets holding point IDs, offsets or similar (#6388)

diff --git a/lib/segment/src/payload_storage/query_checker.rs b/lib/segment/src/payload_storage/query_checker.rs
index 0aa9571e4..5e18b5df5 100644
--- a/lib/segment/src/payload_storage/query_checker.rs
+++ b/lib/segment/src/payload_storage/query_checker.rs
@@ -323,9 +323,9 @@ impl ConditionChecker for SimpleConditionChecker {
 
 #[cfg(test)]
 mod tests {
-    use std::collections::HashSet;
     use std::str::FromStr;
 
+    use ahash::AHashSet;
     use tempfile::Builder;
 
     use super::*;
@@ -648,17 +648,17 @@ mod tests {
         assert!(!payload_checker.check(0, &query));
 
         // id Filter
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
+        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter::new_must_not(Condition::HasId(ids.into()));
         assert!(!payload_checker.check(2, &query));
 
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
+        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter::new_must_not(Condition::HasId(ids.into()));
         assert!(payload_checker.check(10, &query));
 
-        let ids: HashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
+        let ids: AHashSet<_> = vec![1, 2, 3].into_iter().map(|x| x.into()).collect();
 
         let query = Filter::new_must(Condition::HasId(ids.into()));
         assert!(payload_checker.check(2, &query));

</code></pre>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
        });
    </script>
</body>
</html>
    