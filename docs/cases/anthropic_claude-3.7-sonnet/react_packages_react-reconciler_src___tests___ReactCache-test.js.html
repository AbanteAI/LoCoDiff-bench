<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-reconciler/src/__tests__/ReactCache-test.js - Sonnet 3.7</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-reconciler/src/__tests__/ReactCache-test.js</h1>
        <p><a href="../../models/anthropic_claude-3.7-sonnet.html">‚Üê Back to Sonnet 3.7 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.7</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 75947</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 93326</p>
                <p><strong>Native Completion Tokens:</strong> 14300</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.494478</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.7-sonnet/react_packages_react-reconciler_src___tests___ReactCache-test.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.7-sonnet/react_packages_react-reconciler_src___tests___ReactCache-test.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.7-sonnet/react_packages_react-reconciler_src___tests___ReactCache-test.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- react_packages_react-reconciler_src___tests___ReactCache-test.js_expectedoutput.txt (expected)+++ react_packages_react-reconciler_src___tests___ReactCache-test.js_extracted.txt (actual)@@ -1,33 +1,1528 @@-/**</div><div class="diff-removed">- * Copyright (c) Meta Platforms, Inc. and affiliates.</div><div class="diff-removed">- *</div><div class="diff-removed">- * This source code is licensed under the MIT license found in the</div><div class="diff-removed">- * LICENSE file in the root directory of this source tree.</div><div class="diff-removed">- *</div><div class="diff-removed">- * @emails react-core</div><div class="diff-removed">- * @jest-environment node</div><div class="diff-removed">- */</div><div class="diff-removed">-</div><div class="diff-removed">-'use strict';</div><div class="diff-removed">-</div><div> let React;</div><div class="diff-removed">-let ReactNoopFlightServer;</div><div class="diff-removed">-let ReactNoopFlightClient;</div><div class="diff-added">+let ReactNoop;</div><div class="diff-added">+let Cache;</div><div class="diff-added">+let getCacheSignal;</div><div class="diff-added">+let Scheduler;</div><div class="diff-added">+let assertLog;</div><div class="diff-added">+let act;</div><div class="diff-added">+let Suspense;</div><div class="diff-added">+let Activity;</div><div class="diff-added">+let useCacheRefresh;</div><div class="diff-added">+let startTransition;</div><div class="diff-added">+let useState;</div><div> let cache;</div><div class="diff-added">+</div><div class="diff-added">+let getTextCache;</div><div class="diff-added">+let textCaches;</div><div class="diff-added">+let seededCache;</div><div> </div><div> describe('ReactCache', () => {</div><div>   beforeEach(() => {</div><div>     jest.resetModules();</div><div class="diff-removed">-    jest.mock('react', () => require('react/react.react-server'));</div><div class="diff-added">+</div><div>     React = require('react');</div><div class="diff-removed">-</div><div class="diff-removed">-    ReactNoopFlightServer = require('react-noop-renderer/flight-server');</div><div class="diff-removed">-    ReactNoopFlightClient = require('react-noop-renderer/flight-client');</div><div class="diff-removed">-</div><div class="diff-added">+    ReactNoop = require('react-noop-renderer');</div><div class="diff-added">+    Cache = React.unstable_Cache;</div><div class="diff-added">+    Scheduler = require('scheduler');</div><div class="diff-added">+    act = require('internal-test-utils').act;</div><div class="diff-added">+    Suspense = React.Suspense;</div><div>     cache = React.cache;</div><div class="diff-removed">-</div><div class="diff-removed">-    jest.resetModules();</div><div class="diff-removed">-    __unmockReact();</div><div class="diff-added">+    Activity = React.unstable_Activity;</div><div class="diff-added">+    getCacheSignal = React.unstable_getCacheSignal;</div><div class="diff-added">+    useCacheRefresh = React.unstable_useCacheRefresh;</div><div class="diff-added">+    startTransition = React.startTransition;</div><div class="diff-added">+    useState = React.useState;</div><div class="diff-added">+</div><div class="diff-added">+    const InternalTestUtils = require('internal-test-utils');</div><div class="diff-added">+    assertLog = InternalTestUtils.assertLog;</div><div class="diff-added">+</div><div class="diff-added">+    textCaches = [];</div><div class="diff-added">+    seededCache = null;</div><div class="diff-added">+</div><div class="diff-added">+    if (gate(flags => flags.enableCache)) {</div><div class="diff-added">+      getTextCache = cache(() => {</div><div class="diff-added">+        if (seededCache !== null) {</div><div class="diff-added">+          // Trick to seed a cache before it exists.</div><div class="diff-added">+          // TODO: Need a built-in API to seed data before the initial render (i.e.</div><div class="diff-added">+          // not a refresh because nothing has mounted yet).</div><div class="diff-added">+          const textCache = seededCache;</div><div class="diff-added">+          seededCache = null;</div><div class="diff-added">+          return textCache;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        const data = new Map();</div><div class="diff-added">+        const version = textCaches.length + 1;</div><div class="diff-added">+        const textCache = {</div><div class="diff-added">+          version,</div><div class="diff-added">+          data,</div><div class="diff-added">+          resolve(text) {</div><div class="diff-added">+            const record = data.get(text);</div><div class="diff-added">+            if (record === undefined) {</div><div class="diff-added">+              const newRecord = {</div><div class="diff-added">+                status: 'resolved',</div><div class="diff-added">+                value: text,</div><div class="diff-added">+                cleanupScheduled: false,</div><div class="diff-added">+              };</div><div class="diff-added">+              data.set(text, newRecord);</div><div class="diff-added">+            } else if (record.status === 'pending') {</div><div class="diff-added">+              record.value.resolve();</div><div class="diff-added">+            }</div><div class="diff-added">+          },</div><div class="diff-added">+          reject(text, error) {</div><div class="diff-added">+            const record = data.get(text);</div><div class="diff-added">+            if (record === undefined) {</div><div class="diff-added">+              const newRecord = {</div><div class="diff-added">+                status: 'rejected',</div><div class="diff-added">+                value: error,</div><div class="diff-added">+                cleanupScheduled: false,</div><div class="diff-added">+              };</div><div class="diff-added">+              data.set(text, newRecord);</div><div class="diff-added">+            } else if (record.status === 'pending') {</div><div class="diff-added">+              record.value.reject();</div><div class="diff-added">+            }</div><div class="diff-added">+          },</div><div class="diff-added">+        };</div><div class="diff-added">+        textCaches.push(textCache);</div><div class="diff-added">+        return textCache;</div><div class="diff-added">+      });</div><div class="diff-added">+    }</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  function readText(text) {</div><div class="diff-added">+    const signal = getCacheSignal ? getCacheSignal() : null;</div><div class="diff-added">+    const textCache = getTextCache();</div><div class="diff-added">+    const record = textCache.data.get(text);</div><div class="diff-added">+    if (record !== undefined) {</div><div class="diff-added">+      if (!record.cleanupScheduled) {</div><div class="diff-added">+        // This record was seeded prior to the abort signal being available:</div><div class="diff-added">+        // schedule a cleanup function for it.</div><div class="diff-added">+        // TODO: Add ability to cleanup entries seeded w useCacheRefresh()</div><div class="diff-added">+        record.cleanupScheduled = true;</div><div class="diff-added">+        if (getCacheSignal) {</div><div class="diff-added">+          signal.addEventListener('abort', () => {</div><div class="diff-added">+            Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);</div><div class="diff-added">+          });</div><div class="diff-added">+        }</div><div class="diff-added">+      }</div><div class="diff-added">+      switch (record.status) {</div><div class="diff-added">+        case 'pending':</div><div class="diff-added">+          throw record.value;</div><div class="diff-added">+        case 'rejected':</div><div class="diff-added">+          throw record.value;</div><div class="diff-added">+        case 'resolved':</div><div class="diff-added">+          return textCache.version;</div><div class="diff-added">+      }</div><div class="diff-added">+    } else {</div><div class="diff-added">+      Scheduler.log(`Cache miss! [${text}]`);</div><div class="diff-added">+</div><div class="diff-added">+      let resolve;</div><div class="diff-added">+      let reject;</div><div class="diff-added">+      const thenable = new Promise((res, rej) => {</div><div class="diff-added">+        resolve = res;</div><div class="diff-added">+        reject = rej;</div><div class="diff-added">+      }).then(</div><div class="diff-added">+        value => {</div><div class="diff-added">+          if (newRecord.status === 'pending') {</div><div class="diff-added">+            newRecord.status = 'resolved';</div><div class="diff-added">+            newRecord.value = value;</div><div class="diff-added">+          }</div><div class="diff-added">+        },</div><div class="diff-added">+        error => {</div><div class="diff-added">+          if (newRecord.status === 'pending') {</div><div class="diff-added">+            newRecord.status = 'rejected';</div><div class="diff-added">+            newRecord.value = error;</div><div class="diff-added">+          }</div><div class="diff-added">+        },</div><div class="diff-added">+      );</div><div class="diff-added">+      thenable.resolve = resolve;</div><div class="diff-added">+      thenable.reject = reject;</div><div class="diff-added">+</div><div class="diff-added">+      const newRecord = {</div><div class="diff-added">+        status: 'pending',</div><div class="diff-added">+        value: thenable,</div><div class="diff-added">+        cleanupScheduled: true,</div><div class="diff-added">+      };</div><div class="diff-added">+      textCache.data.set(text, newRecord);</div><div class="diff-added">+</div><div class="diff-added">+      if (getCacheSignal) {</div><div class="diff-added">+        signal.addEventListener('abort', () => {</div><div class="diff-added">+          Scheduler.log(`Cache cleanup: ${text} [v${textCache.version}]`);</div><div class="diff-added">+        });</div><div class="diff-added">+      }</div><div class="diff-added">+      throw thenable;</div><div class="diff-added">+    }</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  function Text({text}) {</div><div class="diff-added">+    Scheduler.log(text);</div><div class="diff-added">+    return text;</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  function AsyncText({text, showVersion}) {</div><div class="diff-added">+    const version = readText(text);</div><div class="diff-added">+    const fullText = showVersion ? `${text} [v${version}]` : text;</div><div class="diff-added">+    Scheduler.log(fullText);</div><div class="diff-added">+    return fullText;</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  function seedNextTextCache(text) {</div><div class="diff-added">+    if (seededCache === null) {</div><div class="diff-added">+      seededCache = getTextCache();</div><div class="diff-added">+    }</div><div class="diff-added">+    seededCache.resolve(text);</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  function resolveMostRecentTextCache(text) {</div><div class="diff-added">+    if (textCaches.length === 0) {</div><div class="diff-added">+      throw Error('Cache does not exist.');</div><div class="diff-added">+    } else {</div><div class="diff-added">+      // Resolve the most recently created cache. An older cache can by</div><div class="diff-added">+      // resolved with `textCaches[index].resolve(text)`.</div><div class="diff-added">+      textCaches[textCaches.length - 1].resolve(text);</div><div class="diff-added">+    }</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('render Cache component', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<Cache>Hi</Cache>);</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Hi');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('mount new data', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <AsyncText text="A" /></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        </Cache>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // no cleanup: cache is still retained at the root</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCache</div><div class="diff-added">+  test('root acts as implicit cache boundary', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+          <AsyncText text="A" /></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // no cleanup: cache is still retained at the root</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('multiple new Cache boundaries in the same mount share the same, fresh root cache', async () => {</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <></div><div class="diff-added">+          <Cache></div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <AsyncText text="A" /></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          </Cache></div><div class="diff-added">+          <Cache></div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <AsyncText text="A" /></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+</div><div class="diff-added">+    // Even though there are two new <Cache /> trees, they should share the same</div><div class="diff-added">+    // data cache. So there should be only a single cache miss for A.</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A', 'A']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('AA');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // no cleanup: cache is still retained at the root</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('multiple new Cache boundaries in the same update share the same, fresh cache', async () => {</div><div class="diff-added">+    function App({showMore}) {</div><div class="diff-added">+      return showMore ? (</div><div class="diff-added">+        <></div><div class="diff-added">+          <Cache></div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <AsyncText text="A" /></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          </Cache></div><div class="diff-added">+          <Cache></div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <AsyncText text="A" /></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </></div><div class="diff-added">+      ) : (</div><div class="diff-added">+        '(empty)'</div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('(empty)');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    // Even though there are two new <Cache /> trees, they should share the same</div><div class="diff-added">+    // data cache. So there should be only a single cache miss for A.</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A', 'A']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('AA');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // cleanup occurs for the cache shared by the inner cache boundaries (which</div><div class="diff-added">+    // are not shared w the root because they were added in an update)</div><div class="diff-added">+    // note that no cache is created for the root since the cache is never accessed</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test(</div><div class="diff-added">+    'nested cache boundaries share the same cache as the root during ' +</div><div class="diff-added">+      'the initial render',</div><div class="diff-added">+    async () => {</div><div class="diff-added">+      function App() {</div><div class="diff-added">+        return (</div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <AsyncText text="A" /></div><div class="diff-added">+            <Cache></div><div class="diff-added">+              <AsyncText text="A" /></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        );</div><div class="diff-added">+      }</div><div class="diff-added">+</div><div class="diff-added">+      const root = ReactNoop.createRoot();</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render(<App />);</div><div class="diff-added">+      });</div><div class="diff-added">+      // Even though there is a nested <Cache /> boundary, it should share the same</div><div class="diff-added">+      // data cache as the root. So there should be only a single cache miss for A.</div><div class="diff-added">+      assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        resolveMostRecentTextCache('A');</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['A', 'A']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('AA');</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render('Bye');</div><div class="diff-added">+      });</div><div class="diff-added">+      // no cleanup: cache is still retained at the root</div><div class="diff-added">+      assertLog([]);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+    },</div><div class="diff-added">+  );</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('new content inside an existing Cache boundary should re-use already cached data', async () => {</div><div class="diff-added">+    function App({showMore}) {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+          {showMore ? (</div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          ) : null}</div><div class="diff-added">+        </Cache></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      seedNextTextCache('A');</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Add a new cache boundary</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+      // New tree should use already cached data</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // no cleanup: cache is still retained at the root</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('a new Cache boundary uses fresh cache', async () => {</div><div class="diff-added">+    // The only difference from the previous test is that the "Show More"</div><div class="diff-added">+    // content is wrapped in a nested <Cache /> boundary</div><div class="diff-added">+    function App({showMore}) {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+          {showMore ? (</div><div class="diff-added">+            <Cache></div><div class="diff-added">+              <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+                <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          ) : null}</div><div class="diff-added">+        </Cache></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      seedNextTextCache('A');</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Add a new cache boundary</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+      // New tree should load fresh data.</div><div class="diff-added">+      'Cache miss! [A]',</div><div class="diff-added">+      'Loading...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]Loading...');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Replace all the children: this should retain the root Cache instance,</div><div class="diff-added">+    // but cleanup the separate cache instance created for the fresh cache</div><div class="diff-added">+    // boundary</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    // Cleanup occurs for the *second* cache instance: the first is still</div><div class="diff-added">+    // referenced by the root</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('inner/outer cache boundaries uses the same cache instance on initial render', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading shell..." />}></div><div class="diff-added">+            {/* The shell reads A */}</div><div class="diff-added">+            <Shell></div><div class="diff-added">+              {/* The inner content reads both A and B */}</div><div class="diff-added">+              <Suspense fallback={<Text text="Loading content..." />}></div><div class="diff-added">+                <Cache></div><div class="diff-added">+                  <Content /></div><div class="diff-added">+                </Cache></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Shell></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        </Cache></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    function Shell({children}) {</div><div class="diff-added">+      readText('A');</div><div class="diff-added">+      return (</div><div class="diff-added">+        <></div><div class="diff-added">+          <div></div><div class="diff-added">+            <Text text="Shell" /></div><div class="diff-added">+          </div></div><div class="diff-added">+          <div>{children}</div></div><div class="diff-added">+        </></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    function Content() {</div><div class="diff-added">+      readText('A');</div><div class="diff-added">+      readText('B');</div><div class="diff-added">+      return <Text text="Content" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading shell...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading shell...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'Shell',</div><div class="diff-added">+      // There's a cache miss for B, because it hasn't been read yet. But not</div><div class="diff-added">+      // A, because it was cached when we rendered the shell.</div><div class="diff-added">+      'Cache miss! [B]',</div><div class="diff-added">+      'Loading content...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(</div><div class="diff-added">+      <></div><div class="diff-added">+        <div>Shell</div></div><div class="diff-added">+        <div>Loading content...</div></div><div class="diff-added">+      </>,</div><div class="diff-added">+    );</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('B');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Content']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(</div><div class="diff-added">+      <></div><div class="diff-added">+        <div>Shell</div></div><div class="diff-added">+        <div>Content</div></div><div class="diff-added">+      </>,</div><div class="diff-added">+    );</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // no cleanup: cache is still retained at the root</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('inner/ outer cache boundaries added in the same update use the same cache instance', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+</div><div class="diff-added">+    function App({showMore}) {</div><div class="diff-added">+      return showMore ? (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading shell..." />}></div><div class="diff-added">+            {/* The shell reads A */}</div><div class="diff-added">+            <Shell></div><div class="diff-added">+              {/* The inner content reads both A and B */}</div><div class="diff-added">+              <Suspense fallback={<Text text="Loading content..." />}></div><div class="diff-added">+                <Cache></div><div class="diff-added">+                  <Content /></div><div class="diff-added">+                </Cache></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Shell></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        </Cache></div><div class="diff-added">+      ) : (</div><div class="diff-added">+        '(empty)'</div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    function Shell({children}) {</div><div class="diff-added">+      readText('A');</div><div class="diff-added">+      return (</div><div class="diff-added">+        <></div><div class="diff-added">+          <div></div><div class="diff-added">+            <Text text="Shell" /></div><div class="diff-added">+          </div></div><div class="diff-added">+          <div>{children}</div></div><div class="diff-added">+        </></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    function Content() {</div><div class="diff-added">+      readText('A');</div><div class="diff-added">+      readText('B');</div><div class="diff-added">+      return <Text text="Content" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('(empty)');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App showMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading shell...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading shell...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'Shell',</div><div class="diff-added">+      // There's a cache miss for B, because it hasn't been read yet. But not</div><div class="diff-added">+      // A, because it was cached when we rendered the shell.</div><div class="diff-added">+      'Cache miss! [B]',</div><div class="diff-added">+      'Loading content...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(</div><div class="diff-added">+      <></div><div class="diff-added">+        <div>Shell</div></div><div class="diff-added">+        <div>Loading content...</div></div><div class="diff-added">+      </>,</div><div class="diff-added">+    );</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('B');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Content']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(</div><div class="diff-added">+      <></div><div class="diff-added">+        <div>Shell</div></div><div class="diff-added">+        <div>Content</div></div><div class="diff-added">+      </>,</div><div class="diff-added">+    );</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: B [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCache</div><div class="diff-added">+  test('refresh a cache boundary', async () => {</div><div class="diff-added">+    let refresh;</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      refresh = useCacheRefresh();</div><div class="diff-added">+      return <AsyncText showVersion={true} text="A" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Mount initial data</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+          <App /></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Refresh for new data.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => refresh());</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    // Note that the version has updated</div><div class="diff-added">+    if (getCacheSignal) {</div><div class="diff-added">+      assertLog(['A [v2]', 'Cache cleanup: A [v1]']);</div><div class="diff-added">+    } else {</div><div class="diff-added">+      assertLog(['A [v2]']);</div><div class="diff-added">+    }</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('refresh the root cache', async () => {</div><div class="diff-added">+    let refresh;</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      refresh = useCacheRefresh();</div><div class="diff-added">+      return <AsyncText showVersion={true} text="A" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Mount initial data</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+          <App /></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Refresh for new data.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => refresh());</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    // Note that the version has updated, and the previous cache is cleared</div><div class="diff-added">+    assertLog(['A [v2]', 'Cache cleanup: A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // the original root cache already cleaned up when the refresh completed</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('refresh the root cache without a transition', async () => {</div><div class="diff-added">+    let refresh;</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      refresh = useCacheRefresh();</div><div class="diff-added">+      return <AsyncText showVersion={true} text="A" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Mount initial data</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+          <App /></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Refresh for new data.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      refresh();</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'Cache miss! [A]',</div><div class="diff-added">+      'Loading...',</div><div class="diff-added">+      // The v1 cache can be cleaned up since everything that references it has</div><div class="diff-added">+      // been replaced by a fallback. When the boundary switches back to visible</div><div class="diff-added">+      // it will use the v2 cache.</div><div class="diff-added">+      'Cache cleanup: A [v1]',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    // Note that the version has updated, and the previous cache is cleared</div><div class="diff-added">+    assertLog(['A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // the original root cache already cleaned up when the refresh completed</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('refresh a cache with seed data', async () => {</div><div class="diff-added">+    let refreshWithSeed;</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      const refresh = useCacheRefresh();</div><div class="diff-added">+      const [seed, setSeed] = useState({fn: null});</div><div class="diff-added">+      if (seed.fn) {</div><div class="diff-added">+        seed.fn();</div><div class="diff-added">+        seed.fn = null;</div><div class="diff-added">+      }</div><div class="diff-added">+      refreshWithSeed = fn => {</div><div class="diff-added">+        setSeed({fn});</div><div class="diff-added">+        refresh();</div><div class="diff-added">+      };</div><div class="diff-added">+      return <AsyncText showVersion={true} text="A" />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Mount initial data</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <App /></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        </Cache>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Refresh for new data.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      // Refresh the cache with seeded data, like you would receive from a</div><div class="diff-added">+      // server mutation.</div><div class="diff-added">+      // TODO: Seeding multiple typed textCaches. Should work by calling `refresh`</div><div class="diff-added">+      // multiple times with different key/value pairs</div><div class="diff-added">+      startTransition(() =></div><div class="diff-added">+        refreshWithSeed(() => {</div><div class="diff-added">+          const textCache = getTextCache();</div><div class="diff-added">+          textCache.resolve('A');</div><div class="diff-added">+        }),</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    // The root should re-render without a cache miss.</div><div class="diff-added">+    // The cache is not cleared up yet, since it's still reference by the root</div><div class="diff-added">+    assertLog(['A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye');</div><div class="diff-added">+    });</div><div class="diff-added">+    // the refreshed cache boundary is unmounted and cleans up</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('refreshing a parent cache also refreshes its children', async () => {</div><div class="diff-added">+    let refreshShell;</div><div class="diff-added">+    function RefreshShell() {</div><div class="diff-added">+      refreshShell = useCacheRefresh();</div><div class="diff-added">+      return null;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    function App({showMore}) {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <RefreshShell /></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Suspense></div><div class="diff-added">+          {showMore ? (</div><div class="diff-added">+            <Cache></div><div class="diff-added">+              <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+                <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          ) : null}</div><div class="diff-added">+        </Cache></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      seedNextTextCache('A');</div><div class="diff-added">+      root.render(<App showMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Add a new cache boundary</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      seedNextTextCache('A');</div><div class="diff-added">+      root.render(<App showMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+      // New tree should load fresh data.</div><div class="diff-added">+      'A [v2]',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Now refresh the shell. This should also cause the "Show More" contents to</div><div class="diff-added">+    // refresh, since its cache is nested inside the outer one.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => refreshShell());</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      'A [v3]',</div><div class="diff-added">+      'A [v3]',</div><div class="diff-added">+      // once the refresh completes the inner showMore boundary frees its previous</div><div class="diff-added">+      // cache instance, since it is now using the refreshed parent instance.</div><div class="diff-added">+      'Cache cleanup: A [v2]',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v3]A [v3]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    // Unmounting children releases the refreshed cache instance only; the root</div><div class="diff-added">+    // still retains the original cache instance used for the first render</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v3]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test(</div><div class="diff-added">+    'refreshing a cache boundary does not refresh the other boundaries ' +</div><div class="diff-added">+      'that mounted at the same time (i.e. the ones that share the same cache)',</div><div class="diff-added">+    async () => {</div><div class="diff-added">+      let refreshFirstBoundary;</div><div class="diff-added">+      function RefreshFirstBoundary() {</div><div class="diff-added">+        refreshFirstBoundary = useCacheRefresh();</div><div class="diff-added">+        return null;</div><div class="diff-added">+      }</div><div class="diff-added">+</div><div class="diff-added">+      function App({showMore}) {</div><div class="diff-added">+        return showMore ? (</div><div class="diff-added">+          <></div><div class="diff-added">+            <Cache></div><div class="diff-added">+              <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+                <RefreshFirstBoundary /></div><div class="diff-added">+                <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Cache></div><div class="diff-added">+            <Cache></div><div class="diff-added">+              <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+                <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </></div><div class="diff-added">+        ) : null;</div><div class="diff-added">+      }</div><div class="diff-added">+</div><div class="diff-added">+      // First mount the initial shell without the nested boundaries. This is</div><div class="diff-added">+      // necessary for this test because we want the two inner boundaries to be</div><div class="diff-added">+      // treated like sibling providers that happen to share an underlying</div><div class="diff-added">+      // cache, as opposed to consumers of the root-level cache.</div><div class="diff-added">+      const root = ReactNoop.createRoot();</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render(<App showMore={false} />);</div><div class="diff-added">+      });</div><div class="diff-added">+</div><div class="diff-added">+      // Now reveal the boundaries. In a real app  this would be a navigation.</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render(<App showMore={true} />);</div><div class="diff-added">+      });</div><div class="diff-added">+</div><div class="diff-added">+      // Even though there are two new <Cache /> trees, they should share the same</div><div class="diff-added">+      // data cache. So there should be only a single cache miss for A.</div><div class="diff-added">+      assertLog(['Cache miss! [A]', 'Loading...', 'Loading...']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Loading...Loading...');</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        resolveMostRecentTextCache('A');</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['A [v1]', 'A [v1]']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('A [v1]A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+      // Refresh the first boundary. It should not refresh the second boundary,</div><div class="diff-added">+      // even though they previously shared the same underlying cache.</div><div class="diff-added">+      await act(async () => {</div><div class="diff-added">+        await refreshFirstBoundary();</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        resolveMostRecentTextCache('A');</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['A [v2]']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('A [v2]A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+      // Unmount children: this should clear *both* cache instances:</div><div class="diff-added">+      // the root doesn't have a cache instance (since it wasn't accessed</div><div class="diff-added">+      // during the initial render, and all subsequent cache accesses were within</div><div class="diff-added">+      // a fresh boundary). Therefore this causes cleanup for both the fresh cache</div><div class="diff-added">+      // instance in the refreshed first boundary and cleanup for the non-refreshed</div><div class="diff-added">+      // sibling boundary.</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render('Bye!');</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['Cache cleanup: A [v2]', 'Cache cleanup: A [v1]']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+    },</div><div class="diff-added">+  );</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test(</div><div class="diff-added">+    'mount a new Cache boundary in a sibling while simultaneously ' +</div><div class="diff-added">+      'resolving a Suspense boundary',</div><div class="diff-added">+    async () => {</div><div class="diff-added">+      function App({showMore}) {</div><div class="diff-added">+        return (</div><div class="diff-added">+          <></div><div class="diff-added">+            {showMore ? (</div><div class="diff-added">+              <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+                <Cache></div><div class="diff-added">+                  <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+                </Cache></div><div class="diff-added">+              </Suspense></div><div class="diff-added">+            ) : null}</div><div class="diff-added">+            <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+              <Cache></div><div class="diff-added">+                {' '}</div><div class="diff-added">+                <AsyncText showVersion={true} text="A" />{' '}</div><div class="diff-added">+                <AsyncText showVersion={true} text="B" /></div><div class="diff-added">+              </Cache></div><div class="diff-added">+            </Suspense></div><div class="diff-added">+          </></div><div class="diff-added">+        );</div><div class="diff-added">+      }</div><div class="diff-added">+</div><div class="diff-added">+      const root = ReactNoop.createRoot();</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render(<App showMore={false} />);</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        // This will resolve the content in the first cache</div><div class="diff-added">+        resolveMostRecentTextCache('A');</div><div class="diff-added">+        resolveMostRecentTextCache('B');</div><div class="diff-added">+        // And mount the second tree, which includes new content</div><div class="diff-added">+        root.render(<App showMore={true} />);</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog([</div><div class="diff-added">+        // The new tree should use a fresh cache</div><div class="diff-added">+        'Cache miss! [A]',</div><div class="diff-added">+        'Loading...',</div><div class="diff-added">+        // The other tree uses the cached responses. This demonstrates that the</div><div class="diff-added">+        // requests are not dropped.</div><div class="diff-added">+        'A [v1]',</div><div class="diff-added">+        'B [v1]',</div><div class="diff-added">+      ]);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Loading... A [v1] B [v1]');</div><div class="diff-added">+</div><div class="diff-added">+      // Now resolve the second tree</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        resolveMostRecentTextCache('A');</div><div class="diff-added">+      });</div><div class="diff-added">+      assertLog(['A [v2]']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('A [v2] A [v1] B [v1]');</div><div class="diff-added">+</div><div class="diff-added">+      await act(() => {</div><div class="diff-added">+        root.render('Bye!');</div><div class="diff-added">+      });</div><div class="diff-added">+      // Unmounting children releases both cache boundaries, but the original</div><div class="diff-added">+      // cache instance (used by second boundary) is still referenced by the root.</div><div class="diff-added">+      // only the second cache instance is freed.</div><div class="diff-added">+      assertLog(['Cache cleanup: A [v2]']);</div><div class="diff-added">+      expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+    },</div><div class="diff-added">+  );</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('cache pool is cleared once transitions that depend on it commit their shell', async () => {</div><div class="diff-added">+    function Child({text}) {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Cache></div><div class="diff-added">+          <AsyncText showVersion={true} text={text} /></div><div class="diff-added">+        </Cache></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback={<Text text="Loading..." />}>(empty)</Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('(empty)');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('(empty)');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      // No cache miss, because it uses the pooled cache</div><div class="diff-added">+      'Loading...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('(empty)');</div><div class="diff-added">+</div><div class="diff-added">+    // Resolve the request</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]', 'A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Now do another transition</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+            <Child text="A" /></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      // First two children use the old cache because they already finished</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+      'A [v1]',</div><div class="diff-added">+      // The new child uses a fresh cache</div><div class="diff-added">+      'Cache miss! [A]',</div><div class="diff-added">+      'Loading...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]', 'A [v1]', 'A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]A [v1]A [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: the first text cache instance is created only after the root</div><div class="diff-added">+    // commits, so both fresh cache instances are released by their cache boundaries,</div><div class="diff-added">+    // cleaning up v1 (used for the first two children which render together) and</div><div class="diff-added">+    // v2 (used for the third boundary added later).</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v1]', 'Cache cleanup: A [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('cache pool is not cleared by arbitrary commits', async () => {</div><div class="diff-added">+    function App() {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <></div><div class="diff-added">+          <ShowMore /></div><div class="diff-added">+          <Unrelated /></div><div class="diff-added">+        </></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    let showMore;</div><div class="diff-added">+    function ShowMore() {</div><div class="diff-added">+      const [shouldShow, _showMore] = useState(false);</div><div class="diff-added">+      showMore = () => _showMore(true);</div><div class="diff-added">+      return (</div><div class="diff-added">+        <></div><div class="diff-added">+          <Suspense fallback={<Text text="Loading..." />}></div><div class="diff-added">+            {shouldShow ? (</div><div class="diff-added">+              <Cache></div><div class="diff-added">+                <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+              </Cache></div><div class="diff-added">+            ) : null}</div><div class="diff-added">+          </Suspense></div><div class="diff-added">+        </></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    let updateUnrelated;</div><div class="diff-added">+    function Unrelated() {</div><div class="diff-added">+      const [count, _updateUnrelated] = useState(0);</div><div class="diff-added">+      updateUnrelated = _updateUnrelated;</div><div class="diff-added">+      return <Text text={String(count)} />;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['0']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('0');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        showMore();</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]', 'Loading...']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('0');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      updateUnrelated(1);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([</div><div class="diff-added">+      '1',</div><div class="diff-added">+</div><div class="diff-added">+      // Happens to re-render the fallback. Doesn't need to, but not relevant</div><div class="diff-added">+      // to this test.</div><div class="diff-added">+      'Loading...',</div><div class="diff-added">+    ]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('1');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]1');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: the first text cache instance is created only after initial</div><div class="diff-added">+    // render after calling showMore(). This instance is cleaned up when that boundary</div><div class="diff-added">+    // is unmounted. Bc root cache instance is never accessed, the inner cache</div><div class="diff-added">+    // boundary ends up at v1.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('cache boundary uses a fresh cache when its key changes', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    seedNextTextCache('A');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="A"></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    seedNextTextCache('B');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="B"></div><div class="diff-added">+            <AsyncText showVersion={true} text="B" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['B [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('B [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: the fresh cache instance for B cleans up since the cache boundary</div><div class="diff-added">+    // is the only owner, while the original cache instance (for A) is still retained by</div><div class="diff-added">+    // the root.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: B [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('overlapping transitions after an initial mount use the same fresh cache', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="A"></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // After a mount, subsequent transitions use a fresh cache</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback="Loading..."></div><div class="diff-added">+            <Cache key="B"></div><div class="diff-added">+              <AsyncText showVersion={true} text="B" /></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [B]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Update to a different text and with a different key for the cache</div><div class="diff-added">+    // boundary: this should still use the fresh cache instance created</div><div class="diff-added">+    // for the earlier transition</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback="Loading..."></div><div class="diff-added">+            <Cache key="C"></div><div class="diff-added">+              <AsyncText showVersion={true} text="C" /></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [C]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('C');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['C [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('C [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: the fresh cache used for the updates is freed, while the</div><div class="diff-added">+    // original cache (with A) is still retained at the root.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('overlapping updates after an initial mount use the same fresh cache', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="A"></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [A]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('A');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // After a mount, subsequent updates use a fresh cache</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="B"></div><div class="diff-added">+            <AsyncText showVersion={true} text="B" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [B]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    // A second update uses the same fresh cache: even though this is a new</div><div class="diff-added">+    // Cache boundary, the render uses the fresh cache from the pending update.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="C"></div><div class="diff-added">+            <AsyncText showVersion={true} text="C" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [C]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Loading...');</div><div class="diff-added">+</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      resolveMostRecentTextCache('C');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['C [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('C [v2]');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: the fresh cache used for the updates is freed, while the</div><div class="diff-added">+    // original cache (with A) is still retained at the root.</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache cleanup: B [v2]', 'Cache cleanup: C [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableCacheElement && enableCache</div><div class="diff-added">+  test('cleans up cache only used in an aborted transition', async () => {</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    seedNextTextCache('A');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <Suspense fallback="Loading..."></div><div class="diff-added">+          <Cache key="A"></div><div class="diff-added">+            <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+          </Cache></div><div class="diff-added">+        </Suspense>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Start a transition from A -> B..., which should create a fresh cache</div><div class="diff-added">+    // for the new cache boundary (bc of the different key)</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback="Loading..."></div><div class="diff-added">+            <Cache key="B"></div><div class="diff-added">+              <AsyncText showVersion={true} text="B" /></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['Cache miss! [B]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // ...but cancel by transitioning "back" to A (which we never really left)</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      startTransition(() => {</div><div class="diff-added">+        root.render(</div><div class="diff-added">+          <Suspense fallback="Loading..."></div><div class="diff-added">+            <Cache key="A"></div><div class="diff-added">+              <AsyncText showVersion={true} text="A" /></div><div class="diff-added">+            </Cache></div><div class="diff-added">+          </Suspense>,</div><div class="diff-added">+        );</div><div class="diff-added">+      });</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['A [v1]', 'Cache cleanup: B [v2]']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('A [v1]');</div><div class="diff-added">+</div><div class="diff-added">+    // Unmount children: ...</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render('Bye!');</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('Bye!');</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  // @gate enableActivity</div><div class="diff-added">+  // @gate enableCache</div><div class="diff-added">+  test('prerender a new cache boundary inside an Activity tree', async () => {</div><div class="diff-added">+    function App({prerenderMore}) {</div><div class="diff-added">+      return (</div><div class="diff-added">+        <Activity mode="hidden"></div><div class="diff-added">+          <div></div><div class="diff-added">+            {prerenderMore ? (</div><div class="diff-added">+              <Cache></div><div class="diff-added">+                <AsyncText text="More" /></div><div class="diff-added">+              </Cache></div><div class="diff-added">+            ) : null}</div><div class="diff-added">+          </div></div><div class="diff-added">+        </Activity></div><div class="diff-added">+      );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    const root = ReactNoop.createRoot();</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App prerenderMore={false} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog([]);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(<div hidden={true} />);</div><div class="diff-added">+</div><div class="diff-added">+    seedNextTextCache('More');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<App prerenderMore={true} />);</div><div class="diff-added">+    });</div><div class="diff-added">+    assertLog(['More']);</div><div class="diff-added">+    expect(root).toMatchRenderedOutput(<div hidden={true}>More</div>);</div><div>   });</div><div> </div><div>   it('cache objects and primitive arguments and a mix of them', async () => {</div><div class="diff-info">@@ -49,124 +1544,96 @@     function MoreArgs({a, b}) {</div><div>       return (types(a) === types(a, b)).toString() + ' ';</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a="e" b="f" /></div><div class="diff-removed">-              <Same a="a" b="b" /></div><div class="diff-removed">-              <FlippedOrder a="c" b="d" /></div><div class="diff-removed">-              <FewerArgs a="e" b="f" /></div><div class="diff-removed">-              <MoreArgs a="g" b="h" /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('string string true false false false ');</div><div class="diff-removed">-</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a="e" b={null} /></div><div class="diff-removed">-              <Same a="a" b={null} /></div><div class="diff-removed">-              <FlippedOrder a="c" b={null} /></div><div class="diff-removed">-              <FewerArgs a="e" b={null} /></div><div class="diff-removed">-              <MoreArgs a="g" b={null} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('string object true false false false ');</div><div class="diff-removed">-</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a="e" b="f" /></div><div class="diff-added">+          <Same a="a" b="b" /></div><div class="diff-added">+          <FlippedOrder a="c" b="d" /></div><div class="diff-added">+          <FewerArgs a="e" b="f" /></div><div class="diff-added">+          <MoreArgs a="g" b="h" /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('string string true false false false ');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a="e" b={null} /></div><div class="diff-added">+          <Same a="a" b={null} /></div><div class="diff-added">+          <FlippedOrder a="c" b={null} /></div><div class="diff-added">+          <FewerArgs a="e" b={null} /></div><div class="diff-added">+          <MoreArgs a="g" b={null} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('string object true false false false ');</div><div>     const obj = {};</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a="e" b={obj} /></div><div class="diff-removed">-              <Same a="a" b={obj} /></div><div class="diff-removed">-              <FlippedOrder a="c" b={obj} /></div><div class="diff-removed">-              <FewerArgs a="e" b={obj} /></div><div class="diff-removed">-              <MoreArgs a="g" b={obj} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('string object true false false false ');</div><div class="diff-removed">-</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a="e" b={obj} /></div><div class="diff-added">+          <Same a="a" b={obj} /></div><div class="diff-added">+          <FlippedOrder a="c" b={obj} /></div><div class="diff-added">+          <FewerArgs a="e" b={obj} /></div><div class="diff-added">+          <MoreArgs a="g" b={obj} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('string object true false false false ');</div><div>     const sameObj = {};</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a={sameObj} b={sameObj} /></div><div class="diff-removed">-              <Same a={sameObj} b={sameObj} /></div><div class="diff-removed">-              <FlippedOrder a={sameObj} b={sameObj} /></div><div class="diff-removed">-              <FewerArgs a={sameObj} b={sameObj} /></div><div class="diff-removed">-              <MoreArgs a={sameObj} b={sameObj} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('object object true true false false ');</div><div class="diff-removed">-</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a={sameObj} b={sameObj} /></div><div class="diff-added">+          <Same a={sameObj} b={sameObj} /></div><div class="diff-added">+          <FlippedOrder a={sameObj} b={sameObj} /></div><div class="diff-added">+          <FewerArgs a={sameObj} b={sameObj} /></div><div class="diff-added">+          <MoreArgs a={sameObj} b={sameObj} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('object object true true false false ');</div><div>     const objA = {};</div><div>     const objB = {};</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a={objA} b={objB} /></div><div class="diff-removed">-              <Same a={objA} b={objB} /></div><div class="diff-removed">-              <FlippedOrder a={objA} b={objB} /></div><div class="diff-removed">-              <FewerArgs a={objA} b={objB} /></div><div class="diff-removed">-              <MoreArgs a={objA} b={objB} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('object object true false false false ');</div><div class="diff-removed">-</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a={objA} b={objB} /></div><div class="diff-added">+          <Same a={objA} b={objB} /></div><div class="diff-added">+          <FlippedOrder a={objA} b={objB} /></div><div class="diff-added">+          <FewerArgs a={objA} b={objB} /></div><div class="diff-added">+          <MoreArgs a={objA} b={objB} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('object object true false false false ');</div><div>     const sameSymbol = Symbol();</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a={sameSymbol} b={sameSymbol} /></div><div class="diff-removed">-              <Same a={sameSymbol} b={sameSymbol} /></div><div class="diff-removed">-              <FlippedOrder a={sameSymbol} b={sameSymbol} /></div><div class="diff-removed">-              <FewerArgs a={sameSymbol} b={sameSymbol} /></div><div class="diff-removed">-              <MoreArgs a={sameSymbol} b={sameSymbol} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('symbol symbol true true false false ');</div><div class="diff-removed">-</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a={sameSymbol} b={sameSymbol} /></div><div class="diff-added">+          <Same a={sameSymbol} b={sameSymbol} /></div><div class="diff-added">+          <FlippedOrder a={sameSymbol} b={sameSymbol} /></div><div class="diff-added">+          <FewerArgs a={sameSymbol} b={sameSymbol} /></div><div class="diff-added">+          <MoreArgs a={sameSymbol} b={sameSymbol} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('symbol symbol true true false false ');</div><div>     const notANumber = +'nan';</div><div class="diff-removed">-    expect(</div><div class="diff-removed">-      (</div><div class="diff-removed">-        await ReactNoopFlightClient.read(</div><div class="diff-removed">-          ReactNoopFlightServer.render(</div><div class="diff-removed">-            <></div><div class="diff-removed">-              <Print a={1} b={notANumber} /></div><div class="diff-removed">-              <Same a={1} b={notANumber} /></div><div class="diff-removed">-              <FlippedOrder a={1} b={notANumber} /></div><div class="diff-removed">-              <FewerArgs a={1} b={notANumber} /></div><div class="diff-removed">-              <MoreArgs a={1} b={notANumber} /></div><div class="diff-removed">-            </>,</div><div class="diff-removed">-          ),</div><div class="diff-removed">-        )</div><div class="diff-removed">-      ).join(''),</div><div class="diff-removed">-    ).toEqual('number number true false false false ');</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(</div><div class="diff-added">+        <></div><div class="diff-added">+          <Print a={1} b={notANumber} /></div><div class="diff-added">+          <Same a={1} b={notANumber} /></div><div class="diff-added">+          <FlippedOrder a={1} b={notANumber} /></div><div class="diff-added">+          <FewerArgs a={1} b={notANumber} /></div><div class="diff-added">+          <MoreArgs a={1} b={notANumber} /></div><div class="diff-added">+        </>,</div><div class="diff-added">+      );</div><div class="diff-added">+    });</div><div class="diff-added">+    expect(root).toMatchRenderedOutput('number number true false false false ');</div><div>   });</div><div> </div><div>   it('cached functions that throw should cache the error', async () => {</div><div class="diff-info">@@ -195,29 +1662,10 @@ </div><div>       return 'Blank';</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    ReactNoopFlightServer.render(<Test />);</div><div class="diff-added">+    await act(() => {</div><div class="diff-added">+      root.render(<Test />);</div><div class="diff-added">+    });</div><div>     expect(x).toBe(y);</div><div>     expect(z).not.toBe(x);</div><div>   });</div><div class="diff-removed">-</div><div class="diff-removed">-  it('introspection of returned wrapper function is same on client and server', async () => {</div><div class="diff-removed">-    // When the variant flag is true, test the client version of `cache`.</div><div class="diff-removed">-    if (gate(flags => flags.variant)) {</div><div class="diff-removed">-      jest.resetModules();</div><div class="diff-removed">-      jest.mock('react', () => jest.requireActual('react'));</div><div class="diff-removed">-      const ClientReact = require('react');</div><div class="diff-removed">-      cache = ClientReact.cache;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    function foo(a, b, c) {</div><div class="diff-removed">-      return a + b + c;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    foo.displayName = 'Custom display name';</div><div class="diff-removed">-</div><div class="diff-removed">-    const cachedFoo = cache(foo);</div><div class="diff-removed">-    expect(cachedFoo).not.toBe(foo);</div><div class="diff-removed">-    expect(cachedFoo.length).toBe(0);</div><div class="diff-removed">-    expect(cachedFoo.displayName).toBe(undefined);</div><div class="diff-removed">-  });</div><div> });</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    