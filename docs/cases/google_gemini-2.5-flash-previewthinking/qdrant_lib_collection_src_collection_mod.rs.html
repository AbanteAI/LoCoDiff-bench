<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - Gemini 2.5 Flash Thinking</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <h2>Model: Gemini 2.5 Flash Thinking</h2>
        <p><a href="../../models/google_gemini-2.5-flash-previewthinking.html">All Gemini 2.5 Flash Thinking Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash Thinking</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Native Prompt Tokens:</strong> 73689</p>
                <p><strong>Native Completion Tokens:</strong> 37274</p>
                <p><strong>Native Tokens Reasoning:</strong> 27776</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.14151235</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b..4a729a54 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmpos87g1v8_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmp3kiqei0k_actual.txt	</div><div class="diff-info">@@ -20,6 +20,10 @@ use std::time::Duration;</div><div> </div><div> use clean::ShardCleanTasks;</div><div> use common::budget::ResourceBudget;</div><div class="diff-added">+use common::collection_size_stats::{</div><div class="diff-added">+    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-added">+};</div><div class="diff-added">+use common::is_ready::IsReady;</div><div> use common::types::{DetailsLevel, TelemetryDetail};</div><div> use io::storage_version::StorageVersion;</div><div> use segment::types::ShardKey;</div><div class="diff-info">@@ -29,11 +33,8 @@ use tokio::sync::{Mutex, RwLock, RwLockWriteGuard};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_state::{ShardInfo, State};</div><div class="diff-removed">-use crate::common::collection_size_stats::{</div><div class="diff-removed">-    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-removed">-};</div><div class="diff-removed">-use crate::common::is_ready::IsReady;</div><div> use crate::config::CollectionConfigInternal;</div><div class="diff-added">+use crate::operations::cluster_ops::ReshardingDirection;</div><div> use crate::operations::config_diff::{DiffConfig, OptimizersConfigDiff};</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult, NodeType, OptimizersStatus};</div><div class="diff-info">@@ -46,13 +47,14 @@ use crate::shards::replica_set::ReplicaState::{Active, Dead, Initializing, Liste</div><div> use crate::shards::replica_set::{</div><div>     ChangePeerFromState, ChangePeerState, ReplicaState, ShardReplicaSet,</div><div> };</div><div class="diff-added">+use crate::shards::resharding::{ReshardKey, ReshardingState};</div><div> use crate::shards::shard::{PeerId, ShardId};</div><div> use crate::shards::shard_holder::shard_mapping::ShardKeyMapping;</div><div class="diff-removed">-use crate::shards::shard_holder::{LockedShardHolder, ShardHolder, shard_not_found_error};</div><div class="diff-added">+use crate::shards::shard_holder::{shard_not_found_error, LockedShardHolder, ShardHolder};</div><div> use crate::shards::transfer::helpers::check_transfer_conflicts_strict;</div><div> use crate::shards::transfer::transfer_tasks_pool::{TaskResult, TransferTasksPool};</div><div> use crate::shards::transfer::{ShardTransfer, ShardTransferMethod};</div><div class="diff-removed">-use crate::shards::{CollectionId, replica_set};</div><div class="diff-added">+use crate::shards::{replica_set, CollectionId};</div><div> use crate::telemetry::{</div><div>     CollectionConfigTelemetry, CollectionTelemetry, CollectionsAggregatedTelemetry,</div><div> };</div><div class="diff-info">@@ -155,7 +157,6 @@ impl Collection {</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 optimizer_resource_budget.clone(),</div><div class="diff-removed">-                None,</div><div>             )</div><div>             .await?;</div><div> </div><div class="diff-info">@@ -247,8 +248,6 @@ impl Collection {</div><div>         });</div><div>         collection_config.validate_and_warn();</div><div> </div><div class="diff-removed">-        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");</div><div class="diff-removed">-</div><div>         let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div> </div><div>         if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-info">@@ -257,6 +256,8 @@ impl Collection {</div><div>                 .expect("Can not apply optimizer overwrite");</div><div>         }</div><div> </div><div class="diff-added">+        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");</div><div class="diff-added">+</div><div>         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div> </div><div>         let payload_index_schema = Arc::new(</div><div class="diff-info">@@ -423,7 +424,12 @@ impl Collection {</div><div>         }</div><div> </div><div>         // 2. Check that `from_state` matches current state</div><div class="diff-removed">-        if from_state.is_some() && current_state != from_state {</div><div class="diff-added">+        // Do not be strict about from state if in shard transfer related state (Partial, Resharding)</div><div class="diff-added">+        let is_shard_transfer_related_state = matches!(</div><div class="diff-added">+            current_state,</div><div class="diff-added">+            Some(ReplicaState::Partial) | Some(ReplicaState::Resharding)</div><div class="diff-added">+        );</div><div class="diff-added">+        if from_state.is_some() && current_state != from_state && !is_shard_transfer_related_state {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Replica {peer_id} of shard {shard_id} has state {current_state:?}, but expected {from_state:?}"</div><div>             )));</div><div class="diff-info">@@ -443,6 +449,31 @@ impl Collection {</div><div>             .ensure_replica_with_state(peer_id, new_state)</div><div>             .await?;</div><div> </div><div class="diff-added">+        // If not initialized yet, we need to check if it was initialized by this call</div><div class="diff-added">+        if !self.is_initialized.check_ready() {</div><div class="diff-added">+            let state = self.state().await;</div><div class="diff-added">+</div><div class="diff-added">+            let mut is_ready = true;</div><div class="diff-added">+</div><div class="diff-added">+            for (_shard_id, shard_info) in state.shards {</div><div class="diff-added">+                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-added">+                    matches!(</div><div class="diff-added">+                        state,</div><div class="diff-added">+                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-added">+                    )</div><div class="diff-added">+                });</div><div class="diff-added">+</div><div class="diff-added">+                if !all_replicas_active {</div><div class="diff-added">+                    is_ready = false;</div><div class="diff-added">+                    break;</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            if is_ready {</div><div class="diff-added">+                self.is_initialized.make_ready();</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div>         if new_state == ReplicaState::Dead {</div><div>             let resharding_state = shard_holder.resharding_state.read().clone();</div><div>             let related_transfers = shard_holder.get_related_transfers(shard_id, peer_id);</div><div class="diff-info">@@ -469,6 +500,7 @@ impl Collection {</div><div>                 .as_ref()</div><div>                 .is_some_and(ReplicaState::is_resharding);</div><div>             if is_resharding {</div><div class="diff-added">+                // check if the state is related to the ongoing resharding before initiating abort</div><div>                 if let Some(state) = resharding_state {</div><div>                     abort_resharding_result = self.abort_resharding(state.key(), false).await;</div><div>                 }</div><div class="diff-info">@@ -483,31 +515,6 @@ impl Collection {</div><div>             abort_resharding_result?;</div><div>         }</div><div> </div><div class="diff-removed">-        // If not initialized yet, we need to check if it was initialized by this call</div><div class="diff-removed">-        if !self.is_initialized.check_ready() {</div><div class="diff-removed">-            let state = self.state().await;</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut is_ready = true;</div><div class="diff-removed">-</div><div class="diff-removed">-            for (_shard_id, shard_info) in state.shards {</div><div class="diff-removed">-                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-removed">-                    matches!(</div><div class="diff-removed">-                        state,</div><div class="diff-removed">-                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-                if !all_replicas_active {</div><div class="diff-removed">-                    is_ready = false;</div><div class="diff-removed">-                    break;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            if is_ready {</div><div class="diff-removed">-                self.is_initialized.make_ready();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -545,6 +552,7 @@ impl Collection {</div><div>         let shards_holder = self.shards_holder.read().await;</div><div>         let transfers = shards_holder.shard_transfers.read().clone();</div><div>         let resharding = shards_holder.resharding_state.read().clone();</div><div class="diff-added">+</div><div>         State {</div><div>             config: self.collection_config.read().await.clone(),</div><div>             shards: shards_holder</div><div class="diff-info">@@ -587,6 +595,7 @@ impl Collection {</div><div>             .await</div><div>     }</div><div> </div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div>     pub async fn sync_local_state(</div><div>         &self,</div><div>         on_transfer_failure: OnTransferFailure,</div><div class="diff-info">@@ -598,13 +607,13 @@ impl Collection {</div><div>         // Check for disabled replicas</div><div>         let shard_holder = self.shards_holder.read().await;</div><div> </div><div class="diff-removed">-        let get_shard_transfers = |shard_id, from| {</div><div class="diff-added">+        let get_shard_transfers = |shard_id: ShardId, from: PeerId| {</div><div>             shard_holder</div><div>                 .get_transfers(|transfer| transfer.shard_id == shard_id && transfer.from == from)</div><div>         };</div><div> </div><div>         for replica_set in shard_holder.all_shards() {</div><div class="diff-removed">-            replica_set.sync_local_state(get_shard_transfers)?;</div><div class="diff-added">+            replica_set.sync_local_state(get_shard_transfers).await?;</div><div>         }</div><div> </div><div>         // Check for un-reported finished transfers</div><div class="diff-info">@@ -640,12 +649,6 @@ impl Collection {</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Count how many transfers we are now proposing</div><div class="diff-removed">-        // We must track this here so we can reference it when checking for tranfser limits,</div><div class="diff-removed">-        // because transfers we propose now will not be in the consensus state within the lifetime</div><div class="diff-removed">-        // of this function</div><div class="diff-removed">-        let mut proposed = HashMap::<PeerId, usize>::new();</div><div class="diff-removed">-</div><div>         // Check for proper replica states</div><div>         for replica_set in shard_holder.all_shards() {</div><div>             let this_peer_id = replica_set.this_peer_id();</div><div class="diff-info">@@ -688,34 +691,13 @@ impl Collection {</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Try to find dead replicas with no active transfers</div><div>             let transfers = shard_holder.get_transfers(|_| true);</div><div> </div><div class="diff-removed">-            // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-            let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(this_peer_id);</div><div class="diff-removed">-            incoming += proposed.get(&this_peer_id).copied().unwrap_or(0);</div><div class="diff-removed">-            if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-removed">-                log::trace!(</div><div class="diff-removed">-                    "Postponing automatic shard {shard_id} transfer to stay below limit on this node (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-removed">-                );</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-removed">-            // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-removed">-            let shard_transfer_method = self</div><div class="diff-removed">-                .shared_storage_config</div><div class="diff-removed">-                .default_shard_transfer_method</div><div class="diff-removed">-                .unwrap_or_else(|| {</div><div class="diff-removed">-                    let all_support_wal_delta = self</div><div class="diff-removed">-                        .channel_service</div><div class="diff-removed">-                        .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-removed">-                    if all_support_wal_delta {</div><div class="diff-removed">-                        ShardTransferMethod::WalDelta</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        ShardTransferMethod::default()</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-added">+            // Count how many transfers we are now proposing</div><div class="diff-added">+            // We must track this here so we can reference it when checking for tranfser limits,</div><div class="diff-added">+            // because transfers we propose now will not be in the consensus state within the lifetime</div><div class="diff-added">+            // of this function</div><div class="diff-added">+            let mut proposed = HashMap::<PeerId, usize>::new();</div><div> </div><div>             // Try to find a replica to transfer from</div><div>             //</div><div class="diff-info">@@ -728,7 +710,22 @@ impl Collection {</div><div>                     to_shard_id: None,</div><div>                     sync: true,</div><div>                     // For automatic shard transfers, always select some default method from this point on</div><div class="diff-removed">-                    method: Some(shard_transfer_method),</div><div class="diff-added">+                    // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-added">+                    // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-added">+                    method: Some(</div><div class="diff-added">+                        self.shared_storage_config</div><div class="diff-added">+                            .default_shard_transfer_method</div><div class="diff-added">+                            .unwrap_or_else(|| {</div><div class="diff-added">+                                let all_support_wal_delta = self</div><div class="diff-added">+                                    .channel_service</div><div class="diff-added">+                                    .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-added">+                                if all_support_wal_delta {</div><div class="diff-added">+                                    ShardTransferMethod::WalDelta</div><div class="diff-added">+                                } else {</div><div class="diff-added">+                                    ShardTransferMethod::default()</div><div class="diff-added">+                                }</div><div class="diff-added">+                            }),</div><div class="diff-added">+                    ),</div><div>                 };</div><div> </div><div>                 if check_transfer_conflicts_strict(&transfer, transfers.iter()).is_some() {</div><div class="diff-info">@@ -746,14 +743,14 @@ impl Collection {</div><div>                 }</div><div> </div><div>                 // TODO: Should we, maybe, throttle/backoff this requests a bit?</div><div class="diff-removed">-                if let Err(err) = replica_set.health_check(replica_id).await {</div><div class="diff-added">+                if let Some(err) = replica_set.health_check(replica_id).await.err() {</div><div>                     // TODO: This is rather verbose, not sure if we want to log this at all... :/</div><div>                     log::trace!(</div><div>                         "Replica {replica_id}/{}:{} is not available \</div><div>                          to request shard transfer from: \</div><div>                          {err}",</div><div>                         self.id,</div><div class="diff-removed">-                        replica_set.shard_id,</div><div class="diff-added">+                        shard_id,</div><div>                     );</div><div>                     continue;</div><div>                 }</div><div class="diff-info">@@ -774,6 +771,122 @@ impl Collection {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-added">+    // Added in 835da45</div><div class="diff-added">+    fn check_auto_shard_transfer_limit(&self, incoming: usize, outgoing: usize) -> bool {</div><div class="diff-added">+        // We count both incoming and outgoing transfers for a peer.</div><div class="diff-added">+        // So if we have `limit` active transfers in total for a peer, no new task will be scheduled.</div><div class="diff-added">+        self.shared_storage_config.auto_shard_transfer_limit.map_or(false, |limit| {</div><div class="diff-added">+            incoming + outgoing >= limit</div><div class="diff-added">+        })</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn shard_recovery_point(&self, shard_id: ShardId) -> CollectionResult<RecoveryPoint> {</div><div class="diff-added">+        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-added">+        let Some(replica_set) = shard else {</div><div class="diff-added">+            return Err(CollectionError::NotFound {</div><div class="diff-added">+                what: format!("Shard {shard_id}"),</div><div class="diff-added">+            });</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        replica_set.shard_recovery_point().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn update_shard_cutoff_point(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        shard_id: ShardId,</div><div class="diff-added">+        cutoff: &RecoveryPoint,</div><div class="diff-added">+    ) -> CollectionResult<()> {</div><div class="diff-added">+        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-added">+        let Some(replica_set) = shard else {</div><div class="diff-added">+            return Err(CollectionError::NotFound {</div><div class="diff-added">+                what: format!("Shard {shard_id}"),</div><div class="diff-added">+            });</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        replica_set.update_shard_cutoff_point(cutoff).await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn state(&self) -> State {</div><div class="diff-added">+        let shards_holder = self.shards_holder.read().await;</div><div class="diff-added">+        let transfers = shards_holder.shard_transfers.read().clone();</div><div class="diff-added">+        let resharding = shards_holder.resharding_state.read().clone();</div><div class="diff-added">+</div><div class="diff-added">+        State {</div><div class="diff-added">+            config: self.collection_config.read().await.clone(),</div><div class="diff-added">+            shards: shards_holder</div><div class="diff-added">+                .get_shards()</div><div class="diff-added">+                .map(|(shard_id, replicas)| {</div><div class="diff-added">+                    let shard_info = ShardInfo {</div><div class="diff-added">+                        replicas: replicas.peers(),</div><div class="diff-added">+                    };</div><div class="diff-added">+                    (shard_id, shard_info)</div><div class="diff-added">+                })</div><div class="diff-added">+                .collect(),</div><div class="diff-added">+            resharding,</div><div class="diff-added">+            transfers,</div><div class="diff-added">+            shards_key_mapping: shards_holder.get_shard_key_to_ids_mapping(),</div><div class="diff-added">+            payload_index_schema: self.payload_index_schema.read().clone(),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-added">+        let config = self.collection_config.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-added">+            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-added">+        } else {</div><div class="diff-added">+            Ok(config.optimizer_config.clone())</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div class="diff-added">+        self.updates_lock.write().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn wait_collection_initiated(&self, timeout: Duration) -> bool {</div><div class="diff-added">+        self.is_initialized.await_ready_for_timeout(timeout)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn request_shard_transfer(&self, shard_transfer: ShardTransfer) {</div><div class="diff-added">+        self.request_shard_transfer_cb.deref()(shard_transfer)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn snapshots_path(&self) -> &Path {</div><div class="diff-added">+        &self.snapshots_path</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn shards_holder(&self) -> Arc<LockedShardHolder> {</div><div class="diff-added">+        self.shards_holder.clone()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn trigger_optimizers(&self) {</div><div class="diff-added">+        self.shards_holder.read().await.trigger_optimizers().await;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div class="diff-added">+    /// The cache gets updated every 32 calls.</div><div class="diff-added">+    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-added">+        self.collection_stats_cache</div><div class="diff-added">+            .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div class="diff-added">+            .await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    async fn estimate_collection_size_stats(</div><div class="diff-added">+        shards_holder: &Arc<RwLock<ShardHolder>>,</div><div class="diff-added">+    ) -> Option<CollectionSizeStats> {</div><div class="diff-added">+        let shard_lock = shards_holder.read().await;</div><div class="diff-added">+        let result = shard_lock.estimate_collection_size_stats().await;</div><div class="diff-added">+        result</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn clean_local_shards_statuses(&self) -> HashMap<ShardId, clean::ShardCleanStatus> {</div><div class="diff-added">+        self.shard_clean_tasks.statuses()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub async fn get_telemetry_data(&self, detail: TelemetryDetail) -> CollectionTelemetry {</div><div>         let (shards_telemetry, transfers, resharding) = {</div><div>             if detail.level >= DetailsLevel::Level3 {</div><div class="diff-info">@@ -837,55 +950,6 @@ impl Collection {</div><div>             params: self.collection_config.read().await.params.clone(),</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div class="diff-removed">-        self.updates_lock.write().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn wait_collection_initiated(&self, timeout: Duration) -> bool {</div><div class="diff-removed">-        self.is_initialized.await_ready_for_timeout(timeout)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn request_shard_transfer(&self, shard_transfer: ShardTransfer) {</div><div class="diff-removed">-        self.request_shard_transfer_cb.deref()(shard_transfer)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn snapshots_path(&self) -> &Path {</div><div class="diff-removed">-        &self.snapshots_path</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn shards_holder(&self) -> Arc<LockedShardHolder> {</div><div class="diff-removed">-        self.shards_holder.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn trigger_optimizers(&self) {</div><div class="diff-removed">-        self.shards_holder.read().await.trigger_optimizers().await;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    async fn estimate_collection_size_stats(</div><div class="diff-removed">-        shards_holder: &Arc<RwLock<ShardHolder>>,</div><div class="diff-removed">-    ) -> Option<CollectionSizeStats> {</div><div class="diff-removed">-        let shard_lock = shards_holder.read().await;</div><div class="diff-removed">-        shard_lock.estimate_collection_size_stats().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div class="diff-removed">-    /// The cache gets updated every 32 calls.</div><div class="diff-removed">-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-removed">-        self.collection_stats_cache</div><div class="diff-removed">-            .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div> }</div><div> </div><div> struct CollectionVersion;</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    