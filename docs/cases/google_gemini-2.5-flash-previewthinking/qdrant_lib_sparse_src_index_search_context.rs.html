<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/sparse/src/index/search_context.rs - Gemini 2.5 Flash Thinking</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/sparse/src/index/search_context.rs</h1>
        <h2>Model: Gemini 2.5 Flash Thinking</h2>
        <p><a href="../../models/google_gemini-2.5-flash-previewthinking.html">All Gemini 2.5 Flash Thinking Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash Thinking</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 73797</p>
                <p><strong>Native Prompt Tokens:</strong> 91332</p>
                <p><strong>Native Completion Tokens:</strong> 16151</p>
                <p><strong>Native Tokens Reasoning:</strong> 4445</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.0702283</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_sparse_src_index_search_context.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_sparse_src_index_search_context.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_sparse_src_index_search_context.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8be5822c..9af7dcb0 100644</div><div class="diff-header">--- a/qdrant_lib_sparse_src_index_search_context.rs_expectedoutput.txt (expected):tmp/tmpxso5k0ur_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_sparse_src_index_search_context.rs_extracted.txt (actual):tmp/tmptyoxm5o0_actual.txt	</div><div class="diff-info">@@ -1,4 +1,5 @@</div><div> use std::cmp::{Ordering, max, min};</div><div class="diff-added">+use std::mem::size_of;</div><div> use std::sync::atomic::AtomicBool;</div><div> use std::sync::atomic::Ordering::Relaxed;</div><div> </div><div class="diff-info">@@ -116,13 +117,10 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>             // collect indices and values for the current record id from the query's posting lists *only*</div><div>             for posting_iterator in self.postings_iterators.iter_mut() {</div><div>                 // rely on underlying binary search as the posting lists are sorted by record id</div><div class="diff-removed">-                match posting_iterator.posting_list_iterator.skip_to(id) {</div><div class="diff-removed">-                    None => {} // no match for posting list</div><div class="diff-removed">-                    Some(element) => {</div><div class="diff-removed">-                        // match for posting list</div><div class="diff-removed">-                        indices.push(posting_iterator.query_index);</div><div class="diff-removed">-                        values.push(element.weight);</div><div class="diff-removed">-                    }</div><div class="diff-added">+                if let Some(element) = posting_iterator.posting_list_iterator.skip_to(id) {</div><div class="diff-added">+                    // match for posting list</div><div class="diff-added">+                    indices.push(posting_iterator.query_index);</div><div class="diff-added">+                    values.push(element.weight);</div><div>                 }</div><div>             }</div><div> </div><div class="diff-info">@@ -214,11 +212,11 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>     /// Returns the next min record id from all posting list iterators</div><div>     ///</div><div>     /// returns None if all posting list iterators are exhausted</div><div class="diff-removed">-    fn next_min_id(to_inspect: &mut [IndexedPostingListIterator<T>]) -> Option<PointOffsetType> {</div><div class="diff-added">+    fn next_min_id(&mut self) -> Option<PointOffsetType> {</div><div>         let mut min_record_id = None;</div><div> </div><div>         // Iterate to find min record id at the head of the posting lists</div><div class="diff-removed">-        for posting_iterator in to_inspect.iter_mut() {</div><div class="diff-added">+        for posting_iterator in self.postings_iterators.iter_mut() {</div><div>             if let Some(next_element) = posting_iterator.posting_list_iterator.peek() {</div><div>                 match min_record_id {</div><div>                     None => min_record_id = Some(next_element.record_id), // first record with matching id</div><div class="diff-info">@@ -311,11 +309,11 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div> </div><div>             // remove empty posting lists if necessary</div><div>             self.postings_iterators.retain(|posting_iterator| {</div><div class="diff-removed">-                posting_iterator.posting_list_iterator.len_to_end() != 0</div><div class="diff-added">+                !posting_iterator.posting_list_iterator.is_empty()</div><div>             });</div><div> </div><div>             // update min_record_id</div><div class="diff-removed">-            self.min_record_id = Self::next_min_id(&mut self.postings_iterators);</div><div class="diff-added">+            self.min_record_id = self.next_min_id();</div><div> </div><div>             // check if all posting lists are exhausted</div><div>             if self.postings_iterators.is_empty() {</div><div class="diff-info">@@ -345,7 +343,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>                 let pruned = self.prune_longest_posting_list(new_min_score);</div><div>                 if pruned {</div><div>                     // update min_record_id</div><div class="diff-removed">-                    self.min_record_id = Self::next_min_id(&mut self.postings_iterators);</div><div class="diff-added">+                    self.min_record_id = self.next_min_id();</div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-info">@@ -419,4 +417,672 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         // no pruning took place</div><div>         false</div><div>     }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+#[cfg(test)]</div><div class="diff-added">+#[generic_tests::define]</div><div class="diff-added">+mod tests {</div><div class="diff-added">+    use std::any::TypeId;</div><div class="diff-added">+    use std::borrow::Cow;</div><div class="diff-added">+    use std::mem::size_of;</div><div class="diff-added">+    use std::sync::OnceLock;</div><div class="diff-added">+</div><div class="diff-added">+    use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-added">+    use rand::Rng;</div><div class="diff-added">+    use tempfile::TempDir;</div><div class="diff-added">+</div><div class="diff-added">+    use super::*;</div><div class="diff-added">+    use crate::common::scores_memory_pool::ScoresMemoryPool;</div><div class="diff-added">+    use crate::common::sparse_vector::SparseVector;</div><div class="diff-added">+    use crate::common::sparse_vector_fixture::random_sparse_vector;</div><div class="diff-added">+    use crate::common::types::QuantizedU8;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram_builder::InvertedIndexBuilder;</div><div class="diff-added">+    use crate::index::posting_list::PostingList;</div><div class="diff-added">+    use crate::index::posting_list_common::PostingListIter;</div><div class="diff-added">+</div><div class="diff-added">+    // ---- Test instantiations ----</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexRam>)]</div><div class="diff-added">+    mod ram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexMmap>)]</div><div class="diff-added">+    mod mmap {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexImmutableRam>)]</div><div class="diff-added">+    mod iram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<f32>>)]</div><div class="diff-added">+    mod iram_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<half::f16>>)]</div><div class="diff-added">+    mod iram_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<u8>>)]</div><div class="diff-added">+    mod iram_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<QuantizedU8>>)]</div><div class="diff-added">+    mod iram_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<f32>>)]</div><div class="diff-added">+    mod mmap_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<half::f16>>)]</div><div class="diff-added">+    mod mmap_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<u8>>)]</div><div class="diff-added">+    mod mmap_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<QuantizedU8>>)]</div><div class="diff-added">+    mod mmap_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    // --- End of test instantiations ---</div><div class="diff-added">+</div><div class="diff-added">+    static TEST_SCORES_POOL: OnceLock<ScoresMemoryPool> = OnceLock::new();</div><div class="diff-added">+</div><div class="diff-added">+    fn get_pooled_scores() -> PooledScoresHandle<'static> {</div><div class="diff-added">+        TEST_SCORES_POOL</div><div class="diff-added">+            .get_or_init(ScoresMemoryPool::default)</div><div class="diff-added">+            .get()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Match all filter condition for testing</div><div class="diff-added">+    fn match_all(_p: PointOffsetType) -> bool {</div><div class="diff-added">+        true</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Helper struct to store both an index and a temporary directory</div><div class="diff-added">+    struct TestIndex<I: InvertedIndex> {</div><div class="diff-added">+        index: I,</div><div class="diff-added">+        _temp_dir: TempDir,</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    impl<I: InvertedIndex> TestIndex<I> {</div><div class="diff-added">+        fn from_ram(ram_index: InvertedIndexRam) -> Self {</div><div class="diff-added">+            let temp_dir = tempfile::Builder::new()</div><div class="diff-added">+                .prefix("test_index_dir")</div><div class="diff-added">+                .tempdir()</div><div class="diff-added">+                .unwrap();</div><div class="diff-added">+            TestIndex {</div><div class="diff-added">+                index: I::from_ram_index(Cow::Owned(ram_index), &temp_dir).unwrap(),</div><div class="diff-added">+                _temp_dir: temp_dir,</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Round scores to allow some quantization errors</div><div class="diff-added">+    fn round_scores<I: 'static>(mut scores: Vec<ScoredPointOffset>) -> Vec<ScoredPointOffset> {</div><div class="diff-added">+        let errors_allowed_for = [</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedImmutableRam<QuantizedU8>>(),</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedMmap<QuantizedU8>>(),</div><div class="diff-added">+        ];</div><div class="diff-added">+        if errors_allowed_for.contains(&TypeId::of::<I>()) {</div><div class="diff-added">+            let precision = 0.25;</div><div class="diff-added">+            scores.iter_mut().for_each(|score| {</div><div class="diff-added">+                score.score = (score.score / precision).round() * precision;</div><div class="diff-added">+            });</div><div class="diff-added">+            scores</div><div class="diff-added">+        } else {</div><div class="diff-added">+            scores</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn test_empty_query<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram(InvertedIndexRam::empty());</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector::default(), // empty query vector</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            HardwareCounterCell::new(),</div><div class="diff-added">+        );</div><div class="diff-added">+        assert_eq!(search_context.search(&match_all), Vec::new());</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        let posting_list_element_size = size_of::<u32>() + size_of::<DimWeight>();</div><div class="diff-added">+        let expected_cpu_score = posting_list_element_size * 9;</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), expected_cpu_score as u64);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_update_test<I: InvertedIndex + 'static>() {</div><div class="diff-added">+        if TypeId::of::<I>() != TypeId::of::<InvertedIndexRam>() {</div><div class="diff-added">+            // Only InvertedIndexRam supports upserts</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let mut index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // update index with new point</div><div class="diff-added">+        index.index.upsert(</div><div class="diff-added">+            4,</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![40.0, 40.0, 40.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            None,</div><div class="diff-added">+        );</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            search_context.search(&match_all),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 120.0,</div><div class="diff-added">+                    idx: 4</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_hot_key_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 1.0)].into());</div><div class="diff-added">+            builder.add(5, [(1, 2.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 3.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 4.0)].into());</div><div class="diff-added">+            builder.add(8, [(1, 5.0)].into());</div><div class="diff-added">+            builder.add(9, [(1, 6.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+        let posting_list_element_size = size_of::<u32>() + size_of::<DimWeight>();</div><div class="diff-added">+        // [ID=1] (Retrieve all 9 Vectors) => 9</div><div class="diff-added">+        // [ID=2] (Retrieve 1-3)           => 3</div><div class="diff-added">+        // [ID=3] (Retrieve 1-3)           => 3</div><div class="diff-added">+        //                       3 + 3 + 9 => 15</div><div class="diff-added">+        let expected_cpu_score = posting_list_element_size * 15;</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), expected_cpu_score as u64);</div><div class="diff-added">+</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            4,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset { score: 6.0, idx: 9 },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // No difference to previous calculation because it's the same amount of score</div><div class="diff-added">+        // calculations when increasing the "top" parameter.</div><div class="diff-added">+        let expected_cpu_score = posting_list_element_size * (3 + 3 + 9); // The same as above as index is not pruned</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), expected_cpu_score as u64);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_single_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 20.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_under_prune_test<I: InvertedIndex>() {</div><div class="diff-added">+        if !I::Iter::reliable_max_next_weight() {</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 40.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // one would expect this to prune up to `6` but it does not happen it practice because we are under pruning by design</div><div class="diff-added">+        // we should actually check the best score up to `6` - 1 only instead of the max possible score (40.0)</div><div class="diff-added">+        assert!(!search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(40.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 2); // 6, 7</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Generates a random inverted index with `num_vectors` vectors</div><div class="diff-added">+    #[allow(dead_code)]</div><div class="diff-added">+    fn random_inverted_index<R: Rng + ?Sized>(</div><div class="diff-added">+        rnd_gen: &mut R,</div><div class="diff-added">+        num_vectors: u32,</div><div class="diff-added">+        max_sparse_dimension: usize,</div><div class="diff-added">+    ) -> InvertedIndexRam {</div><div class="diff-added">+        let mut inverted_index_ram = InvertedIndexRam::empty();</div><div class="diff-added">+</div><div class="diff-added">+        for i in 1..=num_vectors {</div><div class="diff-added">+            let SparseVector { indices, values } =</div><div class="diff-added">+                random_sparse_vector(rnd_gen, max_sparse_dimension);</div><div class="diff-added">+            let vector = RemappedSparseVector::new(indices, values).unwrap();</div><div class="diff-added">+            inverted_index_ram.upsert(i, vector, None);</div><div class="diff-added">+        }</div><div class="diff-added">+        inverted_index_ram</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn promote_longest_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 2); // posting 2</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(1), 3); // posting 3</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(2), 2); // posting 1</div><div class="diff-added">+</div><div class="diff-added">+        search_context.promote_longest_posting_lists_to_the_front();</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 3); // posting 3</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn plain_search_all_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        let scores = search_context.plain_search(&[1, 3, 2]);</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(scores),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 3,</div><div class="diff-added">+                    score: 60.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 2,</div><div class="diff-added">+                    score: 40.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 1,</div><div class="diff-added">+                    score: 30.0</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // [ID=1] (Retrieve three sparse vectors (1,2,3)) + QueryLength=3 => 6</div><div class="diff-added">+        // [ID=2] (Retrieve two sparse vectors (1,3))     + QueryLength=3 => 5</div><div class="diff-added">+        // [ID=3] (Retrieve two sparse vectors (1,3))     + QueryLength=3 => 5</div><div class="diff-added">+        //                                                      6 + 5 + 5 => 16</div><div class="diff-added">+</div><div class="diff-added">+        // CPU cost in plain search comes from:</div><div class="diff-added">+        // (sparse vector length of point 1) * (size of DimWeight) + (Query vector length) +</div><div class="diff-added">+        // (sparse vector length of point 2) * (size of DimWeight) + (Query vector length) +</div><div class="diff-added">+        // (sparse vector length of point 3) * (size of DimWeight) + (Query vector length)</div><div class="diff-added">+        //</div><div class="diff-added">+        // Query vector length = 3 * size_of::<DimId>() + 3 * size_of::<DimWeight>()</div><div class="diff-added">+        // Point 1 has indices [1, 2, 3]</div><div class="diff-added">+        // Point 2 has indices [1, 3]</div><div class="diff-added">+        // Point 3 has indices [1, 3]</div><div class="diff-added">+        //</div><div class="diff-added">+        // Point 1 with query [1, 2, 3] results in elements for indices [1, 2, 3] - 3 elements * size_of::<DimWeight>() retrieved.</div><div class="diff-added">+        // Point 2 with query [1, 2, 3] results in elements for indices [1, 3] - 2 elements * size_of::<DimWeight>() retrieved.</div><div class="diff-added">+        // Point 3 with query [1, 2, 3] results in elements for indices [1, 3] - 2 elements * size_of::<DimWeight>() retrieved.</div><div class="diff-added">+        //</div><div class="diff-added">+        // Sum of retrieved elements: 3 + 2 + 2 = 7</div><div class="diff-added">+        // CPU cost: 7 * size_of::<DimWeight>() + 3 * QueryLength</div><div class="diff-added">+        // QueryLength = 3 * (size_of::<DimId>() + size_of::<DimWeight>()) = 3 * (4 + 8) = 36 bytes</div><div class="diff-added">+        // CPU cost: 7 * 8 + 3 * 36 = 56 + 108 = 164 bytes</div><div class="diff-added">+        // This accounting seems too simple - plain search cpu usage must be higher.</div><div class="diff-added">+        // Let's check original commits' test expectation.</div><div class="diff-added">+        // commit 0cfb3b0e1d579e5ce633432f640a7f25b6437740 expected 16. This seems to count elements regardless of size.</div><div class="diff-added">+        // CPU cost: 7 (retrieved elements) + 3 * 3 (query length) = 7 + 9 = 16</div><div class="diff-added">+        let query_len = search_context.query.indices.len();</div><div class="diff-added">+        let expected_cpu_score = 7 + 3 * query_len; // Seems to count elements + query length mentions</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), expected_cpu_score as u64);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn plain_search_gap_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        // query vector has a gap for dimension 2</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        let scores = search_context.plain_search(&[1, 2, 3]);</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(scores),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 2,</div><div class="diff-added">+                    score: 40.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 3,</div><div class="diff-added">+                    score: 30.0 // the dimension 2 did not contribute to the score</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 1,</div><div class="diff-added">+                    score: 20.0 // the dimension 2 did not contribute to the score</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // [ID=1] (Retrieve two sparse vectors (1,2)) + QueryLength=2 => 4</div><div class="diff-added">+        // [ID=2] (Retrieve two sparse vectors (1,3)) + QueryLength=2 => 4</div><div class="diff-added">+        // [ID=3] (Retrieve one sparse vector (3))    + QueryLength=2 => 3</div><div class="diff-added">+        //                                                  4 + 4 + 3 => 11</div><div class="diff-added">+</div><div class="diff-added">+        // Point 1 with query [1, 3] results in elements for indices [1, 3] - 2 elements retrieved. Query length 2. Cost = 2 + 2 = 4</div><div class="diff-added">+        // Point 2 with query [1, 3] results in elements for indices [1, 3] - 2 elements retrieved. Query length 2. Cost = 2 + 2 = 4</div><div class="diff-added">+        // Point 3 with query [1, 3] results in elements for indices [3] - 1 element retrieved. Query length 2. Cost = 1 + 2 = 3</div><div class="diff-added">+        // Total cost: 4 + 4 + 3 = 11</div><div class="diff-added">+        let query_len = search_context.query.indices.len();</div><div class="diff-added">+        let expected_cpu_score = (2 + query_len) + (2 + query_len) + (1 + query_len);</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), expected_cpu_score as u64);</div><div class="diff-added">+    }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    