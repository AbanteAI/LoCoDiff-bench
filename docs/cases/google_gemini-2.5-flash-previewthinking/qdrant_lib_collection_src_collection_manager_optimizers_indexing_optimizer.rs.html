<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs - Gemini 2.5 Flash Thinking</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-previewthinking.html">‚Üê Back to Gemini 2.5 Flash Thinking Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash Thinking</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58760</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 74953</p>
                <p><strong>Native Completion Tokens:</strong> 16379</p>
                <p><strong>Native Tokens Reasoning:</strong> 5505</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.06856945</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 237415b4..e720dbbe 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected):tmp/tmpure2h7ox_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual):tmp/tmpkge9jg99_actual.txt	</div><div class="diff-info">@@ -1,20 +1,29 @@</div><div class="diff-removed">-use std::collections::HashSet;</div><div class="diff-removed">-use std::path::{Path, PathBuf};</div><div class="diff-removed">-use std::sync::Arc;</div><div class="diff-removed">-</div><div class="diff-removed">-use parking_lot::Mutex;</div><div class="diff-removed">-use segment::common::operation_time_statistics::OperationDurationsAggregator;</div><div class="diff-removed">-use segment::types::{HnswConfig, QuantizationConfig, SegmentType};</div><div class="diff-removed">-</div><div> use crate::collection_manager::holders::segment_holder::{</div><div class="diff-removed">-    LockedSegmentHolder, SegmentHolder, SegmentId,</div><div class="diff-added">+    LockedSegment, LockedSegmentHolder, SegmentId, SegmentHolder,</div><div> };</div><div> use crate::collection_manager::optimizers::segment_optimizer::{</div><div>     OptimizerThresholds, SegmentOptimizer,</div><div> };</div><div> use crate::config::CollectionParams;</div><div class="diff-added">+use common::budget::ResourceBudget;</div><div class="diff-added">+use common::counter::hardware_counter::HardwareCounter;</div><div class="diff-added">+use common::types::TelemetryDetail;</div><div class="diff-added">+use parking_lot::Mutex;</div><div class="diff-added">+use rand::rng;</div><div class="diff-added">+use segment::common::operation_time_statistics::OperationDurationsAggregator;</div><div class="diff-added">+use segment::entry::entry_point::SegmentEntry;</div><div class="diff-added">+use segment::index::hnsw_index::num_rayon_threads;</div><div class="diff-added">+use segment::segment::SegmentShared;</div><div class="diff-added">+use segment::segment_constructor::build_segment;</div><div class="diff-added">+use segment::types::{HnswConfig, QuantizationConfig, SegmentType};</div><div class="diff-added">+use segment::{Segment, SegmentState};</div><div class="diff-added">+use std::collections::HashSet;</div><div class="diff-added">+use std::path::{Path, PathBuf};</div><div class="diff-added">+use std::sync::atomic::AtomicBool;</div><div class="diff-added">+use std::sync::Arc;</div><div> </div><div> const BYTES_IN_KB: usize = 1024;</div><div class="diff-added">+const INDEXING_OPTIMIZER_NAME: &str = "indexing";</div><div> </div><div> /// Looks for the segments, which require to be indexed.</div><div> ///</div><div class="diff-info">@@ -81,9 +90,9 @@ impl IndexingOptimizer {</div><div>                     return None;</div><div>                 }</div><div> </div><div class="diff-removed">-                Some((idx, vector_size))</div><div class="diff-added">+                Some((*idx, vector_size))</div><div>             })</div><div class="diff-removed">-            .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes)</div><div class="diff-added">+            .min_by_key(|(_, vector_size)| *vector_size)</div><div>             .map(|(idx, size)| (*idx, size))</div><div>     }</div><div> </div><div class="diff-info">@@ -100,6 +109,7 @@ impl IndexingOptimizer {</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div>                 let read_segment = segment_entry.read();</div><div class="diff-added">+                let point_count = read_segment.available_point_count();</div><div>                 let max_vector_size_bytes = read_segment</div><div>                     .max_available_vectors_size_in_bytes()</div><div>                     .unwrap_or_default();</div><div class="diff-info">@@ -110,6 +120,10 @@ impl IndexingOptimizer {</div><div>                     return None; // Never optimize already optimized segment</div><div>                 }</div><div> </div><div class="diff-added">+                // Apply indexing to plain segments which have grown too big</div><div class="diff-added">+                let are_all_vectors_indexed = segment_config.are_all_vectors_indexed();</div><div class="diff-added">+                let is_any_on_disk = segment_config.is_any_on_disk();</div><div class="diff-added">+</div><div>                 let indexing_threshold_bytes = self</div><div>                     .thresholds_config</div><div>                     .indexing_threshold_kb</div><div class="diff-info">@@ -188,6 +202,7 @@ impl IndexingOptimizer {</div><div>         }</div><div>         let (selected_segment_id, selected_segment_size) = *selected_segment.unwrap();</div><div> </div><div class="diff-added">+        let segments_read_guard = segments.read();</div><div>         let number_of_segments = segments_read_guard.len();</div><div> </div><div>         // If the number of segments if equal or bigger than the default_segments_number</div><div class="diff-info">@@ -233,11 +248,48 @@ impl IndexingOptimizer {</div><div> </div><div>         vec![selected_segment_id]</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+    fn build_indexing_segment(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        segments: &[SegmentShared],</div><div class="diff-added">+        id_tracker: Arc<parking_lot::RwLock<id_tracker::simple_id_tracker::SimpleIdTracker>>,</div><div class="diff-added">+        stopped: &AtomicBool,</div><div class="diff-added">+        resource_budget: ResourceBudget,</div><div class="diff-added">+        telemetry_hardware_counter: &HardwareCounter,</div><div class="diff-added">+    ) -> Result<SegmentShared, anyhow::Error> {</div><div class="diff-added">+        let optimized_segment_id = segments</div><div class="diff-added">+            .first()</div><div class="diff-added">+            .and_then(|s| s.read().id())</div><div class="diff-added">+            .unwrap_or_else(|| 0.into());</div><div class="diff-added">+        let segment_temp_dir = self</div><div class="diff-added">+            .collection_temp_dir</div><div class="diff-added">+            .join(format!("optimise_{}", optimized_segment_id));</div><div class="diff-added">+</div><div class="diff-added">+        std::fs::create_dir_all(&segment_temp_dir)?;</div><div class="diff-added">+</div><div class="diff-added">+        let temp_segment = build_segment(</div><div class="diff-added">+            segments,</div><div class="diff-added">+            &segment_temp_dir,</div><div class="diff-added">+            id_tracker,</div><div class="diff-added">+            &self.collection_params,</div><div class="diff-added">+            self.hnsw_config(),</div><div class="diff-added">+            self.quantization_config(),</div><div class="diff-added">+            stopped,</div><div class="diff-added">+            resource_budget,</div><div class="diff-added">+            telemetry_hardware_counter,</div><div class="diff-added">+        )?;</div><div class="diff-added">+</div><div class="diff-added">+        temp_segment.flush()?;</div><div class="diff-added">+</div><div class="diff-added">+        Ok(temp_segment)</div><div class="diff-added">+    }</div><div> }</div><div> </div><div class="diff-added">+use segment::id_tracker;</div><div class="diff-added">+</div><div> impl SegmentOptimizer for IndexingOptimizer {</div><div>     fn name(&self) -> &str {</div><div class="diff-removed">-        "indexing"</div><div class="diff-added">+        INDEXING_OPTIMIZER_NAME</div><div>     }</div><div> </div><div>     fn segments_path(&self) -> &Path {</div><div class="diff-info">@@ -272,17 +324,114 @@ impl SegmentOptimizer for IndexingOptimizer {</div><div>         self.worst_segment(segments, excluded_ids)</div><div>     }</div><div> </div><div class="diff-added">+    fn get_telemetry_data(&self, detail: TelemetryDetail) -> OperationDurationStatistics {</div><div class="diff-added">+        self.get_telemetry_counter().lock().get_statistics(detail)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     fn get_telemetry_counter(&self) -> &Mutex<OperationDurationsAggregator> {</div><div>         &self.telemetry_durations_aggregator</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+    fn optimize(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        segments_holder: LockedSegmentHolder,</div><div class="diff-added">+        segments_to_optimize: Vec<SegmentId>,</div><div class="diff-added">+        resource_budget: ResourceBudget,</div><div class="diff-added">+        stopped: &AtomicBool,</div><div class="diff-added">+    ) -> Result<usize, anyhow::Error> {</div><div class="diff-added">+        let segments: Vec<SegmentShared> = segments_holder.read().values(|id| {</div><div class="diff-added">+            segments_to_optimize.contains(&id.to_owned().into())</div><div class="diff-added">+        });</div><div class="diff-added">+        if segments.is_empty() {</div><div class="diff-added">+            let segments_read_guard = segments_holder.read();</div><div class="diff-added">+            let number_of_segments = segments_read_guard.len();</div><div class="diff-added">+            let max_segment_size_bytes = self</div><div class="diff-added">+                .thresholds_config</div><div class="diff-added">+                .max_segment_size_kb</div><div class="diff-added">+                .saturating_mul(BYTES_IN_KB);</div><div class="diff-added">+            let total_segments_size_bytes: usize = segments_read_guard</div><div class="diff-added">+                .iter()</div><div class="diff-added">+                .map(|(_, segment)| {</div><div class="diff-added">+                    segment.get().read().available_vectors_size_in_bytes(None).unwrap_or_default()</div><div class="diff-added">+                })</div><div class="diff-added">+                .sum();</div><div class="diff-added">+</div><div class="diff-added">+            // Check if new appendable segment is required:</div><div class="diff-added">+            // If there are no unindexed large segments to optimize AND</div><div class="diff-added">+            // total number of segments is less than default AND</div><div class="diff-added">+            // all segments already exceed max_segment_size</div><div class="diff-added">+            if number_of_segments < self.default_segments_number && total_segments_size_bytes.saturating_div(number_of_segments) > max_segment_size_bytes {</div><div class="diff-added">+                let current_segments: Vec<_> = segments_read_guard</div><div class="diff-added">+                    .iter()</div><div class="diff-added">+                    .map(|(id, s)| (*id, s.get().read()))</div><div class="diff-added">+                    .collect();</div><div class="diff-added">+                log::debug!("creating new appendable segment: reason: no segments to optimize; \</div><div class="diff-added">+                             number_of_segments: {}; \</div><div class="diff-added">+                             default_segments_number: {}; \</div><div class="diff-added">+                             max_segment_size_bytes: {}; \</div><div class="diff-added">+                             total_segments_size_bytes: {};</div><div class="diff-added">+                             current_segments: {:#?};</div><div class="diff-added">+                             candidates: {:#?}",</div><div class="diff-added">+                             number_of_segments,</div><div class="diff-added">+                             self.default_segments_number,</div><div class="diff-added">+                             max_segment_size_bytes,</div><div class="diff-added">+                             total_segments_size_bytes,</div><div class="diff-added">+                             current_segments.iter().map(|(id, s)| (id, s.info())).collect::<Vec<_>>(),</div><div class="diff-added">+                             self.worst_segment(segments_holder.clone(), &Default::default()),</div><div class="diff-added">+                );</div><div class="diff-added">+</div><div class="diff-added">+                let new_segment_id = segments_read_guard.generate_new_segment_id();</div><div class="diff-added">+                let new_segment = build_segment(</div><div class="diff-added">+                    &[],</div><div class="diff-added">+                    self.segments_path(),</div><div class="diff-added">+                    segments_read_guard.id_tracker().clone(),</div><div class="diff-added">+                    &self.collection_params,</div><div class="diff-added">+                    self.hnsw_config(),</div><div class="diff-added">+                    self.quantization_config(),</div><div class="diff-added">+                    stopped,</div><div class="diff-added">+                    resource_budget,</div><div class="diff-added">+                    &HardwareCounter::default() // No need for hardware counter for creating an empty segment</div><div class="diff-added">+                )?;</div><div class="diff-added">+                segments_read_guard.drop_replace_merge(segments_to_optimize.iter().copied(), [new_segment_id].iter().copied(), new_segment.into())?;</div><div class="diff-added">+                return Ok(0);</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            return Ok(0); // Nothing to optimize</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let optimized_point_count = segments</div><div class="diff-added">+            .iter()</div><div class="diff-added">+            .map(|segment| segment.read().available_point_count())</div><div class="diff-added">+            .sum();</div><div class="diff-added">+</div><div class="diff-added">+        let _timer = self.get_telemetry_counter().lock().guard_operation();</div><div class="diff-added">+</div><div class="diff-added">+        let id_tracker = segments.first().unwrap().read().id_tracker().clone();</div><div class="diff-added">+</div><div class="diff-added">+        let new_segment = self.build_indexing_segment(</div><div class="diff-added">+            &segments,</div><div class="diff-added">+            id_tracker,</div><div class="diff-added">+            stopped,</div><div class="diff-added">+            resource_budget,</div><div class="diff-added">+            &HardwareCounter::default()</div><div class="diff-added">+        )?;</div><div class="diff-added">+</div><div class="diff-added">+        segments_holder.read().drop_replace_merge(</div><div class="diff-added">+            segments_to_optimize.iter().copied(),</div><div class="diff-added">+            [new_segment.read().id().unwrap()].iter().copied(),</div><div class="diff-added">+            new_segment.into(),</div><div class="diff-added">+        )?;</div><div class="diff-added">+</div><div class="diff-added">+        Ok(optimized_point_count)</div><div class="diff-added">+    }</div><div> }</div><div> </div><div> #[cfg(test)]</div><div> mod tests {</div><div>     use std::collections::BTreeMap;</div><div>     use std::ops::Deref;</div><div class="diff-removed">-    use std::sync::Arc;</div><div>     use std::sync::atomic::AtomicBool;</div><div class="diff-added">+    use std::sync::Arc;</div><div> </div><div>     use common::budget::ResourceBudget;</div><div>     use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-info">@@ -295,7 +444,9 @@ mod tests {</div><div>     use segment::index::hnsw_index::num_rayon_threads;</div><div>     use segment::json_path::JsonPath;</div><div>     use segment::payload_json;</div><div class="diff-removed">-    use segment::segment_constructor::simple_segment_constructor::{VECTOR1_NAME, VECTOR2_NAME};</div><div class="diff-added">+    use segment::segment_constructor::simple_segment_constructor::{</div><div class="diff-added">+        VECTOR1_NAME, VECTOR2_NAME,</div><div class="diff-added">+    };</div><div>     use segment::types::{Distance, PayloadSchemaType, VectorNameBuf};</div><div>     use tempfile::Builder;</div><div> </div><div class="diff-info">@@ -591,10 +742,7 @@ mod tests {</div><div>             "Testing that 2 segments are actually indexed"</div><div>         );</div><div> </div><div class="diff-removed">-        let on_disk_count = configs</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .filter(|config| config.is_any_on_disk())</div><div class="diff-removed">-            .count();</div><div class="diff-added">+        let on_disk_count = configs.iter().filter(|config| config.is_any_on_disk()).count();</div><div>         assert_eq!(</div><div>             on_disk_count, 1,</div><div>             "Testing that only largest segment is not Mmap"</div><div class="diff-info">@@ -718,6 +866,8 @@ mod tests {</div><div>         let insert_point_ops =</div><div>             PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div> </div><div class="diff-added">+        let hw_counter = HardwareCounterCell::new();</div><div class="diff-added">+</div><div>         process_point_operation(</div><div>             locked_holder.deref(),</div><div>             opnum.next().unwrap(),</div><div class="diff-info">@@ -938,6 +1088,9 @@ mod tests {</div><div>             .on_disk</div><div>             .take();</div><div> </div><div class="diff-added">+        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-added">+        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-added">+</div><div>         // Optimizers used in test</div><div>         let index_optimizer = IndexingOptimizer::new(</div><div>             2,</div><div class="diff-info">@@ -953,20 +1106,15 @@ mod tests {</div><div>             dir.path().to_owned(),</div><div>             temp_dir.path().to_owned(),</div><div>             collection_params,</div><div class="diff-removed">-            hnsw_config,</div><div class="diff-added">+            hnsw_config.clone(),</div><div>             Default::default(),</div><div>         );</div><div> </div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div>         // Use indexing optimizer to build mmap</div><div>         let changed = index_optimizer</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 vec![segment_id],</div><div class="diff-removed">-                permit,</div><div>                 budget.clone(),</div><div>                 &false.into(),</div><div>             )</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    