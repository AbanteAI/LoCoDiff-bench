<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Gemini 2.5 Flash Thinking</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-previewthinking.html">‚Üê Back to Gemini 2.5 Flash Thinking Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash Thinking</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 75872</p>
                <p><strong>Native Completion Tokens:</strong> 19698</p>
                <p><strong>Native Tokens Reasoning:</strong> 7959</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.0803238</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-previewthinking/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb3..af24ae40 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpvils2zfb_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmp6qjufkrj_actual.txt	</div><div class="diff-info">@@ -21,6 +21,7 @@ use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div> use common::rate_limiting::RateLimiter;</div><div class="diff-added">+use common::telemetry_module::TelemetryDetail;</div><div> use common::{panic, tar_ext};</div><div> use indicatif::{ProgressBar, ProgressStyle};</div><div> use itertools::Itertools;</div><div class="diff-info">@@ -34,6 +35,7 @@ use segment::types::{</div><div>     Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,</div><div>     SnapshotFormat,</div><div> };</div><div class="diff-added">+use segment::vector_storage::common::get_async_scorer;</div><div> use tokio::fs::{create_dir_all, remove_dir_all, remove_file};</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::Sender;</div><div class="diff-info">@@ -55,22 +57,18 @@ use crate::config::CollectionConfigInternal;</div><div> use crate::operations::OperationWithClockTag;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{</div><div class="diff-removed">-    CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div class="diff-removed">-    check_sparse_compatible_with_segment_config,</div><div class="diff-added">+    CollectionError, CollectionRequestVerification, CollectionResult, OptimizersStatus,</div><div class="diff-added">+    ShardInfoInternal, ShardStatus, check_sparse_compatible_with_segment_config,</div><div> };</div><div> use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::CollectionId;</div><div> use crate::shards::shard::ShardId;</div><div> use crate::shards::shard_config::ShardConfig;</div><div class="diff-added">+use crate::shards::telemetry::{LocalShardTelemetry, OptimizerTelemetry};</div><div> use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};</div><div> use crate::wal::SerdeWal;</div><div class="diff-removed">-use crate::wal_delta::{LockedWal, RecoverableWal};</div><div class="diff-removed">-</div><div class="diff-removed">-/// If rendering WAL load progression in basic text form, report progression every 60 seconds.</div><div class="diff-removed">-const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);</div><div class="diff-removed">-</div><div class="diff-removed">-const WAL_PATH: &str = "wal";</div><div class="diff-added">+use crate::wal_delta::{LockedWal, RecoverableWal, WAL_PATH};</div><div> </div><div> const SEGMENTS_PATH: &str = "segments";</div><div> </div><div class="diff-info">@@ -175,11 +173,11 @@ impl LocalShard {</div><div> </div><div>         // default to 2x the WAL capacity</div><div>         let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-added">+            2 * (config.wal_config.wal_capacity_mb as u64);</div><div> </div><div>         let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div>             shard_path.to_owned(),</div><div class="diff-removed">-            disk_buffer_threshold_mb,</div><div class="diff-added">+            disk_buffer_threshold_threshold_mb,</div><div>         )</div><div>         .await;</div><div> </div><div class="diff-info">@@ -234,11 +232,7 @@ impl LocalShard {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-removed">-    }</div><div> </div><div class="diff-removed">-    /// Recovers shard from disk.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn load(</div><div>         id: ShardId,</div><div class="diff-info">@@ -258,11 +252,12 @@ impl LocalShard {</div><div>         let segments_path = Self::segments_path(shard_path);</div><div> </div><div>         let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(</div><div class="diff-removed">-            wal_path.to_str().unwrap(),</div><div class="diff-added">+            wal_path.to_str().unwrap().to_string(),</div><div>             (&collection_config_read.wal_config).into(),</div><div>         )</div><div>         .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;</div><div> </div><div class="diff-added">+</div><div>         // Walk over segments directory and collect all directory entries now</div><div>         // Collect now and error early to prevent errors while we've already spawned load threads</div><div>         let segment_paths = std::fs::read_dir(&segments_path)</div><div class="diff-info">@@ -307,6 +302,7 @@ impl LocalShard {</div><div>             })</div><div>             .map(|entry| entry.path());</div><div> </div><div class="diff-added">+</div><div>         let mut load_handlers = vec![];</div><div> </div><div>         // This semaphore is used to limit the number of threads that load segments concurrently.</div><div class="diff-info">@@ -371,6 +367,7 @@ impl LocalShard {</div><div>                 })</div><div>                 .unwrap_or(Ok(()))?;</div><div> </div><div class="diff-added">+</div><div>             segment_holder.add_new(segment);</div><div>         }</div><div> </div><div class="diff-info">@@ -411,6 +408,7 @@ impl LocalShard {</div><div>             )?;</div><div>         }</div><div> </div><div class="diff-added">+</div><div>         let local_shard = LocalShard::new(</div><div>             segment_holder,</div><div>             collection_config,</div><div class="diff-info">@@ -548,7 +546,7 @@ impl LocalShard {</div><div>         }</div><div> </div><div>         let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-removed">-            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div class="diff-added">+            SerdeWal::new(wal_path.to_str().unwrap().to_string(), (&config.wal_config).into())?;</div><div> </div><div>         let optimizers = build_optimizers(</div><div>             shard_path,</div><div class="diff-info">@@ -708,7 +706,8 @@ impl LocalShard {</div><div>         bar.finish();</div><div>         if !show_progress_bar {</div><div>             log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-added">+                "Recovered shard {}: {0}/{0} (100%)",</div><div class="diff-added">+                self.path.display(),</div><div>                 wal.len(false),</div><div>             );</div><div>         }</div><div class="diff-info">@@ -732,9 +731,8 @@ impl LocalShard {</div><div>                     let segment_guard = raw_segment.read();</div><div>                     if let Err(err) = segment_guard.check_data_consistency() {</div><div>                         log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-added">+                            "Segment {:?} is inconsistent: {err}",</div><div>                             segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div>                         );</div><div>                         return Err(err.into());</div><div>                     }</div><div class="diff-info">@@ -749,76 +747,6 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        // makes sure that the Stop signal is the last one in this channel</div><div class="diff-removed">-        let old_sender = self.update_sender.swap(Arc::new(update_sender));</div><div class="diff-removed">-        old_sender.send(UpdateSignal::Stop).await?;</div><div class="diff-removed">-        update_handler.stop_flush_worker();</div><div class="diff-removed">-</div><div class="diff-removed">-        update_handler.wait_workers_stops().await?;</div><div class="diff-removed">-        let new_optimizers = build_optimizers(</div><div class="diff-removed">-            &self.path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &config.optimizer_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        update_handler.optimizers = new_optimizers;</div><div class="diff-removed">-        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div class="diff-removed">-        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div class="diff-removed">-    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-removed">-            if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update read rate limiter</div><div class="diff-removed">-                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-removed">-                    let new_read_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-removed">-                    self.read_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-removed">-                    return;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // remove read rate limiter for all other situations</div><div class="diff-removed">-        self.read_rate_limiter.take();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn trigger_optimizers(&self) {</div><div class="diff-removed">-        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-removed">-        // - If receiver is already dead - we do not care</div><div class="diff-removed">-        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Finishes ongoing update tasks</div><div class="diff-removed">-    pub async fn stop_gracefully(&self) {</div><div class="diff-removed">-        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-removed">-            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.stop_flush_worker().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-removed">-            log::warn!("Update workers failed with: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div>         log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div>         // Read dir first as the directory contents would change during restore</div><div class="diff-info">@@ -847,7 +775,7 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div class="diff-added">+    /// Create snapshot for local shard and archive to a tar builder</div><div>     pub async fn create_snapshot(</div><div>         &self,</div><div>         temp_path: &Path,</div><div class="diff-info">@@ -864,8 +792,11 @@ impl LocalShard {</div><div>             // It will notify us when all submitted updates so far have been processed.</div><div>             let (tx, rx) = oneshot::channel();</div><div>             let plunger = UpdateSignal::Plunger(tx);</div><div class="diff-removed">-            self.update_sender.load().send(plunger).await?;</div><div class="diff-removed">-            rx.await?;</div><div class="diff-added">+            // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-added">+            // - If receiver is already dead - we do not care</div><div class="diff-added">+            // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-added">+            let _ = self.update_sender.load().send(plunger).await;</div><div class="diff-added">+            let _ = rx.await; // Ignore error even if the notification mechanism does not work for some reason</div><div>         }</div><div> </div><div>         let segments_path = Self::segments_path(&self.path);</div><div class="diff-info">@@ -1106,21 +1037,48 @@ impl LocalShard {</div><div>     }</div><div> </div><div>     pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-added">+        self.update_tracker</div><div>     }</div><div> </div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-added">+    /// Apply shard's strict mode configuration update</div><div class="diff-added">+    /// - Update read rate limiter</div><div class="diff-added">+    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-added">+        let config = self.collection_config.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-added">+            if let Some(true) = strict_mode_config.enabled {</div><div class="diff-added">+                // update read rate limiter</div><div class="diff-added">+                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-added">+                    let new_read_rate_limiter =</div><div class="diff-added">+                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-added">+                    self.read_rate_limiter</div><div class="diff-added">+                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-added">+                    return;</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+        // remove read rate limiter for all other situations</div><div class="diff-added">+        self.read_rate_limiter.take();</div><div>     }</div><div> </div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-added">+    pub fn trigger_optimizers(&self) {</div><div class="diff-added">+        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-added">+        // - If receiver is already dead - we do not care</div><div class="diff-added">+        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-added">+        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Finishes ongoing update tasks</div><div class="diff-added">+    pub async fn stop_gracefully(&self) {</div><div class="diff-added">+        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-added">+            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        self.stop_flush_worker().await;</div><div class="diff-added">+</div><div class="diff-added">+        if let Err(err) = self.wait_update_workers_stops().await {</div><div class="diff-added">+            log::warn!("Update workers failed with: {err}");</div><div class="diff-added">+        }</div><div>     }</div><div> </div><div>     /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-info">@@ -1154,6 +1112,14 @@ impl LocalShard {</div><div>         }</div><div>         Ok(())</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn read_query_verification_config(&self) -> Option<CollectionRequestVerification> {</div><div class="diff-added">+        self.collection_config</div><div class="diff-added">+            .blocking_read()</div><div class="diff-added">+            .strict_mode_config</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+            .and_then(|config| config.enabled.then(|| config.verification.clone()))</div><div class="diff-added">+    }</div><div> }</div><div> </div><div> impl Drop for LocalShard {</div><div class="diff-info">@@ -1171,6 +1137,10 @@ impl Drop for LocalShard {</div><div>     }</div><div> }</div><div> </div><div class="diff-added">+const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";</div><div class="diff-added">+</div><div class="diff-added">+const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";</div><div class="diff-added">+</div><div> /// Convenience struct for combining clock maps belonging to a shard</div><div> ///</div><div> /// Holds a clock map for tracking the highest clocks and the cutoff clocks.</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    