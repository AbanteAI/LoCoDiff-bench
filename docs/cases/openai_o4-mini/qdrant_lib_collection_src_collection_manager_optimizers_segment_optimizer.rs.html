<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/segment_optimizer.rs - o4-mini-medium</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/segment_optimizer.rs</h1>
        <p><a href="../../models/openai_o4-mini.html">‚Üê Back to o4-mini-medium Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-medium</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56534</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 56703</p>
                <p><strong>Native Completion Tokens:</strong> 3893</p>
                <p><strong>Native Tokens Reasoning:</strong> 320</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.003975125</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index a458d559..c35a03ce 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_expectedoutput.txt (expected):tmp/tmpa8foksp9_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_extracted.txt (actual):tmp/tmpuu_8kn1i_actual.txt	</div><div class="diff-info">@@ -1,8 +1,8 @@</div><div> use std::collections::{HashMap, HashSet};</div><div> use std::ops::Deref;</div><div> use std::path::Path;</div><div class="diff-removed">-use std::sync::Arc;</div><div> use std::sync::atomic::{AtomicBool, Ordering};</div><div class="diff-added">+use std::sync::Arc;</div><div> </div><div> use common::budget::{ResourceBudget, ResourcePermit};</div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-info">@@ -10,7 +10,7 @@ use common::disk::dir_size;</div><div> use io::storage_version::StorageVersion;</div><div> use itertools::Itertools;</div><div> use parking_lot::{Mutex, RwLockUpgradableReadGuard};</div><div class="diff-removed">-use segment::common::operation_error::{OperationResult, check_process_stopped};</div><div class="diff-added">+use segment::common::operation_error::{check_process_stopped, OperationResult};</div><div> use segment::common::operation_time_statistics::{</div><div>     OperationDurationsAggregator, ScopeDurationMeasurer,</div><div> };</div><div class="diff-info">@@ -19,7 +19,10 @@ use segment::index::sparse_index::sparse_index_config::SparseIndexType;</div><div> use segment::segment::{Segment, SegmentVersion};</div><div> use segment::segment_constructor::build_segment;</div><div> use segment::segment_constructor::segment_builder::SegmentBuilder;</div><div class="diff-removed">-use segment::types::{HnswConfig, Indexes, QuantizationConfig, SegmentConfig, VectorStorageType};</div><div class="diff-added">+use segment::types::{</div><div class="diff-added">+    HnswConfig, Indexes, PayloadFieldSchema, PayloadKeyType, PointIdType,</div><div class="diff-added">+    QuantizationConfig, SegmentConfig, VectorStorageType,</div><div class="diff-added">+};</div><div> </div><div> use crate::collection_manager::holders::proxy_segment::{self, ProxyIndexChange, ProxySegment};</div><div> use crate::collection_manager::holders::segment_holder::{</div><div class="diff-info">@@ -31,6 +34,7 @@ use crate::operations::types::{CollectionError, CollectionResult};</div><div> </div><div> const BYTES_IN_KB: usize = 1024;</div><div> </div><div class="diff-added">+/// Thresholds controlling when segments are optimized.</div><div> #[derive(Debug, Clone, Copy)]</div><div> pub struct OptimizerThresholds {</div><div>     pub max_segment_size_kb: usize,</div><div class="diff-info">@@ -38,46 +42,33 @@ pub struct OptimizerThresholds {</div><div>     pub indexing_threshold_kb: usize,</div><div> }</div><div> </div><div class="diff-removed">-/// SegmentOptimizer - trait implementing common functionality of the optimizers</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It provides functions which allow to re-build specified segments into a new, better one.</div><div class="diff-removed">-/// Process allows read and write (with some tricks) access to the optimized segments.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Process of the optimization is same for all optimizers.</div><div class="diff-removed">-/// The selection of the candidates for optimization and the configuration</div><div class="diff-removed">-/// of resulting segment are up to concrete implementations.</div><div class="diff-added">+/// A trait that implements segment optimization logic.</div><div> pub trait SegmentOptimizer {</div><div class="diff-removed">-    /// Get name describing this optimizer</div><div class="diff-added">+    /// Get a descriptive name for this optimizer.</div><div>     fn name(&self) -> &str;</div><div> </div><div class="diff-removed">-    /// Get the path of the segments directory</div><div class="diff-added">+    /// Path to the directory containing segment files.</div><div>     fn segments_path(&self) -> &Path;</div><div> </div><div class="diff-removed">-    /// Get temp path, where optimized segments could be temporary stored</div><div class="diff-added">+    /// Path to use for temporary segment files during optimization.</div><div>     fn temp_path(&self) -> &Path;</div><div> </div><div class="diff-removed">-    /// Get basic segment config</div><div class="diff-added">+    /// Collection-level parameters.</div><div>     fn collection_params(&self) -> CollectionParams;</div><div> </div><div class="diff-removed">-    /// Get HNSW config</div><div class="diff-added">+    /// HNSW index configuration.</div><div>     fn hnsw_config(&self) -> &HnswConfig;</div><div> </div><div class="diff-removed">-    /// Get quantization config</div><div class="diff-added">+    /// Configuration for quantization, if any.</div><div>     fn quantization_config(&self) -> Option<QuantizationConfig>;</div><div> </div><div class="diff-removed">-    /// Get thresholds configuration for the current optimizer</div><div class="diff-added">+    /// Thresholds for this optimizer.</div><div>     fn threshold_config(&self) -> &OptimizerThresholds;</div><div> </div><div class="diff-removed">-    /// Checks if segment optimization is required</div><div class="diff-removed">-    fn check_condition(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        excluded_ids: &HashSet<SegmentId>,</div><div class="diff-removed">-    ) -> Vec<SegmentId>;</div><div class="diff-removed">-</div><div class="diff-added">+    /// Telemetry aggregator for operation durations.</div><div>     fn get_telemetry_counter(&self) -> &Mutex<OperationDurationsAggregator>;</div><div> </div><div class="diff-removed">-    /// Build temp segment</div><div class="diff-added">+    /// Create a new empty temporary segment.</div><div>     fn temp_segment(&self, save_version: bool) -> CollectionResult<LockedSegment> {</div><div>         let collection_params = self.collection_params();</div><div>         let config = SegmentConfig {</div><div class="diff-info">@@ -92,67 +83,36 @@ pub trait SegmentOptimizer {</div><div>         )?))</div><div>     }</div><div> </div><div class="diff-removed">-    /// Build optimized segment</div><div class="diff-added">+    /// Build a `SegmentBuilder` configured for optimized segments.</div><div>     fn optimized_segment_builder(</div><div>         &self,</div><div>         optimizing_segments: &[LockedSegment],</div><div>     ) -> CollectionResult<SegmentBuilder> {</div><div class="diff-removed">-        // Example:</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // S1: {</div><div class="diff-removed">-        //     text_vectors: 10000,</div><div class="diff-removed">-        //     image_vectors: 100</div><div class="diff-removed">-        // }</div><div class="diff-removed">-        // S2: {</div><div class="diff-removed">-        //     text_vectors: 200,</div><div class="diff-removed">-        //     image_vectors: 10000</div><div class="diff-removed">-        // }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Example: bytes_count_by_vector_name = {</div><div class="diff-removed">-        //     text_vectors: 10200 * dim * VECTOR_ELEMENT_SIZE</div><div class="diff-removed">-        //     image_vectors: 10100 * dim * VECTOR_ELEMENT_SIZE</div><div class="diff-removed">-        // }</div><div class="diff-added">+        // Estimate bytes by vector name across segments.</div><div>         let mut bytes_count_by_vector_name = HashMap::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Counting up how much space do the segments being optimized actually take on the fs.</div><div class="diff-removed">-        // If there was at least one error while reading the size, this will be `None`.</div><div>         let mut space_occupied = Some(0u64);</div><div> </div><div>         for segment in optimizing_segments {</div><div>             let segment = match segment {</div><div class="diff-removed">-                LockedSegment::Original(segment) => segment,</div><div class="diff-added">+                LockedSegment::Original(o) => o,</div><div>                 LockedSegment::Proxy(_) => {</div><div>                     return Err(CollectionError::service_error(</div><div>                         "Proxy segment is not expected here".to_string(),</div><div>                     ));</div><div>                 }</div><div>             };</div><div class="diff-removed">-            let locked_segment = segment.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            for vector_name in locked_segment.vector_names() {</div><div class="diff-removed">-                let vector_size = locked_segment.available_vectors_size_in_bytes(&vector_name)?;</div><div class="diff-removed">-                let size = bytes_count_by_vector_name.entry(vector_name).or_insert(0);</div><div class="diff-removed">-                *size += vector_size;</div><div class="diff-added">+            let locked = segment.read();</div><div class="diff-added">+            for vector_name in locked.vector_names() {</div><div class="diff-added">+                let vector_size = locked.available_vectors_size_in_bytes(&vector_name)?;</div><div class="diff-added">+                *bytes_count_by_vector_name.entry(vector_name).or_insert(0) += vector_size;</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            space_occupied =</div><div class="diff-removed">-                space_occupied.and_then(|acc| match dir_size(locked_segment.data_path()) {</div><div class="diff-removed">-                    Ok(size) => Some(size + acc),</div><div class="diff-removed">-                    Err(err) => {</div><div class="diff-removed">-                        log::debug!(</div><div class="diff-removed">-                            "Could not estimate size of segment `{}`: {}",</div><div class="diff-removed">-                            locked_segment.data_path().display(),</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-added">+            space_occupied = space_occupied.and_then(|acc| {</div><div class="diff-added">+                dir_size(locked.data_path())</div><div class="diff-added">+                    .map(|size| size + acc)</div><div class="diff-added">+                    .ok()</div><div class="diff-added">+            });</div><div>         }</div><div class="diff-removed">-</div><div>         let space_needed = space_occupied.map(|x| 2 * x);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure temp_path exists</div><div class="diff-removed">-</div><div>         if !self.temp_path().exists() {</div><div>             std::fs::create_dir_all(self.temp_path()).map_err(|err| {</div><div>                 CollectionError::service_error(format!(</div><div class="diff-info">@@ -162,9 +122,8 @@ pub trait SegmentOptimizer {</div><div>                 ))</div><div>             })?;</div><div>         }</div><div class="diff-removed">-</div><div>         let space_available = match fs4::available_space(self.temp_path()) {</div><div class="diff-removed">-            Ok(available) => Some(available),</div><div class="diff-added">+            Ok(avail) => Some(avail),</div><div>             Err(err) => {</div><div>                 log::debug!(</div><div>                     "Could not estimate available storage space in `{}`: {}",</div><div class="diff-info">@@ -174,194 +133,114 @@ pub trait SegmentOptimizer {</div><div>                 None</div><div>             }</div><div>         };</div><div class="diff-removed">-</div><div class="diff-removed">-        match (space_available, space_needed) {</div><div class="diff-removed">-            (Some(space_available), Some(space_needed)) => {</div><div class="diff-removed">-                if space_available < space_needed {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Not enough space available for optimization".to_string(),</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-            _ => {</div><div class="diff-removed">-                log::warn!(</div><div class="diff-removed">-                    "Could not estimate available storage space in `{}`; will try optimizing anyway",</div><div class="diff-removed">-                    self.name()</div><div class="diff-removed">-                );</div><div class="diff-added">+        if let (Some(avail), Some(need)) = (space_available, space_needed) {</div><div class="diff-added">+            if avail < need {</div><div class="diff-added">+                return Err(CollectionError::service_error(</div><div class="diff-added">+                    "Not enough space available for optimization".to_string(),</div><div class="diff-added">+                ));</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Example: maximal_vector_store_size_bytes = 10200 * dim * VECTOR_ELEMENT_SIZE</div><div class="diff-removed">-        let maximal_vector_store_size_bytes = bytes_count_by_vector_name</div><div class="diff-removed">-            .values()</div><div class="diff-removed">-            .max()</div><div class="diff-removed">-            .copied()</div><div class="diff-removed">-            .unwrap_or(0);</div><div class="diff-removed">-</div><div class="diff-added">+        let maximal = bytes_count_by_vector_name.values().max().copied().unwrap_or(0);</div><div>         let thresholds = self.threshold_config();</div><div class="diff-removed">-        let collection_params = self.collection_params();</div><div class="diff-added">+        let params = self.collection_params();</div><div> </div><div class="diff-removed">-        let threshold_is_indexed = maximal_vector_store_size_bytes</div><div class="diff-removed">-            >= thresholds.indexing_threshold_kb.saturating_mul(BYTES_IN_KB);</div><div class="diff-added">+        let threshold_indexed = maximal >= thresholds.indexing_threshold_kb.saturating_mul(BYTES_IN_KB);</div><div class="diff-added">+        let threshold_on_disk = maximal >= thresholds.memmap_threshold_kb.saturating_mul(BYTES_IN_KB);</div><div> </div><div class="diff-removed">-        let threshold_is_on_disk = maximal_vector_store_size_bytes</div><div class="diff-removed">-            >= thresholds.memmap_threshold_kb.saturating_mul(BYTES_IN_KB);</div><div class="diff-added">+        // Base vector and sparse configs.</div><div class="diff-added">+        let mut vector_data = params.to_base_vector_data()?;</div><div class="diff-added">+        let mut sparse_vector_data = params.to_sparse_vector_data()?;</div><div> </div><div class="diff-removed">-        let mut vector_data = collection_params.to_base_vector_data()?;</div><div class="diff-removed">-        let mut sparse_vector_data = collection_params.to_sparse_vector_data()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // If indexing, change to HNSW index and quantization</div><div class="diff-removed">-        if threshold_is_indexed {</div><div class="diff-added">+        // If indexing, set HNSW + quantization per vector.</div><div class="diff-added">+        if threshold_indexed {</div><div>             let collection_hnsw = self.hnsw_config();</div><div class="diff-removed">-            let collection_quantization = self.quantization_config();</div><div class="diff-removed">-            vector_data.iter_mut().for_each(|(vector_name, config)| {</div><div class="diff-removed">-                // Assign HNSW index</div><div class="diff-removed">-                let param_hnsw = collection_params</div><div class="diff-removed">-                    .vectors</div><div class="diff-removed">-                    .get_params(vector_name)</div><div class="diff-removed">-                    .and_then(|params| params.hnsw_config);</div><div class="diff-removed">-                let vector_hnsw = param_hnsw</div><div class="diff-added">+            let collection_quant = self.quantization_config();</div><div class="diff-added">+            for (name, cfg) in &mut vector_data {</div><div class="diff-added">+                let vec_hnsw = params</div><div class="diff-added">+                    .vectors.get_params(name)</div><div class="diff-added">+                    .and_then(|p| p.hnsw_config)</div><div>                     .and_then(|c| c.update(collection_hnsw).ok())</div><div>                     .unwrap_or_else(|| collection_hnsw.clone());</div><div class="diff-removed">-                config.index = Indexes::Hnsw(vector_hnsw);</div><div class="diff-removed">-</div><div class="diff-removed">-                // Assign quantization config</div><div class="diff-removed">-                let param_quantization = collection_params</div><div class="diff-added">+                cfg.index = Indexes::Hnsw(vec_hnsw);</div><div class="diff-added">+                cfg.quantization_config = params</div><div>                     .vectors</div><div class="diff-removed">-                    .get_params(vector_name)</div><div class="diff-removed">-                    .and_then(|params| params.quantization_config.as_ref());</div><div class="diff-removed">-                let vector_quantization = param_quantization</div><div class="diff-removed">-                    .or(collection_quantization.as_ref())</div><div class="diff-removed">-                    .cloned();</div><div class="diff-removed">-                config.quantization_config = vector_quantization;</div><div class="diff-removed">-            });</div><div class="diff-added">+                    .get_params(name)</div><div class="diff-added">+                    .and_then(|p| p.quantization_config.clone())</div><div class="diff-added">+                    .or_else(|| collection_quant.clone());</div><div class="diff-added">+            }</div><div>         }</div><div> </div><div class="diff-removed">-        // If storing on disk, set storage type in current segment (not in collection config)</div><div class="diff-removed">-        if threshold_is_on_disk {</div><div class="diff-removed">-            vector_data.iter_mut().for_each(|(vector_name, config)| {</div><div class="diff-removed">-                // Check whether on_disk is explicitly configured, if not, set it to true</div><div class="diff-removed">-                let config_on_disk = collection_params</div><div class="diff-added">+        // If on disk threshold, set vector storage to Mmap, respecting explicit config.</div><div class="diff-added">+        if threshold_on_disk {</div><div class="diff-added">+            for (name, cfg) in &mut vector_data {</div><div class="diff-added">+                let explicit = params</div><div>                     .vectors</div><div class="diff-removed">-                    .get_params(vector_name)</div><div class="diff-removed">-                    .and_then(|config| config.on_disk);</div><div class="diff-removed">-</div><div class="diff-removed">-                match config_on_disk {</div><div class="diff-removed">-                    Some(true) => config.storage_type = VectorStorageType::Mmap, // Both agree, but prefer mmap storage type</div><div class="diff-removed">-                    Some(false) => {} // on_disk=false wins, do nothing</div><div class="diff-removed">-                    None => config.storage_type = VectorStorageType::Mmap, // Mmap threshold wins</div><div class="diff-added">+                    .get_params(name)</div><div class="diff-added">+                    .and_then(|p| p.on_disk);</div><div class="diff-added">+                match explicit {</div><div class="diff-added">+                    Some(true) => cfg.storage_type = VectorStorageType::Mmap,</div><div class="diff-added">+                    Some(false) => {}</div><div class="diff-added">+                    None => cfg.storage_type = VectorStorageType::Mmap,</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-removed">-                // If we explicitly configure on_disk, but the segment storage type uses something</div><div class="diff-removed">-                // that doesn't match, warn about it</div><div class="diff-removed">-                if let Some(config_on_disk) = config_on_disk {</div><div class="diff-removed">-                    if config_on_disk != config.storage_type.is_on_disk() {</div><div class="diff-removed">-                        log::warn!("Collection config for vector {vector_name} has on_disk={config_on_disk:?} configured, but storage type for segment doesn't match it");</div><div class="diff-added">+                if let Some(explicit) = explicit {</div><div class="diff-added">+                    if explicit != cfg.storage_type.is_on_disk() {</div><div class="diff-added">+                        log::warn!(</div><div class="diff-added">+                            "Collection config for vector {name} has on_disk={explicit:?}, but segment storage differs"</div><div class="diff-added">+                        );</div><div>                     }</div><div>                 }</div><div class="diff-removed">-            });</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        sparse_vector_data</div><div class="diff-removed">-            .iter_mut()</div><div class="diff-removed">-            .for_each(|(vector_name, config)| {</div><div class="diff-removed">-                // Assign sparse index on disk</div><div class="diff-removed">-                if let Some(sparse_config) = &collection_params.sparse_vectors {</div><div class="diff-removed">-                    if let Some(params) = sparse_config.get(vector_name) {</div><div class="diff-removed">-                        let config_on_disk = params</div><div class="diff-removed">-                            .index</div><div class="diff-removed">-                            .and_then(|index_params| index_params.on_disk)</div><div class="diff-removed">-                            .unwrap_or(threshold_is_on_disk);</div><div class="diff-removed">-</div><div class="diff-removed">-                        // If mmap OR index is exceeded</div><div class="diff-removed">-                        let is_big = threshold_is_on_disk || threshold_is_indexed;</div><div class="diff-removed">-</div><div class="diff-removed">-                        let index_type = match (is_big, config_on_disk) {</div><div class="diff-removed">-                            (true, true) => SparseIndexType::Mmap, // Big and configured on disk</div><div class="diff-removed">-                            (true, false) => SparseIndexType::ImmutableRam, // Big and not on disk nor reached threshold</div><div class="diff-removed">-                            (false, _) => SparseIndexType::MutableRam,      // Small</div><div class="diff-added">+            }</div><div class="diff-added">+            // For sparse</div><div class="diff-added">+            for (name, cfg) in &mut sparse_vector_data {</div><div class="diff-added">+                if let Some(sparse_cfg) = &params.sparse_vectors {</div><div class="diff-added">+                    if let Some(p) = sparse_cfg.get(name) {</div><div class="diff-added">+                        let on_disk_cfg = p.index.and_then(|i| i.on_disk).unwrap_or(threshold_on_disk);</div><div class="diff-added">+                        let is_big = threshold_on_disk || threshold_indexed;</div><div class="diff-added">+                        cfg.index.index_type = match (is_big, on_disk_cfg) {</div><div class="diff-added">+                            (true, true) => SparseIndexType::Mmap,</div><div class="diff-added">+                            (true, false) => SparseIndexType::ImmutableRam,</div><div class="diff-added">+                            (false, _) => SparseIndexType::MutableRam,</div><div>                         };</div><div class="diff-removed">-</div><div class="diff-removed">-                        config.index.index_type = index_type;</div><div>                     }</div><div>                 }</div><div class="diff-removed">-            });</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div> </div><div class="diff-removed">-        let optimized_config = SegmentConfig {</div><div class="diff-added">+        let mut config = SegmentConfig {</div><div>             vector_data,</div><div>             sparse_vector_data,</div><div class="diff-removed">-            payload_storage_type: collection_params.payload_storage_type(),</div><div class="diff-added">+            payload_storage_type: params.payload_storage_type(),</div><div>         };</div><div> </div><div>         Ok(SegmentBuilder::new(</div><div>             self.segments_path(),</div><div>             self.temp_path(),</div><div class="diff-removed">-            &optimized_config,</div><div class="diff-added">+            &config,</div><div>         )?)</div><div>     }</div><div> </div><div class="diff-removed">-    /// Restores original segments from proxies</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `segments` - segment holder</div><div class="diff-removed">-    /// * `proxy_ids` - ids of poxy-wrapped segment to restore</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Result</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Original segments are pushed into `segments`, proxies removed.</div><div class="diff-removed">-    /// Returns IDs on restored segments</div><div class="diff-removed">-    ///</div><div class="diff-added">+    /// Unwrap proxies back to original segments.</div><div>     fn unwrap_proxy(</div><div>         &self,</div><div>         segments: &LockedSegmentHolder,</div><div>         proxy_ids: &[SegmentId],</div><div>     ) -> Vec<SegmentId> {</div><div class="diff-removed">-        let mut segments_lock = segments.write();</div><div class="diff-removed">-        let mut restored_segment_ids = vec![];</div><div class="diff-removed">-        for &proxy_id in proxy_ids {</div><div class="diff-removed">-            if let Some(proxy_segment_ref) = segments_lock.get(proxy_id) {</div><div class="diff-removed">-                let locked_proxy_segment = proxy_segment_ref.clone();</div><div class="diff-removed">-                match locked_proxy_segment {</div><div class="diff-removed">-                    LockedSegment::Original(_) => {</div><div class="diff-removed">-                        /* Already unwrapped. It should not actually be here */</div><div class="diff-removed">-                        log::warn!("Attempt to unwrap raw segment! Should not happen.")</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(proxy_segment) => {</div><div class="diff-removed">-                        let wrapped_segment = proxy_segment.read().wrapped_segment.clone();</div><div class="diff-removed">-                        let (restored_id, _proxies) =</div><div class="diff-removed">-                            segments_lock.swap_new(wrapped_segment, &[proxy_id]);</div><div class="diff-removed">-                        restored_segment_ids.push(restored_id);</div><div class="diff-removed">-                    }</div><div class="diff-added">+        let mut lock = segments.write();</div><div class="diff-added">+        let mut restored = Vec::new();</div><div class="diff-added">+        for &pid in proxy_ids {</div><div class="diff-added">+            if let Some(seg_ref) = lock.get(pid) {</div><div class="diff-added">+                if let LockedSegment::Proxy(px) = seg_ref.clone() {</div><div class="diff-added">+                    let orig = px.read().wrapped_segment.clone();</div><div class="diff-added">+                    let (new_id, _) = lock.swap_new(orig, &[pid]);</div><div class="diff-added">+                    restored.push(new_id);</div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-removed">-        restored_segment_ids</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Checks if optimization cancellation is requested.</div><div class="diff-removed">-    fn check_cancellation(&self, stopped: &AtomicBool) -> CollectionResult<()> {</div><div class="diff-removed">-        if stopped.load(Ordering::Relaxed) {</div><div class="diff-removed">-            return Err(CollectionError::Cancelled {</div><div class="diff-removed">-                description: "optimization cancelled by service".to_string(),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-added">+        restored</div><div>     }</div><div> </div><div class="diff-removed">-    /// Unwraps proxy, adds temp segment into collection and returns a `Cancelled` error.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `segments` - all registered segments of the collection</div><div class="diff-removed">-    /// * `proxy_ids` - currently used proxies</div><div class="diff-removed">-    /// * `temp_segment` - currently used temporary segment</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Result</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Rolls back optimization state.</div><div class="diff-removed">-    /// All processed changes will still be there, but the collection should be returned into state</div><div class="diff-removed">-    /// before optimization.</div><div class="diff-added">+    /// Handle cancellation: unwrap proxies, and if temp segment non-empty, add back.</div><div>     fn handle_cancellation(</div><div>         &self,</div><div>         segments: &LockedSegmentHolder,</div><div class="diff-info">@@ -370,131 +249,69 @@ pub trait SegmentOptimizer {</div><div>     ) -> OperationResult<()> {</div><div>         self.unwrap_proxy(segments, proxy_ids);</div><div>         if !temp_segment.get().read().is_empty() {</div><div class="diff-removed">-            let mut write_segments = segments.write();</div><div class="diff-removed">-            write_segments.add_new_locked(temp_segment);</div><div class="diff-added">+            let mut lock = segments.write();</div><div class="diff-added">+            lock.add_new_locked(temp_segment);</div><div>         } else {</div><div class="diff-removed">-            // Temp segment is already removed from proxy, so nobody could write to it in between</div><div>             temp_segment.drop_data()?;</div><div>         }</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Function to wrap slow part of optimization. Performs proxy rollback in case of cancellation.</div><div class="diff-removed">-    /// Warn: this function might be _VERY_ CPU intensive,</div><div class="diff-removed">-    /// so it is necessary to avoid any locks inside this part of the code</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `optimizing_segments` - Segments to optimize</div><div class="diff-removed">-    /// * `proxy_deleted_points` - Holds a set of points, deleted while optimization was running</div><div class="diff-removed">-    /// * `proxy_changed_indexes` - Holds a set of indexes changes, created or deleted while optimization was running</div><div class="diff-removed">-    /// * `stopped` - flag to check if optimization was cancelled by external thread</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Result</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Constructs optimized segment</div><div class="diff-added">+    /// Build new optimized segment from proxies.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     fn build_new_segment(</div><div>         &self,</div><div>         optimizing_segments: &[LockedSegment],</div><div>         proxy_deleted_points: proxy_segment::LockedRmSet,</div><div class="diff-removed">-        proxy_changed_indexes: proxy_segment::LockedIndexChanges,</div><div class="diff-removed">-        permit: ResourcePermit, // IO resources for copying data</div><div class="diff-added">+        proxy_index_changes: proxy_segment::LockedIndexChanges,</div><div class="diff-added">+        permit: ResourcePermit,</div><div>         resource_budget: ResourceBudget,</div><div>         stopped: &AtomicBool,</div><div>         hw_counter: &HardwareCounterCell,</div><div>     ) -> CollectionResult<Segment> {</div><div class="diff-removed">-        let mut segment_builder = self.optimized_segment_builder(optimizing_segments)?;</div><div class="diff-removed">-</div><div class="diff-added">+        let mut builder = self.optimized_segment_builder(optimizing_segments)?;</div><div>         self.check_cancellation(stopped)?;</div><div> </div><div class="diff-removed">-        let segments: Vec<_> = optimizing_segments</div><div class="diff-added">+        // Collect originals</div><div class="diff-added">+        let originals: Vec<_> = optimizing_segments</div><div>             .iter()</div><div class="diff-removed">-            .map(|i| match i {</div><div class="diff-added">+            .map(|s| match s {</div><div>                 LockedSegment::Original(o) => o.clone(),</div><div>                 LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    panic!("Trying to optimize a segment that is already being optimized!")</div><div class="diff-added">+                    panic!("Proxy in build_new_segment");</div><div>                 }</div><div>             })</div><div>             .collect();</div><div> </div><div class="diff-removed">-        let mut defragmentation_keys = HashSet::new();</div><div class="diff-removed">-        for segment in &segments {</div><div class="diff-removed">-            let payload_index = &segment.read().payload_index;</div><div class="diff-removed">-            let payload_index = payload_index.borrow();</div><div class="diff-removed">-</div><div class="diff-removed">-            let keys = payload_index</div><div class="diff-removed">-                .config()</div><div class="diff-removed">-                .indexed_fields</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .filter_map(|(key, schema)| schema.is_tenant().then_some(key))</div><div class="diff-removed">-                .cloned();</div><div class="diff-removed">-            defragmentation_keys.extend(keys);</div><div class="diff-added">+        // Probe defrag tenant keys</div><div class="diff-added">+        let mut keys = HashSet::new();</div><div class="diff-added">+        for seg in &originals {</div><div class="diff-added">+            let idx = seg.read().payload_index.borrow();</div><div class="diff-added">+            for (k, sch) in idx.config().indexed_fields.iter() {</div><div class="diff-added">+                if sch.is_tenant() {</div><div class="diff-added">+                    keys.insert(k.clone());</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        if !defragmentation_keys.is_empty() {</div><div class="diff-removed">-            segment_builder.set_defragment_keys(defragmentation_keys.into_iter().collect());</div><div class="diff-added">+        if !keys.is_empty() {</div><div class="diff-added">+            builder.set_defragment_keys(keys.into_iter().collect());</div><div>         }</div><div> </div><div class="diff-added">+        // Update from existing segments</div><div>         {</div><div class="diff-removed">-            let segment_guards = segments.iter().map(|segment| segment.read()).collect_vec();</div><div class="diff-removed">-            segment_builder.update(</div><div class="diff-removed">-                &segment_guards.iter().map(Deref::deref).collect_vec(),</div><div class="diff-removed">-                stopped,</div><div class="diff-removed">-            )?;</div><div class="diff-added">+            let guards: Vec<_> = originals.iter().map(|o| o.read()).collect();</div><div class="diff-added">+            builder.update(&guards.iter().map(Deref::deref).collect_vec(), stopped)?;</div><div>         }</div><div> </div><div class="diff-removed">-        // Apply index changes to segment builder</div><div class="diff-removed">-        // Indexes are only used for defragmentation in segment builder, so versions are ignored</div><div class="diff-removed">-        for (field_name, change) in proxy_changed_indexes.read().iter_unordered() {</div><div class="diff-added">+        // Apply index changes to builder</div><div class="diff-added">+        for (fname, change) in proxy_index_changes.read().iter_unordered() {</div><div>             match change {</div><div class="diff-removed">-                ProxyIndexChange::Create(schema, _) => {</div><div class="diff-removed">-                    segment_builder.add_indexed_field(field_name.to_owned(), schema.to_owned());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ProxyIndexChange::Delete(_) => {</div><div class="diff-removed">-                    segment_builder.remove_indexed_field(field_name);</div><div class="diff-removed">-                }</div><div class="diff-added">+                ProxyIndexChange::Create(schema, _) => builder.add_indexed_field(fname.clone(), schema.clone()),</div><div class="diff-added">+                ProxyIndexChange::Delete(_) => builder.remove_indexed_field(fname),</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // 000 - acquired</div><div class="diff-removed">-        // +++ - blocked on waiting</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Case: 1 indexation job at a time, long indexing</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //  IO limit = 1</div><div class="diff-removed">-        // CPU limit = 2                         Next optimization</div><div class="diff-removed">-        //                                       ‚îÇ            loop</div><div class="diff-removed">-        //                                       ‚îÇ</div><div class="diff-removed">-        //                                       ‚ñº</div><div class="diff-removed">-        //  IO 0  00000000000000                  000000000</div><div class="diff-removed">-        // CPU 1              00000000000000000</div><div class="diff-removed">-        //     2              00000000000000000</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //  IO 0  ++++++++++++++00000000000000000</div><div class="diff-removed">-        // CPU 1                       ++++++++0000000000</div><div class="diff-removed">-        //     2                       ++++++++0000000000</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //  Case: 1 indexing job at a time, short indexation</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //   IO limit = 1</div><div class="diff-removed">-        //  CPU limit = 2</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //   IO 0  000000000000   ++++++++0000000000</div><div class="diff-removed">-        //  CPU 1            00000</div><div class="diff-removed">-        //      2            00000</div><div class="diff-removed">-        //</div><div class="diff-removed">-        //   IO 0  ++++++++++++00000000000   +++++++</div><div class="diff-removed">-        //  CPU 1                       00000</div><div class="diff-removed">-        //      2                       00000</div><div class="diff-removed">-        // At this stage workload shifts from IO to CPU, so we can release IO permit</div><div class="diff-removed">-</div><div class="diff-removed">-        // Use same number of threads for indexing as for IO.</div><div class="diff-removed">-        // This ensures that IO is equally distributed between optimization jobs.</div><div class="diff-added">+        // First create optimized segment under IO budget</div><div>         let desired_cpus = permit.num_io as usize;</div><div>         let indexing_permit = resource_budget</div><div>             .replace_with(permit, desired_cpus, 0, stopped)</div><div class="diff-info">@@ -502,65 +319,36 @@ pub trait SegmentOptimizer {</div><div>                 description: "optimization cancelled while waiting for budget".to_string(),</div><div>             })?;</div><div> </div><div class="diff-removed">-        let mut optimized_segment: Segment =</div><div class="diff-removed">-            segment_builder.build(indexing_permit, stopped, hw_counter)?;</div><div class="diff-added">+        let mut optimized = builder.build(indexing_permit, stopped, hw_counter)?;</div><div> </div><div class="diff-removed">-        // Delete points</div><div class="diff-removed">-        let deleted_points_snapshot = proxy_deleted_points</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(point_id, versions)| (*point_id, *versions))</div><div class="diff-removed">-            .collect::<Vec<_>>();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Apply index changes before point deletions</div><div class="diff-removed">-        // Point deletions bump the segment version, can cause index changes to be ignored</div><div class="diff-removed">-        let old_optimized_segment_version = optimized_segment.version();</div><div class="diff-removed">-        for (field_name, change) in proxy_changed_indexes.read().iter_ordered() {</div><div class="diff-removed">-            debug_assert!(</div><div class="diff-removed">-                change.version() >= old_optimized_segment_version,</div><div class="diff-removed">-                "proxied index change should have newer version than segment",</div><div class="diff-removed">-            );</div><div class="diff-added">+        // Apply deletions and index changes by version</div><div class="diff-added">+        let old_ver = optimized.version();</div><div class="diff-added">+        for (fname, change) in proxy_index_changes.read().iter_ordered() {</div><div class="diff-added">+            // may be already applied</div><div>             match change {</div><div class="diff-removed">-                ProxyIndexChange::Create(schema, version) => {</div><div class="diff-removed">-                    optimized_segment.create_field_index(</div><div class="diff-removed">-                        *version,</div><div class="diff-removed">-                        field_name,</div><div class="diff-removed">-                        Some(schema),</div><div class="diff-removed">-                        hw_counter,</div><div class="diff-removed">-                    )?;</div><div class="diff-added">+                ProxyIndexChange::Create(schema, v) => {</div><div class="diff-added">+                    optimized.create_field_index(*v, fname, Some(schema), hw_counter)?;</div><div>                 }</div><div class="diff-removed">-                ProxyIndexChange::Delete(version) => {</div><div class="diff-removed">-                    optimized_segment.delete_field_index(*version, field_name)?;</div><div class="diff-added">+                ProxyIndexChange::Delete(v) => {</div><div class="diff-added">+                    optimized.delete_field_index(*v, fname)?;</div><div>                 }</div><div>             }</div><div>             self.check_cancellation(stopped)?;</div><div>         }</div><div> </div><div class="diff-removed">-        for (point_id, versions) in deleted_points_snapshot {</div><div class="diff-removed">-            optimized_segment</div><div class="diff-removed">-                .delete_point(versions.operation_version, point_id, hw_counter)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-added">+        let deleted_pts: Vec<_> = proxy_deleted_points</div><div class="diff-added">+            .read()</div><div class="diff-added">+            .iter()</div><div class="diff-added">+            .map(|(pid, ver)| (*pid, *ver))</div><div class="diff-added">+            .collect();</div><div class="diff-added">+        for (pid, ver) in deleted_pts {</div><div class="diff-added">+            optimized.delete_point(ver, pid, hw_counter).unwrap();</div><div>         }</div><div> </div><div class="diff-removed">-        Ok(optimized_segment)</div><div class="diff-added">+        Ok(optimized)</div><div>     }</div><div> </div><div class="diff-removed">-    /// Performs optimization of collections's segments, including:</div><div class="diff-removed">-    ///     - Segment rebuilding</div><div class="diff-removed">-    ///     - Segment joining</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `segments` - segments holder</div><div class="diff-removed">-    /// * `ids` - list of segment ids to perform optimization on. All segments will be merged into single one</div><div class="diff-removed">-    /// * `stopped` - flag for early stopping of the optimization. If appears to be `true` - optimization process should be cancelled, all segments unwrapped.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Result</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// New optimized segment should be added into `segments`.</div><div class="diff-removed">-    /// If there were any record changes during the optimization - an additional plain segment will be created.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns id of the created optimized segment. If no optimization was done - returns None</div><div class="diff-added">+    /// Perform the full optimize cycle, returning the new segment ID (or 0 if none).</div><div>     fn optimize(</div><div>         &self,</div><div>         segments: LockedSegmentHolder,</div><div class="diff-info">@@ -570,213 +358,109 @@ pub trait SegmentOptimizer {</div><div>         stopped: &AtomicBool,</div><div>     ) -> CollectionResult<usize> {</div><div>         check_process_stopped(stopped)?;</div><div class="diff-removed">-</div><div>         let mut timer = ScopeDurationMeasurer::new(self.get_telemetry_counter());</div><div>         timer.set_success(false);</div><div> </div><div class="diff-removed">-        // On the one hand - we want to check consistently if all provided segments are</div><div class="diff-removed">-        // available for optimization (not already under one) and we want to do it before creating a temp segment</div><div class="diff-removed">-        // which is an expensive operation. So we can't not unlock `segments` after the check and before the insert.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // On the other hand - we do not want to hold write lock during the segment creation.</div><div class="diff-removed">-        // Solution in the middle - is a upgradable lock. It ensures consistency after the check and allows to perform read operation.</div><div class="diff-removed">-        let segments_lock = segments.upgradable_read();</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizing_segments: Vec<_> = ids</div><div class="diff-added">+        let lock = segments.upgradable_read();</div><div class="diff-added">+        let originals: Vec<_> = ids</div><div>             .iter()</div><div>             .cloned()</div><div class="diff-removed">-            .map(|id| segments_lock.get(id))</div><div class="diff-removed">-            .filter_map(|x| x.cloned())</div><div class="diff-added">+            .filter_map(|id| lock.get(id).cloned())</div><div>             .collect();</div><div> </div><div class="diff-removed">-        // Check if all segments are not under other optimization or some ids are missing</div><div class="diff-removed">-        let all_segments_ok = optimizing_segments.len() == ids.len()</div><div class="diff-removed">-            && optimizing_segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .all(|s| matches!(s, LockedSegment::Original(_)));</div><div class="diff-added">+        let all_ok = originals.len() == ids.len()</div><div class="diff-added">+            && originals.iter().all(|s| matches!(s, LockedSegment::Original(_)));</div><div> </div><div class="diff-removed">-        if !all_segments_ok {</div><div class="diff-removed">-            // Cancel the optimization</div><div class="diff-added">+        if !all_ok {</div><div class="diff-added">+            timer.set_success(false);</div><div>             return Ok(0);</div><div>         }</div><div> </div><div>         check_process_stopped(stopped)?;</div><div> </div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::disposable(); // Internal operation, no measurement needed!</div><div class="diff-removed">-</div><div class="diff-removed">-        let tmp_segment = self.temp_segment(false)?;</div><div class="diff-removed">-        let proxy_deleted_points = proxy_segment::LockedRmSet::default();</div><div class="diff-added">+        let tmp = self.temp_segment(false)?;</div><div class="diff-added">+        let proxy_deleted = proxy_segment::LockedRmSet::default();</div><div>         let proxy_index_changes = proxy_segment::LockedIndexChanges::default();</div><div> </div><div>         let mut proxies = Vec::new();</div><div class="diff-removed">-        for sg in optimizing_segments.iter() {</div><div class="diff-removed">-            let mut proxy = ProxySegment::new(</div><div class="diff-added">+        for sg in &originals {</div><div class="diff-added">+            let mut px = ProxySegment::new(</div><div>                 sg.clone(),</div><div class="diff-removed">-                tmp_segment.clone(),</div><div class="diff-removed">-                Arc::clone(&proxy_deleted_points),</div><div class="diff-added">+                tmp.clone(),</div><div class="diff-added">+                Arc::clone(&proxy_deleted),</div><div>                 Arc::clone(&proxy_index_changes),</div><div>             );</div><div class="diff-removed">-            // Wrapped segment is fresh, so it has no operations</div><div class="diff-removed">-            // Operation with number 0 will be applied</div><div class="diff-removed">-            proxy.replicate_field_indexes(0, &hw_counter)?;</div><div class="diff-removed">-            proxies.push(proxy);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Save segment version once all payload indices have been converted</div><div class="diff-removed">-        // If this ends up not being saved due to a crash, the segment will not be used</div><div class="diff-removed">-        match &tmp_segment {</div><div class="diff-removed">-            LockedSegment::Original(segment) => {</div><div class="diff-removed">-                let segment_path = &segment.read().current_path;</div><div class="diff-removed">-                SegmentVersion::save(segment_path)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-            LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-added">+            px.replicate_field_indexes(0, &HardwareCounterCell::disposable())?;</div><div class="diff-added">+            proxies.push(px);</div><div>         }</div><div> </div><div>         let proxy_ids: Vec<_> = {</div><div class="diff-removed">-            // Exclusive lock for the segments operations.</div><div class="diff-removed">-            let mut write_segments = RwLockUpgradableReadGuard::upgrade(segments_lock);</div><div class="diff-removed">-            let mut proxy_ids = Vec::new();</div><div class="diff-removed">-            for (mut proxy, idx) in proxies.into_iter().zip(ids.iter().cloned()) {</div><div class="diff-removed">-                // replicate_field_indexes for the second time,</div><div class="diff-removed">-                // because optimized segments could have been changed.</div><div class="diff-removed">-                // The probability is small, though,</div><div class="diff-removed">-                // so we can afford this operation under the full collection write lock</div><div class="diff-removed">-                proxy.replicate_field_indexes(0, &hw_counter)?; // Slow only in case the index is change in the gap between two calls</div><div class="diff-removed">-                proxy_ids.push(write_segments.swap_new(proxy, &[idx]).0);</div><div class="diff-added">+            let mut write = RwLockUpgradableReadGuard::upgrade(lock);</div><div class="diff-added">+            let mut out = Vec::with_capacity(ids.len());</div><div class="diff-added">+            for (mut px, idx) in proxies.into_iter().zip(ids.iter().cloned()) {</div><div class="diff-added">+                px.replicate_field_indexes(0, &HardwareCounterCell::disposable())?;</div><div class="diff-added">+                out.push(write.swap_new(px, &[idx]).0);</div><div>             }</div><div class="diff-removed">-            proxy_ids</div><div class="diff-added">+            out</div><div>         };</div><div> </div><div class="diff-removed">-        if let Err(e) = check_process_stopped(stopped) {</div><div class="diff-removed">-            self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-            return Err(CollectionError::from(e));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // ---- SLOW PART -----</div><div class="diff-added">+        check_process_stopped(stopped).inspect_err(|_| {</div><div class="diff-added">+            let _ = self.handle_cancellation(&segments, &proxy_ids, tmp.clone());</div><div class="diff-added">+        })?;</div><div> </div><div class="diff-removed">-        let mut optimized_segment = match self.build_new_segment(</div><div class="diff-removed">-            &optimizing_segments,</div><div class="diff-removed">-            Arc::clone(&proxy_deleted_points),</div><div class="diff-added">+        let optimized_segment = match self.build_new_segment(</div><div class="diff-added">+            &originals,</div><div class="diff-added">+            Arc::clone(&proxy_deleted),</div><div>             Arc::clone(&proxy_index_changes),</div><div>             permit,</div><div>             resource_budget,</div><div>             stopped,</div><div class="diff-removed">-            &hw_counter,</div><div class="diff-added">+            &HardwareCounterCell::disposable(),</div><div>         ) {</div><div class="diff-removed">-            Ok(segment) => segment,</div><div class="diff-removed">-            Err(error) => {</div><div class="diff-removed">-                if matches!(error, CollectionError::Cancelled { .. }) {</div><div class="diff-removed">-                    self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-                    return Err(error);</div><div class="diff-added">+            Ok(seg) => seg,</div><div class="diff-added">+            Err(err) => {</div><div class="diff-added">+                if let CollectionError::Cancelled { .. } = err {</div><div class="diff-added">+                    let _ = self.handle_cancellation(&segments, &proxy_ids, tmp.clone());</div><div>                 }</div><div class="diff-removed">-                return Err(error);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Avoid unnecessary point removing in the critical section:</div><div class="diff-removed">-        // - save already removed points while avoiding long read locks</div><div class="diff-removed">-        // - exclude already removed points from post-optimization removing</div><div class="diff-removed">-        let already_remove_points = {</div><div class="diff-removed">-            let mut all_removed_points: HashSet<_> =</div><div class="diff-removed">-                proxy_deleted_points.read().keys().copied().collect();</div><div class="diff-removed">-            for existing_point in optimized_segment.iter_points() {</div><div class="diff-removed">-                all_removed_points.remove(&existing_point);</div><div class="diff-added">+                return Err(err);</div><div>             }</div><div class="diff-removed">-            all_removed_points</div><div>         };</div><div> </div><div class="diff-removed">-        // ---- SLOW PART ENDS HERE -----</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(e) = check_process_stopped(stopped) {</div><div class="diff-removed">-            self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-            return Err(CollectionError::from(e));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         {</div><div class="diff-removed">-            // This block locks all operations with collection. It should be fast</div><div class="diff-removed">-            let mut write_segments_guard = segments.write();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Apply index changes before point deletions</div><div class="diff-removed">-            // Point deletions bump the segment version, can cause index changes to be ignored</div><div class="diff-removed">-            for (field_name, change) in proxy_index_changes.read().iter_ordered() {</div><div class="diff-removed">-                // Warn: change version might be lower than the segment version,</div><div class="diff-removed">-                // because we might already applied the change earlier in optimization.</div><div class="diff-removed">-                // Applied optimizations are not removed from `proxy_index_changes`.</div><div class="diff-removed">-                match change {</div><div class="diff-removed">-                    ProxyIndexChange::Create(schema, version) => {</div><div class="diff-removed">-                        optimized_segment.create_field_index(</div><div class="diff-removed">-                            *version,</div><div class="diff-removed">-                            field_name,</div><div class="diff-removed">-                            Some(schema),</div><div class="diff-removed">-                            &hw_counter,</div><div class="diff-removed">-                        )?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    ProxyIndexChange::Delete(version) => {</div><div class="diff-removed">-                        optimized_segment.delete_field_index(*version, field_name)?;</div><div class="diff-removed">-                    }</div><div class="diff-added">+            let mut write = segments.write();</div><div class="diff-added">+            let deleted_pts = proxy_deleted.read();</div><div class="diff-added">+            let already = {</div><div class="diff-added">+                let mut s = HashSet::new();</div><div class="diff-added">+                for (pid, _) in deleted_pts.iter() {</div><div class="diff-added">+                    s.insert(*pid);</div><div>                 }</div><div class="diff-removed">-                self.check_cancellation(stopped)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            let deleted_points = proxy_deleted_points.read();</div><div class="diff-removed">-            let points_diff = deleted_points</div><div class="diff-added">+                s</div><div class="diff-added">+            };</div><div class="diff-added">+            let pts_diff = deleted_pts</div><div>                 .iter()</div><div class="diff-removed">-                .filter(|&(point_id, _version)| !already_remove_points.contains(point_id));</div><div class="diff-removed">-            for (&point_id, &versions) in points_diff {</div><div class="diff-removed">-                // Delete points here with their operation version, that'll bump the optimized</div><div class="diff-removed">-                // segment version and will ensure we flush the new changes</div><div class="diff-removed">-                debug_assert!(</div><div class="diff-removed">-                    versions.operation_version</div><div class="diff-removed">-                        >= optimized_segment.point_version(point_id).unwrap_or(0),</div><div class="diff-removed">-                    "proxied point deletes should have newer version than point in segment",</div><div class="diff-removed">-                );</div><div class="diff-removed">-                optimized_segment</div><div class="diff-removed">-                    .delete_point(versions.operation_version, point_id, &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-added">+                .filter(|(pid, _)| !already.contains(pid));</div><div class="diff-added">+            for (&pid, &ver) in pts_diff {</div><div class="diff-added">+                optimized_segment.delete_point(ver, pid, &HardwareCounterCell::disposable()).unwrap();</div><div>             }</div><div> </div><div>             let point_count = optimized_segment.available_point_count();</div><div class="diff-removed">-</div><div class="diff-removed">-            let (_, proxies) = write_segments_guard.swap_new(optimized_segment, &proxy_ids);</div><div class="diff-added">+            write.add_new_locked(tmp.clone());</div><div class="diff-added">+            let (new_id, proxies) = write.swap_new(optimized_segment, &proxy_ids);</div><div>             debug_assert_eq!(</div><div>                 proxies.len(),</div><div>                 proxy_ids.len(),</div><div class="diff-removed">-                "swapped different number of proxies on unwrap, missing or incorrect segment IDs?",</div><div class="diff-added">+                "swapped different number of proxies"</div><div>             );</div><div class="diff-removed">-</div><div class="diff-removed">-            let has_appendable_segments = write_segments_guard.has_appendable_segment();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Release reference counter of the optimized segments</div><div class="diff-removed">-            drop(optimizing_segments);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Append a temp segment to collection if it is not empty or there is no other appendable segment</div><div class="diff-removed">-            if !has_appendable_segments || !tmp_segment.get().read().is_empty() {</div><div class="diff-removed">-                write_segments_guard.add_new_locked(tmp_segment);</div><div class="diff-removed">-</div><div class="diff-removed">-                // unlock collection for search and updates</div><div class="diff-removed">-                drop(write_segments_guard);</div><div class="diff-removed">-                // After the collection is unlocked - we can remove data as slow as we want.</div><div class="diff-removed">-</div><div class="diff-removed">-                // Only remove data after we ensure the consistency of the collection.</div><div class="diff-removed">-                // If remove fails - we will still have operational collection with reported error.</div><div class="diff-removed">-                for proxy in proxies {</div><div class="diff-removed">-                    proxy.drop_data()?;</div><div class="diff-removed">-                }</div><div class="diff-added">+            let has_app = write.has_appendable_segment();</div><div class="diff-added">+            if !has_app || !tmp.get().read().is_empty() {</div><div class="diff-added">+                write.add_new_locked(tmp);</div><div>             } else {</div><div class="diff-removed">-                // unlock collection for search and updates</div><div class="diff-removed">-                drop(write_segments_guard);</div><div class="diff-removed">-                // After the collection is unlocked - we can remove data as slow as we want.</div><div class="diff-removed">-</div><div class="diff-removed">-                // Proxy contains pointer to the `tmp_segment`, so they should be removed first</div><div class="diff-removed">-                for proxy in proxies {</div><div class="diff-removed">-                    proxy.drop_data()?;</div><div class="diff-added">+                for px in proxies {</div><div class="diff-added">+                    px.drop_data()?;</div><div>                 }</div><div class="diff-removed">-                tmp_segment.drop_data()?;</div><div>             }</div><div class="diff-removed">-</div><div>             timer.set_success(true);</div><div class="diff-removed">-</div><div class="diff-removed">-            Ok(point_count)</div><div class="diff-added">+            return Ok(point_count as usize);</div><div>         }</div><div>     }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    