<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - o4-mini-medium</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <p><a href="../../models/openai_o4-mini.html">‚Üê Back to o4-mini-medium Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-medium</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 79722</p>
                <p><strong>Native Completion Tokens:</strong> 7743</p>
                <p><strong>Native Tokens Reasoning:</strong> 320</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.00608817</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected)+++ react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual)@@ -7,40 +7,22 @@  * @flow</div><div>  */</div><div> </div><div class="diff-removed">-import type {</div><div class="diff-removed">-  Awaited,</div><div class="diff-removed">-  ReactContext,</div><div class="diff-removed">-  StartTransitionOptions,</div><div class="diff-removed">-  Usable,</div><div class="diff-removed">-  Thenable,</div><div class="diff-removed">-  ReactDebugInfo,</div><div class="diff-removed">-} from 'shared/ReactTypes';</div><div class="diff-added">+import type {Awaited, ReactContext, ReactDebugInfo, StartTransitionOptions, Usable, Thenable} from 'shared/ReactTypes';</div><div> import type {</div><div>   ContextDependency,</div><div>   Dependencies,</div><div class="diff-added">+  Dispatcher as DispatcherType,</div><div>   Fiber,</div><div class="diff-removed">-  Dispatcher as DispatcherType,</div><div> } from 'react-reconciler/src/ReactInternalTypes';</div><div> import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';</div><div class="diff-removed">-</div><div> import ErrorStackParser from 'error-stack-parser';</div><div> import assign from 'shared/assign';</div><div class="diff-added">+import hasOwnProperty from 'shared/hasOwnProperty';</div><div> import ReactSharedInternals from 'shared/ReactSharedInternals';</div><div> import {</div><div class="diff-removed">-  FunctionComponent,</div><div class="diff-removed">-  SimpleMemoComponent,</div><div class="diff-removed">-  ContextProvider,</div><div class="diff-removed">-  ForwardRef,</div><div class="diff-removed">-} from 'react-reconciler/src/ReactWorkTags';</div><div class="diff-removed">-import {</div><div class="diff-added">+  REACT_CONTEXT_TYPE,</div><div>   REACT_MEMO_CACHE_SENTINEL,</div><div class="diff-removed">-  REACT_CONTEXT_TYPE,</div><div> } from 'shared/ReactSymbols';</div><div class="diff-removed">-import hasOwnProperty from 'shared/hasOwnProperty';</div><div class="diff-removed">-</div><div class="diff-removed">-type CurrentDispatcherRef = typeof ReactSharedInternals;</div><div class="diff-removed">-</div><div class="diff-removed">-// Used to track hooks called during a render</div><div> </div><div> type HookLogEntry = {</div><div>   displayName: string | null,</div><div class="diff-info">@@ -53,84 +35,39 @@ </div><div> let hookLog: Array<HookLogEntry> = [];</div><div> </div><div class="diff-removed">-// Primitives</div><div class="diff-removed">-</div><div> type BasicStateAction<S> = (S => S) | S;</div><div class="diff-removed">-</div><div> type Dispatch<A> = A => void;</div><div> </div><div> let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div> </div><div class="diff-removed">-type Hook = {</div><div class="diff-removed">-  memoizedState: any,</div><div class="diff-removed">-  next: Hook | null,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div> function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div class="diff-removed">-  // This initializes a cache of all primitive hooks so that the top</div><div class="diff-removed">-  // most stack frames added by calling the primitive hook can be removed.</div><div>   if (primitiveStackCache === null) {</div><div>     const cache = new Map<string, Array<any>>();</div><div>     let readHookLog;</div><div>     try {</div><div class="diff-removed">-      // Use all hooks here to add them to the hook log.</div><div class="diff-added">+      const Dispatcher = ReactSharedInternals.ReactCurrentDispatcher.current;</div><div class="diff-added">+</div><div class="diff-added">+      // Warm up with all hooks</div><div>       Dispatcher.useContext(({_currentValue: null}: any));</div><div>       Dispatcher.useState(null);</div><div>       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);</div><div>       Dispatcher.useRef(null);</div><div class="diff-removed">-      if (typeof Dispatcher.useCacheRefresh === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useCacheRefresh();</div><div class="diff-removed">-      }</div><div class="diff-removed">-      Dispatcher.useLayoutEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useInsertionEffect(() => {});</div><div class="diff-added">+      Dispatcher.useCacheRefresh();</div><div class="diff-added">+      Dispatcher.useCallback(() => {});</div><div class="diff-added">+      Dispatcher.useContext(({_currentValue: null}: any));</div><div>       Dispatcher.useEffect(() => {});</div><div>       Dispatcher.useImperativeHandle(undefined, () => null);</div><div>       Dispatcher.useDebugValue(null);</div><div class="diff-removed">-      Dispatcher.useCallback(() => {});</div><div class="diff-removed">-      Dispatcher.useTransition();</div><div class="diff-removed">-      Dispatcher.useSyncExternalStore(</div><div class="diff-removed">-        () => () => {},</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-      );</div><div class="diff-removed">-      Dispatcher.useDeferredValue(null);</div><div class="diff-added">+      Dispatcher.useLayoutEffect(() => {});</div><div class="diff-added">+      Dispatcher.useInsertionEffect(() => {});</div><div>       Dispatcher.useMemo(() => null);</div><div class="diff-added">+      Dispatcher.useMemoCache(0);</div><div>       Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);</div><div>       Dispatcher.useFormState((s: mixed, p: mixed) => s, null);</div><div>       Dispatcher.useActionState((s: mixed, p: mixed) => s, null);</div><div>       Dispatcher.useHostTransitionStatus();</div><div class="diff-removed">-      if (typeof Dispatcher.useMemoCache === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useMemoCache(0);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (typeof Dispatcher.use === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.use(</div><div class="diff-removed">-          ({</div><div class="diff-removed">-            $$typeof: REACT_CONTEXT_TYPE,</div><div class="diff-removed">-            _currentValue: null,</div><div class="diff-removed">-          }: any),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        Dispatcher.use({</div><div class="diff-removed">-          then() {},</div><div class="diff-removed">-          status: 'fulfilled',</div><div class="diff-removed">-          value: null,</div><div class="diff-removed">-        });</div><div class="diff-removed">-        try {</div><div class="diff-removed">-          Dispatcher.use(</div><div class="diff-removed">-            ({</div><div class="diff-removed">-              then() {},</div><div class="diff-removed">-            }: any),</div><div class="diff-removed">-          );</div><div class="diff-removed">-        } catch (x) {}</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-added">+      Dispatcher.use(() => {});</div><div>       Dispatcher.useId();</div><div class="diff-removed">-</div><div class="diff-removed">-      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-removed">-        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-removed">-      }</div><div>     } finally {</div><div>       readHookLog = hookLog;</div><div>       hookLog = [];</div><div class="diff-info">@@ -144,9 +81,14 @@   return primitiveStackCache;</div><div> }</div><div> </div><div class="diff-added">+type Hook = {</div><div class="diff-added">+  memoizedState: any,</div><div class="diff-added">+  next: Hook | null,</div><div class="diff-added">+  updateQueue: any | null,</div><div class="diff-added">+};</div><div class="diff-added">+</div><div class="diff-added">+let currentHook: null | Hook = null;</div><div> let currentFiber: null | Fiber = null;</div><div class="diff-removed">-let currentHook: null | Hook = null;</div><div class="diff-removed">-let currentContextDependency: null | ContextDependency<mixed> = null;</div><div> </div><div> function nextHook(): null | Hook {</div><div>   const hook = currentHook;</div><div class="diff-info">@@ -158,43 +100,28 @@ </div><div> function readContext<T>(context: ReactContext<T>): T {</div><div>   if (currentFiber === null) {</div><div class="diff-removed">-    // Hook inspection without access to the Fiber tree</div><div class="diff-removed">-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.</div><div>     return context._currentValue;</div><div>   } else {</div><div>     if (currentContextDependency === null) {</div><div>       throw new Error(</div><div class="diff-removed">-        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',</div><div class="diff-added">+        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.'</div><div>       );</div><div>     }</div><div class="diff-removed">-</div><div>     let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div>     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-removed">-      value = ((currentContextDependency.memoizedValue: any): T);</div><div class="diff-removed">-</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-added">+      // $FlowFixMe[incompatible-use]</div><div class="diff-added">+      value = (currentContextDependency.memoizedValue: any);</div><div class="diff-added">+      // $FlowFixMe[incompatible-use]</div><div>       currentContextDependency = currentContextDependency.next;</div><div>     } else {</div><div class="diff-removed">-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-removed">-      // Multiple reads of the same context were also only tracked as a single dependency.</div><div class="diff-removed">-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.</div><div>       value = context._currentValue;</div><div>     }</div><div class="diff-removed">-</div><div>     return value;</div><div>   }</div><div> }</div><div> </div><div> const SuspenseException: mixed = new Error(</div><div class="diff-removed">-  "Suspense Exception: This is not a real error! It's an implementation " +</div><div class="diff-removed">-    'detail of `use` to interrupt the current render. You must either ' +</div><div class="diff-removed">-    'rethrow it immediately, or move the `use` call outside of the ' +</div><div class="diff-removed">-    '`try/catch` block. Capturing without rethrowing will lead to ' +</div><div class="diff-removed">-    'unexpected behavior.\n\n' +</div><div class="diff-removed">-    'To handle async errors, wrap your component in an error boundary, or ' +</div><div class="diff-removed">-    "call the promise's `.catch` method and pass the result to `use`.",</div><div class="diff-added">+  "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."</div><div> );</div><div> </div><div> function use<T>(usable: Usable<T>): T {</div><div class="diff-info">@@ -210,33 +137,27 @@             primitive: 'Promise',</div><div>             stackError: new Error(),</div><div>             value: fulfilledValue,</div><div class="diff-removed">-            debugInfo:</div><div class="diff-removed">-              thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div class="diff-added">+            debugInfo: thenable._debugInfo ?? null,</div><div>             dispatcherHookName: 'Use',</div><div>           });</div><div>           return fulfilledValue;</div><div>         }</div><div>         case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          throw rejectedError;</div><div class="diff-added">+          throw thenable.reason;</div><div>         }</div><div>       }</div><div class="diff-removed">-      // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-      // but we can still emit anything up until this point.</div><div>       hookLog.push({</div><div>         displayName: null,</div><div>         primitive: 'Unresolved',</div><div>         stackError: new Error(),</div><div>         value: thenable,</div><div class="diff-removed">-        debugInfo:</div><div class="diff-removed">-          thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div class="diff-added">+        debugInfo: thenable._debugInfo ?? null,</div><div>         dispatcherHookName: 'Use',</div><div>       });</div><div>       throw SuspenseException;</div><div>     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {</div><div>       const context: ReactContext<T> = (usable: any);</div><div>       const value = readContext(context);</div><div class="diff-removed">-</div><div>       hookLog.push({</div><div>         displayName: context.displayName || 'Context',</div><div>         primitive: 'Context (use)',</div><div class="diff-info">@@ -245,12 +166,9 @@         debugInfo: null,</div><div>         dispatcherHookName: 'Use',</div><div>       });</div><div class="diff-removed">-</div><div>       return value;</div><div>     }</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // eslint-disable-next-line react-internal/safe-string-coercion</div><div>   throw new Error('An unsupported type was passed to use(): ' + String(usable));</div><div> }</div><div> </div><div class="diff-info">@@ -260,7 +178,7 @@     displayName: context.displayName || null,</div><div>     primitive: 'Context',</div><div>     stackError: new Error(),</div><div class="diff-removed">-    value: value,</div><div class="diff-added">+    value,</div><div>     debugInfo: null,</div><div>     dispatcherHookName: 'Context',</div><div>   });</div><div class="diff-info">@@ -268,14 +186,14 @@ }</div><div> </div><div> function useState<S>(</div><div class="diff-removed">-  initialState: (() => S) | S,</div><div class="diff-added">+  initialState: (() => S) | S</div><div> ): [S, Dispatch<BasicStateAction<S>>] {</div><div>   const hook = nextHook();</div><div>   const state: S =</div><div>     hook !== null</div><div>       ? hook.memoizedState</div><div>       : typeof initialState === 'function'</div><div class="diff-removed">-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-added">+        ? // $FlowFixMe[incompatible-use]</div><div>           initialState()</div><div>         : initialState;</div><div>   hookLog.push({</div><div class="diff-info">@@ -292,7 +210,7 @@ function useReducer<S, I, A>(</div><div>   reducer: (S, A) => S,</div><div>   initialArg: I,</div><div class="diff-removed">-  init?: I => S,</div><div class="diff-added">+  init?: I => S</div><div> ): [S, Dispatch<A>] {</div><div>   const hook = nextHook();</div><div>   let state;</div><div class="diff-info">@@ -341,7 +259,7 @@ </div><div> function useLayoutEffect(</div><div>   create: () => (() => void) | void,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -356,7 +274,7 @@ </div><div> function useInsertionEffect(</div><div>   create: () => mixed,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -369,9 +287,12 @@   });</div><div> }</div><div> </div><div class="diff-removed">-function useEffect(</div><div class="diff-added">+function useEffect<T>(</div><div>   create: () => (() => void) | void,</div><div class="diff-removed">-  deps: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  update?: ((resource: {...} | void | null) => void) | void,</div><div class="diff-added">+  updateDeps?: Array<mixed> | void | null,</div><div class="diff-added">+  destroy?: ((resource: {...} | void | null) => void) | void</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -387,14 +308,10 @@ function useImperativeHandle<T>(</div><div>   ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,</div><div>   create: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null</div><div> ): void {</div><div>   nextHook();</div><div class="diff-removed">-  // We don't actually store the instance anywhere if there is no ref callback</div><div class="diff-removed">-  // and if there is a ref callback it might not store it but if it does we</div><div class="diff-removed">-  // have no way of knowing where. So let's only enable introspection of the</div><div class="diff-removed">-  // ref itself if it is using the object form.</div><div class="diff-removed">-  let instance: ?T = undefined;</div><div class="diff-added">+  let instance;</div><div>   if (ref !== null && typeof ref === 'object') {</div><div>     instance = ref.current;</div><div>   }</div><div class="diff-info">@@ -409,6 +326,7 @@ }</div><div> </div><div> function useDebugValue(value: any, formatterFn: ?(value: any) => any) {</div><div class="diff-added">+  nextHook();</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'DebugValue',</div><div class="diff-info">@@ -434,7 +352,7 @@ </div><div> function useMemo<T>(</div><div>   nextCreate: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null</div><div> ): T {</div><div>   const hook = nextHook();</div><div>   const value = hook !== null ? hook.memoizedState[0] : nextCreate();</div><div class="diff-info">@@ -452,11 +370,8 @@ function useSyncExternalStore<T>(</div><div>   subscribe: (() => void) => () => void,</div><div>   getSnapshot: () => T,</div><div class="diff-removed">-  getServerSnapshot?: () => T,</div><div class="diff-added">+  getServerSnapshot?: () => T</div><div> ): T {</div><div class="diff-removed">-  // useSyncExternalStore() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div>   nextHook(); // SyncExternalStore</div><div>   nextHook(); // Effect</div><div>   const value = getSnapshot();</div><div class="diff-info">@@ -471,18 +386,10 @@   return value;</div><div> }</div><div> </div><div class="diff-removed">-function useTransition(): [</div><div class="diff-removed">-  boolean,</div><div class="diff-removed">-  (callback: () => void, options?: StartTransitionOptions) => void,</div><div class="diff-removed">-] {</div><div class="diff-removed">-  // useTransition() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div class="diff-added">+function useTransition(): [boolean, (() => void) => void] {</div><div>   const stateHook = nextHook();</div><div>   nextHook(); // Callback</div><div class="diff-removed">-</div><div>   const isPending = stateHook !== null ? stateHook.memoizedState : false;</div><div class="diff-removed">-</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'Transition',</div><div class="diff-info">@@ -522,39 +429,9 @@   return id;</div><div> }</div><div> </div><div class="diff-removed">-// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-removed">-// it should not be called directly in user-generated code</div><div class="diff-removed">-function useMemoCache(size: number): Array<mixed> {</div><div class="diff-removed">-  const fiber = currentFiber;</div><div class="diff-removed">-  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-removed">-  if (fiber == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const memoCache =</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-removed">-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-removed">-  if (memoCache == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  let data = memoCache.data[memoCache.index];</div><div class="diff-removed">-  if (data === undefined) {</div><div class="diff-removed">-    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-removed">-    for (let i = 0; i < size; i++) {</div><div class="diff-removed">-      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div class="diff-removed">-  memoCache.index++;</div><div class="diff-removed">-  return data;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> function useOptimistic<S, A>(</div><div>   passthrough: S,</div><div class="diff-removed">-  reducer: ?(S, A) => S,</div><div class="diff-added">+  reducer: ?(S, A) => S</div><div> ): [S, (A) => void] {</div><div>   const hook = nextHook();</div><div>   let state;</div><div class="diff-info">@@ -574,10 +451,14 @@   return [state, (action: A) => {}];</div><div> }</div><div> </div><div class="diff-added">+function useDeferredValue<T>(value: T): T { // fallback overload</div><div class="diff-added">+  return value;</div><div class="diff-added">+}</div><div class="diff-added">+</div><div> function useFormState<S, P>(</div><div>   action: (Awaited<S>, P) => S,</div><div>   initialState: Awaited<S>,</div><div class="diff-removed">-  permalink?: string,</div><div class="diff-added">+  permalink?: string</div><div> ): [Awaited<S>, (P) => void, boolean] {</div><div>   const hook = nextHook(); // FormState</div><div>   nextHook(); // PendingState</div><div class="diff-info">@@ -592,62 +473,49 @@     if (</div><div>       typeof actionResult === 'object' &&</div><div>       actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div>       typeof actionResult.then === 'function'</div><div>     ) {</div><div>       const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div>       switch (thenable.status) {</div><div>         case 'fulfilled': {</div><div>           value = thenable.value;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          debugInfo = thenable._debugInfo ?? null;</div><div>           break;</div><div>         }</div><div>         case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-added">+          error = thenable.reason;</div><div>           break;</div><div>         }</div><div>         default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div>           error = SuspenseException;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          debugInfo = thenable._debugInfo ?? null;</div><div>           value = thenable;</div><div>       }</div><div>     } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-added">+      value = actionResult;</div><div>     }</div><div>   } else {</div><div>     value = initialState;</div><div>   }</div><div class="diff-removed">-</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'FormState',</div><div class="diff-removed">-    stackError: stackError,</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: debugInfo,</div><div class="diff-added">+    stackError,</div><div class="diff-added">+    value,</div><div class="diff-added">+    debugInfo,</div><div>     dispatcherHookName: 'FormState',</div><div>   });</div><div class="diff-removed">-</div><div>   if (error !== null) {</div><div>     throw error;</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div class="diff-removed">-  const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div class="diff-added">+  const state = (value: any);</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div> function useActionState<S, P>(</div><div>   action: (Awaited<S>, P) => S,</div><div>   initialState: Awaited<S>,</div><div class="diff-removed">-  permalink?: string,</div><div class="diff-added">+  permalink?: string</div><div> ): [Awaited<S>, (P) => void, boolean] {</div><div>   const hook = nextHook(); // FormState</div><div>   nextHook(); // PendingState</div><div class="diff-info">@@ -662,67 +530,51 @@     if (</div><div>       typeof actionResult === 'object' &&</div><div>       actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div>       typeof actionResult.then === 'function'</div><div>     ) {</div><div>       const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div>       switch (thenable.status) {</div><div>         case 'fulfilled': {</div><div>           value = thenable.value;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          debugInfo = thenable._debugInfo ?? null;</div><div>           break;</div><div>         }</div><div>         case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-added">+          error = thenable.reason;</div><div>           break;</div><div>         }</div><div>         default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div>           error = SuspenseException;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          debugInfo = thenable._debugInfo ?? null;</div><div>           value = thenable;</div><div>       }</div><div>     } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-added">+      value = actionResult;</div><div>     }</div><div>   } else {</div><div>     value = initialState;</div><div>   }</div><div class="diff-removed">-</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'ActionState',</div><div class="diff-removed">-    stackError: stackError,</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: debugInfo,</div><div class="diff-added">+    stackError,</div><div class="diff-added">+    value,</div><div class="diff-added">+    debugInfo,</div><div>     dispatcherHookName: 'ActionState',</div><div>   });</div><div class="diff-removed">-</div><div>   if (error !== null) {</div><div>     throw error;</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div class="diff-removed">-  const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div class="diff-added">+  const state = (value: any);</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div> function useHostTransitionStatus(): TransitionStatus {</div><div class="diff-removed">-  const status = readContext<TransitionStatus>(</div><div class="diff-removed">-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue</div><div class="diff-added">+  const status = readContext(</div><div>     ({</div><div class="diff-removed">-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.</div><div>       _currentValue: null,</div><div class="diff-removed">-    }: ReactContext<TransitionStatus>),</div><div class="diff-added">+    }: ReactContext<TransitionStatus>)</div><div>   );</div><div class="diff-removed">-</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'HostTransitionStatus',</div><div class="diff-info">@@ -731,75 +583,35 @@     debugInfo: null,</div><div>     dispatcherHookName: 'HostTransitionStatus',</div><div>   });</div><div class="diff-removed">-</div><div>   return status;</div><div> }</div><div> </div><div class="diff-removed">-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'EffectEvent',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: callback,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'EffectEvent',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  return callback;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> const Dispatcher: DispatcherType = {</div><div class="diff-added">+  use,</div><div>   readContext,</div><div class="diff-removed">-</div><div class="diff-removed">-  use,</div><div>   useCallback,</div><div>   useContext,</div><div>   useEffect,</div><div>   useImperativeHandle,</div><div class="diff-added">+  useDebugValue,</div><div>   useLayoutEffect,</div><div>   useInsertionEffect,</div><div>   useMemo,</div><div class="diff-added">+  useMemoCache,</div><div class="diff-added">+  useOptimistic,</div><div>   useReducer,</div><div>   useRef,</div><div>   useState,</div><div class="diff-removed">-  useDebugValue,</div><div class="diff-removed">-  useDeferredValue,</div><div>   useTransition,</div><div>   useSyncExternalStore,</div><div class="diff-added">+  useDeferredValue,</div><div>   useId,</div><div>   useHostTransitionStatus,</div><div>   useFormState,</div><div>   useActionState,</div><div class="diff-removed">-  useOptimistic,</div><div class="diff-removed">-  useMemoCache,</div><div>   useCacheRefresh,</div><div>   useEffectEvent,</div><div> };</div><div class="diff-removed">-</div><div class="diff-removed">-// create a proxy to throw a custom error</div><div class="diff-removed">-// in case future versions of React adds more hooks</div><div class="diff-removed">-const DispatcherProxyHandler = {</div><div class="diff-removed">-  get(target: DispatcherType, prop: string) {</div><div class="diff-removed">-    if (target.hasOwnProperty(prop)) {</div><div class="diff-removed">-      // $FlowFixMe[invalid-computed-prop]</div><div class="diff-removed">-      return target[prop];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const error = new Error('Missing method in Dispatcher: ' + prop);</div><div class="diff-removed">-    // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-    // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-    error.name = 'ReactDebugToolsUnsupportedHookError';</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  },</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-// `Proxy` may not exist on some platforms</div><div class="diff-removed">-const DispatcherProxy =</div><div class="diff-removed">-  typeof Proxy === 'undefined'</div><div class="diff-removed">-    ? Dispatcher</div><div class="diff-removed">-    : new Proxy(Dispatcher, DispatcherProxyHandler);</div><div class="diff-removed">-</div><div class="diff-removed">-// Inspect</div><div> </div><div> export type HookSource = {</div><div>   lineNumber: number | null,</div><div class="diff-info">@@ -807,7 +619,6 @@   fileName: string | null,</div><div>   functionName: string | null,</div><div> };</div><div class="diff-removed">-</div><div> export type HooksNode = {</div><div>   id: number | null,</div><div>   isStateEditable: boolean,</div><div class="diff-info">@@ -819,33 +630,35 @@ };</div><div> export type HooksTree = Array<HooksNode>;</div><div> </div><div class="diff-removed">-// Don't assume</div><div class="diff-removed">-//</div><div class="diff-removed">-// We can't assume that stack frames are nth steps away from anything.</div><div class="diff-removed">-// E.g. we can't assume that the root call shares all frames with the stack</div><div class="diff-removed">-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`</div><div class="diff-removed">-// in a wrapper constructor like a polyfill. That'll add an extra frame.</div><div class="diff-removed">-// Similar things can happen with the call to the dispatcher. The top frame</div><div class="diff-removed">-// may not be the primitive.</div><div class="diff-removed">-//</div><div class="diff-removed">-// We also can't assume that the last frame of the root call is the same</div><div class="diff-removed">-// frame as the last frame of the hook call because long stack traces can be</div><div class="diff-removed">-// truncated to a stack trace limit.</div><div class="diff-removed">-</div><div class="diff-removed">-let mostLikelyAncestorIndex = 0;</div><div class="diff-added">+// create a proxy to throw a custom error</div><div class="diff-added">+const DispatcherProxyHandler = {</div><div class="diff-added">+  get(target: DispatcherType, prop: string) {</div><div class="diff-added">+    if (target.hasOwnProperty(prop)) {</div><div class="diff-added">+      // $FlowFixMe[invalid-computed-prop]</div><div class="diff-added">+      return target[prop];</div><div class="diff-added">+    }</div><div class="diff-added">+    const error = new Error('Missing method in Dispatcher: ' + prop);</div><div class="diff-added">+    error.name = 'ReactDebugToolsUnsupportedHookError';</div><div class="diff-added">+    throw error;</div><div class="diff-added">+  },</div><div class="diff-added">+};</div><div class="diff-added">+const DispatcherProxy =</div><div class="diff-added">+  typeof Proxy === 'undefined'</div><div class="diff-added">+    ? Dispatcher</div><div class="diff-added">+    : new Proxy(Dispatcher, DispatcherProxyHandler);</div><div class="diff-added">+</div><div class="diff-added">+// Inspect</div><div> </div><div> function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {</div><div>   const source = rootStack[rootIndex].source;</div><div>   hookSearch: for (let i = 0; i < hookStack.length; i++) {</div><div>     if (hookStack[i].source === source) {</div><div class="diff-removed">-      // This looks like a match. Validate that the rest of both stack match up.</div><div>       for (</div><div>         let a = rootIndex + 1, b = i + 1;</div><div>         a < rootStack.length && b < hookStack.length;</div><div>         a++, b++</div><div>       ) {</div><div>         if (hookStack[b].source !== rootStack[a].source) {</div><div class="diff-removed">-          // If not, give up and try a different match.</div><div>           continue hookSearch;</div><div>         }</div><div>       }</div><div class="diff-info">@@ -859,13 +672,11 @@   let rootIndex = findSharedIndex(</div><div>     hookStack,</div><div>     rootStack,</div><div class="diff-removed">-    mostLikelyAncestorIndex,</div><div class="diff-added">+    mostLikelyAncestorIndex</div><div>   );</div><div>   if (rootIndex !== -1) {</div><div>     return rootIndex;</div><div>   }</div><div class="diff-removed">-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.</div><div class="diff-removed">-  // If that takes more than 5 frames, something probably went wrong.</div><div>   for (let i = 0; i < rootStack.length && i < 5; i++) {</div><div>     rootIndex = findSharedIndex(hookStack, rootStack, i);</div><div>     if (rootIndex !== -1) {</div><div class="diff-info">@@ -881,7 +692,6 @@   if (wrapperName === 'HostTransitionStatus') {</div><div>     return hookName === wrapperName || hookName === 'FormStatus';</div><div>   }</div><div class="diff-removed">-</div><div>   return hookName === wrapperName;</div><div> }</div><div> </div><div class="diff-info">@@ -892,11 +702,7 @@     return -1;</div><div>   }</div><div>   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {</div><div class="diff-removed">-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack</div><div class="diff-removed">-    // For React Native (uses Hermes), these source fields will be identical and skipped</div><div>     if (primitiveStack[i].source !== hookStack[i].source) {</div><div class="diff-removed">-      // If the next two frames are functions called `useX` then we assume that they're part of the</div><div class="diff-removed">-      // wrappers that the React package or other packages adds around the dispatcher.</div><div>       if (</div><div>         i < hookStack.length - 1 &&</div><div>         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-info">@@ -909,16 +715,13 @@       ) {</div><div>         i++;</div><div>       }</div><div class="diff-removed">-</div><div>       return i;</div><div>     }</div><div>   }</div><div>   return -1;</div><div> }</div><div> </div><div class="diff-removed">-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  // Get the stack trace between the primitive hook function and</div><div class="diff-removed">-  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-added">+function parseTrimmedStack(rootStack: any, hook: HookLogEntry): [any, any] {</div><div>   const hookStack = ErrorStackParser.parse(hook.stackError);</div><div>   const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div>   const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-info">@@ -928,7 +731,6 @@     rootIndex - primitiveIndex < 2</div><div>   ) {</div><div>     if (primitiveIndex === -1) {</div><div class="diff-removed">-      // Something went wrong. Give up.</div><div>       return [null, null];</div><div>     } else {</div><div>       return [hookStack[primitiveIndex - 1], null];</div><div class="diff-info">@@ -945,12 +747,10 @@     return '';</div><div>   }</div><div>   let startIndex = functionName.lastIndexOf('[as ');</div><div class="diff-removed">-</div><div>   if (startIndex !== -1) {</div><div class="diff-removed">-    // Workaround for sourcemaps in Jest and Chrome.</div><div class="diff-removed">-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"</div><div class="diff-removed">-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"</div><div class="diff-removed">-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));</div><div class="diff-added">+    return parseHookName(</div><div class="diff-added">+      functionName.slice(startIndex + '[as '.length, -1)</div><div class="diff-added">+    );</div><div>   }</div><div>   startIndex = functionName.lastIndexOf('.');</div><div>   if (startIndex === -1) {</div><div class="diff-info">@@ -958,15 +758,9 @@   } else {</div><div>     startIndex += 1;</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('unstable_')) {</div><div class="diff-removed">-    startIndex += 'unstable_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div>   if (functionName.slice(startIndex).startsWith('experimental_')) {</div><div>     startIndex += 'experimental_'.length;</div><div>   }</div><div class="diff-removed">-</div><div>   if (functionName.slice(startIndex, startIndex + 3) === 'use') {</div><div>     if (functionName.length - startIndex === 3) {</div><div>       return 'Use';</div><div class="diff-info">@@ -976,10 +770,7 @@   return functionName.slice(startIndex);</div><div> }</div><div> </div><div class="diff-removed">-function buildTree(</div><div class="diff-removed">-  rootStack: any,</div><div class="diff-removed">-  readHookLog: Array<HookLogEntry>,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-added">+function buildTree(rootStack: any, readHookLog: Array<HookLogEntry>): HooksTree {</div><div>   const rootChildren: Array<HooksNode> = [];</div><div>   let prevStack = null;</div><div>   let levelChildren = rootChildren;</div><div class="diff-info">@@ -994,20 +785,17 @@     if (displayName === null && primitiveFrame !== null) {</div><div>       displayName =</div><div>         parseHookName(primitiveFrame.functionName) ||</div><div class="diff-removed">-        // Older versions of React do not have sourcemaps.</div><div class="diff-removed">-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div>         parseHookName(hook.dispatcherHookName);</div><div>     }</div><div>     if (stack !== null) {</div><div class="diff-removed">-      // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-removed">-      // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div>       let commonSteps = 0;</div><div>       if (prevStack !== null) {</div><div class="diff-removed">-        // Compare the current level's stack to the new stack.</div><div class="diff-removed">-        while (commonSteps < stack.length && commonSteps < prevStack.length) {</div><div class="diff-removed">-          const stackSource = stack[stack.length - commonSteps - 1].source;</div><div class="diff-added">+        while (</div><div class="diff-added">+          commonSteps < stack.length &&</div><div class="diff-added">+          commonSteps < prevStack.length</div><div class="diff-added">+        ) {</div><div class="diff-added">+          const stackSource =</div><div class="diff-added">+            stack[stack.length - commonSteps - 1].source;</div><div>           const prevSource =</div><div>             prevStack[prevStack.length - commonSteps - 1].source;</div><div>           if (stackSource !== prevSource) {</div><div class="diff-info">@@ -1015,14 +803,10 @@           }</div><div>           commonSteps++;</div><div>         }</div><div class="diff-removed">-        // Pop back the stack as many steps as were not common.</div><div>         for (let j = prevStack.length - 1; j > commonSteps; j--) {</div><div class="diff-removed">-          // $FlowFixMe[incompatible-type]</div><div>           levelChildren = stackOfChildren.pop();</div><div>         }</div><div>       }</div><div class="diff-removed">-      // The remaining part of the new stack are custom hooks. Push them</div><div class="diff-removed">-      // to the tree.</div><div>       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div>         const children: Array<HooksNode> = [];</div><div>         const stackFrame = stack[j];</div><div class="diff-info">@@ -1036,11 +820,10 @@           hookSource: {</div><div>             lineNumber: stackFrame.lineNumber,</div><div>             columnNumber: stackFrame.columnNumber,</div><div class="diff-added">+            fileName: stackFrame.fileName,</div><div>             functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div>           },</div><div>         };</div><div class="diff-removed">-</div><div>         levelChildren.push(levelChild);</div><div>         stackOfChildren.push(levelChildren);</div><div>         levelChildren = children;</div><div class="diff-info">@@ -1048,9 +831,6 @@       prevStack = stack;</div><div>     }</div><div>     const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div>     const id =</div><div>       primitive === 'Context' ||</div><div>       primitive === 'Context (use)' ||</div><div class="diff-info">@@ -1060,20 +840,18 @@       primitive === 'HostTransitionStatus'</div><div>         ? null</div><div>         : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-added">+    const isStateEditable =</div><div class="diff-added">+      primitive === 'Reducer' || primitive === 'State';</div><div class="diff-added">+    const name = hook.displayName || primitive;</div><div>     const levelChild: HooksNode = {</div><div>       id,</div><div>       isStateEditable,</div><div>       name,</div><div>       value: hook.value,</div><div>       subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-added">+      debugInfo,</div><div>       hookSource: null,</div><div>     };</div><div class="diff-removed">-</div><div>     const hookSource: HookSource = {</div><div>       lineNumber: null,</div><div>       functionName: null,</div><div class="diff-info">@@ -1087,32 +865,24 @@       hookSource.fileName = stackFrame.fileName;</div><div>       hookSource.columnNumber = stackFrame.columnNumber;</div><div>     }</div><div class="diff-removed">-</div><div>     levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div>     levelChildren.push(levelChild);</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div>   processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div>   return rootChildren;</div><div> }</div><div> </div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div> function processDebugValues(</div><div>   hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-added">+  parentHooksNode: HooksNode | null</div><div> ): void {</div><div>   const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div>   for (let i = 0; i < hooksTree.length; i++) {</div><div>     const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-added">+    if (</div><div class="diff-added">+      hooksNode.name === 'DebugValue' &&</div><div class="diff-added">+      hooksNode.subHooks.length === 0</div><div class="diff-added">+    ) {</div><div>       hooksTree.splice(i, 1);</div><div>       i--;</div><div>       debugValueHooksNodes.push(hooksNode);</div><div class="diff-info">@@ -1120,66 +890,49 @@       processDebugValues(hooksNode.subHooks, hooksNode);</div><div>     }</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div>   if (parentHooksNode !== null) {</div><div>     if (debugValueHooksNodes.length === 1) {</div><div>       parentHooksNode.value = debugValueHooksNodes[0].value;</div><div>     } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-added">+      parentHooksNode.value = debugValueHooksNodes.map(</div><div class="diff-added">+        ({value}) => value</div><div class="diff-added">+      );</div><div>     }</div><div>   }</div><div> }</div><div> </div><div> function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div>   if (</div><div>     error instanceof Error &&</div><div>     error.name === 'ReactDebugToolsUnsupportedHookError'</div><div>   ) {</div><div>     throw error;</div><div>   }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-added">+  if (error === SuspenseException) {</div><div class="diff-added">+    return;</div><div class="diff-added">+  }</div><div class="diff-added">+  const wrapperError = new Error(</div><div class="diff-added">+    'Error rendering inspected component',</div><div class="diff-added">+    {cause: error}</div><div class="diff-added">+  );</div><div>   wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-added">+  // $FlowFixMe[prop-missing]</div><div>   wrapperError.cause = error;</div><div>   throw wrapperError;</div><div> }</div><div> </div><div class="diff-removed">-export function inspectHooks<Props>(</div><div class="diff-added">+function inspectHooks<Props>(</div><div>   renderFunction: Props => React$Node,</div><div>   props: Props,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-added">+  currentDispatcher: ?typeof ReactSharedInternals</div><div> ): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div>   if (currentDispatcher == null) {</div><div>     currentDispatcher = ReactSharedInternals;</div><div>   }</div><div class="diff-removed">-</div><div>   const previousDispatcher = currentDispatcher.H;</div><div>   currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-</div><div>   let readHookLog;</div><div>   let ancestorStackError;</div><div class="diff-removed">-</div><div>   try {</div><div>     ancestorStackError = new Error();</div><div>     renderFunction(props);</div><div class="diff-info">@@ -1188,26 +941,26 @@   } finally {</div><div>     readHookLog = hookLog;</div><div>     hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div class="diff-added">+    // $FlowFixMe[incompatible-use]</div><div>     currentDispatcher.H = previousDispatcher;</div><div>   }</div><div>   const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div>   return buildTree(rootStack, readHookLog);</div><div> }</div><div> </div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-added">+function setupContexts(</div><div class="diff-added">+  contextMap: Map<ReactContext<any>, any>,</div><div class="diff-added">+  fiber: Fiber</div><div class="diff-added">+) {</div><div>   let current: null | Fiber = fiber;</div><div>   while (current) {</div><div>     if (current.tag === ContextProvider) {</div><div>       let context: ReactContext<any> = current.type;</div><div>       if ((context: any)._context !== undefined) {</div><div class="diff-removed">-        // Support inspection of pre-19+ providers.</div><div>         context = (context: any)._context;</div><div>       }</div><div>       if (!contextMap.has(context)) {</div><div class="diff-removed">-        // Store the current value that we're going to restore later.</div><div>         contextMap.set(context, context._currentValue);</div><div class="diff-removed">-        // Set the inner most provider value on the context.</div><div>         context._currentValue = current.memoizedProps.value;</div><div>       }</div><div>     }</div><div class="diff-info">@@ -1219,11 +972,11 @@   contextMap.forEach((value, context) => (context._currentValue = value));</div><div> }</div><div> </div><div class="diff-removed">-function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-added">+export function inspectHooksOfForwardRef<Props, Ref>(</div><div>   renderFunction: (Props, Ref) => React$Node,</div><div>   props: Props,</div><div>   ref: Ref,</div><div class="diff-removed">-  currentDispatcher: CurrentDispatcherRef,</div><div class="diff-added">+  currentDispatcher: typeof ReactSharedInternals</div><div> ): HooksTree {</div><div>   const previousDispatcher = currentDispatcher.H;</div><div>   let readHookLog;</div><div class="diff-info">@@ -1237,6 +990,7 @@   } finally {</div><div>     readHookLog = hookLog;</div><div>     hookLog = [];</div><div class="diff-added">+    // $FlowFixMe[incompatible-use]</div><div>     currentDispatcher.H = previousDispatcher;</div><div>   }</div><div>   const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-info">@@ -1245,7 +999,6 @@ </div><div> function resolveDefaultProps(Component: any, baseProps: any) {</div><div>   if (Component && Component.defaultProps) {</div><div class="diff-removed">-    // Resolve default props. Taken from ReactElement</div><div>     const props = assign({}, baseProps);</div><div>     const defaultProps = Component.defaultProps;</div><div>     for (const propName in defaultProps) {</div><div class="diff-info">@@ -1260,52 +1013,48 @@ </div><div> export function inspectHooksOfFiber(</div><div>   fiber: Fiber,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-added">+  currentDispatcher: ?typeof ReactSharedInternals</div><div> ): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div>   if (</div><div>     fiber.tag !== FunctionComponent &&</div><div>     fiber.tag !== SimpleMemoComponent &&</div><div>     fiber.tag !== ForwardRef</div><div>   ) {</div><div>     throw new Error(</div><div class="diff-removed">-      'Unknown Fiber. Needs to be a function component to inspect hooks.',</div><div class="diff-added">+      'Unknown Fiber. Needs to be a function component to inspect hooks.'</div><div>     );</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div>   getPrimitiveStackCache();</div><div class="diff-removed">-</div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div>   currentHook = (fiber.memoizedState: Hook);</div><div>   currentFiber = fiber;</div><div class="diff-removed">-</div><div>   if (hasOwnProperty.call(currentFiber, 'dependencies')) {</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`</div><div class="diff-removed">-    const dependencies = currentFiber.dependencies;</div><div class="diff-added">+    // $FlowFixMe[incompatible-use]</div><div class="diff-added">+    const dependencies: Dependencies = currentFiber.dependencies;</div><div>     currentContextDependency =</div><div>       dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {</div><div class="diff-added">+  } else if (</div><div class="diff-added">+    hasOwnProperty.call(currentFiber, 'dependencies_old')</div><div class="diff-added">+  ) {</div><div>     const dependencies: Dependencies = (currentFiber: any).dependencies_old;</div><div>     currentContextDependency =</div><div>       dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {</div><div class="diff-added">+  } else if (</div><div class="diff-added">+    hasOwnProperty.call(currentFiber, 'dependencies_new')</div><div class="diff-added">+  ) {</div><div>     const dependencies: Dependencies = (currentFiber: any).dependencies_new;</div><div>     currentContextDependency =</div><div>       dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {</div><div class="diff-added">+  } else if (</div><div class="diff-added">+    hasOwnProperty.call(currentFiber, 'contextDependencies')</div><div class="diff-added">+  ) {</div><div>     const contextDependencies = (currentFiber: any).contextDependencies;</div><div>     currentContextDependency =</div><div class="diff-removed">-      contextDependencies !== null ? contextDependencies.first : null;</div><div class="diff-added">+      contextDependencies !== null</div><div class="diff-added">+        ? contextDependencies.first</div><div class="diff-added">+        : null;</div><div>   } else {</div><div>     throw new Error(</div><div class="diff-removed">-      'Unsupported React version. This is a bug in React Debug Tools.',</div><div class="diff-added">+      'Unsupported React version. This is a bug in React Debug Tools.'</div><div>     );</div><div>   }</div><div> </div><div class="diff-info">@@ -1314,32 +1063,30 @@   if (type !== fiber.elementType) {</div><div>     props = resolveDefaultProps(type, props);</div><div>   }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Only used for versions of React without memoized context value in context dependencies.</div><div>   const contextMap = new Map<ReactContext<any>, any>();</div><div>   try {</div><div>     if (</div><div>       currentContextDependency !== null &&</div><div class="diff-removed">-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')</div><div class="diff-added">+      !hasOwnProperty.call(</div><div class="diff-added">+        currentContextDependency,</div><div class="diff-added">+        'memoizedValue'</div><div class="diff-added">+      )</div><div>     ) {</div><div>       setupContexts(contextMap, fiber);</div><div>     }</div><div class="diff-removed">-</div><div>     if (fiber.tag === ForwardRef) {</div><div>       return inspectHooksOfForwardRef(</div><div>         type.render,</div><div>         props,</div><div>         fiber.ref,</div><div class="diff-removed">-        currentDispatcher,</div><div class="diff-added">+        currentDispatcher</div><div>       );</div><div>     }</div><div class="diff-removed">-</div><div>     return inspectHooks(type, props, currentDispatcher);</div><div>   } finally {</div><div class="diff-added">+    currentContextDependency = null;</div><div>     currentFiber = null;</div><div>     currentHook = null;</div><div class="diff-removed">-    currentContextDependency = null;</div><div class="diff-removed">-</div><div>     restoreContexts(contextMap);</div><div>   }</div><div> }</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    