<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs - o4-mini-medium</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs</h1>
        <p><a href="../../models/openai_o4-mini.html">‚Üê Back to o4-mini-medium Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-medium</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58760</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 58972</p>
                <p><strong>Native Completion Tokens:</strong> 13352</p>
                <p><strong>Native Tokens Reasoning:</strong> 6592</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0061809</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 237415b4..86229a9e 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected):tmp/tmppehk83kq_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual):tmp/tmp_rr_av7__actual.txt	</div><div class="diff-info">@@ -9,15 +9,12 @@ use segment::types::{HnswConfig, QuantizationConfig, SegmentType};</div><div> use crate::collection_manager::holders::segment_holder::{</div><div>     LockedSegmentHolder, SegmentHolder, SegmentId,</div><div> };</div><div class="diff-removed">-use crate::collection_manager::optimizers::segment_optimizer::{</div><div class="diff-removed">-    OptimizerThresholds, SegmentOptimizer,</div><div class="diff-removed">-};</div><div class="diff-added">+use crate::collection_manager::optimizers::segment_optimizer::{OptimizerThresholds, SegmentOptimizer};</div><div> use crate::config::CollectionParams;</div><div> </div><div> const BYTES_IN_KB: usize = 1024;</div><div> </div><div> /// Looks for the segments, which require to be indexed.</div><div class="diff-removed">-///</div><div> /// If segment is too large, but still does not have indexes - it is time to create some indexes.</div><div> /// The process of index creation is slow and CPU-bounded, so it is convenient to perform</div><div> /// index building in a same way as segment re-creation.</div><div class="diff-info">@@ -60,7 +57,6 @@ impl IndexingOptimizer {</div><div>     ) -> Option<(SegmentId, usize)> {</div><div>         segments</div><div>             .iter()</div><div class="diff-removed">-            // Excluded externally, might already be scheduled for optimization</div><div>             .filter(|(idx, _)| !excluded_ids.contains(idx))</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div class="diff-info">@@ -75,16 +71,15 @@ impl IndexingOptimizer {</div><div> </div><div>                 let segment_config = read_segment.config();</div><div>                 let is_any_vector_indexed = segment_config.is_any_vector_indexed();</div><div class="diff-removed">-                let is_any_on_disk = segment_config.is_any_on_disk();</div><div class="diff-added">+                let is_any_mmap = segment_config.is_any_mmap();</div><div> </div><div class="diff-removed">-                if !(is_any_vector_indexed || is_any_on_disk) {</div><div class="diff-added">+                if !(is_any_vector_indexed || is_any_mmap) {</div><div>                     return None;</div><div>                 }</div><div> </div><div class="diff-removed">-                Some((idx, vector_size))</div><div class="diff-added">+                Some((*idx, vector_size))</div><div>             })</div><div>             .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes)</div><div class="diff-removed">-            .map(|(idx, size)| (*idx, size))</div><div>     }</div><div> </div><div>     fn worst_segment(</div><div class="diff-info">@@ -95,21 +90,20 @@ impl IndexingOptimizer {</div><div>         let segments_read_guard = segments.read();</div><div>         let candidates: Vec<_> = segments_read_guard</div><div>             .iter()</div><div class="diff-removed">-            // Excluded externally, might already be scheduled for optimization</div><div>             .filter(|(idx, _)| !excluded_ids.contains(idx))</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div>                 let read_segment = segment_entry.read();</div><div class="diff-added">+                let point_count = read_segment.available_point_count();</div><div>                 let max_vector_size_bytes = read_segment</div><div>                     .max_available_vectors_size_in_bytes()</div><div>                     .unwrap_or_default();</div><div> </div><div class="diff-removed">-                let segment_config = read_segment.config();</div><div class="diff-removed">-</div><div>                 if read_segment.segment_type() == SegmentType::Special {</div><div class="diff-removed">-                    return None; // Never optimize already optimized segment</div><div class="diff-added">+                    return None;</div><div>                 }</div><div> </div><div class="diff-added">+                let segment_config = read_segment.config();</div><div>                 let indexing_threshold_bytes = self</div><div>                     .thresholds_config</div><div>                     .indexing_threshold_kb</div><div class="diff-info">@@ -127,10 +121,8 @@ impl IndexingOptimizer {</div><div>                         let storage_size_bytes = read_segment</div><div>                             .available_vectors_size_in_bytes(vector_name)</div><div>                             .unwrap_or_default();</div><div class="diff-removed">-</div><div>                         let is_big_for_index = storage_size_bytes >= indexing_threshold_bytes;</div><div>                         let is_big_for_mmap = storage_size_bytes >= mmap_threshold_bytes;</div><div class="diff-removed">-</div><div>                         let optimize_for_index = is_big_for_index && !is_indexed;</div><div>                         let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk</div><div>                         {</div><div class="diff-info">@@ -138,7 +130,6 @@ impl IndexingOptimizer {</div><div>                         } else {</div><div>                             is_big_for_mmap && !is_on_disk</div><div>                         };</div><div class="diff-removed">-</div><div>                         if optimize_for_index || optimize_for_mmap {</div><div>                             require_optimization = true;</div><div>                             break;</div><div class="diff-info">@@ -147,8 +138,7 @@ impl IndexingOptimizer {</div><div>                 }</div><div> </div><div>                 if !require_optimization {</div><div class="diff-removed">-                    if let Some(sparse_vectors_params) =</div><div class="diff-removed">-                        self.collection_params.sparse_vectors.as_ref()</div><div class="diff-added">+                    if let Some(sparse_vectors_params) = self.collection_params.sparse_vectors.as_ref()</div><div>                     {</div><div>                         for sparse_vector_name in sparse_vectors_params.keys() {</div><div>                             if let Some(sparse_vector_data) =</div><div class="diff-info">@@ -156,16 +146,12 @@ impl IndexingOptimizer {</div><div>                             {</div><div>                                 let is_index_immutable =</div><div>                                     sparse_vector_data.index.index_type.is_immutable();</div><div class="diff-removed">-</div><div>                                 let storage_size = read_segment</div><div>                                     .available_vectors_size_in_bytes(sparse_vector_name)</div><div>                                     .unwrap_or_default();</div><div class="diff-removed">-</div><div>                                 let is_big_for_index = storage_size >= indexing_threshold_bytes;</div><div>                                 let is_big_for_mmap = storage_size >= mmap_threshold_bytes;</div><div class="diff-removed">-</div><div>                                 let is_big = is_big_for_index || is_big_for_mmap;</div><div class="diff-removed">-</div><div>                                 if is_big && !is_index_immutable {</div><div>                                     require_optimization = true;</div><div>                                     break;</div><div class="diff-info">@@ -187,12 +173,10 @@ impl IndexingOptimizer {</div><div>             return vec![];</div><div>         }</div><div>         let (selected_segment_id, selected_segment_size) = *selected_segment.unwrap();</div><div class="diff-removed">-</div><div>         let number_of_segments = segments_read_guard.len();</div><div> </div><div>         // If the number of segments if equal or bigger than the default_segments_number</div><div>         // We want to make sure that we at least do not increase number of segments after optimization, thus we take more than one segment to optimize</div><div class="diff-removed">-</div><div>         if number_of_segments < self.default_segments_number {</div><div>             return vec![selected_segment_id];</div><div>         }</div><div class="diff-info">@@ -281,8 +265,8 @@ impl SegmentOptimizer for IndexingOptimizer {</div><div> mod tests {</div><div>     use std::collections::BTreeMap;</div><div>     use std::ops::Deref;</div><div class="diff-removed">-    use std::sync::Arc;</div><div>     use std::sync::atomic::AtomicBool;</div><div class="diff-added">+    use std::sync::Arc;</div><div> </div><div>     use common::budget::ResourceBudget;</div><div>     use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-info">@@ -346,7 +330,8 @@ mod tests {</div><div>             .map(|(name, params)| {</div><div>                 (</div><div>                     name.to_owned(),</div><div class="diff-removed">-                    VectorParamsBuilder::new(params.size as u64, params.distance).build(),</div><div class="diff-added">+                    VectorParamsBuilder::new(params.size as u64, params.distance)</div><div class="diff-added">+                        .build(),</div><div>                 )</div><div>             })</div><div>             .collect();</div><div class="diff-info">@@ -382,16 +367,17 @@ mod tests {</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div>         assert!(suggested_to_optimize.contains(&large_segment_id));</div><div> </div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div>         index_optimizer</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-added">+                ResourceBudget::new(</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                )</div><div class="diff-added">+                .try_acquire(0, num_rayon_threads(0))</div><div class="diff-added">+                .unwrap(),</div><div class="diff-added">+                Default::default(),</div><div>                 &stopped,</div><div>             )</div><div>             .unwrap();</div><div class="diff-info">@@ -399,12 +385,18 @@ mod tests {</div><div>         let infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|(_sid, segment)| match segment {</div><div class="diff-added">+                LockedSegment::Original(s) => s.read().info(),</div><div class="diff-added">+                _ => panic!("Unexpected proxy segment"),</div><div class="diff-added">+            })</div><div>             .collect_vec();</div><div>         let configs = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-added">+            .map(|(_sid, segment)| match segment {</div><div class="diff-added">+                LockedSegment::Original(s) => s.read().config().clone(),</div><div class="diff-added">+                _ => panic!("Unexpected proxy segment"),</div><div class="diff-added">+            })</div><div>             .collect_vec();</div><div> </div><div>         assert_eq!(infos.len(), 2);</div><div class="diff-info">@@ -430,7 +422,6 @@ mod tests {</div><div>         let mut holder = SegmentHolder::default();</div><div> </div><div>         let payload_field: JsonPath = "number".parse().unwrap();</div><div class="diff-removed">-</div><div>         let stopped = AtomicBool::new(false);</div><div>         let dim = 256;</div><div> </div><div class="diff-info">@@ -442,15 +433,12 @@ mod tests {</div><div>         let mut opnum = 101..1000000;</div><div> </div><div>         let small_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 25, dim);</div><div class="diff-removed">-        let middle_low_segment =</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 90, dim);</div><div>         let middle_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim);</div><div>         let large_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 200, dim);</div><div> </div><div>         let segment_config = small_segment.segment_config.clone();</div><div> </div><div>         let small_segment_id = holder.add_new(small_segment);</div><div class="diff-removed">-        let middle_low_segment_id = holder.add_new(middle_low_segment);</div><div>         let middle_segment_id = holder.add_new(middle_segment);</div><div>         let large_segment_id = holder.add_new(large_segment);</div><div> </div><div class="diff-info">@@ -476,7 +464,6 @@ mod tests {</div><div>             Default::default(),</div><div>             Default::default(),</div><div>         );</div><div class="diff-removed">-</div><div>         let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div> </div><div>         let excluded_ids = Default::default();</div><div class="diff-info">@@ -486,34 +473,15 @@ mod tests {</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div>         assert!(suggested_to_optimize.is_empty());</div><div> </div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;</div><div class="diff-added">+        index_optimizer.thresholds_config.memmap_threshold_kb = 150;</div><div>         index_optimizer.thresholds_config.indexing_threshold_kb = 50;</div><div> </div><div>         let suggested_to_optimize =</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div>         assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&middle_low_segment_id));</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 1000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 50;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 1000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 150;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 50;</div><div> </div><div>         // ----- CREATE AN INDEXED FIELD ------</div><div>         let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div>         process_field_index_operation(</div><div>             locked_holder.deref(),</div><div>             opnum.next().unwrap(),</div><div class="diff-info">@@ -525,10 +493,6 @@ mod tests {</div><div>         )</div><div>         .unwrap();</div><div> </div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div>         // ------ Plain -> Mmap & Indexed payload</div><div>         let suggested_to_optimize =</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-info">@@ -538,15 +502,19 @@ mod tests {</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-added">+                ResourceBudget::new(</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                )</div><div class="diff-added">+                .try_acquire(0, num_rayon_threads(0))</div><div class="diff-added">+                .unwrap(),</div><div class="diff-added">+                Default::default(),</div><div>                 &stopped,</div><div>             )</div><div>             .unwrap();</div><div>         eprintln!("Done");</div><div> </div><div>         // ------ Plain -> Indexed payload</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div>         let suggested_to_optimize =</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div>         assert!(suggested_to_optimize.contains(&middle_segment_id));</div><div class="diff-info">@@ -554,8 +522,13 @@ mod tests {</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-added">+                ResourceBudget::new(</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                )</div><div class="diff-added">+                .try_acquire(0, num_rayon_threads(0))</div><div class="diff-added">+                .unwrap(),</div><div class="diff-added">+                Default::default(),</div><div>                 &stopped,</div><div>             )</div><div>             .unwrap();</div><div class="diff-info">@@ -574,12 +547,12 @@ mod tests {</div><div>         let infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|(_, segment)| segment.get().read().info())</div><div>             .collect_vec();</div><div>         let configs = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-added">+            .map(|(_, segment)| segment.get().read().config().clone())</div><div>             .collect_vec();</div><div> </div><div>         let indexed_count = infos</div><div class="diff-info">@@ -595,10 +568,7 @@ mod tests {</div><div>             .iter()</div><div>             .filter(|config| config.is_any_on_disk())</div><div>             .count();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            on_disk_count, 1,</div><div class="diff-removed">-            "Testing that only largest segment is not Mmap"</div><div class="diff-removed">-        );</div><div class="diff-added">+        assert_eq!(on_disk_count, 1, "Testing that only largest segment is on disk");</div><div> </div><div>         let segment_dirs = segments_dir.path().read_dir().unwrap().collect_vec();</div><div>         assert_eq!(</div><div class="diff-info">@@ -620,32 +590,26 @@ mod tests {</div><div>         }</div><div> </div><div>         let point_payload = payload_json! {"number": 10000i64};</div><div class="diff-removed">-</div><div class="diff-removed">-        let batch = BatchPersisted {</div><div class="diff-removed">-            ids: vec![501.into(), 502.into(), 503.into()],</div><div class="diff-removed">-            vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-            payloads: Some(vec![</div><div class="diff-removed">-                Some(point_payload.clone()),</div><div class="diff-removed">-                Some(point_payload.clone()),</div><div class="diff-removed">-                Some(point_payload),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div>         let insert_point_ops =</div><div class="diff-removed">-            PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div class="diff-removed">-</div><div class="diff-added">+            PointOperations::UpsertPoints(PointInsertOperationsInternal::from(BatchPersisted {</div><div class="diff-added">+                ids: vec![501.into(), 502.into(), 503.into()],</div><div class="diff-added">+                vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                ]),</div><div class="diff-added">+                payloads: Some(vec![</div><div class="diff-added">+                    Some(point_payload.clone()),</div><div class="diff-added">+                    Some(point_payload.clone()),</div><div class="diff-added">+                    Some(point_payload),</div><div class="diff-added">+                ]),</div><div class="diff-added">+            }));</div><div>         let smallest_size = infos</div><div>             .iter()</div><div>             .min_by_key(|info| info.num_vectors)</div><div>             .unwrap()</div><div>             .num_vectors;</div><div> </div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div>         process_point_operation(</div><div>             locked_holder.deref(),</div><div>             opnum.next().unwrap(),</div><div class="diff-info">@@ -657,7 +621,7 @@ mod tests {</div><div>         let new_infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|(_, segment)| segment.get().read().info())</div><div>             .collect_vec();</div><div>         let new_smallest_size = new_infos</div><div>             .iter()</div><div class="diff-info">@@ -673,8 +637,6 @@ mod tests {</div><div> </div><div>         // ---- New appendable segment should be created if none left</div><div> </div><div class="diff-removed">-        // Index even the smallest segment</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div>         index_optimizer.thresholds_config.indexing_threshold_kb = 20;</div><div>         let suggested_to_optimize =</div><div>             index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-info">@@ -683,8 +645,13 @@ mod tests {</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-added">+                ResourceBudget::new(</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                    num_rayon_threads(0),</div><div class="diff-added">+                )</div><div class="diff-added">+                .try_acquire(0, num_rayon_threads(0))</div><div class="diff-added">+                .unwrap(),</div><div class="diff-added">+                Default::default(),</div><div>                 &stopped,</div><div>             )</div><div>             .unwrap();</div><div class="diff-info">@@ -692,31 +659,25 @@ mod tests {</div><div>         let new_infos2 = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|(_, segment)| segment.get().read().info())</div><div>             .collect_vec();</div><div> </div><div class="diff-removed">-        let mut has_empty = false;</div><div class="diff-removed">-        for info in new_infos2 {</div><div class="diff-removed">-            has_empty |= info.num_vectors == 0;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         assert!(</div><div class="diff-removed">-            has_empty,</div><div class="diff-removed">-            "Testing that new segment is created if none left"</div><div class="diff-added">+            new_infos2.len() > new_infos.len(),</div><div class="diff-added">+            "Testing that new appendable segment was created"</div><div>         );</div><div> </div><div class="diff-removed">-        let batch = BatchPersisted {</div><div class="diff-removed">-            ids: vec![601.into(), 602.into(), 603.into()],</div><div class="diff-removed">-            vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-            payloads: None,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let insert_point_ops =</div><div class="diff-removed">-            PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div class="diff-added">+        let insert_point_ops = PointOperations::UpsertPoints(</div><div class="diff-added">+            PointInsertOperationsInternal::from(BatchPersisted {</div><div class="diff-added">+                ids: vec![601.into(), 602.into(), 603.into()],</div><div class="diff-added">+                vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                    random_vector(&mut rng, dim),</div><div class="diff-added">+                ]),</div><div class="diff-added">+                payloads: None,</div><div class="diff-added">+            }),</div><div class="diff-added">+        );</div><div> </div><div>         process_point_operation(</div><div>             locked_holder.deref(),</div><div class="diff-info">@@ -727,115 +688,6 @@ mod tests {</div><div>         .unwrap();</div><div>     }</div><div> </div><div class="diff-removed">-    /// Test that indexing optimizer maintain expected number of during the optimization duty</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_indexing_optimizer_with_number_of_segments() {</div><div class="diff-removed">-        init();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let stopped = AtomicBool::new(false);</div><div class="diff-removed">-        let dim = 256;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_dir = Builder::new().prefix("segments_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segments_temp_dir = Builder::new()</div><div class="diff-removed">-            .prefix("segments_temp_dir")</div><div class="diff-removed">-            .tempdir()</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        let mut opnum = 101..1000000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments = vec![</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-        ];</div><div class="diff-removed">-</div><div class="diff-removed">-        let number_of_segments = segments.len();</div><div class="diff-removed">-        let segment_config = segments[0].segment_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let _segment_ids: Vec<SegmentId> = segments</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|segment| holder.add_new(segment))</div><div class="diff-removed">-            .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-        let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-            number_of_segments, // Keep the same number of segments</div><div class="diff-removed">-            OptimizerThresholds {</div><div class="diff-removed">-                max_segment_size_kb: 1000,</div><div class="diff-removed">-                memmap_threshold_kb: 1000,</div><div class="diff-removed">-                indexing_threshold_kb: 10, // Always optimize</div><div class="diff-removed">-            },</div><div class="diff-removed">-            segments_dir.path().to_owned(),</div><div class="diff-removed">-            segments_temp_dir.path().to_owned(),</div><div class="diff-removed">-            CollectionParams {</div><div class="diff-removed">-                vectors: VectorsConfig::Single(</div><div class="diff-removed">-                    VectorParamsBuilder::new(</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].size as u64,</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].distance,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                    .build(),</div><div class="diff-removed">-                ),</div><div class="diff-removed">-                ..CollectionParams::empty()</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Index until all segments are indexed</div><div class="diff-removed">-        let mut numer_of_optimizations = 0;</div><div class="diff-removed">-        loop {</div><div class="diff-removed">-            let suggested_to_optimize =</div><div class="diff-removed">-                index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            if suggested_to_optimize.is_empty() {</div><div class="diff-removed">-                break;</div><div class="diff-removed">-            }</div><div class="diff-removed">-            log::debug!("suggested_to_optimize = {suggested_to_optimize:#?}");</div><div class="diff-removed">-</div><div class="diff-removed">-            let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-            index_optimizer</div><div class="diff-removed">-                .optimize(</div><div class="diff-removed">-                    locked_holder.clone(),</div><div class="diff-removed">-                    suggested_to_optimize,</div><div class="diff-removed">-                    permit,</div><div class="diff-removed">-                    budget.clone(),</div><div class="diff-removed">-                    &stopped,</div><div class="diff-removed">-                )</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            numer_of_optimizations += 1;</div><div class="diff-removed">-            assert!(numer_of_optimizations <= number_of_segments);</div><div class="diff-removed">-            let number_of_segments = locked_holder.read().len();</div><div class="diff-removed">-            log::debug!(</div><div class="diff-removed">-                "numer_of_optimizations = {numer_of_optimizations}, number_of_segments = {number_of_segments}"</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure that the total number of segments did not change</div><div class="diff-removed">-        assert_eq!(locked_holder.read().len(), number_of_segments);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// This tests things are as we expect when we define both `on_disk: false` and `memmap_threshold`</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Before this PR (<https://github.com/qdrant/qdrant/pull/3167>) such configuration would create an infinite optimization loop.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It tests whether:</div><div class="diff-removed">-    /// - the on_disk flag is preferred over memmap_threshold</div><div class="diff-removed">-    /// - the index optimizer and config mismatch optimizer don't conflict with this preference</div><div class="diff-removed">-    /// - there is no infinite optiization loop with the above configuration</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// In short, this is what happens in this test:</div><div class="diff-removed">-    /// - create randomized segment as base with `on_disk: false` and `memmap_threshold`</div><div class="diff-removed">-    /// - test that indexing optimizer and config mismatch optimizer dont trigger</div><div class="diff-removed">-    /// - test that current storage is in memory</div><div class="diff-removed">-    /// - change `on_disk: None`</div><div class="diff-removed">-    /// - test that indexing optimizer now wants to optimize for `memmap_threshold`</div><div class="diff-removed">-    /// - optimize with indexing optimizer to put storage on disk</div><div class="diff-removed">-    /// - test that config mismatch optimizer doesn't try to revert on disk storage</div><div>     #[test]</div><div>     fn test_on_disk_memmap_threshold_conflict() {</div><div>         // Collection configuration</div><div class="diff-info">@@ -860,9 +712,8 @@ mod tests {</div><div>         let mut holder = SegmentHolder::default();</div><div> </div><div>         let segment = random_segment(dir.path(), 100, point_count, dim as usize);</div><div class="diff-removed">-</div><div>         let segment_id = holder.add_new(segment);</div><div class="diff-removed">-        let locked_holder: Arc<parking_lot::RwLock<_>> = Arc::new(RwLock::new(holder));</div><div class="diff-added">+        let locked_holder: Arc<RwLock<_>> = Arc::new(RwLock::new(holder));</div><div> </div><div>         let hnsw_config = HnswConfig {</div><div>             m: 16,</div><div class="diff-info">@@ -874,10 +725,9 @@ mod tests {</div><div>         };</div><div> </div><div>         {</div><div class="diff-removed">-            // Optimizers used in test</div><div>             let index_optimizer = IndexingOptimizer::new(</div><div>                 2,</div><div class="diff-removed">-                thresholds_config,</div><div class="diff-added">+                thresholds_config.clone(),</div><div>                 dir.path().to_owned(),</div><div>                 temp_dir.path().to_owned(),</div><div>                 collection_params.clone(),</div><div class="diff-info">@@ -885,7 +735,8 @@ mod tests {</div><div>                 Default::default(),</div><div>             );</div><div>             let config_mismatch_optimizer = ConfigMismatchOptimizer::new(</div><div class="diff-removed">-                thresholds_config,</div><div class="diff-added">+                2,</div><div class="diff-added">+                thresholds_config.clone(),</div><div>                 dir.path().to_owned(),</div><div>                 temp_dir.path().to_owned(),</div><div>                 collection_params.clone(),</div><div class="diff-info">@@ -893,44 +744,36 @@ mod tests {</div><div>                 Default::default(),</div><div>             );</div><div> </div><div class="diff-removed">-            // Index optimizer should not optimize and put storage back in memory, nothing changed</div><div>             let suggested_to_optimize =</div><div>                 index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                suggested_to_optimize.len(),</div><div class="diff-removed">-                0,</div><div class="diff-added">+            assert!(</div><div class="diff-added">+                suggested_to_optimize.is_empty(),</div><div>                 "index optimizer should not run for index nor mmap"</div><div>             );</div><div> </div><div class="diff-removed">-            // Config mismatch optimizer should not try to change the current state</div><div>             let suggested_to_optimize = config_mismatch_optimizer</div><div>                 .check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                suggested_to_optimize.len(),</div><div class="diff-removed">-                0,</div><div class="diff-added">+            assert!(</div><div class="diff-added">+                suggested_to_optimize.is_empty(),</div><div>                 "config mismatch optimizer should not change anything"</div><div>             );</div><div> </div><div class="diff-removed">-            // Ensure segment is not on disk</div><div>             locked_holder</div><div>                 .read()</div><div>                 .iter()</div><div>                 .map(|(_, segment)| match segment {</div><div>                     LockedSegment::Original(s) => s.read(),</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-added">+                    _ => panic!("Unexpected proxy segment"),</div><div>                 })</div><div>                 .filter(|segment| segment.total_point_count() > 0)</div><div>                 .for_each(|segment| {</div><div>                     assert!(</div><div class="diff-removed">-                        !segment.config().vector_data[DEFAULT_VECTOR_NAME]</div><div class="diff-removed">-                            .storage_type</div><div class="diff-removed">-                            .is_on_disk(),</div><div class="diff-added">+                        !segment.config().vector_data[""].storage_type.is_on_disk(),</div><div>                         "segment must not be on disk with mmap",</div><div>                     );</div><div>                 });</div><div>         }</div><div> </div><div class="diff-removed">-        // Remove explicit on_disk flag and go back to default</div><div>         collection_params</div><div>             .vectors</div><div>             .get_params_mut(DEFAULT_VECTOR_NAME)</div><div class="diff-info">@@ -938,10 +781,9 @@ mod tests {</div><div>             .on_disk</div><div>             .take();</div><div> </div><div class="diff-removed">-        // Optimizers used in test</div><div>         let index_optimizer = IndexingOptimizer::new(</div><div>             2,</div><div class="diff-removed">-            thresholds_config,</div><div class="diff-added">+            thresholds_config.clone(),</div><div>             dir.path().to_owned(),</div><div>             temp_dir.path().to_owned(),</div><div>             collection_params.clone(),</div><div class="diff-info">@@ -949,59 +791,138 @@ mod tests {</div><div>             Default::default(),</div><div>         );</div><div>         let config_mismatch_optimizer = ConfigMismatchOptimizer::new(</div><div class="diff-added">+            2,</div><div>             thresholds_config,</div><div>             dir.path().to_owned(),</div><div>             temp_dir.path().to_owned(),</div><div>             collection_params,</div><div class="diff-removed">-            hnsw_config,</div><div class="diff-added">+            hnsw_config.clone(),</div><div>             Default::default(),</div><div>         );</div><div> </div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Use indexing optimizer to build mmap</div><div class="diff-added">+        let budget = ResourceBudget::new(num_rayon_threads(0), num_rayon_threads(0));</div><div>         let changed = index_optimizer</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div>                 vec![segment_id],</div><div class="diff-removed">-                permit,</div><div class="diff-added">+                budget.clone().try_acquire(0, num_rayon_threads(0)).unwrap(),</div><div>                 budget.clone(),</div><div>                 &false.into(),</div><div>             )</div><div>             .unwrap();</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            changed > 0,</div><div class="diff-removed">-            "optimizer should have rebuilt this segment for mmap"</div><div class="diff-removed">-        );</div><div class="diff-added">+        assert!(changed > 0, "optimizer should have rebuilt this segment for mmap");</div><div>         assert!(</div><div>             locked_holder.read().get(segment_id).is_none(),</div><div>             "optimized segment should be gone",</div><div>         );</div><div>         assert_eq!(locked_holder.read().len(), 2, "mmap must be built");</div><div> </div><div class="diff-removed">-        // Mismatch optimizer should not optimize yet, HNSW config is not changed yet</div><div>         let suggested_to_optimize =</div><div>             config_mismatch_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-        assert_eq!(suggested_to_optimize.len(), 0);</div><div class="diff-added">+        assert!(suggested_to_optimize.is_empty());</div><div> </div><div class="diff-removed">-        // Ensure new segment is on disk now</div><div>         locked_holder</div><div>             .read()</div><div>             .iter()</div><div>             .map(|(_, segment)| match segment {</div><div>                 LockedSegment::Original(s) => s.read(),</div><div class="diff-removed">-                LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-added">+                _ => panic!("Unexpected proxy segment"),</div><div>             })</div><div>             .filter(|segment| segment.total_point_count() > 0)</div><div>             .for_each(|segment| {</div><div>                 assert!(</div><div class="diff-removed">-                    segment.config().vector_data[DEFAULT_VECTOR_NAME]</div><div class="diff-removed">-                        .storage_type</div><div class="diff-removed">-                        .is_on_disk(),</div><div class="diff-added">+                    segment.config().vector_data[""].storage_type.is_on_disk(),</div><div>                     "segment must be on disk with mmap",</div><div>                 );</div><div>             });</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn test_indexing_optimizer_with_number_of_segments() {</div><div class="diff-added">+        init();</div><div class="diff-added">+</div><div class="diff-added">+        let mut holder = SegmentHolder::default();</div><div class="diff-added">+        let stopped = AtomicBool::new(false);</div><div class="diff-added">+        let dim = 256;</div><div class="diff-added">+</div><div class="diff-added">+        let segments_dir = Builder::new().prefix("segments_dir").tempdir().unwrap();</div><div class="diff-added">+        let segments_temp_dir = Builder::new()</div><div class="diff-added">+            .prefix("segments_temp_dir")</div><div class="diff-added">+            .tempdir()</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+        let mut opnum = 101..1000000;</div><div class="diff-added">+</div><div class="diff-added">+        let segments = vec![</div><div class="diff-added">+            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-added">+            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-added">+            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-added">+            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-added">+        ];</div><div class="diff-added">+        let number_of_segments = segments.len();</div><div class="diff-added">+        let segment_config = segments[0].segment_config.clone();</div><div class="diff-added">+</div><div class="diff-added">+        let _segment_ids: Vec<SegmentId> = segments</div><div class="diff-added">+            .into_iter()</div><div class="diff-added">+            .map(|segment| holder.add_new(segment))</div><div class="diff-added">+            .collect();</div><div class="diff-added">+</div><div class="diff-added">+        let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div class="diff-added">+</div><div class="diff-added">+        let index_optimizer = IndexingOptimizer::new(</div><div class="diff-added">+            number_of_segments,</div><div class="diff-added">+            OptimizerThresholds {</div><div class="diff-added">+                max_segment_size_kb: 1000,</div><div class="diff-added">+                memmap_threshold_kb: 1000,</div><div class="diff-added">+                indexing_threshold_kb: 10,</div><div class="diff-added">+            },</div><div class="diff-added">+            segments_dir.path().to_owned(),</div><div class="diff-added">+            segments_temp_dir.path().to_owned(),</div><div class="diff-added">+            CollectionParams {</div><div class="diff-added">+                vectors: VectorsConfig::Single(</div><div class="diff-added">+                    VectorParamsBuilder::new(</div><div class="diff-added">+                        segment_config.vector_data[DEFAULT_VECTOR_NAME].size as u64,</div><div class="diff-added">+                        segment_config.vector_data[DEFAULT_VECTOR_NAME].distance,</div><div class="diff-added">+                    )</div><div class="diff-added">+                    .build(),</div><div class="diff-added">+                ),</div><div class="diff-added">+                ..CollectionParams::empty()</div><div class="diff-added">+            },</div><div class="diff-added">+            Default::default(),</div><div class="diff-added">+            Default::default(),</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-added">+        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-added">+</div><div class="diff-added">+        // Index until all segments are indexed</div><div class="diff-added">+        let mut numer_of_optimizations = 0;</div><div class="diff-added">+        loop {</div><div class="diff-added">+            let suggested_to_optimize =</div><div class="diff-added">+                index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-added">+            if suggested_to_optimize.is_empty() {</div><div class="diff-added">+                break;</div><div class="diff-added">+            }</div><div class="diff-added">+            log::debug!("suggested_to_optimize = {suggested_to_optimize:#?}");</div><div class="diff-added">+</div><div class="diff-added">+            index_optimizer</div><div class="diff-added">+                .optimize(</div><div class="diff-added">+                    locked_holder.clone(),</div><div class="diff-added">+                    suggested_to_optimize,</div><div class="diff-added">+                    budget.clone().try_acquire(0, permit_cpu_count).unwrap(),</div><div class="diff-added">+                    budget.clone(),</div><div class="diff-added">+                    &stopped,</div><div class="diff-added">+                )</div><div class="diff-added">+                .unwrap();</div><div class="diff-added">+            numer_of_optimizations += 1;</div><div class="diff-added">+            assert!(numer_of_optimizations <= number_of_segments);</div><div class="diff-added">+            let number_of_segments = locked_holder.read().len();</div><div class="diff-added">+            log::debug!(</div><div class="diff-added">+                "numer_of_optimizations = {numer_of_optimizations}, number_of_segments = {number_of_segments}"</div><div class="diff-added">+            );</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(locked_holder.read().len(), number_of_segments);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Additional snapshot and other tests would follow here...</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    