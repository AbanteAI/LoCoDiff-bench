<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs</h1>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">‚Üê Back to Sonnet 3.6 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56319</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 76314</p>
                <p><strong>Native Completion Tokens:</strong> 8193</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> length</p>
                <p><strong>Cost:</strong> $0.351837</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 1e234a3f..edd037df 100644</div><div class="diff-header">--- a/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_expectedoutput.txt (expected):tmp/tmp5usuth12_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_extracted.txt (actual):tmp/tmpx2zycwth_actual.txt	</div><div class="diff-info">@@ -4,7 +4,7 @@ use std::fs::remove_file;</div><div> use std::sync::atomic::AtomicBool;</div><div> </div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-use common::types::{PointOffsetType, TelemetryDetail};</div><div class="diff-added">+use common::types::{PointOffsetType, TelemetryDetail}; </div><div> use io::storage_version::VERSION_FILE;</div><div> use itertools::Itertools;</div><div> use rand::SeedableRng;</div><div class="diff-info">@@ -13,12 +13,11 @@ use segment::common::operation_error::OperationResult;</div><div> use segment::data_types::named_vectors::NamedVectors;</div><div> use segment::data_types::vectors::{QueryVector, VectorInternal};</div><div> use segment::entry::entry_point::SegmentEntry;</div><div class="diff-added">+use segment::fixture_for_all_indices;</div><div> use segment::fixtures::payload_fixtures::STR_KEY;</div><div> use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};</div><div> use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};</div><div class="diff-removed">-use segment::index::sparse_index::sparse_vector_index::{</div><div class="diff-removed">-    SparseVectorIndex, SparseVectorIndexOpenArgs,</div><div class="diff-removed">-};</div><div class="diff-added">+use segment::index::sparse_index::sparse_vector_index::{SparseVectorIndex, SparseVectorIndexOpenArgs};</div><div> use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};</div><div> use segment::json_path::JsonPath;</div><div> use segment::segment::Segment;</div><div class="diff-info">@@ -27,7 +26,7 @@ use segment::types::PayloadFieldSchema::FieldType;</div><div> use segment::types::PayloadSchemaType::Keyword;</div><div> use segment::types::{</div><div>     Condition, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD, FieldCondition, Filter, ScoredPoint,</div><div class="diff-removed">-    SegmentConfig, SeqNumberType, SparseVectorDataConfig, SparseVectorStorageType, VectorName,</div><div class="diff-added">+    SegmentConfig, SeqNumberType, SparseVectorDataConfig, SparseVectorStorageType, VectorName, </div><div>     VectorStorageDatatype,</div><div> };</div><div> use segment::vector_storage::VectorStorage;</div><div class="diff-info">@@ -42,7 +41,7 @@ use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div> use sparse::index::posting_list_common::PostingListIter as _;</div><div> use tempfile::Builder;</div><div> </div><div class="diff-removed">-/// Max dimension of sparse vectors used in tests</div><div class="diff-added">+/// Max dimension of sparse vectors used in tests </div><div> const MAX_SPARSE_DIM: usize = 4096;</div><div> </div><div> /// Number of vectors to index in tests</div><div class="diff-info">@@ -65,7 +64,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div> </div><div>     let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div>         &mut rnd,</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-added">+        NUM_VECTORS, </div><div>         MAX_SPARSE_DIM,</div><div>         full_scan_threshold,</div><div>         data_dir.path(),</div><div class="diff-info">@@ -87,24 +86,19 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div>     // expects the filter to have no effect on the results because the filter matches everything</div><div>     for query in query_vectors {</div><div>         let maximum_number_of_results = sparse_vector_index.max_result_count(&query);</div><div class="diff-removed">-        // get all results minus 10 to force a bit of pruning</div><div class="diff-added">+        // get all results minus 10 to force a bit of pruning </div><div>         let top = max(1, maximum_number_of_results.saturating_sub(10));</div><div>         let query_vector: QueryVector = query.clone().into();</div><div class="diff-added">+        </div><div>         // with filter</div><div>         let index_results_filter = sparse_vector_index</div><div class="diff-removed">-            .search(</div><div class="diff-removed">-                &[&query_vector],</div><div class="diff-removed">-                Some(&filter),</div><div class="diff-removed">-                top,</div><div class="diff-removed">-                None,</div><div class="diff-removed">-                &Default::default(),</div><div class="diff-removed">-            )</div><div class="diff-added">+            .search(&[&query_vector], Some(&filter), top, None, &Default::default())</div><div>             .unwrap();</div><div> </div><div>         // without filter</div><div>         let index_results_no_filter = sparse_vector_index</div><div>             .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-added">+            .unwrap();  </div><div> </div><div>         assert_eq!(index_results_filter.len(), index_results_no_filter.len());</div><div> </div><div class="diff-info">@@ -121,7 +115,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div>             for (filter_result, no_filter_result) in filter_result</div><div>                 .iter()</div><div>                 .filter(|s| s.score != 0.0)</div><div class="diff-removed">-                .zip(no_filter_result.iter().filter(|s| s.score != 0.0))</div><div class="diff-added">+                .zip(no_filter_result.iter().filter(|s| s.score != 0.0))  </div><div>             {</div><div>                 if filter_result.idx != no_filter_result.idx {</div><div>                     // we do not break ties when identical scores</div><div class="diff-info">@@ -143,7 +137,7 @@ fn sparse_vector_index_ram_filter_search() {</div><div> #[test]</div><div> fn sparse_vector_index_fallback_plain_search() {</div><div>     // very high full scan threshold to force fallback to plain search</div><div class="diff-removed">-    compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);</div><div class="diff-added">+    compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);  </div><div> }</div><div> </div><div> /// Checks that the sparse vector index is consistent with the underlying storage</div><div class="diff-info">@@ -156,7 +150,7 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars</div><div>         // assuming no deleted points</div><div>         let vector = borrowed_vector_storage.get_vector(id);</div><div>         let vector: &SparseVector = vector.as_vec_ref().try_into().unwrap();</div><div class="diff-removed">-        let remapped_vector = sparse_vector_index</div><div class="diff-added">+        let remapped_vector = sparse_vector_index  </div><div>             .indices_tracker()</div><div>             .remap_vector(vector.to_owned());</div><div>         // check posting lists are consistent with storage</div><div class="diff-info">@@ -213,7 +207,7 @@ fn sparse_vector_index_consistent_with_storage() {</div><div> </div><div>     let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();</div><div> </div><div class="diff-removed">-    // create mmap sparse vector index</div><div class="diff-added">+    // create mmap sparse vector index </div><div>     let mut sparse_index_config = sparse_vector_ram_index.config();</div><div>     sparse_index_config.index_type = SparseIndexType::Mmap;</div><div>     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =</div><div class="diff-info">@@ -244,7 +238,7 @@ fn sparse_vector_index_consistent_with_storage() {</div><div>     sparse_index_config.index_type = SparseIndexType::Mmap;</div><div>     let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =</div><div>         SparseVectorIndex::open(SparseVectorIndexOpenArgs {</div><div class="diff-removed">-            config: sparse_index_config,</div><div class="diff-added">+            config: sparse_index_config, </div><div>             id_tracker: sparse_vector_ram_index.id_tracker().clone(),</div><div>             vector_storage: sparse_vector_ram_index.vector_storage().clone(),</div><div>             payload_index: sparse_vector_ram_index.payload_index().clone(),</div><div class="diff-info">@@ -271,7 +265,7 @@ fn sparse_vector_index_load_missing_mmap() {</div><div>             data_dir.path(),</div><div>             [].iter().cloned(),</div><div>             10_000,</div><div class="diff-removed">-            SparseIndexType::Mmap,</div><div class="diff-added">+            SparseIndexType::Mmap, </div><div>         );</div><div>     // absent configuration file for mmap are ignored</div><div>     // a new index is created</div><div class="diff-info">@@ -293,10 +287,10 @@ fn sparse_vector_index_ram_deleted_points_search() {</div><div>     )</div><div>     .unwrap();</div><div> </div><div class="diff-removed">-    // sanity check (all indexed, no deleted points)</div><div class="diff-added">+    // sanity check (all indexed, no deleted points) </div><div>     assert_eq!(</div><div>         sparse_vector_index</div><div class="diff-removed">-            .id_tracker()</div><div class="diff-added">+            .id_tracker() </div><div>             .borrow()</div><div>             .available_point_count(),</div><div>         sparse_vector_index.indexed_vector_count()</div><div class="diff-info">@@ -304,7 +298,7 @@ fn sparse_vector_index_ram_deleted_points_search() {</div><div>     assert_eq!(</div><div>         sparse_vector_index</div><div>             .id_tracker()</div><div class="diff-removed">-            .borrow()</div><div class="diff-added">+            .borrow() </div><div>             .deleted_point_count(),</div><div>         0</div><div>     );</div><div class="diff-info">@@ -440,7 +434,7 @@ fn sparse_vector_index_ram_filtered_search() {</div><div>             &[&query_vector],</div><div>             Some(&filter),</div><div>             half_indexed_count * 2, // original top</div><div class="diff-removed">-            None,</div><div class="diff-added">+            None, </div><div>             &Default::default(),</div><div>         )</div><div>         .unwrap();</div><div class="diff-info">@@ -453,7 +447,7 @@ fn sparse_vector_index_plain_search() {</div><div>     let mut rnd = StdRng::seed_from_u64(42);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    // setup index</div><div class="diff-added">+    // setup index </div><div>     let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div>         &mut rnd,</div><div>         NUM_VECTORS,</div><div class="diff-info">@@ -571,7 +565,7 @@ fn handling_empty_sparse_vectors() {</div><div>     assert_eq!(results[0].len(), 0);</div><div> }</div><div> </div><div class="diff-removed">-#[test]</div><div class="diff-added">+#[test]  </div><div> fn sparse_vector_index_persistence_test() {</div><div>     let stopped = AtomicBool::new(false);</div><div> </div><div class="diff-info">@@ -617,7 +611,7 @@ fn sparse_vector_index_persistence_test() {</div><div> </div><div>     let search_result = segment</div><div>         .search(</div><div class="diff-removed">-            SPARSE_VECTOR_NAME,</div><div class="diff-added">+            SPARSE_VECTOR_NAME, </div><div>             &query_vector,</div><div>             &Default::default(),</div><div>             &Default::default(),</div><div class="diff-info">@@ -650,12 +644,13 @@ fn sparse_vector_index_persistence_test() {</div><div>     assert_eq!(search_after_reload_result.len(), top);</div><div>     assert_eq!(search_result, search_after_reload_result);</div><div> </div><div class="diff-removed">-    fixture_for_all_indices!(check_persistence::<_>(</div><div class="diff-added">+    check_persistence::<InvertedIndexCompressedImmutableRam<f32>>(</div><div>         &segment,</div><div>         &search_result,</div><div>         &query_vector,</div><div class="diff-removed">-        top</div><div class="diff-removed">-    ));</div><div class="diff-added">+        top,</div><div class="diff-added">+    );</div><div class="diff-added">+    check_persistence::<InvertedIndexCompressedMmap<f32>>(&segment, &search_result, &query_vector, top);</div><div> }</div><div> </div><div> fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div class="diff-info">@@ -692,7 +687,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div> </div><div>     let check_search = |sparse_vector_index: &SparseVectorIndex<TInvertedIndex>| {</div><div>         // check that the loaded index performs the same search</div><div class="diff-removed">-        let search_after_reload_result = sparse_vector_index</div><div class="diff-added">+        let search_after_reload_result = sparse_vector_index  </div><div>             .search(&[query_vector], None, top, None, &Default::default())</div><div>             .unwrap();</div><div>         assert_eq!(search_after_reload_result[0].len(), top);</div><div class="diff-info">@@ -703,7 +698,7 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div>             let id_1 = segment</div><div>                 .id_tracker</div><div>                 .borrow_mut()</div><div class="diff-removed">-                .internal_id(search_1.id)</div><div class="diff-added">+                .internal_id(search_1.id)  </div><div>                 .unwrap();</div><div>             assert_eq!(id_1, search_2.idx);</div><div>         }</div><div class="diff-info">@@ -737,7 +732,7 @@ fn check_sparse_vector_index_files<I: InvertedIndex>() {</div><div>     let index = fixture_sparse_index::<I, _>(</div><div>         &mut StdRng::seed_from_u64(42),</div><div>         1,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-added">+        MAX_SPARSE_DIM, </div><div>         LOW_FULL_SCAN_THRESHOLD,</div><div>         data_dir.path(),</div><div>     );</div><div class="diff-info">@@ -768,35 +763,4 @@ fn sparse_vector_test_large_index() {</div><div>         )]),</div><div>         payload_storage_type: Default::default(),</div><div>     };</div><div class="diff-removed">-    let mut segment = build_segment(dir.path(), &config, true).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-    let vector: VectorInternal = SparseVector {</div><div class="diff-removed">-        indices: vec![DimId::MAX],</div><div class="diff-removed">-        values: vec![0.0],</div><div class="diff-removed">-    }</div><div class="diff-removed">-    .into();</div><div class="diff-removed">-    let mut named_vector = NamedVectors::default();</div><div class="diff-removed">-    named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);</div><div class="diff-removed">-    let idx = 0.into();</div><div class="diff-removed">-    segment</div><div class="diff-removed">-        .upsert_point(0 as SeqNumberType, idx, named_vector, &hw_counter)</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let borrowed_vector_index = segment.vector_data[SPARSE_VECTOR_NAME]</div><div class="diff-removed">-        .vector_index</div><div class="diff-removed">-        .borrow();</div><div class="diff-removed">-    match &*borrowed_vector_index {</div><div class="diff-removed">-        VectorIndexEnum::SparseRam(sparse_vector_index) => {</div><div class="diff-removed">-            assert!(</div><div class="diff-removed">-                sparse_vector_index</div><div class="diff-removed">-                    .indices_tracker()</div><div class="diff-removed">-                    .remap_index(DimId::MAX)</div><div class="diff-removed">-                    .is_some(),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            assert_eq!(sparse_vector_index.inverted_index().max_index().unwrap(), 0);</div><div class="diff-removed">-        }</div><div class="diff-removed">-        _ => panic!("unexpected vector index type"),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+    let mut segment = build_segment(dir.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    