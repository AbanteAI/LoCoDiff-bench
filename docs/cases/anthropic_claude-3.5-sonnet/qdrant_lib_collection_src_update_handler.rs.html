<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">‚Üê Back to Sonnet 3.6 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 82736</p>
                <p><strong>Native Completion Tokens:</strong> 7616</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.362448</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -35,12 +35,12 @@ use crate::operations::types::{CollectionError, CollectionResult};</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::local_shard::LocalShardClocks;</div><div class="diff-removed">-use crate::wal::WalError;</div><div class="diff-added">+use crate::wal::WalError; </div><div> use crate::wal_delta::LockedWal;</div><div> </div><div> /// Interval at which the optimizer worker cleans up old optimization handles</div><div> ///</div><div class="diff-removed">-/// The longer the duration, the longer it  takes for panicked tasks to be reported.</div><div class="diff-added">+/// The longer the duration, the longer it takes for panicked tasks to be reported.</div><div> const OPTIMIZER_CLEANUP_INTERVAL: Duration = Duration::from_secs(5);</div><div> </div><div> pub type Optimizer = dyn SegmentOptimizer + Sync + Send;</div><div class="diff-info">@@ -48,7 +48,7 @@ /// Information, required to perform operation and notify regarding the result</div><div> #[derive(Debug)]</div><div> pub struct OperationData {</div><div class="diff-removed">-    /// Sequential number of the operation</div><div class="diff-added">+    /// Sequential number of the operation  </div><div>     pub op_num: SeqNumberType,</div><div>     /// Operation</div><div>     pub operation: CollectionUpdateOperations,</div><div class="diff-info">@@ -60,11 +60,11 @@ }</div><div> </div><div> /// Signal, used to inform Updater process</div><div class="diff-removed">-#[derive(Debug)]</div><div class="diff-added">+#[derive(Debug)] </div><div> pub enum UpdateSignal {</div><div>     /// Requested operation to perform</div><div>     Operation(OperationData),</div><div class="diff-removed">-    /// Stop all optimizers and listening</div><div class="diff-added">+    /// Stop all optimizers and listening  </div><div>     Stop,</div><div>     /// Empty signal used to trigger optimizers</div><div>     Nop,</div><div class="diff-info">@@ -80,7 +80,7 @@     /// Stop all optimizers and listening</div><div>     Stop,</div><div>     /// Empty signal used to trigger optimizers</div><div class="diff-removed">-    Nop,</div><div class="diff-added">+    Nop, </div><div> }</div><div> </div><div> /// Structure, which holds object, required for processing updates of the collection</div><div class="diff-info">@@ -100,7 +100,7 @@     /// This parameter depends on the optimizer config and should be updated accordingly.</div><div>     pub flush_interval_sec: u64,</div><div>     segments: LockedSegmentHolder,</div><div class="diff-removed">-    /// Process, that listens updates signals and perform updates</div><div class="diff-added">+    /// Process, that listens updates signals and perform updates </div><div>     update_worker: Option<JoinHandle<()>>,</div><div>     /// Process, that listens for post-update signals and performs optimization</div><div>     optimizer_worker: Option<JoinHandle<()>>,</div><div class="diff-info">@@ -162,14 +162,14 @@             flush_interval_sec,</div><div>             optimization_handles: Arc::new(TokioMutex::new(vec![])),</div><div>             max_optimization_threads,</div><div class="diff-removed">-            clocks,</div><div class="diff-added">+            clocks, </div><div>             shard_path,</div><div>             has_triggered_optimizers: Default::default(),</div><div>         }</div><div>     }</div><div> </div><div>     pub fn run_workers(&mut self, update_receiver: Receiver<UpdateSignal>) {</div><div class="diff-removed">-        let (tx, rx) = mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-added">+        let (tx, rx) = mpsc::channel(UPDATE_QUEUE_SIZE);</div><div>         self.optimizer_worker = Some(self.runtime_handle.spawn(Self::optimization_worker_fn(</div><div>             self.optimizers.clone(),</div><div>             tx.clone(),</div><div class="diff-info">@@ -178,7 +178,7 @@             self.wal.clone(),</div><div>             self.optimization_handles.clone(),</div><div>             self.optimizers_log.clone(),</div><div class="diff-removed">-            self.total_optimized_points.clone(),</div><div class="diff-added">+            self.total_optimized_points.clone(), </div><div>             self.optimizer_resource_budget.clone(),</div><div>             self.max_optimization_threads,</div><div>             self.has_triggered_optimizers.clone(),</div><div class="diff-info">@@ -211,7 +211,7 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Gracefully wait before all optimizations stop</div><div class="diff-added">+    /// Gracefully wait before all optimizations stop </div><div>     /// If some optimization is in progress - it will be finished before shutdown.</div><div>     pub async fn wait_workers_stops(&mut self) -> CollectionResult<()> {</div><div>         let maybe_handle = self.update_worker.take();</div><div class="diff-info">@@ -242,7 +242,7 @@     }</div><div> </div><div>     /// Checks if there are any failed operations.</div><div class="diff-removed">-    /// If so - attempts to re-apply all failed operations.</div><div class="diff-added">+    /// If so - attempts to re-apply all failed operations. </div><div>     async fn try_recover(segments: LockedSegmentHolder, wal: LockedWal) -> CollectionResult<usize> {</div><div>         // Try to re-apply everything starting from the first failed operation</div><div>         let first_failed_operation_option = segments.read().failed_operation.iter().cloned().min();</div><div class="diff-info">@@ -261,156 +261,6 @@             }</div><div>         };</div><div>         Ok(0)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Checks conditions for all optimizers until there is no suggested segment</div><div class="diff-removed">-    /// Starts a task for each optimization</div><div class="diff-removed">-    /// Returns handles for started tasks</div><div class="diff-removed">-    pub(crate) fn launch_optimization<F>(</div><div class="diff-removed">-        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-removed">-        total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: &ResourceBudget,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        callback: F,</div><div class="diff-removed">-        limit: Option<usize>,</div><div class="diff-removed">-    ) -> Vec<StoppableTaskHandle<bool>></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: Fn(bool) + Send + Clone + Sync + 'static,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        let mut scheduled_segment_ids = HashSet::<_>::default();</div><div class="diff-removed">-        let mut handles = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        'outer: for optimizer in optimizers.iter() {</div><div class="diff-removed">-            loop {</div><div class="diff-removed">-                // Return early if we reached the optimization job limit</div><div class="diff-removed">-                if limit.map(|extra| handles.len() >= extra).unwrap_or(false) {</div><div class="diff-removed">-                    log::trace!("Reached optimization job limit, postponing other optimizations");</div><div class="diff-removed">-                    break 'outer;</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                let nonoptimal_segment_ids =</div><div class="diff-removed">-                    optimizer.check_condition(segments.clone(), &scheduled_segment_ids);</div><div class="diff-removed">-                if nonoptimal_segment_ids.is_empty() {</div><div class="diff-removed">-                    break;</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                debug!("Optimizing segments: {:?}", &nonoptimal_segment_ids);</div><div class="diff-removed">-</div><div class="diff-removed">-                // Determine how many Resources we prefer for optimization task, acquire permit for it</div><div class="diff-removed">-                // And use same amount of IO threads as CPUs</div><div class="diff-removed">-                let max_indexing_threads = optimizer.hnsw_config().max_indexing_threads;</div><div class="diff-removed">-                let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-removed">-                let Some(mut permit) = optimizer_resource_budget.try_acquire(0, desired_io) else {</div><div class="diff-removed">-                    // If there is no Resource budget, break outer loop and return early</div><div class="diff-removed">-                    // If we have no handles (no optimizations) trigger callback so that we wake up</div><div class="diff-removed">-                    // our optimization worker to try again later, otherwise it could get stuck</div><div class="diff-removed">-                    log::trace!(</div><div class="diff-removed">-                        "No available IO permit for {} optimizer, postponing",</div><div class="diff-removed">-                        optimizer.name(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    if handles.is_empty() {</div><div class="diff-removed">-                        callback(false);</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    break 'outer;</div><div class="diff-removed">-                };</div><div class="diff-removed">-                log::trace!(</div><div class="diff-removed">-                    "Acquired {} IO permit for {} optimizer",</div><div class="diff-removed">-                    permit.num_io,</div><div class="diff-removed">-                    optimizer.name(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-</div><div class="diff-removed">-                let permit_callback = callback.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-                permit.set_on_release(move || {</div><div class="diff-removed">-                    // Notify scheduler that resource budget changed</div><div class="diff-removed">-                    permit_callback(false);</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-                let optimizer = optimizer.clone();</div><div class="diff-removed">-                let optimizers_log = optimizers_log.clone();</div><div class="diff-removed">-                let total_optimized_points = total_optimized_points.clone();</div><div class="diff-removed">-                let segments = segments.clone();</div><div class="diff-removed">-                let nsi = nonoptimal_segment_ids.clone();</div><div class="diff-removed">-                scheduled_segment_ids.extend(&nsi);</div><div class="diff-removed">-                let callback = callback.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-                let handle = spawn_stoppable(</div><div class="diff-removed">-                    // Stoppable task</div><div class="diff-removed">-                    {</div><div class="diff-removed">-                        let resource_budget = optimizer_resource_budget.clone();</div><div class="diff-removed">-                        let segments = segments.clone();</div><div class="diff-removed">-                        move |stopped| {</div><div class="diff-removed">-                            // Track optimizer status</div><div class="diff-removed">-                            let tracker = Tracker::start(optimizer.as_ref().name(), nsi.clone());</div><div class="diff-removed">-                            let tracker_handle = tracker.handle();</div><div class="diff-removed">-                            optimizers_log.lock().register(tracker);</div><div class="diff-removed">-</div><div class="diff-removed">-                            // Optimize and handle result</div><div class="diff-removed">-                            match optimizer.as_ref().optimize(</div><div class="diff-removed">-                                segments.clone(),</div><div class="diff-removed">-                                nsi,</div><div class="diff-removed">-                                permit,</div><div class="diff-removed">-                                resource_budget,</div><div class="diff-removed">-                                stopped,</div><div class="diff-removed">-                            ) {</div><div class="diff-removed">-                                // Perform some actions when optimization if finished</div><div class="diff-removed">-                                Ok(optimized_points) => {</div><div class="diff-removed">-                                    let is_optimized = optimized_points > 0;</div><div class="diff-removed">-                                    total_optimized_points</div><div class="diff-removed">-                                        .fetch_add(optimized_points, Ordering::Relaxed);</div><div class="diff-removed">-                                    tracker_handle.update(TrackerStatus::Done);</div><div class="diff-removed">-                                    callback(is_optimized);</div><div class="diff-removed">-                                    is_optimized</div><div class="diff-removed">-                                }</div><div class="diff-removed">-                                // Handle and report errors</div><div class="diff-removed">-                                Err(error) => match error {</div><div class="diff-removed">-                                    CollectionError::Cancelled { description } => {</div><div class="diff-removed">-                                        debug!("Optimization cancelled - {description}");</div><div class="diff-removed">-                                        tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Cancelled(description));</div><div class="diff-removed">-                                        false</div><div class="diff-removed">-                                    }</div><div class="diff-removed">-                                    _ => {</div><div class="diff-removed">-                                        segments.write().report_optimizer_error(error.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-                                        // Error of the optimization can not be handled by API user</div><div class="diff-removed">-                                        // It is only possible to fix after full restart,</div><div class="diff-removed">-                                        // so the best available action here is to stop whole</div><div class="diff-removed">-                                        // optimization thread and log the error</div><div class="diff-removed">-                                        log::error!("Optimization error: {error}");</div><div class="diff-removed">-</div><div class="diff-removed">-                                        tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Error(error.to_string()));</div><div class="diff-removed">-</div><div class="diff-removed">-                                        panic!("Optimization error: {error}");</div><div class="diff-removed">-                                    }</div><div class="diff-removed">-                                },</div><div class="diff-removed">-                            }</div><div class="diff-removed">-                        }</div><div class="diff-removed">-                    },</div><div class="diff-removed">-                    // Panic handler</div><div class="diff-removed">-                    Some(Box::new(move |panic_payload| {</div><div class="diff-removed">-                        let message = panic::downcast_str(&panic_payload).unwrap_or("");</div><div class="diff-removed">-                        let separator = if !message.is_empty() { ": " } else { "" };</div><div class="diff-removed">-</div><div class="diff-removed">-                        warn!(</div><div class="diff-removed">-                            "Optimization task panicked, collection may be in unstable state\</div><div class="diff-removed">-                             {separator}{message}"</div><div class="diff-removed">-                        );</div><div class="diff-removed">-</div><div class="diff-removed">-                        segments</div><div class="diff-removed">-                            .write()</div><div class="diff-removed">-                            .report_optimizer_error(CollectionError::service_error(format!(</div><div class="diff-removed">-                                "Optimization task panicked{separator}{message}"</div><div class="diff-removed">-                            )));</div><div class="diff-removed">-                    })),</div><div class="diff-removed">-                );</div><div class="diff-removed">-                handles.push(handle);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        handles</div><div>     }</div><div> </div><div>     /// Ensure there is at least one appendable segment with enough capacity</div><div class="diff-info">@@ -462,7 +312,7 @@     ///</div><div>     /// This function returns a tuple of two booleans:</div><div>     /// - The first indicates if any optimizers have been triggered since startup.</div><div class="diff-removed">-    /// - The second indicates if there are any pending/suboptimal optimizers.</div><div class="diff-added">+    /// - The second indicates if there are any pending/suboptimal optimizers. </div><div>     pub(crate) fn check_optimizer_conditions(&self) -> (bool, bool) {</div><div>         // Check if Qdrant triggered any optimizations since starting at all</div><div>         let has_triggered_any_optimizers = self.has_triggered_optimizers.load(Ordering::Relaxed);</div><div class="diff-info">@@ -537,7 +387,7 @@             handle.join_and_handle_panic().await;</div><div>         }</div><div> </div><div class="diff-removed">-        finished_any</div><div class="diff-added">+        finished_any </div><div>     }</div><div> </div><div>     #[allow(clippy::too_many_arguments)]</div><div class="diff-info">@@ -567,18 +417,18 @@         loop {</div><div>             let result = timeout(OPTIMIZER_CLEANUP_INTERVAL, receiver.recv()).await;</div><div> </div><div class="diff-removed">-            let cleaned_any =</div><div class="diff-added">+            let cleaned_any = </div><div>                 Self::cleanup_optimization_handles(optimization_handles.clone()).await;</div><div> </div><div>             // Either continue below here with the worker, or reloop/break</div><div>             // Decision logic doing one of three things:</div><div>             // 1. run optimizers</div><div class="diff-removed">-            // 2. reloop and wait for next signal</div><div class="diff-added">+            // 2. reloop and wait for next signal  </div><div>             // 3. break here and stop the optimization worker</div><div>             let ignore_max_handles = match result {</div><div>                 // Regular optimizer signal: run optimizers: do 1</div><div>                 Ok(Some(OptimizerSignal::Operation(_))) => false,</div><div class="diff-removed">-                // Optimizer signal ignoring max handles: do 1</div><div class="diff-added">+                // Optimizer signal ignoring max handles: do 1  </div><div>                 Ok(Some(OptimizerSignal::Nop)) => true,</div><div>                 // Hit optimizer cleanup interval, did clean up a task: do 1</div><div>                 Err(Elapsed { .. }) if cleaned_any => {</div><div class="diff-info">@@ -634,7 +484,7 @@             // Continue if we have enough resource budget available to start an optimization</div><div>             // Otherwise skip now and start a task to trigger the optimizer again once resource</div><div>             // budget becomes available</div><div class="diff-removed">-            let desired_cpus = 0;</div><div class="diff-added">+            let desired_cpus = 0; </div><div>             let desired_io = num_rayon_threads(max_indexing_threads);</div><div>             if !optimizer_resource_budget.has_budget(desired_cpus, desired_io) {</div><div>                 let trigger_active = resource_available_trigger</div><div class="diff-info">@@ -651,7 +501,7 @@                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Determine optimization handle limit based on max handles we allow</div><div class="diff-added">+            // Determine optimization handle limit based on max handles we allow </div><div>             // Not related to the CPU budget, but a different limit for the maximum number</div><div>             // of concurrent concrete optimizations per shard as configured by the user in</div><div>             // the Qdrant configuration.</div><div class="diff-info">@@ -678,7 +528,7 @@ </div><div>     async fn update_worker_fn(</div><div>         mut receiver: Receiver<UpdateSignal>,</div><div class="diff-removed">-        optimize_sender: Sender<OptimizerSignal>,</div><div class="diff-added">+        optimize_sender: Sender<OptimizerSignal>, </div><div>         wal: LockedWal,</div><div>         segments: LockedSegmentHolder,</div><div>     ) {</div><div class="diff-info">@@ -824,7 +674,7 @@     }</div><div> </div><div>     /// Returns confirmed version after flush of all segments</div><div class="diff-removed">-    ///</div><div class="diff-added">+    /// </div><div>     /// # Errors</div><div>     /// Returns an error on flush failure</div><div>     fn flush_segments(segments: LockedSegmentHolder) -> OperationResult<SeqNumberType> {</div><div class="diff-info">@@ -840,7 +690,7 @@ /// Trigger optimizers when CPU budget is available</div><div> fn trigger_optimizers_on_resource_budget(</div><div>     optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    desired_cpus: usize,</div><div class="diff-added">+    desired_cpus: usize, </div><div>     desired_io: usize,</div><div>     sender: Sender<OptimizerSignal>,</div><div> ) -> JoinHandle<()> {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    