<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">‚Üê Back to Sonnet 3.6 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 77090</p>
                <p><strong>Native Completion Tokens:</strong> 1575</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.254895</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b..6626968e 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmpwigpe2gk_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmpcp904cgg_actual.txt	</div><div class="diff-info">@@ -97,796 +97,7 @@ pub type RequestShardTransfer = Arc<dyn Fn(ShardTransfer) + Send + Sync>;</div><div> pub type OnTransferFailure = Arc<dyn Fn(ShardTransfer, CollectionId, &str) + Send + Sync>;</div><div> pub type OnTransferSuccess = Arc<dyn Fn(ShardTransfer, CollectionId) + Send + Sync>;</div><div> </div><div class="diff-removed">-impl Collection {</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn new(</div><div class="diff-removed">-        name: CollectionId,</div><div class="diff-removed">-        this_peer_id: PeerId,</div><div class="diff-removed">-        path: &Path,</div><div class="diff-removed">-        snapshots_path: &Path,</div><div class="diff-removed">-        collection_config: &CollectionConfigInternal,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        shard_distribution: CollectionShardDistribution,</div><div class="diff-removed">-        shard_key_mapping: Option<ShardKeyMapping>,</div><div class="diff-removed">-        channel_service: ChannelService,</div><div class="diff-removed">-        on_replica_failure: ChangePeerFromState,</div><div class="diff-removed">-        request_shard_transfer: RequestShardTransfer,</div><div class="diff-removed">-        abort_shard_transfer: replica_set::AbortShardTransfer,</div><div class="diff-removed">-        search_runtime: Option<Handle>,</div><div class="diff-removed">-        update_runtime: Option<Handle>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        optimizers_overwrite: Option<OptimizersConfigDiff>,</div><div class="diff-removed">-    ) -> Result<Self, CollectionError> {</div><div class="diff-removed">-        let start_time = std::time::Instant::now();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut shard_holder = ShardHolder::new(path)?;</div><div class="diff-removed">-        shard_holder.set_shard_key_mappings(shard_key_mapping.clone().unwrap_or_default())?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let payload_index_schema = Arc::new(Self::load_payload_index_schema(path)?);</div><div class="diff-removed">-</div><div class="diff-removed">-        let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div class="diff-removed">-        for (shard_id, mut peers) in shard_distribution.shards {</div><div class="diff-removed">-            let is_local = peers.remove(&this_peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-removed">-            if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-                effective_optimizers_config =</div><div class="diff-removed">-                    optimizers_overwrite.update(&effective_optimizers_config)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            let shard_key = shard_key_mapping</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .and_then(|mapping| mapping.shard_key(shard_id));</div><div class="diff-removed">-            let replica_set = ShardReplicaSet::build(</div><div class="diff-removed">-                shard_id,</div><div class="diff-removed">-                shard_key.clone(),</div><div class="diff-removed">-                name.clone(),</div><div class="diff-removed">-                this_peer_id,</div><div class="diff-removed">-                is_local,</div><div class="diff-removed">-                peers,</div><div class="diff-removed">-                on_replica_failure.clone(),</div><div class="diff-removed">-                abort_shard_transfer.clone(),</div><div class="diff-removed">-                path,</div><div class="diff-removed">-                shared_collection_config.clone(),</div><div class="diff-removed">-                effective_optimizers_config,</div><div class="diff-removed">-                shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div class="diff-removed">-                channel_service.clone(),</div><div class="diff-removed">-                update_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                search_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                optimizer_resource_budget.clone(),</div><div class="diff-removed">-                None,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await?;</div><div class="diff-removed">-</div><div class="diff-removed">-            shard_holder.add_shard(shard_id, replica_set, shard_key)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let locked_shard_holder = Arc::new(LockedShardHolder::new(shard_holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection_stats_cache = CollectionSizeStatsCache::new_with_values(</div><div class="diff-removed">-            Self::estimate_collection_size_stats(&locked_shard_holder).await,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        // Once the config is persisted - the collection is considered to be successfully created.</div><div class="diff-removed">-        CollectionVersion::save(path)?;</div><div class="diff-removed">-        collection_config.save(path)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(Self {</div><div class="diff-removed">-            id: name.clone(),</div><div class="diff-removed">-            shards_holder: locked_shard_holder,</div><div class="diff-removed">-            collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            this_peer_id,</div><div class="diff-removed">-            path: path.to_owned(),</div><div class="diff-removed">-            snapshots_path: snapshots_path.to_owned(),</div><div class="diff-removed">-            channel_service,</div><div class="diff-removed">-            transfer_tasks: Mutex::new(TransferTasksPool::new(name.clone())),</div><div class="diff-removed">-            request_shard_transfer_cb: request_shard_transfer.clone(),</div><div class="diff-removed">-            notify_peer_failure_cb: on_replica_failure.clone(),</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-removed">-            init_time: start_time.elapsed(),</div><div class="diff-removed">-            is_initialized: Default::default(),</div><div class="diff-removed">-            updates_lock: Default::default(),</div><div class="diff-removed">-            update_runtime: update_runtime.unwrap_or_else(Handle::current),</div><div class="diff-removed">-            search_runtime: search_runtime.unwrap_or_else(Handle::current),</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            collection_stats_cache,</div><div class="diff-removed">-            shard_clean_tasks: Default::default(),</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn load(</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        this_peer_id: PeerId,</div><div class="diff-removed">-        path: &Path,</div><div class="diff-removed">-        snapshots_path: &Path,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        channel_service: ChannelService,</div><div class="diff-removed">-        on_replica_failure: replica_set::ChangePeerFromState,</div><div class="diff-removed">-        request_shard_transfer: RequestShardTransfer,</div><div class="diff-removed">-        abort_shard_transfer: replica_set::AbortShardTransfer,</div><div class="diff-removed">-        search_runtime: Option<Handle>,</div><div class="diff-removed">-        update_runtime: Option<Handle>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        optimizers_overwrite: Option<OptimizersConfigDiff>,</div><div class="diff-removed">-    ) -> Self {</div><div class="diff-removed">-        let start_time = std::time::Instant::now();</div><div class="diff-removed">-        let stored_version = CollectionVersion::load(path)</div><div class="diff-removed">-            .expect("Can't read collection version")</div><div class="diff-removed">-            .expect("Collection version is not found");</div><div class="diff-removed">-</div><div class="diff-removed">-        let app_version = CollectionVersion::current();</div><div class="diff-removed">-</div><div class="diff-removed">-        if stored_version > app_version {</div><div class="diff-removed">-            panic!("Collection version is greater than application version");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if stored_version != app_version {</div><div class="diff-removed">-            if Self::can_upgrade_storage(&stored_version, &app_version) {</div><div class="diff-removed">-                log::info!("Migrating collection {stored_version} -> {app_version}");</div><div class="diff-removed">-                CollectionVersion::save(path)</div><div class="diff-removed">-                    .unwrap_or_else(|err| panic!("Can't save collection version {err}"));</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                log::error!("Cannot upgrade version {stored_version} to {app_version}.");</div><div class="diff-removed">-                panic!(</div><div class="diff-removed">-                    "Cannot upgrade version {stored_version} to {app_version}. Try to use older version of Qdrant first.",</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection_config = CollectionConfigInternal::load(path).unwrap_or_else(|err| {</div><div class="diff-removed">-            panic!(</div><div class="diff-removed">-                "Can't read collection config due to {}\nat {}",</div><div class="diff-removed">-                err,</div><div class="diff-removed">-                path.to_str().unwrap(),</div><div class="diff-removed">-            )</div><div class="diff-removed">-        });</div><div class="diff-removed">-        collection_config.validate_and_warn();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-            effective_optimizers_config = optimizers_overwrite</div><div class="diff-removed">-                .update(&effective_optimizers_config)</div><div class="diff-removed">-                .expect("Can not apply optimizer overwrite");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div class="diff-removed">-</div><div class="diff-removed">-        let payload_index_schema = Arc::new(</div><div class="diff-removed">-            Self::load_payload_index_schema(path)</div><div class="diff-removed">-                .expect("Can't load or initialize payload index schema"),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        shard_holder</div><div class="diff-removed">-            .load_shards(</div><div class="diff-removed">-                path,</div><div class="diff-removed">-                &collection_id,</div><div class="diff-removed">-                shared_collection_config.clone(),</div><div class="diff-removed">-                effective_optimizers_config,</div><div class="diff-removed">-                shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div class="diff-removed">-                channel_service.clone(),</div><div class="diff-removed">-                on_replica_failure.clone(),</div><div class="diff-removed">-                abort_shard_transfer.clone(),</div><div class="diff-removed">-                this_peer_id,</div><div class="diff-removed">-                update_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                search_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                optimizer_resource_budget.clone(),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let locked_shard_holder = Arc::new(LockedShardHolder::new(shard_holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection_stats_cache = CollectionSizeStatsCache::new_with_values(</div><div class="diff-removed">-            Self::estimate_collection_size_stats(&locked_shard_holder).await,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        Self {</div><div class="diff-removed">-            id: collection_id.clone(),</div><div class="diff-removed">-            shards_holder: locked_shard_holder,</div><div class="diff-removed">-            collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            this_peer_id,</div><div class="diff-removed">-            path: path.to_owned(),</div><div class="diff-removed">-            snapshots_path: snapshots_path.to_owned(),</div><div class="diff-removed">-            channel_service,</div><div class="diff-removed">-            transfer_tasks: Mutex::new(TransferTasksPool::new(collection_id.clone())),</div><div class="diff-removed">-            request_shard_transfer_cb: request_shard_transfer.clone(),</div><div class="diff-removed">-            notify_peer_failure_cb: on_replica_failure,</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-removed">-            init_time: start_time.elapsed(),</div><div class="diff-removed">-            is_initialized: Default::default(),</div><div class="diff-removed">-            updates_lock: Default::default(),</div><div class="diff-removed">-            update_runtime: update_runtime.unwrap_or_else(Handle::current),</div><div class="diff-removed">-            search_runtime: search_runtime.unwrap_or_else(Handle::current),</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            collection_stats_cache,</div><div class="diff-removed">-            shard_clean_tasks: Default::default(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if stored version have consequent version.</div><div class="diff-removed">-    /// If major version is different, then it is not compatible.</div><div class="diff-removed">-    /// If the difference in consecutive versions is greater than 1 in patch,</div><div class="diff-removed">-    /// then the collection is not compatible with the current version.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Example:</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.1 = true</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.2 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.0 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.1 = false</div><div class="diff-removed">-    pub fn can_upgrade_storage(stored: &Version, app: &Version) -> bool {</div><div class="diff-removed">-        if stored.major != app.major {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.minor != app.minor {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.patch + 1 < app.patch {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        true</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn name(&self) -> String {</div><div class="diff-removed">-        self.id.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn uuid(&self) -> Option<uuid::Uuid> {</div><div class="diff-removed">-        self.collection_config.read().await.uuid</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn get_shard_keys(&self) -> Vec<ShardKey> {</div><div class="diff-removed">-        self.shards_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .get_shard_key_to_ids_mapping()</div><div class="diff-removed">-            .keys()</div><div class="diff-removed">-            .cloned()</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Return a list of local shards, present on this peer</div><div class="diff-removed">-    pub async fn get_local_shards(&self) -> Vec<ShardId> {</div><div class="diff-removed">-        self.shards_holder.read().await.get_local_shards().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn contains_shard(&self, shard_id: ShardId) -> bool {</div><div class="diff-removed">-        self.shards_holder.read().await.contains_shard(shard_id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn wait_local_shard_replica_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        state: ReplicaState,</div><div class="diff-removed">-        timeout: Duration,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-removed">-        let Some(replica_set) = shard else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        replica_set.wait_for_local_state(state, timeout).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn set_shard_replica_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        peer_id: PeerId,</div><div class="diff-removed">-        new_state: ReplicaState,</div><div class="diff-removed">-        from_state: Option<ReplicaState>,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let shard_holder = self.shards_holder.read().await;</div><div class="diff-removed">-        let replica_set = shard_holder</div><div class="diff-removed">-            .get_shard(shard_id)</div><div class="diff-removed">-            .ok_or_else(|| shard_not_found_error(shard_id))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Changing shard {}:{shard_id} replica state from {:?} to {new_state:?}",</div><div class="diff-removed">-            self.id,</div><div class="diff-removed">-            replica_set.peer_state(peer_id),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let current_state = replica_set.peer_state(peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Validation:</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // 1. Check that peer exists in the cluster (peer might *not* exist, if it was removed from</div><div class="diff-removed">-        //    the cluster right before `SetShardReplicaSet` was proposed)</div><div class="diff-removed">-        let peer_exists = self</div><div class="diff-removed">-            .channel_service</div><div class="diff-removed">-            .id_to_address</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .contains_key(&peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        let replica_exists = replica_set.peer_state(peer_id).is_some();</div><div class="diff-removed">-</div><div class="diff-removed">-        if !peer_exists && !replica_exists {</div><div class="diff-removed">-            return Err(CollectionError::bad_input(format!(</div><div class="diff-removed">-                "Can't set replica {peer_id}:{shard_id} state to {new_state:?}, \</div><div class="diff-removed">-                 because replica {peer_id}:{shard_id} does not exist \</div><div class="diff-removed">-                 and peer {peer_id} is not part of the cluster"</div><div class="diff-removed">-            )));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // 2. Check that `from_state` matches current state</div><div class="diff-removed">-        if from_state.is_some() && current_state != from_state {</div><div class="diff-removed">-            return Err(CollectionError::bad_input(format!(</div><div class="diff-removed">-                "Replica {peer_id} of shard {shard_id} has state {current_state:?}, but expected {from_state:?}"</div><div class="diff-removed">-            )));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // 3. Do not deactivate the last active replica</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `is_last_active_replica` counts both `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-        if replica_set.is_last_active_replica(peer_id) && !new_state.is_active() {</div><div class="diff-removed">-            return Err(CollectionError::bad_input(format!(</div><div class="diff-removed">-                "Cannot deactivate the last active replica {peer_id} of shard {shard_id}"</div><div class="diff-removed">-            )));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Update replica status</div><div class="diff-removed">-        replica_set</div><div class="diff-removed">-            .ensure_replica_with_state(peer_id, new_state)</div><div class="diff-removed">-            .await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        if new_state == ReplicaState::Dead {</div><div class="diff-removed">-            let resharding_state = shard_holder.resharding_state.read().clone();</div><div class="diff-removed">-            let related_transfers = shard_holder.get_related_transfers(shard_id, peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Functions below lock `shard_holder`!</div><div class="diff-removed">-            drop(shard_holder);</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut abort_resharding_result = CollectionResult::Ok(());</div><div class="diff-removed">-</div><div class="diff-removed">-            // Abort resharding, if resharding shard is marked as `Dead`.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // This branch should only be triggered, if resharding is currently at `MigratingPoints`</div><div class="diff-removed">-            // stage, because target shard should be marked as `Active`, when all resharding transfers</div><div class="diff-removed">-            // are successfully completed, and so the check *right above* this one would be triggered.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // So, if resharding reached `ReadHashRingCommitted`, this branch *won't* be triggered,</div><div class="diff-removed">-            // and resharding *won't* be cancelled. The update request should *fail* with "failed to</div><div class="diff-removed">-            // update all replicas of a shard" error.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // If resharding reached `ReadHashRingCommitted`, and this branch is triggered *somehow*,</div><div class="diff-removed">-            // then `Collection::abort_resharding` call should return an error, so no special handling</div><div class="diff-removed">-            // is needed.</div><div class="diff-removed">-            let is_resharding = current_state</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .is_some_and(ReplicaState::is_resharding);</div><div class="diff-removed">-            if is_resharding {</div><div class="diff-removed">-                if let Some(state) = resharding_state {</div><div class="diff-removed">-                    abort_resharding_result = self.abort_resharding(state.key(), false).await;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Terminate transfer if source or target replicas are now dead</div><div class="diff-removed">-            for transfer in related_transfers {</div><div class="diff-removed">-                self.abort_shard_transfer(transfer.key(), None).await?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate resharding errors now</div><div class="diff-removed">-            abort_resharding_result?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // If not initialized yet, we need to check if it was initialized by this call</div><div class="diff-removed">-        if !self.is_initialized.check_ready() {</div><div class="diff-removed">-            let state = self.state().await;</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut is_ready = true;</div><div class="diff-removed">-</div><div class="diff-removed">-            for (_shard_id, shard_info) in state.shards {</div><div class="diff-removed">-                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-removed">-                    matches!(</div><div class="diff-removed">-                        state,</div><div class="diff-removed">-                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-                if !all_replicas_active {</div><div class="diff-removed">-                    is_ready = false;</div><div class="diff-removed">-                    break;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            if is_ready {</div><div class="diff-removed">-                self.is_initialized.make_ready();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn shard_recovery_point(&self, shard_id: ShardId) -> CollectionResult<RecoveryPoint> {</div><div class="diff-removed">-        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-removed">-        let Some(replica_set) = shard else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        replica_set.shard_recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn update_shard_cutoff_point(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        cutoff: &RecoveryPoint,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-removed">-        let Some(replica_set) = shard else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        replica_set.update_shard_cutoff_point(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn state(&self) -> State {</div><div class="diff-removed">-        let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-        let transfers = shards_holder.shard_transfers.read().clone();</div><div class="diff-removed">-        let resharding = shards_holder.resharding_state.read().clone();</div><div class="diff-removed">-        State {</div><div class="diff-removed">-            config: self.collection_config.read().await.clone(),</div><div class="diff-removed">-            shards: shards_holder</div><div class="diff-removed">-                .get_shards()</div><div class="diff-removed">-                .map(|(shard_id, replicas)| {</div><div class="diff-removed">-                    let shard_info = ShardInfo {</div><div class="diff-removed">-                        replicas: replicas.peers(),</div><div class="diff-removed">-                    };</div><div class="diff-removed">-                    (shard_id, shard_info)</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .collect(),</div><div class="diff-removed">-            resharding,</div><div class="diff-removed">-            transfers,</div><div class="diff-removed">-            shards_key_mapping: shards_holder.get_shard_key_to_ids_mapping(),</div><div class="diff-removed">-            payload_index_schema: self.payload_index_schema.read().clone(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        // Abort resharding, if shards are removed from peer driving resharding</div><div class="diff-removed">-        // (which *usually* means the *peer* is being removed from consensus)</div><div class="diff-removed">-        let resharding_state = self</div><div class="diff-removed">-            .resharding_state()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .filter(|state| state.peer_id == peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(state) = resharding_state {</div><div class="diff-removed">-            if let Err(err) = self.abort_resharding(state.key(), true).await {</div><div class="diff-removed">-                log::error!(</div><div class="diff-removed">-                    "Failed to abort resharding {} while removing peer {peer_id}: {err}",</div><div class="diff-removed">-                    state.key(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.shards_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .remove_shards_at_peer(peer_id)</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn sync_local_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        on_transfer_failure: OnTransferFailure,</div><div class="diff-removed">-        on_transfer_success: OnTransferSuccess,</div><div class="diff-removed">-        on_finish_init: ChangePeerState,</div><div class="diff-removed">-        on_convert_to_listener: ChangePeerState,</div><div class="diff-removed">-        on_convert_from_listener: ChangePeerState,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        // Check for disabled replicas</div><div class="diff-removed">-        let shard_holder = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let get_shard_transfers = |shard_id, from| {</div><div class="diff-removed">-            shard_holder</div><div class="diff-removed">-                .get_transfers(|transfer| transfer.shard_id == shard_id && transfer.from == from)</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        for replica_set in shard_holder.all_shards() {</div><div class="diff-removed">-            replica_set.sync_local_state(get_shard_transfers)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Check for un-reported finished transfers</div><div class="diff-removed">-        let outgoing_transfers = shard_holder.get_outgoing_transfers(self.this_peer_id);</div><div class="diff-removed">-        let tasks_lock = self.transfer_tasks.lock().await;</div><div class="diff-removed">-        for transfer in outgoing_transfers {</div><div class="diff-removed">-            match tasks_lock</div><div class="diff-removed">-                .get_task_status(&transfer.key())</div><div class="diff-removed">-                .map(|s| s.result)</div><div class="diff-removed">-            {</div><div class="diff-removed">-                None => {</div><div class="diff-removed">-                    log::debug!(</div><div class="diff-removed">-                        "Transfer {:?} does not exist, but not reported as cancelled. Reporting now.",</div><div class="diff-removed">-                        transfer.key(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    on_transfer_failure(transfer, self.name(), "transfer task does not exist");</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Some(TaskResult::Running) => (),</div><div class="diff-removed">-                Some(TaskResult::Finished) => {</div><div class="diff-removed">-                    log::debug!(</div><div class="diff-removed">-                        "Transfer {:?} is finished successfully, but not reported. Reporting now.",</div><div class="diff-removed">-                        transfer.key(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    on_transfer_success(transfer, self.name());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Some(TaskResult::Failed) => {</div><div class="diff-removed">-                    log::debug!(</div><div class="diff-removed">-                        "Transfer {:?} is failed, but not reported as failed. Reporting now.",</div><div class="diff-removed">-                        transfer.key(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    on_transfer_failure(transfer, self.name(), "transfer failed");</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Count how many transfers we are now proposing</div><div class="diff-removed">-        // We must track this here so we can reference it when checking for tranfser limits,</div><div class="diff-removed">-        // because transfers we propose now will not be in the consensus state within the lifetime</div><div class="diff-removed">-        // of this function</div><div class="diff-removed">-        let mut proposed = HashMap::<PeerId, usize>::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Check for proper replica states</div><div class="diff-removed">-        for replica_set in shard_holder.all_shards() {</div><div class="diff-removed">-            let this_peer_id = replica_set.this_peer_id();</div><div class="diff-removed">-            let shard_id = replica_set.shard_id;</div><div class="diff-removed">-</div><div class="diff-removed">-            let peers = replica_set.peers();</div><div class="diff-removed">-            let this_peer_state = peers.get(&this_peer_id).copied();</div><div class="diff-removed">-</div><div class="diff-removed">-            if this_peer_state == Some(Initializing) {</div><div class="diff-removed">-                // It is possible, that collection creation didn't report</div><div class="diff-removed">-                // Try to activate shard, as the collection clearly exists</div><div class="diff-removed">-                on_finish_init(this_peer_id, shard_id);</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            if self.shared_storage_config.node_type == NodeType::Listener {</div><div class="diff-removed">-                // We probably should not switch node type during resharding, so we only check for `Active`,</div><div class="diff-removed">-                // but not `ReshardingScaleDown` replica state here...</div><div class="diff-removed">-                let is_last_active = peers.values().filter(|&&state| state == Active).count() == 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                if this_peer_state == Some(Active) && !is_last_active {</div><div class="diff-removed">-                    // Convert active node from active to listener</div><div class="diff-removed">-                    on_convert_to_listener(this_peer_id, shard_id);</div><div class="diff-removed">-                    continue;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            } else if this_peer_state == Some(Listener) {</div><div class="diff-removed">-                // Convert listener node to active</div><div class="diff-removed">-                on_convert_from_listener(this_peer_id, shard_id);</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Don't automatically recover replicas if started in recovery mode</div><div class="diff-removed">-            if self.shared_storage_config.recovery_mode.is_some() {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Don't recover replicas if not dead</div><div class="diff-removed">-            let is_dead = this_peer_state == Some(Dead);</div><div class="diff-removed">-            if !is_dead {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Try to find dead replicas with no active transfers</div><div class="diff-removed">-            let transfers = shard_holder.get_transfers(|_| true);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-            let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(this_peer_id);</div><div class="diff-removed">-            incoming += proposed.get(&this_peer_id).copied().unwrap_or(0);</div><div class="diff-removed">-            if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-removed">-                log::trace!(</div><div class="diff-removed">-                    "Postponing automatic shard {shard_id} transfer to stay below limit on this node (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-removed">-                );</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-removed">-            // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-removed">-            let shard_transfer_method = self</div><div class="diff-removed">-                .shared_storage_config</div><div class="diff-removed">-                .default_shard_transfer_method</div><div class="diff-removed">-                .unwrap_or_else(|| {</div><div class="diff-removed">-                    let all_support_wal_delta = self</div><div class="diff-removed">-                        .channel_service</div><div class="diff-removed">-                        .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-removed">-                    if all_support_wal_delta {</div><div class="diff-removed">-                        ShardTransferMethod::WalDelta</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        ShardTransferMethod::default()</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-            // Try to find a replica to transfer from</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // `active_remote_shards` includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-            for replica_id in replica_set.active_remote_shards() {</div><div class="diff-removed">-                let transfer = ShardTransfer {</div><div class="diff-removed">-                    from: replica_id,</div><div class="diff-removed">-                    to: this_peer_id,</div><div class="diff-removed">-                    shard_id,</div><div class="diff-removed">-                    to_shard_id: None,</div><div class="diff-removed">-                    sync: true,</div><div class="diff-removed">-                    // For automatic shard transfers, always select some default method from this point on</div><div class="diff-removed">-                    method: Some(shard_transfer_method),</div><div class="diff-removed">-                };</div><div class="diff-removed">-</div><div class="diff-removed">-                if check_transfer_conflicts_strict(&transfer, transfers.iter()).is_some() {</div><div class="diff-removed">-                    continue; // this transfer won't work</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-                let (incoming, mut outgoing) = shard_holder.count_shard_transfer_io(replica_id);</div><div class="diff-removed">-                outgoing += proposed.get(&replica_id).copied().unwrap_or(0);</div><div class="diff-removed">-                if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-removed">-                    log::trace!(</div><div class="diff-removed">-                        "Postponing automatic shard {shard_id} transfer to stay below limit on peer {replica_id} (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    continue;</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                // TODO: Should we, maybe, throttle/backoff this requests a bit?</div><div class="diff-removed">-                if let Err(err) = replica_set.health_check(replica_id).await {</div><div class="diff-removed">-                    // TODO: This is rather verbose, not sure if we want to log this at all... :/</div><div class="diff-removed">-                    log::trace!(</div><div class="diff-removed">-                        "Replica {replica_id}/{}:{} is not available \</div><div class="diff-removed">-                         to request shard transfer from: \</div><div class="diff-removed">-                         {err}",</div><div class="diff-removed">-                        self.id,</div><div class="diff-removed">-                        replica_set.shard_id,</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    continue;</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Recovering shard {}:{shard_id} on peer {this_peer_id} by requesting it from {replica_id}",</div><div class="diff-removed">-                    self.name(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-</div><div class="diff-removed">-                // Update our counters for proposed transfers, then request (propose) shard transfer</div><div class="diff-removed">-                *proposed.entry(transfer.from).or_default() += 1;</div><div class="diff-removed">-                *proposed.entry(transfer.to).or_default() += 1;</div><div class="diff-removed">-                self.request_shard_transfer(transfer);</div><div class="diff-removed">-                break;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn get_telemetry_data(&self, detail: TelemetryDetail) -> CollectionTelemetry {</div><div class="diff-removed">-        let (shards_telemetry, transfers, resharding) = {</div><div class="diff-removed">-            if detail.level >= DetailsLevel::Level3 {</div><div class="diff-removed">-                let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-                let mut shards_telemetry = Vec::new();</div><div class="diff-removed">-                for shard in shards_holder.all_shards() {</div><div class="diff-removed">-                    shards_telemetry.push(shard.get_telemetry_data(detail).await)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                (</div><div class="diff-removed">-                    Some(shards_telemetry),</div><div class="diff-removed">-                    Some(shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)),</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        shards_holder</div><div class="diff-removed">-                            .get_resharding_operations_info()</div><div class="diff-removed">-                            .unwrap_or_default(),</div><div class="diff-removed">-                    ),</div><div class="diff-removed">-                )</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                (None, None, None)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard_clean_tasks = self.clean_local_shards_statuses();</div><div class="diff-removed">-</div><div class="diff-removed">-        CollectionTelemetry {</div><div class="diff-removed">-            id: self.name(),</div><div class="diff-removed">-            init_time_ms: self.init_time.as_millis() as u64,</div><div class="diff-removed">-            config: CollectionConfigTelemetry::from(self.collection_config.read().await.clone()),</div><div class="diff-removed">-            shards: shards_telemetry,</div><div class="diff-removed">-            transfers,</div><div class="diff-removed">-            resharding,</div><div class="diff-removed">-            shard_clean_tasks: (!shard_clean_tasks.is_empty()).then_some(shard_clean_tasks),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn get_aggregated_telemetry_data(&self) -> CollectionsAggregatedTelemetry {</div><div class="diff-removed">-        let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut shard_optimization_statuses = Vec::new();</div><div class="diff-removed">-        let mut vectors = 0;</div><div class="diff-removed">-</div><div class="diff-removed">-        for shard in shards_holder.all_shards() {</div><div class="diff-removed">-            let shard_optimization_status = shard</div><div class="diff-removed">-                .get_optimization_status()</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .unwrap_or(OptimizersStatus::Ok);</div><div class="diff-removed">-</div><div class="diff-removed">-            shard_optimization_statuses.push(shard_optimization_status);</div><div class="diff-removed">-</div><div class="diff-removed">-            vectors += shard.get_size_stats().await.num_vectors;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizers_status = shard_optimization_statuses</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .max()</div><div class="diff-removed">-            .unwrap_or(OptimizersStatus::Ok);</div><div class="diff-removed">-</div><div class="diff-removed">-        CollectionsAggregatedTelemetry {</div><div class="diff-removed">-            vectors,</div><div class="diff-removed">-            optimizers_status,</div><div class="diff-removed">-            params: self.collection_config.read().await.params.clone(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div class="diff-removed">-        self.updates_lock.write().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn wait_collection_initiated(&self, timeout: Duration) -> bool {</div><div class="diff-removed">-        self.is_initialized.await_ready_for_timeout(timeout)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn request_shard_transfer(&self, shard_transfer: ShardTransfer) {</div><div class="diff-removed">-        self.request_shard_transfer_cb.deref()(shard_transfer)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn snapshots_path(&self) -> &Path {</div><div class="diff-removed">-        &self.snapshots_path</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn shards_holder(&self) -> Arc<LockedShardHolder> {</div><div class="diff-removed">-        self.shards_holder.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn trigger_optimizers(&self) {</div><div class="diff-removed">-        self.shards_holder.read().await.trigger_optimizers().await;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    async fn estimate_collection_size_stats(</div><div class="diff-removed">-        shards_holder: &Arc<RwLock<ShardHolder>>,</div><div class="diff-removed">-    ) -> Option<CollectionSizeStats> {</div><div class="diff-removed">-        let shard_lock = shards_holder.read().await;</div><div class="diff-removed">-        shard_lock.estimate_collection_size_stats().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div class="diff-removed">-    /// The cache gets updated every 32 calls.</div><div class="diff-removed">-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-removed">-        self.collection_stats_cache</div><div class="diff-removed">-            .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+// ... Rest of the implementation</div><div> </div><div> struct CollectionVersion;</div><div> </div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    