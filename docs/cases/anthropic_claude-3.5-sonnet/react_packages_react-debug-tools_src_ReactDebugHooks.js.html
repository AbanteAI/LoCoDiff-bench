<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">‚Üê Back to Sonnet 3.6 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 101332</p>
                <p><strong>Native Completion Tokens:</strong> 8192</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> length</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.426876</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected)+++ react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual)@@ -10,16 +10,17 @@ import type {</div><div>   Awaited,</div><div>   ReactContext,</div><div class="diff-added">+  ReactProviderType,</div><div>   StartTransitionOptions,</div><div>   Usable,</div><div>   Thenable,</div><div>   ReactDebugInfo,</div><div> } from 'shared/ReactTypes';</div><div> import type {</div><div class="diff-removed">-  ContextDependency,</div><div class="diff-added">+  ContextDependency, </div><div>   Dependencies,</div><div>   Fiber,</div><div class="diff-removed">-  Dispatcher as DispatcherType,</div><div class="diff-added">+  Dispatcher as DispatcherType, </div><div> } from 'react-reconciler/src/ReactInternalTypes';</div><div> import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';</div><div> </div><div class="diff-info">@@ -53,7 +54,7 @@ </div><div> let hookLog: Array<HookLogEntry> = [];</div><div> </div><div class="diff-removed">-// Primitives</div><div class="diff-added">+// Primitives </div><div> </div><div> type BasicStateAction<S> = (S => S) | S;</div><div> </div><div class="diff-info">@@ -89,11 +90,7 @@       Dispatcher.useDebugValue(null);</div><div>       Dispatcher.useCallback(() => {});</div><div>       Dispatcher.useTransition();</div><div class="diff-removed">-      Dispatcher.useSyncExternalStore(</div><div class="diff-removed">-        () => () => {},</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-      );</div><div class="diff-added">+      Dispatcher.useSyncExternalStore(() => () => {}, () => null, () => null);</div><div>       Dispatcher.useDeferredValue(null);</div><div>       Dispatcher.useMemo(() => null);</div><div>       Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);</div><div class="diff-info">@@ -106,23 +103,19 @@       }</div><div>       if (typeof Dispatcher.use === 'function') {</div><div>         // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.use(</div><div class="diff-removed">-          ({</div><div class="diff-removed">-            $$typeof: REACT_CONTEXT_TYPE,</div><div class="diff-removed">-            _currentValue: null,</div><div class="diff-removed">-          }: any),</div><div class="diff-removed">-        );</div><div class="diff-added">+        Dispatcher.use(({</div><div class="diff-added">+          $$typeof: REACT_CONTEXT_TYPE, </div><div class="diff-added">+          _currentValue: null,</div><div class="diff-added">+        }: any));</div><div>         Dispatcher.use({</div><div>           then() {},</div><div>           status: 'fulfilled',</div><div>           value: null,</div><div>         });</div><div>         try {</div><div class="diff-removed">-          Dispatcher.use(</div><div class="diff-removed">-            ({</div><div class="diff-removed">-              then() {},</div><div class="diff-removed">-            }: any),</div><div class="diff-removed">-          );</div><div class="diff-added">+          Dispatcher.use(({</div><div class="diff-added">+            then() {},</div><div class="diff-added">+          }: any));</div><div>         } catch (x) {}</div><div>       }</div><div> </div><div class="diff-info">@@ -134,18 +127,18 @@     } finally {</div><div>       readHookLog = hookLog;</div><div>       hookLog = [];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-      const hook = readHookLog[i];</div><div class="diff-removed">-      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));</div><div class="diff-removed">-    }</div><div class="diff-removed">-    primitiveStackCache = cache;</div><div class="diff-added">+      for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-added">+        const hook = readHookLog[i];</div><div class="diff-added">+        cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));</div><div class="diff-added">+      }</div><div class="diff-added">+      primitiveStackCache = cache;</div><div class="diff-added">+    }</div><div>   }</div><div>   return primitiveStackCache;</div><div> }</div><div> </div><div> let currentFiber: null | Fiber = null;</div><div class="diff-removed">-let currentHook: null | Hook = null;</div><div class="diff-added">+let currentHook: null | Hook = null; </div><div> let currentContextDependency: null | ContextDependency<mixed> = null;</div><div> </div><div> function nextHook(): null | Hook {</div><div class="diff-info">@@ -169,12 +162,12 @@     }</div><div> </div><div>     let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div class="diff-added">+    // For now we don't expose readContext usage in the hooks debugging info.  </div><div>     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div>       // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div>       value = ((currentContextDependency.memoizedValue: any): T);</div><div> </div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-added">+      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency` </div><div>       currentContextDependency = currentContextDependency.next;</div><div>     } else {</div><div>       // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-info">@@ -191,7 +184,7 @@   "Suspense Exception: This is not a real error! It's an implementation " +</div><div>     'detail of `use` to interrupt the current render. You must either ' +</div><div>     'rethrow it immediately, or move the `use` call outside of the ' +</div><div class="diff-removed">-    '`try/catch` block. Capturing without rethrowing will lead to ' +</div><div class="diff-added">+    '`try/catch` block. Capturing without rethrowing will lead to ' + </div><div>     'unexpected behavior.\n\n' +</div><div>     'To handle async errors, wrap your component in an error boundary, or ' +</div><div>     "call the promise's `.catch` method and pass the result to `use`.",</div><div class="diff-info">@@ -199,7 +192,7 @@ </div><div> function use<T>(usable: Usable<T>): T {</div><div>   if (usable !== null && typeof usable === 'object') {</div><div class="diff-removed">-    // $FlowFixMe[method-unbinding]</div><div class="diff-added">+    // $FlowFixMe[method-unbinding] </div><div>     if (typeof usable.then === 'function') {</div><div>       const thenable: Thenable<any> = (usable: any);</div><div>       switch (thenable.status) {</div><div class="diff-info">@@ -209,7 +202,7 @@             displayName: null,</div><div>             primitive: 'Promise',</div><div>             stackError: new Error(),</div><div class="diff-removed">-            value: fulfilledValue,</div><div class="diff-added">+            value: fulfilledValue, </div><div>             debugInfo:</div><div>               thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div>             dispatcherHookName: 'Use',</div><div class="diff-info">@@ -230,7 +223,7 @@         value: thenable,</div><div>         debugInfo:</div><div>           thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div class="diff-removed">-        dispatcherHookName: 'Use',</div><div class="diff-added">+        dispatcherHookName: 'Use', </div><div>       });</div><div>       throw SuspenseException;</div><div>     } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {</div><div class="diff-info">@@ -259,7 +252,7 @@   hookLog.push({</div><div>     displayName: context.displayName || null,</div><div>     primitive: 'Context',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-added">+    stackError: new Error(), </div><div>     value: value,</div><div>     debugInfo: null,</div><div>     dispatcherHookName: 'Context',</div><div class="diff-info">@@ -284,7 +277,7 @@     stackError: new Error(),</div><div>     value: state,</div><div>     debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'State',</div><div class="diff-added">+    dispatcherHookName: 'State', </div><div>   });</div><div>   return [state, (action: BasicStateAction<S>) => {}];</div><div> }</div><div class="diff-info">@@ -360,7 +353,7 @@ ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-added">+    displayName: null, </div><div>     primitive: 'InsertionEffect',</div><div>     stackError: new Error(),</div><div>     value: create,</div><div class="diff-info">@@ -456,7 +449,7 @@ ): T {</div><div>   // useSyncExternalStore() composes multiple hooks internally.</div><div>   // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div class="diff-added">+  // so that subsequent hooks have the right memoized state. </div><div>   nextHook(); // SyncExternalStore</div><div>   nextHook(); // Effect</div><div>   const value = getSnapshot();</div><div class="diff-info">@@ -531,7 +524,7 @@     return [];</div><div>   }</div><div> </div><div class="diff-removed">-  const memoCache =</div><div class="diff-added">+  const memoCache =  </div><div>     // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div>     fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div>   if (memoCache == null) {</div><div class="diff-info">@@ -546,14 +539,12 @@     }</div><div>   }</div><div> </div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div>   memoCache.index++;</div><div>   return data;</div><div> }</div><div> </div><div> function useOptimistic<S, A>(</div><div class="diff-removed">-  passthrough: S,</div><div class="diff-added">+  passthrough: S,  </div><div>   reducer: ?(S, A) => S,</div><div> ): [S, (A) => void] {</div><div>   const hook = nextHook();</div><div class="diff-info">@@ -575,6 +566,76 @@ }</div><div> </div><div> function useFormState<S, P>(</div><div class="diff-added">+  action: (Awaited<S>, P) => S,</div><div class="diff-added">+  initialState: Awaited<S>, </div><div class="diff-added">+  permalink?: string,  </div><div class="diff-added">+): [Awaited<S>, (P) => void, boolean] {</div><div class="diff-added">+  const hook = nextHook(); // FormState</div><div class="diff-added">+  nextHook(); // PendingState</div><div class="diff-added">+  nextHook(); // ActionQueue</div><div class="diff-added">+  const stackError = new Error();</div><div class="diff-added">+  let value;</div><div class="diff-added">+  let debugInfo = null;</div><div class="diff-added">+  let error = null;</div><div class="diff-added">+</div><div class="diff-added">+  if (hook !== null) {</div><div class="diff-added">+    const actionResult = hook.memoizedState;</div><div class="diff-added">+    if (</div><div class="diff-added">+      typeof actionResult === 'object' &&</div><div class="diff-added">+      actionResult !== null &&</div><div class="diff-added">+      // $FlowFixMe[method-unbinding]</div><div class="diff-added">+      typeof actionResult.then === 'function'</div><div class="diff-added">+    ) {</div><div class="diff-added">+      const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-added">+      switch (thenable.status) {</div><div class="diff-added">+        case 'fulfilled': {</div><div class="diff-added">+          value = thenable.value;</div><div class="diff-added">+          debugInfo =  </div><div class="diff-added">+            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          break;</div><div class="diff-added">+        }</div><div class="diff-added">+        case 'rejected': {</div><div class="diff-added">+          const rejectedError = thenable.reason;</div><div class="diff-added">+          error = rejectedError;</div><div class="diff-added">+          break; </div><div class="diff-added">+        }</div><div class="diff-added">+        default: </div><div class="diff-added">+          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-added">+          // but we can still emit anything up until this point.</div><div class="diff-added">+          error = SuspenseException;</div><div class="diff-added">+          debugInfo =  </div><div class="diff-added">+            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-added">+          value = thenable;</div><div class="diff-added">+      }</div><div class="diff-added">+    } else {</div><div class="diff-added">+      value = (actionResult: any);</div><div class="diff-added">+    }</div><div class="diff-added">+  } else {</div><div class="diff-added">+    value = initialState;</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  hookLog.push({</div><div class="diff-added">+    displayName: null,</div><div class="diff-added">+    primitive: 'FormState',</div><div class="diff-added">+    stackError: stackError,</div><div class="diff-added">+    value: value,</div><div class="diff-added">+    debugInfo: debugInfo,</div><div class="diff-added">+    dispatcherHookName: 'FormState',</div><div class="diff-added">+  });</div><div class="diff-added">+</div><div class="diff-added">+  if (error !== null) {</div><div class="diff-added">+    throw error;</div><div class="diff-added">+  }</div><div class="diff-added">+  </div><div class="diff-added">+  // value being a Thenable is equivalent to error being not null</div><div class="diff-added">+  // i.e. we only reach this point with Awaited<S></div><div class="diff-added">+  const state = ((value: any): Awaited<S>);</div><div class="diff-added">+</div><div class="diff-added">+  // TODO: support displaying pending value  </div><div class="diff-added">+  return [state, (payload: P) => {}, false];</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+function useActionState<S, P>(</div><div>   action: (Awaited<S>, P) => S,</div><div>   initialState: Awaited<S>,</div><div>   permalink?: string,</div><div class="diff-info">@@ -605,7 +666,7 @@         }</div><div>         case 'rejected': {</div><div>           const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-added">+          error = rejectedError; </div><div>           break;</div><div>         }</div><div>         default:</div><div class="diff-info">@@ -617,77 +678,7 @@           value = thenable;</div><div>       }</div><div>     } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    value = initialState;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'FormState',</div><div class="diff-removed">-    stackError: stackError,</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: debugInfo,</div><div class="diff-removed">-    dispatcherHookName: 'FormState',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  if (error !== null) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div class="diff-removed">-  const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div class="diff-removed">-  return [state, (payload: P) => {}, false];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useActionState<S, P>(</div><div class="diff-removed">-  action: (Awaited<S>, P) => S,</div><div class="diff-removed">-  initialState: Awaited<S>,</div><div class="diff-removed">-  permalink?: string,</div><div class="diff-removed">-): [Awaited<S>, (P) => void, boolean] {</div><div class="diff-removed">-  const hook = nextHook(); // FormState</div><div class="diff-removed">-  nextHook(); // PendingState</div><div class="diff-removed">-  nextHook(); // ActionQueue</div><div class="diff-removed">-  const stackError = new Error();</div><div class="diff-removed">-  let value;</div><div class="diff-removed">-  let debugInfo = null;</div><div class="diff-removed">-  let error = null;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    const actionResult = hook.memoizedState;</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      typeof actionResult === 'object' &&</div><div class="diff-removed">-      actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div class="diff-removed">-      typeof actionResult.then === 'function'</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-removed">-      switch (thenable.status) {</div><div class="diff-removed">-        case 'fulfilled': {</div><div class="diff-removed">-          value = thenable.value;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div class="diff-removed">-          error = SuspenseException;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          value = thenable;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-added">+      value = (actionResult: any);  </div><div>     }</div><div>   } else {</div><div>     value = initialState;</div><div class="diff-info">@@ -719,7 +710,7 @@     // $FlowFixMe[prop-missing] `readContext` only needs _currentValue</div><div>     ({</div><div>       // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.</div><div class="diff-removed">-      _currentValue: null,</div><div class="diff-added">+      _currentValue: null,  </div><div>     }: ReactContext<TransitionStatus>),</div><div>   );</div><div> </div><div class="diff-info">@@ -729,7 +720,7 @@     stackError: new Error(),</div><div>     value: status,</div><div>     debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'HostTransitionStatus',</div><div class="diff-added">+    dispatcherHookName: 'HostTransitionStatus', </div><div>   });</div><div> </div><div>   return status;</div><div class="diff-info">@@ -741,7 +732,7 @@     displayName: null,</div><div>     primitive: 'EffectEvent',</div><div>     stackError: new Error(),</div><div class="diff-removed">-    value: callback,</div><div class="diff-added">+    value: callback, </div><div>     debugInfo: null,</div><div>     dispatcherHookName: 'EffectEvent',</div><div>   });</div><div class="diff-info">@@ -752,7 +743,7 @@ const Dispatcher: DispatcherType = {</div><div>   readContext,</div><div> </div><div class="diff-removed">-  use,</div><div class="diff-added">+  use, </div><div>   useCallback,</div><div>   useContext,</div><div>   useEffect,</div><div class="diff-info">@@ -778,7 +769,7 @@ };</div><div> </div><div> // create a proxy to throw a custom error</div><div class="diff-removed">-// in case future versions of React adds more hooks</div><div class="diff-added">+// in case future versions of React adds more hooks  </div><div> const DispatcherProxyHandler = {</div><div>   get(target: DispatcherType, prop: string) {</div><div>     if (target.hasOwnProperty(prop)) {</div><div class="diff-info">@@ -794,7 +785,7 @@ };</div><div> </div><div> // `Proxy` may not exist on some platforms</div><div class="diff-removed">-const DispatcherProxy =</div><div class="diff-added">+const DispatcherProxy = </div><div>   typeof Proxy === 'undefined'</div><div>     ? Dispatcher</div><div>     : new Proxy(Dispatcher, DispatcherProxyHandler);</div><div class="diff-info">@@ -809,7 +800,7 @@ };</div><div> </div><div> export type HooksNode = {</div><div class="diff-removed">-  id: number | null,</div><div class="diff-added">+  id: number | null, </div><div>   isStateEditable: boolean,</div><div>   name: string,</div><div>   value: mixed,</div><div class="diff-info">@@ -817,16 +808,16 @@   debugInfo: null | ReactDebugInfo,</div><div>   hookSource: null | HookSource,</div><div> };</div><div class="diff-added">+</div><div> export type HooksTree = Array<HooksNode>;</div><div> </div><div> // Don't assume</div><div> //</div><div> // We can't assume that stack frames are nth steps away from anything.</div><div class="diff-removed">-// E.g. we can't assume that the root call shares all frames with the stack</div><div class="diff-added">+// E.g. we can't assume that the root call shares all frames with the stack  </div><div> // of a hook call. A simple way to demonstrate this is wrapping `new Error()`</div><div> // in a wrapper constructor like a polyfill. That'll add an extra frame.</div><div class="diff-removed">-// Similar things can happen with the call to the dispatcher. The top frame</div><div class="diff-removed">-// may not be the primitive.</div><div class="diff-added">+// Similar things can happen with the call to the dispatcher.</div><div> //</div><div> // We also can't assume that the last frame of the root call is the same</div><div> // frame as the last frame of the hook call because long stack traces can be</div><div class="diff-info">@@ -892,7 +883,7 @@     return -1;</div><div>   }</div><div>   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {</div><div class="diff-removed">-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack</div><div class="diff-added">+    // Note: there is no guarantee that we will find the top-most primitive frame in the stack </div><div>     // For React Native (uses Hermes), these source fields will be identical and skipped</div><div>     if (primitiveStack[i].source !== hookStack[i].source) {</div><div>       // If the next two frames are functions called `useX` then we assume that they're part of the</div><div class="diff-info">@@ -904,7 +895,7 @@         i++;</div><div>       }</div><div>       if (</div><div class="diff-removed">-        i < hookStack.length - 1 &&</div><div class="diff-added">+        i < hookStack.length - 1 && </div><div>         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div>       ) {</div><div>         i++;</div><div class="diff-info">@@ -920,426 +911,5 @@   // Get the stack trace between the primitive hook function and</div><div>   // the root function call. I.e. the stack frames of custom hooks.</div><div>   const hookStack = ErrorStackParser.parse(hook.stackError);</div><div class="diff-removed">-  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div>   const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    rootIndex === -1 ||</div><div class="diff-removed">-    primitiveIndex === -1 ||</div><div class="diff-removed">-    rootIndex - primitiveIndex < 2</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    if (primitiveIndex === -1) {</div><div class="diff-removed">-      // Something went wrong. Give up.</div><div class="diff-removed">-      return [null, null];</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      return [hookStack[primitiveIndex - 1], null];</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return [</div><div class="diff-removed">-    hookStack[primitiveIndex - 1],</div><div class="diff-removed">-    hookStack.slice(primitiveIndex, rootIndex - 1),</div><div class="diff-removed">-  ];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function parseHookName(functionName: void | string): string {</div><div class="diff-removed">-  if (!functionName) {</div><div class="diff-removed">-    return '';</div><div class="diff-removed">-  }</div><div class="diff-removed">-  let startIndex = functionName.lastIndexOf('[as ');</div><div class="diff-removed">-</div><div class="diff-removed">-  if (startIndex !== -1) {</div><div class="diff-removed">-    // Workaround for sourcemaps in Jest and Chrome.</div><div class="diff-removed">-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"</div><div class="diff-removed">-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"</div><div class="diff-removed">-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));</div><div class="diff-removed">-  }</div><div class="diff-removed">-  startIndex = functionName.lastIndexOf('.');</div><div class="diff-removed">-  if (startIndex === -1) {</div><div class="diff-removed">-    startIndex = 0;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    startIndex += 1;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('unstable_')) {</div><div class="diff-removed">-    startIndex += 'unstable_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('experimental_')) {</div><div class="diff-removed">-    startIndex += 'experimental_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex, startIndex + 3) === 'use') {</div><div class="diff-removed">-    if (functionName.length - startIndex === 3) {</div><div class="diff-removed">-      return 'Use';</div><div class="diff-removed">-    }</div><div class="diff-removed">-    startIndex += 3;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return functionName.slice(startIndex);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function buildTree(</div><div class="diff-removed">-  rootStack: any,</div><div class="diff-removed">-  readHookLog: Array<HookLogEntry>,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const rootChildren: Array<HooksNode> = [];</div><div class="diff-removed">-  let prevStack = null;</div><div class="diff-removed">-  let levelChildren = rootChildren;</div><div class="diff-removed">-  let nativeHookID = 0;</div><div class="diff-removed">-  const stackOfChildren = [];</div><div class="diff-removed">-  for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-    const hook = readHookLog[i];</div><div class="diff-removed">-    const parseResult = parseTrimmedStack(rootStack, hook);</div><div class="diff-removed">-    const primitiveFrame = parseResult[0];</div><div class="diff-removed">-    const stack = parseResult[1];</div><div class="diff-removed">-    let displayName = hook.displayName;</div><div class="diff-removed">-    if (displayName === null && primitiveFrame !== null) {</div><div class="diff-removed">-      displayName =</div><div class="diff-removed">-        parseHookName(primitiveFrame.functionName) ||</div><div class="diff-removed">-        // Older versions of React do not have sourcemaps.</div><div class="diff-removed">-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div class="diff-removed">-        parseHookName(hook.dispatcherHookName);</div><div class="diff-removed">-    }</div><div class="diff-removed">-    if (stack !== null) {</div><div class="diff-removed">-      // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-removed">-      // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div class="diff-removed">-      let commonSteps = 0;</div><div class="diff-removed">-      if (prevStack !== null) {</div><div class="diff-removed">-        // Compare the current level's stack to the new stack.</div><div class="diff-removed">-        while (commonSteps < stack.length && commonSteps < prevStack.length) {</div><div class="diff-removed">-          const stackSource = stack[stack.length - commonSteps - 1].source;</div><div class="diff-removed">-          const prevSource =</div><div class="diff-removed">-            prevStack[prevStack.length - commonSteps - 1].source;</div><div class="diff-removed">-          if (stackSource !== prevSource) {</div><div class="diff-removed">-            break;</div><div class="diff-removed">-          }</div><div class="diff-removed">-          commonSteps++;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // Pop back the stack as many steps as were not common.</div><div class="diff-removed">-        for (let j = prevStack.length - 1; j > commonSteps; j--) {</div><div class="diff-removed">-          // $FlowFixMe[incompatible-type]</div><div class="diff-removed">-          levelChildren = stackOfChildren.pop();</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // The remaining part of the new stack are custom hooks. Push them</div><div class="diff-removed">-      // to the tree.</div><div class="diff-removed">-      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div class="diff-removed">-        const children: Array<HooksNode> = [];</div><div class="diff-removed">-        const stackFrame = stack[j];</div><div class="diff-removed">-        const levelChild: HooksNode = {</div><div class="diff-removed">-          id: null,</div><div class="diff-removed">-          isStateEditable: false,</div><div class="diff-removed">-          name: parseHookName(stack[j - 1].functionName),</div><div class="diff-removed">-          value: undefined,</div><div class="diff-removed">-          subHooks: children,</div><div class="diff-removed">-          debugInfo: null,</div><div class="diff-removed">-          hookSource: {</div><div class="diff-removed">-            lineNumber: stackFrame.lineNumber,</div><div class="diff-removed">-            columnNumber: stackFrame.columnNumber,</div><div class="diff-removed">-            functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div class="diff-removed">-          },</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        levelChildren.push(levelChild);</div><div class="diff-removed">-        stackOfChildren.push(levelChildren);</div><div class="diff-removed">-        levelChildren = children;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      prevStack = stack;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-removed">-    const id =</div><div class="diff-removed">-      primitive === 'Context' ||</div><div class="diff-removed">-      primitive === 'Context (use)' ||</div><div class="diff-removed">-      primitive === 'DebugValue' ||</div><div class="diff-removed">-      primitive === 'Promise' ||</div><div class="diff-removed">-      primitive === 'Unresolved' ||</div><div class="diff-removed">-      primitive === 'HostTransitionStatus'</div><div class="diff-removed">-        ? null</div><div class="diff-removed">-        : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-removed">-    const levelChild: HooksNode = {</div><div class="diff-removed">-      id,</div><div class="diff-removed">-      isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-removed">-      value: hook.value,</div><div class="diff-removed">-      subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-removed">-      hookSource: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    const hookSource: HookSource = {</div><div class="diff-removed">-      lineNumber: null,</div><div class="diff-removed">-      functionName: null,</div><div class="diff-removed">-      fileName: null,</div><div class="diff-removed">-      columnNumber: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChildren.push(levelChild);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-removed">-  processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div class="diff-removed">-  return rootChildren;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-removed">-function processDebugValues(</div><div class="diff-removed">-  hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-  for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-removed">-    const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-removed">-      hooksTree.splice(i, 1);</div><div class="diff-removed">-      i--;</div><div class="diff-removed">-      debugValueHooksNodes.push(hooksNode);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div class="diff-removed">-  if (parentHooksNode !== null) {</div><div class="diff-removed">-    if (debugValueHooksNodes.length === 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-removed">-    } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    error instanceof Error &&</div><div class="diff-removed">-    error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-  wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-removed">-  wrapperError.cause = error;</div><div class="diff-removed">-  throw wrapperError;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooks<Props>(</div><div class="diff-removed">-  renderFunction: Props => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-removed">-  let current: null | Fiber = fiber;</div><div class="diff-removed">-  while (current) {</div><div class="diff-removed">-    if (current.tag === ContextProvider) {</div><div class="diff-removed">-      let context: ReactContext<any> = current.type;</div><div class="diff-removed">-      if ((context: any)._context !== undefined) {</div><div class="diff-removed">-        // Support inspection of pre-19+ providers.</div><div class="diff-removed">-        context = (context: any)._context;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (!contextMap.has(context)) {</div><div class="diff-removed">-        // Store the current value that we're going to restore later.</div><div class="diff-removed">-        contextMap.set(context, context._currentValue);</div><div class="diff-removed">-        // Set the inner most provider value on the context.</div><div class="diff-removed">-        context._currentValue = current.memoizedProps.value;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    current = current.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {</div><div class="diff-removed">-  contextMap.forEach((value, context) => (context._currentValue = value));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-removed">-  renderFunction: (Props, Ref) => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  ref: Ref,</div><div class="diff-removed">-  currentDispatcher: CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props, ref);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function resolveDefaultProps(Component: any, baseProps: any) {</div><div class="diff-removed">-  if (Component && Component.defaultProps) {</div><div class="diff-removed">-    // Resolve default props. Taken from ReactElement</div><div class="diff-removed">-    const props = assign({}, baseProps);</div><div class="diff-removed">-    const defaultProps = Component.defaultProps;</div><div class="diff-removed">-    for (const propName in defaultProps) {</div><div class="diff-removed">-      if (props[propName] === undefined) {</div><div class="diff-removed">-        props[propName] = defaultProps[propName];</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    return props;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return baseProps;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooksOfFiber(</div><div class="diff-removed">-  fiber: Fiber,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    fiber.tag !== FunctionComponent &&</div><div class="diff-removed">-    fiber.tag !== SimpleMemoComponent &&</div><div class="diff-removed">-    fiber.tag !== ForwardRef</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unknown Fiber. Needs to be a function component to inspect hooks.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div class="diff-removed">-  getPrimitiveStackCache();</div><div class="diff-removed">-</div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div class="diff-removed">-  currentHook = (fiber.memoizedState: Hook);</div><div class="diff-removed">-  currentFiber = fiber;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`</div><div class="diff-removed">-    const dependencies = currentFiber.dependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {</div><div class="diff-removed">-    const contextDependencies = (currentFiber: any).contextDependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      contextDependencies !== null ? contextDependencies.first : null;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unsupported React version. This is a bug in React Debug Tools.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const type = fiber.type;</div><div class="diff-removed">-  let props = fiber.memoizedProps;</div><div class="diff-removed">-  if (type !== fiber.elementType) {</div><div class="diff-removed">-    props = resolveDefaultProps(type, props);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Only used for versions of React without memoized context value in context dependencies.</div><div class="diff-removed">-  const contextMap = new Map<ReactContext<any>, any>();</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      currentContextDependency !== null &&</div><div class="diff-removed">-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      setupContexts(contextMap, fiber);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (fiber.tag === ForwardRef) {</div><div class="diff-removed">-      return inspectHooksOfForwardRef(</div><div class="diff-removed">-        type.render,</div><div class="diff-removed">-        props,</div><div class="diff-removed">-        fiber.ref,</div><div class="diff-removed">-        currentDispatcher,</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return inspectHooks(type, props, currentDispatcher);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    currentFiber = null;</div><div class="diff-removed">-    currentHook = null;</div><div class="diff-removed">-    currentContextDependency = null;</div><div class="diff-removed">-</div><div class="diff-removed">-    restoreContexts(contextMap);</div><div class="diff-removed">-  }</div><div class="diff-removed">-}+  const rootIndex = findCommonAnc</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    