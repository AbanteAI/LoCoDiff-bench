<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: Sonnet 3.6</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">All Sonnet 3.6 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 80569</p>
                <p><strong>Native Completion Tokens:</strong> 2258</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.275577</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb3..3732e977 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpg9eb51ce_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpvqspyn7s_actual.txt	</div><div class="diff-info">@@ -71,11 +71,8 @@ use crate::wal_delta::{LockedWal, RecoverableWal};</div><div> const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);</div><div> </div><div> const WAL_PATH: &str = "wal";</div><div class="diff-removed">-</div><div> const SEGMENTS_PATH: &str = "segments";</div><div class="diff-removed">-</div><div> const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";</div><div class="diff-removed">-</div><div> const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";</div><div> </div><div> /// LocalShard</div><div class="diff-info">@@ -108,7 +105,7 @@ impl LocalShard {</div><div>     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div>         log::debug!(</div><div>             "Moving local shard from {} to {}",</div><div class="diff-removed">-            from.display(),</div><div class="diff-added">+            from.display(), </div><div>             to.display()</div><div>         );</div><div> </div><div class="diff-info">@@ -153,1022 +150,7 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn new(</div><div class="diff-removed">-        segment_holder: SegmentHolder,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        wal: SerdeWal<OperationWithClockTag>,</div><div class="diff-removed">-        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        clocks: LocalShardClocks,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-    ) -> Self {</div><div class="diff-removed">-        let segment_holder = Arc::new(RwLock::new(segment_holder));</div><div class="diff-removed">-        let config = collection_config.read().await;</div><div class="diff-removed">-        let locked_wal = Arc::new(Mutex::new(wal));</div><div class="diff-removed">-        let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));</div><div class="diff-removed">-        let total_optimized_points = Arc::new(AtomicUsize::new(0));</div><div class="diff-removed">-</div><div class="diff-removed">-        // default to 2x the WAL capacity</div><div class="diff-removed">-        let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-removed">-</div><div class="diff-removed">-        let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div class="diff-removed">-            shard_path.to_owned(),</div><div class="diff-removed">-            disk_buffer_threshold_mb,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut update_handler = UpdateHandler::new(</div><div class="diff-removed">-            shared_storage_config.clone(),</div><div class="diff-removed">-            payload_index_schema.clone(),</div><div class="diff-removed">-            optimizers.clone(),</div><div class="diff-removed">-            optimizers_log.clone(),</div><div class="diff-removed">-            total_optimized_points.clone(),</div><div class="diff-removed">-            optimizer_resource_budget.clone(),</div><div class="diff-removed">-            update_runtime.clone(),</div><div class="diff-removed">-            segment_holder.clone(),</div><div class="diff-removed">-            locked_wal.clone(),</div><div class="diff-removed">-            config.optimizer_config.flush_interval_sec,</div><div class="diff-removed">-            config.optimizer_config.max_optimization_threads,</div><div class="diff-removed">-            clocks.clone(),</div><div class="diff-removed">-            shard_path.into(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(shared_storage_config.update_queue_size);</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        let update_tracker = segment_holder.read().update_tracker();</div><div class="diff-removed">-</div><div class="diff-removed">-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .read_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(ParkingMutex::new)</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        Self {</div><div class="diff-removed">-            segments: segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal: RecoverableWal::new(locked_wal, clocks.newest_clocks, clocks.oldest_clocks),</div><div class="diff-removed">-            update_handler: Arc::new(Mutex::new(update_handler)),</div><div class="diff-removed">-            update_sender: ArcSwap::from_pointee(update_sender),</div><div class="diff-removed">-            update_tracker,</div><div class="diff-removed">-            path: shard_path.to_owned(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizers_log,</div><div class="diff-removed">-            total_optimized_points,</div><div class="diff-removed">-            disk_usage_watcher,</div><div class="diff-removed">-            read_rate_limiter,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Recovers shard from disk.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn load(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        let collection_config_read = collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal_path = Self::wal_path(shard_path);</div><div class="diff-removed">-        let segments_path = Self::segments_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(</div><div class="diff-removed">-            wal_path.to_str().unwrap(),</div><div class="diff-removed">-            (&collection_config_read.wal_config).into(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Walk over segments directory and collect all directory entries now</div><div class="diff-removed">-        // Collect now and error early to prevent errors while we've already spawned load threads</div><div class="diff-removed">-        let segment_paths = std::fs::read_dir(&segments_path)</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Can't read segments directory due to {err}\nat {}",</div><div class="diff-removed">-                    segments_path.display(),</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Failed to read segment path in segment directory: {err}",</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Grab segment paths, filter out hidden entries and non-directories</div><div class="diff-removed">-        let segment_paths = segment_paths</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .filter(|entry| {</div><div class="diff-removed">-                let is_hidden = entry</div><div class="diff-removed">-                    .file_name()</div><div class="diff-removed">-                    .to_str()</div><div class="diff-removed">-                    .is_some_and(|s| s.starts_with('.'));</div><div class="diff-removed">-                if is_hidden {</div><div class="diff-removed">-                    log::debug!(</div><div class="diff-removed">-                        "Segments path entry prefixed with a period, ignoring: {}",</div><div class="diff-removed">-                        entry.path().display(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                }</div><div class="diff-removed">-                !is_hidden</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .filter(|entry| {</div><div class="diff-removed">-                let is_dir = entry.path().is_dir();</div><div class="diff-removed">-                if !is_dir {</div><div class="diff-removed">-                    log::warn!(</div><div class="diff-removed">-                        "Segments path entry is not a directory, skipping: {}",</div><div class="diff-removed">-                        entry.path().display(),</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                }</div><div class="diff-removed">-                is_dir</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .map(|entry| entry.path());</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut load_handlers = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        // This semaphore is used to limit the number of threads that load segments concurrently.</div><div class="diff-removed">-        // Uncomment it if you need to debug segment loading.</div><div class="diff-removed">-        // let semaphore = Arc::new(parking_lot::Mutex::new(()));</div><div class="diff-removed">-</div><div class="diff-removed">-        for segment_path in segment_paths {</div><div class="diff-removed">-            let payload_index_schema = payload_index_schema.clone();</div><div class="diff-removed">-            // let semaphore_clone = semaphore.clone();</div><div class="diff-removed">-            load_handlers.push(</div><div class="diff-removed">-                thread::Builder::new()</div><div class="diff-removed">-                    .name(format!("shard-load-{collection_id}-{id}"))</div><div class="diff-removed">-                    .spawn(move || {</div><div class="diff-removed">-                        // let _guard = semaphore_clone.lock();</div><div class="diff-removed">-                        let mut res = load_segment(&segment_path, &AtomicBool::new(false))?;</div><div class="diff-removed">-                        if let Some(segment) = &mut res {</div><div class="diff-removed">-                            segment.check_consistency_and_repair()?;</div><div class="diff-removed">-                            segment.update_all_field_indices(</div><div class="diff-removed">-                                &payload_index_schema.read().schema.clone(),</div><div class="diff-removed">-                            )?;</div><div class="diff-removed">-                        } else {</div><div class="diff-removed">-                            std::fs::remove_dir_all(&segment_path).map_err(|err| {</div><div class="diff-removed">-                                CollectionError::service_error(format!(</div><div class="diff-removed">-                                    "Can't remove leftover segment {}, due to {err}",</div><div class="diff-removed">-                                    segment_path.to_str().unwrap(),</div><div class="diff-removed">-                                ))</div><div class="diff-removed">-                            })?;</div><div class="diff-removed">-                        }</div><div class="diff-removed">-                        Ok::<_, CollectionError>(res)</div><div class="diff-removed">-                    })?,</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut segment_holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        for handler in load_handlers {</div><div class="diff-removed">-            let segment = handler.join().map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Can't join segment load thread: {:?}",</div><div class="diff-removed">-                    err.type_id()</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })??;</div><div class="diff-removed">-</div><div class="diff-removed">-            let Some(segment) = segment else {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            collection_config_read</div><div class="diff-removed">-                .params</div><div class="diff-removed">-                .vectors</div><div class="diff-removed">-                .check_compatible_with_segment_config(&segment.config().vector_data, true)?;</div><div class="diff-removed">-            collection_config_read</div><div class="diff-removed">-                .params</div><div class="diff-removed">-                .sparse_vectors</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .map(|sparse_vectors| {</div><div class="diff-removed">-                    check_sparse_compatible_with_segment_config(</div><div class="diff-removed">-                        sparse_vectors,</div><div class="diff-removed">-                        &segment.config().sparse_vector_data,</div><div class="diff-removed">-                        true,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .unwrap_or(Ok(()))?;</div><div class="diff-removed">-</div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let res = segment_holder.deduplicate_points().await?;</div><div class="diff-removed">-        if res > 0 {</div><div class="diff-removed">-            log::debug!("Deduplicated {res} points");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        clear_temp_segments(shard_path);</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &collection_config_read.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &collection_config_read.hnsw_config,</div><div class="diff-removed">-            &collection_config_read.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(collection_config_read); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let clocks = LocalShardClocks::load(shard_path)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Always make sure we have any appendable segments, needed for update operations</div><div class="diff-removed">-        if !segment_holder.has_appendable_segment() {</div><div class="diff-removed">-            debug_assert!(</div><div class="diff-removed">-                false,</div><div class="diff-removed">-                "Shard has no appendable segments, this should never happen",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            log::warn!(</div><div class="diff-removed">-                "Shard has no appendable segments, this should never happen. Creating new appendable segment now",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            let segments_path = LocalShard::segments_path(shard_path);</div><div class="diff-removed">-            let collection_params = collection_config.read().await.params.clone();</div><div class="diff-removed">-            let payload_index_schema = payload_index_schema.read();</div><div class="diff-removed">-            segment_holder.create_appendable_segment(</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                &collection_params,</div><div class="diff-removed">-                &payload_index_schema,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let local_shard = LocalShard::new(</div><div class="diff-removed">-            segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            clocks,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Apply outstanding operations from WAL</div><div class="diff-removed">-        local_shard.load_from_wal(collection_id).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(local_shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn shard_path(&self) -> PathBuf {</div><div class="diff-removed">-        self.path.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn wal_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(WAL_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn segments_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(SEGMENTS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build_local(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        // initialize local shard config file</div><div class="diff-removed">-        let local_shard_config = ShardConfig::new_replica_set();</div><div class="diff-removed">-        let shard = Self::build(</div><div class="diff-removed">-            id,</div><div class="diff-removed">-            collection_id,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            effective_optimizers_config,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await?;</div><div class="diff-removed">-        local_shard_config.save(shard_path)?;</div><div class="diff-removed">-        Ok(shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        let config = collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal_path = Self::wal_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&wal_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard wal directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&segments_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard segments directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut segment_holder = SegmentHolder::default();</div><div class="diff-removed">-        let mut build_handlers = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_params = config.params.to_base_vector_data()?;</div><div class="diff-removed">-        let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div class="diff-removed">-        let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        for _sid in 0..segment_number {</div><div class="diff-removed">-            let path_clone = segments_path.clone();</div><div class="diff-removed">-            let segment_config = SegmentConfig {</div><div class="diff-removed">-                vector_data: vector_params.clone(),</div><div class="diff-removed">-                sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-removed">-                payload_storage_type: config.params.payload_storage_type(),</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let segment = thread::Builder::new()</div><div class="diff-removed">-                .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            build_handlers.push(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let join_results = build_handlers</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|handler| handler.join())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for join_result in join_results {</div><div class="diff-removed">-            let segment = join_result.map_err(|err| {</div><div class="diff-removed">-                let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-removed">-                let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-removed">-</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Segment DB create panicked{separator}{message}",</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })??;</div><div class="diff-removed">-</div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-removed">-            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection = LocalShard::new(</div><div class="diff-removed">-            segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            LocalShardClocks::default(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(collection)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn stop_flush_worker(&self) {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.stop_flush_worker()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.wait_workers_stops().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Loads latest collection operations from WAL</div><div class="diff-removed">-    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-removed">-        let wal = self.wal.wal.lock().await;</div><div class="diff-removed">-        let bar = ProgressBar::new(wal.len(false));</div><div class="diff-removed">-</div><div class="diff-removed">-        let progress_style = ProgressStyle::default_bar()</div><div class="diff-removed">-            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")</div><div class="diff-removed">-            .expect("Failed to create progress style");</div><div class="diff-removed">-        bar.set_style(progress_style);</div><div class="diff-removed">-</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Recovering shard {} starting reading WAL from {}",</div><div class="diff-removed">-            self.path.display(),</div><div class="diff-removed">-            wal.first_index(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.set_message(format!("Recovering collection {collection_id}"));</div><div class="diff-removed">-        let segments = self.segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Fall back to basic text output if the progress bar is hidden (e.g. not a tty)</div><div class="diff-removed">-        let show_progress_bar = !bar.is_hidden();</div><div class="diff-removed">-        let mut last_progress_report = Instant::now();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovering shard {}: 0/{} (0%)",</div><div class="diff-removed">-                self.path.display(),</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div class="diff-removed">-        // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div class="diff-removed">-        // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div class="diff-removed">-        // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div class="diff-removed">-        // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div class="diff-removed">-        // index *occasionally*), but the storage can handle it.</div><div class="diff-removed">-</div><div class="diff-removed">-        for (op_num, update) in wal.read_all(false) {</div><div class="diff-removed">-            if let Some(clock_tag) = update.clock_tag {</div><div class="diff-removed">-                newest_clocks.advance_clock(clock_tag);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate `CollectionError::ServiceError`, but skip other error types.</div><div class="diff-removed">-            match &CollectionUpdater::update(</div><div class="diff-removed">-                segments,</div><div class="diff-removed">-                op_num,</div><div class="diff-removed">-                update.operation,</div><div class="diff-removed">-                &HardwareCounterCell::disposable(), // Internal operation, no measurement needed.</div><div class="diff-removed">-            ) {</div><div class="diff-removed">-                Err(err @ CollectionError::ServiceError { error, backtrace }) => {</div><div class="diff-removed">-                    let path = self.path.display();</div><div class="diff-removed">-</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Can't apply WAL operation: {error}, \</div><div class="diff-removed">-                         collection: {collection_id}, \</div><div class="diff-removed">-                         shard: {path}, \</div><div class="diff-removed">-                         op_num: {op_num}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-</div><div class="diff-removed">-                    if let Some(backtrace) = &backtrace {</div><div class="diff-removed">-                        log::error!("Backtrace: {backtrace}");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::OutOfMemory { .. }) => {</div><div class="diff-removed">-                    log::error!("{err}");</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),</div><div class="diff-removed">-                Err(err) => log::error!("{err}"),</div><div class="diff-removed">-                Ok(_) => (),</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Update progress bar or show text progress every WAL_LOAD_REPORT_EVERY</div><div class="diff-removed">-            bar.inc(1);</div><div class="diff-removed">-            if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div class="diff-removed">-                let progress = bar.position();</div><div class="diff-removed">-                log::info!(</div><div class="diff-removed">-                    "{progress}/{} ({}%)",</div><div class="diff-removed">-                    wal.len(false),</div><div class="diff-removed">-                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                last_progress_report = Instant::now();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // It is possible, that after recovery, if WAL flush was not enforced.</div><div class="diff-removed">-            // We could be left with some un-versioned points.</div><div class="diff-removed">-            // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                match segment {</div><div class="diff-removed">-                    LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                        raw_segment.write().cleanup_versions()?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                        debug_assert!(false, "Proxy segment found in load_from_wal");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-removed">-            // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-removed">-            // version.</div><div class="diff-removed">-            segments.flush_all(true, true)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.finish();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        // makes sure that the Stop signal is the last one in this channel</div><div class="diff-removed">-        let old_sender = self.update_sender.swap(Arc::new(update_sender));</div><div class="diff-removed">-        old_sender.send(UpdateSignal::Stop).await?;</div><div class="diff-removed">-        update_handler.stop_flush_worker();</div><div class="diff-removed">-</div><div class="diff-removed">-        update_handler.wait_workers_stops().await?;</div><div class="diff-removed">-        let new_optimizers = build_optimizers(</div><div class="diff-removed">-            &self.path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &config.optimizer_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        update_handler.optimizers = new_optimizers;</div><div class="diff-removed">-        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div class="diff-removed">-        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div class="diff-removed">-    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-removed">-            if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update read rate limiter</div><div class="diff-removed">-                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-removed">-                    let new_read_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-removed">-                    self.read_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-removed">-                    return;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // remove read rate limiter for all other situations</div><div class="diff-removed">-        self.read_rate_limiter.take();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn trigger_optimizers(&self) {</div><div class="diff-removed">-        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-removed">-        // - If receiver is already dead - we do not care</div><div class="diff-removed">-        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Finishes ongoing update tasks</div><div class="diff-removed">-    pub async fn stop_gracefully(&self) {</div><div class="diff-removed">-        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-removed">-            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.stop_flush_worker().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-removed">-            log::warn!("Update workers failed with: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div class="diff-removed">-        // Read dir first as the directory contents would change during restore</div><div class="diff-removed">-        let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Filter out hidden entries</div><div class="diff-removed">-        let entries = entries.into_iter().filter(|entry| {</div><div class="diff-removed">-            let is_hidden = entry</div><div class="diff-removed">-                .file_name()</div><div class="diff-removed">-                .to_str()</div><div class="diff-removed">-                .is_some_and(|s| s.starts_with('.'));</div><div class="diff-removed">-            if is_hidden {</div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Ignoring hidden segment in local shard during snapshot recovery: {}",</div><div class="diff-removed">-                    entry.path().display(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-            !is_hidden</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        for entry in entries {</div><div class="diff-removed">-            Segment::restore_snapshot_in_place(&entry.path())?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div class="diff-removed">-    pub async fn create_snapshot(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-        format: SnapshotFormat,</div><div class="diff-removed">-        save_wal: bool,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        let wal = self.wal.wal.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if !save_wal {</div><div class="diff-removed">-            // If we are not saving WAL, we still need to make sure that all submitted by this point</div><div class="diff-removed">-            // updates have made it to the segments. So we use the Plunger to achieve that.</div><div class="diff-removed">-            // It will notify us when all submitted updates so far have been processed.</div><div class="diff-removed">-            let (tx, rx) = oneshot::channel();</div><div class="diff-removed">-            let plunger = UpdateSignal::Plunger(tx);</div><div class="diff-removed">-            self.update_sender.load().send(plunger).await?;</div><div class="diff-removed">-            rx.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(&self.path);</div><div class="diff-removed">-        let collection_params = self.collection_config.read().await.params.clone();</div><div class="diff-removed">-        let temp_path = temp_path.to_owned();</div><div class="diff-removed">-        let payload_index_schema = self.payload_index_schema.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar_c = tar.clone();</div><div class="diff-removed">-        tokio::task::spawn_blocking(move || {</div><div class="diff-removed">-            // Do not change segments while snapshotting</div><div class="diff-removed">-            SegmentHolder::snapshot_all_segments(</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                Some(&collection_params),</div><div class="diff-removed">-                &payload_index_schema.read().clone(),</div><div class="diff-removed">-                &temp_path,</div><div class="diff-removed">-                &tar_c.descend(Path::new(SEGMENTS_PATH))?,</div><div class="diff-removed">-                format,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if save_wal {</div><div class="diff-removed">-                // snapshot all shard's WAL</div><div class="diff-removed">-                Self::snapshot_wal(wal, &tar_c)</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                Self::snapshot_empty_wal(wal, &temp_path, &tar_c)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .await??;</div><div class="diff-removed">-</div><div class="diff-removed">-        LocalShardClocks::archive_data(&self.path, tar).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create empty WAL which is compatible with currently stored data</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_empty_wal(</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let (segment_capacity, latest_op_num) = {</div><div class="diff-removed">-            let wal_guard = wal.blocking_lock();</div><div class="diff-removed">-            (wal_guard.segment_capacity(), wal_guard.last_index())</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = tempfile::tempdir_in(temp_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can not create temporary directory for WAL: {err}",</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Wal::generate_empty_wal_starting_at_index(</div><div class="diff-removed">-            temp_dir.path(),</div><div class="diff-removed">-            &WalOptions {</div><div class="diff-removed">-                segment_capacity,</div><div class="diff-removed">-                segment_queue_len: 0,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            latest_op_num,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Error while create empty WAL: {err}"))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-            })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// snapshot WAL</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        // lock wal during snapshot</div><div class="diff-removed">-        let mut wal_guard = wal.blocking_lock();</div><div class="diff-removed">-        wal_guard.flush()?;</div><div class="diff-removed">-        let source_wal_path = wal_guard.path();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar = tar.descend(Path::new(WAL_PATH))?;</div><div class="diff-removed">-        for entry in std::fs::read_dir(source_wal_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-        })? {</div><div class="diff-removed">-            let entry = entry.map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if entry.file_name() == ".wal" {</div><div class="diff-removed">-                // This sentinel file is used for WAL locking. Trying to archive</div><div class="diff-removed">-                // or open it will cause the following error on Windows:</div><div class="diff-removed">-                // > The process cannot access the file because another process</div><div class="diff-removed">-                // > has locked a portion of the file. (os error 33)</div><div class="diff-removed">-                // https://github.com/qdrant/wal/blob/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual)::new(&entry.file_name()))</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-removed">-        self.segments()</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .segment_manifests()</div><div class="diff-removed">-            .map_err(CollectionError::from)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn estimate_cardinality<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CollectionResult<CardinalityEstimation> {</div><div class="diff-removed">-        let segments = self.segments().read();</div><div class="diff-removed">-        let cardinality = segments</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_id, segment)| {</div><div class="diff-removed">-                segment</div><div class="diff-removed">-                    .get()</div><div class="diff-removed">-                    .read()</div><div class="diff-removed">-                    .estimate_point_count(filter, hw_counter)</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .fold(CardinalityEstimation::exact(0), |acc, x| {</div><div class="diff-removed">-                CardinalityEstimation {</div><div class="diff-removed">-                    primary_clauses: vec![],</div><div class="diff-removed">-                    min: acc.min + x.min,</div><div class="diff-removed">-                    exp: acc.exp + x.exp,</div><div class="diff-removed">-                    max: acc.max + x.max,</div><div class="diff-removed">-                }</div><div class="diff-removed">-            });</div><div class="diff-removed">-        Ok(cardinality)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn read_filtered<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_counter: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Red status on failed operation or optimizer error</div><div class="diff-removed">-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {</div><div class="diff-removed">-                let optimizer_status = segments</div><div class="diff-removed">-                    .optimizer_errors</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .map_or(OptimizersStatus::Ok, |err| {</div><div class="diff-removed">-                        OptimizersStatus::Error(err.to_string())</div><div class="diff-removed">-                    });</div><div class="diff-removed">-                return (ShardStatus::Red, optimizer_status);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Yellow status if we have a special segment, indicates a proxy segment used during optimization</div><div class="diff-removed">-            // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div class="diff-removed">-            let has_special_segment = segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-removed">-                .any(|segment_type| segment_type == SegmentType::Special);</div><div class="diff-removed">-            if has_special_segment {</div><div class="diff-removed">-                return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Yellow or grey status if there are pending optimizations</div><div class="diff-removed">-        // Grey if optimizers were not triggered yet after restart,</div><div class="diff-removed">-        // we don't automatically trigger them to prevent a crash loop</div><div class="diff-removed">-        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self</div><div class="diff-removed">-            .update_handler</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .check_optimizer_conditions();</div><div class="diff-removed">-        if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-removed">-                ShardStatus::Yellow</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                ShardStatus::Grey</div><div class="diff-removed">-            };</div><div class="diff-removed">-            return (status, OptimizersStatus::Ok);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Green status because everything is fine</div><div class="diff-removed">-        (ShardStatus::Green, OptimizersStatus::Ok)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_info(&self) -> ShardInfoInternal {</div><div class="diff-removed">-        let collection_config = self.collection_config.read().await.clone();</div><div class="diff-removed">-        let mut vectors_count = 0;</div><div class="diff-removed">-        let mut indexed_vectors_count = 0;</div><div class="diff-removed">-        let mut points_count = 0;</div><div class="diff-removed">-        let mut segments_count = 0;</div><div class="diff-removed">-        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                segments_count += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_info = segment.get().read().info();</div><div class="diff-removed">-</div><div class="diff-removed">-                vectors_count += segment_info.num_vectors;</div><div class="diff-removed">-                indexed_vectors_count += segment_info.num_indexed_vectors;</div><div class="diff-removed">-                points_count += segment_info.num_points;</div><div class="diff-removed">-                for (key, val) in segment_info.index_schema {</div><div class="diff-removed">-                    schema</div><div class="diff-removed">-                        .entry(key)</div><div class="diff-removed">-                        .and_modify(|entry| entry.points += val.points)</div><div class="diff-removed">-                        .or_insert(val);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let (status, optimizer_status) = self.local_shard_status().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        ShardInfoInternal {</div><div class="diff-removed">-            status,</div><div class="diff-removed">-            optimizer_status,</div><div class="diff-removed">-            vectors_count,</div><div class="diff-removed">-            indexed_vectors_count,</div><div class="diff-removed">-            points_count,</div><div class="diff-removed">-            segments_count,</div><div class="diff-removed">-            config: collection_config,</div><div class="diff-removed">-            payload_schema: schema,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_read_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        context: &str,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-removed">-                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl Drop for LocalShard {</div><div class="diff-removed">-    fn drop(&mut self) {</div><div class="diff-removed">-        thread::scope(|s| {</div><div class="diff-removed">-            let handle = thread::Builder::new()</div><div class="diff-removed">-                .name("drop-shard".to_string())</div><div class="diff-removed">-                .spawn_scoped(s, || {</div><div class="diff-removed">-                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.</div><div class="diff-removed">-                    self.update_runtime</div><div class="diff-removed">-                        .block_on(async { self.stop_gracefully().await })</div><div class="diff-removed">-                });</div><div class="diff-removed">-            handle.expect("Failed to create thread for shard drop");</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-added">+    // ... rest of the implementation ...</div><div> }</div><div> </div><div> /// Convenience struct for combining clock maps belonging to a shard</div><div class="diff-info">@@ -1184,91 +166,9 @@ impl LocalShardClocks {</div><div>     fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {</div><div>         Self {</div><div>             newest_clocks: Arc::new(Mutex::new(newest_clocks)),</div><div class="diff-removed">-            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Load clock maps from disk</div><div class="diff-removed">-    pub fn load(shard_path: &Path) -> CollectionResult<Self> {</div><div class="diff-removed">-        let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let oldest_clocks = ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(Self::new(newest_clocks, oldest_clocks))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Persist clock maps to disk</div><div class="diff-removed">-    pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        self.oldest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.newest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Put clock data from the disk into an archive.</div><div class="diff-removed">-    pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&newest_clocks_from, Path::new(NEWEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&oldest_clocks_from, Path::new(OLDEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Move clock data on disk from one shard path to another.</div><div class="diff-removed">-    pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            let newest_clocks_to = Self::newest_clocks_path(to);</div><div class="diff-removed">-            move_file(newest_clocks_from, newest_clocks_to).await?;</div><div class="diff-added">+            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)), </div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            let oldest_clocks_to = Self::oldest_clocks_path(to);</div><div class="diff-removed">-            move_file(oldest_clocks_from, oldest_clocks_to).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Delete clock data from disk at the given shard path.</div><div class="diff-removed">-    pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_path = Self::newest_clocks_path(shard_path);</div><div class="diff-removed">-        let oldest_clocks_path = Self::oldest_clocks_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(newest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(oldest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn newest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(NEWEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn oldest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(OLDEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-added">+    // ... rest of the implementation ...</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    