<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/segments_searcher.rs - Sonnet 3.6</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/segments_searcher.rs</h1>
        <p><a href="../../models/anthropic_claude-3.5-sonnet.html">‚Üê Back to Sonnet 3.6 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.6</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 67928</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 90525</p>
                <p><strong>Native Completion Tokens:</strong> 8193</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> length</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.39447</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual)@@ -39,7 +39,7 @@ </div><div> // batch -> point for one segment</div><div> type SegmentBatchSearchResult = Vec<Vec<ScoredPoint>>;</div><div class="diff-removed">-// Segment -> batch -> point</div><div class="diff-added">+// Segment -> batch -> point  </div><div> type BatchSearchResult = Vec<SegmentBatchSearchResult>;</div><div> </div><div> // Result of batch search in one segment</div><div class="diff-info">@@ -59,7 +59,7 @@ </div><div>         let mut search_results_per_segment_res = FuturesUnordered::new();</div><div>         for (idx, search) in searches.into_iter().enumerate() {</div><div class="diff-removed">-            // map the result to include the request index for later reordering</div><div class="diff-added">+            // map the result to include the request index for later reordering  </div><div>             let result_with_request_index = search.map(move |res| res.map(|s| (idx, s)));</div><div>             search_results_per_segment_res.push(result_with_request_index);</div><div>         }</div><div class="diff-info">@@ -77,7 +77,7 @@     }</div><div> </div><div>     /// Processes search result of `[segment_size x batch_size]`.</div><div class="diff-removed">-    ///</div><div class="diff-added">+    /// </div><div>     /// # Arguments</div><div>     /// * `search_result` - `[segment_size x batch_size]`</div><div>     /// * `limits` - `[batch_size]` - how many results to return for each batched request</div><div class="diff-info">@@ -94,14 +94,15 @@     ) {</div><div>         let number_segments = search_result.len();</div><div>         let batch_size = limits.len();</div><div class="diff-removed">-</div><div class="diff-added">+        </div><div>         // The lowest scored element must be larger or equal to the worst scored element in each segment.</div><div>         // Otherwise, the sampling is invalid and some points might be missing.</div><div>         // e.g. with 3 segments with the following sampled ranges:</div><div>         // s1 - [0.91 -> 0.87]</div><div class="diff-removed">-        // s2 - [0.92 -> 0.86]</div><div class="diff-added">+        // s2 - [0.92 -> 0.86] </div><div>         // s3 - [0.93 -> 0.85]</div><div class="diff-removed">-        // If the top merged scores result range is [0.93 -> 0.86] then we do not know if s1 could have contributed more points at the lower part between [0.87 -> 0.86]</div><div class="diff-added">+        // If the top merged scores result range is [0.93 -> 0.86] then we do not know if s1 could have contributed </div><div class="diff-added">+        // more points at the lower part between [0.87 -> 0.86]</div><div>         // In that case, we need to re-run the search without sampling on that segment.</div><div> </div><div>         // Initialize result aggregators for each batched request</div><div class="diff-info">@@ -110,7 +111,7 @@ </div><div>         // Therefore we need to track the lowest scored element per segment for each batch</div><div>         let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![</div><div class="diff-removed">-            vec![f32::max_value(); batch_size]; // initial max score value for each batch</div><div class="diff-added">+            vec![f32::max_value(); batch_size]; // initial max score value for each batch </div><div>             number_segments</div><div>         ];</div><div> </div><div class="diff-info">@@ -121,7 +122,7 @@ </div><div>         // Batch results merged from all segments</div><div>         for (segment_idx, segment_result) in search_result.into_iter().enumerate() {</div><div class="diff-removed">-            // merge results for each batch search request across segments</div><div class="diff-added">+            // merge results for each batch search request across segments </div><div>             for (batch_req_idx, query_res) in segment_result.into_iter().enumerate() {</div><div>                 retrieved_points_per_request[segment_idx][batch_req_idx] = query_res.len();</div><div>                 lowest_scores_per_request[segment_idx][batch_req_idx] = query_res</div><div class="diff-info">@@ -146,7 +147,7 @@                     let retrieved_points = retrieved_points_per_request[segment_id][batch_id];</div><div>                     let have_further_results = further_results[segment_id][batch_id];</div><div> </div><div class="diff-removed">-                    if have_further_results</div><div class="diff-added">+                    if have_further_results  </div><div>                         && retrieved_points < required_limit</div><div>                         && segment_lowest_score >= lowest_batch_score</div><div>                     {</div><div class="diff-info">@@ -157,7 +158,7 @@                         // the lowest score in the batch. In that case, we need to re-run the search</div><div>                         // without sampling on that segment.</div><div>                         searches_to_rerun</div><div class="diff-removed">-                            .entry(segment_id)</div><div class="diff-added">+                            .entry(segment_id) </div><div>                             .or_default()</div><div>                             .push(batch_id);</div><div>                     }</div><div class="diff-info">@@ -171,7 +172,7 @@     pub async fn prepare_query_context(</div><div>         segments: LockedSegmentHolder,</div><div>         batch_request: &CoreSearchRequestBatch,</div><div class="diff-removed">-        collection_config: &CollectionConfigInternal,</div><div class="diff-added">+        collection_config: &CollectionConfigInternal, </div><div>         is_stopped_guard: &StoppingGuard,</div><div>         hw_measurement_acc: HwMeasurementAcc,</div><div>     ) -> CollectionResult<Option<QueryContext>> {</div><div class="diff-info">@@ -190,12 +191,12 @@             collection_config.params.get_distance(vector_name)?;</div><div>             if let Some(sparse_vector_params) = collection_config</div><div>                 .params</div><div class="diff-removed">-                .get_sparse_vector_params_opt(vector_name)</div><div class="diff-added">+                .get_sparse_vector_params_opt(vector_name)  </div><div>             {</div><div>                 if sparse_vector_params.modifier == Some(Modifier::Idf)</div><div>                     && !idf_vectors.contains(&vector_name)</div><div>                 {</div><div class="diff-removed">-                    idf_vectors.push(vector_name);</div><div class="diff-added">+                    idf_vectors.push(vector_name);  </div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-info">@@ -228,6 +229,29 @@                 }</div><div> </div><div>                 let segments = segments.non_appendable_then_appendable_segments();</div><div class="diff-added">+                let available_point_count = segments</div><div class="diff-added">+                    .map(|segment| segment.get().read().available_point_count())</div><div class="diff-added">+                    .sum();</div><div class="diff-added">+                Some(available_point_count) </div><div class="diff-added">+            })</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        let Some(available_point_count) = task.await? else {</div><div class="diff-added">+            return Ok(None);</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        // Do blocking calls in a blocking task: `segment.get().read()` calls might block async runtime </div><div class="diff-added">+        let task = {</div><div class="diff-added">+            let segments = segments.clone();</div><div class="diff-added">+</div><div class="diff-added">+            tokio::task::spawn_blocking(move || {</div><div class="diff-added">+                let segments = segments.read();</div><div class="diff-added">+</div><div class="diff-added">+                if segments.is_empty() {</div><div class="diff-added">+                    return None; </div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+                let segments = segments.non_appendable_then_appendable_segments();</div><div>                 for locked_segment in segments {</div><div>                     let segment = locked_segment.get();</div><div>                     let segment_guard = segment.read();</div><div class="diff-info">@@ -260,7 +284,7 @@             // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.</div><div>             // With probabilistic sampling we determine a smaller sampling limit for each segment.</div><div>             // Use probabilistic sampling if:</div><div class="diff-removed">-            // - sampling is enabled</div><div class="diff-added">+            // - sampling is enabled  </div><div>             // - more than 1 segment</div><div>             // - segments are not empty</div><div>             let use_sampling = sampling_enabled</div><div class="diff-info">@@ -300,15 +324,14 @@             all_search_results_per_segment,</div><div>             batch_request</div><div>                 .searches</div><div class="diff-removed">-                .iter()</div><div class="diff-added">+                .iter() </div><div>                 .map(|request| request.limit + request.offset)</div><div>                 .collect(),</div><div>             &further_results,</div><div>         );</div><div class="diff-removed">-        // The second step of the search is to re-run the search without sampling on some segments</div><div class="diff-added">+        // The second step of the search is to re-run the search without sampling on some segments  </div><div>         // Expected that this stage will be executed rarely</div><div>         if !searches_to_rerun.is_empty() {</div><div class="diff-removed">-            // TODO notify telemetry of failing sampling</div><div>             // Ensure consistent order of segment ids</div><div>             let searches_to_rerun: Vec<(SegmentOffset, Vec<BatchOffset>)> =</div><div>                 searches_to_rerun.into_iter().collect();</div><div class="diff-info">@@ -334,7 +357,7 @@                             partial_batch_request,</div><div>                             false,</div><div>                             &segment_query_context,</div><div class="diff-removed">-                        )</div><div class="diff-added">+                        ) </div><div>                     }))</div><div>                 }</div><div>                 res</div><div class="diff-info">@@ -368,7 +391,7 @@     }</div><div> </div><div>     /// Retrieve records for the given points ids from the segments</div><div class="diff-removed">-    /// - if payload is enabled, payload will be fetched</div><div class="diff-added">+    /// - if payload is enabled, payload will be fetched </div><div>     /// - if vector is enabled, vector will be fetched</div><div>     ///</div><div>     /// The points ids can contain duplicates, the records will be fetched only once</div><div class="diff-info">@@ -390,7 +413,6 @@                 let with_payload = with_payload.clone();</div><div>                 let with_vector = with_vector.clone();</div><div>                 let is_stopped = stopping_guard.get_is_stopped();</div><div class="diff-removed">-                // TODO create one Task per segment level retrieve</div><div>                 move || {</div><div>                     Self::retrieve_blocking(</div><div>                         segments,</div><div class="diff-info">@@ -451,14 +473,14 @@                                     hw_counter</div><div>                                         .vector_io_read()</div><div>                                         .incr_delta(vectors.estimate_size_in_bytes());</div><div class="diff-removed">-                                    Some(VectorStructInternal::from(vectors))</div><div class="diff-added">+                                    Some(VectorStructInternal::from(vectors))  </div><div>                                 }</div><div>                                 WithVector::Bool(false) => None,</div><div>                                 WithVector::Selector(vector_names) => {</div><div>                                     let mut selected_vectors = NamedVectors::default();</div><div>                                     for vector_name in vector_names {</div><div>                                         if let Some(vector) = segment.vector(vector_name, id)? {</div><div class="diff-removed">-                                            selected_vectors.insert(vector_name.clone(), vector);</div><div class="diff-added">+                                            selected_vectors.insert(vector_name.clone(), vector); </div><div>                                         }</div><div>                                     }</div><div>                                     hw_counter</div><div class="diff-info">@@ -473,7 +495,7 @@                     },</div><div>                 );</div><div>                 *version_entry.or_default() = version;</div><div class="diff-removed">-</div><div class="diff-added">+                </div><div>                 Ok(true)</div><div>             })?;</div><div> </div><div class="diff-info">@@ -481,7 +503,7 @@     }</div><div> </div><div>     pub async fn read_filtered(</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-added">+        segments: LockedSegmentHolder, </div><div>         filter: Option<&Filter>,</div><div>         runtime_handle: &Handle,</div><div>         hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-info">@@ -496,13 +518,10 @@                 let all_points: BTreeSet<_> = segments</div><div>                     .non_appendable_then_appendable_segments()</div><div>                     .flat_map(|segment| {</div><div class="diff-removed">-                        segment.get().read().read_filtered(</div><div class="diff-removed">-                            None,</div><div class="diff-removed">-                            None,</div><div class="diff-removed">-                            filter.as_ref(),</div><div class="diff-removed">-                            &is_stopped,</div><div class="diff-removed">-                            &hw_counter,</div><div class="diff-removed">-                        )</div><div class="diff-added">+                        segment</div><div class="diff-added">+                            .get()</div><div class="diff-added">+                            .read() </div><div class="diff-added">+                            .read_filtered(None, None, filter.as_ref(), &is_stopped, &hw_counter)</div><div>                     })</div><div>                     .collect();</div><div>                 Ok(all_points)</div><div class="diff-info">@@ -547,7 +566,7 @@         }</div><div> </div><div>         // use aggregator with only one "batch"</div><div class="diff-removed">-        let mut aggregator = BatchResultAggregator::new(std::iter::once(limit));</div><div class="diff-added">+        let mut aggregator = BatchResultAggregator::new(std::iter::once(limit)); </div><div>         aggregator.update_point_versions(segments_results.iter().flatten());</div><div>         aggregator.update_batch_results(0, segments_results.into_iter().flatten());</div><div>         let top =</div><div class="diff-info">@@ -559,7 +578,7 @@     }</div><div> }</div><div> </div><div class="diff-removed">-#[derive(PartialEq, Default, Debug)]</div><div class="diff-added">+#[derive(PartialEq, Default, Debug)]  </div><div> pub enum SearchType {</div><div>     #[default]</div><div>     Nearest,</div><div class="diff-info">@@ -575,7 +594,7 @@             QueryEnum::Nearest(_) => Self::Nearest,</div><div>             QueryEnum::RecommendBestScore(_) => Self::RecommendBestScore,</div><div>             QueryEnum::RecommendSumScores(_) => Self::RecommendSumScores,</div><div class="diff-removed">-            QueryEnum::Discover(_) => Self::Discover,</div><div class="diff-added">+            QueryEnum::Discover(_) => Self::Discover, </div><div>             QueryEnum::Context(_) => Self::Context,</div><div>         }</div><div>     }</div><div class="diff-info">@@ -592,7 +611,6 @@     pub params: Option<&'a SearchParams>,</div><div> }</div><div> </div><div class="diff-removed">-/// Returns suggested search sampling size for a given number of points and required limit.</div><div> fn sampling_limit(</div><div>     limit: usize,</div><div>     ef_limit: Option<usize>,</div><div class="diff-info">@@ -611,9 +629,11 @@     let effective = ef_limit.map_or(limit, |ef_limit| {</div><div>         effective_limit(limit, ef_limit, poisson_sampling)</div><div>     });</div><div class="diff-added">+</div><div>     log::trace!(</div><div>         "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",</div><div>     );</div><div class="diff-added">+</div><div>     effective</div><div> }</div><div> </div><div class="diff-info">@@ -623,7 +643,7 @@     poisson_sampling.max(ef_limit).min(limit)</div><div> }</div><div> </div><div class="diff-removed">-/// Process sequentially contiguous batches</div><div class="diff-added">+/// Search inside a segment</div><div> ///</div><div> /// # Arguments</div><div> ///</div><div class="diff-info">@@ -640,7 +660,7 @@ fn search_in_segment(</div><div>     segment: LockedSegment,</div><div>     request: Arc<CoreSearchRequestBatch>,</div><div class="diff-removed">-    use_sampling: bool,</div><div class="diff-added">+    use_sampling: bool,  </div><div>     segment_query_context: &SegmentQueryContext,</div><div> ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {</div><div>     let batch_size = request.searches.len();</div><div class="diff-info">@@ -679,7 +699,7 @@                     &segment,</div><div>                     &vectors_batch,</div><div>                     &prev_params,</div><div class="diff-removed">-                    use_sampling,</div><div class="diff-added">+                    use_sampling,  </div><div>                     segment_query_context,</div><div>                 )?;</div><div>                 further_results.append(&mut further);</div><div class="diff-info">@@ -741,286 +761,4 @@         search_params.vector_name,</div><div>         vectors_batch,</div><div>         &search_params.with_payload,</div><div class="diff-removed">-        &search_params.with_vector,</div><div class="diff-removed">-        search_params.filter,</div><div class="diff-removed">-        top,</div><div class="diff-removed">-        search_params.params,</div><div class="diff-removed">-        segment_query_context,</div><div class="diff-removed">-    )?;</div><div class="diff-removed">-</div><div class="diff-removed">-    let further_results = res</div><div class="diff-removed">-        .iter()</div><div class="diff-removed">-        .map(|batch_result| batch_result.len() == top)</div><div class="diff-removed">-        .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-    Ok((res, further_results))</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Find the HNSW ef_construct for a named vector</div><div class="diff-removed">-///</div><div class="diff-removed">-/// If the given named vector has no HNSW index, `None` is returned.</div><div class="diff-removed">-fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Option<usize> {</div><div class="diff-removed">-    config</div><div class="diff-removed">-        .vector_data</div><div class="diff-removed">-        .get(vector_name)</div><div class="diff-removed">-        .and_then(|config| match &config.index {</div><div class="diff-removed">-            Indexes::Plain {} => None,</div><div class="diff-removed">-            Indexes::Hnsw(hnsw) => Some(hnsw),</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .map(|hnsw| hnsw.ef_construct)</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[cfg(test)]</div><div class="diff-removed">-mod tests {</div><div class="diff-removed">-    use ahash::AHashSet;</div><div class="diff-removed">-    use api::rest::SearchRequestInternal;</div><div class="diff-removed">-    use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-    use parking_lot::RwLock;</div><div class="diff-removed">-    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;</div><div class="diff-removed">-    use segment::fixtures::index_fixtures::random_vector;</div><div class="diff-removed">-    use segment::index::VectorIndexEnum;</div><div class="diff-removed">-    use segment::types::{Condition, HasIdCondition};</div><div class="diff-removed">-    use tempfile::Builder;</div><div class="diff-removed">-</div><div class="diff-removed">-    use super::*;</div><div class="diff-removed">-    use crate::collection_manager::fixtures::{build_test_holder, random_segment};</div><div class="diff-removed">-    use crate::collection_manager::holders::segment_holder::SegmentHolder;</div><div class="diff-removed">-    use crate::operations::types::CoreSearchRequest;</div><div class="diff-removed">-    use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_is_indexed_enough_condition() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment1 = random_segment(dir.path(), 10, 200, 256);</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_index = segment1</div><div class="diff-removed">-            .vector_data</div><div class="diff-removed">-            .get(DEFAULT_VECTOR_NAME)</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .vector_index</div><div class="diff-removed">-            .clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_index_borrow = vector_index.borrow();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        match &*vector_index_borrow {</div><div class="diff-removed">-            VectorIndexEnum::Plain(plain_index) => {</div><div class="diff-removed">-                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);</div><div class="diff-removed">-                assert!(!res_1);</div><div class="diff-removed">-</div><div class="diff-removed">-                let res_2 =</div><div class="diff-removed">-                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);</div><div class="diff-removed">-                assert!(res_2);</div><div class="diff-removed">-</div><div class="diff-removed">-                let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));</div><div class="diff-removed">-</div><div class="diff-removed">-                let res_3 = plain_index.is_small_enough_for_unindexed_search(</div><div class="diff-removed">-                    25,</div><div class="diff-removed">-                    Some(&ids_filter),</div><div class="diff-removed">-                    &hw_counter,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                assert!(res_3);</div><div class="diff-removed">-            }</div><div class="diff-removed">-            _ => panic!("Expected plain index"),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[tokio::test]</div><div class="diff-removed">-    async fn test_segments_search() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_holder = build_test_holder(dir.path());</div><div class="diff-removed">-</div><div class="diff-removed">-        let query = vec![1.0, 1.0, 1.0, 1.0];</div><div class="diff-removed">-</div><div class="diff-removed">-        let req = CoreSearchRequest {</div><div class="diff-removed">-            query: query.into(),</div><div class="diff-removed">-            with_payload: None,</div><div class="diff-removed">-            with_vector: None,</div><div class="diff-removed">-            filter: None,</div><div class="diff-removed">-            params: None,</div><div class="diff-removed">-            limit: 5,</div><div class="diff-removed">-            score_threshold: None,</div><div class="diff-removed">-            offset: 0,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let batch_request = CoreSearchRequestBatch {</div><div class="diff-removed">-            searches: vec![req],</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-        let result = SegmentsSearcher::search(</div><div class="diff-removed">-            Arc::new(segment_holder),</div><div class="diff-removed">-            Arc::new(batch_request),</div><div class="diff-removed">-            &Handle::current(),</div><div class="diff-removed">-            true,</div><div class="diff-removed">-            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_acc),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await</div><div class="diff-removed">-        .unwrap()</div><div class="diff-removed">-        .into_iter()</div><div class="diff-removed">-        .next()</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // eprintln!("result = {:?}", &result);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(result.len(), 5);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert!(result[0].id == 3.into() || result[0].id == 11.into());</div><div class="diff-removed">-        assert!(result[1].id == 3.into() || result[1].id == 11.into());</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[tokio::test]</div><div class="diff-removed">-    async fn test_segments_search_sampling() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment1 = random_segment(dir.path(), 10, 2000, 4);</div><div class="diff-removed">-        let segment2 = random_segment(dir.path(), 10, 4000, 4);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let _sid1 = holder.add_new(segment1);</div><div class="diff-removed">-        let _sid2 = holder.add_new(segment2);</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_holder = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut rnd = rand::rng();</div><div class="diff-removed">-</div><div class="diff-removed">-        for _ in 0..100 {</div><div class="diff-removed">-            let req1 = SearchRequestInternal {</div><div class="diff-removed">-                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-removed">-                limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-removed">-                offset: None,</div><div class="diff-removed">-                with_payload: None,</div><div class="diff-removed">-                with_vector: None,</div><div class="diff-removed">-                filter: None,</div><div class="diff-removed">-                params: None,</div><div class="diff-removed">-                score_threshold: None,</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let req2 = SearchRequestInternal {</div><div class="diff-removed">-                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-removed">-                limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-removed">-                offset: None,</div><div class="diff-removed">-                filter: None,</div><div class="diff-removed">-                params: None,</div><div class="diff-removed">-                with_payload: None,</div><div class="diff-removed">-                with_vector: None,</div><div class="diff-removed">-                score_threshold: None,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            let batch_request = CoreSearchRequestBatch {</div><div class="diff-removed">-                searches: vec![req1.into(), req2.into()],</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            let batch_request = Arc::new(batch_request);</div><div class="diff-removed">-</div><div class="diff-removed">-            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-            let result_no_sampling = SegmentsSearcher::search(</div><div class="diff-removed">-                segment_holder.clone(),</div><div class="diff-removed">-                batch_request.clone(),</div><div class="diff-removed">-                &Handle::current(),</div><div class="diff-removed">-                false,</div><div class="diff-removed">-                query_context,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-            assert!(!result_no_sampling.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-            let result_sampling = SegmentsSearcher::search(</div><div class="diff-removed">-                segment_holder.clone(),</div><div class="diff-removed">-                batch_request,</div><div class="diff-removed">-                &Handle::current(),</div><div class="diff-removed">-                true,</div><div class="diff-removed">-                query_context,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            assert!(!result_sampling.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-            // assert equivalence in depth</div><div class="diff-removed">-            assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());</div><div class="diff-removed">-            assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());</div><div class="diff-removed">-</div><div class="diff-removed">-            for (no_sampling, sampling) in</div><div class="diff-removed">-                result_no_sampling[0].iter().zip(result_sampling[0].iter())</div><div class="diff-removed">-            {</div><div class="diff-removed">-                assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_retrieve() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segment_holder = build_test_holder(dir.path());</div><div class="diff-removed">-        let records = SegmentsSearcher::retrieve_blocking(</div><div class="diff-removed">-            Arc::new(segment_holder),</div><div class="diff-removed">-            &[1.into(), 2.into(), 3.into()],</div><div class="diff-removed">-            &WithPayload::from(true),</div><div class="diff-removed">-            &true.into(),</div><div class="diff-removed">-            &AtomicBool::new(false),</div><div class="diff-removed">-            HwMeasurementAcc::new(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        assert_eq!(records.len(), 3);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit_ef() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit_high() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Tests whether calculating the effective ef limit value is correct.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Because there was confusion about what the effective value should be for some input</div><div class="diff-removed">-    /// combinations, we decided to write this tests to ensure correctness.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// See: <https://github.com/qdrant/qdrant/pull/1694></div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_effective_limit() {</div><div class="diff-removed">-        // Test cases to assert: (limit, ef_limit, poisson_sampling, effective)</div><div class="diff-removed">-        let tests = [</div><div class="diff-removed">-            (1000, 128, 150, 150),</div><div class="diff-removed">-            (1000, 128, 110, 128),</div><div class="diff-removed">-            (130, 128, 150, 130),</div><div class="diff-removed">-            (130, 128, 110, 128),</div><div class="diff-removed">-            (50, 128, 150, 50),</div><div class="diff-removed">-            (50, 128, 110, 50),</div><div class="diff-removed">-            (500, 1000, 300, 500),</div><div class="diff-removed">-            (500, 400, 300, 400),</div><div class="diff-removed">-            (1000, 0, 150, 150),</div><div class="diff-removed">-            (1000, 0, 110, 110),</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective)| assert_eq!(</div><div class="diff-removed">-            effective_limit(limit, ef_limit, poisson_sampling),</div><div class="diff-removed">-            effective,</div><div class="diff-removed">-            "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",</div><div class="diff-removed">-        ));</div><div class="diff-removed">-    }</div><div class="diff-removed">-}+        &search_params.with</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    