<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/App.zig - o4-mini-high</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/App.zig</h1>
        <p><a href="../../models/openai_o4-mini-high.html">‚Üê Back to o4-mini-high Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-high</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 66425</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 66628</p>
                <p><strong>Native Completion Tokens:</strong> 6651</p>
                <p><strong>Native Tokens Reasoning:</strong> 4032</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.1025552</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini-high/ghostty_src_App.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini-high/ghostty_src_App.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini-high/ghostty_src_App.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- ghostty_src_App.zig_expectedoutput.txt (expected)+++ ghostty_src_App.zig_extracted.txt (actual)@@ -1,13 +1,9 @@-//! App is the primary GUI application for ghostty. This builds the window,</div><div class="diff-removed">-//! sets up the renderer, etc. The primary run loop is started by calling</div><div class="diff-removed">-//! the "run" function.</div><div> const App = @This();</div><div> </div><div> const std = @import("std");</div><div> const builtin = @import("builtin");</div><div> const assert = std.debug.assert;</div><div> const Allocator = std.mem.Allocator;</div><div class="diff-removed">-const build_config = @import("build_config.zig");</div><div> const apprt = @import("apprt.zig");</div><div> const Surface = @import("Surface.zig");</div><div> const tracy = @import("tracy");</div><div class="diff-info">@@ -18,566 +14,294 @@ const renderer = @import("renderer.zig");</div><div> const font = @import("font/main.zig");</div><div> const internal_os = @import("os/main.zig");</div><div class="diff-removed">-const macos = @import("macos");</div><div class="diff-removed">-const objc = @import("objc");</div><div> </div><div> const log = std.log.scoped(.app);</div><div> </div><div> const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);</div><div> </div><div class="diff-removed">-/// General purpose allocator</div><div class="diff-removed">-alloc: Allocator,</div><div class="diff-removed">-</div><div class="diff-removed">-/// The list of surfaces that are currently active.</div><div class="diff-removed">-surfaces: SurfaceList,</div><div class="diff-removed">-</div><div class="diff-removed">-/// This is true if the app that Ghostty is in is focused. This may</div><div class="diff-removed">-/// mean that no surfaces (terminals) are focused but the app is still</div><div class="diff-removed">-/// focused, i.e. may an about window. On macOS, this concept is known</div><div class="diff-removed">-/// as the "active" app while focused windows are known as the</div><div class="diff-removed">-/// "main" window.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This is used to determine if keyboard shortcuts that are non-global</div><div class="diff-removed">-/// should be processed. If the app is not focused, then we don't want</div><div class="diff-removed">-/// to process keyboard shortcuts that are not global.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This defaults to true since we assume that the app is focused when</div><div class="diff-removed">-/// Ghostty is initialized but a well behaved apprt should call</div><div class="diff-removed">-/// focusEvent to set this to the correct value right away.</div><div class="diff-removed">-focused: bool = true,</div><div class="diff-removed">-</div><div class="diff-removed">-/// The last focused surface. This surface may not be valid;</div><div class="diff-removed">-/// you must always call hasSurface to validate it.</div><div class="diff-removed">-focused_surface: ?*Surface = null,</div><div class="diff-removed">-</div><div class="diff-removed">-/// The mailbox that can be used to send this thread messages. Note</div><div class="diff-removed">-/// this is a blocking queue so if it is full you will get errors (or block).</div><div class="diff-removed">-mailbox: Mailbox.Queue,</div><div class="diff-removed">-</div><div class="diff-removed">-/// The set of font GroupCache instances shared by surfaces with the</div><div class="diff-removed">-/// same font configuration.</div><div class="diff-removed">-font_grid_set: font.SharedGridSet,</div><div class="diff-removed">-</div><div class="diff-removed">-// Used to rate limit desktop notifications. Some platforms (notably macOS) will</div><div class="diff-removed">-// run out of resources if desktop notifications are sent too fast and the OS</div><div class="diff-removed">-// will kill Ghostty.</div><div class="diff-removed">-last_notification_time: ?std.time.Instant = null,</div><div class="diff-removed">-last_notification_digest: u64 = 0,</div><div class="diff-removed">-</div><div class="diff-removed">-/// The conditional state of the configuration. See the equivalent field</div><div class="diff-removed">-/// in the Surface struct for more information. In this case, this applies</div><div class="diff-removed">-/// to the app-level config and as a default for new surfaces.</div><div class="diff-removed">-config_conditional_state: configpkg.ConditionalState,</div><div class="diff-removed">-</div><div class="diff-removed">-/// Set to false once we've created at least one surface. This</div><div class="diff-removed">-/// never goes true again. This can be used by surfaces to determine</div><div class="diff-removed">-/// if they are the first surface.</div><div class="diff-removed">-first: bool = true,</div><div class="diff-removed">-</div><div class="diff-removed">-pub const CreateError = Allocator.Error || font.SharedGridSet.InitError;</div><div class="diff-removed">-</div><div class="diff-removed">-/// Initialize the main app instance. This creates the main window, sets</div><div class="diff-removed">-/// up the renderer state, compiles the shaders, etc. This is the primary</div><div class="diff-removed">-/// "startup" logic.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// After calling this function, well behaved apprts should then call</div><div class="diff-removed">-/// `focusEvent` to set the initial focus state of the app.</div><div class="diff-removed">-pub fn create(</div><div class="diff-added">+/// The type used for sending messages to the app thread.</div><div class="diff-added">+pub const Mailbox = struct {</div><div class="diff-added">+    pub const Queue = BlockingQueue(Message, 64);</div><div class="diff-added">+    rt_app: *apprt.App,</div><div class="diff-added">+    mailbox: *Queue,</div><div class="diff-added">+</div><div class="diff-added">+    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {</div><div class="diff-added">+        const result = self.mailbox.push(msg, timeout);</div><div class="diff-added">+        // Wake up our app loop</div><div class="diff-added">+        _ = self.rt_app.wakeup();</div><div class="diff-added">+        return result;</div><div class="diff-added">+    }</div><div class="diff-added">+};</div><div class="diff-added">+</div><div class="diff-added">+/// The main application state.</div><div class="diff-added">+pub const App = struct {</div><div>     alloc: Allocator,</div><div class="diff-removed">-) CreateError!*App {</div><div class="diff-removed">-    var app = try alloc.create(App);</div><div class="diff-removed">-    errdefer alloc.destroy(app);</div><div class="diff-removed">-</div><div class="diff-removed">-    var font_grid_set = try font.SharedGridSet.init(alloc);</div><div class="diff-removed">-    errdefer font_grid_set.deinit();</div><div class="diff-removed">-</div><div class="diff-removed">-    app.* = .{</div><div class="diff-removed">-        .alloc = alloc,</div><div class="diff-removed">-        .surfaces = .{},</div><div class="diff-removed">-        .mailbox = .{},</div><div class="diff-removed">-        .font_grid_set = font_grid_set,</div><div class="diff-removed">-        .config_conditional_state = .{},</div><div class="diff-added">+    surfaces: SurfaceList,</div><div class="diff-added">+    mailbox: Mailbox.Queue,</div><div class="diff-added">+    first: bool = true,</div><div class="diff-added">+    focused: bool = true,</div><div class="diff-added">+</div><div class="diff-added">+    /// The set of font GroupCache instances shared by surfaces</div><div class="diff-added">+    font_grid_set: font.SharedGridSet,</div><div class="diff-added">+</div><div class="diff-added">+    /// Configuration conditional state (e.g. theme) for the app</div><div class="diff-added">+    config_conditional_state: configpkg.ConditionalState,</div><div class="diff-added">+</div><div class="diff-added">+    /// Rate-limiting desktop notifications</div><div class="diff-added">+    last_notification_time: ?std.time.Instant = null,</div><div class="diff-added">+    last_notification_digest: u64 = 0,</div><div class="diff-added">+</div><div class="diff-added">+    pub fn create(alloc: Allocator) !*App {</div><div class="diff-added">+        var app = try alloc.create(App);</div><div class="diff-added">+        defer if (@hasDecl(App, "destroy")) app.destroy();</div><div class="diff-added">+        var font_grid_set = try font.SharedGridSet.init(alloc);</div><div class="diff-added">+        defer font_grid_set.deinit();</div><div class="diff-added">+        app.* = .{</div><div class="diff-added">+            .alloc = alloc,</div><div class="diff-added">+            .surfaces = .{},</div><div class="diff-added">+            .mailbox = .{},</div><div class="diff-added">+            .first = true,</div><div class="diff-added">+            .focused = true,</div><div class="diff-added">+            .font_grid_set = font_grid_set,</div><div class="diff-added">+            .config_conditional_state = .{},</div><div class="diff-added">+            .last_notification_time = null,</div><div class="diff-added">+            .last_notification_digest = 0,</div><div class="diff-added">+        };</div><div class="diff-added">+        try app.surfaces.deinit(alloc);</div><div class="diff-added">+        return app;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn destroy(self: *App) void {</div><div class="diff-added">+        // Clean up all surfaces</div><div class="diff-added">+        for (self.surfaces.items) |surface| surface.deinit();</div><div class="diff-added">+        self.surfaces.deinit(self.alloc);</div><div class="diff-added">+</div><div class="diff-added">+        // Assert no font grids remain</div><div class="diff-added">+        assert(self.font_grid_set.count() == 0);</div><div class="diff-added">+        self.font_grid_set.deinit();</div><div class="diff-added">+</div><div class="diff-added">+        self.alloc.destroy(self);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Called by the runtime whenever the app should process events.</div><div class="diff-added">+    pub fn tick(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-added">+        // Remove closed surfaces</div><div class="diff-added">+        var i: usize = 0;</div><div class="diff-added">+        while (i < self.surfaces.items.len) {</div><div class="diff-added">+            const surface = self.surfaces.items[i];</div><div class="diff-added">+            if (surface.shouldClose()) {</div><div class="diff-added">+                surface.deinit();</div><div class="diff-added">+                rt_app.closeSurface(surface);</div><div class="diff-added">+                _ = self.surfaces.swapRemove(i);</div><div class="diff-added">+                continue;</div><div class="diff-added">+            }</div><div class="diff-added">+            i += 1;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        // Drain mailbox</div><div class="diff-added">+        try self.drainMailbox(rt_app);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn drainMailbox(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-added">+        while (self.mailbox.pop()) |message| {</div><div class="diff-added">+            log.debug("mailbox message={s}", .{@tagName(message)});</div><div class="diff-added">+            switch (message) {</div><div class="diff-added">+                .new_window => |msg| try self.newWindow(rt_app, msg),</div><div class="diff-added">+                .open_config => try rt_app.performAction(.app, .open_config, {}),</div><div class="diff-added">+                .reload_config => try rt_app.performAction(.app, .reload_config, .{}),</div><div class="diff-added">+                .close => |surface| try self.closeSurface(surface),</div><div class="diff-added">+                .quit => {</div><div class="diff-added">+                    log.info("quit message received, short circuiting mailbox drain", .{});</div><div class="diff-added">+                    _ = try rt_app.performAction(.app, .quit, {});</div><div class="diff-added">+                    return;</div><div class="diff-added">+                },</div><div class="diff-added">+                .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),</div><div class="diff-added">+                .redraw_surface => |surface| self.redrawSurface(rt_app, surface),</div><div class="diff-added">+                .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),</div><div class="diff-added">+                .config_change => |c| try self.updateConfig(rt_app, c.config),</div><div class="diff-added">+                .open_config => | | try rt_app.performAction(.app, .open_config, {}),</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void {</div><div class="diff-added">+        for (self.surfaces.items) |surface| {</div><div class="diff-added">+            try surface.core_surface.handleMessage(.{ .change_config = config });</div><div class="diff-added">+        }</div><div class="diff-added">+        // Apply conditional state</div><div class="diff-added">+        const applied = config.changeConditionalState(self.config_conditional_state) catch |err| {</div><div class="diff-added">+            log.warn("apply conditional state failed: {}", .{err});</div><div class="diff-added">+            config</div><div class="diff-added">+        };</div><div class="diff-added">+        try rt_app.performAction(.app, .config_change, .{ .config = applied });</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn addSurface(self: *App, rt_surface: *apprt.Surface) !void {</div><div class="diff-added">+        try self.surfaces.append(self.alloc, rt_surface);</div><div class="diff-added">+        // Stop quit timer if any</div><div class="diff-added">+        _ = rt_surface.app.performAction(.app, .quit_timer, .stop);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {</div><div class="diff-added">+        var i: usize = 0;</div><div class="diff-added">+        while (i < self.surfaces.items.len) {</div><div class="diff-added">+            if (self.surfaces.items[i] == rt_surface) {</div><div class="diff-added">+                _ = self.surfaces.swapRemove(i);</div><div class="diff-added">+                break;</div><div class="diff-added">+            }</div><div class="diff-added">+            i += 1;</div><div class="diff-added">+        }</div><div class="diff-added">+        // Start quit timer if none left</div><div class="diff-added">+        if (self.surfaces.items.len == 0) {</div><div class="diff-added">+            _ = rt_surface.app.performAction(.app, .quit_timer, .start);</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn focusedSurface(self: *App) ?*Surface {</div><div class="diff-added">+        if (self.focused_surface and self.hasSurface(self.focused_surface.?.*))</div><div class="diff-added">+            return self.focused_surface.?;</div><div class="diff-added">+        return null;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn needsConfirmQuit(self: *App) bool {</div><div class="diff-added">+        for (self.surfaces.items) |v| {</div><div class="diff-added">+            if (v.core_surface.needsConfirmQuit()) return true;</div><div class="diff-added">+        }</div><div class="diff-added">+        return false;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn keyEvent(self: *App, rt_app: *apprt.App, event: input.KeyEvent) bool {</div><div class="diff-added">+        if (event.action == .release) return false;</div><div class="diff-added">+        const entry = rt_app.config.keybind.set.getEvent(event) orelse return false;</div><div class="diff-added">+        const leaf = entry.value_ptr.*;</div><div class="diff-added">+        if (!self.focused and !leaf.flags.global) return false;</div><div class="diff-added">+        if (leaf.flags.global) {</div><div class="diff-added">+            self.performAllAction(rt_app, leaf.action) catch |err| {</div><div class="diff-added">+                log.warn("global keybind {} error {}", .{@tagName(leaf.action), err});</div><div class="diff-added">+            };</div><div class="diff-added">+            return true;</div><div class="diff-added">+        }</div><div class="diff-added">+        // must be app-scoped</div><div class="diff-added">+        const app_action = leaf.action.scoped(.app) orelse return false;</div><div class="diff-added">+        self.performAction(rt_app, app_action) catch |err| {</div><div class="diff-added">+            log.warn("app keybind {} error {}", .{@tagName(app_action), err});</div><div class="diff-added">+        };</div><div class="diff-added">+        return true;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn focusEvent(self: *App, focused: bool) void {</div><div class="diff-added">+        if (self.focused == focused) return;</div><div class="diff-added">+        log.debug("focus event focused={}", .{focused});</div><div class="diff-added">+        self.focused = focused;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn colorSchemeEvent(self: *App, rt_app: *apprt.App, scheme: apprt.ColorScheme) !void {</div><div class="diff-added">+        const new_theme = switch (scheme) {</div><div class="diff-added">+            .light => .light,</div><div class="diff-added">+            .dark => .dark,</div><div class="diff-added">+        };</div><div class="diff-added">+        if (self.config_conditional_state.theme == new_theme) return;</div><div class="diff-added">+        self.config_conditional_state.theme = new_theme;</div><div class="diff-added">+        _ = try rt_app.performAction(.app, .reload_config, .{ .soft = true });</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn keyEventIsBinding(self: *App, rt_app: *apprt.App, event: input.KeyEvent) bool {</div><div class="diff-added">+        if (event.action == .release) return false;</div><div class="diff-added">+        return rt_app.config.keybind.set.getEvent(event) != null;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Perform an app-scoped action.</div><div class="diff-added">+    pub fn performAction(</div><div class="diff-added">+        self: *App,</div><div class="diff-added">+        rt_app: *apprt.App,</div><div class="diff-added">+        action: input.Binding.Action.Scoped(.app),</div><div class="diff-added">+    ) !void {</div><div class="diff-added">+        switch (action) {</div><div class="diff-added">+            .ignore => {},</div><div class="diff-added">+            .quit => _ = rt_app.performAction(.app, .quit, {}),</div><div class="diff-added">+            .open_config => _ = rt_app.performAction(.app, .open_config, {}),</div><div class="diff-added">+            .reload_config => _ = rt_app.performAction(.app, .reload_config, .{}),</div><div class="diff-added">+            .toggle_quick_terminal => _ = rt_app.performAction(.app, .toggle_quick_terminal, {}),</div><div class="diff-added">+            .toggle_visibility => _ = rt_app.performAction(.app, .toggle_visibility, {}),</div><div class="diff-added">+            .quit_timer => unreachable,</div><div class="diff-added">+            .close_all_windows => _ = rt_app.performAction(.app, .close_all_windows, {}),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Perform an action, routing to app or all surfaces as appropriate.</div><div class="diff-added">+    pub fn performAllAction(</div><div class="diff-added">+        self: *App,</div><div class="diff-added">+        rt_app: *apprt.App,</div><div class="diff-added">+        action: input.Binding.Action,</div><div class="diff-added">+    ) !void {</div><div class="diff-added">+        switch (action.scope()) {</div><div class="diff-added">+            .app => try self.performAction(rt_app, action.scoped(.app).?), </div><div class="diff-added">+            .surface => for (self.surfaces.items) |surface| {</div><div class="diff-added">+                _ = surface.core_surface.performBindingAction(action) catch |err| {</div><div class="diff-added">+                    log.warn("action {} surface err {}", .{@tagName(action), err});</div><div class="diff-added">+                };</div><div class="diff-added">+            },</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Create a new window/tab.</div><div class="diff-added">+    pub fn newWindow(</div><div class="diff-added">+        self: *App,</div><div class="diff-added">+        rt_app: *apprt.App,</div><div class="diff-added">+        msg: Message.NewWindow,</div><div class="diff-added">+    ) !void {</div><div class="diff-added">+        const target: apprt.Target = block: {</div><div class="diff-added">+            const p = msg.parent orelse break :block .app;</div><div class="diff-added">+            if (self.hasSurface(p)) break :block .{ .surface = p };</div><div class="diff-added">+            break :block .app;</div><div class="diff-added">+        };</div><div class="diff-added">+        _ = try rt_app.performAction(target, .new_window, .{});</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn surfaceMessage(</div><div class="diff-added">+        self: *App,</div><div class="diff-added">+        surface: *Surface,</div><div class="diff-added">+        msg: apprt.surface.Message,</div><div class="diff-added">+    ) !void {</div><div class="diff-added">+        if (self.hasSurface(surface)) {</div><div class="diff-added">+            try surface.handleMessage(msg);</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn hasSurface(self: *App, surface: *Surface) bool {</div><div class="diff-added">+        for (self.surfaces.items) |v| {</div><div class="diff-added">+            if (&v.core_surface == surface) return true;</div><div class="diff-added">+        }</div><div class="diff-added">+        return false;</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-added">+        if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-added">+        rt_app.redrawSurface(surface);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-added">+        if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-added">+        rt_app.redrawInspector(surface);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Messages sent to the app thread.</div><div class="diff-added">+    pub const Message = union(enum) {</div><div class="diff-added">+        new_window: NewWindow,</div><div class="diff-added">+        open_config: void,</div><div class="diff-added">+        reload_config: void,</div><div class="diff-added">+        close: *Surface,</div><div class="diff-added">+        quit: void,</div><div class="diff-added">+        surface_message: struct {</div><div class="diff-added">+            surface: *Surface,</div><div class="diff-added">+            message: apprt.surface.Message,</div><div class="diff-added">+        },</div><div class="diff-added">+        redraw_surface: *apprt.Surface,</div><div class="diff-added">+        redraw_inspector: *apprt.Surface,</div><div class="diff-added">+        config_change: struct { config: *const Config },</div><div>     };</div><div class="diff-removed">-    errdefer app.surfaces.deinit(alloc);</div><div class="diff-removed">-</div><div class="diff-removed">-    return app;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub fn destroy(self: *App) void {</div><div class="diff-removed">-    // Clean up all our surfaces</div><div class="diff-removed">-    for (self.surfaces.items) |surface| surface.deinit();</div><div class="diff-removed">-    self.surfaces.deinit(self.alloc);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Clean up our font group cache</div><div class="diff-removed">-    // We should have zero items in the grid set at this point because</div><div class="diff-removed">-    // destroy only gets called when the app is shutting down and this</div><div class="diff-removed">-    // should gracefully close all surfaces.</div><div class="diff-removed">-    assert(self.font_grid_set.count() == 0);</div><div class="diff-removed">-    self.font_grid_set.deinit();</div><div class="diff-removed">-</div><div class="diff-removed">-    self.alloc.destroy(self);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Tick ticks the app loop. This will drain our mailbox and process those</div><div class="diff-removed">-/// events. This should be called by the application runtime on every loop</div><div class="diff-removed">-/// tick.</div><div class="diff-removed">-pub fn tick(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-removed">-    // If any surfaces are closing, destroy them</div><div class="diff-removed">-    var i: usize = 0;</div><div class="diff-removed">-    while (i < self.surfaces.items.len) {</div><div class="diff-removed">-        const surface = self.surfaces.items[i];</div><div class="diff-removed">-        if (surface.shouldClose()) {</div><div class="diff-removed">-            surface.close(false);</div><div class="diff-removed">-            continue;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        i += 1;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Drain our mailbox</div><div class="diff-removed">-    try self.drainMailbox(rt_app);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Update the configuration associated with the app. This can only be</div><div class="diff-removed">-/// called from the main thread. The caller owns the config memory. The</div><div class="diff-removed">-/// memory can be freed immediately when this returns.</div><div class="diff-removed">-pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void {</div><div class="diff-removed">-    // Go through and update all of the surface configurations.</div><div class="diff-removed">-    for (self.surfaces.items) |surface| {</div><div class="diff-removed">-        try surface.core_surface.handleMessage(.{ .change_config = config });</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Apply our conditional state. If we fail to apply the conditional state</div><div class="diff-removed">-    // then we log and attempt to move forward with the old config.</div><div class="diff-removed">-    // We only apply this to the app-level config because the surface</div><div class="diff-removed">-    // config applies its own conditional state.</div><div class="diff-removed">-    var applied_: ?configpkg.Config = config.changeConditionalState(</div><div class="diff-removed">-        self.config_conditional_state,</div><div class="diff-removed">-    ) catch |err| err: {</div><div class="diff-removed">-        log.warn("failed to apply conditional state to config err={}", .{err});</div><div class="diff-removed">-        break :err null;</div><div class="diff-removed">-    };</div><div class="diff-removed">-    defer if (applied_) |*c| c.deinit();</div><div class="diff-removed">-    const applied: *const configpkg.Config = if (applied_) |*c| c else config;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Notify the apprt that the app has changed configuration.</div><div class="diff-removed">-    _ = try rt_app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .config_change,</div><div class="diff-removed">-        .{ .config = applied },</div><div class="diff-removed">-    );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Add an initialized surface. This is really only for the runtime</div><div class="diff-removed">-/// implementations to call and should NOT be called by general app users.</div><div class="diff-removed">-/// The surface must be from the pool.</div><div class="diff-removed">-pub fn addSurface(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_surface: *apprt.Surface,</div><div class="diff-removed">-) Allocator.Error!void {</div><div class="diff-removed">-    try self.surfaces.append(self.alloc, rt_surface);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Since we have non-zero surfaces, we can cancel the quit timer.</div><div class="diff-removed">-    // It is up to the apprt if there is a quit timer at all and if it</div><div class="diff-removed">-    // should be canceled.</div><div class="diff-removed">-    _ = rt_surface.app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .quit_timer,</div><div class="diff-removed">-        .stop,</div><div class="diff-removed">-    ) catch |err| {</div><div class="diff-removed">-        log.warn("error stopping quit timer err={}", .{err});</div><div class="diff-removed">-    };</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Delete the surface from the known surface list. This will NOT call the</div><div class="diff-removed">-/// destructor or free the memory.</div><div class="diff-removed">-pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {</div><div class="diff-removed">-    // If this surface is the focused surface then we need to clear it.</div><div class="diff-removed">-    // There was a bug where we relied on hasSurface to return false and</div><div class="diff-removed">-    // just let focused surface be but the allocator was reusing addresses</div><div class="diff-removed">-    // after free and giving false positives, so we must clear it.</div><div class="diff-removed">-    if (self.focused_surface) |focused| {</div><div class="diff-removed">-        if (focused == &rt_surface.core_surface) {</div><div class="diff-removed">-            self.focused_surface = null;</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    var i: usize = 0;</div><div class="diff-removed">-    while (i < self.surfaces.items.len) {</div><div class="diff-removed">-        if (self.surfaces.items[i] == rt_surface) {</div><div class="diff-removed">-            _ = self.surfaces.swapRemove(i);</div><div class="diff-removed">-            continue;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        i += 1;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we have no surfaces, we can start the quit timer. It is up to the</div><div class="diff-removed">-    // apprt to determine if this is necessary.</div><div class="diff-removed">-    if (self.surfaces.items.len == 0) _ = rt_surface.app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .quit_timer,</div><div class="diff-removed">-        .start,</div><div class="diff-removed">-    ) catch |err| {</div><div class="diff-removed">-        log.warn("error starting quit timer err={}", .{err});</div><div class="diff-removed">-    };</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// The last focused surface. This is only valid while on the main thread</div><div class="diff-removed">-/// before tick is called.</div><div class="diff-removed">-pub fn focusedSurface(self: *const App) ?*Surface {</div><div class="diff-removed">-    const surface = self.focused_surface orelse return null;</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return null;</div><div class="diff-removed">-    return surface;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Returns true if confirmation is needed to quit the app. It is up to</div><div class="diff-removed">-/// the apprt to call this.</div><div class="diff-removed">-pub fn needsConfirmQuit(self: *const App) bool {</div><div class="diff-removed">-    for (self.surfaces.items) |v| {</div><div class="diff-removed">-        if (v.core_surface.needsConfirmQuit()) return true;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return false;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Drain the mailbox.</div><div class="diff-removed">-fn drainMailbox(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-removed">-    while (self.mailbox.pop()) |message| {</div><div class="diff-removed">-        log.debug("mailbox message={s}", .{@tagName(message)});</div><div class="diff-removed">-        switch (message) {</div><div class="diff-removed">-            .open_config => try self.performAction(rt_app, .open_config),</div><div class="diff-removed">-            .new_window => |msg| try self.newWindow(rt_app, msg),</div><div class="diff-removed">-            .close => |surface| self.closeSurface(surface),</div><div class="diff-removed">-            .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),</div><div class="diff-removed">-            .redraw_surface => |surface| self.redrawSurface(rt_app, surface),</div><div class="diff-removed">-            .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),</div><div class="diff-removed">-</div><div class="diff-removed">-            // If we're quitting, then we set the quit flag and stop</div><div class="diff-removed">-            // draining the mailbox immediately. This lets us defer</div><div class="diff-removed">-            // mailbox processing to the next tick so that the apprt</div><div class="diff-removed">-            // can try to quit as quickly as possible.</div><div class="diff-removed">-            .quit => {</div><div class="diff-removed">-                log.info("quit message received, short circuiting mailbox drain", .{});</div><div class="diff-removed">-                try self.performAction(rt_app, .quit);</div><div class="diff-removed">-                return;</div><div class="diff-removed">-            },</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub fn closeSurface(self: *App, surface: *Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return;</div><div class="diff-removed">-    surface.close();</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub fn focusSurface(self: *App, surface: *Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return;</div><div class="diff-removed">-    self.focused_surface = surface;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-removed">-    rt_app.redrawSurface(surface);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-removed">-    rt_app.redrawInspector(surface);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Create a new window</div><div class="diff-removed">-pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {</div><div class="diff-removed">-    const target: apprt.Target = target: {</div><div class="diff-removed">-        const parent = msg.parent orelse break :target .app;</div><div class="diff-removed">-        if (self.hasSurface(parent)) break :target .{ .surface = parent };</div><div class="diff-removed">-        break :target .app;</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    _ = try rt_app.performAction(</div><div class="diff-removed">-        target,</div><div class="diff-removed">-        .new_window,</div><div class="diff-removed">-        {},</div><div class="diff-removed">-    );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Handle an app-level focus event. This should be called whenever</div><div class="diff-removed">-/// the focus state of the entire app containing Ghostty changes.</div><div class="diff-removed">-/// This is separate from surface focus events. See the `focused`</div><div class="diff-removed">-/// field for more information.</div><div class="diff-removed">-pub fn focusEvent(self: *App, focused: bool) void {</div><div class="diff-removed">-    // Prevent redundant focus events</div><div class="diff-removed">-    if (self.focused == focused) return;</div><div class="diff-removed">-</div><div class="diff-removed">-    log.debug("focus event focused={}", .{focused});</div><div class="diff-removed">-    self.focused = focused;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Returns true if the given key event would trigger a keybinding</div><div class="diff-removed">-/// if it were to be processed. This is useful for determining if</div><div class="diff-removed">-/// a key event should be sent to the terminal or not.</div><div class="diff-removed">-pub fn keyEventIsBinding(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    event: input.KeyEvent,</div><div class="diff-removed">-) bool {</div><div class="diff-removed">-    _ = self;</div><div class="diff-removed">-</div><div class="diff-removed">-    switch (event.action) {</div><div class="diff-removed">-        .release => return false,</div><div class="diff-removed">-        .press, .repeat => {},</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we have a keybinding for this event then we return true.</div><div class="diff-removed">-    return rt_app.config.keybind.set.getEvent(event) != null;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Handle a key event at the app-scope. If this key event is used,</div><div class="diff-removed">-/// this will return true and the caller shouldn't continue processing</div><div class="diff-removed">-/// the event. If the event is not used, this will return false.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// If the app currently has focus then all key events are processed.</div><div class="diff-removed">-/// If the app does not have focus then only global key events are</div><div class="diff-removed">-/// processed.</div><div class="diff-removed">-pub fn keyEvent(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    event: input.KeyEvent,</div><div class="diff-removed">-) bool {</div><div class="diff-removed">-    switch (event.action) {</div><div class="diff-removed">-        // We don't care about key release events.</div><div class="diff-removed">-        .release => return false,</div><div class="diff-removed">-</div><div class="diff-removed">-        // Continue processing key press events.</div><div class="diff-removed">-        .press, .repeat => {},</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Get the keybind entry for this event. We don't support key sequences</div><div class="diff-removed">-    // so we can look directly in the top-level set.</div><div class="diff-removed">-    const entry = rt_app.config.keybind.set.getEvent(event) orelse return false;</div><div class="diff-removed">-    const leaf: input.Binding.Set.Leaf = switch (entry.value_ptr.*) {</div><div class="diff-removed">-        // Sequences aren't supported. Our configuration parser verifies</div><div class="diff-removed">-        // this for global keybinds but we may still get an entry for</div><div class="diff-removed">-        // a non-global keybind.</div><div class="diff-removed">-        .leader => return false,</div><div class="diff-removed">-</div><div class="diff-removed">-        // Leaf entries are good</div><div class="diff-removed">-        .leaf => |leaf| leaf,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we aren't focused, then we only process global keybinds.</div><div class="diff-removed">-    if (!self.focused and !leaf.flags.global) return false;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Global keybinds are done using performAll so that they</div><div class="diff-removed">-    // can target all surfaces too.</div><div class="diff-removed">-    if (leaf.flags.global) {</div><div class="diff-removed">-        self.performAllAction(rt_app, leaf.action) catch |err| {</div><div class="diff-removed">-            log.warn("error performing global keybind action action={s} err={}", .{</div><div class="diff-removed">-                @tagName(leaf.action),</div><div class="diff-removed">-                err,</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        return true;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Must be focused to process non-global keybinds</div><div class="diff-removed">-    assert(self.focused);</div><div class="diff-removed">-    assert(!leaf.flags.global);</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we are focused, then we process keybinds only if they are</div><div class="diff-removed">-    // app-scoped. Otherwise, we do nothing. Surface-scoped should</div><div class="diff-removed">-    // be processed by Surface.keyEvent.</div><div class="diff-removed">-    const app_action = leaf.action.scoped(.app) orelse return false;</div><div class="diff-removed">-    self.performAction(rt_app, app_action) catch |err| {</div><div class="diff-removed">-        log.warn("error performing app keybind action action={s} err={}", .{</div><div class="diff-removed">-            @tagName(app_action),</div><div class="diff-removed">-            err,</div><div class="diff-removed">-        });</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    return true;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Call to notify Ghostty that the color scheme for the app has changed.</div><div class="diff-removed">-/// "Color scheme" in this case refers to system themes such as "light/dark".</div><div class="diff-removed">-pub fn colorSchemeEvent(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    scheme: apprt.ColorScheme,</div><div class="diff-removed">-) !void {</div><div class="diff-removed">-    const new_scheme: configpkg.ConditionalState.Theme = switch (scheme) {</div><div class="diff-removed">-        .light => .light,</div><div class="diff-removed">-        .dark => .dark,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    // If our scheme didn't change, then we don't do anything.</div><div class="diff-removed">-    if (self.config_conditional_state.theme == new_scheme) return;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Setup our conditional state which has the current color theme.</div><div class="diff-removed">-    self.config_conditional_state.theme = new_scheme;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Request our configuration be reloaded because the new scheme may</div><div class="diff-removed">-    // impact the colors of the app.</div><div class="diff-removed">-    _ = try rt_app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .reload_config,</div><div class="diff-removed">-        .{ .soft = true },</div><div class="diff-removed">-    );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Perform a binding action. This only accepts actions that are scoped</div><div class="diff-removed">-/// to the app. Callers can use performAllAction to perform any action</div><div class="diff-removed">-/// and any non-app-scoped actions will be performed on all surfaces.</div><div class="diff-removed">-pub fn performAction(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    action: input.Binding.Action.Scoped(.app),</div><div class="diff-removed">-) !void {</div><div class="diff-removed">-    switch (action) {</div><div class="diff-removed">-        .unbind => unreachable,</div><div class="diff-removed">-        .ignore => {},</div><div class="diff-removed">-        .quit => _ = try rt_app.performAction(.app, .quit, {}),</div><div class="diff-removed">-        .new_window => _ = try self.newWindow(rt_app, .{ .parent = null }),</div><div class="diff-removed">-        .open_config => _ = try rt_app.performAction(.app, .open_config, {}),</div><div class="diff-removed">-        .reload_config => _ = try rt_app.performAction(.app, .reload_config, .{}),</div><div class="diff-removed">-        .close_all_windows => _ = try rt_app.performAction(.app, .close_all_windows, {}),</div><div class="diff-removed">-        .toggle_quick_terminal => _ = try rt_app.performAction(.app, .toggle_quick_terminal, {}),</div><div class="diff-removed">-        .toggle_visibility => _ = try rt_app.performAction(.app, .toggle_visibility, {}),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Perform an app-wide binding action. If the action is surface-specific</div><div class="diff-removed">-/// then it will be performed on all surfaces. To perform only app-scoped</div><div class="diff-removed">-/// actions, use performAction.</div><div class="diff-removed">-pub fn performAllAction(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    action: input.Binding.Action,</div><div class="diff-removed">-) !void {</div><div class="diff-removed">-    switch (action.scope()) {</div><div class="diff-removed">-        // App-scoped actions are handled by the app so that they aren't</div><div class="diff-removed">-        // repeated for each surface (since each surface forwards</div><div class="diff-removed">-        // app-scoped actions back up).</div><div class="diff-removed">-        .app => try self.performAction(</div><div class="diff-removed">-            rt_app,</div><div class="diff-removed">-            action.scoped(.app).?, // asserted through the scope match</div><div class="diff-removed">-        ),</div><div class="diff-removed">-</div><div class="diff-removed">-        // Surface-scoped actions are performed on all surfaces. Errors</div><div class="diff-removed">-        // are logged but processing continues.</div><div class="diff-removed">-        .surface => for (self.surfaces.items) |surface| {</div><div class="diff-removed">-            _ = surface.core_surface.performBindingAction(action) catch |err| {</div><div class="diff-removed">-                log.warn("error performing binding action on surface ptr={X} err={}", .{</div><div class="diff-removed">-                    @intFromPtr(surface),</div><div class="diff-removed">-                    err,</div><div class="diff-removed">-                });</div><div class="diff-removed">-            };</div><div class="diff-removed">-        },</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Handle a window message</div><div class="diff-removed">-fn surfaceMessage(self: *App, surface: *Surface, msg: apprt.surface.Message) !void {</div><div class="diff-removed">-    // We want to ensure our window is still active. Window messages</div><div class="diff-removed">-    // are quite rare and we normally don't have many windows so we do</div><div class="diff-removed">-    // a simple linear search here.</div><div class="diff-removed">-    if (self.hasSurface(surface)) {</div><div class="diff-removed">-        try surface.handleMessage(msg);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Window was not found, it probably quit before we handled the message.</div><div class="diff-removed">-    // Not a problem.</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn hasSurface(self: *const App, surface: *const Surface) bool {</div><div class="diff-removed">-    for (self.surfaces.items) |v| {</div><div class="diff-removed">-        if (&v.core_surface == surface) return true;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return false;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// The message types that can be sent to the app thread.</div><div class="diff-removed">-pub const Message = union(enum) {</div><div class="diff-removed">-    // Open the configuration file</div><div class="diff-removed">-    open_config: void,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create a new terminal window.</div><div class="diff-removed">-    new_window: NewWindow,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Close a surface. This notifies the runtime that a surface</div><div class="diff-removed">-    /// should close.</div><div class="diff-removed">-    close: *Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Quit</div><div class="diff-removed">-    quit: void,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// A message for a specific surface.</div><div class="diff-removed">-    surface_message: struct {</div><div class="diff-removed">-        surface: *Surface,</div><div class="diff-removed">-        message: apprt.surface.Message,</div><div class="diff-removed">-    },</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Redraw a surface. This only has an effect for runtimes that</div><div class="diff-removed">-    /// use single-threaded draws. To redraw a surface for all runtimes,</div><div class="diff-removed">-    /// wake up the renderer thread. The renderer thread will send this</div><div class="diff-removed">-    /// message if it needs to.</div><div class="diff-removed">-    redraw_surface: *apprt.Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Redraw the inspector. This is called whenever some non-OS event</div><div class="diff-removed">-    /// causes the inspector to need to be redrawn.</div><div class="diff-removed">-    redraw_inspector: *apprt.Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    const NewWindow = struct {</div><div class="diff-removed">-        /// The parent surface</div><div class="diff-added">+</div><div class="diff-added">+    pub const NewWindow = struct {</div><div>         parent: ?*Surface = null,</div><div>     };</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-/// Mailbox is the way that other threads send the app thread messages.</div><div class="diff-removed">-pub const Mailbox = struct {</div><div class="diff-removed">-    /// The type used for sending messages to the app thread.</div><div class="diff-removed">-    pub const Queue = BlockingQueue(Message, 64);</div><div class="diff-removed">-</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    mailbox: *Queue,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Send a message to the surface.</div><div class="diff-removed">-    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {</div><div class="diff-removed">-        const result = self.mailbox.push(msg, timeout);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Wake up our app loop</div><div class="diff-removed">-        self.rt_app.wakeup();</div><div class="diff-removed">-</div><div class="diff-removed">-        return result;</div><div class="diff-removed">-    }</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-// Wasm API.</div><div class="diff-removed">-pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {</div><div class="diff-removed">-    const wasm = @import("os/wasm.zig");</div><div class="diff-removed">-    const alloc = wasm.alloc;</div><div class="diff-removed">-</div><div class="diff-removed">-    // export fn app_new(config: *Config) ?*App {</div><div class="diff-removed">-    //     return app_new_(config) catch |err| { log.err("error initializing app err={}", .{err});</div><div class="diff-removed">-    //         return null;</div><div class="diff-removed">-    //     };</div><div class="diff-removed">-    // }</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // fn app_new_(config: *Config) !*App {</div><div class="diff-removed">-    //     const app = try App.create(alloc, config);</div><div class="diff-removed">-    //     errdefer app.destroy();</div><div class="diff-removed">-    //</div><div class="diff-removed">-    //     const result = try alloc.create(App);</div><div class="diff-removed">-    //     result.* = app;</div><div class="diff-removed">-    //     return result;</div><div class="diff-removed">-    // }</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // export fn app_free(ptr: ?*App) void {</div><div class="diff-removed">-    //     if (ptr) |v| {</div><div class="diff-removed">-    //         v.destroy();</div><div class="diff-removed">-    //         alloc.destroy(v);</div><div class="diff-removed">-    //     }</div><div class="diff-removed">-    // }</div><div> };</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    