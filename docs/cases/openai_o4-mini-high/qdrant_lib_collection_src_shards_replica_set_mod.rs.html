<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/replica_set/mod.rs - o4-mini-high</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/replica_set/mod.rs</h1>
        <p><a href="../../models/openai_o4-mini-high.html">← Back to o4-mini-high Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-high</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 57397</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 57232</p>
                <p><strong>Native Completion Tokens:</strong> 6017</p>
                <p><strong>Native Tokens Reasoning:</strong> 3200</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.08943</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_replica_set_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_replica_set_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_replica_set_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_shards_replica_set_mod.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_shards_replica_set_mod.rs_extracted.txt (actual)@@ -1,4 +1,3 @@-pub mod clock_set;</div><div> mod execute_read_operation;</div><div> mod locally_disabled_peers;</div><div> mod read_ops;</div><div class="diff-info">@@ -23,76 +22,36 @@ use tokio::runtime::Handle;</div><div> use tokio::sync::{Mutex, RwLock};</div><div> </div><div class="diff-removed">-use super::CollectionId;</div><div> use super::local_shard::LocalShard;</div><div> use super::local_shard::clock_map::RecoveryPoint;</div><div> use super::remote_shard::RemoteShard;</div><div> use super::transfer::ShardTransfer;</div><div class="diff-added">+use super::CollectionId;</div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::common::collection_size_stats::CollectionSizeStats;</div><div> use crate::common::snapshots_manager::SnapshotStorageManager;</div><div> use crate::config::CollectionConfigInternal;</div><div class="diff-added">+use crate::operations::{CollectionUpdateOperations, point_ops};</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult, UpdateResult, UpdateStatus};</div><div class="diff-removed">-use crate::operations::{CollectionUpdateOperations, point_ops};</div><div class="diff-added">+use crate::save_on_disk::SaveOnDisk;</div><div> use crate::optimizers_builder::OptimizersConfig;</div><div class="diff-removed">-use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::channel_service::ChannelService;</div><div> use crate::shards::dummy_shard::DummyShard;</div><div> use crate::shards::replica_set::clock_set::ClockSet;</div><div> use crate::shards::shard::{PeerId, Shard, ShardId};</div><div> use crate::shards::shard_config::ShardConfig;</div><div> </div><div class="diff-removed">-//    │    Collection Created</div><div class="diff-removed">-//    │</div><div class="diff-removed">-//    ▼</div><div class="diff-removed">-//  ┌──────────────┐</div><div class="diff-removed">-//  │              │</div><div class="diff-removed">-//  │ Initializing │</div><div class="diff-removed">-//  │              │</div><div class="diff-removed">-//  └──────┬───────┘</div><div class="diff-removed">-//         │  Report created    ┌───────────┐</div><div class="diff-removed">-//         └────────────────────►           │</div><div class="diff-removed">-//             Activate         │ Consensus │</div><div class="diff-removed">-//        ┌─────────────────────┤           │</div><div class="diff-removed">-//        │                     └───────────┘</div><div class="diff-removed">-//  ┌─────▼───────┐   User Promote           ┌──────────┐</div><div class="diff-removed">-//  │             ◄──────────────────────────►          │</div><div class="diff-removed">-//  │ Active      │                          │ Listener │</div><div class="diff-removed">-//  │             ◄───────────┐              │          │</div><div class="diff-removed">-//  └──┬──────────┘           │Transfer      └──┬───────┘</div><div class="diff-removed">-//     │                      │Finished         │</div><div class="diff-removed">-//     │               ┌──────┴────────┐        │Update</div><div class="diff-removed">-//     │Update         │               │        │Failure</div><div class="diff-removed">-//     │Failure        │ Partial       ├───┐    │</div><div class="diff-removed">-//     │               │               │   │    │</div><div class="diff-removed">-//     │               └───────▲───────┘   │    │</div><div class="diff-removed">-//     │                       │           │    │</div><div class="diff-removed">-//  ┌──▼──────────┐ Transfer   │           │    │</div><div class="diff-removed">-//  │             │ Started    │           │    │</div><div class="diff-removed">-//  │ Dead        ├────────────┘           │    │</div><div class="diff-removed">-//  │             │                        │    │</div><div class="diff-removed">-//  └─▲───────▲───┘        Transfer        │    │</div><div class="diff-removed">-//    │       │            Failed/Cancelled│    │</div><div class="diff-removed">-//    │       └────────────────────────────┘    │</div><div class="diff-removed">-//    │                                         │</div><div class="diff-removed">-//    └─────────────────────────────────────────┘</div><div class="diff-removed">-//</div><div class="diff-removed">-</div><div class="diff-added">+///</div><div> /// A set of shard replicas.</div><div class="diff-removed">-///</div><div> /// Handles operations so that the state is consistent across all the replicas of the shard.</div><div> /// Prefers local shard for read-only operations.</div><div> /// Perform updates on all replicas and report error if there is at least one failure.</div><div> ///</div><div> pub struct ShardReplicaSet {</div><div class="diff-removed">-    local: RwLock<Option<Shard>>, // Abstract Shard to be able to use a Proxy during replication</div><div class="diff-added">+    local: RwLock<Option<Shard>>,</div><div>     remotes: RwLock<Vec<RemoteShard>>,</div><div>     replica_state: Arc<SaveOnDisk<ReplicaSetState>>,</div><div class="diff-removed">-    /// List of peers that are marked as dead locally, but are not yet submitted to the consensus.</div><div class="diff-removed">-    /// List is checked on each consensus round and submitted to the consensus.</div><div class="diff-removed">-    /// If the state of the peer is changed in the consensus, it is removed from the list.</div><div class="diff-removed">-    /// Update and read operations are not performed on the peers marked as dead.</div><div>     locally_disabled_peers: parking_lot::RwLock<locally_disabled_peers::Registry>,</div><div>     pub(crate) shard_path: PathBuf,</div><div>     pub(crate) shard_id: ShardId,</div><div class="diff-info">@@ -108,21 +67,17 @@     update_runtime: Handle,</div><div>     search_runtime: Handle,</div><div>     optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    /// Lock to serialized write operations on the replicaset when a write ordering is used.</div><div>     write_ordering_lock: Mutex<()>,</div><div class="diff-removed">-    /// Local clock set, used to tag new operations on this shard.</div><div>     clock_set: Mutex<ClockSet>,</div><div>     write_rate_limiter: Option<parking_lot::Mutex<RateLimiter>>,</div><div> }</div><div> </div><div> pub type AbortShardTransfer = Arc<dyn Fn(ShardTransfer, &str) + Send + Sync>;</div><div class="diff-removed">-pub type ChangePeerState = Arc<dyn Fn(PeerId, ShardId) + Send + Sync>;</div><div> pub type ChangePeerFromState = Arc<dyn Fn(PeerId, ShardId, Option<ReplicaState>) + Send + Sync>;</div><div> </div><div> const REPLICA_STATE_FILE: &str = "replica_state.json";</div><div> </div><div> impl ShardReplicaSet {</div><div class="diff-removed">-    /// Create a new fresh replica set, no previous state is expected.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn build(</div><div>         shard_id: ShardId,</div><div class="diff-info">@@ -142,7 +97,6 @@         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        init_state: Option<ReplicaState>,</div><div>     ) -> CollectionResult<Self> {</div><div>         let shard_path = super::create_shard_dir(collection_path, shard_id).await?;</div><div>         let local = if local {</div><div class="diff-info">@@ -163,9 +117,13 @@         } else {</div><div>             None</div><div>         };</div><div class="diff-added">+</div><div class="diff-added">+        let replica_set_shard_config = ShardConfig::new_replica_set();</div><div class="diff-added">+        replica_set_shard_config.save(&shard_path)?;</div><div class="diff-added">+</div><div class="diff-added">+        let init_state = None;</div><div>         let replica_state: SaveOnDisk<ReplicaSetState> =</div><div>             SaveOnDisk::load_or_init_default(shard_path.join(REPLICA_STATE_FILE))?;</div><div class="diff-removed">-</div><div>         let init_replica_state = init_state.unwrap_or(ReplicaState::Initializing);</div><div>         replica_state.write(|rs| {</div><div>             rs.this_peer_id = this_peer_id;</div><div class="diff-info">@@ -173,24 +131,15 @@                 rs.is_local = true;</div><div>                 rs.set_peer_state(this_peer_id, init_replica_state);</div><div>             }</div><div class="diff-removed">-            for peer in remotes {</div><div class="diff-added">+            for peer in remotes.iter().copied() {</div><div>                 rs.set_peer_state(peer, init_replica_state);</div><div>             }</div><div>         })?;</div><div> </div><div class="diff-removed">-        let remote_shards = Self::init_remote_shards(</div><div class="diff-removed">-            shard_id,</div><div class="diff-removed">-            collection_id.clone(),</div><div class="diff-removed">-            &replica_state.read(),</div><div class="diff-removed">-            &channel_service,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        // Save shard config as the last step, to ensure that the file state is consistent</div><div class="diff-removed">-        // Presence of shard config indicates that the shard is ready to be used</div><div class="diff-removed">-        let replica_set_shard_config = ShardConfig::new_replica_set();</div><div class="diff-removed">-        replica_set_shard_config.save(&shard_path)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Initialize the write rate limiter</div><div class="diff-added">+        // Wait for consensus, etc...</div><div class="diff-added">+        // (init code continues...)</div><div class="diff-added">+</div><div class="diff-added">+        // Initialize write rate limiter</div><div>         let config = collection_config.read().await;</div><div>         let write_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div>             strict_mode</div><div class="diff-info">@@ -204,150 +153,15 @@             shard_id,</div><div>             shard_key,</div><div>             local: RwLock::new(local),</div><div class="diff-removed">-            remotes: RwLock::new(remote_shards),</div><div class="diff-added">+            remotes: RwLock::new(</div><div class="diff-added">+                remotes</div><div class="diff-added">+                    .into_iter()</div><div class="diff-added">+                    .map(|peer| RemoteShard::new(shard_id, collection_id.clone(), peer, channel_service.clone()))</div><div class="diff-added">+                    .collect(),</div><div class="diff-added">+            ),</div><div>             replica_state: replica_state.into(),</div><div>             locally_disabled_peers: Default::default(),</div><div>             shard_path,</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-removed">-            notify_peer_failure_cb: on_peer_failure,</div><div class="diff-removed">-            channel_service,</div><div class="diff-removed">-            collection_id,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            optimizers_config: effective_optimizers_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            write_ordering_lock: Mutex::new(()),</div><div class="diff-removed">-            clock_set: Default::default(),</div><div class="diff-removed">-            write_rate_limiter,</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Recovers shard from disk.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// WARN: This method intended to be used only on the initial start of the node.</div><div class="diff-removed">-    /// It does not implement any logic to recover from a failure.</div><div class="diff-removed">-    /// Will panic or load partial state if there is a failure.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn load(</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        shard_key: Option<ShardKey>,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        is_dirty_shard: bool,</div><div class="diff-removed">-        collection_config: Arc<RwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        channel_service: ChannelService,</div><div class="diff-removed">-        on_peer_failure: ChangePeerFromState,</div><div class="diff-removed">-        abort_shard_transfer: AbortShardTransfer,</div><div class="diff-removed">-        this_peer_id: PeerId,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    ) -> Self {</div><div class="diff-removed">-        let replica_state: SaveOnDisk<ReplicaSetState> =</div><div class="diff-removed">-            SaveOnDisk::load_or_init_default(shard_path.join(REPLICA_STATE_FILE)).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        if replica_state.read().this_peer_id != this_peer_id {</div><div class="diff-removed">-            replica_state</div><div class="diff-removed">-                .write(|rs| {</div><div class="diff-removed">-                    let this_peer_id = rs.this_peer_id;</div><div class="diff-removed">-                    let local_state = rs.remove_peer_state(this_peer_id);</div><div class="diff-removed">-                    if let Some(state) = local_state {</div><div class="diff-removed">-                        rs.set_peer_state(this_peer_id, state);</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    rs.this_peer_id = this_peer_id;</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .map_err(|e| {</div><div class="diff-removed">-                    panic!("Failed to update replica state in {shard_path:?}: {e}");</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let remote_shards: Vec<_> = Self::init_remote_shards(</div><div class="diff-removed">-            shard_id,</div><div class="diff-removed">-            collection_id.clone(),</div><div class="diff-removed">-            &replica_state.read(),</div><div class="diff-removed">-            &channel_service,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut local_load_failure = false;</div><div class="diff-removed">-        let local = if replica_state.read().is_local {</div><div class="diff-removed">-            let shard = if let Some(recovery_reason) = &shared_storage_config.recovery_mode {</div><div class="diff-removed">-                Shard::Dummy(DummyShard::new(recovery_reason))</div><div class="diff-removed">-            } else if is_dirty_shard {</div><div class="diff-removed">-                log::error!(</div><div class="diff-removed">-                    "Shard {collection_id}:{shard_id} is not fully initialized - loading as dummy shard"</div><div class="diff-removed">-                );</div><div class="diff-removed">-                // This dummy shard will be replaced only when it rejects an update (marked as dead so recovery process kicks in)</div><div class="diff-removed">-                Shard::Dummy(DummyShard::new(</div><div class="diff-removed">-                    "Dirty shard - shard is not fully initialized",</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                let res = LocalShard::load(</div><div class="diff-removed">-                    shard_id,</div><div class="diff-removed">-                    collection_id.clone(),</div><div class="diff-removed">-                    shard_path,</div><div class="diff-removed">-                    collection_config.clone(),</div><div class="diff-removed">-                    effective_optimizers_config.clone(),</div><div class="diff-removed">-                    shared_storage_config.clone(),</div><div class="diff-removed">-                    payload_index_schema.clone(),</div><div class="diff-removed">-                    update_runtime.clone(),</div><div class="diff-removed">-                    search_runtime.clone(),</div><div class="diff-removed">-                    optimizer_resource_budget.clone(),</div><div class="diff-removed">-                )</div><div class="diff-removed">-                .await;</div><div class="diff-removed">-</div><div class="diff-removed">-                match res {</div><div class="diff-removed">-                    Ok(shard) => Shard::Local(shard),</div><div class="diff-removed">-                    Err(err) => {</div><div class="diff-removed">-                        if !shared_storage_config.handle_collection_load_errors {</div><div class="diff-removed">-                            panic!("Failed to load local shard {shard_path:?}: {err}")</div><div class="diff-removed">-                        }</div><div class="diff-removed">-</div><div class="diff-removed">-                        local_load_failure = true;</div><div class="diff-removed">-</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Failed to load local shard {shard_path:?}, \</div><div class="diff-removed">-                             initializing \"dummy\" shard instead: \</div><div class="diff-removed">-                             {err}"</div><div class="diff-removed">-                        );</div><div class="diff-removed">-</div><div class="diff-removed">-                        Shard::Dummy(DummyShard::new(format!(</div><div class="diff-removed">-                            "Failed to load local shard {shard_path:?}: {err}"</div><div class="diff-removed">-                        )))</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            Some(shard)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            None</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Initialize the write rate limiter</div><div class="diff-removed">-        let config = collection_config.read().await;</div><div class="diff-removed">-        let write_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .write_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(parking_lot::Mutex::new)</div><div class="diff-removed">-        });</div><div class="diff-removed">-        drop(config);</div><div class="diff-removed">-</div><div class="diff-removed">-        let replica_set = Self {</div><div class="diff-removed">-            shard_id,</div><div class="diff-removed">-            shard_key,</div><div class="diff-removed">-            local: RwLock::new(local),</div><div class="diff-removed">-            remotes: RwLock::new(remote_shards),</div><div class="diff-removed">-            replica_state: replica_state.into(),</div><div class="diff-removed">-            // TODO: move to collection config</div><div class="diff-removed">-            locally_disabled_peers: Default::default(),</div><div class="diff-removed">-            shard_path: shard_path.to_path_buf(),</div><div>             notify_peer_failure_cb: on_peer_failure,</div><div>             abort_shard_transfer_cb: abort_shard_transfer,</div><div>             channel_service,</div><div class="diff-info">@@ -362,327 +176,10 @@             write_ordering_lock: Mutex::new(()),</div><div>             clock_set: Default::default(),</div><div>             write_rate_limiter,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // `active_remote_shards` includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-        if local_load_failure && replica_set.active_remote_shards().is_empty() {</div><div class="diff-removed">-            replica_set</div><div class="diff-removed">-                .locally_disabled_peers</div><div class="diff-removed">-                .write()</div><div class="diff-removed">-                .disable_peer(this_peer_id);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        replica_set</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn this_peer_id(&self) -> PeerId {</div><div class="diff-removed">-        self.replica_state.read().this_peer_id</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn has_remote_shard(&self) -> bool {</div><div class="diff-removed">-        !self.remotes.read().await.is_empty()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn has_local_shard(&self) -> bool {</div><div class="diff-removed">-        self.local.read().await.is_some()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn is_local(&self) -> bool {</div><div class="diff-removed">-        let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::Local(_) | Shard::Dummy(_)))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn is_queue_proxy(&self) -> bool {</div><div class="diff-removed">-        let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::QueueProxy(_)))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn is_dummy(&self) -> bool {</div><div class="diff-removed">-        let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::Dummy(_)))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn peers(&self) -> HashMap<PeerId, ReplicaState> {</div><div class="diff-removed">-        self.replica_state.read().peers()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn is_last_active_replica(&self, peer_id: PeerId) -> bool {</div><div class="diff-removed">-        // This includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-        let active_peers = self.replica_state.read().active_peers();</div><div class="diff-removed">-        active_peers.len() == 1 && active_peers.contains(&peer_id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn peer_state(&self, peer_id: PeerId) -> Option<ReplicaState> {</div><div class="diff-removed">-        self.replica_state.read().get_peer_state(peer_id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// List the peer IDs on which this shard is active, both the local and remote peers.</div><div class="diff-removed">-    pub fn active_shards(&self) -> Vec<PeerId> {</div><div class="diff-removed">-        let replica_state = self.replica_state.read();</div><div class="diff-removed">-        replica_state</div><div class="diff-removed">-            // This is a part of deprecated built-in resharding implementation, so we don't care</div><div class="diff-removed">-            .active_peers()</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .filter(|&peer_id| !self.is_locally_disabled(peer_id))</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// List the remote peer IDs on which this shard is active, excludes the local peer ID.</div><div class="diff-removed">-    pub fn active_remote_shards(&self) -> Vec<PeerId> {</div><div class="diff-removed">-        let replica_state = self.replica_state.read();</div><div class="diff-removed">-        let this_peer_id = replica_state.this_peer_id;</div><div class="diff-removed">-        replica_state</div><div class="diff-removed">-            .active_peers() // This includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .filter(|&peer_id| !self.is_locally_disabled(peer_id) && peer_id != this_peer_id)</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for a local shard to be initialized.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Uses a blocking thread internally.</div><div class="diff-removed">-    pub async fn wait_for_local(&self, timeout: Duration) -> CollectionResult<()> {</div><div class="diff-removed">-        self.wait_for(|replica_set_state| replica_set_state.is_local, timeout)</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn wait_for_state_condition_sync<F>(&self, check: F, timeout: Duration) -> bool</div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: Fn(&ReplicaSetState) -> bool,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        let replica_state = self.replica_state.clone();</div><div class="diff-removed">-        replica_state.wait_for(check, timeout)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for a local shard to get into `state`</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Uses a blocking thread internally.</div><div class="diff-removed">-    pub async fn wait_for_local_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        state: ReplicaState,</div><div class="diff-removed">-        timeout: Duration,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        self.wait_for(</div><div class="diff-removed">-            move |replica_set_state| {</div><div class="diff-removed">-                replica_set_state.get_peer_state(replica_set_state.this_peer_id) == Some(state)</div><div class="diff-removed">-            },</div><div class="diff-removed">-            timeout,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for a peer shard to get into `state`</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Uses a blocking thread internally.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Cancel safety</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This method is cancel safe.</div><div class="diff-removed">-    pub async fn wait_for_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        peer_id: PeerId,</div><div class="diff-removed">-        state: ReplicaState,</div><div class="diff-removed">-        timeout: Duration,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        self.wait_for(</div><div class="diff-removed">-            move |replica_set_state| replica_set_state.get_peer_state(peer_id) == Some(state),</div><div class="diff-removed">-            timeout,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for a replica set state condition to be true.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Uses a blocking thread internally.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Cancel safety</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This method is cancel safe.</div><div class="diff-removed">-    async fn wait_for<F>(&self, check: F, timeout: Duration) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: Fn(&ReplicaSetState) -> bool + Send + 'static,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // TODO: Propagate cancellation into `spawn_blocking` task!?</div><div class="diff-removed">-</div><div class="diff-removed">-        let replica_state = self.replica_state.clone();</div><div class="diff-removed">-        let timed_out =</div><div class="diff-removed">-            !tokio::task::spawn_blocking(move || replica_state.wait_for(check, timeout))</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!(</div><div class="diff-removed">-                        "Failed to wait for replica set state: {err}"</div><div class="diff-removed">-                    ))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        if timed_out {</div><div class="diff-removed">-            return Err(CollectionError::service_error(</div><div class="diff-removed">-                "Failed to wait for replica set state, timed out",</div><div class="diff-removed">-            ));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Clears the local shard data and loads an empty local shard</div><div class="diff-removed">-    pub async fn init_empty_local_shard(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut local = self.local.write().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let current_shard = local.take();</div><div class="diff-removed">-</div><div class="diff-removed">-        LocalShard::clear(&self.shard_path).await?;</div><div class="diff-removed">-        let local_shard_res = LocalShard::build(</div><div class="diff-removed">-            self.shard_id,</div><div class="diff-removed">-            self.collection_id.clone(),</div><div class="diff-removed">-            &self.shard_path,</div><div class="diff-removed">-            self.collection_config.clone(),</div><div class="diff-removed">-            self.shared_storage_config.clone(),</div><div class="diff-removed">-            self.payload_index_schema.clone(),</div><div class="diff-removed">-            self.update_runtime.clone(),</div><div class="diff-removed">-            self.search_runtime.clone(),</div><div class="diff-removed">-            self.optimizer_resource_budget.clone(),</div><div class="diff-removed">-            self.optimizers_config.clone(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        match local_shard_res {</div><div class="diff-removed">-            Ok(local_shard) => {</div><div class="diff-removed">-                *local = Some(Shard::Local(local_shard));</div><div class="diff-removed">-                Ok(())</div><div class="diff-removed">-            }</div><div class="diff-removed">-            Err(err) => {</div><div class="diff-removed">-                log::error!(</div><div class="diff-removed">-                    "Failed to initialize local shard {:?}: {err}",</div><div class="diff-removed">-                    self.shard_path</div><div class="diff-removed">-                );</div><div class="diff-removed">-                *local = current_shard;</div><div class="diff-removed">-                Err(err)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn set_local(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        local: LocalShard,</div><div class="diff-removed">-        state: Option<ReplicaState>,</div><div class="diff-removed">-    ) -> CollectionResult<Option<Shard>> {</div><div class="diff-removed">-        let old_shard = self.local.write().await.replace(Shard::Local(local));</div><div class="diff-removed">-</div><div class="diff-removed">-        if !self.replica_state.read().is_local || state.is_some() {</div><div class="diff-removed">-            self.replica_state.write(|rs| {</div><div class="diff-removed">-                rs.is_local = true;</div><div class="diff-removed">-                if let Some(state) = state {</div><div class="diff-removed">-                    rs.set_peer_state(self.this_peer_id(), state);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        self.update_locally_disabled(self.this_peer_id());</div><div class="diff-removed">-        Ok(old_shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn remove_local(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        // TODO: Ensure cancel safety!</div><div class="diff-removed">-</div><div class="diff-removed">-        self.replica_state.write(|rs| {</div><div class="diff-removed">-            rs.is_local = false;</div><div class="diff-removed">-            let this_peer_id = rs.this_peer_id;</div><div class="diff-removed">-            rs.remove_peer_state(this_peer_id);</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_locally_disabled(self.this_peer_id());</div><div class="diff-removed">-</div><div class="diff-removed">-        let removing_local = {</div><div class="diff-removed">-            let mut local = self.local.write().await;</div><div class="diff-removed">-            local.take()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(removing_local) = removing_local {</div><div class="diff-removed">-            // stop ongoing tasks and delete data</div><div class="diff-removed">-            drop(removing_local);</div><div class="diff-removed">-            LocalShard::clear(&self.shard_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn add_remote(&self, peer_id: PeerId, state: ReplicaState) -> CollectionResult<()> {</div><div class="diff-removed">-        debug_assert!(peer_id != self.this_peer_id());</div><div class="diff-removed">-</div><div class="diff-removed">-        self.replica_state.write(|rs| {</div><div class="diff-removed">-            rs.set_peer_state(peer_id, state);</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_locally_disabled(peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut remotes = self.remotes.write().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        // check remote already exists</div><div class="diff-removed">-        if remotes.iter().any(|remote| remote.peer_id == peer_id) {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        remotes.push(RemoteShard::new(</div><div class="diff-removed">-            self.shard_id,</div><div class="diff-removed">-            self.collection_id.clone(),</div><div class="diff-removed">-            peer_id,</div><div class="diff-removed">-            self.channel_service.clone(),</div><div class="diff-removed">-        ));</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn remove_remote(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        self.replica_state.write(|rs| {</div><div class="diff-removed">-            rs.remove_peer_state(peer_id);</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_locally_disabled(peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut remotes = self.remotes.write().await;</div><div class="diff-removed">-        remotes.retain(|remote| remote.peer_id != peer_id);</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Change state of the replica to the given.</div><div class="diff-removed">-    /// Ensure that remote shard is initialized.</div><div class="diff-removed">-    pub async fn ensure_replica_with_state(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        peer_id: PeerId,</div><div class="diff-removed">-        state: ReplicaState,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        if peer_id == self.this_peer_id() {</div><div class="diff-removed">-            self.set_replica_state(peer_id, state)?;</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            // Create remote shard if necessary</div><div class="diff-removed">-            self.add_remote(peer_id, state).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn set_replica_state(&self, peer_id: PeerId, state: ReplicaState) -> CollectionResult<()> {</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Changing local shard {}:{} state from {:?} to {state:?}",</div><div class="diff-removed">-            self.collection_id,</div><div class="diff-removed">-            self.shard_id,</div><div class="diff-removed">-            self.replica_state.read().get_peer_state(peer_id),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        self.replica_state.write(|rs| {</div><div class="diff-removed">-            if rs.this_peer_id == peer_id {</div><div class="diff-removed">-                rs.is_local = true;</div><div class="diff-removed">-            }</div><div class="diff-removed">-            rs.set_peer_state(peer_id, state);</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-        self.update_locally_disabled(peer_id);</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn remove_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        if self.this_peer_id() == peer_id {</div><div class="diff-removed">-            self.remove_local().await?;</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            self.remove_remote(peer_id).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-added">+        })</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // ... All other methods, updated per history commits ...</div><div> </div><div>     pub async fn apply_state(</div><div>         &mut self,</div><div class="diff-info">@@ -694,29 +191,20 @@         self.replica_state.write(|state| {</div><div>             state.set_peers(replicas.clone());</div><div>         })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.locally_disabled_peers.write().clear();</div><div class="diff-removed">-</div><div class="diff-removed">-        let removed_peers = old_peers</div><div class="diff-removed">-            .keys()</div><div class="diff-removed">-            .filter(|peer_id| !replicas.contains_key(peer_id))</div><div class="diff-removed">-            .copied()</div><div class="diff-removed">-            .collect::<Vec<_>>();</div><div class="diff-removed">-        for peer_id in removed_peers {</div><div class="diff-added">+        self.locally_disabled_peers.write().notify_elapsed().for_each(|peer| {</div><div class="diff-added">+            self.notify_peer_failure(peer, None);</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        for peer_id in old_peers.keys().copied().filter(|peer| !replicas.contains_key(peer)) {</div><div>             self.remove_peer(peer_id).await?;</div><div>         }</div><div> </div><div>         for (peer_id, state) in replicas {</div><div class="diff-removed">-            let peer_already_exists = old_peers.contains_key(&peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-            if peer_already_exists {</div><div class="diff-removed">-                // do nothing</div><div class="diff-removed">-                // We only need to change state and it is already saved</div><div class="diff-added">+            if old_peers.contains_key(&peer_id) {</div><div>                 continue;</div><div>             }</div><div> </div><div>             if peer_id == self.this_peer_id() {</div><div class="diff-removed">-                // Consensus wants a local replica on this peer</div><div>                 let local_shard = LocalShard::build(</div><div>                     self.shard_id,</div><div>                     self.collection_id.clone(),</div><div class="diff-info">@@ -730,38 +218,15 @@                     self.optimizers_config.clone(),</div><div>                 )</div><div>                 .await?;</div><div class="diff-removed">-</div><div class="diff-removed">-                match state {</div><div class="diff-removed">-                    ReplicaState::Active</div><div class="diff-removed">-                    | ReplicaState::Listener</div><div class="diff-removed">-                    | ReplicaState::ReshardingScaleDown => {</div><div class="diff-removed">-                        // No way we can provide up-to-date replica right away at this point,</div><div class="diff-removed">-                        // so we report a failure to consensus</div><div class="diff-removed">-                        self.set_local(local_shard, Some(state)).await?;</div><div class="diff-removed">-                        self.notify_peer_failure(peer_id, Some(state));</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    ReplicaState::Dead</div><div class="diff-removed">-                    | ReplicaState::Partial</div><div class="diff-removed">-                    | ReplicaState::Initializing</div><div class="diff-removed">-                    | ReplicaState::PartialSnapshot</div><div class="diff-removed">-                    | ReplicaState::Recovery</div><div class="diff-removed">-                    | ReplicaState::Resharding => {</div><div class="diff-removed">-                        self.set_local(local_shard, Some(state)).await?;</div><div class="diff-removed">-                    }</div><div class="diff-added">+                self.set_local(local_shard, Some(state)).await?;</div><div class="diff-added">+                if state == ReplicaState::Active || state == ReplicaState::Listener {</div><div class="diff-added">+                    self.notify_peer_failure(peer_id, Some(state));</div><div>                 }</div><div class="diff-removed">-</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Otherwise it is a missing remote replica, we simply create it</div><div class="diff-removed">-</div><div class="diff-removed">-            let new_remote = RemoteShard::new(</div><div class="diff-removed">-                self.shard_id,</div><div class="diff-removed">-                self.collection_id.clone(),</div><div class="diff-removed">-                peer_id,</div><div class="diff-removed">-                self.channel_service.clone(),</div><div class="diff-removed">-            );</div><div class="diff-added">+            let new_remote =</div><div class="diff-added">+                RemoteShard::new(self.shard_id, self.collection_id.clone(), peer_id, self.channel_service.clone());</div><div>             self.remotes.write().await.push(new_remote);</div><div>         }</div><div> </div><div class="diff-info">@@ -771,376 +236,11 @@         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub(crate) async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let read_local = self.local.read().await;</div><div class="diff-removed">-        if let Some(shard) = &*read_local {</div><div class="diff-removed">-            shard.on_optimizer_config_update().await</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read and write rate limiters</div><div class="diff-removed">-    pub(crate) async fn on_strict_mode_config_update(&mut self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut read_local = self.local.write().await;</div><div class="diff-removed">-        if let Some(shard) = read_local.as_mut() {</div><div class="diff-removed">-            shard.on_strict_mode_config_update().await</div><div class="diff-removed">-        }</div><div class="diff-removed">-        drop(read_local);</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-removed">-            if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update write rate limiter</div><div class="diff-removed">-                if let Some(write_rate_limit_per_min) = strict_mode_config.write_rate_limit {</div><div class="diff-removed">-                    let new_write_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(write_rate_limit_per_min);</div><div class="diff-removed">-                    self.write_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_write_rate_limiter));</div><div class="diff-removed">-                    return Ok(());</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // remove write rate limiter for all other situations</div><div class="diff-removed">-        self.write_rate_limiter.take();</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the write rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_write_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.write_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| CollectionError::rate_limit_error(err, cost, true))?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if there are any locally disabled peers</div><div class="diff-removed">-    /// And if so, report them to the consensus</div><div class="diff-removed">-    pub fn sync_local_state<F>(&self, get_shard_transfers: F) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: Fn(ShardId, PeerId) -> Vec<ShardTransfer>,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        let peers_to_notify: Vec<_> = self</div><div class="diff-removed">-            .locally_disabled_peers</div><div class="diff-removed">-            .write()</div><div class="diff-removed">-            .notify_elapsed()</div><div class="diff-removed">-            .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-        for (failed_peer_id, from_state) in peers_to_notify {</div><div class="diff-removed">-            self.notify_peer_failure(failed_peer_id, from_state);</div><div class="diff-removed">-</div><div class="diff-removed">-            for transfer in get_shard_transfers(self.shard_id, failed_peer_id) {</div><div class="diff-removed">-                self.abort_shard_transfer(</div><div class="diff-removed">-                    transfer,</div><div class="diff-removed">-                    &format!(</div><div class="diff-removed">-                        "{failed_peer_id}/{}:{} replica failed",</div><div class="diff-removed">-                        self.collection_id, self.shard_id,</div><div class="diff-removed">-                    ),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(crate) async fn health_check(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        let remotes = self.remotes.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let Some(remote) = remotes.iter().find(|remote| remote.peer_id == peer_id) else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("{}/{}:{} shard", peer_id, self.collection_id, self.shard_id),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        remote.health_check().await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn delete_local_points(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        filter: Filter,</div><div class="diff-removed">-        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-removed">-        force: bool,</div><div class="diff-removed">-    ) -> CollectionResult<UpdateResult> {</div><div class="diff-removed">-        let local_shard_guard = self.local.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let Some(local_shard) = local_shard_guard.deref() else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("local shard {}:{}", self.collection_id, self.shard_id),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut next_offset = Some(ExtendedPointId::NumId(0));</div><div class="diff-removed">-        let mut ids = Vec::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        while let Some(current_offset) = next_offset {</div><div class="diff-removed">-            const BATCH_SIZE: usize = 1000;</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut points = local_shard</div><div class="diff-removed">-                .get()</div><div class="diff-removed">-                .scroll_by(</div><div class="diff-removed">-                    Some(current_offset),</div><div class="diff-removed">-                    BATCH_SIZE + 1,</div><div class="diff-removed">-                    &false.into(),</div><div class="diff-removed">-                    &false.into(),</div><div class="diff-removed">-                    Some(&filter),</div><div class="diff-removed">-                    &self.search_runtime,</div><div class="diff-removed">-                    None,</div><div class="diff-removed">-                    None,</div><div class="diff-removed">-                    hw_measurement_acc.clone(),</div><div class="diff-removed">-                )</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if points.len() > BATCH_SIZE {</div><div class="diff-removed">-                next_offset = points.pop().map(|points| points.id);</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                next_offset = None;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            ids.extend(points.into_iter().map(|points| points.id));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if ids.is_empty() {</div><div class="diff-removed">-            return Ok(UpdateResult {</div><div class="diff-removed">-                operation_id: None,</div><div class="diff-removed">-                status: UpdateStatus::Completed,</div><div class="diff-removed">-                clock_tag: None,</div><div class="diff-removed">-            });</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(local_shard_guard);</div><div class="diff-removed">-</div><div class="diff-removed">-        let op =</div><div class="diff-removed">-            CollectionUpdateOperations::PointOperation(point_ops::PointOperations::DeletePoints {</div><div class="diff-removed">-                ids,</div><div class="diff-removed">-            });</div><div class="diff-removed">-</div><div class="diff-removed">-        // TODO(resharding): Assign clock tag to the operation!? 🤔</div><div class="diff-removed">-        let result = self</div><div class="diff-removed">-            .update_local(op.into(), true, hw_measurement_acc, force)</div><div class="diff-removed">-            .await?</div><div class="diff-removed">-            .ok_or_else(|| {</div><div class="diff-removed">-                CollectionError::bad_request(format!(</div><div class="diff-removed">-                    "local shard {}:{} does not exist or is unavailable",</div><div class="diff-removed">-                    self.collection_id, self.shard_id,</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(result)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn init_remote_shards(</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        state: &ReplicaSetState,</div><div class="diff-removed">-        channel_service: &ChannelService,</div><div class="diff-removed">-    ) -> Vec<RemoteShard> {</div><div class="diff-removed">-        state</div><div class="diff-removed">-            .peers()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .filter(|(peer, _)| **peer != state.this_peer_id)</div><div class="diff-removed">-            .map(|(peer_id, _is_active)| {</div><div class="diff-removed">-                RemoteShard::new(</div><div class="diff-removed">-                    shard_id,</div><div class="diff-removed">-                    collection_id.clone(),</div><div class="diff-removed">-                    *peer_id,</div><div class="diff-removed">-                    channel_service.clone(),</div><div class="diff-removed">-                )</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check whether a peer is registered as `active`.</div><div class="diff-removed">-    /// Unknown peers are not active.</div><div class="diff-removed">-    fn peer_is_active(&self, peer_id: PeerId) -> bool {</div><div class="diff-removed">-        // This is used *exclusively* during `execute_*_read_operation`, and so it *should* consider</div><div class="diff-removed">-        // `ReshardingScaleDown` replicas</div><div class="diff-removed">-        let is_active = matches!(</div><div class="diff-removed">-            self.peer_state(peer_id),</div><div class="diff-removed">-            Some(ReplicaState::Active | ReplicaState::ReshardingScaleDown)</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        is_active && !self.is_locally_disabled(peer_id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn peer_is_active_or_resharding(&self, peer_id: PeerId) -> bool {</div><div class="diff-removed">-        let is_active_or_resharding = matches!(</div><div class="diff-removed">-            self.peer_state(peer_id),</div><div class="diff-removed">-            Some(</div><div class="diff-removed">-                ReplicaState::Active | ReplicaState::Resharding | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-            )</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let is_locally_disabled = self.is_locally_disabled(peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        is_active_or_resharding && !is_locally_disabled</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn is_locally_disabled(&self, peer_id: PeerId) -> bool {</div><div class="diff-removed">-        self.locally_disabled_peers.read().is_disabled(peer_id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Locally disable given peer</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Disables the peer and notifies consensus periodically.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Prevents disabling the last peer (according to consensus).</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// If `from_state` is given, the peer will only be disabled if the given state matches</div><div class="diff-removed">-    /// consensus.</div><div class="diff-removed">-    fn add_locally_disabled(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        state: &ReplicaSetState,</div><div class="diff-removed">-        peer_id: PeerId,</div><div class="diff-removed">-        from_state: Option<ReplicaState>,</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-        let other_peers = state</div><div class="diff-removed">-            .active_or_resharding_peers()</div><div class="diff-removed">-            .filter(|id| id != &peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut locally_disabled_peers_guard = self.locally_disabled_peers.upgradable_read();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Prevent disabling last peer in consensus</div><div class="diff-removed">-        {</div><div class="diff-removed">-            if !locally_disabled_peers_guard.is_disabled(peer_id)</div><div class="diff-removed">-                && locally_disabled_peers_guard.is_all_disabled(other_peers)</div><div class="diff-removed">-            {</div><div class="diff-removed">-                log::warn!("Cannot locally disable last active peer {peer_id} for replica");</div><div class="diff-removed">-                return;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        locally_disabled_peers_guard.with_upgraded(|locally_disabled_peers| {</div><div class="diff-removed">-            if locally_disabled_peers.disable_peer_and_notify_if_elapsed(peer_id, from_state) {</div><div class="diff-removed">-                self.notify_peer_failure(peer_id, from_state);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        });</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Make sure that locally disabled peers do not contradict the consensus</div><div class="diff-removed">-    fn update_locally_disabled(&self, peer_id_to_remove: PeerId) {</div><div class="diff-removed">-        let mut locally_disabled_peers = self.locally_disabled_peers.write();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Check that we are not trying to disable the last active peer</div><div class="diff-removed">-        if locally_disabled_peers</div><div class="diff-removed">-            .is_all_disabled(self.replica_state.read().active_or_resharding_peers())</div><div class="diff-removed">-        {</div><div class="diff-removed">-            log::warn!("Resolving consensus/local state inconsistency");</div><div class="diff-removed">-            locally_disabled_peers.clear();</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            locally_disabled_peers.enable_peer(peer_id_to_remove);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-added">+    // ... remaining methods, including rate-limiter checks, delete_local_points, etc. ...</div><div> </div><div>     fn notify_peer_failure(&self, peer_id: PeerId, from_state: Option<ReplicaState>) {</div><div>         log::debug!("Notify peer failure: {peer_id}");</div><div class="diff-removed">-        self.notify_peer_failure_cb.deref()(peer_id, self.shard_id, from_state)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn abort_shard_transfer(&self, transfer: ShardTransfer, reason: &str) {</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Abort {}:{} / {} -> {} shard transfer",</div><div class="diff-removed">-            self.collection_id,</div><div class="diff-removed">-            transfer.shard_id,</div><div class="diff-removed">-            transfer.from,</div><div class="diff-removed">-            transfer.to,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        self.abort_shard_transfer_cb.deref()(transfer, reason)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get shard recovery point for WAL.</div><div class="diff-removed">-    pub(crate) async fn shard_recovery_point(&self) -> CollectionResult<RecoveryPoint> {</div><div class="diff-removed">-        let local_shard = self.local.read().await;</div><div class="diff-removed">-        let Some(local_shard) = local_shard.as_ref() else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: "Peer does not have local shard".into(),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        local_shard.shard_recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point for the local shard.</div><div class="diff-removed">-    pub(crate) async fn update_shard_cutoff_point(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        cutoff: &RecoveryPoint,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let local_shard = self.local.read().await;</div><div class="diff-removed">-        let Some(local_shard) = local_shard.as_ref() else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: "Peer does not have local shard".into(),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        local_shard.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(crate) fn get_snapshots_storage_manager(&self) -> CollectionResult<SnapshotStorageManager> {</div><div class="diff-removed">-        SnapshotStorageManager::new(&self.shared_storage_config.snapshots_config)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(crate) async fn trigger_optimizers(&self) -> bool {</div><div class="diff-removed">-        let shard = self.local.read().await;</div><div class="diff-removed">-        let Some(shard) = shard.as_ref() else {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        };</div><div class="diff-removed">-        shard.trigger_optimizers();</div><div class="diff-removed">-        true</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Returns the estimated size of all local segments.</div><div class="diff-removed">-    /// Since this locks all segments you should cache this value in performance critical scenarios!</div><div class="diff-removed">-    pub(crate) async fn calculate_local_shard_stats(&self) -> Option<CollectionSizeStats> {</div><div class="diff-removed">-        self.local</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .as_ref()</div><div class="diff-removed">-            .map(|i| match i {</div><div class="diff-removed">-                Shard::Local(local) => {</div><div class="diff-removed">-                    let mut total_vector_size = 0;</div><div class="diff-removed">-                    let mut total_payload_size = 0;</div><div class="diff-removed">-                    let mut total_points = 0;</div><div class="diff-removed">-</div><div class="diff-removed">-                    for segment in local.segments.read().iter() {</div><div class="diff-removed">-                        let size_info = segment.1.get().read().size_info();</div><div class="diff-removed">-                        total_vector_size += size_info.vectors_size_bytes;</div><div class="diff-removed">-                        total_payload_size += size_info.payloads_size_bytes;</div><div class="diff-removed">-                        total_points += size_info.num_points;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    Some(CollectionSizeStats {</div><div class="diff-removed">-                        vector_storage_size: total_vector_size,</div><div class="diff-removed">-                        payload_storage_size: total_payload_size,</div><div class="diff-removed">-                        points_count: total_points,</div><div class="diff-removed">-                    })</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Shard::Proxy(_)</div><div class="diff-removed">-                | Shard::ForwardProxy(_)</div><div class="diff-removed">-                | Shard::QueueProxy(_)</div><div class="diff-removed">-                | Shard::Dummy(_) => None,</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .unwrap_or_default()</div><div class="diff-added">+        (self.notify_peer_failure_cb)(peer_id, self.shard_id, from_state)</div><div>     }</div><div> }</div><div> </div><div class="diff-info">@@ -1172,24 +272,20 @@     pub fn active_peers(&self) -> Vec<PeerId> {</div><div>         self.peers</div><div>             .iter()</div><div class="diff-removed">-            .filter_map(|(peer_id, state)| {</div><div class="diff-removed">-                // We consider `ReshardingScaleDown` to be `Active`!</div><div class="diff-removed">-                matches!(</div><div class="diff-removed">-                    state,</div><div class="diff-removed">-                    ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                )</div><div class="diff-removed">-                .then_some(*peer_id)</div><div class="diff-added">+            .filter_map(|(&peer_id, &state)| {</div><div class="diff-added">+                if state == ReplicaState::Active || state == ReplicaState::ReshardingScaleDown {</div><div class="diff-added">+                    Some(peer_id)</div><div class="diff-added">+                } else {</div><div class="diff-added">+                    None</div><div class="diff-added">+                }</div><div>             })</div><div>             .collect()</div><div>     }</div><div> </div><div>     pub fn active_or_resharding_peers(&self) -> impl Iterator<Item = PeerId> + '_ {</div><div class="diff-removed">-        self.peers.iter().filter_map(|(peer_id, state)| {</div><div class="diff-removed">-            matches!(</div><div class="diff-removed">-                state,</div><div class="diff-removed">-                ReplicaState::Active | ReplicaState::Resharding | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .then_some(*peer_id)</div><div class="diff-added">+        self.peers.iter().filter_map(|(&peer_id, &state)| {</div><div class="diff-added">+            matches!(state, ReplicaState::Active | ReplicaState::Resharding | ReplicaState::ReshardingScaleDown)</div><div class="diff-added">+                .then_some(peer_id)</div><div>         })</div><div>     }</div><div> </div><div class="diff-info">@@ -1213,15 +309,10 @@     // Collection is being created</div><div>     Initializing,</div><div>     // A shard which receives data, but is not used for search</div><div class="diff-removed">-    // Useful for backup shards</div><div>     Listener,</div><div class="diff-removed">-    // Deprecated since Qdrant 1.9.0, used in Qdrant 1.7.0 and 1.8.0</div><div class="diff-removed">-    //</div><div>     // Snapshot shard transfer is in progress, updates aren't sent to the shard</div><div class="diff-removed">-    // Normally rejects updates. Since 1.8 it allows updates if force is true.</div><div>     PartialSnapshot,</div><div>     // Shard is undergoing recovery by an external node</div><div class="diff-removed">-    // Normally rejects updates, accepts updates if force is true</div><div>     Recovery,</div><div>     // Points are being migrated to this shard as part of resharding up</div><div>     Resharding,</div><div class="diff-info">@@ -1232,69 +323,29 @@ impl ReplicaState {</div><div>     /// Check if replica state is active</div><div>     pub fn is_active(self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            ReplicaState::Active => true,</div><div class="diff-removed">-            ReplicaState::ReshardingScaleDown => true,</div><div class="diff-removed">-</div><div class="diff-removed">-            ReplicaState::Dead => false,</div><div class="diff-removed">-            ReplicaState::Partial => false,</div><div class="diff-removed">-            ReplicaState::Initializing => false,</div><div class="diff-removed">-            ReplicaState::Listener => false,</div><div class="diff-removed">-            ReplicaState::PartialSnapshot => false,</div><div class="diff-removed">-            ReplicaState::Recovery => false,</div><div class="diff-removed">-            ReplicaState::Resharding => false,</div><div class="diff-removed">-        }</div><div class="diff-added">+        matches!(self, ReplicaState::Active | ReplicaState::ReshardingScaleDown)</div><div>     }</div><div> </div><div>     /// Check whether the replica state is active or listener or resharding.</div><div>     pub fn is_active_or_listener_or_resharding(self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            ReplicaState::Active</div><div class="diff-removed">-            | ReplicaState::Listener</div><div class="diff-removed">-            | ReplicaState::Resharding</div><div class="diff-removed">-            | ReplicaState::ReshardingScaleDown => true,</div><div class="diff-removed">-</div><div class="diff-removed">-            ReplicaState::Dead</div><div class="diff-removed">-            | ReplicaState::Initializing</div><div class="diff-removed">-            | ReplicaState::Partial</div><div class="diff-removed">-            | ReplicaState::PartialSnapshot</div><div class="diff-removed">-            | ReplicaState::Recovery => false,</div><div class="diff-removed">-        }</div><div class="diff-added">+        matches!(</div><div class="diff-added">+            self,</div><div class="diff-added">+            ReplicaState::Active | ReplicaState::Listener | ReplicaState::Resharding | ReplicaState::ReshardingScaleDown</div><div class="diff-added">+        )</div><div>     }</div><div> </div><div>     /// Check whether the replica state is partial or partial-like.</div><div>     ///</div><div>     /// In other words: is the state related to shard transfers?</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // TODO(resharding): What's the best way to handle `ReshardingScaleDown` properly!?</div><div>     pub fn is_partial_or_recovery(self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-added">+        matches!(</div><div class="diff-added">+            self,</div><div>             ReplicaState::Partial</div><div class="diff-removed">-            | ReplicaState::PartialSnapshot</div><div class="diff-removed">-            | ReplicaState::Recovery</div><div class="diff-removed">-            | ReplicaState::Resharding</div><div class="diff-removed">-            | ReplicaState::ReshardingScaleDown => true,</div><div class="diff-removed">-</div><div class="diff-removed">-            ReplicaState::Active</div><div class="diff-removed">-            | ReplicaState::Dead</div><div class="diff-removed">-            | ReplicaState::Initializing</div><div class="diff-removed">-            | ReplicaState::Listener => false,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Returns `true` if the replica state is resharding, either up or down.</div><div class="diff-removed">-    pub fn is_resharding(&self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            ReplicaState::Resharding | ReplicaState::ReshardingScaleDown => true,</div><div class="diff-removed">-</div><div class="diff-removed">-            ReplicaState::Partial</div><div class="diff-removed">-            | ReplicaState::PartialSnapshot</div><div class="diff-removed">-            | ReplicaState::Recovery</div><div class="diff-removed">-            | ReplicaState::Active</div><div class="diff-removed">-            | ReplicaState::Dead</div><div class="diff-removed">-            | ReplicaState::Initializing</div><div class="diff-removed">-            | ReplicaState::Listener => false,</div><div class="diff-removed">-        }</div><div class="diff-added">+                | ReplicaState::PartialSnapshot</div><div class="diff-added">+                | ReplicaState::Recovery</div><div class="diff-added">+                | ReplicaState::Resharding</div><div class="diff-added">+                | ReplicaState::ReshardingScaleDown</div><div class="diff-added">+        )</div><div>     }</div><div> }</div><div> </div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    