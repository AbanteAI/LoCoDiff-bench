<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - o4-mini-high</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <h2>Model: o4-mini-high</h2>
        <p><a href="../../models/openai_o4-mini-high.html">All o4-mini-high Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-high</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Native Prompt Tokens:</strong> 58515</p>
                <p><strong>Native Completion Tokens:</strong> 32602</p>
                <p><strong>Native Tokens Reasoning:</strong> 26368</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.2078153</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b..451ae85b 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmp0i5ryhez_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmpezasvldo_actual.txt	</div><div class="diff-info">@@ -29,9 +29,6 @@ use tokio::sync::{Mutex, RwLock, RwLockWriteGuard};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_state::{ShardInfo, State};</div><div class="diff-removed">-use crate::common::collection_size_stats::{</div><div class="diff-removed">-    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-removed">-};</div><div> use crate::common::is_ready::IsReady;</div><div> use crate::config::CollectionConfigInternal;</div><div> use crate::operations::config_diff::{DiffConfig, OptimizersConfigDiff};</div><div class="diff-info">@@ -42,20 +39,17 @@ use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::channel_service::ChannelService;</div><div> use crate::shards::collection_shard_distribution::CollectionShardDistribution;</div><div> use crate::shards::local_shard::clock_map::RecoveryPoint;</div><div class="diff-removed">-use crate::shards::replica_set::ReplicaState::{Active, Dead, Initializing, Listener};</div><div> use crate::shards::replica_set::{</div><div>     ChangePeerFromState, ChangePeerState, ReplicaState, ShardReplicaSet,</div><div> };</div><div class="diff-added">+use crate::shards::resharding::ReshardKey;</div><div> use crate::shards::shard::{PeerId, ShardId};</div><div class="diff-removed">-use crate::shards::shard_holder::shard_mapping::ShardKeyMapping;</div><div> use crate::shards::shard_holder::{LockedShardHolder, ShardHolder, shard_not_found_error};</div><div> use crate::shards::transfer::helpers::check_transfer_conflicts_strict;</div><div> use crate::shards::transfer::transfer_tasks_pool::{TaskResult, TransferTasksPool};</div><div> use crate::shards::transfer::{ShardTransfer, ShardTransferMethod};</div><div> use crate::shards::{CollectionId, replica_set};</div><div class="diff-removed">-use crate::telemetry::{</div><div class="diff-removed">-    CollectionConfigTelemetry, CollectionTelemetry, CollectionsAggregatedTelemetry,</div><div class="diff-removed">-};</div><div class="diff-added">+use crate::telemetry::{CollectionConfigTelemetry, CollectionTelemetry, CollectionsAggregatedTelemetry};</div><div> </div><div> /// Collection's data is split into several shards.</div><div> pub struct Collection {</div><div class="diff-info">@@ -85,6 +79,7 @@ pub struct Collection {</div><div>     update_runtime: Handle,</div><div>     // Search runtime handle.</div><div>     search_runtime: Handle,</div><div class="diff-added">+    // Budget for optimizer CPU/IO usage.</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     // Cached statistics of collection size, may be outdated.</div><div>     collection_stats_cache: CollectionSizeStatsCache,</div><div class="diff-info">@@ -93,7 +88,6 @@ pub struct Collection {</div><div> }</div><div> </div><div> pub type RequestShardTransfer = Arc<dyn Fn(ShardTransfer) + Send + Sync>;</div><div class="diff-removed">-</div><div> pub type OnTransferFailure = Arc<dyn Fn(ShardTransfer, CollectionId, &str) + Send + Sync>;</div><div> pub type OnTransferSuccess = Arc<dyn Fn(ShardTransfer, CollectionId) + Send + Sync>;</div><div> </div><div class="diff-info">@@ -107,7 +101,6 @@ impl Collection {</div><div>         collection_config: &CollectionConfigInternal,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div>         shard_distribution: CollectionShardDistribution,</div><div class="diff-removed">-        shard_key_mapping: Option<ShardKeyMapping>,</div><div>         channel_service: ChannelService,</div><div>         on_replica_failure: ChangePeerFromState,</div><div>         request_shard_transfer: RequestShardTransfer,</div><div class="diff-info">@@ -120,23 +113,31 @@ impl Collection {</div><div>         let start_time = std::time::Instant::now();</div><div> </div><div>         let mut shard_holder = ShardHolder::new(path)?;</div><div class="diff-removed">-        shard_holder.set_shard_key_mappings(shard_key_mapping.clone().unwrap_or_default())?;</div><div class="diff-added">+        shard_holder.set_shard_key_mappings(</div><div class="diff-added">+            collection_config</div><div class="diff-added">+                .params</div><div class="diff-added">+                .shard_key_mapping</div><div class="diff-added">+                .clone()</div><div class="diff-added">+                .unwrap_or_default(),</div><div class="diff-added">+        )?;</div><div> </div><div>         let payload_index_schema = Arc::new(Self::load_payload_index_schema(path)?);</div><div> </div><div>         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div class="diff-added">+        let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-added">+        if let Some(overwrite) = optimizers_overwrite.clone() {</div><div class="diff-added">+            effective_optimizers_config = overwrite.update(&effective_optimizers_config)?;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div>         for (shard_id, mut peers) in shard_distribution.shards {</div><div>             let is_local = peers.remove(&this_peer_id);</div><div> </div><div class="diff-removed">-            let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-removed">-            if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-                effective_optimizers_config =</div><div class="diff-removed">-                    optimizers_overwrite.update(&effective_optimizers_config)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            let shard_key = shard_key_mapping</div><div class="diff-added">+            let shard_key = collection_config</div><div class="diff-added">+                .params</div><div class="diff-added">+                .shard_key_mapping</div><div>                 .as_ref()</div><div>                 .and_then(|mapping| mapping.shard_key(shard_id));</div><div class="diff-added">+</div><div>             let replica_set = ShardReplicaSet::build(</div><div>                 shard_id,</div><div>                 shard_key.clone(),</div><div class="diff-info">@@ -148,9 +149,8 @@ impl Collection {</div><div>                 abort_shard_transfer.clone(),</div><div>                 path,</div><div>                 shared_collection_config.clone(),</div><div class="diff-removed">-                effective_optimizers_config,</div><div class="diff-added">+                effective_optimizers_config.clone(),</div><div>                 shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div>                 channel_service.clone(),</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-info">@@ -159,14 +159,14 @@ impl Collection {</div><div>             )</div><div>             .await?;</div><div> </div><div class="diff-removed">-            shard_holder.add_shard(shard_id, replica_set, shard_key)?;</div><div class="diff-added">+            shard_holder.add_shard(shard_id, replica_set, shard_key.clone())?;</div><div>         }</div><div> </div><div>         let locked_shard_holder = Arc::new(LockedShardHolder::new(shard_holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection_stats_cache = CollectionSizeStatsCache::new_with_values(</div><div class="diff-removed">-            Self::estimate_collection_size_stats(&locked_shard_holder).await,</div><div class="diff-removed">-        );</div><div class="diff-added">+        let local_stats_cache =</div><div class="diff-added">+            LocalDataStatsCache::new_with_values(Self::calculate_local_shards_stats(&locked_shard_holder).await);</div><div class="diff-added">+        let collection_stats_cache =</div><div class="diff-added">+            CollectionSizeStatsCache::new_with_values(Self::estimate_collection_size_stats(&locked_shard_holder).await);</div><div> </div><div>         // Once the config is persisted - the collection is considered to be successfully created.</div><div>         CollectionVersion::save(path)?;</div><div class="diff-info">@@ -176,9 +176,9 @@ impl Collection {</div><div>             id: name.clone(),</div><div>             shards_holder: locked_shard_holder,</div><div>             collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div>             path: path.to_owned(),</div><div>             snapshots_path: snapshots_path.to_owned(),</div><div class="diff-info">@@ -206,7 +206,7 @@ impl Collection {</div><div>         snapshots_path: &Path,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div>         channel_service: ChannelService,</div><div class="diff-removed">-        on_replica_failure: replica_set::ChangePeerFromState,</div><div class="diff-added">+        on_replica_failure: ChangePeerFromState,</div><div>         request_shard_transfer: RequestShardTransfer,</div><div>         abort_shard_transfer: replica_set::AbortShardTransfer,</div><div>         search_runtime: Option<Handle>,</div><div class="diff-info">@@ -218,15 +218,13 @@ impl Collection {</div><div>         let stored_version = CollectionVersion::load(path)</div><div>             .expect("Can't read collection version")</div><div>             .expect("Collection version is not found");</div><div class="diff-removed">-</div><div>         let app_version = CollectionVersion::current();</div><div> </div><div>         if stored_version > app_version {</div><div>             panic!("Collection version is greater than application version");</div><div>         }</div><div class="diff-removed">-</div><div>         if stored_version != app_version {</div><div class="diff-removed">-            if Self::can_upgrade_storage(&stored_version, &app_version) {</div><div class="diff-added">+            if Self::can_upgrade_storage(&stored_version, &app_version.parse().unwrap()) {</div><div>                 log::info!("Migrating collection {stored_version} -> {app_version}");</div><div>                 CollectionVersion::save(path)</div><div>                     .unwrap_or_else(|err| panic!("Can't save collection version {err}"));</div><div class="diff-info">@@ -247,23 +245,17 @@ impl Collection {</div><div>         });</div><div>         collection_config.validate_and_warn();</div><div> </div><div class="diff-removed">-        let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");</div><div class="diff-added">+        let mut shard_holder = ShardHolder::new(path)?;</div><div class="diff-added">+        let shard_key_mapping = CollectionConfigInternal::load_shard_mapping(path)</div><div class="diff-added">+            .expect("Can't load or initialize shard key mapping");</div><div> </div><div class="diff-removed">-        let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-added">+        shard_holder.set_shard_key_mappings(shard_key_mapping.clone())?;</div><div> </div><div class="diff-removed">-        if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-            effective_optimizers_config = optimizers_overwrite</div><div class="diff-removed">-                .update(&effective_optimizers_config)</div><div class="diff-removed">-                .expect("Can not apply optimizer overwrite");</div><div class="diff-removed">-        }</div><div class="diff-added">+        let payload_index_schema = Arc::new(Self::load_payload_index_schema(path)</div><div class="diff-added">+            .expect("Can't load or initialize payload index schema"));</div><div> </div><div>         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div> </div><div class="diff-removed">-        let payload_index_schema = Arc::new(</div><div class="diff-removed">-            Self::load_payload_index_schema(path)</div><div class="diff-removed">-                .expect("Can't load or initialize payload index schema"),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div>         shard_holder</div><div>             .load_shards(</div><div>                 path,</div><div class="diff-info">@@ -271,7 +263,6 @@ impl Collection {</div><div>                 shared_collection_config.clone(),</div><div>                 effective_optimizers_config,</div><div>                 shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div>                 channel_service.clone(),</div><div>                 on_replica_failure.clone(),</div><div>                 abort_shard_transfer.clone(),</div><div class="diff-info">@@ -279,22 +270,21 @@ impl Collection {</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 optimizer_resource_budget.clone(),</div><div class="diff-added">+                shard_key_mapping.clone(),</div><div>             )</div><div>             .await;</div><div> </div><div>         let locked_shard_holder = Arc::new(LockedShardHolder::new(shard_holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection_stats_cache = CollectionSizeStatsCache::new_with_values(</div><div class="diff-removed">-            Self::estimate_collection_size_stats(&locked_shard_holder).await,</div><div class="diff-removed">-        );</div><div class="diff-added">+        let collection_stats_cache =</div><div class="diff-added">+            CollectionSizeStatsCache::new_with_values(Self::estimate_collection_size_stats(&locked_shard_holder).await);</div><div> </div><div>         Self {</div><div>             id: collection_id.clone(),</div><div>             shards_holder: locked_shard_holder,</div><div>             collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div>             path: path.to_owned(),</div><div>             snapshots_path: snapshots_path.to_owned(),</div><div class="diff-info">@@ -318,12 +308,6 @@ impl Collection {</div><div>     /// If major version is different, then it is not compatible.</div><div>     /// If the difference in consecutive versions is greater than 1 in patch,</div><div>     /// then the collection is not compatible with the current version.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Example:</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.1 = true</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.2 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.0 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.1 = false</div><div>     pub fn can_upgrade_storage(stored: &Version, app: &Version) -> bool {</div><div>         if stored.major != app.major {</div><div>             return false;</div><div class="diff-info">@@ -341,10 +325,6 @@ impl Collection {</div><div>         self.id.clone()</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn uuid(&self) -> Option<uuid::Uuid> {</div><div class="diff-removed">-        self.collection_config.read().await.uuid</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn get_shard_keys(&self) -> Vec<ShardKey> {</div><div>         self.shards_holder</div><div>             .read()</div><div class="diff-info">@@ -400,20 +380,13 @@ impl Collection {</div><div>             replica_set.peer_state(peer_id),</div><div>         );</div><div> </div><div class="diff-removed">-        let current_state = replica_set.peer_state(peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Validation:</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // 1. Check that peer exists in the cluster (peer might *not* exist, if it was removed from</div><div class="diff-removed">-        //    the cluster right before `SetShardReplicaSet` was proposed)</div><div class="diff-added">+        // 1. Check that peer or existing replica is in cluster</div><div>         let peer_exists = self</div><div>             .channel_service</div><div>             .id_to_address</div><div>             .read()</div><div>             .contains_key(&peer_id);</div><div class="diff-removed">-</div><div>         let replica_exists = replica_set.peer_state(peer_id).is_some();</div><div class="diff-removed">-</div><div>         if !peer_exists && !replica_exists {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Can't set replica {peer_id}:{shard_id} state to {new_state:?}, \</div><div class="diff-info">@@ -422,7 +395,8 @@ impl Collection {</div><div>             )));</div><div>         }</div><div> </div><div class="diff-removed">-        // 2. Check that `from_state` matches current state</div><div class="diff-added">+        // 2. Check that from_state matches current</div><div class="diff-added">+        let current_state = replica_set.peer_state(peer_id);</div><div>         if from_state.is_some() && current_state != from_state {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Replica {peer_id} of shard {shard_id} has state {current_state:?}, but expected {from_state:?}"</div><div class="diff-info">@@ -430,79 +404,49 @@ impl Collection {</div><div>         }</div><div> </div><div>         // 3. Do not deactivate the last active replica</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `is_last_active_replica` counts both `Active` and `ReshardingScaleDown` replicas!</div><div>         if replica_set.is_last_active_replica(peer_id) && !new_state.is_active() {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Cannot deactivate the last active replica {peer_id} of shard {shard_id}"</div><div>             )));</div><div>         }</div><div> </div><div class="diff-removed">-        // Update replica status</div><div class="diff-added">+        // Abort resharding if relevant</div><div class="diff-added">+        if matches!(current_state, Some(ReplicaState::Resharding | ReplicaState::ReshardingScaleDown))</div><div class="diff-added">+            && new_state == ReplicaState::Dead</div><div class="diff-added">+        {</div><div class="diff-added">+            drop(shard_holder);</div><div class="diff-added">+            if let Some(state) = self.resharding_state().await.filter(|s| s.peer_id == peer_id) {</div><div class="diff-added">+                self.abort_resharding(state.key(), false).await?;</div><div class="diff-added">+            }</div><div class="diff-added">+            return Ok(());</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div>         replica_set</div><div>             .ensure_replica_with_state(peer_id, new_state)</div><div>             .await?;</div><div> </div><div>         if new_state == ReplicaState::Dead {</div><div class="diff-removed">-            let resharding_state = shard_holder.resharding_state.read().clone();</div><div>             let related_transfers = shard_holder.get_related_transfers(shard_id, peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Functions below lock `shard_holder`!</div><div>             drop(shard_holder);</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut abort_resharding_result = CollectionResult::Ok(());</div><div class="diff-removed">-</div><div class="diff-removed">-            // Abort resharding, if resharding shard is marked as `Dead`.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // This branch should only be triggered, if resharding is currently at `MigratingPoints`</div><div class="diff-removed">-            // stage, because target shard should be marked as `Active`, when all resharding transfers</div><div class="diff-removed">-            // are successfully completed, and so the check *right above* this one would be triggered.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // So, if resharding reached `ReadHashRingCommitted`, this branch *won't* be triggered,</div><div class="diff-removed">-            // and resharding *won't* be cancelled. The update request should *fail* with "failed to</div><div class="diff-removed">-            // update all replicas of a shard" error.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // If resharding reached `ReadHashRingCommitted`, and this branch is triggered *somehow*,</div><div class="diff-removed">-            // then `Collection::abort_resharding` call should return an error, so no special handling</div><div class="diff-removed">-            // is needed.</div><div class="diff-removed">-            let is_resharding = current_state</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .is_some_and(ReplicaState::is_resharding);</div><div class="diff-removed">-            if is_resharding {</div><div class="diff-removed">-                if let Some(state) = resharding_state {</div><div class="diff-removed">-                    abort_resharding_result = self.abort_resharding(state.key(), false).await;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Terminate transfer if source or target replicas are now dead</div><div>             for transfer in related_transfers {</div><div>                 self.abort_shard_transfer(transfer.key(), None).await?;</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate resharding errors now</div><div class="diff-removed">-            abort_resharding_result?;</div><div>         }</div><div> </div><div>         // If not initialized yet, we need to check if it was initialized by this call</div><div>         if !self.is_initialized.check_ready() {</div><div>             let state = self.state().await;</div><div class="diff-removed">-</div><div>             let mut is_ready = true;</div><div class="diff-removed">-</div><div class="diff-removed">-            for (_shard_id, shard_info) in state.shards {</div><div class="diff-removed">-                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-removed">-                    matches!(</div><div class="diff-removed">-                        state,</div><div class="diff-removed">-                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-                if !all_replicas_active {</div><div class="diff-added">+            for (_id, shard_info) in state.shards {</div><div class="diff-added">+                let all_active = shard_info</div><div class="diff-added">+                    .replicas</div><div class="diff-added">+                    .into_iter()</div><div class="diff-added">+                    .all(|(_, st)| matches!(st, ReplicaState::Active | ReplicaState::ReshardingScaleDown));</div><div class="diff-added">+                if !all_active {</div><div>                     is_ready = false;</div><div>                     break;</div><div>                 }</div><div>             }</div><div class="diff-removed">-</div><div>             if is_ready {</div><div>                 self.is_initialized.make_ready();</div><div>             }</div><div class="diff-info">@@ -513,14 +457,12 @@ impl Collection {</div><div> </div><div>     pub async fn shard_recovery_point(&self, shard_id: ShardId) -> CollectionResult<RecoveryPoint> {</div><div>         let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div>         let shard = shard_holder_read.get_shard(shard_id);</div><div>         let Some(replica_set) = shard else {</div><div>             return Err(CollectionError::NotFound {</div><div>                 what: format!("Shard {shard_id}"),</div><div>             });</div><div>         };</div><div class="diff-removed">-</div><div>         replica_set.shard_recovery_point().await</div><div>     }</div><div> </div><div class="diff-info">@@ -530,14 +472,12 @@ impl Collection {</div><div>         cutoff: &RecoveryPoint,</div><div>     ) -> CollectionResult<()> {</div><div>         let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div>         let shard = shard_holder_read.get_shard(shard_id);</div><div>         let Some(replica_set) = shard else {</div><div>             return Err(CollectionError::NotFound {</div><div>                 what: format!("Shard {shard_id}"),</div><div>             });</div><div>         };</div><div class="diff-removed">-</div><div>         replica_set.update_shard_cutoff_point(cutoff).await</div><div>     }</div><div> </div><div class="diff-info">@@ -550,28 +490,29 @@ impl Collection {</div><div>             shards: shards_holder</div><div>                 .get_shards()</div><div>                 .map(|(shard_id, replicas)| {</div><div class="diff-removed">-                    let shard_info = ShardInfo {</div><div class="diff-removed">-                        replicas: replicas.peers(),</div><div class="diff-removed">-                    };</div><div class="diff-added">+                    let shard_info = ShardInfo { replicas: replicas.peers() };</div><div>                     (shard_id, shard_info)</div><div>                 })</div><div>                 .collect(),</div><div class="diff-removed">-            resharding,</div><div>             transfers,</div><div>             shards_key_mapping: shards_holder.get_shard_key_to_ids_mapping(),</div><div>             payload_index_schema: self.payload_index_schema.read().clone(),</div><div class="diff-added">+            resharding,</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        // Abort resharding, if shards are removed from peer driving resharding</div><div class="diff-removed">-        // (which *usually* means the *peer* is being removed from consensus)</div><div class="diff-removed">-        let resharding_state = self</div><div class="diff-removed">-            .resharding_state()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .filter(|state| state.peer_id == peer_id);</div><div class="diff-added">+    pub async fn apply_state(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        state: State,</div><div class="diff-added">+        this_peer_id: PeerId,</div><div class="diff-added">+        abort_transfer: impl FnMut(ShardTransfer),</div><div class="diff-added">+    ) -> CollectionResult<()> {</div><div class="diff-added">+        state.apply(this_peer_id, self, abort_transfer).await</div><div class="diff-added">+    }</div><div> </div><div class="diff-removed">-        if let Some(state) = resharding_state {</div><div class="diff-added">+    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-added">+        // Abort resharding if shards driving resharding are removed</div><div class="diff-added">+        if let Some(state) = self.resharding_state().await.filter(|s| s.peer_id == peer_id) {</div><div>             if let Err(err) = self.abort_resharding(state.key(), true).await {</div><div>                 log::error!(</div><div>                     "Failed to abort resharding {} while removing peer {peer_id}: {err}",</div><div class="diff-info">@@ -579,12 +520,7 @@ impl Collection {</div><div>                 );</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.shards_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .remove_shards_at_peer(peer_id)</div><div class="diff-removed">-            .await</div><div class="diff-added">+        self.shards_holder.read().await.remove_shards_at_peer(peer_id).await</div><div>     }</div><div> </div><div>     pub async fn sync_local_state(</div><div class="diff-info">@@ -595,26 +531,20 @@ impl Collection {</div><div>         on_convert_to_listener: ChangePeerState,</div><div>         on_convert_from_listener: ChangePeerState,</div><div>     ) -> CollectionResult<()> {</div><div class="diff-removed">-        // Check for disabled replicas</div><div>         let shard_holder = self.shards_holder.read().await;</div><div> </div><div class="diff-removed">-        let get_shard_transfers = |shard_id, from| {</div><div class="diff-removed">-            shard_holder</div><div class="diff-removed">-                .get_transfers(|transfer| transfer.shard_id == shard_id && transfer.from == from)</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-added">+        // Sync replica sets</div><div>         for replica_set in shard_holder.all_shards() {</div><div class="diff-removed">-            replica_set.sync_local_state(get_shard_transfers)?;</div><div class="diff-added">+            replica_set.sync_local_state(|shard_id, from| {</div><div class="diff-added">+                shard_holder.get_transfers(|t| t.shard_id == shard_id && t.from == from)</div><div class="diff-added">+            })?;</div><div>         }</div><div> </div><div>         // Check for un-reported finished transfers</div><div>         let outgoing_transfers = shard_holder.get_outgoing_transfers(self.this_peer_id);</div><div>         let tasks_lock = self.transfer_tasks.lock().await;</div><div>         for transfer in outgoing_transfers {</div><div class="diff-removed">-            match tasks_lock</div><div class="diff-removed">-                .get_task_status(&transfer.key())</div><div class="diff-removed">-                .map(|s| s.result)</div><div class="diff-removed">-            {</div><div class="diff-added">+            match tasks_lock.get_task_status(&transfer.key()).map(|s| s.result) {</div><div>                 None => {</div><div>                     log::debug!(</div><div>                         "Transfer {:?} does not exist, but not reported as cancelled. Reporting now.",</div><div class="diff-info">@@ -640,130 +570,101 @@ impl Collection {</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Count how many transfers we are now proposing</div><div class="diff-removed">-        // We must track this here so we can reference it when checking for tranfser limits,</div><div class="diff-removed">-        // because transfers we propose now will not be in the consensus state within the lifetime</div><div class="diff-removed">-        // of this function</div><div class="diff-added">+        // Check for proper replica states and possibly auto-recover</div><div>         let mut proposed = HashMap::<PeerId, usize>::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Check for proper replica states</div><div>         for replica_set in shard_holder.all_shards() {</div><div>             let this_peer_id = replica_set.this_peer_id();</div><div>             let shard_id = replica_set.shard_id;</div><div class="diff-removed">-</div><div>             let peers = replica_set.peers();</div><div>             let this_peer_state = peers.get(&this_peer_id).copied();</div><div> </div><div class="diff-removed">-            if this_peer_state == Some(Initializing) {</div><div class="diff-removed">-                // It is possible, that collection creation didn't report</div><div class="diff-removed">-                // Try to activate shard, as the collection clearly exists</div><div class="diff-added">+            // If initializing, finish init</div><div class="diff-added">+            if this_peer_state == Some(ReplicaState::Initializing) {</div><div>                 on_finish_init(this_peer_id, shard_id);</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-added">+            // Listener <-> Active conversion</div><div class="diff-added">+            let is_last_active =</div><div class="diff-added">+                peers.values().filter(|&&st| st == ReplicaState::Active).count() == 1;</div><div>             if self.shared_storage_config.node_type == NodeType::Listener {</div><div class="diff-removed">-                // We probably should not switch node type during resharding, so we only check for `Active`,</div><div class="diff-removed">-                // but not `ReshardingScaleDown` replica state here...</div><div class="diff-removed">-                let is_last_active = peers.values().filter(|&&state| state == Active).count() == 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                if this_peer_state == Some(Active) && !is_last_active {</div><div class="diff-removed">-                    // Convert active node from active to listener</div><div class="diff-added">+                if this_peer_state == Some(ReplicaState::Active) && !is_last_active {</div><div>                     on_convert_to_listener(this_peer_id, shard_id);</div><div>                     continue;</div><div>                 }</div><div class="diff-removed">-            } else if this_peer_state == Some(Listener) {</div><div class="diff-removed">-                // Convert listener node to active</div><div class="diff-added">+            } else if this_peer_state == Some(ReplicaState::Listener) {</div><div>                 on_convert_from_listener(this_peer_id, shard_id);</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Don't automatically recover replicas if started in recovery mode</div><div class="diff-added">+            // Only recover dead replicas</div><div>             if self.shared_storage_config.recovery_mode.is_some() {</div><div>                 continue;</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Don't recover replicas if not dead</div><div class="diff-removed">-            let is_dead = this_peer_state == Some(Dead);</div><div class="diff-removed">-            if !is_dead {</div><div class="diff-added">+            if this_peer_state != Some(ReplicaState::Dead) {</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Try to find dead replicas with no active transfers</div><div>             let transfers = shard_holder.get_transfers(|_| true);</div><div> </div><div class="diff-removed">-            // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-            let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(this_peer_id);</div><div class="diff-added">+            // Respect shard transfer limits</div><div class="diff-added">+            let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(&this_peer_id);</div><div>             incoming += proposed.get(&this_peer_id).copied().unwrap_or(0);</div><div>             if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div>                 log::trace!(</div><div class="diff-removed">-                    "Postponing automatic shard {shard_id} transfer to stay below limit on this node (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-added">+                    "Postponing automatic shard {shard_id} transfer to stay below limit on this node \</div><div class="diff-added">+                     (incoming: {incoming}, outgoing: {outgoing})",</div><div>                 );</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-removed">-            // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-removed">-            let shard_transfer_method = self</div><div class="diff-removed">-                .shared_storage_config</div><div class="diff-removed">-                .default_shard_transfer_method</div><div class="diff-removed">-                .unwrap_or_else(|| {</div><div class="diff-removed">-                    let all_support_wal_delta = self</div><div class="diff-removed">-                        .channel_service</div><div class="diff-removed">-                        .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-removed">-                    if all_support_wal_delta {</div><div class="diff-removed">-                        ShardTransferMethod::WalDelta</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        ShardTransferMethod::default()</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-            // Try to find a replica to transfer from</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // `active_remote_shards` includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-added">+            // Try remote sources</div><div>             for replica_id in replica_set.active_remote_shards() {</div><div class="diff-added">+                let shard_transfer_method = self</div><div class="diff-added">+                    .shared_storage_config</div><div class="diff-added">+                    .default_shard_transfer_method</div><div class="diff-added">+                    .unwrap_or_else(|| {</div><div class="diff-added">+                        let all_support = self</div><div class="diff-added">+                            .channel_service</div><div class="diff-added">+                            .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-added">+                        if all_support {</div><div class="diff-added">+                            ShardTransferMethod::WalDelta</div><div class="diff-added">+                        } else {</div><div class="diff-added">+                            ShardTransferMethod::default()</div><div class="diff-added">+                        }</div><div class="diff-added">+                    });</div><div>                 let transfer = ShardTransfer {</div><div>                     from: replica_id,</div><div>                     to: this_peer_id,</div><div>                     shard_id,</div><div>                     to_shard_id: None,</div><div>                     sync: true,</div><div class="diff-removed">-                    // For automatic shard transfers, always select some default method from this point on</div><div>                     method: Some(shard_transfer_method),</div><div>                 };</div><div class="diff-removed">-</div><div>                 if check_transfer_conflicts_strict(&transfer, transfers.iter()).is_some() {</div><div class="diff-removed">-                    continue; // this transfer won't work</div><div class="diff-added">+                    continue;</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-removed">-                // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-                let (incoming, mut outgoing) = shard_holder.count_shard_transfer_io(replica_id);</div><div class="diff-removed">-                outgoing += proposed.get(&replica_id).copied().unwrap_or(0);</div><div class="diff-removed">-                if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-added">+                if let Err(err) = replica_set.health_check(replica_id).await {</div><div>                     log::trace!(</div><div class="diff-removed">-                        "Postponing automatic shard {shard_id} transfer to stay below limit on peer {replica_id} (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-added">+                        "Replica {replica_id}/{}/{} is not available to request shard \</div><div class="diff-added">+                         transfer from: {err}",</div><div class="diff-added">+                        self.id,</div><div class="diff-added">+                        shard_id,</div><div>                     );</div><div>                     continue;</div><div>                 }</div><div> </div><div class="diff-removed">-                // TODO: Should we, maybe, throttle/backoff this requests a bit?</div><div class="diff-removed">-                if let Err(err) = replica_set.health_check(replica_id).await {</div><div class="diff-removed">-                    // TODO: This is rather verbose, not sure if we want to log this at all... :/</div><div class="diff-added">+                // Apply limits</div><div class="diff-added">+                let (inc2, mut out2) = shard_holder.count_shard_transfer_io(&replica_id);</div><div class="diff-added">+                out2 += proposed.get(&replica_id).copied().unwrap_or(0);</div><div class="diff-added">+                if self.check_auto_shard_transfer_limit(inc2, out2) {</div><div>                     log::trace!(</div><div class="diff-removed">-                        "Replica {replica_id}/{}:{} is not available \</div><div class="diff-removed">-                         to request shard transfer from: \</div><div class="diff-removed">-                         {err}",</div><div class="diff-removed">-                        self.id,</div><div class="diff-removed">-                        replica_set.shard_id,</div><div class="diff-added">+                        "Postponing automatic shard {shard_id} transfer to stay below limit on peer \</div><div class="diff-added">+                         {replica_id} (incoming: {inc2}, outgoing: {out2})",</div><div>                     );</div><div>                     continue;</div><div>                 }</div><div> </div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Recovering shard {}:{shard_id} on peer {this_peer_id} by requesting it from {replica_id}",</div><div class="diff-removed">-                    self.name(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-</div><div class="diff-removed">-                // Update our counters for proposed transfers, then request (propose) shard transfer</div><div>                 *proposed.entry(transfer.from).or_default() += 1;</div><div>                 *proposed.entry(transfer.to).or_default() += 1;</div><div>                 self.request_shard_transfer(transfer);</div><div class="diff-info">@@ -775,79 +676,50 @@ impl Collection {</div><div>     }</div><div> </div><div>     pub async fn get_telemetry_data(&self, detail: TelemetryDetail) -> CollectionTelemetry {</div><div class="diff-removed">-        let (shards_telemetry, transfers, resharding) = {</div><div class="diff-removed">-            if detail.level >= DetailsLevel::Level3 {</div><div class="diff-removed">-                let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-                let mut shards_telemetry = Vec::new();</div><div class="diff-removed">-                for shard in shards_holder.all_shards() {</div><div class="diff-removed">-                    shards_telemetry.push(shard.get_telemetry_data(detail).await)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                (</div><div class="diff-removed">-                    Some(shards_telemetry),</div><div class="diff-removed">-                    Some(shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)),</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        shards_holder</div><div class="diff-removed">-                            .get_resharding_operations_info()</div><div class="diff-removed">-                            .unwrap_or_default(),</div><div class="diff-removed">-                    ),</div><div class="diff-removed">-                )</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                (None, None, None)</div><div class="diff-added">+        let (shards, transfers, resharding) = if detail.level >= DetailsLevel::Level3 {</div><div class="diff-added">+            let shards_holder = self.shards_holder.read().await;</div><div class="diff-added">+            let mut list = Vec::new();</div><div class="diff-added">+            for shard in shards_holder.all_shards() {</div><div class="diff-added">+                list.push(shard.get_telemetry_data(detail).await);</div><div>             }</div><div class="diff-added">+            (</div><div class="diff-added">+                Some(list),</div><div class="diff-added">+                Some(shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)),</div><div class="diff-added">+                Some(shards_holder.get_resharding_operations_info().unwrap_or_default()),</div><div class="diff-added">+            )</div><div class="diff-added">+        } else {</div><div class="diff-added">+            (None, None, None)</div><div>         };</div><div> </div><div class="diff-removed">-        let shard_clean_tasks = self.clean_local_shards_statuses();</div><div class="diff-removed">-</div><div class="diff-added">+        let shard_clean = self.clean_local_shards_statuses();</div><div>         CollectionTelemetry {</div><div>             id: self.name(),</div><div>             init_time_ms: self.init_time.as_millis() as u64,</div><div>             config: CollectionConfigTelemetry::from(self.collection_config.read().await.clone()),</div><div class="diff-removed">-            shards: shards_telemetry,</div><div class="diff-added">+            shards,</div><div>             transfers,</div><div>             resharding,</div><div class="diff-removed">-            shard_clean_tasks: (!shard_clean_tasks.is_empty()).then_some(shard_clean_tasks),</div><div class="diff-added">+            shard_clean_tasks: (!shard_clean.is_empty()).then_some(shard_clean),</div><div>         }</div><div>     }</div><div> </div><div>     pub async fn get_aggregated_telemetry_data(&self) -> CollectionsAggregatedTelemetry {</div><div>         let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut shard_optimization_statuses = Vec::new();</div><div class="diff-removed">-        let mut vectors = 0;</div><div class="diff-removed">-</div><div class="diff-added">+        let mut statuses = Vec::new();</div><div class="diff-added">+        let mut total_vectors = 0;</div><div>         for shard in shards_holder.all_shards() {</div><div class="diff-removed">-            let shard_optimization_status = shard</div><div class="diff-removed">-                .get_optimization_status()</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .unwrap_or(OptimizersStatus::Ok);</div><div class="diff-removed">-</div><div class="diff-removed">-            shard_optimization_statuses.push(shard_optimization_status);</div><div class="diff-removed">-</div><div class="diff-removed">-            vectors += shard.get_size_stats().await.num_vectors;</div><div class="diff-added">+            let status = shard.get_optimization_status().await.unwrap_or(OptimizersStatus::Ok);</div><div class="diff-added">+            statuses.push(status);</div><div class="diff-added">+            total_vectors += shard.get_size_stats().await.num_vectors;</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizers_status = shard_optimization_statuses</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .max()</div><div class="diff-removed">-            .unwrap_or(OptimizersStatus::Ok);</div><div class="diff-removed">-</div><div class="diff-added">+        let overall = statuses.into_iter().max().unwrap_or(OptimizersStatus::Ok);</div><div>         CollectionsAggregatedTelemetry {</div><div class="diff-removed">-            vectors,</div><div class="diff-removed">-            optimizers_status,</div><div class="diff-added">+            vectors: total_vectors,</div><div class="diff-added">+            optimizers_status: overall,</div><div>             params: self.collection_config.read().await.params.clone(),</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div>         self.updates_lock.write().await</div><div>     }</div><div class="diff-info">@@ -875,13 +747,13 @@ impl Collection {</div><div>     async fn estimate_collection_size_stats(</div><div>         shards_holder: &Arc<RwLock<ShardHolder>>,</div><div>     ) -> Option<CollectionSizeStats> {</div><div class="diff-removed">-        let shard_lock = shards_holder.read().await;</div><div class="diff-removed">-        shard_lock.estimate_collection_size_stats().await</div><div class="diff-added">+        let lock = shards_holder.read().await;</div><div class="diff-added">+        lock.estimate_collection_size_stats().await</div><div>     }</div><div> </div><div class="diff-removed">-    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div class="diff-removed">-    /// The cache gets updated every 32 calls.</div><div class="diff-removed">-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-added">+    pub(crate) async fn estimated_collection_stats(</div><div class="diff-added">+        &self,</div><div class="diff-added">+    ) -> Option<&CollectionSizeAtomicStats> {</div><div>         self.collection_stats_cache</div><div>             .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div>             .await</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    