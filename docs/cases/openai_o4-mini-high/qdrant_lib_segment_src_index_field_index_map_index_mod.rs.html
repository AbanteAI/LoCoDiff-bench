<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/src/index/field_index/map_index/mod.rs - o4-mini-high</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/src/index/field_index/map_index/mod.rs</h1>
        <p><a href="../../models/openai_o4-mini-high.html">‚Üê Back to o4-mini-high Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-high</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56553</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 56447</p>
                <p><strong>Native Completion Tokens:</strong> 10278</p>
                <p><strong>Native Tokens Reasoning:</strong> 768</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.1073149</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_segment_src_index_field_index_map_index_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_segment_src_index_field_index_map_index_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_segment_src_index_field_index_map_index_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_segment_src_index_field_index_map_index_mod.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_field_index_map_index_mod.rs_extracted.txt (actual)@@ -1,3 +1,9 @@+// @generated by cargo dev tools; do not edit by hand.</div><div class="diff-added">+</div><div class="diff-added">+pub mod immutable_map_index;</div><div class="diff-added">+pub mod mmap_map_index;</div><div class="diff-added">+pub mod mutable_map_index;</div><div class="diff-added">+</div><div> use std::borrow::Borrow;</div><div> use std::collections::hash_map::Entry;</div><div> use std::fmt::{Debug, Display};</div><div class="diff-info">@@ -8,53 +14,52 @@ use std::sync::Arc;</div><div> </div><div> use ahash::HashMap;</div><div class="diff-removed">-use common::counter::hardware_counter::HardwareCounterCell;</div><div> use common::mmap_hashmap::Key;</div><div> use common::types::PointOffsetType;</div><div> use indexmap::IndexSet;</div><div> use itertools::Itertools;</div><div class="diff-removed">-use mmap_map_index::MmapMapIndex;</div><div> use parking_lot::RwLock;</div><div> use rocksdb::DB;</div><div> use serde_json::Value;</div><div> use smol_str::SmolStr;</div><div> use uuid::Uuid;</div><div> </div><div class="diff-removed">-use self::immutable_map_index::ImmutableMapIndex;</div><div class="diff-removed">-use self::mutable_map_index::MutableMapIndex;</div><div class="diff-removed">-use super::FieldIndexBuilderTrait;</div><div class="diff-removed">-use super::facet_index::FacetIndex;</div><div class="diff-removed">-use super::mmap_point_to_values::MmapValue;</div><div> use crate::common::Flusher;</div><div> use crate::common::operation_error::{OperationError, OperationResult};</div><div class="diff-added">+use crate::counter::hardware_counter::HardwareCounterCell;</div><div> use crate::data_types::facets::{FacetHit, FacetValueRef};</div><div> use crate::index::field_index::stat_tools::number_of_selected_points;</div><div> use crate::index::field_index::{</div><div class="diff-removed">-    CardinalityEstimation, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition, ValueIndexer,</div><div class="diff-added">+    CardinalityEstimation, FieldCondition, PayloadBlockCondition, PayloadFieldIndex, PrimaryCondition,</div><div class="diff-added">+    ValueIndexer,</div><div> };</div><div class="diff-removed">-use crate::index::query_estimator::combine_should_estimations;</div><div> use crate::telemetry::PayloadIndexTelemetry;</div><div> use crate::types::{</div><div class="diff-removed">-    AnyVariants, FieldCondition, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue,</div><div class="diff-removed">-    PayloadKeyType, UuidIntType, ValueVariants,</div><div class="diff-added">+    AnyVariants, IntPayloadType, Match, MatchAny, MatchExcept, MatchValue, PayloadKeyType, UuidIntType,</div><div class="diff-added">+    ValueVariants,</div><div> };</div><div> </div><div class="diff-removed">-pub mod immutable_map_index;</div><div class="diff-removed">-pub mod mmap_map_index;</div><div class="diff-removed">-pub mod mutable_map_index;</div><div class="diff-removed">-</div><div class="diff-added">+use self::immutable_map_index::ImmutableMapIndex;</div><div class="diff-added">+use self::mmap_map_index::MmapMapIndex;</div><div class="diff-added">+use self::mmap_point_to_values::MmapValue;</div><div class="diff-added">+use self::mutable_map_index::MutableMapIndex;</div><div class="diff-added">+use super::FieldIndexBuilderTrait;</div><div class="diff-added">+</div><div class="diff-added">+/// Iterator over point IDs by reference.</div><div> pub type IdRefIter<'a> = Box<dyn Iterator<Item = &'a PointOffsetType> + 'a>;</div><div class="diff-added">+/// Iterator over point IDs by value.</div><div> pub type IdIter<'a> = Box<dyn Iterator<Item = PointOffsetType> + 'a>;</div><div> </div><div class="diff-added">+/// A key type usable in a MapIndex.</div><div> pub trait MapIndexKey: Key + MmapValue + Eq + Display + Debug {</div><div class="diff-added">+    /// Owned form of the key.</div><div>     type Owned: Borrow<Self> + Hash + Eq + Clone + FromStr + Default;</div><div class="diff-removed">-</div><div class="diff-added">+    /// Convert borrowed to owned.</div><div>     fn to_owned(&self) -> Self::Owned;</div><div> }</div><div> </div><div> impl MapIndexKey for str {</div><div>     type Owned = SmolStr;</div><div class="diff-removed">-</div><div>     fn to_owned(&self) -> Self::Owned {</div><div>         SmolStr::from(self)</div><div>     }</div><div class="diff-info">@@ -62,7 +67,6 @@ </div><div> impl MapIndexKey for IntPayloadType {</div><div>     type Owned = IntPayloadType;</div><div class="diff-removed">-</div><div>     fn to_owned(&self) -> Self::Owned {</div><div>         *self</div><div>     }</div><div class="diff-info">@@ -70,12 +74,15 @@ </div><div> impl MapIndexKey for UuidIntType {</div><div>     type Owned = UuidIntType;</div><div class="diff-removed">-</div><div>     fn to_owned(&self) -> Self::Owned {</div><div>         *self</div><div>     }</div><div> }</div><div> </div><div class="diff-added">+/// An index mapping payload field values to points.</div><div class="diff-added">+///</div><div class="diff-added">+/// Supports a mutable on-disk RocksDB-backed index, an immutable disk-loaded index,</div><div class="diff-added">+/// and an on-disk or in-ram memory-mapped index.</div><div> pub enum MapIndex<N: MapIndexKey + ?Sized> {</div><div>     Mutable(MutableMapIndex<N>),</div><div>     Immutable(ImmutableMapIndex<N>),</div><div class="diff-info">@@ -83,6 +90,7 @@ }</div><div> </div><div> impl<N: MapIndexKey + ?Sized> MapIndex<N> {</div><div class="diff-added">+    /// Create a new in-memory (RocksDB + appendable flag) index.</div><div>     pub fn new_memory(db: Arc<RwLock<DB>>, field_name: &str, is_appendable: bool) -> Self {</div><div>         if is_appendable {</div><div>             MapIndex::Mutable(MutableMapIndex::new(db, field_name))</div><div class="diff-info">@@ -91,16 +99,17 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Load an existing memory map (immutable) index.</div><div>     pub fn new_mmap(path: &Path, is_on_disk: bool) -> OperationResult<Self> {</div><div class="diff-removed">-        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(</div><div class="diff-removed">-            path, is_on_disk,</div><div class="diff-removed">-        )?)))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+        Ok(MapIndex::Mmap(Box::new(MmapMapIndex::load(path, is_on_disk)?)))</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Builder for a memory (RocksDB) index.</div><div>     pub fn builder(db: Arc<RwLock<DB>>, field_name: &str) -> MapIndexBuilder<N> {</div><div>         MapIndexBuilder(MapIndex::Mutable(MutableMapIndex::new(db, field_name)))</div><div>     }</div><div> </div><div class="diff-added">+    /// Builder for a memory-map index.</div><div>     pub fn mmap_builder(path: &Path, is_on_disk: bool) -> MapIndexMmapBuilder<N> {</div><div>         MapIndexMmapBuilder {</div><div>             path: path.to_owned(),</div><div class="diff-info">@@ -110,28 +119,29 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn load_from_db(&mut self) -> OperationResult<bool> {</div><div class="diff-added">+    /// Load or reload from underlying storage.</div><div class="diff-added">+    pub fn load_from_db(&mut self) -> OperationResult<bool> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.load_from_db(),</div><div>             MapIndex::Immutable(index) => index.load_from_db(),</div><div class="diff-removed">-            // mmap index is always loaded</div><div>             MapIndex::Mmap(_) => Ok(true),</div><div>         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Check if any value at `idx` satisfies `check_fn`.</div><div>     pub fn check_values_any(</div><div>         &self,</div><div>         idx: PointOffsetType,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div>         check_fn: impl Fn(&N) -> bool,</div><div>     ) -> bool {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.check_values_any(idx, check_fn),</div><div>             MapIndex::Immutable(index) => index.check_values_any(idx, check_fn),</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.check_values_any(idx, hw_counter, check_fn),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+            MapIndex::Mmap(index) => index.check_values_any(idx, check_fn),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Return stored values for a point.</div><div>     pub fn get_values(</div><div>         &self,</div><div>         idx: PointOffsetType,</div><div class="diff-info">@@ -147,6 +157,7 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Number of values for a point.</div><div>     pub fn values_count(&self, idx: PointOffsetType) -> usize {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.values_count(idx).unwrap_or_default(),</div><div class="diff-info">@@ -155,7 +166,13 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn get_indexed_points(&self) -> usize {</div><div class="diff-added">+    /// Is the values list empty?</div><div class="diff-added">+    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {</div><div class="diff-added">+        self.values_count(idx) == 0</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Total indexed points.</div><div class="diff-added">+    pub fn get_indexed_points(&self) -> usize {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_indexed_points(),</div><div>             MapIndex::Immutable(index) => index.get_indexed_points(),</div><div class="diff-info">@@ -163,7 +180,8 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn get_values_count(&self) -> usize {</div><div class="diff-added">+    /// Total number of assigned values.</div><div class="diff-added">+    pub fn get_values_count(&self) -> usize {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_values_count(),</div><div>             MapIndex::Immutable(index) => index.get_values_count(),</div><div class="diff-info">@@ -171,6 +189,7 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Unique distinct values count.</div><div>     pub fn get_unique_values_count(&self) -> usize {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_unique_values_count(),</div><div class="diff-info">@@ -179,22 +198,31 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn get_count_for_value(&self, value: &N, hw_counter: &HardwareCounterCell) -> Option<usize> {</div><div class="diff-removed">-        match self {</div><div class="diff-added">+    /// Cardnarity for single value.</div><div class="diff-added">+    fn match_cardinality(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        value: &N,</div><div class="diff-added">+        _hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> CardinalityEstimation {</div><div class="diff-added">+        let values_count = match self {</div><div>             MapIndex::Mutable(index) => index.get_count_for_value(value),</div><div>             MapIndex::Immutable(index) => index.get_count_for_value(value),</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.get_count_for_value(value, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_iterator(&self, value: &N, hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {</div><div class="diff-added">+            MapIndex::Mmap(index) => index.get_count_for_value(value),</div><div class="diff-added">+        }</div><div class="diff-added">+        .unwrap_or(0);</div><div class="diff-added">+        CardinalityEstimation::exact(values_count)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Iterator of points having `value`.</div><div class="diff-added">+    fn get_iterator(&self, value: &N, _hw_counter: &HardwareCounterCell) -> IdRefIter<'_> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_iterator(value),</div><div>             MapIndex::Immutable(index) => index.get_iterator(value),</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.get_iterator(value, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+            MapIndex::Mmap(index) => index.get_iterator(value),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Iterator of all distinct values.</div><div>     pub fn iter_values(&self) -> Box<dyn Iterator<Item = &N> + '_> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.iter_values(),</div><div class="diff-info">@@ -203,6 +231,7 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Iterator over (value, count).</div><div>     pub fn iter_counts_per_value(&self) -> Box<dyn Iterator<Item = (&N, usize)> + '_> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => Box::new(index.iter_counts_per_value()),</div><div class="diff-info">@@ -211,6 +240,7 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Iterator over (value, point IDs).</div><div>     pub fn iter_values_map<'a>(</div><div>         &'a self,</div><div>         hw_cell: &'a HardwareCounterCell,</div><div class="diff-info">@@ -222,10 +252,16 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn storage_cf_name(field: &str) -> String {</div><div class="diff-removed">-        format!("{field}_map")</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+    /// Return storage files for mmap variant.</div><div class="diff-added">+    fn files(&self) -> Vec<PathBuf> {</div><div class="diff-added">+        match self {</div><div class="diff-added">+            MapIndex::Mutable(_) => Vec::new(),</div><div class="diff-added">+            MapIndex::Immutable(_) => Vec::new(),</div><div class="diff-added">+            MapIndex::Mmap(index) => index.files(),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Return database flusher.</div><div>     fn flusher(&self) -> Flusher {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_db_wrapper().flusher(),</div><div class="diff-info">@@ -234,55 +270,7 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn match_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        value: &N,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CardinalityEstimation {</div><div class="diff-removed">-        let values_count = self.get_count_for_value(value, hw_counter).unwrap_or(0);</div><div class="diff-removed">-</div><div class="diff-removed">-        CardinalityEstimation::exact(values_count)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {</div><div class="diff-removed">-        PayloadIndexTelemetry {</div><div class="diff-removed">-            field_name: None,</div><div class="diff-removed">-            points_count: self.get_indexed_points(),</div><div class="diff-removed">-            points_values_count: self.get_values_count(),</div><div class="diff-removed">-            histogram_bucket_size: None,</div><div class="diff-removed">-            index_type: match self {</div><div class="diff-removed">-                MapIndex::Mutable(_) => "mutable_map",</div><div class="diff-removed">-                MapIndex::Immutable(_) => "immutable_map",</div><div class="diff-removed">-                MapIndex::Mmap(_) => "mmap_map",</div><div class="diff-removed">-            },</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {</div><div class="diff-removed">-        format!("{value}/{idx}")</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {</div><div class="diff-removed">-        const DECODE_ERR: &str = "Index db parsing error: wrong data format";</div><div class="diff-removed">-        let separator_pos = s</div><div class="diff-removed">-            .rfind('/')</div><div class="diff-removed">-            .ok_or_else(|| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-removed">-        if separator_pos == s.len() - 1 {</div><div class="diff-removed">-            return Err(OperationError::service_error(DECODE_ERR));</div><div class="diff-removed">-        }</div><div class="diff-removed">-        let value_str = &s[..separator_pos];</div><div class="diff-removed">-        let value =</div><div class="diff-removed">-            N::Owned::from_str(value_str).map_err(|_| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-removed">-        let idx_str = &s[separator_pos + 1..];</div><div class="diff-removed">-        let idx = PointOffsetType::from_str(idx_str)</div><div class="diff-removed">-            .map_err(|_| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-removed">-        Ok((value, idx))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn values_is_empty(&self, idx: PointOffsetType) -> bool {</div><div class="diff-removed">-        self.values_count(idx) == 0</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+    /// Drop underlying column (RocksDB) or noop for mmap.</div><div>     fn clear(self) -> OperationResult<()> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),</div><div class="diff-info">@@ -291,6 +279,7 @@         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Remove a point assignment.</div><div>     fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div>         match self {</div><div>             MapIndex::Mutable(index) => index.remove_point(id),</div><div class="diff-info">@@ -302,127 +291,40 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn files(&self) -> Vec<PathBuf> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(_) => Vec::new(),</div><div class="diff-removed">-            MapIndex::Immutable(_) => Vec::new(),</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.files(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Estimates cardinality for `except` clause</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * 'excluded' - values, which are not considered as matching</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Returns</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `CardinalityEstimation` - estimation of cardinality</div><div class="diff-added">+    /// Cardinality estimation for Except.</div><div>     fn except_cardinality<'a>(</div><div>         &'a self,</div><div>         excluded: impl Iterator<Item = &'a N>,</div><div>         hw_counter: &HardwareCounterCell,</div><div>     ) -> CardinalityEstimation {</div><div class="diff-removed">-        // Minimal case: we exclude as many points as possible.</div><div class="diff-removed">-        // In this case, excluded points do not have any other values except excluded ones.</div><div class="diff-removed">-        // So the first step - we estimate how many other points is needed to fit unused values.</div><div class="diff-removed">-</div><div class="diff-removed">-        // Example:</div><div class="diff-removed">-        // Values: 20, 20</div><div class="diff-removed">-        // Unique values: 5</div><div class="diff-removed">-        // Total points: 100</div><div class="diff-removed">-        // Total values: 110</div><div class="diff-removed">-        // total_excluded_value_count = 40</div><div class="diff-removed">-        // non_excluded_values_count = 110 - 40 = 70</div><div class="diff-removed">-        // max_values_per_point = 5 - 2 = 3</div><div class="diff-removed">-        // min_not_excluded_by_values = 70 / 3 = 24</div><div class="diff-removed">-        // min = max(24, 100 - 40) = 60</div><div class="diff-removed">-        // exp = ...</div><div class="diff-removed">-        // max = min(20, 70) = 20</div><div class="diff-removed">-</div><div class="diff-removed">-        // Values: 60, 60</div><div class="diff-removed">-        // Unique values: 5</div><div class="diff-removed">-        // Total points: 100</div><div class="diff-removed">-        // Total values: 200</div><div class="diff-removed">-        // total_excluded_value_count = 120</div><div class="diff-removed">-        // non_excluded_values_count = 200 - 120 = 80</div><div class="diff-removed">-        // max_values_per_point = 5 - 2 = 3</div><div class="diff-removed">-        // min_not_excluded_by_values = 80 / 3 = 27</div><div class="diff-removed">-        // min = max(27, 100 - 120) = 27</div><div class="diff-removed">-        // exp = ...</div><div class="diff-removed">-        // max = min(60, 80) = 60</div><div class="diff-removed">-</div><div class="diff-removed">-        // Values: 60, 60, 60</div><div class="diff-removed">-        // Unique values: 5</div><div class="diff-removed">-        // Total points: 100</div><div class="diff-removed">-        // Total values: 200</div><div class="diff-removed">-        // total_excluded_value_count = 180</div><div class="diff-removed">-        // non_excluded_values_count = 200 - 180 = 20</div><div class="diff-removed">-        // max_values_per_point = 5 - 3 = 2</div><div class="diff-removed">-        // min_not_excluded_by_values = 20 / 2 = 10</div><div class="diff-removed">-        // min = max(10, 100 - 180) = 10</div><div class="diff-removed">-        // exp = ...</div><div class="diff-removed">-        // max = min(60, 20) = 20</div><div class="diff-removed">-</div><div class="diff-removed">-        let excluded_value_counts: Vec<_> = excluded</div><div class="diff-removed">-            .map(|val| {</div><div class="diff-removed">-                self.get_count_for_value(val.borrow(), hw_counter)</div><div class="diff-removed">-                    .unwrap_or(0)</div><div class="diff-added">+        let total_values = self.get_values_count();</div><div class="diff-added">+        let total_points = self.get_indexed_points();</div><div class="diff-added">+        let excluded_counts: Vec<_> = excluded</div><div class="diff-added">+            .map(|val| match self {</div><div class="diff-added">+                MapIndex::Mutable(index) => index.get_count_for_value(val).unwrap_or(0),</div><div class="diff-added">+                MapIndex::Immutable(index) => index.get_count_for_value(val).unwrap_or(0),</div><div class="diff-added">+                MapIndex::Mmap(index) => index.get_count_for_value(val).unwrap_or(0),</div><div>             })</div><div>             .collect();</div><div class="diff-removed">-        let total_excluded_value_count: usize = excluded_value_counts.iter().sum();</div><div class="diff-removed">-</div><div class="diff-removed">-        debug_assert!(total_excluded_value_count <= self.get_values_count());</div><div class="diff-removed">-</div><div class="diff-removed">-        let non_excluded_values_count = self</div><div class="diff-removed">-            .get_values_count()</div><div class="diff-removed">-            .saturating_sub(total_excluded_value_count);</div><div class="diff-removed">-        let max_values_per_point = self</div><div class="diff-removed">-            .get_unique_values_count()</div><div class="diff-removed">-            .saturating_sub(excluded_value_counts.len());</div><div class="diff-removed">-</div><div class="diff-removed">-        if max_values_per_point == 0 {</div><div class="diff-removed">-            // All points are excluded, so we can't select any point</div><div class="diff-removed">-            debug_assert_eq!(non_excluded_values_count, 0);</div><div class="diff-added">+        let total_excluded: usize = excluded_counts.iter().sum();</div><div class="diff-added">+</div><div class="diff-added">+        let non_excluded_values = total_values.saturating_sub(total_excluded);</div><div class="diff-added">+        let max_vals_per_point = self.get_unique_values_count().saturating_sub(excluded_counts.len());</div><div class="diff-added">+</div><div class="diff-added">+        if max_vals_per_point == 0 {</div><div>             return CardinalityEstimation::exact(0);</div><div>         }</div><div> </div><div class="diff-removed">-        // Minimal amount of points, required to fit all unused values.</div><div class="diff-removed">-        // Cardinality can't be less than this value.</div><div class="diff-removed">-        let min_not_excluded_by_values = non_excluded_values_count.div_ceil(max_values_per_point);</div><div class="diff-removed">-</div><div class="diff-removed">-        let min = min_not_excluded_by_values.max(</div><div class="diff-removed">-            self.get_indexed_points()</div><div class="diff-removed">-                .saturating_sub(total_excluded_value_count),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        // Maximum scenario: selected points overlap as much as possible.</div><div class="diff-removed">-        // From one side, all excluded values should be assigned to the same point</div><div class="diff-removed">-        // => we can take the value with the maximum amount of points.</div><div class="diff-removed">-        // From another side, all other values should be enough to fill all other points.</div><div class="diff-removed">-</div><div class="diff-removed">-        let max_excluded_value_count = excluded_value_counts.iter().max().copied().unwrap_or(0);</div><div class="diff-removed">-</div><div class="diff-removed">-        let max = self</div><div class="diff-removed">-            .get_indexed_points()</div><div class="diff-removed">-            .saturating_sub(max_excluded_value_count)</div><div class="diff-removed">-            .min(non_excluded_values_count);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Expected case: we assume that all points are filled equally.</div><div class="diff-removed">-        // So we can estimate the probability of the point to have non-excluded value.</div><div class="diff-removed">-        let exp = number_of_selected_points(self.get_indexed_points(), non_excluded_values_count)</div><div class="diff-removed">-            .max(min)</div><div class="diff-removed">-            .min(max);</div><div class="diff-removed">-</div><div class="diff-removed">-        CardinalityEstimation {</div><div class="diff-removed">-            primary_clauses: vec![],</div><div class="diff-removed">-            min,</div><div class="diff-removed">-            exp,</div><div class="diff-removed">-            max,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+        let min_points_by_vals = non_excluded_values.div_ceil(max_vals_per_point);</div><div class="diff-added">+        let min = min_points_by_vals.max(total_points.saturating_sub(total_excluded));</div><div class="diff-added">+        let max_excl = excluded_counts.into_iter().max().unwrap_or(0);</div><div class="diff-added">+        let max = total_points.saturating_sub(max_excl).min(non_excluded_values);</div><div class="diff-added">+        let exp = number_of_selected_points(total_points, non_excluded_values).max(min).min(max);</div><div class="diff-added">+</div><div class="diff-added">+        CardinalityEstimation { primary_clauses: vec![], min, exp, max }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Iterator of points not having any of the excluded values.</div><div>     fn except_set<'a, K, A>(</div><div>         &'a self,</div><div>         excluded: &'a IndexSet<K, A>,</div><div class="diff-info">@@ -435,41 +337,83 @@         Box::new(</div><div>             self.iter_values()</div><div>                 .filter(|key| !excluded.contains((*key).borrow()))</div><div class="diff-removed">-                .flat_map(move |key| self.get_iterator(key.borrow(), hw_counter).copied())</div><div class="diff-added">+                .flat_map(move |key| self.get_iterator(key, hw_counter).copied())</div><div>                 .unique(),</div><div>         )</div><div>     }</div><div> </div><div class="diff-added">+    /// Column family name.</div><div class="diff-added">+    pub fn storage_cf_name(field: &str) -> String {</div><div class="diff-added">+        format!("{}_map", field)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Encode record for RocksDB.</div><div class="diff-added">+    pub fn encode_db_record(value: &N, idx: PointOffsetType) -> String {</div><div class="diff-added">+        format!("{value}/{idx}")</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Decode RocksDB record.</div><div class="diff-added">+    pub fn decode_db_record(s: &str) -> OperationResult<(N::Owned, PointOffsetType)> {</div><div class="diff-added">+        const DECODE_ERR: &str = "Index db parsing error: wrong data format";</div><div class="diff-added">+        let pos = s.rfind('/').ok_or_else(|| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-added">+        if pos == s.len() - 1 {</div><div class="diff-added">+            return Err(OperationError::service_error(DECODE_ERR));</div><div class="diff-added">+        }</div><div class="diff-added">+        let vs = &s[..pos];</div><div class="diff-added">+        let val = N::Owned::from_str(vs).map_err(|_| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-added">+        let is = &s[pos + 1..];</div><div class="diff-added">+        let id = PointOffsetType::from_str(is).map_err(|_| OperationError::service_error(DECODE_ERR))?;</div><div class="diff-added">+        Ok((val, id))</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Populate mmap pages.</div><div class="diff-added">+    pub fn populate(&self) -> OperationResult<()> {</div><div class="diff-added">+        if let MapIndex::Mmap(idx) = self {</div><div class="diff-added">+            idx.populate()?;</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Clear mmap cache.</div><div class="diff-added">+    pub fn clear_cache(&self) -> OperationResult<()> {</div><div class="diff-added">+        if let MapIndex::Mmap(idx) = self {</div><div class="diff-added">+            idx.clear_cache()?;</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Is mmap on-disk?</div><div>     pub fn is_on_disk(&self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(_) => false,</div><div class="diff-removed">-            MapIndex::Immutable(_) => false,</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.is_on_disk(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Populate all pages in the mmap.</div><div class="diff-removed">-    /// Block until all pages are populated.</div><div class="diff-removed">-    pub fn populate(&self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(_) => {}   // Not a mmap</div><div class="diff-removed">-            MapIndex::Immutable(_) => {} // Not a mmap</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.populate()?,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Drop disk cache.</div><div class="diff-removed">-    pub fn clear_cache(&self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(_) => {}   // Not a mmap</div><div class="diff-removed">-            MapIndex::Immutable(_) => {} // Not a mmap</div><div class="diff-removed">-            MapIndex::Mmap(index) => index.clear_cache()?,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+        matches!(self, MapIndex::Mmap(idx) if idx.is_on_disk())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Telemetry information.</div><div class="diff-added">+    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {</div><div class="diff-added">+        PayloadIndexTelemetry {</div><div class="diff-added">+            field_name: None,</div><div class="diff-added">+            points_count: self.get_indexed_points(),</div><div class="diff-added">+            points_values_count: self.get_values_count(),</div><div class="diff-added">+            histogram_bucket_size: None,</div><div class="diff-added">+            index_type: match self {</div><div class="diff-added">+                MapIndex::Mutable(_) => "mutable_map",</div><div class="diff-added">+                MapIndex::Immutable(_) => "immutable_map",</div><div class="diff-added">+                MapIndex::Mmap(_) => "mmap_map",</div><div class="diff-added">+            },</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Cardinality estimation for a single value.</div><div class="diff-added">+    pub fn match_cardinality(&self, value: &N) -> CardinalityEstimation {</div><div class="diff-added">+        let cnt = match self {</div><div class="diff-added">+            MapIndex::Mutable(index) => index.get_count_for_value(value).unwrap_or(0),</div><div class="diff-added">+            MapIndex::Immutable(index) => index.get_count_for_value(value).unwrap_or(0),</div><div class="diff-added">+            MapIndex::Mmap(index) => index.get_count_for_value(value).unwrap_or(0),</div><div class="diff-added">+        };</div><div class="diff-added">+        CardinalityEstimation::exact(cnt)</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Builder for a RocksDB-based index.</div><div> pub struct MapIndexBuilder<N: MapIndexKey + ?Sized>(MapIndex<N>);</div><div> </div><div> impl<N: MapIndexKey + ?Sized> FieldIndexBuilderTrait for MapIndexBuilder<N></div><div class="diff-info">@@ -479,11 +423,7 @@     type FieldIndexType = MapIndex<N>;</div><div> </div><div>     fn init(&mut self) -> OperationResult<()> {</div><div class="diff-removed">-        match &mut self.0 {</div><div class="diff-removed">-            MapIndex::Mutable(index) => index.get_db_wrapper().recreate_column_family(),</div><div class="diff-removed">-            MapIndex::Immutable(index) => index.get_db_wrapper().recreate_column_family(),</div><div class="diff-removed">-            MapIndex::Mmap(_) => unreachable!(),</div><div class="diff-removed">-        }</div><div class="diff-added">+        self.0.get_db_wrapper().recreate_column_family()</div><div>     }</div><div> </div><div>     fn add_point(</div><div class="diff-info">@@ -500,6 +440,7 @@     }</div><div> }</div><div> </div><div class="diff-added">+/// Builder for a memory-mapped index.</div><div> pub struct MapIndexMmapBuilder<N: MapIndexKey + ?Sized> {</div><div>     path: PathBuf,</div><div>     point_to_values: Vec<Vec<N::Owned>>,</div><div class="diff-info">@@ -524,35 +465,26 @@         payload: &[&Value],</div><div>         hw_counter: &HardwareCounterCell,</div><div>     ) -> OperationResult<()> {</div><div class="diff-removed">-        let mut flatten_values: Vec<_> = vec![];</div><div class="diff-removed">-        for value in payload.iter() {</div><div class="diff-removed">-            let payload_values = <MapIndex<N> as ValueIndexer>::get_values(value);</div><div class="diff-removed">-            flatten_values.extend(payload_values);</div><div class="diff-removed">-        }</div><div class="diff-removed">-        let flatten_values: Vec<N::Owned> = flatten_values.into_iter().map(Into::into).collect();</div><div class="diff-removed">-</div><div class="diff-added">+        let mut flatten = Vec::new();</div><div class="diff-added">+        for v in payload.iter() {</div><div class="diff-added">+            flatten.extend(<MapIndex<N> as ValueIndexer>::get_values(v));</div><div class="diff-added">+        }</div><div class="diff-added">+        let owned: Vec<_> = flatten.into_iter().map(Into::into).collect();</div><div>         if self.point_to_values.len() <= id as usize {</div><div>             self.point_to_values.resize_with(id as usize + 1, Vec::new);</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.point_to_values[id as usize].extend(flatten_values.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut hw_cell_wb = hw_counter</div><div class="diff-removed">-            .payload_index_io_write_counter()</div><div class="diff-removed">-            .write_back_counter();</div><div class="diff-removed">-</div><div class="diff-removed">-        for value in flatten_values {</div><div class="diff-removed">-            let entry = self.values_to_points.entry(value);</div><div class="diff-removed">-</div><div class="diff-removed">-            if let Entry::Vacant(e) = &entry {</div><div class="diff-removed">-                let size = N::mmapped_size(N::as_referenced(e.key().borrow()));</div><div class="diff-removed">-                hw_cell_wb.incr_delta(size);</div><div class="diff-added">+        self.point_to_values[id as usize].extend(owned.clone());</div><div class="diff-added">+</div><div class="diff-added">+        let mut wb = hw_counter.payload_index_io_write_counter().write_back_counter();</div><div class="diff-added">+        for val in owned {</div><div class="diff-added">+            let ent = self.values_to_points.entry(val.clone());</div><div class="diff-added">+            if let Entry::Vacant(e) = &ent {</div><div class="diff-added">+                let sz = N::mmapped_size(N::as_referenced(e.key().borrow()));</div><div class="diff-added">+                wb.incr_delta(sz);</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            hw_cell_wb.incr_delta(size_of_val(&id));</div><div class="diff-removed">-            entry.or_default().push(id);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-added">+            wb.incr_delta(std::mem::size_of_val(&id));</div><div class="diff-added">+            ent.or_default().push(id);</div><div class="diff-added">+        }</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -570,42 +502,36 @@     fn count_indexed_points(&self) -> usize {</div><div>         self.get_indexed_points()</div><div>     }</div><div class="diff-removed">-</div><div>     fn load(&mut self) -> OperationResult<bool> {</div><div>         self.load_from_db()</div><div>     }</div><div class="diff-removed">-</div><div>     fn cleanup(self) -> OperationResult<()> {</div><div>         self.clear()</div><div>     }</div><div class="diff-removed">-</div><div>     fn flusher(&self) -> Flusher {</div><div>         MapIndex::flusher(self)</div><div>     }</div><div class="diff-removed">-</div><div>     fn files(&self) -> Vec<PathBuf> {</div><div>         self.files()</div><div>     }</div><div class="diff-removed">-</div><div>     fn filter<'a>(</div><div>         &'a self,</div><div>         condition: &'a FieldCondition,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div>     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {</div><div>         match &condition.r#match {</div><div>             Some(Match::Value(MatchValue { value })) => match value {</div><div>                 ValueVariants::String(keyword) => Some(Box::new(</div><div>                     self.get_iterator(keyword.as_str(), hw_counter).copied(),</div><div>                 )),</div><div class="diff-removed">-                ValueVariants::Integer(_) => None,</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-added">+                _ => None,</div><div>             },</div><div>             Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {</div><div>                 AnyVariants::Strings(keywords) => Some(Box::new(</div><div>                     keywords</div><div>                         .iter()</div><div class="diff-removed">-                        .flat_map(move |keyword| {</div><div class="diff-removed">-                            self.get_iterator(keyword.as_str(), hw_counter).copied()</div><div class="diff-added">+                        .flat_map(move |kw| {</div><div class="diff-added">+                            self.get_iterator(kw.as_str(), hw_counter).copied()</div><div>                         })</div><div>                         .unique(),</div><div>                 )),</div><div class="diff-info">@@ -630,7 +556,6 @@             _ => None,</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div>     fn estimate_cardinality(</div><div>         &self,</div><div>         condition: &FieldCondition,</div><div class="diff-info">@@ -639,37 +564,25 @@         match &condition.r#match {</div><div>             Some(Match::Value(MatchValue { value })) => match value {</div><div>                 ValueVariants::String(keyword) => {</div><div class="diff-removed">-                    let mut estimation = self.match_cardinality(keyword.as_str(), hw_counter);</div><div class="diff-removed">-                    estimation</div><div class="diff-removed">-                        .primary_clauses</div><div class="diff-removed">-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-removed">-                    Some(estimation)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ValueVariants::Integer(_) => None,</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {</div><div class="diff-added">+                    let mut est = self.match_cardinality(keyword.as_str(), hw_counter);</div><div class="diff-added">+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-added">+                    Some(est)</div><div class="diff-added">+                }</div><div class="diff-added">+                _ => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Any(MatchAny { any })) => match any {</div><div>                 AnyVariants::Strings(keywords) => {</div><div class="diff-removed">-                    let estimations = keywords</div><div class="diff-added">+                    let v: Vec<_> = keywords</div><div>                         .iter()</div><div class="diff-removed">-                        .map(|keyword| self.match_cardinality(keyword.as_str(), hw_counter))</div><div class="diff-removed">-                        .collect::<Vec<_>>();</div><div class="diff-removed">-                    let estimation = if estimations.is_empty() {</div><div class="diff-removed">-                        CardinalityEstimation::exact(0)</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        combine_should_estimations(&estimations, self.get_indexed_points())</div><div class="diff-removed">-                    };</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(</div><div class="diff-removed">-                            condition.clone(),</div><div class="diff-removed">-                        ))),</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => {</div><div class="diff-removed">-                    if integers.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-added">+                        .map(|kw| self.match_cardinality(kw.as_str(), hw_counter))</div><div class="diff-added">+                        .collect();</div><div class="diff-added">+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }</div><div class="diff-added">+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };</div><div class="diff-added">+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Integers(ints) => {</div><div class="diff-added">+                    if ints.is_empty() {</div><div class="diff-added">+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div>                     } else {</div><div>                         None</div><div>                     }</div><div class="diff-info">@@ -681,9 +594,7 @@                 }</div><div>                 AnyVariants::Integers(others) => {</div><div>                     if others.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-added">+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div>                     } else {</div><div>                         None</div><div>                     }</div><div class="diff-info">@@ -692,7 +603,6 @@             _ => None,</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div>     fn payload_blocks(</div><div>         &self,</div><div>         threshold: usize,</div><div class="diff-info">@@ -700,101 +610,100 @@     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div>         Box::new(</div><div>             self.iter_values()</div><div class="diff-removed">-                .map(|value| {</div><div class="diff-added">+                .map(move |v| {</div><div>                     (</div><div class="diff-removed">-                        value,</div><div class="diff-removed">-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Payload_blocks only used in HNSW building, which is unmeasured.</div><div class="diff-removed">-                            .unwrap_or(0),</div><div class="diff-added">+                        v,</div><div class="diff-added">+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),</div><div>                     )</div><div>                 })</div><div class="diff-removed">-                .filter(move |(_value, count)| *count > threshold)</div><div class="diff-removed">-                .map(move |(value, count)| PayloadBlockCondition {</div><div class="diff-removed">-                    condition: FieldCondition::new_match(key.clone(), value.to_string().into()),</div><div class="diff-removed">-                    cardinality: count,</div><div class="diff-added">+                .filter(move |&(_v, cnt)| cnt > threshold)</div><div class="diff-added">+                .map(move |(v, cnt)| PayloadBlockCondition {</div><div class="diff-added">+                    condition: FieldCondition::new_match(key.clone(), v.to_string().into()),</div><div class="diff-added">+                    cardinality: cnt,</div><div>                 }),</div><div>         )</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-impl PayloadFieldIndex for MapIndex<UuidIntType> {</div><div class="diff-added">+impl PayloadFieldIndex for MapIndex<IntPayloadType> {</div><div>     fn count_indexed_points(&self) -> usize {</div><div>         self.get_indexed_points()</div><div>     }</div><div class="diff-removed">-</div><div>     fn load(&mut self) -> OperationResult<bool> {</div><div>         self.load_from_db()</div><div>     }</div><div class="diff-removed">-</div><div>     fn cleanup(self) -> OperationResult<()> {</div><div>         self.clear()</div><div>     }</div><div class="diff-removed">-</div><div>     fn flusher(&self) -> Flusher {</div><div>         MapIndex::flusher(self)</div><div>     }</div><div class="diff-removed">-</div><div>     fn files(&self) -> Vec<PathBuf> {</div><div>         self.files()</div><div>     }</div><div class="diff-removed">-</div><div>     fn filter<'a>(</div><div>         &'a self,</div><div>         condition: &'a FieldCondition,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div>     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {</div><div>         match &condition.r#match {</div><div>             Some(Match::Value(MatchValue { value })) => match value {</div><div class="diff-removed">-                ValueVariants::String(uuid_string) => {</div><div class="diff-removed">-                    let uuid = Uuid::from_str(uuid_string).ok()?;</div><div class="diff-removed">-                    Some(Box::new(</div><div class="diff-removed">-                        self.get_iterator(&uuid.as_u128(), hw_counter).copied(),</div><div class="diff-removed">-                    ))</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ValueVariants::Integer(_) => None,</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {</div><div class="diff-removed">-                AnyVariants::Strings(uuids_string) => {</div><div class="diff-removed">-                    let uuids: Result<IndexSet<u128>, _> = uuids_string</div><div class="diff-added">+                ValueVariants::Integer(integer) => Some(Box::new(self.get_iterator(integer, hw_counter).copied())),</div><div class="diff-added">+                _ => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Any(MatchAny { any })) => match any {</div><div class="diff-added">+                AnyVariants::Integers(integers) => Some(Box::new(</div><div class="diff-added">+                    integers</div><div>                         .iter()</div><div class="diff-removed">-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))</div><div class="diff-removed">-                        .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                    let uuids = uuids.ok()?;</div><div class="diff-removed">-</div><div class="diff-removed">-                    Some(Box::new(</div><div class="diff-removed">-                        uuids</div><div class="diff-removed">-                            .into_iter()</div><div class="diff-removed">-                            .flat_map(move |uuid| self.get_iterator(&uuid, hw_counter).copied())</div><div class="diff-removed">-                            .unique(),</div><div class="diff-removed">-                    ))</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => {</div><div class="diff-removed">-                    if integers.is_empty() {</div><div class="diff-added">+                        .flat_map(move |i| self.get_iterator(i, hw_counter).copied())</div><div class="diff-added">+                        .unique(),</div><div class="diff-added">+                )),</div><div class="diff-added">+                AnyVariants::Strings(_) => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Except(MatchExcept { except })) => match except {</div><div class="diff-added">+                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),</div><div class="diff-added">+                AnyVariants::Strings(_) => {</div><div class="diff-added">+                    if except.is_empty() {</div><div>                         Some(Box::new(iter::empty()))</div><div>                     } else {</div><div>                         None</div><div>                     }</div><div>                 }</div><div>             },</div><div class="diff-added">+            _ => None,</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+    fn estimate_cardinality(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        condition: &FieldCondition,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> Option<CardinalityEstimation> {</div><div class="diff-added">+        match &condition.r#match {</div><div class="diff-added">+            Some(Match::Value(MatchValue { value })) => match value {</div><div class="diff-added">+                ValueVariants::Integer(integer) => {</div><div class="diff-added">+                    let mut est = self.match_cardinality(integer, hw_counter);</div><div class="diff-added">+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-added">+                    Some(est)</div><div class="diff-added">+                }</div><div class="diff-added">+                _ => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Any(MatchAny { any })) => match any {</div><div class="diff-added">+                AnyVariants::Integers(integers) => {</div><div class="diff-added">+                    let v: Vec<_> = integers</div><div class="diff-added">+                        .iter()</div><div class="diff-added">+                        .map(|i| self.match_cardinality(i, hw_counter))</div><div class="diff-added">+                        .collect();</div><div class="diff-added">+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }</div><div class="diff-added">+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };</div><div class="diff-added">+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Strings(_) => None,</div><div class="diff-added">+            },</div><div>             Some(Match::Except(MatchExcept { except })) => match except {</div><div class="diff-removed">-                AnyVariants::Strings(uuids_string) => {</div><div class="diff-removed">-                    let uuids: Result<IndexSet<u128>, _> = uuids_string</div><div class="diff-removed">-                        .iter()</div><div class="diff-removed">-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))</div><div class="diff-removed">-                        .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                    let excluded_uuids = uuids.ok()?;</div><div class="diff-removed">-                    let exclude_iter = self</div><div class="diff-removed">-                        .iter_values()</div><div class="diff-removed">-                        .filter(move |key| !excluded_uuids.contains(*key))</div><div class="diff-removed">-                        .flat_map(move |key| self.get_iterator(key, hw_counter).copied())</div><div class="diff-removed">-                        .unique();</div><div class="diff-removed">-                    Some(Box::new(exclude_iter))</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(other) => {</div><div class="diff-removed">-                    if other.is_empty() {</div><div class="diff-removed">-                        Some(Box::new(iter::empty()))</div><div class="diff-added">+                AnyVariants::Integers(integers) => Some(self.except_cardinality(integers.iter(), hw_counter)),</div><div class="diff-added">+                AnyVariants::Strings(_) => {</div><div class="diff-added">+                    if except.is_empty() {</div><div class="diff-added">+                        Some(CardinalityEstimation::exact(0).with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div>                     } else {</div><div>                         None</div><div>                     }</div><div class="diff-info">@@ -803,84 +712,6 @@             _ => None,</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn estimate_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        condition: &FieldCondition,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> Option<CardinalityEstimation> {</div><div class="diff-removed">-        match &condition.r#match {</div><div class="diff-removed">-            Some(Match::Value(MatchValue { value })) => match value {</div><div class="diff-removed">-                ValueVariants::String(uuid_string) => {</div><div class="diff-removed">-                    let uuid = Uuid::from_str(uuid_string).ok()?;</div><div class="diff-removed">-                    let mut estimation = self.match_cardinality(&uuid.as_u128(), hw_counter);</div><div class="diff-removed">-                    estimation</div><div class="diff-removed">-                        .primary_clauses</div><div class="diff-removed">-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-removed">-                    Some(estimation)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ValueVariants::Integer(_) => None,</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {</div><div class="diff-removed">-                AnyVariants::Strings(uuids_string) => {</div><div class="diff-removed">-                    let uuids: Result<IndexSet<u128>, _> = uuids_string</div><div class="diff-removed">-                        .iter()</div><div class="diff-removed">-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))</div><div class="diff-removed">-                        .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                    let uuids = uuids.ok()?;</div><div class="diff-removed">-</div><div class="diff-removed">-                    let estimations = uuids</div><div class="diff-removed">-                        .into_iter()</div><div class="diff-removed">-                        .map(|uuid| self.match_cardinality(&uuid, hw_counter))</div><div class="diff-removed">-                        .collect::<Vec<_>>();</div><div class="diff-removed">-                    let estimation = if estimations.is_empty() {</div><div class="diff-removed">-                        CardinalityEstimation::exact(0)</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        combine_should_estimations(&estimations, self.get_indexed_points())</div><div class="diff-removed">-                    };</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(</div><div class="diff-removed">-                            condition.clone(),</div><div class="diff-removed">-                        ))),</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => {</div><div class="diff-removed">-                    if integers.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Except(MatchExcept { except })) => match except {</div><div class="diff-removed">-                AnyVariants::Strings(uuids_string) => {</div><div class="diff-removed">-                    let uuids: Result<IndexSet<u128>, _> = uuids_string</div><div class="diff-removed">-                        .iter()</div><div class="diff-removed">-                        .map(|uuid_string| Uuid::from_str(uuid_string).map(|x| x.as_u128()))</div><div class="diff-removed">-                        .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                    let excluded_uuids = uuids.ok()?;</div><div class="diff-removed">-</div><div class="diff-removed">-                    Some(self.except_cardinality(excluded_uuids.iter(), hw_counter))</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(other) => {</div><div class="diff-removed">-                    if other.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            },</div><div class="diff-removed">-            _ => None,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     fn payload_blocks(</div><div>         &self,</div><div>         threshold: usize,</div><div class="diff-info">@@ -888,88 +719,80 @@     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div>         Box::new(</div><div>             self.iter_values()</div><div class="diff-removed">-                .map(move |value| {</div><div class="diff-added">+                .map(move |v| {</div><div>                     (</div><div class="diff-removed">-                        value,</div><div class="diff-removed">-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // payload_blocks only used in HNSW building, which is unmeasured.</div><div class="diff-removed">-                            .unwrap_or(0),</div><div class="diff-added">+                        v,</div><div class="diff-added">+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),</div><div>                     )</div><div>                 })</div><div class="diff-removed">-                .filter(move |(_value, count)| *count >= threshold)</div><div class="diff-removed">-                .map(move |(value, count)| PayloadBlockCondition {</div><div class="diff-removed">-                    condition: FieldCondition::new_match(</div><div class="diff-removed">-                        key.clone(),</div><div class="diff-removed">-                        Uuid::from_u128(*value).to_string().into(),</div><div class="diff-removed">-                    ),</div><div class="diff-removed">-                    cardinality: count,</div><div class="diff-added">+                .filter(move |&(_v, cnt)| cnt >= threshold)</div><div class="diff-added">+                .map(move |(v, cnt)| PayloadBlockCondition {</div><div class="diff-added">+                    condition: FieldCondition::new_match(key.clone(), (*v).into()),</div><div class="diff-added">+                    cardinality: cnt,</div><div>                 }),</div><div>         )</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-impl PayloadFieldIndex for MapIndex<IntPayloadType> {</div><div class="diff-added">+impl PayloadFieldIndex for MapIndex<UuidIntType> {</div><div>     fn count_indexed_points(&self) -> usize {</div><div>         self.get_indexed_points()</div><div>     }</div><div class="diff-removed">-</div><div>     fn load(&mut self) -> OperationResult<bool> {</div><div>         self.load_from_db()</div><div>     }</div><div class="diff-removed">-</div><div>     fn cleanup(self) -> OperationResult<()> {</div><div>         self.clear()</div><div>     }</div><div class="diff-removed">-</div><div>     fn flusher(&self) -> Flusher {</div><div>         MapIndex::flusher(self)</div><div>     }</div><div class="diff-removed">-</div><div>     fn files(&self) -> Vec<PathBuf> {</div><div>         self.files()</div><div>     }</div><div class="diff-removed">-</div><div>     fn filter<'a>(</div><div>         &'a self,</div><div>         condition: &'a FieldCondition,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div>     ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {</div><div>         match &condition.r#match {</div><div>             Some(Match::Value(MatchValue { value })) => match value {</div><div class="diff-removed">-                ValueVariants::String(_) => None,</div><div class="diff-removed">-                ValueVariants::Integer(integer) => {</div><div class="diff-removed">-                    Some(Box::new(self.get_iterator(integer, hw_counter).copied()))</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Any(MatchAny { any: any_variant })) => match any_variant {</div><div class="diff-removed">-                AnyVariants::Strings(keywords) => {</div><div class="diff-removed">-                    if keywords.is_empty() {</div><div class="diff-removed">-                        Some(Box::new(vec![].into_iter()))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => Some(Box::new(</div><div class="diff-removed">-                    integers</div><div class="diff-removed">-                        .iter()</div><div class="diff-removed">-                        .flat_map(move |integer| self.get_iterator(integer, hw_counter).copied())</div><div class="diff-removed">-                        .unique(),</div><div class="diff-removed">-                )),</div><div class="diff-added">+                ValueVariants::String(s) => {</div><div class="diff-added">+                    let uuid = Uuid::from_str(s).ok()?;</div><div class="diff-added">+                    Some(Box::new(self.get_iterator(&uuid.as_u128(), hw_counter).copied()))</div><div class="diff-added">+                }</div><div class="diff-added">+                _ => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Any(MatchAny { any })) => match any {</div><div class="diff-added">+                AnyVariants::Strings(ss) => {</div><div class="diff-added">+                    let uuids: Result<IndexSet<u128>, _> =</div><div class="diff-added">+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();</div><div class="diff-added">+                    let uu = uuids.ok()?;</div><div class="diff-added">+                    Some(Box::new(</div><div class="diff-added">+                        uu.into_iter()</div><div class="diff-added">+                            .flat_map(move |u| self.get_iterator(&u, hw_counter).copied())</div><div class="diff-added">+                            .unique(),</div><div class="diff-added">+                    ))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Integers(_) => None,</div><div>             },</div><div>             Some(Match::Except(MatchExcept { except })) => match except {</div><div class="diff-removed">-                AnyVariants::Strings(other) => {</div><div class="diff-removed">-                    if other.is_empty() {</div><div class="diff-removed">-                        Some(Box::new(iter::empty()))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => Some(self.except_set(integers, hw_counter)),</div><div class="diff-added">+                AnyVariants::Strings(ss) => {</div><div class="diff-added">+                    let uuids: Result<IndexSet<u128>, _> =</div><div class="diff-added">+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();</div><div class="diff-added">+                    let uu = uuids.ok()?;</div><div class="diff-added">+                    Some(Box::new(</div><div class="diff-added">+                        self.iter_values()</div><div class="diff-added">+                            .filter(move |key| !uu.contains(*key))</div><div class="diff-added">+                            .flat_map(move |key| self.get_iterator(key, hw_counter).copied())</div><div class="diff-added">+                            .unique(),</div><div class="diff-added">+                    ))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Integers(_) => None,</div><div>             },</div><div>             _ => None,</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div>     fn estimate_cardinality(</div><div>         &self,</div><div>         condition: &FieldCondition,</div><div class="diff-info">@@ -977,61 +800,38 @@     ) -> Option<CardinalityEstimation> {</div><div>         match &condition.r#match {</div><div>             Some(Match::Value(MatchValue { value })) => match value {</div><div class="diff-removed">-                ValueVariants::String(_) => None,</div><div class="diff-removed">-                ValueVariants::Integer(integer) => {</div><div class="diff-removed">-                    let mut estimation = self.match_cardinality(integer, hw_counter);</div><div class="diff-removed">-                    estimation</div><div class="diff-removed">-                        .primary_clauses</div><div class="diff-removed">-                        .push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-removed">-                    Some(estimation)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ValueVariants::Bool(_) => None,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(Match::Any(MatchAny { any: any_variants })) => match any_variants {</div><div class="diff-removed">-                AnyVariants::Strings(keywords) => {</div><div class="diff-removed">-                    if keywords.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => {</div><div class="diff-removed">-                    let estimations = integers</div><div class="diff-removed">-                        .iter()</div><div class="diff-removed">-                        .map(|integer| self.match_cardinality(integer, hw_counter))</div><div class="diff-removed">-                        .collect::<Vec<_>>();</div><div class="diff-removed">-                    let estimation = if estimations.is_empty() {</div><div class="diff-removed">-                        CardinalityEstimation::exact(0)</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        combine_should_estimations(&estimations, self.get_indexed_points())</div><div class="diff-removed">-                    };</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        estimation.with_primary_clause(PrimaryCondition::Condition(Box::new(</div><div class="diff-removed">-                            condition.clone(),</div><div class="diff-removed">-                        ))),</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                }</div><div class="diff-added">+                ValueVariants::String(s) => {</div><div class="diff-added">+                    let uuid = Uuid::from_str(s).ok()?;</div><div class="diff-added">+                    let mut est = self.match_cardinality(&uuid.as_u128(), hw_counter);</div><div class="diff-added">+                    est.primary_clauses.push(PrimaryCondition::Condition(Box::new(condition.clone())));</div><div class="diff-added">+                    Some(est)</div><div class="diff-added">+                }</div><div class="diff-added">+                _ => None,</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(Match::Any(MatchAny { any })) => match any {</div><div class="diff-added">+                AnyVariants::Strings(ss) => {</div><div class="diff-added">+                    let uuids: Result<IndexSet<u128>, _> =</div><div class="diff-added">+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();</div><div class="diff-added">+                    let uu = uuids.ok()?;</div><div class="diff-added">+                    let v: Vec<_> = uu.into_iter().map(|u| self.match_cardinality(&u, hw_counter)).collect();</div><div class="diff-added">+                    let c = if v.is_empty() { CardinalityEstimation::exact(0) }</div><div class="diff-added">+                    else { crate::index::field_index::combine_should_estimations(&v, self.get_indexed_points()) };</div><div class="diff-added">+                    Some(c.with_primary_clause(PrimaryCondition::Condition(Box::new(condition.clone()))))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Integers(_) => None,</div><div>             },</div><div>             Some(Match::Except(MatchExcept { except })) => match except {</div><div class="diff-removed">-                AnyVariants::Strings(others) => {</div><div class="diff-removed">-                    if others.is_empty() {</div><div class="diff-removed">-                        Some(CardinalityEstimation::exact(0).with_primary_clause(</div><div class="diff-removed">-                            PrimaryCondition::Condition(Box::new(condition.clone())),</div><div class="diff-removed">-                        ))</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        None</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                AnyVariants::Integers(integers) => {</div><div class="diff-removed">-                    Some(self.except_cardinality(integers.iter(), hw_counter))</div><div class="diff-removed">-                }</div><div class="diff-added">+                AnyVariants::Strings(ss) => {</div><div class="diff-added">+                    let uuids: Result<IndexSet<u128>, _> =</div><div class="diff-added">+                        ss.iter().map(|s| Uuid::from_str(s).map(|u| u.as_u128())).collect();</div><div class="diff-added">+                    let uu = uuids.ok()?;</div><div class="diff-added">+                    Some(self.except_cardinality(uu.iter(), hw_counter))</div><div class="diff-added">+                }</div><div class="diff-added">+                AnyVariants::Integers(_) => None,</div><div>             },</div><div>             _ => None,</div><div>         }</div><div>     }</div><div class="diff-removed">-</div><div>     fn payload_blocks(</div><div>         &self,</div><div>         threshold: usize,</div><div class="diff-info">@@ -1039,163 +839,122 @@     ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div>         Box::new(</div><div>             self.iter_values()</div><div class="diff-removed">-                .map(move |value| {</div><div class="diff-added">+                .map(move |v| {</div><div>                     (</div><div class="diff-removed">-                        value,</div><div class="diff-removed">-                        self.get_count_for_value(value, &HardwareCounterCell::disposable()) // Only used in HNSW building so no measurement needed here.</div><div class="diff-removed">-                            .unwrap_or(0),</div><div class="diff-added">+                        v,</div><div class="diff-added">+                        self.get_count_for_value(v, &HardwareCounterCell::disposable()).unwrap_or(0),</div><div>                     )</div><div>                 })</div><div class="diff-removed">-                .filter(move |(_value, count)| *count >= threshold)</div><div class="diff-removed">-                .map(move |(value, count)| PayloadBlockCondition {</div><div class="diff-removed">-                    condition: FieldCondition::new_match(key.clone(), (*value).into()),</div><div class="diff-removed">-                    cardinality: count,</div><div class="diff-added">+                .filter(move |&(_v, cnt)| cnt >= threshold)</div><div class="diff-added">+                .map(move |(v, cnt)| PayloadBlockCondition {</div><div class="diff-added">+                    condition: FieldCondition::new_match(</div><div class="diff-added">+                        key.clone(),</div><div class="diff-added">+                        Uuid::from_u128(*v).to_string().into(),</div><div class="diff-added">+                    ),</div><div class="diff-added">+                    cardinality: cnt,</div><div>                 }),</div><div>         )</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+impl ValueIndexer for MapIndex<str> {</div><div class="diff-added">+    type ValueType = String;</div><div class="diff-added">+    fn add_many(</div><div class="diff-added">+        &mut self,</div><div class="diff-added">+        id: PointOffsetType,</div><div class="diff-added">+        values: Vec<String>,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> OperationResult<()> {</div><div class="diff-added">+        match self {</div><div class="diff-added">+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-added">+            _ => Err(OperationError::service_error("Can't add values to this index")),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+    fn get_value(value: &Value) -> Option<String> {</div><div class="diff-added">+        value.as_str().map(|s| s.to_owned())</div><div class="diff-added">+    }</div><div class="diff-added">+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-added">+        self.remove_point(id)</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+impl ValueIndexer for MapIndex<IntPayloadType> {</div><div class="diff-added">+    type ValueType = IntPayloadType;</div><div class="diff-added">+    fn add_many(</div><div class="diff-added">+        &mut self,</div><div class="diff-added">+        id: PointOffsetType,</div><div class="diff-added">+        values: Vec<IntPayloadType>,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> OperationResult<()> {</div><div class="diff-added">+        match self {</div><div class="diff-added">+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-added">+            _ => Err(OperationError::service_error("Can't add values to this index")),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+    fn get_value(value: &Value) -> Option<IntPayloadType> {</div><div class="diff-added">+        value.as_i64()</div><div class="diff-added">+    }</div><div class="diff-added">+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-added">+        self.remove_point(id)</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+impl ValueIndexer for MapIndex<UuidIntType> {</div><div class="diff-added">+    type ValueType = UuidIntType;</div><div class="diff-added">+    fn add_many(</div><div class="diff-added">+        &mut self,</div><div class="diff-added">+        id: PointOffsetType,</div><div class="diff-added">+        values: Vec<UuidIntType>,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> OperationResult<()> {</div><div class="diff-added">+        match self {</div><div class="diff-added">+            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-added">+            _ => Err(OperationError::service_error("Can't add values to this index")),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+    fn get_value(value: &Value) -> Option<UuidIntType> {</div><div class="diff-added">+        value.as_str().and_then(|s| Uuid::parse_str(s).ok().map(|u| u.as_u128()))</div><div class="diff-added">+    }</div><div class="diff-added">+    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-added">+        self.remove_point(id)</div><div>     }</div><div> }</div><div> </div><div> impl<N> FacetIndex for MapIndex<N></div><div> where</div><div>     N: MapIndexKey + ?Sized,</div><div class="diff-added">+    for<'a> &'a N: Into<FacetValueRef<'a>>,</div><div>     for<'a> N::Referenced<'a>: Into<FacetValueRef<'a>>,</div><div class="diff-removed">-    for<'a> &'a N: Into<FacetValueRef<'a>>,</div><div> {</div><div>     fn get_point_values(</div><div>         &self,</div><div>         point_id: PointOffsetType,</div><div class="diff-removed">-    ) -> impl Iterator<Item = FacetValueRef> + '_ {</div><div class="diff-removed">-        MapIndex::get_values(self, point_id)</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .flatten()</div><div class="diff-removed">-            .map(Into::into)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+    ) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {</div><div class="diff-added">+        self.get_values(point_id).into_iter().flatten().map(Into::into)</div><div class="diff-added">+    }</div><div>     fn iter_values(&self) -> impl Iterator<Item = FacetValueRef<'_>> + '_ {</div><div>         self.iter_values().map(Into::into)</div><div>     }</div><div class="diff-removed">-</div><div>     fn iter_values_map<'a>(</div><div>         &'a self,</div><div>         hw_counter: &'a HardwareCounterCell,</div><div>     ) -> impl Iterator<Item = (FacetValueRef<'a>, IdIter<'a>)> + 'a {</div><div class="diff-removed">-        self.iter_values_map(hw_counter)</div><div class="diff-removed">-            .map(|(k, iter)| (k.into(), iter))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+        self.iter_values_map(hw_counter).map(|(k, it)| (k.into(), it))</div><div class="diff-added">+    }</div><div>     fn iter_counts_per_value(&self) -> impl Iterator<Item = FacetHit<FacetValueRef<'_>>> + '_ {</div><div class="diff-removed">-        self.iter_counts_per_value().map(|(value, count)| FacetHit {</div><div class="diff-removed">-            value: value.into(),</div><div class="diff-removed">-            count,</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl ValueIndexer for MapIndex<str> {</div><div class="diff-removed">-    type ValueType = String;</div><div class="diff-removed">-</div><div class="diff-removed">-    fn add_many(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        id: PointOffsetType,</div><div class="diff-removed">-        values: Vec<String>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-removed">-            MapIndex::Immutable(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to immutable map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-            MapIndex::Mmap(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to mmap map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_value(value: &Value) -> Option<String> {</div><div class="diff-removed">-        if let Value::String(keyword) = value {</div><div class="diff-removed">-            return Some(keyword.to_owned());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        None</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-removed">-        self.remove_point(id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl ValueIndexer for MapIndex<IntPayloadType> {</div><div class="diff-removed">-    type ValueType = IntPayloadType;</div><div class="diff-removed">-</div><div class="diff-removed">-    fn add_many(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        id: PointOffsetType,</div><div class="diff-removed">-        values: Vec<IntPayloadType>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-removed">-            MapIndex::Immutable(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to immutable map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-            MapIndex::Mmap(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to mmap map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_value(value: &Value) -> Option<IntPayloadType> {</div><div class="diff-removed">-        if let Value::Number(num) = value {</div><div class="diff-removed">-            return num.as_i64();</div><div class="diff-removed">-        }</div><div class="diff-removed">-        None</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-removed">-        self.remove_point(id)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl ValueIndexer for MapIndex<UuidIntType> {</div><div class="diff-removed">-    type ValueType = UuidIntType;</div><div class="diff-removed">-</div><div class="diff-removed">-    fn add_many(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        id: PointOffsetType,</div><div class="diff-removed">-        values: Vec<Self::ValueType>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            MapIndex::Mutable(index) => index.add_many_to_map(id, values, hw_counter),</div><div class="diff-removed">-            MapIndex::Immutable(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to immutable map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-            MapIndex::Mmap(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Can't add values to mmap map index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_value(value: &Value) -> Option<Self::ValueType> {</div><div class="diff-removed">-        Some(Uuid::parse_str(value.as_str()?).ok()?.as_u128())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-removed">-        self.remove_point(id)</div><div class="diff-added">+        self.iter_counts_per_value()</div><div class="diff-added">+            .map(|(v, c)| FacetHit { value: v.into(), count: c })</div><div>     }</div><div> }</div><div> </div><div> #[cfg(test)]</div><div> mod tests {</div><div class="diff-added">+    use super::*;</div><div class="diff-added">+    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;</div><div class="diff-added">+    use rstest::rstest;</div><div>     use std::collections::HashSet;</div><div>     use std::path::Path;</div><div class="diff-removed">-</div><div class="diff-removed">-    use rstest::rstest;</div><div>     use tempfile::Builder;</div><div class="diff-removed">-</div><div class="diff-removed">-    use super::*;</div><div class="diff-removed">-    use crate::common::rocksdb_wrapper::open_db_with_existing_cf;</div><div class="diff-removed">-</div><div class="diff-removed">-    const FIELD_NAME: &str = "test";</div><div> </div><div>     #[derive(Clone, Copy)]</div><div>     enum IndexType {</div><div class="diff-info">@@ -1207,109 +966,68 @@     fn save_map_index<N>(</div><div>         data: &[Vec<N::Owned>],</div><div>         path: &Path,</div><div class="diff-removed">-        index_type: IndexType,</div><div class="diff-added">+        idx_type: IndexType,</div><div>         into_value: impl Fn(&N::Owned) -> Value,</div><div>     ) where</div><div>         N: MapIndexKey + ?Sized,</div><div>         MapIndex<N>: PayloadFieldIndex + ValueIndexer,</div><div>         <MapIndex<N> as ValueIndexer>::ValueType: Into<N::Owned>,</div><div>     {</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        match index_type {</div><div class="diff-added">+        let hw = HardwareCounterCell::new();</div><div class="diff-added">+        match idx_type {</div><div>             IndexType::Mutable | IndexType::Immutable => {</div><div class="diff-removed">-                let mut builder =</div><div class="diff-removed">-                    MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), FIELD_NAME);</div><div class="diff-removed">-                builder.init().unwrap();</div><div class="diff-removed">-                for (idx, values) in data.iter().enumerate() {</div><div class="diff-removed">-                    let values: Vec<Value> = values.iter().map(&into_value).collect();</div><div class="diff-removed">-                    let values: Vec<_> = values.iter().collect();</div><div class="diff-removed">-                    builder</div><div class="diff-removed">-                        .add_point(idx as PointOffsetType, &values, &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                }</div><div class="diff-removed">-                builder.finalize().unwrap();</div><div class="diff-added">+                let mut bldr = MapIndex::<N>::builder(open_db_with_existing_cf(path).unwrap(), "test");</div><div class="diff-added">+                bldr.init().unwrap();</div><div class="diff-added">+                for (i, vals) in data.iter().enumerate() {</div><div class="diff-added">+                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();</div><div class="diff-added">+                    let refs: Vec<_> = vs.iter().collect();</div><div class="diff-added">+                    bldr.add_point(i as _, &refs, &hw).unwrap();</div><div class="diff-added">+                }</div><div class="diff-added">+                bldr.finalize().unwrap();</div><div>             }</div><div>             IndexType::Mmap => {</div><div class="diff-removed">-                let mut builder = MapIndex::<N>::mmap_builder(path, false);</div><div class="diff-removed">-                builder.init().unwrap();</div><div class="diff-removed">-                for (idx, values) in data.iter().enumerate() {</div><div class="diff-removed">-                    let values: Vec<Value> = values.iter().map(&into_value).collect();</div><div class="diff-removed">-                    let values: Vec<_> = values.iter().collect();</div><div class="diff-removed">-                    builder</div><div class="diff-removed">-                        .add_point(idx as PointOffsetType, &values, &hw_counter)</div><div class="diff-removed">-                        .unwrap();</div><div class="diff-removed">-                }</div><div class="diff-removed">-                builder.finalize().unwrap();</div><div class="diff-added">+                let mut bldr = MapIndex::<N>::mmap_builder(path, false);</div><div class="diff-added">+                bldr.init().unwrap();</div><div class="diff-added">+                for (i, vals) in data.iter().enumerate() {</div><div class="diff-added">+                    let vs: Vec<Value> = vals.iter().map(&into_value).collect();</div><div class="diff-added">+                    let refs: Vec<_> = vs.iter().collect();</div><div class="diff-added">+                    bldr.add_point(i as _, &refs, &hw).unwrap();</div><div class="diff-added">+                }</div><div class="diff-added">+                bldr.finalize().unwrap();</div><div>             }</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    fn load_map_index<N: MapIndexKey + ?Sized>(</div><div class="diff-added">+    fn load_map_index<N>(</div><div>         data: &[Vec<N::Owned>],</div><div>         path: &Path,</div><div class="diff-removed">-        index_type: IndexType,</div><div class="diff-removed">-    ) -> MapIndex<N> {</div><div class="diff-removed">-        let mut index = match index_type {</div><div class="diff-removed">-            IndexType::Mutable => {</div><div class="diff-removed">-                MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), FIELD_NAME, true)</div><div class="diff-removed">-            }</div><div class="diff-removed">-            IndexType::Immutable => MapIndex::<N>::new_memory(</div><div class="diff-removed">-                open_db_with_existing_cf(path).unwrap(),</div><div class="diff-removed">-                FIELD_NAME,</div><div class="diff-removed">-                false,</div><div class="diff-removed">-            ),</div><div class="diff-added">+        idx_type: IndexType,</div><div class="diff-added">+    ) -> MapIndex<N></div><div class="diff-added">+    where</div><div class="diff-added">+        N: MapIndexKey + ?Sized,</div><div class="diff-added">+    {</div><div class="diff-added">+        let mut idx = match idx_type {</div><div class="diff-added">+            IndexType::Mutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", true),</div><div class="diff-added">+            IndexType::Immutable => MapIndex::<N>::new_memory(open_db_with_existing_cf(path).unwrap(), "test", false),</div><div>             IndexType::Mmap => MapIndex::<N>::new_mmap(path, false).unwrap(),</div><div>         };</div><div class="diff-removed">-        index.load_from_db().unwrap();</div><div class="diff-removed">-        for (idx, values) in data.iter().enumerate() {</div><div class="diff-removed">-            let index_values: HashSet<N::Owned> = index</div><div class="diff-removed">-                .get_values(idx as PointOffsetType)</div><div class="diff-removed">-                .unwrap()</div><div class="diff-removed">-                .map(|v| N::to_owned(N::from_referenced(&v)))</div><div class="diff-added">+        idx.load_from_db().unwrap();</div><div class="diff-added">+        for (i, vals) in data.iter().enumerate() {</div><div class="diff-added">+            let got: HashSet<N> = idx</div><div class="diff-added">+                .get_values(i as _).unwrap()</div><div class="diff-added">+                .map(|r| N::to_owned(N::as_referenced(&r)))</div><div>                 .collect();</div><div class="diff-removed">-            let index_values: HashSet<&N> = index_values.iter().map(|v| v.borrow()).collect();</div><div class="diff-removed">-            let check_values: HashSet<&N> = values.iter().map(|v| v.borrow()).collect();</div><div class="diff-removed">-            assert_eq!(index_values, check_values);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        index</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_index_non_ascending_insertion() {</div><div class="diff-removed">-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-removed">-        let mut builder = MapIndex::<IntPayloadType>::mmap_builder(temp_dir.path(), false);</div><div class="diff-removed">-        builder.init().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let data = [vec![1, 2, 3, 4, 5, 6], vec![25], vec![10, 11]];</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        for (idx, values) in data.iter().enumerate().rev() {</div><div class="diff-removed">-            let values: Vec<Value> = values.iter().map(|i| (*i).into()).collect();</div><div class="diff-removed">-            let values: Vec<_> = values.iter().collect();</div><div class="diff-removed">-            builder</div><div class="diff-removed">-                .add_point(idx as PointOffsetType, &values, &hw_counter)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let index = builder.finalize().unwrap();</div><div class="diff-removed">-        for (idx, values) in data.iter().enumerate().rev() {</div><div class="diff-removed">-            let res: Vec<_> = index</div><div class="diff-removed">-                .get_values(idx as u32)</div><div class="diff-removed">-                .unwrap()</div><div class="diff-removed">-                .map(|i| *i as i32)</div><div class="diff-removed">-                .collect();</div><div class="diff-removed">-            assert_eq!(res, *values);</div><div class="diff-removed">-        }</div><div class="diff-added">+            let want: HashSet<N> = vals.iter().cloned().collect();</div><div class="diff-added">+            assert_eq!(got, want);</div><div class="diff-added">+        }</div><div class="diff-added">+        idx</div><div>     }</div><div> </div><div>     #[rstest]</div><div>     #[case(IndexType::Mutable)]</div><div>     #[case(IndexType::Immutable)]</div><div>     #[case(IndexType::Mmap)]</div><div class="diff-removed">-    fn test_int_disk_map_index(#[case] index_type: IndexType) {</div><div class="diff-added">+    fn test_int_disk_map_index(#[case] idx_type: IndexType) {</div><div>         let data = vec![</div><div>             vec![1, 2, 3, 4, 5, 6],</div><div>             vec![1, 2, 3, 4, 5, 6],</div><div class="diff-info">@@ -1317,82 +1035,61 @@             vec![19, 20, 21, 22, 23, 24],</div><div>             vec![25],</div><div>         ];</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-removed">-        save_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type, |v| (*v).into());</div><div class="diff-removed">-        let index = load_map_index::<IntPayloadType>(&data, temp_dir.path(), index_type);</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure cardinality is non zero</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            !index</div><div class="diff-removed">-                .except_cardinality(vec![].into_iter(), &hw_counter)</div><div class="diff-removed">-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),</div><div class="diff-removed">-        );</div><div class="diff-added">+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-added">+        save_map_index::<IntPayloadType>(&data, td.path(), idx_type, |v| (*v).into());</div><div class="diff-added">+        let idx = load_map_index::<IntPayloadType>(&data, td.path(), idx_type);</div><div class="diff-added">+        let hw = HardwareCounterCell::new();</div><div class="diff-added">+        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));</div><div>     }</div><div> </div><div>     #[rstest]</div><div>     #[case(IndexType::Mutable)]</div><div>     #[case(IndexType::Immutable)]</div><div>     #[case(IndexType::Mmap)]</div><div class="diff-removed">-    fn test_string_disk_map_index(#[case] index_type: IndexType) {</div><div class="diff-added">+    fn test_string_disk_map_index(#[case] idx_type: IndexType) {</div><div>         let data = vec![</div><div class="diff-removed">-            vec![</div><div class="diff-removed">-                SmolStr::from("AABB"),</div><div class="diff-removed">-                SmolStr::from("UUFF"),</div><div class="diff-removed">-                SmolStr::from("IIBB"),</div><div class="diff-removed">-            ],</div><div class="diff-removed">-            vec![</div><div class="diff-removed">-                SmolStr::from("PPMM"),</div><div class="diff-removed">-                SmolStr::from("QQXX"),</div><div class="diff-removed">-                SmolStr::from("YYBB"),</div><div class="diff-removed">-            ],</div><div class="diff-removed">-            vec![</div><div class="diff-removed">-                SmolStr::from("FFMM"),</div><div class="diff-removed">-                SmolStr::from("IICC"),</div><div class="diff-removed">-                SmolStr::from("IIBB"),</div><div class="diff-removed">-            ],</div><div class="diff-removed">-            vec![</div><div class="diff-removed">-                SmolStr::from("AABB"),</div><div class="diff-removed">-                SmolStr::from("UUFF"),</div><div class="diff-removed">-                SmolStr::from("IIBB"),</div><div class="diff-removed">-            ],</div><div class="diff-added">+            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],</div><div class="diff-added">+            vec![SmolStr::from("PPMM"), SmolStr::from("QQXX"), SmolStr::from("YYBB")],</div><div class="diff-added">+            vec![SmolStr::from("FFMM"), SmolStr::from("IICC"), SmolStr::from("IIBB")],</div><div class="diff-added">+            vec![SmolStr::from("AABB"), SmolStr::from("UUFF"), SmolStr::from("IIBB")],</div><div>             vec![SmolStr::from("PPGG")],</div><div>         ];</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-removed">-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());</div><div class="diff-removed">-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure cardinality is non zero</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            !index</div><div class="diff-removed">-                .except_cardinality(vec![].into_iter(), &hw_counter)</div><div class="diff-removed">-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),</div><div class="diff-removed">-        );</div><div class="diff-added">+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-added">+        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());</div><div class="diff-added">+        let idx = load_map_index::<str>(&data, td.path(), idx_type);</div><div class="diff-added">+        let hw = HardwareCounterCell::new();</div><div class="diff-added">+        assert!(!idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));</div><div>     }</div><div> </div><div>     #[rstest]</div><div>     #[case(IndexType::Mutable)]</div><div>     #[case(IndexType::Immutable)]</div><div>     #[case(IndexType::Mmap)]</div><div class="diff-removed">-    fn test_empty_index(#[case] index_type: IndexType) {</div><div class="diff-added">+    fn test_empty_index(#[case] idx_type: IndexType) {</div><div>         let data: Vec<Vec<SmolStr>> = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-removed">-        save_map_index::<str>(&data, temp_dir.path(), index_type, |v| v.to_string().into());</div><div class="diff-removed">-        let index = load_map_index::<str>(&data, temp_dir.path(), index_type);</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure cardinality is zero</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            index</div><div class="diff-removed">-                .except_cardinality(vec![].into_iter(), &hw_counter)</div><div class="diff-removed">-                .equals_min_exp_max(&CardinalityEstimation::exact(0)),</div><div class="diff-removed">-        );</div><div class="diff-added">+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-added">+        save_map_index::<str>(&data, td.path(), idx_type, |v| v.to_string().into());</div><div class="diff-added">+        let idx = load_map_index::<str>(&data, td.path(), idx_type);</div><div class="diff-added">+        let hw = HardwareCounterCell::new();</div><div class="diff-added">+        assert!(idx.except_cardinality(vec![].into_iter(), &hw).equals_min_exp_max(&CardinalityEstimation::exact(0)));</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn test_index_non_ascending_insertion() {</div><div class="diff-added">+        let td = Builder::new().prefix("store_dir").tempdir().unwrap();</div><div class="diff-added">+        let mut bldr = MapIndex::<IntPayloadType>::mmap_builder(td.path(), false);</div><div class="diff-added">+        bldr.init().unwrap();</div><div class="diff-added">+        let data = [vec![1,2,3,4,5,6], vec![25], vec![10,11]];</div><div class="diff-added">+        let hw = HardwareCounterCell::new();</div><div class="diff-added">+        for (i, vals) in data.iter().enumerate().rev() {</div><div class="diff-added">+            let vs: Vec<Value> = vals.iter().map(|&x| x.into()).collect();</div><div class="diff-added">+            let refs: Vec<_> = vs.iter().collect();</div><div class="diff-added">+            bldr.add_point(i as _, &refs, &hw).unwrap();</div><div class="diff-added">+        }</div><div class="diff-added">+        let idx = bldr.finalize().unwrap();</div><div class="diff-added">+        for (i, vals) in data.iter().enumerate().rev() {</div><div class="diff-added">+            let got: Vec<_> = idx.get_values(i as _).unwrap().map(|&x| x as i32).collect();</div><div class="diff-added">+            assert_eq!(got, *vals);</div><div class="diff-added">+        }</div><div>     }</div><div> }</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    