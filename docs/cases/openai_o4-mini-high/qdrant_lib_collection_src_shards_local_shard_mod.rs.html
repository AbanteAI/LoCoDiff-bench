<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - o4-mini-high</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: o4-mini-high</h2>
        <p><a href="../../models/openai_o4-mini-high.html">All o4-mini-high Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o4-mini-high</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 59478</p>
                <p><strong>Native Completion Tokens:</strong> 8977</p>
                <p><strong>Native Tokens Reasoning:</strong> 2624</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.00524623</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o4-mini-high/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb3..97d2e66c 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpo65oeanq_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpe8lsu0ke_actual.txt	</div><div class="diff-info">@@ -1,7 +1,5 @@</div><div> pub mod clock_map;</div><div> pub mod disk_usage_watcher;</div><div class="diff-removed">-pub(super) mod facet;</div><div class="diff-removed">-pub(super) mod formula_rescore;</div><div> pub(super) mod query;</div><div> pub(super) mod scroll;</div><div> pub(super) mod search;</div><div class="diff-info">@@ -30,35 +28,23 @@ use segment::entry::entry_point::SegmentEntry as _;</div><div> use segment::index::field_index::CardinalityEstimation;</div><div> use segment::segment::Segment;</div><div> use segment::segment_constructor::{build_segment, load_segment};</div><div class="diff-removed">-use segment::types::{</div><div class="diff-removed">-    Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,</div><div class="diff-removed">-    SnapshotFormat,</div><div class="diff-removed">-};</div><div class="diff-added">+use segment::types::{Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType, SnapshotFormat};</div><div> use tokio::fs::{create_dir_all, remove_dir_all, remove_file};</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::Sender;</div><div> use tokio::sync::{Mutex, RwLock as TokioRwLock, mpsc, oneshot};</div><div> use wal::{Wal, WalOptions};</div><div> </div><div class="diff-removed">-use self::clock_map::{ClockMap, RecoveryPoint};</div><div class="diff-removed">-use self::disk_usage_watcher::DiskUsageWatcher;</div><div class="diff-removed">-use super::update_tracker::UpdateTracker;</div><div class="diff-removed">-use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div class="diff-removed">-use crate::collection_manager::collection_updater::CollectionUpdater;</div><div class="diff-removed">-use crate::collection_manager::holders::segment_holder::{</div><div class="diff-removed">-    LockedSegment, LockedSegmentHolder, SegmentHolder,</div><div class="diff-removed">-};</div><div class="diff-added">+use crate::collection_manager::holders::segment_holder::{LockedSegment, LockedSegmentHolder, SegmentHolder};</div><div> use crate::collection_manager::optimizers::TrackerLog;</div><div> use crate::collection_manager::segments_searcher::SegmentsSearcher;</div><div> use crate::common::file_utils::{move_dir, move_file};</div><div> use crate::config::CollectionConfigInternal;</div><div class="diff-removed">-use crate::operations::OperationWithClockTag;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{</div><div class="diff-removed">-    CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div class="diff-removed">-    check_sparse_compatible_with_segment_config,</div><div class="diff-added">+    check_sparse_compatible_with_segment_config, CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div> };</div><div class="diff-removed">-use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};</div><div class="diff-added">+use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::CollectionId;</div><div> use crate::shards::shard::ShardId;</div><div class="diff-info">@@ -71,40 +57,34 @@ use crate::wal_delta::{LockedWal, RecoverableWal};</div><div> const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);</div><div> </div><div> const WAL_PATH: &str = "wal";</div><div class="diff-removed">-</div><div> const SEGMENTS_PATH: &str = "segments";</div><div> </div><div class="diff-removed">-const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";</div><div class="diff-removed">-</div><div class="diff-removed">-const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";</div><div class="diff-removed">-</div><div> /// LocalShard</div><div> ///</div><div class="diff-removed">-/// LocalShard is an entity that can be moved between peers and contains some part of one collections data.</div><div class="diff-added">+/// LocalShard is an entity that can be moved between peers and contains some part of one collectionâ€™s data.</div><div> ///</div><div class="diff-removed">-/// Holds all object, required for collection functioning</div><div class="diff-added">+/// Holds all objects required for collection functioning</div><div> pub struct LocalShard {</div><div>     pub(super) segments: LockedSegmentHolder,</div><div>     pub(super) collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div>     pub(super) shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-    pub(crate) payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+    pub(super) payload_index_schema: Arc<SaveOnDisk<crate::collection::payload_index_schema::PayloadIndexSchema>>,</div><div>     pub(super) wal: RecoverableWal,</div><div>     pub(super) update_handler: Arc<Mutex<UpdateHandler>>,</div><div>     pub(super) update_sender: ArcSwap<Sender<UpdateSignal>>,</div><div class="diff-removed">-    pub(super) update_tracker: UpdateTracker,</div><div class="diff-added">+    pub(super) update_tracker: crate::shards::update_tracker::UpdateTracker,</div><div>     pub(super) path: PathBuf,</div><div>     pub(super) optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>     pub(super) optimizers_log: Arc<ParkingMutex<TrackerLog>>,</div><div>     pub(super) total_optimized_points: Arc<AtomicUsize>,</div><div>     update_runtime: Handle,</div><div>     pub(super) search_runtime: Handle,</div><div class="diff-removed">-    disk_usage_watcher: DiskUsageWatcher,</div><div class="diff-added">+    disk_usage_watcher: crate::shards::local_shard::disk_usage_watcher::DiskUsageWatcher,</div><div>     read_rate_limiter: Option<ParkingMutex<RateLimiter>>,</div><div> }</div><div> </div><div class="diff-removed">-/// Shard holds information about segments and WAL.</div><div> impl LocalShard {</div><div class="diff-removed">-    /// Moves `wal`, `segments` and `clocks` data from one path to another.</div><div class="diff-added">+    /// Moves `wal`, `segments` and clock data from one path to another.</div><div>     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div>         log::debug!(</div><div>             "Moving local shard from {} to {}",</div><div class="diff-info">@@ -114,18 +94,18 @@ impl LocalShard {</div><div> </div><div>         let wal_from = Self::wal_path(from);</div><div>         let wal_to = Self::wal_path(to);</div><div class="diff-added">+        move_dir(&wal_from, &wal_to).await?;</div><div class="diff-added">+</div><div>         let segments_from = Self::segments_path(from);</div><div>         let segments_to = Self::segments_path(to);</div><div class="diff-removed">-</div><div class="diff-removed">-        move_dir(wal_from, wal_to).await?;</div><div class="diff-removed">-        move_dir(segments_from, segments_to).await?;</div><div class="diff-added">+        move_dir(&segments_from, &segments_to).await?;</div><div> </div><div>         LocalShardClocks::move_data(from, to).await?;</div><div> </div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Checks if path have local shard data present</div><div class="diff-added">+    /// Checks if path has local shard data present</div><div>     pub fn check_data(shard_path: &Path) -> bool {</div><div>         let wal_path = Self::wal_path(shard_path);</div><div>         let segments_path = Self::segments_path(shard_path);</div><div class="diff-info">@@ -139,15 +119,16 @@ impl LocalShard {</div><div>         // Delete WAL</div><div>         let wal_path = Self::wal_path(shard_path);</div><div>         if wal_path.exists() {</div><div class="diff-removed">-            remove_dir_all(wal_path).await?;</div><div class="diff-added">+            remove_dir_all(&wal_path).await?;</div><div>         }</div><div> </div><div>         // Delete segments</div><div>         let segments_path = Self::segments_path(shard_path);</div><div>         if segments_path.exists() {</div><div class="diff-removed">-            remove_dir_all(segments_path).await?;</div><div class="diff-added">+            remove_dir_all(&segments_path).await?;</div><div>         }</div><div> </div><div class="diff-added">+        // Delete clock maps</div><div>         LocalShardClocks::delete_data(shard_path).await?;</div><div> </div><div>         Ok(())</div><div class="diff-info">@@ -158,14 +139,15 @@ impl LocalShard {</div><div>         segment_holder: SegmentHolder,</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        wal: SerdeWal<OperationWithClockTag>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<crate::collection::payload_index_schema::PayloadIndexSchema>>,</div><div class="diff-added">+        wal: SerdeWal<crate::operations::OperationWithClockTag>,</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-added">+        optimizer_config: OptimizersConfig,</div><div>         shard_path: &Path,</div><div>         clocks: LocalShardClocks,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div class="diff-added">+        optimizer_resource_budget: ResourceBudget,</div><div>     ) -> Self {</div><div>         let segment_holder = Arc::new(RwLock::new(segment_holder));</div><div>         let config = collection_config.read().await;</div><div class="diff-info">@@ -175,9 +157,8 @@ impl LocalShard {</div><div> </div><div>         // default to 2x the WAL capacity</div><div>         let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-removed">-</div><div class="diff-removed">-        let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div class="diff-added">+            2 * config.wal_config.wal_capacity_mb;</div><div class="diff-added">+        let disk_usage_watcher = crate::shards::local_shard::disk_usage_watcher::DiskUsageWatcher::new(</div><div>             shard_path.to_owned(),</div><div>             disk_buffer_threshold_mb,</div><div>         )</div><div class="diff-info">@@ -197,6 +178,7 @@ impl LocalShard {</div><div>             config.optimizer_config.max_optimization_threads,</div><div>             clocks.clone(),</div><div>             shard_path.into(),</div><div class="diff-added">+            disk_usage_watcher.clone(),</div><div>         );</div><div> </div><div>         let (update_sender, update_receiver) =</div><div class="diff-info">@@ -205,12 +187,11 @@ impl LocalShard {</div><div> </div><div>         let update_tracker = segment_holder.read().update_tracker();</div><div> </div><div class="diff-removed">-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .read_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(ParkingMutex::new)</div><div class="diff-removed">-        });</div><div class="diff-added">+        let read_rate_limiter = config</div><div class="diff-added">+            .strict_mode_config</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+            .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute))</div><div class="diff-added">+            .map(ParkingMutex::new);</div><div> </div><div>         drop(config); // release `shared_config` from borrow checker</div><div> </div><div class="diff-info">@@ -224,18 +205,18 @@ impl LocalShard {</div><div>             update_sender: ArcSwap::from_pointee(update_sender),</div><div>             update_tracker,</div><div>             path: shard_path.to_owned(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div>             optimizers,</div><div>             optimizers_log,</div><div>             total_optimized_points,</div><div class="diff-added">+            update_runtime,</div><div class="diff-added">+            search_runtime,</div><div>             disk_usage_watcher,</div><div>             read_rate_limiter,</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-added">+    pub(super) fn segments(&self) -> &LockedSegmentHolder {</div><div class="diff-added">+        &self.segments</div><div>     }</div><div> </div><div>     /// Recovers shard from disk.</div><div class="diff-info">@@ -247,7 +228,7 @@ impl LocalShard {</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div>         effective_optimizers_config: OptimizersConfig,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<crate::collection::payload_index_schema::PayloadIndexSchema>>,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-info">@@ -257,14 +238,13 @@ impl LocalShard {</div><div>         let wal_path = Self::wal_path(shard_path);</div><div>         let segments_path = Self::segments_path(shard_path);</div><div> </div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> = SerdeWal::new(</div><div class="diff-removed">-            wal_path.to_str().unwrap(),</div><div class="diff-removed">-            (&collection_config_read.wal_config).into(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;</div><div class="diff-added">+        let wal: SerdeWal<crate::operations::OperationWithClockTag> =</div><div class="diff-added">+            SerdeWal::new(</div><div class="diff-added">+                wal_path.to_str().unwrap(),</div><div class="diff-added">+                (&collection_config_read.wal_config).into(),</div><div class="diff-added">+            )</div><div class="diff-added">+            .map_err(|e| CollectionError::service_error(format!("Wal error: {e}")))?;</div><div> </div><div class="diff-removed">-        // Walk over segments directory and collect all directory entries now</div><div class="diff-removed">-        // Collect now and error early to prevent errors while we've already spawned load threads</div><div>         let segment_paths = std::fs::read_dir(&segments_path)</div><div>             .map_err(|err| {</div><div>                 CollectionError::service_error(format!(</div><div class="diff-info">@@ -279,7 +259,6 @@ impl LocalShard {</div><div>                 ))</div><div>             })?;</div><div> </div><div class="diff-removed">-        // Grab segment paths, filter out hidden entries and non-directories</div><div>         let segment_paths = segment_paths</div><div>             .into_iter()</div><div>             .filter(|entry| {</div><div class="diff-info">@@ -309,18 +288,12 @@ impl LocalShard {</div><div> </div><div>         let mut load_handlers = vec![];</div><div> </div><div class="diff-removed">-        // This semaphore is used to limit the number of threads that load segments concurrently.</div><div class="diff-removed">-        // Uncomment it if you need to debug segment loading.</div><div class="diff-removed">-        // let semaphore = Arc::new(parking_lot::Mutex::new(()));</div><div class="diff-removed">-</div><div>         for segment_path in segment_paths {</div><div>             let payload_index_schema = payload_index_schema.clone();</div><div class="diff-removed">-            // let semaphore_clone = semaphore.clone();</div><div>             load_handlers.push(</div><div>                 thread::Builder::new()</div><div>                     .name(format!("shard-load-{collection_id}-{id}"))</div><div>                     .spawn(move || {</div><div class="diff-removed">-                        // let _guard = semaphore_clone.lock();</div><div>                         let mut res = load_segment(&segment_path, &AtomicBool::new(false))?;</div><div>                         if let Some(segment) = &mut res {</div><div>                             segment.check_consistency_and_repair()?;</div><div class="diff-info">@@ -346,71 +319,36 @@ impl LocalShard {</div><div>             let segment = handler.join().map_err(|err| {</div><div>                 CollectionError::service_error(format!(</div><div>                     "Can't join segment load thread: {:?}",</div><div class="diff-removed">-                    err.type_id()</div><div class="diff-added">+                    err</div><div>                 ))</div><div>             })??;</div><div class="diff-removed">-</div><div class="diff-removed">-            let Some(segment) = segment else {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            collection_config_read</div><div class="diff-removed">-                .params</div><div class="diff-removed">-                .vectors</div><div class="diff-removed">-                .check_compatible_with_segment_config(&segment.config().vector_data, true)?;</div><div class="diff-removed">-            collection_config_read</div><div class="diff-removed">-                .params</div><div class="diff-removed">-                .sparse_vectors</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .map(|sparse_vectors| {</div><div class="diff-added">+            if let Some(segment) = segment {</div><div class="diff-added">+                collection_config_read</div><div class="diff-added">+                    .params</div><div class="diff-added">+                    .vectors</div><div class="diff-added">+                    .check_compatible_with_segment_config(</div><div class="diff-added">+                        &segment.config().vector_data,</div><div class="diff-added">+                        true,</div><div class="diff-added">+                    )?;</div><div class="diff-added">+                if let Some(sparse) = &collection_config_read.params.sparse_vectors {</div><div>                     check_sparse_compatible_with_segment_config(</div><div class="diff-removed">-                        sparse_vectors,</div><div class="diff-added">+                        sparse,</div><div>                         &segment.config().sparse_vector_data,</div><div>                         true,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .unwrap_or(Ok(()))?;</div><div class="diff-removed">-</div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-added">+                    )?;</div><div class="diff-added">+                }</div><div class="diff-added">+                segment_holder.add_new(segment);</div><div class="diff-added">+            }</div><div>         }</div><div> </div><div class="diff-removed">-        let res = segment_holder.deduplicate_points().await?;</div><div class="diff-removed">-        if res > 0 {</div><div class="diff-removed">-            log::debug!("Deduplicated {res} points");</div><div class="diff-added">+        let deduped = segment_holder.deduplicate_points().await?;</div><div class="diff-added">+        if deduped > 0 {</div><div class="diff-added">+            log::debug!("Deduplicated {deduped} points");</div><div>         }</div><div> </div><div>         clear_temp_segments(shard_path);</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &collection_config_read.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &collection_config_read.hnsw_config,</div><div class="diff-removed">-            &collection_config_read.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(collection_config_read); // release `shared_config` from borrow checker</div><div> </div><div>         let clocks = LocalShardClocks::load(shard_path)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Always make sure we have any appendable segments, needed for update operations</div><div class="diff-removed">-        if !segment_holder.has_appendable_segment() {</div><div class="diff-removed">-            debug_assert!(</div><div class="diff-removed">-                false,</div><div class="diff-removed">-                "Shard has no appendable segments, this should never happen",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            log::warn!(</div><div class="diff-removed">-                "Shard has no appendable segments, this should never happen. Creating new appendable segment now",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            let segments_path = LocalShard::segments_path(shard_path);</div><div class="diff-removed">-            let collection_params = collection_config.read().await.params.clone();</div><div class="diff-removed">-            let payload_index_schema = payload_index_schema.read();</div><div class="diff-removed">-            segment_holder.create_appendable_segment(</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                &collection_params,</div><div class="diff-removed">-                &payload_index_schema,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         let local_shard = LocalShard::new(</div><div>             segment_holder,</div><div>             collection_config,</div><div class="diff-info">@@ -418,17 +356,22 @@ impl LocalShard {</div><div>             payload_index_schema,</div><div>             wal,</div><div>             optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-added">+            effective_optimizers_config,</div><div>             shard_path,</div><div>             clocks,</div><div>             update_runtime,</div><div>             search_runtime,</div><div class="diff-added">+            optimizer_resource_budget,</div><div>         )</div><div>         .await;</div><div> </div><div class="diff-removed">-        // Apply outstanding operations from WAL</div><div class="diff-added">+        // Always apply WAL after snapshot loading</div><div>         local_shard.load_from_wal(collection_id).await?;</div><div> </div><div class="diff-added">+        // The storage is expected to be consistent after WAL recovery</div><div class="diff-added">+        #[cfg(feature = "data-consistency-check")]</div><div class="diff-added">+        local_shard.check_data_consistency()?;</div><div class="diff-added">+</div><div>         Ok(local_shard)</div><div>     }</div><div> </div><div class="diff-info">@@ -444,32 +387,186 @@ impl LocalShard {</div><div>         shard_path.join(SEGMENTS_PATH)</div><div>     }</div><div> </div><div class="diff-added">+    pub async fn recovery_point(&self) -> crate::wal_delta::RecoveryPoint {</div><div class="diff-added">+        self.wal.recovery_point().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Update the cutoff point on the current shard.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// This also updates the highest seen clocks.</div><div class="diff-added">+    pub async fn update_cutoff(&self, cutoff: &crate::wal_delta::RecoveryPoint) {</div><div class="diff-added">+        self.wal.update_cutoff(cutoff).await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Trigger optimizers explicitly.</div><div class="diff-added">+    pub fn trigger_optimizers(&self) {</div><div class="diff-added">+        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Finishes ongoing update tasks</div><div class="diff-added">+    pub async fn stop_gracefully(&self) {</div><div class="diff-added">+        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-added">+            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-added">+        }</div><div class="diff-added">+        self.stop_flush_worker().await;</div><div class="diff-added">+        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-added">+            log::warn!("Update workers failed with: {err}");</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Get segment manifests for partial snapshot recovery</div><div class="diff-added">+    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-added">+        self.segments.read().segment_manifests().map_err(CollectionError::from)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Check data consistency for all segments (optional feature)</div><div class="diff-added">+    #[cfg(feature = "data-consistency-check")]</div><div class="diff-added">+    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-added">+        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-added">+        for (_idx, segment) in self.segments.read().iter() {</div><div class="diff-added">+            match segment {</div><div class="diff-added">+                LockedSegment::Original(raw_segment) => {</div><div class="diff-added">+                    let guard = raw_segment.read();</div><div class="diff-added">+                    if let Err(e) = guard.check_data_consistency() {</div><div class="diff-added">+                        log::error!(</div><div class="diff-added">+                            "Segment {:?} is inconsistent: {e}",</div><div class="diff-added">+                            guard.current_path</div><div class="diff-added">+                        );</div><div class="diff-added">+                        return Err(e.into());</div><div class="diff-added">+                    }</div><div class="diff-added">+                }</div><div class="diff-added">+                LockedSegment::Proxy(_) => {</div><div class="diff-added">+                    return Err(CollectionError::service_error(</div><div class="diff-added">+                        "Proxy segment found in check_data_consistency",</div><div class="diff-added">+                    ));</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Loads latest collection operations from WAL</div><div class="diff-added">+    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div class="diff-added">+        let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-added">+        let mut wal = self.wal.wal.lock().await;</div><div class="diff-added">+        let bar = ProgressBar::new(wal.len(false));</div><div class="diff-added">+</div><div class="diff-added">+        let style = ProgressStyle::default_bar()</div><div class="diff-added">+            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")</div><div class="diff-added">+            .expect("Failed to create progress style");</div><div class="diff-added">+        bar.set_style(style);</div><div class="diff-added">+</div><div class="diff-added">+        log::debug!(</div><div class="diff-added">+            "Recovering shard {} starting reading WAL from {}",</div><div class="diff-added">+            self.path.display(),</div><div class="diff-added">+            wal.first_index()</div><div class="diff-added">+        );</div><div class="diff-added">+        bar.set_message(format!("Recovering collection {collection_id}"));</div><div class="diff-added">+</div><div class="diff-added">+        let show_progress = !bar.is_hidden();</div><div class="diff-added">+        let mut last_report = Instant::now();</div><div class="diff-added">+        if !show_progress {</div><div class="diff-added">+            log::info!(</div><div class="diff-added">+                "Recovering shard {}: 0/{} (0%)",</div><div class="diff-added">+                self.path.display(),</div><div class="diff-added">+                wal.len(false),</div><div class="diff-added">+            );</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        for (op_num, update) in wal.read_all(false) {</div><div class="diff-added">+            if let Some(clock_tag) = update.clock_tag {</div><div class="diff-added">+                newest_clocks.advance_clock(clock_tag);</div><div class="diff-added">+            }</div><div class="diff-added">+            match &CollectionUpdater::update(</div><div class="diff-added">+                &self.segments,</div><div class="diff-added">+                op_num,</div><div class="diff-added">+                update.operation.clone(),</div><div class="diff-added">+                &HardwareCounterCell::disposable()</div><div class="diff-added">+            ) {</div><div class="diff-added">+                Err(crate::operations::CollectionError::ServiceError { error, backtrace }) => {</div><div class="diff-added">+                    log::error!(</div><div class="diff-added">+                        "Can't apply WAL operation: {error}, \</div><div class="diff-added">+                        collection: {collection_id}, \</div><div class="diff-added">+                        shard: {path}, \</div><div class="diff-added">+                        op_num: {op_num}",</div><div class="diff-added">+                        path = self.path.display()</div><div class="diff-added">+                    );</div><div class="diff-added">+                    if let Some(bt) = backtrace {</div><div class="diff-added">+                        log::error!("Backtrace: {bt}");</div><div class="diff-added">+                    }</div><div class="diff-added">+                    return Err(crate::operations::CollectionError::ServiceError {</div><div class="diff-added">+                        error: error.clone(),</div><div class="diff-added">+                        backtrace: backtrace.clone(),</div><div class="diff-added">+                    });</div><div class="diff-added">+                }</div><div class="diff-added">+                Err(e) => {</div><div class="diff-added">+                    log::error!("{e}");</div><div class="diff-added">+                    return Err(e.clone());</div><div class="diff-added">+                }</div><div class="diff-added">+                Ok(_) => {}</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            bar.inc(1);</div><div class="diff-added">+            if !show_progress && last_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div class="diff-added">+                let pos = bar.position();</div><div class="diff-added">+                let total = wal.len(false);</div><div class="diff-added">+                log::info!(</div><div class="diff-added">+                    "{pos}/{total} ({}%)",</div><div class="diff-added">+                    (pos as f32 / total as f32 * 100.0) as usize</div><div class="diff-added">+                );</div><div class="diff-added">+                last_report = Instant::now();</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        {</div><div class="diff-added">+            let segments = self.segments.read();</div><div class="diff-added">+            for (_idx, segment) in segments.iter() {</div><div class="diff-added">+                if let LockedSegment::Original(raw) = segment {</div><div class="diff-added">+                    raw.write().cleanup_versions()?;</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+            // Force a flush after re-applying WAL operations</div><div class="diff-added">+            segments.flush_all(true, true)?;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        bar.finish();</div><div class="diff-added">+        if !show_progress {</div><div class="diff-added">+            log::info!(</div><div class="diff-added">+                "Recovered shard {}: {0}/{0} (100%)",</div><div class="diff-added">+                self.path.display(),</div><div class="diff-added">+                wal.len(false),</div><div class="diff-added">+            );</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Build local replica shard with config file</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn build_local(</div><div>         id: ShardId,</div><div>         collection_id: CollectionId,</div><div>         shard_path: &Path,</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<crate::collection::payload_index_schema::PayloadIndexSchema>>,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div>     ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        // initialize local shard config file</div><div>         let local_shard_config = ShardConfig::new_replica_set();</div><div>         let shard = Self::build(</div><div>             id,</div><div>             collection_id,</div><div>             shard_path,</div><div>             collection_config,</div><div class="diff-added">+            effective_optimizers_config,</div><div>             shared_storage_config,</div><div>             payload_index_schema,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            effective_optimizers_config,</div><div class="diff-added">+            update_runtime.clone(),</div><div class="diff-added">+            search_runtime.clone(),</div><div class="diff-added">+            optimizer_resource_budget.clone(),</div><div>         )</div><div>         .await?;</div><div>         local_shard_config.save(shard_path)?;</div><div class="diff-info">@@ -483,29 +580,23 @@ impl LocalShard {</div><div>         collection_id: CollectionId,</div><div>         shard_path: &Path,</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<crate::collection::payload_index_schema::PayloadIndexSchema>>,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div>     ) -> CollectionResult<LocalShard> {</div><div>         let config = collection_config.read().await;</div><div> </div><div>         let wal_path = Self::wal_path(shard_path);</div><div class="diff-removed">-</div><div>         create_dir_all(&wal_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard wal directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-added">+            CollectionError::service_error(format!("Can't create shard wal directory. Error: {err}"))</div><div>         })?;</div><div> </div><div>         let segments_path = Self::segments_path(shard_path);</div><div class="diff-removed">-</div><div>         create_dir_all(&segments_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard segments directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-added">+            CollectionError::service_error(format!("Can't create shard segments directory. Error: {err}"))</div><div>         })?;</div><div> </div><div>         let mut segment_holder = SegmentHolder::default();</div><div class="diff-info">@@ -515,39 +606,34 @@ impl LocalShard {</div><div>         let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div>         let segment_number = config.optimizer_config.get_number_segments();</div><div> </div><div class="diff-removed">-        for _sid in 0..segment_number {</div><div class="diff-added">+        for _ in 0..segment_number {</div><div>             let path_clone = segments_path.clone();</div><div class="diff-removed">-            let segment_config = SegmentConfig {</div><div class="diff-removed">-                vector_data: vector_params.clone(),</div><div class="diff-removed">-                sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-removed">-                payload_storage_type: config.params.payload_storage_type(),</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let segment = thread::Builder::new()</div><div class="diff-added">+            let schema = payload_index_schema.read().clone();</div><div class="diff-added">+            let params = config.params.clone();</div><div class="diff-added">+            let handler = thread::Builder::new()</div><div>                 .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            build_handlers.push(segment);</div><div class="diff-added">+                .spawn(move || {</div><div class="diff-added">+                    let seg = build_segment(&path_clone, &SegmentConfig {</div><div class="diff-added">+                        vector_data: vector_params.clone(),</div><div class="diff-added">+                        sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-added">+                        payload_storage_type: params.payload_storage_type(),</div><div class="diff-added">+                    }, true)?;</div><div class="diff-added">+                    seg.create_payload_indices(&schema)?;</div><div class="diff-added">+                    Ok(seg)</div><div class="diff-added">+                })?;</div><div class="diff-added">+            build_handlers.push(handler);</div><div>         }</div><div> </div><div class="diff-removed">-        let join_results = build_handlers</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|handler| handler.join())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for join_result in join_results {</div><div class="diff-removed">-            let segment = join_result.map_err(|err| {</div><div class="diff-added">+        for handler in build_handlers {</div><div class="diff-added">+            let segment = handler.join().map_err(|err| {</div><div>                 let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-removed">-                let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-removed">-</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Segment DB create panicked{separator}{message}",</div><div class="diff-removed">-                ))</div><div class="diff-added">+                let sep = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-added">+                CollectionError::service_error(format!("Segment DB create panicked{sep}{message}"))</div><div>             })??;</div><div class="diff-removed">-</div><div>             segment_holder.add_new(segment);</div><div>         }</div><div> </div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-added">+        let wal: SerdeWal<crate::operations::OperationWithClockTag> =</div><div>             SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div> </div><div>         let optimizers = build_optimizers(</div><div class="diff-info">@@ -560,573 +646,52 @@ impl LocalShard {</div><div> </div><div>         drop(config); // release `shared_config` from borrow checker</div><div> </div><div class="diff-removed">-        let collection = LocalShard::new(</div><div class="diff-added">+        Ok(LocalShard::new(</div><div>             segment_holder,</div><div>             collection_config,</div><div>             shared_storage_config,</div><div>             payload_index_schema,</div><div>             wal,</div><div>             optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-added">+            effective_optimizers_config,</div><div>             shard_path,</div><div>             LocalShardClocks::default(),</div><div>             update_runtime,</div><div>             search_runtime,</div><div class="diff-added">+            optimizer_resource_budget,</div><div>         )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(collection)</div><div class="diff-added">+        .await)</div><div>     }</div><div> </div><div>     pub async fn stop_flush_worker(&self) {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.stop_flush_worker()</div><div class="diff-added">+        let mut handler = self.update_handler.lock().await;</div><div class="diff-added">+        handler.stop_flush_worker();</div><div>     }</div><div> </div><div>     pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.wait_workers_stops().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Loads latest collection operations from WAL</div><div class="diff-removed">-    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-removed">-        let wal = self.wal.wal.lock().await;</div><div class="diff-removed">-        let bar = ProgressBar::new(wal.len(false));</div><div class="diff-removed">-</div><div class="diff-removed">-        let progress_style = ProgressStyle::default_bar()</div><div class="diff-removed">-            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")</div><div class="diff-removed">-            .expect("Failed to create progress style");</div><div class="diff-removed">-        bar.set_style(progress_style);</div><div class="diff-removed">-</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Recovering shard {} starting reading WAL from {}",</div><div class="diff-removed">-            self.path.display(),</div><div class="diff-removed">-            wal.first_index(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.set_message(format!("Recovering collection {collection_id}"));</div><div class="diff-removed">-        let segments = self.segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Fall back to basic text output if the progress bar is hidden (e.g. not a tty)</div><div class="diff-removed">-        let show_progress_bar = !bar.is_hidden();</div><div class="diff-removed">-        let mut last_progress_report = Instant::now();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovering shard {}: 0/{} (0%)",</div><div class="diff-removed">-                self.path.display(),</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div class="diff-removed">-        // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div class="diff-removed">-        // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div class="diff-removed">-        // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div class="diff-removed">-        // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div class="diff-removed">-        // index *occasionally*), but the storage can handle it.</div><div class="diff-removed">-</div><div class="diff-removed">-        for (op_num, update) in wal.read_all(false) {</div><div class="diff-removed">-            if let Some(clock_tag) = update.clock_tag {</div><div class="diff-removed">-                newest_clocks.advance_clock(clock_tag);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate `CollectionError::ServiceError`, but skip other error types.</div><div class="diff-removed">-            match &CollectionUpdater::update(</div><div class="diff-removed">-                segments,</div><div class="diff-removed">-                op_num,</div><div class="diff-removed">-                update.operation,</div><div class="diff-removed">-                &HardwareCounterCell::disposable(), // Internal operation, no measurement needed.</div><div class="diff-removed">-            ) {</div><div class="diff-removed">-                Err(err @ CollectionError::ServiceError { error, backtrace }) => {</div><div class="diff-removed">-                    let path = self.path.display();</div><div class="diff-removed">-</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Can't apply WAL operation: {error}, \</div><div class="diff-removed">-                         collection: {collection_id}, \</div><div class="diff-removed">-                         shard: {path}, \</div><div class="diff-removed">-                         op_num: {op_num}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-</div><div class="diff-removed">-                    if let Some(backtrace) = &backtrace {</div><div class="diff-removed">-                        log::error!("Backtrace: {backtrace}");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::OutOfMemory { .. }) => {</div><div class="diff-removed">-                    log::error!("{err}");</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),</div><div class="diff-removed">-                Err(err) => log::error!("{err}"),</div><div class="diff-removed">-                Ok(_) => (),</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Update progress bar or show text progress every WAL_LOAD_REPORT_EVERY</div><div class="diff-removed">-            bar.inc(1);</div><div class="diff-removed">-            if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div class="diff-removed">-                let progress = bar.position();</div><div class="diff-removed">-                log::info!(</div><div class="diff-removed">-                    "{progress}/{} ({}%)",</div><div class="diff-removed">-                    wal.len(false),</div><div class="diff-removed">-                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                last_progress_report = Instant::now();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // It is possible, that after recovery, if WAL flush was not enforced.</div><div class="diff-removed">-            // We could be left with some un-versioned points.</div><div class="diff-removed">-            // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                match segment {</div><div class="diff-removed">-                    LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                        raw_segment.write().cleanup_versions()?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                        debug_assert!(false, "Proxy segment found in load_from_wal");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-removed">-            // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-removed">-            // version.</div><div class="diff-removed">-            segments.flush_all(true, true)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.finish();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        // makes sure that the Stop signal is the last one in this channel</div><div class="diff-removed">-        let old_sender = self.update_sender.swap(Arc::new(update_sender));</div><div class="diff-removed">-        old_sender.send(UpdateSignal::Stop).await?;</div><div class="diff-removed">-        update_handler.stop_flush_worker();</div><div class="diff-removed">-</div><div class="diff-removed">-        update_handler.wait_workers_stops().await?;</div><div class="diff-removed">-        let new_optimizers = build_optimizers(</div><div class="diff-removed">-            &self.path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &config.optimizer_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        update_handler.optimizers = new_optimizers;</div><div class="diff-removed">-        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div class="diff-removed">-        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-added">+        let mut handler = self.update_handler.lock().await;</div><div class="diff-added">+        handler.wait_workers_stops().await</div><div>     }</div><div> </div><div>     /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div>     pub async fn on_strict_mode_config_update(&mut self) {</div><div>         let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div>         if let Some(strict_mode_config) = &config.strict_mode_config {</div><div>             if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update read rate limiter</div><div class="diff-removed">-                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-removed">-                    let new_read_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-removed">-                    self.read_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-added">+                if let Some(limit) = strict_mode_config.read_rate_limit {</div><div class="diff-added">+                    let limiter = RateLimiter::new_per_minute(limit);</div><div class="diff-added">+                    self.read_rate_limiter.replace(ParkingMutex::new(limiter));</div><div>                     return;</div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-removed">-        // remove read rate limiter for all other situations</div><div>         self.read_rate_limiter.take();</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn trigger_optimizers(&self) {</div><div class="diff-removed">-        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-removed">-        // - If receiver is already dead - we do not care</div><div class="diff-removed">-        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Finishes ongoing update tasks</div><div class="diff-removed">-    pub async fn stop_gracefully(&self) {</div><div class="diff-removed">-        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-removed">-            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.stop_flush_worker().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-removed">-            log::warn!("Update workers failed with: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div class="diff-removed">-        // Read dir first as the directory contents would change during restore</div><div class="diff-removed">-        let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Filter out hidden entries</div><div class="diff-removed">-        let entries = entries.into_iter().filter(|entry| {</div><div class="diff-removed">-            let is_hidden = entry</div><div class="diff-removed">-                .file_name()</div><div class="diff-removed">-                .to_str()</div><div class="diff-removed">-                .is_some_and(|s| s.starts_with('.'));</div><div class="diff-removed">-            if is_hidden {</div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Ignoring hidden segment in local shard during snapshot recovery: {}",</div><div class="diff-removed">-                    entry.path().display(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-            !is_hidden</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        for entry in entries {</div><div class="diff-removed">-            Segment::restore_snapshot_in_place(&entry.path())?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div class="diff-removed">-    pub async fn create_snapshot(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-        format: SnapshotFormat,</div><div class="diff-removed">-        save_wal: bool,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        let wal = self.wal.wal.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if !save_wal {</div><div class="diff-removed">-            // If we are not saving WAL, we still need to make sure that all submitted by this point</div><div class="diff-removed">-            // updates have made it to the segments. So we use the Plunger to achieve that.</div><div class="diff-removed">-            // It will notify us when all submitted updates so far have been processed.</div><div class="diff-removed">-            let (tx, rx) = oneshot::channel();</div><div class="diff-removed">-            let plunger = UpdateSignal::Plunger(tx);</div><div class="diff-removed">-            self.update_sender.load().send(plunger).await?;</div><div class="diff-removed">-            rx.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(&self.path);</div><div class="diff-removed">-        let collection_params = self.collection_config.read().await.params.clone();</div><div class="diff-removed">-        let temp_path = temp_path.to_owned();</div><div class="diff-removed">-        let payload_index_schema = self.payload_index_schema.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar_c = tar.clone();</div><div class="diff-removed">-        tokio::task::spawn_blocking(move || {</div><div class="diff-removed">-            // Do not change segments while snapshotting</div><div class="diff-removed">-            SegmentHolder::snapshot_all_segments(</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                Some(&collection_params),</div><div class="diff-removed">-                &payload_index_schema.read().clone(),</div><div class="diff-removed">-                &temp_path,</div><div class="diff-removed">-                &tar_c.descend(Path::new(SEGMENTS_PATH))?,</div><div class="diff-removed">-                format,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if save_wal {</div><div class="diff-removed">-                // snapshot all shard's WAL</div><div class="diff-removed">-                Self::snapshot_wal(wal, &tar_c)</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                Self::snapshot_empty_wal(wal, &temp_path, &tar_c)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .await??;</div><div class="diff-removed">-</div><div class="diff-removed">-        LocalShardClocks::archive_data(&self.path, tar).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create empty WAL which is compatible with currently stored data</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_empty_wal(</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let (segment_capacity, latest_op_num) = {</div><div class="diff-removed">-            let wal_guard = wal.blocking_lock();</div><div class="diff-removed">-            (wal_guard.segment_capacity(), wal_guard.last_index())</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = tempfile::tempdir_in(temp_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can not create temporary directory for WAL: {err}",</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Wal::generate_empty_wal_starting_at_index(</div><div class="diff-removed">-            temp_dir.path(),</div><div class="diff-removed">-            &WalOptions {</div><div class="diff-removed">-                segment_capacity,</div><div class="diff-removed">-                segment_queue_len: 0,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            latest_op_num,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Error while create empty WAL: {err}"))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-            })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// snapshot WAL</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        // lock wal during snapshot</div><div class="diff-removed">-        let mut wal_guard = wal.blocking_lock();</div><div class="diff-removed">-        wal_guard.flush()?;</div><div class="diff-removed">-        let source_wal_path = wal_guard.path();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar = tar.descend(Path::new(WAL_PATH))?;</div><div class="diff-removed">-        for entry in std::fs::read_dir(source_wal_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-        })? {</div><div class="diff-removed">-            let entry = entry.map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if entry.file_name() == ".wal" {</div><div class="diff-removed">-                // This sentinel file is used for WAL locking. Trying to archive</div><div class="diff-removed">-                // or open it will cause the following error on Windows:</div><div class="diff-removed">-                // > The process cannot access the file because another process</div><div class="diff-removed">-                // > has locked a portion of the file. (os error 33)</div><div class="diff-removed">-                // https://github.com/qdrant/wal/blob/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual)::new(&entry.file_name()))</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-removed">-        self.segments()</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .segment_manifests()</div><div class="diff-removed">-            .map_err(CollectionError::from)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn estimate_cardinality<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CollectionResult<CardinalityEstimation> {</div><div class="diff-removed">-        let segments = self.segments().read();</div><div class="diff-removed">-        let cardinality = segments</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_id, segment)| {</div><div class="diff-removed">-                segment</div><div class="diff-removed">-                    .get()</div><div class="diff-removed">-                    .read()</div><div class="diff-removed">-                    .estimate_point_count(filter, hw_counter)</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .fold(CardinalityEstimation::exact(0), |acc, x| {</div><div class="diff-removed">-                CardinalityEstimation {</div><div class="diff-removed">-                    primary_clauses: vec![],</div><div class="diff-removed">-                    min: acc.min + x.min,</div><div class="diff-removed">-                    exp: acc.exp + x.exp,</div><div class="diff-removed">-                    max: acc.max + x.max,</div><div class="diff-removed">-                }</div><div class="diff-removed">-            });</div><div class="diff-removed">-        Ok(cardinality)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn read_filtered<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_counter: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Red status on failed operation or optimizer error</div><div class="diff-removed">-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {</div><div class="diff-removed">-                let optimizer_status = segments</div><div class="diff-removed">-                    .optimizer_errors</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .map_or(OptimizersStatus::Ok, |err| {</div><div class="diff-removed">-                        OptimizersStatus::Error(err.to_string())</div><div class="diff-removed">-                    });</div><div class="diff-removed">-                return (ShardStatus::Red, optimizer_status);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Yellow status if we have a special segment, indicates a proxy segment used during optimization</div><div class="diff-removed">-            // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div class="diff-removed">-            let has_special_segment = segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-removed">-                .any(|segment_type| segment_type == SegmentType::Special);</div><div class="diff-removed">-            if has_special_segment {</div><div class="diff-removed">-                return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Yellow or grey status if there are pending optimizations</div><div class="diff-removed">-        // Grey if optimizers were not triggered yet after restart,</div><div class="diff-removed">-        // we don't automatically trigger them to prevent a crash loop</div><div class="diff-removed">-        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self</div><div class="diff-removed">-            .update_handler</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .check_optimizer_conditions();</div><div class="diff-removed">-        if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-removed">-                ShardStatus::Yellow</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                ShardStatus::Grey</div><div class="diff-removed">-            };</div><div class="diff-removed">-            return (status, OptimizersStatus::Ok);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Green status because everything is fine</div><div class="diff-removed">-        (ShardStatus::Green, OptimizersStatus::Ok)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_info(&self) -> ShardInfoInternal {</div><div class="diff-removed">-        let collection_config = self.collection_config.read().await.clone();</div><div class="diff-removed">-        let mut vectors_count = 0;</div><div class="diff-removed">-        let mut indexed_vectors_count = 0;</div><div class="diff-removed">-        let mut points_count = 0;</div><div class="diff-removed">-        let mut segments_count = 0;</div><div class="diff-removed">-        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                segments_count += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_info = segment.get().read().info();</div><div class="diff-removed">-</div><div class="diff-removed">-                vectors_count += segment_info.num_vectors;</div><div class="diff-removed">-                indexed_vectors_count += segment_info.num_indexed_vectors;</div><div class="diff-removed">-                points_count += segment_info.num_points;</div><div class="diff-removed">-                for (key, val) in segment_info.index_schema {</div><div class="diff-removed">-                    schema</div><div class="diff-removed">-                        .entry(key)</div><div class="diff-removed">-                        .and_modify(|entry| entry.points += val.points)</div><div class="diff-removed">-                        .or_insert(val);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let (status, optimizer_status) = self.local_shard_status().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        ShardInfoInternal {</div><div class="diff-removed">-            status,</div><div class="diff-removed">-            optimizer_status,</div><div class="diff-removed">-            vectors_count,</div><div class="diff-removed">-            indexed_vectors_count,</div><div class="diff-removed">-            points_count,</div><div class="diff-removed">-            segments_count,</div><div class="diff-removed">-            config: collection_config,</div><div class="diff-removed">-            payload_schema: schema,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Check if the read rate limiter allows the operation to proceed</div><div>     /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-added">+    /// - context: the context of the operation for logging</div><div class="diff-added">+    /// - cost_fn: lazily computed cost for rate limiting</div><div>     ///</div><div>     /// Returns an error if the rate limit is exceeded.</div><div>     fn check_read_rate_limiter<F>(</div><div class="diff-info">@@ -1138,7 +703,6 @@ impl LocalShard {</div><div>     where</div><div>         F: FnOnce() -> usize,</div><div>     {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div>         if hw_measurement_acc.is_disposable() {</div><div>             return Ok(());</div><div>         }</div><div class="diff-info">@@ -1158,117 +722,96 @@ impl LocalShard {</div><div> </div><div> impl Drop for LocalShard {</div><div>     fn drop(&mut self) {</div><div class="diff-removed">-        thread::scope(|s| {</div><div class="diff-added">+        std::thread::scope(|s| {</div><div>             let handle = thread::Builder::new()</div><div>                 .name("drop-shard".to_string())</div><div>                 .spawn_scoped(s, || {</div><div class="diff-removed">-                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.</div><div>                     self.update_runtime</div><div>                         .block_on(async { self.stop_gracefully().await })</div><div>                 });</div><div>             handle.expect("Failed to create thread for shard drop");</div><div class="diff-removed">-        })</div><div class="diff-added">+        });</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-/// Convenience struct for combining clock maps belonging to a shard</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Holds a clock map for tracking the highest clocks and the cutoff clocks.</div><div class="diff-added">+/// Combination of newest and oldest clock maps for a shard</div><div> #[derive(Clone, Debug, Default)]</div><div> pub struct LocalShardClocks {</div><div class="diff-removed">-    newest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-removed">-    oldest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-added">+    newest_clocks: Arc<Mutex<crate::clock_map::ClockMap>>,</div><div class="diff-added">+    oldest_clocks: Arc<Mutex<crate::clock_map::ClockMap>>,</div><div> }</div><div> </div><div> impl LocalShardClocks {</div><div class="diff-removed">-    fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {</div><div class="diff-added">+    pub fn default() -> Self {</div><div class="diff-added">+        Self::new(crate::clock_map::ClockMap::default(), crate::clock_map::ClockMap::default())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn new(newest: crate::clock_map::ClockMap, oldest: crate::clock_map::ClockMap) -> Self {</div><div>         Self {</div><div class="diff-removed">-            newest_clocks: Arc::new(Mutex::new(newest_clocks)),</div><div class="diff-removed">-            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),</div><div class="diff-added">+            newest_clocks: Arc::new(Mutex::new(newest)),</div><div class="diff-added">+            oldest_clocks: Arc::new(Mutex::new(oldest)),</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    // Load clock maps from disk</div><div>     pub fn load(shard_path: &Path) -> CollectionResult<Self> {</div><div class="diff-removed">-        let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let oldest_clocks = ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(Self::new(newest_clocks, oldest_clocks))</div><div class="diff-added">+        let newest = crate::clock_map::ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-added">+        let oldest = crate::clock_map::ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-added">+        Ok(Self::new(newest, oldest))</div><div>     }</div><div> </div><div class="diff-removed">-    /// Persist clock maps to disk</div><div>     pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {</div><div>         self.oldest_clocks</div><div>             .lock()</div><div>             .await</div><div>             .store_if_changed(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div>         self.newest_clocks</div><div>             .lock()</div><div>             .await</div><div>             .store_if_changed(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Put clock data from the disk into an archive.</div><div class="diff-removed">-    pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&newest_clocks_from, Path::new(NEWEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-added">+    pub async fn copy_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div class="diff-added">+        let newest_from = Self::newest_clocks_path(from);</div><div class="diff-added">+        let oldest_from = Self::oldest_clocks_path(from);</div><div class="diff-added">+        if newest_from.exists() {</div><div class="diff-added">+            tar_ext::BuilderExt::append_file(&newest_from, Path::new(WAL_PATH))?;</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&oldest_clocks_from, Path::new(OLDEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-added">+        if oldest_from.exists() {</div><div class="diff-added">+            tar_ext::BuilderExt::append_file(&oldest_from, Path::new(SEGMENTS_PATH))?;</div><div>         }</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Move clock data on disk from one shard path to another.</div><div>     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            let newest_clocks_to = Self::newest_clocks_path(to);</div><div class="diff-removed">-            move_file(newest_clocks_from, newest_clocks_to).await?;</div><div class="diff-added">+        let newest_from = Self::newest_clocks_path(from);</div><div class="diff-added">+        let oldest_from = Self::oldest_clocks_path(from);</div><div class="diff-added">+        if newest_from.exists() {</div><div class="diff-added">+            move_file(&newest_from, &Self::newest_clocks_path(to)).await?;</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            let oldest_clocks_to = Self::oldest_clocks_path(to);</div><div class="diff-removed">-            move_file(oldest_clocks_from, oldest_clocks_to).await?;</div><div class="diff-added">+        if oldest_from.exists() {</div><div class="diff-added">+            move_file(&oldest_from, &Self::oldest_clocks_path(to)).await?;</div><div>         }</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Delete clock data from disk at the given shard path.</div><div>     pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_path = Self::newest_clocks_path(shard_path);</div><div class="diff-removed">-        let oldest_clocks_path = Self::oldest_clocks_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(newest_clocks_path).await?;</div><div class="diff-added">+        let newest = Self::newest_clocks_path(shard_path);</div><div class="diff-added">+        let oldest = Self::oldest_clocks_path(shard_path);</div><div class="diff-added">+        if newest.exists() {</div><div class="diff-added">+            remove_file(&newest).await?;</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(oldest_clocks_path).await?;</div><div class="diff-added">+        if oldest.exists() {</div><div class="diff-added">+            remove_file(&oldest).await?;</div><div>         }</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div>     fn newest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(NEWEST_CLOCKS_PATH)</div><div class="diff-added">+        shard_path.join("newest_clocks.json")</div><div>     }</div><div> </div><div>     fn oldest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(OLDEST_CLOCKS_PATH)</div><div class="diff-added">+        shard_path.join("oldest_clocks.json")</div><div>     }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    