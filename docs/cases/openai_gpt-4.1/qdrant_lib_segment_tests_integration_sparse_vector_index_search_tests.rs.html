<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs - GPT-4.1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs</h1>
        <p><a href="../../models/openai_gpt-4.1.html">‚Üê Back to GPT-4.1 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT-4.1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56319</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 56728</p>
                <p><strong>Native Completion Tokens:</strong> 6208</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.008156</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 1e234a3f..341f8e5f 100644</div><div class="diff-header">--- a/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_expectedoutput.txt (expected):tmp/tmpnwocpmis_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_extracted.txt (actual):tmp/tmptimeja07_actual.txt	</div><div class="diff-info">@@ -1,4 +1,3 @@</div><div class="diff-removed">-use std::cmp::max;</div><div> use std::collections::HashMap;</div><div> use std::fs::remove_file;</div><div> use std::sync::atomic::AtomicBool;</div><div class="diff-info">@@ -35,10 +34,10 @@ use segment::{fixture_for_all_indices, payload_json};</div><div> use sparse::common::sparse_vector::SparseVector;</div><div> use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};</div><div> use sparse::common::types::DimId;</div><div class="diff-removed">-use sparse::index::inverted_index::InvertedIndex;</div><div> use sparse::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;</div><div> use sparse::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;</div><div> use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div class="diff-added">+use sparse::index::inverted_index::InvertedIndex;</div><div> use sparse::index::posting_list_common::PostingListIter as _;</div><div> use tempfile::Builder;</div><div> </div><div class="diff-info">@@ -88,7 +87,7 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div>     for query in query_vectors {</div><div>         let maximum_number_of_results = sparse_vector_index.max_result_count(&query);</div><div>         // get all results minus 10 to force a bit of pruning</div><div class="diff-removed">-        let top = max(1, maximum_number_of_results.saturating_sub(10));</div><div class="diff-added">+        let top = std::cmp::max(1, maximum_number_of_results.saturating_sub(10));</div><div>         let query_vector: QueryVector = query.clone().into();</div><div>         // with filter</div><div>         let index_results_filter = sparse_vector_index</div><div class="diff-info">@@ -102,15 +101,14 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div>             .unwrap();</div><div> </div><div>         // without filter</div><div class="diff-removed">-        let index_results_no_filter = sparse_vector_index</div><div class="diff-removed">-            .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-added">+        let index_results_no_filter =</div><div class="diff-added">+            sparse_vector_index.search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-added">+                .unwrap();</div><div> </div><div>         assert_eq!(index_results_filter.len(), index_results_no_filter.len());</div><div> </div><div class="diff-removed">-        for (filter_result, no_filter_result) in index_results_filter</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .zip(index_results_no_filter.iter())</div><div class="diff-added">+        for (filter_result, no_filter_result) in</div><div class="diff-added">+            index_results_filter.iter().zip(index_results_no_filter.iter())</div><div>         {</div><div>             assert_eq!(</div><div>                 filter_result.len(),</div><div class="diff-info">@@ -134,19 +132,18 @@ fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize)</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_ram_filter_search() {</div><div class="diff-removed">-    // very low full scan threshold to force usage of inverted index</div><div class="diff-removed">-    compare_sparse_vectors_search_with_without_filter(LOW_FULL_SCAN_THRESHOLD);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> #[test]</div><div> fn sparse_vector_index_fallback_plain_search() {</div><div>     // very high full scan threshold to force fallback to plain search</div><div>     compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);</div><div> }</div><div> </div><div class="diff-removed">-/// Checks that the sparse vector index is consistent with the underlying storage</div><div class="diff-added">+#[test]</div><div class="diff-added">+fn sparse_vector_index_ram_filter_search() {</div><div class="diff-added">+    // very low full scan threshold to force usage of inverted index</div><div class="diff-added">+    compare_sparse_vectors_search_with_without_filter(LOW_FULL_SCAN_THRESHOLD);</div><div class="diff-added">+}</div><div class="diff-added">+</div><div> #[cfg(test)]</div><div> fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {</div><div>     let borrowed_vector_storage = sparse_vector_index.vector_storage().borrow();</div><div class="diff-info">@@ -187,9 +184,9 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars</div><div>         // check the vector can be found via search using large top</div><div>         let top = sparse_vector_index.max_result_count(vector);</div><div>         let query_vector: QueryVector = vector.to_owned().into();</div><div class="diff-removed">-        let results = sparse_vector_index</div><div class="diff-removed">-            .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-added">+        let results =</div><div class="diff-added">+            sparse_vector_index.search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-added">+                .unwrap();</div><div>         assert!(results[0].iter().any(|s| s.idx == id));</div><div>     }</div><div> }</div><div class="diff-info">@@ -197,7 +194,7 @@ fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &Spars</div><div> #[test]</div><div> fn sparse_vector_index_consistent_with_storage() {</div><div>     let stopped = AtomicBool::new(false);</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div>     let sparse_vector_ram_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div class="diff-info">@@ -281,7 +278,7 @@ fn sparse_vector_index_load_missing_mmap() {</div><div> #[test]</div><div> fn sparse_vector_index_ram_deleted_points_search() {</div><div>     let top = 10;</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div> </div><div class="diff-info">@@ -358,7 +355,7 @@ fn sparse_vector_index_ram_deleted_points_search() {</div><div> </div><div> #[test]</div><div> fn sparse_vector_index_ram_filtered_search() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div> </div><div class="diff-info">@@ -450,7 +447,7 @@ fn sparse_vector_index_ram_filtered_search() {</div><div> </div><div> #[test]</div><div> fn sparse_vector_index_plain_search() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div>     // setup index</div><div class="diff-info">@@ -526,7 +523,7 @@ fn sparse_vector_index_plain_search() {</div><div> </div><div> #[test]</div><div> fn handling_empty_sparse_vectors() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div>     let sparse_vector_index: SparseVectorIndex<InvertedIndexCompressedImmutableRam<f32>> =</div><div class="diff-info">@@ -564,21 +561,18 @@ fn handling_empty_sparse_vectors() {</div><div>     let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();</div><div> </div><div>     // empty vectors are not searchable (recommend using scroll API to retrieve those)</div><div class="diff-removed">-    let results = sparse_vector_index</div><div class="diff-removed">-        .search(&[&query_vector], None, 10, None, &Default::default())</div><div class="diff-removed">-        .unwrap();</div><div class="diff-added">+    let results =</div><div class="diff-added">+        sparse_vector_index.search(&[&query_vector], None, 10, None, &Default::default()).unwrap();</div><div>     assert_eq!(results.len(), 1);</div><div>     assert_eq!(results[0].len(), 0);</div><div> }</div><div> </div><div> #[test]</div><div> fn sparse_vector_index_persistence_test() {</div><div class="diff-removed">-    let stopped = AtomicBool::new(false);</div><div class="diff-removed">-</div><div>     let dim = 8;</div><div>     let num_vectors: u64 = 5_000;</div><div>     let top = 3;</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+    let mut rnd = StdRng::seed_from_u64(43);</div><div> </div><div>     let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div> </div><div class="diff-info">@@ -632,9 +626,7 @@ fn sparse_vector_index_persistence_test() {</div><div>     let path = segment.current_path.clone();</div><div>     drop(segment);</div><div> </div><div class="diff-removed">-    // persistence using rebuild of inverted index</div><div class="diff-removed">-    // for appendable segment vector index has to be rebuilt</div><div class="diff-removed">-    let segment = load_segment(&path, &stopped).unwrap().unwrap();</div><div class="diff-added">+    let segment = load_segment(&path, &AtomicBool::new(false)).unwrap().unwrap();</div><div>     let search_after_reload_result = segment</div><div>         .search(</div><div>             SPARSE_VECTOR_NAME,</div><div class="diff-info">@@ -690,25 +682,6 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div>         .unwrap()</div><div>     };</div><div> </div><div class="diff-removed">-    let check_search = |sparse_vector_index: &SparseVectorIndex<TInvertedIndex>| {</div><div class="diff-removed">-        // check that the loaded index performs the same search</div><div class="diff-removed">-        let search_after_reload_result = sparse_vector_index</div><div class="diff-removed">-            .search(&[query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert_eq!(search_after_reload_result[0].len(), top);</div><div class="diff-removed">-        for (search_1, search_2) in search_result</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .zip(search_after_reload_result[0].iter())</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let id_1 = segment</div><div class="diff-removed">-                .id_tracker</div><div class="diff-removed">-                .borrow_mut()</div><div class="diff-removed">-                .internal_id(search_1.id)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            assert_eq!(id_1, search_2.idx);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div>     let sparse_vector_index = open_index();</div><div> </div><div>     let version_file = inverted_index_dir.path().join(VERSION_FILE);</div><div class="diff-info">@@ -717,14 +690,46 @@ fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div>     // reload sparse index from file</div><div>     drop(sparse_vector_index);</div><div>     let sparse_vector_index = open_index();</div><div class="diff-removed">-    check_search(&sparse_vector_index);</div><div class="diff-added">+</div><div class="diff-added">+    // check search</div><div class="diff-added">+    let search_after_reload_result = sparse_vector_index</div><div class="diff-added">+        .search(&[query_vector], None, top, None, &Default::default())</div><div class="diff-added">+        .unwrap();</div><div class="diff-added">+    assert_eq!(search_after_reload_result[0].len(), top);</div><div class="diff-added">+    for (search_1, search_2) in search_result</div><div class="diff-added">+        .iter()</div><div class="diff-added">+        .zip(search_after_reload_result[0].iter())</div><div class="diff-added">+    {</div><div class="diff-added">+        let id_1 = segment</div><div class="diff-added">+            .id_tracker</div><div class="diff-added">+            .borrow_mut()</div><div class="diff-added">+            .internal_id(search_1.id)</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+        assert_eq!(id_1, search_2.idx);</div><div class="diff-added">+    }</div><div> </div><div>     // drop version file and reload index</div><div>     drop(sparse_vector_index);</div><div>     remove_file(&version_file).unwrap();</div><div>     let sparse_vector_index = open_index();</div><div>     assert!(version_file.exists(), "version file should be recreated");</div><div class="diff-removed">-    check_search(&sparse_vector_index);</div><div class="diff-added">+</div><div class="diff-added">+    // check search</div><div class="diff-added">+    let search_after_reload_result = sparse_vector_index</div><div class="diff-added">+        .search(&[query_vector], None, top, None, &Default::default())</div><div class="diff-added">+        .unwrap();</div><div class="diff-added">+    assert_eq!(search_after_reload_result[0].len(), top);</div><div class="diff-added">+    for (search_1, search_2) in search_result</div><div class="diff-added">+        .iter()</div><div class="diff-added">+        .zip(search_after_reload_result[0].iter())</div><div class="diff-added">+    {</div><div class="diff-added">+        let id_1 = segment</div><div class="diff-added">+            .id_tracker</div><div class="diff-added">+            .borrow_mut()</div><div class="diff-added">+            .internal_id(search_1.id)</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+        assert_eq!(id_1, search_2.idx);</div><div class="diff-added">+    }</div><div> }</div><div> </div><div> #[test]</div><div class="diff-info">@@ -735,7 +740,7 @@ fn sparse_vector_index_files() {</div><div> fn check_sparse_vector_index_files<I: InvertedIndex>() {</div><div>     let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div>     let index = fixture_sparse_index::<I, _>(</div><div class="diff-removed">-        &mut StdRng::seed_from_u64(42),</div><div class="diff-added">+        &mut StdRng::seed_from_u64(43),</div><div>         1,</div><div>         MAX_SPARSE_DIM,</div><div>         LOW_FULL_SCAN_THRESHOLD,</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    