<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <p><a href="../../models/openai_o3.html">‚Üê Back to o3 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 58515</p>
                <p><strong>Native Completion Tokens:</strong> 9674</p>
                <p><strong>Native Tokens Reasoning:</strong> 2560</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $1.0207155</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b..c3c196dc 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmp5zu3r3kh_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmptoosdc3__actual.txt	</div><div class="diff-info">@@ -36,7 +36,9 @@ use crate::common::is_ready::IsReady;</div><div> use crate::config::CollectionConfigInternal;</div><div> use crate::operations::config_diff::{DiffConfig, OptimizersConfigDiff};</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div class="diff-removed">-use crate::operations::types::{CollectionError, CollectionResult, NodeType, OptimizersStatus};</div><div class="diff-added">+use crate::operations::types::{</div><div class="diff-added">+    CollectionError, CollectionResult, NodeType, OptimizersStatus,</div><div class="diff-added">+};</div><div> use crate::optimizers_builder::OptimizersConfig;</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::channel_service::ChannelService;</div><div class="diff-info">@@ -46,34 +48,39 @@ use crate::shards::replica_set::ReplicaState::{Active, Dead, Initializing, Liste</div><div> use crate::shards::replica_set::{</div><div>     ChangePeerFromState, ChangePeerState, ReplicaState, ShardReplicaSet,</div><div> };</div><div class="diff-added">+use crate::shards::resharding::ReshardKey;</div><div> use crate::shards::shard::{PeerId, ShardId};</div><div class="diff-removed">-use crate::shards::shard_holder::shard_mapping::ShardKeyMapping;</div><div class="diff-removed">-use crate::shards::shard_holder::{LockedShardHolder, ShardHolder, shard_not_found_error};</div><div class="diff-added">+use crate::shards::shard_holder::{</div><div class="diff-added">+    shard_not_found_error,</div><div class="diff-added">+    shard_mapping::ShardKeyMapping,</div><div class="diff-added">+    LockedShardHolder,</div><div class="diff-added">+    ShardHolder,</div><div class="diff-added">+};</div><div> use crate::shards::transfer::helpers::check_transfer_conflicts_strict;</div><div> use crate::shards::transfer::transfer_tasks_pool::{TaskResult, TransferTasksPool};</div><div> use crate::shards::transfer::{ShardTransfer, ShardTransferMethod};</div><div class="diff-removed">-use crate::shards::{CollectionId, replica_set};</div><div class="diff-added">+use crate::shards::{replica_set, CollectionId};</div><div> use crate::telemetry::{</div><div>     CollectionConfigTelemetry, CollectionTelemetry, CollectionsAggregatedTelemetry,</div><div> };</div><div> </div><div> /// Collection's data is split into several shards.</div><div> pub struct Collection {</div><div class="diff-removed">-    pub(crate) id: CollectionId,</div><div class="diff-added">+    pub(crate) id:            CollectionId,</div><div>     pub(crate) shards_holder: Arc<LockedShardHolder>,</div><div>     pub(crate) collection_config: Arc<RwLock<CollectionConfigInternal>>,</div><div>     pub(crate) shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-    payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-    optimizers_overwrite: Option<OptimizersConfigDiff>,</div><div class="diff-removed">-    this_peer_id: PeerId,</div><div class="diff-removed">-    path: PathBuf,</div><div class="diff-removed">-    snapshots_path: PathBuf,</div><div class="diff-removed">-    channel_service: ChannelService,</div><div class="diff-removed">-    transfer_tasks: Mutex<TransferTasksPool>,</div><div class="diff-added">+    payload_index_schema:     Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+    optimizers_overwrite:     Option<OptimizersConfigDiff>,</div><div class="diff-added">+    this_peer_id:             PeerId,</div><div class="diff-added">+    path:                     PathBuf,</div><div class="diff-added">+    snapshots_path:           PathBuf,</div><div class="diff-added">+    channel_service:          ChannelService,</div><div class="diff-added">+    transfer_tasks:           Mutex<TransferTasksPool>,</div><div>     request_shard_transfer_cb: RequestShardTransfer,</div><div class="diff-removed">-    notify_peer_failure_cb: ChangePeerFromState,</div><div class="diff-removed">-    abort_shard_transfer_cb: replica_set::AbortShardTransfer,</div><div class="diff-removed">-    init_time: Duration,</div><div class="diff-added">+    notify_peer_failure_cb:   ChangePeerFromState,</div><div class="diff-added">+    abort_shard_transfer_cb:  replica_set::AbortShardTransfer,</div><div class="diff-added">+    init_time:                Duration,</div><div>     // One-way boolean flag that is set to true when the collection is fully initialized</div><div>     // i.e. all shards are activated for the first time.</div><div>     is_initialized: Arc<IsReady>,</div><div class="diff-info">@@ -128,7 +135,8 @@ impl Collection {</div><div>         for (shard_id, mut peers) in shard_distribution.shards {</div><div>             let is_local = peers.remove(&this_peer_id);</div><div> </div><div class="diff-removed">-            let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-added">+            let mut effective_optimizers_config =</div><div class="diff-added">+                collection_config.optimizer_config.clone();</div><div>             if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div>                 effective_optimizers_config =</div><div>                     optimizers_overwrite.update(&effective_optimizers_config)?;</div><div class="diff-info">@@ -173,20 +181,20 @@ impl Collection {</div><div>         collection_config.save(path)?;</div><div> </div><div>         Ok(Self {</div><div class="diff-removed">-            id: name.clone(),</div><div class="diff-removed">-            shards_holder: locked_shard_holder,</div><div class="diff-removed">-            collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-added">+            id:                    name.clone(),</div><div class="diff-added">+            shards_holder:         locked_shard_holder,</div><div class="diff-added">+            collection_config:     shared_collection_config,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div class="diff-removed">-            path: path.to_owned(),</div><div class="diff-removed">-            snapshots_path: snapshots_path.to_owned(),</div><div class="diff-added">+            path:                  path.to_owned(),</div><div class="diff-added">+            snapshots_path:        snapshots_path.to_owned(),</div><div>             channel_service,</div><div class="diff-removed">-            transfer_tasks: Mutex::new(TransferTasksPool::new(name.clone())),</div><div class="diff-added">+            transfer_tasks:        Mutex::new(TransferTasksPool::new(name.clone())),</div><div>             request_shard_transfer_cb: request_shard_transfer.clone(),</div><div class="diff-removed">-            notify_peer_failure_cb: on_replica_failure.clone(),</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-added">+            notify_peer_failure_cb:    on_replica_failure.clone(),</div><div class="diff-added">+            abort_shard_transfer_cb:   abort_shard_transfer,</div><div>             init_time: start_time.elapsed(),</div><div>             is_initialized: Default::default(),</div><div>             updates_lock: Default::default(),</div><div class="diff-info">@@ -252,9 +260,10 @@ impl Collection {</div><div>         let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div> </div><div>         if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-            effective_optimizers_config = optimizers_overwrite</div><div class="diff-removed">-                .update(&effective_optimizers_config)</div><div class="diff-removed">-                .expect("Can not apply optimizer overwrite");</div><div class="diff-added">+            effective_optimizers_config =</div><div class="diff-added">+                optimizers_overwrite</div><div class="diff-added">+                    .update(&effective_optimizers_config)</div><div class="diff-added">+                    .expect("Can not apply optimizer overwrite");</div><div>         }</div><div> </div><div>         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div class="diff-info">@@ -289,20 +298,20 @@ impl Collection {</div><div>         );</div><div> </div><div>         Self {</div><div class="diff-removed">-            id: collection_id.clone(),</div><div class="diff-removed">-            shards_holder: locked_shard_holder,</div><div class="diff-removed">-            collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-added">+            id:                    collection_id.clone(),</div><div class="diff-added">+            shards_holder:         locked_shard_holder,</div><div class="diff-added">+            collection_config:     shared_collection_config,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div class="diff-removed">-            path: path.to_owned(),</div><div class="diff-removed">-            snapshots_path: snapshots_path.to_owned(),</div><div class="diff-added">+            path:                  path.to_owned(),</div><div class="diff-added">+            snapshots_path:        snapshots_path.to_owned(),</div><div>             channel_service,</div><div class="diff-removed">-            transfer_tasks: Mutex::new(TransferTasksPool::new(collection_id.clone())),</div><div class="diff-added">+            transfer_tasks:        Mutex::new(TransferTasksPool::new(collection_id.clone())),</div><div>             request_shard_transfer_cb: request_shard_transfer.clone(),</div><div class="diff-removed">-            notify_peer_failure_cb: on_replica_failure,</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-added">+            notify_peer_failure_cb:    on_replica_failure,</div><div class="diff-added">+            abort_shard_transfer_cb:   abort_shard_transfer,</div><div>             init_time: start_time.elapsed(),</div><div>             is_initialized: Default::default(),</div><div>             updates_lock: Default::default(),</div><div class="diff-info">@@ -331,10 +340,7 @@ impl Collection {</div><div>         if stored.minor != app.minor {</div><div>             return false;</div><div>         }</div><div class="diff-removed">-        if stored.patch + 1 < app.patch {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        true</div><div class="diff-added">+        stored.patch + 1 >= app.patch</div><div>     }</div><div> </div><div>     pub fn name(&self) -> String {</div><div class="diff-info">@@ -375,7 +381,7 @@ impl Collection {</div><div>         let shard = shard_holder_read.get_shard(shard_id);</div><div>         let Some(replica_set) = shard else {</div><div>             return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-added">+                what: "Shard {shard_id}".into(),</div><div>             });</div><div>         };</div><div> </div><div class="diff-info">@@ -483,19 +489,22 @@ impl Collection {</div><div>             abort_resharding_result?;</div><div>         }</div><div> </div><div class="diff-removed">-        // If not initialized yet, we need to check if it was initialized by this call</div><div>         if !self.is_initialized.check_ready() {</div><div>             let state = self.state().await;</div><div> </div><div>             let mut is_ready = true;</div><div> </div><div>             for (_shard_id, shard_info) in state.shards {</div><div class="diff-removed">-                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-removed">-                    matches!(</div><div class="diff-removed">-                        state,</div><div class="diff-removed">-                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                });</div><div class="diff-added">+                let all_replicas_active =</div><div class="diff-added">+                    shard_info</div><div class="diff-added">+                        .replicas</div><div class="diff-added">+                        .into_iter()</div><div class="diff-added">+                        .all(|(_, state)| {</div><div class="diff-added">+                            matches!(</div><div class="diff-added">+                                state,</div><div class="diff-added">+                                ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-added">+                            )</div><div class="diff-added">+                        });</div><div> </div><div>                 if !all_replicas_active {</div><div>                     is_ready = false;</div><div class="diff-info">@@ -508,10 +517,34 @@ impl Collection {</div><div>             }</div><div>         }</div><div> </div><div class="diff-added">+        // Try to request shard transfer if replicas on the current peer are dead</div><div class="diff-added">+        if new_state == ReplicaState::Dead && self.this_peer_id == peer_id {</div><div class="diff-added">+            let transfer_from = replica_set</div><div class="diff-added">+                .peers()</div><div class="diff-added">+                .into_iter()</div><div class="diff-added">+                .find(|(_, state)| state == &ReplicaState::Active)</div><div class="diff-added">+                .map(|(peer_id, _)| peer_id);</div><div class="diff-added">+            if let Some(transfer_from) = transfer_from {</div><div class="diff-added">+                self.request_shard_transfer(ShardTransfer {</div><div class="diff-added">+                    shard_id,</div><div class="diff-added">+                    from: transfer_from,</div><div class="diff-added">+                    to: self.this_peer_id,</div><div class="diff-added">+                    to_shard_id: None,</div><div class="diff-added">+                    sync: true,</div><div class="diff-added">+                    method: None,</div><div class="diff-added">+                })</div><div class="diff-added">+            } else {</div><div class="diff-added">+                log::warn!("No alive replicas to recover shard {shard_id}");</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn shard_recovery_point(&self, shard_id: ShardId) -> CollectionResult<RecoveryPoint> {</div><div class="diff-added">+    pub async fn shard_recovery_point(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        shard_id: ShardId,</div><div class="diff-added">+    ) -> CollectionResult<RecoveryPoint> {</div><div>         let shard_holder_read = self.shards_holder.read().await;</div><div> </div><div>         let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-info">@@ -534,7 +567,7 @@ impl Collection {</div><div>         let shard = shard_holder_read.get_shard(shard_id);</div><div>         let Some(replica_set) = shard else {</div><div>             return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-added">+                what: "Shard {shard_id}".into(),</div><div>             });</div><div>         };</div><div> </div><div class="diff-info">@@ -563,30 +596,6 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        // Abort resharding, if shards are removed from peer driving resharding</div><div class="diff-removed">-        // (which *usually* means the *peer* is being removed from consensus)</div><div class="diff-removed">-        let resharding_state = self</div><div class="diff-removed">-            .resharding_state()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .filter(|state| state.peer_id == peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(state) = resharding_state {</div><div class="diff-removed">-            if let Err(err) = self.abort_resharding(state.key(), true).await {</div><div class="diff-removed">-                log::error!(</div><div class="diff-removed">-                    "Failed to abort resharding {} while removing peer {peer_id}: {err}",</div><div class="diff-removed">-                    state.key(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.shards_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .remove_shards_at_peer(peer_id)</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn sync_local_state(</div><div>         &self,</div><div>         on_transfer_failure: OnTransferFailure,</div><div class="diff-info">@@ -664,7 +673,8 @@ impl Collection {</div><div>             if self.shared_storage_config.node_type == NodeType::Listener {</div><div>                 // We probably should not switch node type during resharding, so we only check for `Active`,</div><div>                 // but not `ReshardingScaleDown` replica state here...</div><div class="diff-removed">-                let is_last_active = peers.values().filter(|&&state| state == Active).count() == 1;</div><div class="diff-added">+                let is_last_active =</div><div class="diff-added">+                    peers.values().filter(|&&state| state == Active).count() == 1;</div><div> </div><div>                 if this_peer_state == Some(Active) && !is_last_active {</div><div>                     // Convert active node from active to listener</div><div class="diff-info">@@ -701,22 +711,6 @@ impl Collection {</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-removed">-            // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-removed">-            let shard_transfer_method = self</div><div class="diff-removed">-                .shared_storage_config</div><div class="diff-removed">-                .default_shard_transfer_method</div><div class="diff-removed">-                .unwrap_or_else(|| {</div><div class="diff-removed">-                    let all_support_wal_delta = self</div><div class="diff-removed">-                        .channel_service</div><div class="diff-removed">-                        .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-removed">-                    if all_support_wal_delta {</div><div class="diff-removed">-                        ShardTransferMethod::WalDelta</div><div class="diff-removed">-                    } else {</div><div class="diff-removed">-                        ShardTransferMethod::default()</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div>             // Try to find a replica to transfer from</div><div>             //</div><div>             // `active_remote_shards` includes `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-info">@@ -728,7 +722,20 @@ impl Collection {</div><div>                     to_shard_id: None,</div><div>                     sync: true,</div><div>                     // For automatic shard transfers, always select some default method from this point on</div><div class="diff-removed">-                    method: Some(shard_transfer_method),</div><div class="diff-added">+                    method: Some(</div><div class="diff-added">+                        self.shared_storage_config</div><div class="diff-added">+                            .default_shard_transfer_method</div><div class="diff-added">+                            .unwrap_or_else(|| {</div><div class="diff-added">+                                let all_support_wal_delta = self</div><div class="diff-added">+                                    .channel_service</div><div class="diff-added">+                                    .all_peers_at_version(&Version::new(1, 8, 0));</div><div class="diff-added">+                                if all_support_wal_delta {</div><div class="diff-added">+                                    ShardTransferMethod::WalDelta</div><div class="diff-added">+                                } else {</div><div class="diff-added">+                                    ShardTransferMethod::default()</div><div class="diff-added">+                                }</div><div class="diff-added">+                            }),</div><div class="diff-added">+                    ),</div><div>                 };</div><div> </div><div>                 if check_transfer_conflicts_strict(&transfer, transfers.iter()).is_some() {</div><div class="diff-info">@@ -755,6 +762,7 @@ impl Collection {</div><div>                         self.id,</div><div>                         replica_set.shard_id,</div><div>                     );</div><div class="diff-added">+</div><div>                     continue;</div><div>                 }</div><div> </div><div class="diff-info">@@ -784,7 +792,9 @@ impl Collection {</div><div>                 }</div><div>                 (</div><div>                     Some(shards_telemetry),</div><div class="diff-removed">-                    Some(shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)),</div><div class="diff-added">+                    Some(shards_holder.get_shard_transfer_info(</div><div class="diff-added">+                        &*self.transfer_tasks.lock().await,</div><div class="diff-added">+                    )),</div><div>                     Some(</div><div>                         shards_holder</div><div>                             .get_resharding_operations_info()</div><div class="diff-info">@@ -801,7 +811,9 @@ impl Collection {</div><div>         CollectionTelemetry {</div><div>             id: self.name(),</div><div>             init_time_ms: self.init_time.as_millis() as u64,</div><div class="diff-removed">-            config: CollectionConfigTelemetry::from(self.collection_config.read().await.clone()),</div><div class="diff-added">+            config: CollectionConfigTelemetry::from(</div><div class="diff-added">+                self.collection_config.read().await.clone(),</div><div class="diff-added">+            ),</div><div>             shards: shards_telemetry,</div><div>             transfers,</div><div>             resharding,</div><div class="diff-info">@@ -816,10 +828,8 @@ impl Collection {</div><div>         let mut vectors = 0;</div><div> </div><div>         for shard in shards_holder.all_shards() {</div><div class="diff-removed">-            let shard_optimization_status = shard</div><div class="diff-removed">-                .get_optimization_status()</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .unwrap_or(OptimizersStatus::Ok);</div><div class="diff-added">+            let shard_optimization_status =</div><div class="diff-added">+                shard.get_optimization_status().await.unwrap_or(OptimizersStatus::Ok);</div><div> </div><div>             shard_optimization_statuses.push(shard_optimization_status);</div><div> </div><div class="diff-info">@@ -838,16 +848,6 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div>         self.updates_lock.write().await</div><div>     }</div><div class="diff-info">@@ -881,7 +881,9 @@ impl Collection {</div><div> </div><div>     /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div>     /// The cache gets updated every 32 calls.</div><div class="diff-removed">-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-added">+    pub(crate) async fn estimated_collection_stats(</div><div class="diff-added">+        &self,</div><div class="diff-added">+    ) -> Option<&CollectionSizeAtomicStats> {</div><div>         self.collection_stats_cache</div><div>             .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div>             .await</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    