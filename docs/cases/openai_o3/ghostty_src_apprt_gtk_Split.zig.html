<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/apprt/gtk/Split.zig - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/apprt/gtk/Split.zig</h1>
        <p><a href="../../models/openai_o3.html">← Back to o3 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 24834</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 24863</p>
                <p><strong>Native Completion Tokens:</strong> 4736</p>
                <p><strong>Native Tokens Reasoning:</strong> 2176</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.4599735</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/ghostty_src_apprt_gtk_Split.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/ghostty_src_apprt_gtk_Split.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/ghostty_src_apprt_gtk_Split.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- ghostty_src_apprt_gtk_Split.zig_expectedoutput.txt (expected)+++ ghostty_src_apprt_gtk_Split.zig_extracted.txt (actual)@@ -10,7 +10,6 @@ const gtk = @import("gtk");</div><div> </div><div> const apprt = @import("../../apprt.zig");</div><div class="diff-removed">-const font = @import("../../font/main.zig");</div><div> const CoreSurface = @import("../../Surface.zig");</div><div> </div><div> const Surface = @import("Surface.zig");</div><div class="diff-info">@@ -26,13 +25,13 @@     pub fn fromDirection(direction: apprt.action.SplitDirection) Orientation {</div><div>         return switch (direction) {</div><div>             .right, .left => .horizontal,</div><div class="diff-removed">-            .down, .up => .vertical,</div><div class="diff-added">+            .down,  .up   => .vertical,</div><div>         };</div><div>     }</div><div> </div><div>     pub fn fromResizeDirection(direction: apprt.action.ResizeSplit.Direction) Orientation {</div><div>         return switch (direction) {</div><div class="diff-removed">-            .up, .down => .vertical,</div><div class="diff-added">+            .up, .down   => .vertical,</div><div>             .left, .right => .horizontal,</div><div>         };</div><div>     }</div><div class="diff-info">@@ -44,19 +43,14 @@ /// The container for this split panel.</div><div> container: Surface.Container,</div><div> </div><div class="diff-removed">-/// The orientation of this split panel.</div><div class="diff-added">+/// The orientation of this split.</div><div> orientation: Orientation,</div><div> </div><div> /// The elements of this split panel.</div><div class="diff-removed">-top_left: Surface.Container.Elem,</div><div class="diff-added">+top_left:     Surface.Container.Elem,</div><div> bottom_right: Surface.Container.Elem,</div><div> </div><div class="diff-removed">-/// Create a new split panel with the given sibling surface in the given</div><div class="diff-removed">-/// direction. The direction is where the new surface will be initialized.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// The sibling surface can be in a split already or it can be within a</div><div class="diff-removed">-/// tab. This properly handles updating the surface container so that</div><div class="diff-removed">-/// it represents the new split.</div><div class="diff-added">+/// Create a new split.</div><div> pub fn create(</div><div>     alloc: Allocator,</div><div>     sibling: *Surface,</div><div class="diff-info">@@ -68,33 +62,24 @@     return split;</div><div> }</div><div> </div><div class="diff-added">+/// Initialize an already-allocated Split.</div><div> pub fn init(</div><div>     self: *Split,</div><div>     sibling: *Surface,</div><div>     direction: apprt.action.SplitDirection,</div><div> ) !void {</div><div class="diff-removed">-    // If our sibling is too small to be split in half then we don't</div><div class="diff-removed">-    // allow the split to happen. This avoids a situation where the</div><div class="diff-removed">-    // split becomes too small.</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // This is kind of a hack. Ideally we'd use gtk_widget_set_size_request</div><div class="diff-removed">-    // properly along the path to ensure minimum sizes. I don't know if</div><div class="diff-removed">-    // GTK even respects that all but any way GTK does this for us seems</div><div class="diff-removed">-    // better than this.</div><div class="diff-added">+    // If the sibling would get too small by being split, abort.</div><div>     {</div><div class="diff-removed">-        // This is the min size of the sibling split. This means the</div><div class="diff-removed">-        // smallest split is half of this.</div><div class="diff-removed">-        const multiplier = 4;</div><div class="diff-removed">-</div><div class="diff-removed">-        const size = &sibling.core_surface.size;</div><div class="diff-added">+        const min_cells = 4; // the new split would be <2×2 otherwise</div><div class="diff-added">+        const size  = &sibling.core_surface.size;</div><div>         const small = switch (direction) {</div><div class="diff-removed">-            .right, .left => size.screen.width < size.cell.width * multiplier,</div><div class="diff-removed">-            .down, .up => size.screen.height < size.cell.height * multiplier,</div><div class="diff-added">+            .right, .left => size.screen.width  < size.cell.width  * min_cells,</div><div class="diff-added">+            .down,  .up   => size.screen.height < size.cell.height * min_cells,</div><div>         };</div><div>         if (small) return error.SplitTooSmall;</div><div>     }</div><div> </div><div class="diff-removed">-    // Create the new child surface for the other direction.</div><div class="diff-added">+    // Create the new child surface.</div><div>     const alloc = sibling.app.core_app.alloc;</div><div>     var surface = try Surface.create(alloc, sibling.app, .{</div><div>         .parent = &sibling.core_surface,</div><div class="diff-info">@@ -103,195 +88,142 @@     sibling.dimSurface();</div><div>     sibling.setSplitZoom(false);</div><div> </div><div class="diff-removed">-    // Create the actual GTKPaned, attach the proper children.</div><div class="diff-added">+    // Build the GtkPaned.</div><div>     const orientation: gtk.Orientation = switch (direction) {</div><div>         .right, .left => .horizontal,</div><div class="diff-removed">-        .down, .up => .vertical,</div><div class="diff-added">+        .down,  .up   => .vertical,</div><div>     };</div><div>     const paned = gtk.Paned.new(orientation);</div><div>     errdefer paned.unref();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Keep a long-lived reference, which we unref in destroy.</div><div class="diff-removed">-    paned.ref();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Update all of our containers to point to the right place.</div><div class="diff-removed">-    // The split has to point to where the sibling pointed to because</div><div class="diff-removed">-    // we're inheriting its parent. The sibling points to its location</div><div class="diff-removed">-    // in the split, and the surface points to the other location.</div><div class="diff-added">+    paned.ref(); // long-lived</div><div class="diff-added">+</div><div class="diff-added">+    // Update containers.</div><div>     const container = sibling.container;</div><div>     const tl: *Surface, const br: *Surface = switch (direction) {</div><div class="diff-removed">-        .right, .down => right_down: {</div><div class="diff-removed">-            sibling.container = .{ .split_tl = &self.top_left };</div><div class="diff-added">+        .right, .down => blk: {</div><div class="diff-added">+            sibling.container = .{ .split_tl = &self.top_left  };</div><div>             surface.container = .{ .split_br = &self.bottom_right };</div><div class="diff-removed">-            break :right_down .{ sibling, surface };</div><div class="diff-removed">-        },</div><div class="diff-removed">-</div><div class="diff-removed">-        .left, .up => left_up: {</div><div class="diff-added">+            break :blk .{ sibling, surface };</div><div class="diff-added">+        },</div><div class="diff-added">+        .left, .up => blk: {</div><div>             sibling.container = .{ .split_br = &self.bottom_right };</div><div>             surface.container = .{ .split_tl = &self.top_left };</div><div class="diff-removed">-            break :left_up .{ surface, sibling };</div><div class="diff-added">+            break :blk .{ surface, sibling };</div><div>         },</div><div>     };</div><div> </div><div>     self.* = .{</div><div class="diff-removed">-        .paned = paned,</div><div class="diff-removed">-        .container = container,</div><div class="diff-removed">-        .top_left = .{ .surface = tl },</div><div class="diff-removed">-        .bottom_right = .{ .surface = br },</div><div class="diff-added">+        .paned       = paned,</div><div class="diff-added">+        .container   = container,</div><div class="diff-added">+        .top_left    = .{ .surface = tl },</div><div class="diff-added">+        .bottom_right= .{ .surface = br },</div><div>         .orientation = Orientation.fromDirection(direction),</div><div>     };</div><div> </div><div class="diff-removed">-    // Replace the previous containers element with our split. This allows a</div><div class="diff-removed">-    // non-split to become a split, a split to become a nested split, etc.</div><div class="diff-added">+    // Replace previous element with our new split and wire up children.</div><div>     container.replace(.{ .split = self });</div><div class="diff-removed">-</div><div class="diff-removed">-    // Update our children so that our GL area is properly added to the paned.</div><div>     self.updateChildren();</div><div> </div><div class="diff-removed">-    // The new surface should always grab focus</div><div class="diff-added">+    // Focus the new surface.</div><div>     surface.grabFocus();</div><div> }</div><div> </div><div class="diff-added">+/// Destroy the split and its children.</div><div> pub fn destroy(self: *Split, alloc: Allocator) void {</div><div>     self.top_left.deinit(alloc);</div><div>     self.bottom_right.deinit(alloc);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Clean up our GTK reference. This will trigger all the destroy callbacks</div><div class="diff-removed">-    // that are necessary for the surfaces to clean up.</div><div>     self.paned.unref();</div><div class="diff-removed">-</div><div>     alloc.destroy(self);</div><div> }</div><div> </div><div class="diff-removed">-/// Remove the top left child.</div><div class="diff-removed">-pub fn removeTopLeft(self: *Split) void {</div><div class="diff-removed">-    self.removeChild(self.top_left, self.bottom_right);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Remove the top left child.</div><div class="diff-removed">-pub fn removeBottomRight(self: *Split) void {</div><div class="diff-removed">-    self.removeChild(self.bottom_right, self.top_left);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+/// Remove one child, collapsing the split.</div><div> fn removeChild(</div><div>     self: *Split,</div><div>     remove: Surface.Container.Elem,</div><div class="diff-removed">-    keep: Surface.Container.Elem,</div><div class="diff-added">+    keep:   Surface.Container.Elem,</div><div> ) void {</div><div>     const window = self.container.window() orelse return;</div><div class="diff-removed">-    const alloc = window.app.core_app.alloc;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Remove our children since we are going to no longer be a split anyways.</div><div class="diff-removed">-    // This prevents widgets with multiple parents.</div><div class="diff-added">+    const alloc  = window.app.core_app.alloc;</div><div class="diff-added">+</div><div class="diff-added">+    // We’re no longer a split – clean up.</div><div>     self.removeChildren();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Our container must become whatever our top left is</div><div>     self.container.replace(keep);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Grab focus of the left-over side</div><div>     keep.grabFocus();</div><div> </div><div class="diff-removed">-    // When a child is removed we are no longer a split, so destroy ourself</div><div>     remove.deinit(alloc);</div><div>     alloc.destroy(self);</div><div> }</div><div> </div><div class="diff-removed">-/// Move the divider in the given direction by the given amount.</div><div class="diff-added">+/// Convenience helpers.</div><div class="diff-added">+pub fn removeTopLeft   (self: *Split) void { self.removeChild(self.top_left,     self.bottom_right); }</div><div class="diff-added">+pub fn removeBottomRight(self: *Split) void { self.removeChild(self.bottom_right, self.top_left    ); }</div><div class="diff-added">+</div><div class="diff-added">+/// Move divider by amount in direction.</div><div> pub fn moveDivider(</div><div>     self: *Split,</div><div>     direction: apprt.action.ResizeSplit.Direction,</div><div>     amount: u16,</div><div> ) void {</div><div>     const min_pos = 10;</div><div class="diff-removed">-</div><div class="diff-removed">-    const pos = self.paned.getPosition();</div><div class="diff-removed">-    const new = switch (direction) {</div><div class="diff-removed">-        .up, .left => @max(pos - amount, min_pos),</div><div class="diff-removed">-        .down, .right => new_pos: {</div><div class="diff-added">+    const pos     = self.paned.getPosition();</div><div class="diff-added">+    const new     = switch (direction) {</div><div class="diff-added">+        .up, .left   => @max(pos - amount, min_pos),</div><div class="diff-added">+        .down, .right => blk: {</div><div>             const max_pos: u16 = @as(u16, @intFromFloat(self.maxPosition())) - min_pos;</div><div class="diff-removed">-            break :new_pos @min(pos + amount, max_pos);</div><div class="diff-removed">-        },</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-added">+            break :blk @min(pos + amount, max_pos);</div><div class="diff-added">+        },</div><div class="diff-added">+    };</div><div>     self.paned.setPosition(new);</div><div> }</div><div> </div><div class="diff-removed">-/// Equalize the splits in this split panel. Each split is equalized based on</div><div class="diff-removed">-/// its weight, i.e. the number of Surfaces it contains.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It works recursively by equalizing the children of each split.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It returns this split's weight.</div><div class="diff-added">+/// Equalize child splits recursively; returns weight.</div><div> pub fn equalize(self: *Split) f64 {</div><div class="diff-removed">-    // Calculate weights of top_left/bottom_right</div><div class="diff-removed">-    const top_left_weight = self.top_left.equalize();</div><div class="diff-removed">-    const bottom_right_weight = self.bottom_right.equalize();</div><div class="diff-removed">-    const weight = top_left_weight + bottom_right_weight;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Ratio of top_left weight to overall weight, which gives the split ratio</div><div class="diff-removed">-    const ratio = top_left_weight / weight;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Convert split ratio into new position for divider</div><div class="diff-removed">-    self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));</div><div class="diff-removed">-</div><div class="diff-removed">-    return weight;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// maxPosition returns the maximum position of the GtkPaned, which is the</div><div class="diff-removed">-// "max-position" attribute.</div><div class="diff-added">+    const wl = self.top_left.equalize();</div><div class="diff-added">+    const wr = self.bottom_right.equalize();</div><div class="diff-added">+    const w  = wl + wr;</div><div class="diff-added">+    self.paned.setPosition(@intFromFloat(self.maxPosition() * (wl / w)));</div><div class="diff-added">+    return w;</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Maximum position (property “max-position”) of the paned.</div><div> fn maxPosition(self: *Split) f64 {</div><div>     var value: gobject.Value = std.mem.zeroes(gobject.Value);</div><div>     defer value.unset();</div><div> </div><div>     _ = value.init(gobject.ext.types.int);</div><div class="diff-removed">-    self.paned.as(gobject.Object).getProperty(</div><div class="diff-removed">-        "max-position",</div><div class="diff-removed">-        &value,</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-added">+    self.paned.as(gobject.Object).getProperty("max-position", &value);</div><div>     return @floatFromInt(value.getInt());</div><div> }</div><div> </div><div class="diff-removed">-// This replaces the element at the given pointer with a new element.</div><div class="diff-removed">-// The ptr must be either top_left or bottom_right (asserted in debug).</div><div class="diff-removed">-// The memory of the old element must be freed or otherwise handled by</div><div class="diff-removed">-// the caller.</div><div class="diff-added">+/// Replace element at pointer with new element.</div><div> pub fn replace(</div><div>     self: *Split,</div><div>     ptr: *Surface.Container.Elem,</div><div>     new: Surface.Container.Elem,</div><div> ) void {</div><div class="diff-removed">-    // We can write our element directly. There's nothing special.</div><div class="diff-removed">-    assert(&self.top_left == ptr or &self.bottom_right == ptr);</div><div class="diff-added">+    assert(ptr == &self.top_left or ptr == &self.bottom_right);</div><div class="diff-added">+</div><div>     ptr.* = new;</div><div> </div><div class="diff-removed">-    // Update our paned children. This will reset the divider</div><div class="diff-removed">-    // position but we want to keep it in place so save and restore it.</div><div>     const pos = self.paned.getPosition();</div><div>     defer self.paned.setPosition(pos);</div><div class="diff-added">+</div><div>     self.updateChildren();</div><div> }</div><div> </div><div class="diff-removed">-// grabFocus grabs the focus of the top-left element.</div><div class="diff-added">+/// Focus on first surface (top-left).</div><div> pub fn grabFocus(self: *Split) void {</div><div>     self.top_left.grabFocus();</div><div> }</div><div> </div><div class="diff-removed">-/// Update the paned children to represent the current state.</div><div class="diff-removed">-/// This should be called anytime the top/left or bottom/right</div><div class="diff-removed">-/// element is changed.</div><div class="diff-added">+/// Update paned children to match state.</div><div> pub fn updateChildren(self: *const Split) void {</div><div class="diff-removed">-    // We have to set both to null. If we overwrite the pane with</div><div class="diff-removed">-    // the same value, then GTK bugs out (the GL area unrealizes</div><div class="diff-removed">-    // and never rerealizes).</div><div>     self.removeChildren();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Set our current children</div><div>     self.paned.setStartChild(self.top_left.widget());</div><div class="diff-removed">-    self.paned.setEndChild(self.bottom_right.widget());</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// A mapping of direction to the element (if any) in that direction.</div><div class="diff-added">+    self.paned.setEndChild  (self.bottom_right.widget());</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Mapping type used for goto-split.</div><div> pub const DirectionMap = std.EnumMap(</div><div>     apprt.action.GotoSplit,</div><div>     ?*Surface,</div><div class="diff-info">@@ -299,143 +231,101 @@ </div><div> pub const Side = enum { top_left, bottom_right };</div><div> </div><div class="diff-removed">-/// Returns the map that can be used to determine elements in various</div><div class="diff-removed">-/// directions (primarily for gotoSplit).</div><div class="diff-added">+/// Compute map of neighbour surfaces relative to “from”.</div><div> pub fn directionMap(self: *const Split, from: Side) DirectionMap {</div><div>     var result = DirectionMap.initFull(null);</div><div> </div><div>     if (self.directionPrevious(from)) |prev| {</div><div>         result.put(.previous, prev.surface);</div><div class="diff-removed">-        if (!prev.wrapped) {</div><div class="diff-removed">-            result.put(.up, prev.surface);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-added">+        if (!prev.wrapped) result.put(.up, prev.surface);</div><div class="diff-added">+    }</div><div>     if (self.directionNext(from)) |next| {</div><div>         result.put(.next, next.surface);</div><div class="diff-removed">-        if (!next.wrapped) {</div><div class="diff-removed">-            result.put(.down, next.surface);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (self.directionLeft(from)) |left| {</div><div class="diff-removed">-        result.put(.left, left);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (self.directionRight(from)) |right| {</div><div class="diff-removed">-        result.put(.right, right);</div><div class="diff-removed">-    }</div><div class="diff-added">+        if (!next.wrapped) result.put(.down, next.surface);</div><div class="diff-added">+    }</div><div class="diff-added">+    if (self.directionLeft(from)) |l|  result.put(.left,  l);</div><div class="diff-added">+    if (self.directionRight(from))|r|  result.put(.right, r);</div><div> </div><div>     return result;</div><div> }</div><div> </div><div class="diff-added">+/// Horizontal neighbour to the left.</div><div> fn directionLeft(self: *const Split, from: Side) ?*Surface {</div><div>     switch (from) {</div><div class="diff-removed">-        .bottom_right => {</div><div class="diff-removed">-            switch (self.orientation) {</div><div class="diff-removed">-                .horizontal => return self.top_left.deepestSurface(.bottom_right),</div><div class="diff-removed">-                .vertical => return directionLeft(</div><div class="diff-removed">-                    self.container.split() orelse return null,</div><div class="diff-removed">-                    .bottom_right,</div><div class="diff-removed">-                ),</div><div class="diff-removed">-            }</div><div class="diff-removed">-        },</div><div class="diff-removed">-        .top_left => return directionLeft(</div><div class="diff-removed">-            self.container.split() orelse return null,</div><div class="diff-removed">-            .bottom_right,</div><div class="diff-removed">-        ),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+        .bottom_right => switch (self.orientation) {</div><div class="diff-added">+            .horizontal => return self.top_left.deepestSurface(.bottom_right),</div><div class="diff-added">+            .vertical   => return directionLeft(self.container.split() orelse return null, .bottom_right),</div><div class="diff-added">+        },</div><div class="diff-added">+        .top_left => return directionLeft(self.container.split() orelse return null, .bottom_right),</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Horizontal neighbour to the right.</div><div> fn directionRight(self: *const Split, from: Side) ?*Surface {</div><div>     switch (from) {</div><div class="diff-added">+        .top_left => switch (self.orientation) {</div><div class="diff-added">+            .horizontal => return self.bottom_right.deepestSurface(.top_left),</div><div class="diff-added">+            .vertical   => return directionRight(self.container.split() orelse return null, .top_left),</div><div class="diff-added">+        },</div><div class="diff-added">+        .bottom_right => return directionRight(self.container.split() orelse return null, .top_left),</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Previous/next helpers (used for goto-split up/down/previous/next).</div><div class="diff-added">+fn directionPrevious(self: *const Split, from: Side) ?struct { surface: *Surface, wrapped: bool } {</div><div class="diff-added">+    switch (from) {</div><div class="diff-added">+        .bottom_right => return .{ .surface = self.top_left.deepestSurface(.bottom_right) orelse return null, .wrapped = false },</div><div>         .top_left => {</div><div class="diff-removed">-            switch (self.orientation) {</div><div class="diff-removed">-                .horizontal => return self.bottom_right.deepestSurface(.top_left),</div><div class="diff-removed">-                .vertical => return directionRight(</div><div class="diff-removed">-                    self.container.split() orelse return null,</div><div class="diff-removed">-                    .top_left,</div><div class="diff-removed">-                ),</div><div class="diff-removed">-            }</div><div class="diff-removed">-        },</div><div class="diff-removed">-        .bottom_right => return directionRight(</div><div class="diff-removed">-            self.container.split() orelse return null,</div><div class="diff-removed">-            .top_left,</div><div class="diff-removed">-        ),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn directionPrevious(self: *const Split, from: Side) ?struct {</div><div class="diff-removed">-    surface: *Surface,</div><div class="diff-removed">-    wrapped: bool,</div><div class="diff-removed">-} {</div><div class="diff-removed">-    switch (from) {</div><div class="diff-removed">-        // From the bottom right, our previous is the deepest surface</div><div class="diff-removed">-        // in the top-left of our own split.</div><div class="diff-removed">-        .bottom_right => return .{</div><div class="diff-removed">-            .surface = self.top_left.deepestSurface(.bottom_right) orelse return null,</div><div class="diff-removed">-            .wrapped = false,</div><div class="diff-removed">-        },</div><div class="diff-removed">-</div><div class="diff-removed">-        // From the top left its more complicated. It is the de</div><div class="diff-removed">-        .top_left => {</div><div class="diff-removed">-            // If we have no parent split then there can be no unwrapped prev.</div><div class="diff-removed">-            // We can still have a wrapped previous.</div><div>             const parent = self.container.split() orelse return .{</div><div>                 .surface = self.bottom_right.deepestSurface(.bottom_right) orelse return null,</div><div>                 .wrapped = true,</div><div>             };</div><div class="diff-removed">-</div><div class="diff-removed">-            // The previous value is the previous of the side that we are.</div><div>             const side = self.container.splitSide() orelse return null;</div><div>             return switch (side) {</div><div class="diff-removed">-                .top_left => parent.directionPrevious(.top_left),</div><div class="diff-removed">-                .bottom_right => parent.directionPrevious(.bottom_right),</div><div class="diff-added">+                .top_left      => parent.directionPrevious(.top_left),</div><div class="diff-added">+                .bottom_right  => parent.directionPrevious(.bottom_right),</div><div>             };</div><div>         },</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-fn directionNext(self: *const Split, from: Side) ?struct {</div><div class="diff-removed">-    surface: *Surface,</div><div class="diff-removed">-    wrapped: bool,</div><div class="diff-removed">-} {</div><div class="diff-added">+fn directionNext(self: *const Split, from: Side) ?struct { surface: *Surface, wrapped: bool } {</div><div>     switch (from) {</div><div class="diff-removed">-        // From the top left, our next is the earliest surface in the</div><div class="diff-removed">-        // top-left direction of the bottom-right side of our split. Fun!</div><div class="diff-removed">-        .top_left => return .{</div><div class="diff-removed">-            .surface = self.bottom_right.deepestSurface(.top_left) orelse return null,</div><div class="diff-removed">-            .wrapped = false,</div><div class="diff-removed">-        },</div><div class="diff-removed">-</div><div class="diff-removed">-        // From the bottom right is more compliated. It is the deepest</div><div class="diff-removed">-        // (last) surface in the</div><div class="diff-added">+        .top_left => return .{ .surface = self.bottom_right.deepestSurface(.top_left) orelse return null, .wrapped = false },</div><div>         .bottom_right => {</div><div class="diff-removed">-            // If we have no parent split then there can be no next.</div><div>             const parent = self.container.split() orelse return .{</div><div>                 .surface = self.top_left.deepestSurface(.top_left) orelse return null,</div><div>                 .wrapped = true,</div><div>             };</div><div class="diff-removed">-</div><div class="diff-removed">-            // The previous value is the previous of the side that we are.</div><div>             const side = self.container.splitSide() orelse return null;</div><div>             return switch (side) {</div><div class="diff-removed">-                .top_left => parent.directionNext(.top_left),</div><div class="diff-added">+                .top_left     => parent.directionNext(.top_left),</div><div>                 .bottom_right => parent.directionNext(.bottom_right),</div><div>             };</div><div>         },</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-pub fn detachTopLeft(self: *const Split) void {</div><div class="diff-removed">-    self.paned.setStartChild(null);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub fn detachBottomRight(self: *const Split) void {</div><div class="diff-removed">-    self.paned.setEndChild(null);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+/// Detach helpers used when collapsing.</div><div class="diff-added">+pub fn detachTopLeft   (self: *const Split) void { self.paned.setStartChild(null); }</div><div class="diff-added">+pub fn detachBottomRight(self: *const Split) void { self.paned.setEndChild(null); }</div><div class="diff-added">+</div><div class="diff-added">+/// Remove both children from paned.</div><div> fn removeChildren(self: *const Split) void {</div><div>     self.detachTopLeft();</div><div>     self.detachBottomRight();</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+/// Recursively find deepest surface on a side.</div><div class="diff-added">+fn deepestSurface(self: *const Split, side: Side) *Surface {</div><div class="diff-added">+    return switch (side) {</div><div class="diff-added">+        .bottom_right => switch (self.bottom_right) {</div><div class="diff-added">+            .surface => |s| s,</div><div class="diff-added">+            .split   => |s| s.deepestSurface(.bottom_right),</div><div class="diff-added">+        },</div><div class="diff-added">+        .top_left => switch (self.top_left) {</div><div class="diff-added">+            .surface => |s| s,</div><div class="diff-added">+            .split   => |s| s.deepestSurface(.top_left),</div><div class="diff-added">+        },</div><div class="diff-added">+    };</div><div> }</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    