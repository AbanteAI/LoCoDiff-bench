<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/openai_o3.html">‚Üê Back to o3 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 61338</p>
                <p><strong>Native Completion Tokens:</strong> 7128</p>
                <p><strong>Native Tokens Reasoning:</strong> 576</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.9434249999999998</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -1,8 +1,8 @@ use std::cmp::min;</div><div> use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div class="diff-added">+use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> use std::sync::Arc;</div><div class="diff-removed">-use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> </div><div> use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-info">@@ -16,10 +16,10 @@ use segment::types::SeqNumberType;</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::{self, Receiver, Sender};</div><div class="diff-removed">-use tokio::sync::{Mutex as TokioMutex, oneshot};</div><div class="diff-added">+use tokio::sync::{oneshot, Mutex as TokioMutex};</div><div> use tokio::task::{self, JoinHandle};</div><div> use tokio::time::error::Elapsed;</div><div class="diff-removed">-use tokio::time::{Duration, timeout};</div><div class="diff-added">+use tokio::time::{timeout, Duration};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_manager::collection_updater::CollectionUpdater;</div><div class="diff-info">@@ -28,19 +28,16 @@     OptimizerThresholds, SegmentOptimizer,</div><div> };</div><div> use crate::collection_manager::optimizers::{Tracker, TrackerLog, TrackerStatus};</div><div class="diff-removed">-use crate::common::stoppable_task::{StoppableTaskHandle, spawn_stoppable};</div><div class="diff-added">+use crate::common::stoppable_task::{spawn_stoppable, StoppableTaskHandle};</div><div> use crate::config::CollectionParams;</div><div class="diff-removed">-use crate::operations::CollectionUpdateOperations;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult};</div><div class="diff-added">+use crate::operations::CollectionUpdateOperations;</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::local_shard::LocalShardClocks;</div><div> use crate::wal::WalError;</div><div> use crate::wal_delta::LockedWal;</div><div> </div><div class="diff-removed">-/// Interval at which the optimizer worker cleans up old optimization handles</div><div class="diff-removed">-///</div><div class="diff-removed">-/// The longer the duration, the longer it  takes for panicked tasks to be reported.</div><div> const OPTIMIZER_CLEANUP_INTERVAL: Duration = Duration::from_secs(5);</div><div> </div><div> pub type Optimizer = dyn SegmentOptimizer + Sync + Send;</div><div class="diff-info">@@ -56,6 +53,7 @@     pub wait: bool,</div><div>     /// Callback notification channel</div><div>     pub sender: Option<oneshot::Sender<CollectionResult<usize>>>,</div><div class="diff-added">+    /// Hardware measurements accumulator</div><div>     pub hw_measurements: HwMeasurementAcc,</div><div> }</div><div> </div><div class="diff-info">@@ -93,8 +91,7 @@     optimizers_log: Arc<Mutex<TrackerLog>>,</div><div>     /// Total number of optimized points since last start</div><div>     total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-    /// Global CPU budget in number of cores for all optimization tasks.</div><div class="diff-removed">-    /// Assigns CPU permits to tasks to limit overall resource utilization.</div><div class="diff-added">+    /// Global resource budget for optimization tasks.</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     /// How frequent can we flush data</div><div>     /// This parameter depends on the optimizer config and should be updated accordingly.</div><div class="diff-info">@@ -104,7 +101,7 @@     update_worker: Option<JoinHandle<()>>,</div><div>     /// Process, that listens for post-update signals and performs optimization</div><div>     optimizer_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Process that periodically flushes segments and tries to truncate wal</div><div class="diff-added">+    /// WAL & flush worker</div><div>     flush_worker: Option<JoinHandle<()>>,</div><div>     /// Sender to stop flush worker</div><div>     flush_stop: Option<oneshot::Sender<()>>,</div><div class="diff-info">@@ -170,6 +167,7 @@ </div><div>     pub fn run_workers(&mut self, update_receiver: Receiver<UpdateSignal>) {</div><div>         let (tx, rx) = mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-added">+</div><div>         self.optimizer_worker = Some(self.runtime_handle.spawn(Self::optimization_worker_fn(</div><div>             self.optimizers.clone(),</div><div>             tx.clone(),</div><div class="diff-info">@@ -184,12 +182,14 @@             self.has_triggered_optimizers.clone(),</div><div>             self.payload_index_schema.clone(),</div><div>         )));</div><div class="diff-added">+</div><div>         self.update_worker = Some(self.runtime_handle.spawn(Self::update_worker_fn(</div><div>             update_receiver,</div><div>             tx,</div><div>             self.wal.clone(),</div><div>             self.segments.clone(),</div><div>         )));</div><div class="diff-added">+</div><div>         let (flush_tx, flush_rx) = oneshot::channel();</div><div>         self.flush_worker = Some(self.runtime_handle.spawn(Self::flush_worker(</div><div>             self.segments.clone(),</div><div class="diff-info">@@ -203,16 +203,9 @@         self.flush_stop = Some(flush_tx);</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn stop_flush_worker(&mut self) {</div><div class="diff-removed">-        if let Some(flush_stop) = self.flush_stop.take() {</div><div class="diff-removed">-            if let Err(()) = flush_stop.send(()) {</div><div class="diff-removed">-                warn!("Failed to stop flush worker as it is already stopped.");</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Gracefully wait before all optimizations stop</div><div>     /// If some optimization is in progress - it will be finished before shutdown.</div><div class="diff-added">+    /// Blocking function.</div><div>     pub async fn wait_workers_stops(&mut self) -> CollectionResult<()> {</div><div>         let maybe_handle = self.update_worker.take();</div><div>         if let Some(handle) = maybe_handle {</div><div class="diff-info">@@ -222,11 +215,6 @@         if let Some(handle) = maybe_handle {</div><div>             handle.await?;</div><div>         }</div><div class="diff-removed">-        let maybe_handle = self.flush_worker.take();</div><div class="diff-removed">-        if let Some(handle) = maybe_handle {</div><div class="diff-removed">-            handle.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         let mut opt_handles_guard = self.optimization_handles.lock().await;</div><div>         let opt_handles = std::mem::take(&mut *opt_handles_guard);</div><div>         let stopping_handles = opt_handles</div><div class="diff-info">@@ -237,7 +225,6 @@         for res in stopping_handles {</div><div>             res.await?;</div><div>         }</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -280,7 +267,6 @@     {</div><div>         let mut scheduled_segment_ids = HashSet::<_>::default();</div><div>         let mut handles = vec![];</div><div class="diff-removed">-</div><div>         'outer: for optimizer in optimizers.iter() {</div><div>             loop {</div><div>                 // Return early if we reached the optimization job limit</div><div class="diff-info">@@ -321,7 +307,6 @@                 );</div><div> </div><div>                 let permit_callback = callback.clone();</div><div class="diff-removed">-</div><div>                 permit.set_on_release(move || {</div><div>                     // Notify scheduler that resource budget changed</div><div>                     permit_callback(false);</div><div class="diff-info">@@ -339,7 +324,6 @@                     // Stoppable task</div><div>                     {</div><div>                         let resource_budget = optimizer_resource_budget.clone();</div><div class="diff-removed">-                        let segments = segments.clone();</div><div>                         move |stopped| {</div><div>                             // Track optimizer status</div><div>                             let tracker = Tracker::start(optimizer.as_ref().name(), nsi.clone());</div><div class="diff-info">@@ -409,8 +393,206 @@                 handles.push(handle);</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div>         handles</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub(crate) async fn process_optimization(</div><div class="diff-added">+        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-added">+        optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-added">+        total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-added">+        optimizer_resource_budget: &ResourceBudget,</div><div class="diff-added">+        sender: Sender<OptimizerSignal>,</div><div class="diff-added">+        limit: usize,</div><div class="diff-added">+    ) {</div><div class="diff-added">+        let mut new_handles = Self::launch_optimization(</div><div class="diff-added">+            optimizers.clone(),</div><div class="diff-added">+            optimizers_log,</div><div class="diff-added">+            total_optimized_points,</div><div class="diff-added">+            optimizer_resource_budget,</div><div class="diff-added">+            segments.clone(),</div><div class="diff-added">+            move |_optimization_result| {</div><div class="diff-added">+                // After optimization is finished, we still need to check if there are</div><div class="diff-added">+                // some further optimizations possible.</div><div class="diff-added">+                // If receiver is already dead - we do not care.</div><div class="diff-added">+                // If channel is full - optimization will be triggered by some other signal</div><div class="diff-added">+                let _ = sender.try_send(OptimizerSignal::Nop);</div><div class="diff-added">+            },</div><div class="diff-added">+            Some(limit),</div><div class="diff-added">+        );</div><div class="diff-added">+        let mut handles = optimization_handles.lock().await;</div><div class="diff-added">+        handles.append(&mut new_handles);</div><div class="diff-added">+        handles.retain(|h| !h.is_finished())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Cleanup finalized optimization task handles</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// This finds and removes completed tasks from our list of optimization handles.</div><div class="diff-added">+    /// It also propagates any panics (and unknown errors) so we properly handle them if desired.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// It is essential to call this every once in a while for handling panics in time.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// Returns true if any optimization handle was finished, joined and removed.</div><div class="diff-added">+    async fn cleanup_optimization_handles(</div><div class="diff-added">+        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-added">+    ) -> bool {</div><div class="diff-added">+        // Remove finished handles</div><div class="diff-added">+        let finished_handles: Vec<_> = {</div><div class="diff-added">+            let mut handles = optimization_handles.lock().await;</div><div class="diff-added">+            (0..handles.len())</div><div class="diff-added">+                .filter(|i| handles[*i].is_finished())</div><div class="diff-added">+                .collect::<Vec<_>>()</div><div class="diff-added">+                .into_iter()</div><div class="diff-added">+                .rev()</div><div class="diff-added">+                .map(|i| handles.swap_remove(i))</div><div class="diff-added">+                .collect()</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        let finished_any = !finished_handles.is_empty();</div><div class="diff-added">+</div><div class="diff-added">+        // Finalize all finished handles to propagate panics</div><div class="diff-added">+        for handle in finished_handles {</div><div class="diff-added">+            handle.join_and_handle_panic().await;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        finished_any</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div class="diff-added">+    async fn optimization_worker_fn(</div><div class="diff-added">+        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-added">+        sender: Sender<OptimizerSignal>,</div><div class="diff-added">+        mut receiver: Receiver<OptimizerSignal>,</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+        wal: LockedWal,</div><div class="diff-added">+        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-added">+        optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-added">+        total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-added">+        optimizer_resource_budget: ResourceBudget,</div><div class="diff-added">+        max_handles: Option<usize>,</div><div class="diff-added">+        has_triggered_optimizers: Arc<AtomicBool>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+    ) {</div><div class="diff-added">+        let max_handles = max_handles.unwrap_or(usize::MAX);</div><div class="diff-added">+        let max_indexing_threads = optimizers</div><div class="diff-added">+            .first()</div><div class="diff-added">+            .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div class="diff-added">+            .unwrap_or_default();</div><div class="diff-added">+</div><div class="diff-added">+        // Asynchronous task to trigger optimizers once CPU budget is available again</div><div class="diff-added">+        let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div class="diff-added">+</div><div class="diff-added">+        loop {</div><div class="diff-added">+            let result = timeout(OPTIMIZER_CLEANUP_INTERVAL, receiver.recv()).await;</div><div class="diff-added">+</div><div class="diff-added">+            let cleaned_any =</div><div class="diff-added">+                Self::cleanup_optimization_handles(optimization_handles.clone()).await;</div><div class="diff-added">+</div><div class="diff-added">+            // Either continue below here with the worker, or reloop/break</div><div class="diff-added">+            // Decision logic doing one of three things:</div><div class="diff-added">+            // 1. run optimizers</div><div class="diff-added">+            // 2. reloop and wait for next signal</div><div class="diff-added">+            // 3. break here and stop the optimization worker</div><div class="diff-added">+            let ignore_max_handles = match result {</div><div class="diff-added">+                // Regular optimizer signal: run optimizers: do 1</div><div class="diff-added">+                Ok(Some(OptimizerSignal::Operation(_))) => false,</div><div class="diff-added">+                // Optimizer signal ignoring max handles: do 1</div><div class="diff-added">+                Ok(Some(OptimizerSignal::Nop)) => true,</div><div class="diff-added">+                // Hit optimizer cleanup interval, did clean up a task: do 1</div><div class="diff-added">+                Err(Elapsed { .. }) if cleaned_any => {</div><div class="diff-added">+                    // This branch prevents a race condition where optimizers would get stuck</div><div class="diff-added">+                    // If the optimizer cleanup interval was triggered and we did clean any task we</div><div class="diff-added">+                    // must run optimizers now. If we don't there may not be any other ongoing</div><div class="diff-added">+                    // tasks that'll trigger this for us. If we don't run optimizers here we might</div><div class="diff-added">+                    // get stuck into yellow state until a new update operation is received.</div><div class="diff-added">+                    // See: <https://github.com/qdrant/qdrant/pull/5111></div><div class="diff-added">+                    log::warn!(</div><div class="diff-added">+                        "Cleaned a optimization handle after timeout, explicitly triggering optimizers",</div><div class="diff-added">+                    );</div><div class="diff-added">+                    true</div><div class="diff-added">+                }</div><div class="diff-added">+                // Hit optimizer cleanup interval, did not clean up a task: do 2</div><div class="diff-added">+                Err(Elapsed { .. }) => continue,</div><div class="diff-added">+                // Channel closed or received stop signal: do 3</div><div class="diff-added">+                Ok(None | Some(OptimizerSignal::Stop)) => break,</div><div class="diff-added">+            };</div><div class="diff-added">+</div><div class="diff-added">+            has_triggered_optimizers.store(true, Ordering::Relaxed);</div><div class="diff-added">+</div><div class="diff-added">+            // Ensure we have at least one appendable segment with enough capacity</div><div class="diff-added">+            // Source required parameters from first optimizer</div><div class="diff-added">+            if let Some(optimizer) = optimizers.first() {</div><div class="diff-added">+                let result = Self::ensure_appendable_segment_with_capacity(</div><div class="diff-added">+                    &segments,</div><div class="diff-added">+                    optimizer.segments_path(),</div><div class="diff-added">+                    &optimizer.collection_params(),</div><div class="diff-added">+                    optimizer.threshold_config(),</div><div class="diff-added">+                    &payload_index_schema.read(),</div><div class="diff-added">+                );</div><div class="diff-added">+                if let Err(err) = result {</div><div class="diff-added">+                    log::error!(</div><div class="diff-added">+                        "Failed to ensure there are appendable segments with capacity: {err}"</div><div class="diff-added">+                    );</div><div class="diff-added">+                    panic!("Failed to ensure there are appendable segments with capacity: {err}");</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            // If not forcing, wait on next signal if we have too many handles</div><div class="diff-added">+            if !ignore_max_handles && optimization_handles.lock().await.len() >= max_handles {</div><div class="diff-added">+                continue;</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            if Self::try_recover(segments.clone(), wal.clone())</div><div class="diff-added">+                .await</div><div class="diff-added">+                .is_err()</div><div class="diff-added">+            {</div><div class="diff-added">+                continue;</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            // Continue if we have enough resource budget available to start an optimization</div><div class="diff-added">+            // Otherwise skip now and start a task to trigger the optimizer again once resource</div><div class="diff-added">+            // budget becomes available</div><div class="diff-added">+            let desired_cpus = 0;</div><div class="diff-added">+            let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-added">+            if !optimizer_resource_budget.has_budget(desired_cpus, desired_io) {</div><div class="diff-added">+                let trigger_active = resource_available_trigger</div><div class="diff-added">+                    .as_ref()</div><div class="diff-added">+                    .is_some_and(|t| !t.is_finished());</div><div class="diff-added">+                if !trigger_active {</div><div class="diff-added">+                    resource_available_trigger.replace(trigger_optimizers_on_resource_budget(</div><div class="diff-added">+                        optimizer_resource_budget.clone(),</div><div class="diff-added">+                        desired_cpus,</div><div class="diff-added">+                        desired_io,</div><div class="diff-added">+                        sender.clone(),</div><div class="diff-added">+                    ));</div><div class="diff-added">+                }</div><div class="diff-added">+                continue;</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            // Determine optimization handle limit based on max handles we allow</div><div class="diff-added">+            // Not related to the CPU budget, but a different limit for the maximum number</div><div class="diff-added">+            // of concurrent concrete optimizations per shard as configured by the user in</div><div class="diff-added">+            // the Qdrant(configuration).</div><div class="diff-added">+            // Skip if we reached limit, an ongoing optimization that finishes will trigger this loop again</div><div class="diff-added">+            let limit = max_handles.saturating_sub(optimization_handles.lock().await.len());</div><div class="diff-added">+            if limit == 0 {</div><div class="diff-added">+                log::trace!("Skipping optimization check, we reached optimization thread limit");</div><div class="diff-added">+                continue;</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            Self::process_optimization(</div><div class="diff-added">+                optimizers.clone(),</div><div class="diff-added">+                segments.clone(),</div><div class="diff-added">+                optimization_handles.clone(),</div><div class="diff-added">+                optimizers_log.clone(),</div><div class="diff-added">+                total_optimized_points.clone(),</div><div class="diff-added">+                &optimizer_resource_budget,</div><div class="diff-added">+                sender.clone(),</div><div class="diff-added">+                limit,</div><div class="diff-added">+            )</div><div class="diff-added">+            .await;</div><div class="diff-added">+        }</div><div>     }</div><div> </div><div>     /// Ensure there is at least one appendable segment with enough capacity</div><div class="diff-info">@@ -477,205 +659,6 @@         (has_triggered_any_optimizers, has_suboptimal_optimizers)</div><div>     }</div><div> </div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub(crate) async fn process_optimization(</div><div class="diff-removed">-        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-        optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-removed">-        total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: &ResourceBudget,</div><div class="diff-removed">-        sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-        limit: usize,</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-        let mut new_handles = Self::launch_optimization(</div><div class="diff-removed">-            optimizers.clone(),</div><div class="diff-removed">-            optimizers_log,</div><div class="diff-removed">-            total_optimized_points,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            segments.clone(),</div><div class="diff-removed">-            move |_optimization_result| {</div><div class="diff-removed">-                // After optimization is finished, we still need to check if there are</div><div class="diff-removed">-                // some further optimizations possible.</div><div class="diff-removed">-                // If receiver is already dead - we do not care.</div><div class="diff-removed">-                // If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-                let _ = sender.try_send(OptimizerSignal::Nop);</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(limit),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-        handles.append(&mut new_handles);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Cleanup finalized optimization task handles</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This finds and removes completed tasks from our list of optimization handles.</div><div class="diff-removed">-    /// It also propagates any panics (and unknown errors) so we properly handle them if desired.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It is essential to call this every once in a while for handling panics in time.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns true if any optimization handle was finished, joined and removed.</div><div class="diff-removed">-    async fn cleanup_optimization_handles(</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    ) -> bool {</div><div class="diff-removed">-        // Remove finished handles</div><div class="diff-removed">-        let finished_handles: Vec<_> = {</div><div class="diff-removed">-            let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-            (0..handles.len())</div><div class="diff-removed">-                .filter(|i| handles[*i].is_finished())</div><div class="diff-removed">-                .collect::<Vec<_>>()</div><div class="diff-removed">-                .into_iter()</div><div class="diff-removed">-                .rev()</div><div class="diff-removed">-                .map(|i| handles.swap_remove(i))</div><div class="diff-removed">-                .collect()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let finished_any = !finished_handles.is_empty();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Finalize all finished handles to propagate panics</div><div class="diff-removed">-        for handle in finished_handles {</div><div class="diff-removed">-            handle.join_and_handle_panic().await;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        finished_any</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    async fn optimization_worker_fn(</div><div class="diff-removed">-        optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-        mut receiver: Receiver<OptimizerSignal>,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-        optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-removed">-        total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        max_handles: Option<usize>,</div><div class="diff-removed">-        has_triggered_optimizers: Arc<AtomicBool>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-        let max_handles = max_handles.unwrap_or(usize::MAX);</div><div class="diff-removed">-        let max_indexing_threads = optimizers</div><div class="diff-removed">-            .first()</div><div class="diff-removed">-            .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div class="diff-removed">-            .unwrap_or_default();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Asynchronous task to trigger optimizers once CPU budget is available again</div><div class="diff-removed">-        let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div class="diff-removed">-</div><div class="diff-removed">-        loop {</div><div class="diff-removed">-            let result = timeout(OPTIMIZER_CLEANUP_INTERVAL, receiver.recv()).await;</div><div class="diff-removed">-</div><div class="diff-removed">-            let cleaned_any =</div><div class="diff-removed">-                Self::cleanup_optimization_handles(optimization_handles.clone()).await;</div><div class="diff-removed">-</div><div class="diff-removed">-            // Either continue below here with the worker, or reloop/break</div><div class="diff-removed">-            // Decision logic doing one of three things:</div><div class="diff-removed">-            // 1. run optimizers</div><div class="diff-removed">-            // 2. reloop and wait for next signal</div><div class="diff-removed">-            // 3. break here and stop the optimization worker</div><div class="diff-removed">-            let ignore_max_handles = match result {</div><div class="diff-removed">-                // Regular optimizer signal: run optimizers: do 1</div><div class="diff-removed">-                Ok(Some(OptimizerSignal::Operation(_))) => false,</div><div class="diff-removed">-                // Optimizer signal ignoring max handles: do 1</div><div class="diff-removed">-                Ok(Some(OptimizerSignal::Nop)) => true,</div><div class="diff-removed">-                // Hit optimizer cleanup interval, did clean up a task: do 1</div><div class="diff-removed">-                Err(Elapsed { .. }) if cleaned_any => {</div><div class="diff-removed">-                    // This branch prevents a race condition where optimizers would get stuck</div><div class="diff-removed">-                    // If the optimizer cleanup interval was triggered and we did clean any task we</div><div class="diff-removed">-                    // must run optimizers now. If we don't there may not be any other ongoing</div><div class="diff-removed">-                    // tasks that'll trigger this for us. If we don't run optimizers here we might</div><div class="diff-removed">-                    // get stuck into yellow state until a new update operation is received.</div><div class="diff-removed">-                    // See: <https://github.com/qdrant/qdrant/pull/5111></div><div class="diff-removed">-                    log::warn!(</div><div class="diff-removed">-                        "Cleaned a optimization handle after timeout, explicitly triggering optimizers",</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    true</div><div class="diff-removed">-                }</div><div class="diff-removed">-                // Hit optimizer cleanup interval, did not clean up a task: do 2</div><div class="diff-removed">-                Err(Elapsed { .. }) => continue,</div><div class="diff-removed">-                // Channel closed or received stop signal: do 3</div><div class="diff-removed">-                Ok(None | Some(OptimizerSignal::Stop)) => break,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            has_triggered_optimizers.store(true, Ordering::Relaxed);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Ensure we have at least one appendable segment with enough capacity</div><div class="diff-removed">-            // Source required parameters from first optimizer</div><div class="diff-removed">-            if let Some(optimizer) = optimizers.first() {</div><div class="diff-removed">-                let result = Self::ensure_appendable_segment_with_capacity(</div><div class="diff-removed">-                    &segments,</div><div class="diff-removed">-                    optimizer.segments_path(),</div><div class="diff-removed">-                    &optimizer.collection_params(),</div><div class="diff-removed">-                    optimizer.threshold_config(),</div><div class="diff-removed">-                    &payload_index_schema.read(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-                if let Err(err) = result {</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Failed to ensure there are appendable segments with capacity: {err}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    panic!("Failed to ensure there are appendable segments with capacity: {err}");</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // If not forcing, wait on next signal if we have too many handles</div><div class="diff-removed">-            if !ignore_max_handles && optimization_handles.lock().await.len() >= max_handles {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            if Self::try_recover(segments.clone(), wal.clone())</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .is_err()</div><div class="diff-removed">-            {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Continue if we have enough resource budget available to start an optimization</div><div class="diff-removed">-            // Otherwise skip now and start a task to trigger the optimizer again once resource</div><div class="diff-removed">-            // budget becomes available</div><div class="diff-removed">-            let desired_cpus = 0;</div><div class="diff-removed">-            let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-removed">-            if !optimizer_resource_budget.has_budget(desired_cpus, desired_io) {</div><div class="diff-removed">-                let trigger_active = resource_available_trigger</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .is_some_and(|t| !t.is_finished());</div><div class="diff-removed">-                if !trigger_active {</div><div class="diff-removed">-                    resource_available_trigger.replace(trigger_optimizers_on_resource_budget(</div><div class="diff-removed">-                        optimizer_resource_budget.clone(),</div><div class="diff-removed">-                        desired_cpus,</div><div class="diff-removed">-                        desired_io,</div><div class="diff-removed">-                        sender.clone(),</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Determine optimization handle limit based on max handles we allow</div><div class="diff-removed">-            // Not related to the CPU budget, but a different limit for the maximum number</div><div class="diff-removed">-            // of concurrent concrete optimizations per shard as configured by the user in</div><div class="diff-removed">-            // the Qdrant configuration.</div><div class="diff-removed">-            // Skip if we reached limit, an ongoing optimization that finishes will trigger this loop again</div><div class="diff-removed">-            let limit = max_handles.saturating_sub(optimization_handles.lock().await.len());</div><div class="diff-removed">-            if limit == 0 {</div><div class="diff-removed">-                log::trace!("Skipping optimization check, we reached optimization thread limit");</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            Self::process_optimization(</div><div class="diff-removed">-                optimizers.clone(),</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                optimization_handles.clone(),</div><div class="diff-removed">-                optimizers_log.clone(),</div><div class="diff-removed">-                total_optimized_points.clone(),</div><div class="diff-removed">-                &optimizer_resource_budget,</div><div class="diff-removed">-                sender.clone(),</div><div class="diff-removed">-                limit,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await;</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     async fn update_worker_fn(</div><div>         mut receiver: Receiver<UpdateSignal>,</div><div>         optimize_sender: Sender<OptimizerSignal>,</div><div class="diff-info">@@ -772,7 +755,7 @@                     debug!("Stopping flush worker for shard {}", shard_path.display());</div><div>                     return;</div><div>                 }</div><div class="diff-removed">-            }</div><div class="diff-added">+            };</div><div> </div><div>             trace!("Attempting flushing");</div><div>             let wal_flash_job = wal.lock().await.flush_async();</div><div class="diff-info">@@ -823,7 +806,7 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Returns confirmed version after flush of all segments</div><div class="diff-added">+    /// Returns confirmed version after flush of all segements</div><div>     ///</div><div>     /// # Errors</div><div>     /// Returns an error on flush failure</div><div class="diff-info">@@ -837,7 +820,7 @@     }</div><div> }</div><div> </div><div class="diff-removed">-/// Trigger optimizers when CPU budget is available</div><div class="diff-added">+/// Trigger optimizers when resource budget is available</div><div> fn trigger_optimizers_on_resource_budget(</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     desired_cpus: usize,</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    