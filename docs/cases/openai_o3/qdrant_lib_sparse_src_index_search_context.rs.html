<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/sparse/src/index/search_context.rs - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/sparse/src/index/search_context.rs</h1>
        <h2>Model: o3</h2>
        <p><a href="../../models/openai_o3.html">All o3 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 73797</p>
                <p><strong>Native Prompt Tokens:</strong> 73775</p>
                <p><strong>Native Completion Tokens:</strong> 8802</p>
                <p><strong>Native Tokens Reasoning:</strong> 1088</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $1.1443215</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/qdrant_lib_sparse_src_index_search_context.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_sparse_src_index_search_context.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/qdrant_lib_sparse_src_index_search_context.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8be5822c..8970de89 100644</div><div class="diff-header">--- a/qdrant_lib_sparse_src_index_search_context.rs_expectedoutput.txt (expected):tmp/tmp6334cie5_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_sparse_src_index_search_context.rs_extracted.txt (actual):tmp/tmpct2g8r0o_actual.txt	</div><div class="diff-info">@@ -1,4 +1,5 @@</div><div class="diff-removed">-use std::cmp::{Ordering, max, min};</div><div class="diff-added">+use std::cmp::{max, min, Ordering};</div><div class="diff-added">+use std::mem::size_of;</div><div> use std::sync::atomic::AtomicBool;</div><div> use std::sync::atomic::Ordering::Relaxed;</div><div> </div><div class="diff-info">@@ -8,7 +9,7 @@ use common::types::{PointOffsetType, ScoredPointOffset};</div><div> </div><div> use super::posting_list_common::PostingListIter;</div><div> use crate::common::scores_memory_pool::PooledScoresHandle;</div><div class="diff-removed">-use crate::common::sparse_vector::{RemappedSparseVector, score_vectors};</div><div class="diff-added">+use crate::common::sparse_vector::{score_vectors, RemappedSparseVector};</div><div> use crate::common::types::{DimId, DimWeight};</div><div> use crate::index::inverted_index::InvertedIndex;</div><div> use crate::index::posting_list::PostingListIterator;</div><div class="diff-info">@@ -132,8 +133,9 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div> </div><div>             // Accumulate the sum of the length of the retrieved sparse vector and the query vector length</div><div>             // as measurement for CPU usage of plain search.</div><div class="diff-removed">-            cpu_counter</div><div class="diff-removed">-                .incr_delta(self.query.indices.len() + values.len() * size_of::<DimWeight>());</div><div class="diff-added">+            cpu_counter.incr_delta(</div><div class="diff-added">+                self.query.indices.len() + values.len() * size_of::<DimWeight>(),</div><div class="diff-added">+            );</div><div> </div><div>             // reconstruct sparse vector and score against query</div><div>             let sparse_score =</div><div class="diff-info">@@ -297,7 +299,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div> </div><div>             // prepare next iterator of batched ids</div><div>             let Some(start_batch_id) = self.min_record_id else {</div><div class="diff-removed">-                break;</div><div class="diff-added">+                break; // all posting lists exhausted</div><div>             };</div><div> </div><div>             // compute batch range of contiguous ids for the next batch</div><div class="diff-info">@@ -383,7 +385,8 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>                             // check against the max possible score using the `max_next_weight`</div><div>                             // we can under prune as we should actually check the best score up to `next_min_id` - 1 only</div><div>                             // instead of the max possible score but it is not possible to know the best score up to `next_min_id` - 1</div><div class="diff-removed">-                            let max_weight_from_list = element.weight.max(element.max_next_weight);</div><div class="diff-added">+                            let max_weight_from_list =</div><div class="diff-added">+                                element.weight.max(element.max_next_weight);</div><div>                             let max_score_contribution =</div><div>                                 max_weight_from_list * longest_posting_iterator.query_weight;</div><div>                             if max_score_contribution <= min_score {</div><div class="diff-info">@@ -409,8 +412,9 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>                         max_weight_from_list * longest_posting_iterator.query_weight;</div><div>                     if max_score_contribution <= min_score {</div><div>                         // prune to the end!</div><div class="diff-removed">-                        let longest_posting_iterator = &mut self.postings_iterators[0];</div><div class="diff-removed">-                        longest_posting_iterator.posting_list_iterator.skip_to_end();</div><div class="diff-added">+                        let longest_posting_iterator =</div><div class="diff-added">+                            &mut self.postings_iterators[0].posting_list_iterator;</div><div class="diff-added">+                        longest_posting_iterator.skip_to_end();</div><div>                         return true;</div><div>                     }</div><div>                 }</div><div class="diff-info">@@ -419,4 +423,500 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         // no pruning took place</div><div>         false</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+    /// Return the current hardware measurement counter.</div><div class="diff-added">+    pub fn take_hardware_counter(&self) -> HardwareCounterCell {</div><div class="diff-added">+        self.hardware_counter.take()</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+#[cfg(test)]</div><div class="diff-added">+#[generic_tests::define]</div><div class="diff-added">+mod tests {</div><div class="diff-added">+    use std::any::TypeId;</div><div class="diff-added">+    use std::borrow::Cow;</div><div class="diff-added">+    use std::sync::OnceLock;</div><div class="diff-added">+</div><div class="diff-added">+    use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-added">+    use rand::Rng;</div><div class="diff-added">+    use tempfile::TempDir;</div><div class="diff-added">+</div><div class="diff-added">+    use super::*;</div><div class="diff-added">+    use crate::common::scores_memory_pool::ScoresMemoryPool;</div><div class="diff-added">+    use crate::common::sparse_vector::SparseVector;</div><div class="diff-added">+    use crate::common::sparse_vector_fixture::random_sparse_vector;</div><div class="diff-added">+    use crate::common::types::QuantizedU8;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram_builder::InvertedIndexBuilder;</div><div class="diff-added">+</div><div class="diff-added">+    // ---- Test instantiations ----</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexRam>)]</div><div class="diff-added">+    mod ram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexMmap>)]</div><div class="diff-added">+    mod mmap {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexImmutableRam>)]</div><div class="diff-added">+    mod iram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<f32>>)]</div><div class="diff-added">+    mod iram_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<half::f16>>)]</div><div class="diff-added">+    mod iram_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<u8>>)]</div><div class="diff-added">+    mod iram_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<QuantizedU8>>)]</div><div class="diff-added">+    mod iram_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<f32>>)]</div><div class="diff-added">+    mod mmap_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<half::f16>>)]</div><div class="diff-added">+    mod mmap_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<u8>>)]</div><div class="diff-added">+    mod mmap_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<QuantizedU8>>)]</div><div class="diff-added">+    mod mmap_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    // --- End of test instantiations ---</div><div class="diff-added">+</div><div class="diff-added">+    static TEST_SCORES_POOL: OnceLock<ScoresMemoryPool> = OnceLock::new();</div><div class="diff-added">+</div><div class="diff-added">+    fn get_pooled_scores() -> PooledScoresHandle<'static> {</div><div class="diff-added">+        TEST_SCORES_POOL</div><div class="diff-added">+            .get_or_init(ScoresMemoryPool::default)</div><div class="diff-added">+            .get()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Match all filter condition for testing</div><div class="diff-added">+    fn match_all(_p: PointOffsetType) -> bool {</div><div class="diff-added">+        true</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Helper struct to store both an index and a temporary directory</div><div class="diff-added">+    #[allow(dead_code)]</div><div class="diff-added">+    struct TestIndex<I: InvertedIndex> {</div><div class="diff-added">+        index: I,</div><div class="diff-added">+        _temp_dir: TempDir,</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    impl<I: InvertedIndex> TestIndex<I> {</div><div class="diff-added">+        fn from_ram(ram_index: InvertedIndexRam) -> Self {</div><div class="diff-added">+            let temp_dir = tempfile::Builder::new()</div><div class="diff-added">+                .prefix("test_index_dir")</div><div class="diff-added">+                .tempdir()</div><div class="diff-added">+                .unwrap();</div><div class="diff-added">+            TestIndex {</div><div class="diff-added">+                index: I::from_ram_index(Cow::Owned(ram_index), &temp_dir).unwrap(),</div><div class="diff-added">+                _temp_dir: temp_dir,</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Round scores to allow some quantization errors</div><div class="diff-added">+    fn round_scores<I: 'static>(mut scores: Vec<ScoredPointOffset>) -> Vec<ScoredPointOffset> {</div><div class="diff-added">+        let errors_allowed_for = [</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedImmutableRam<QuantizedU8>>(),</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedMmap<QuantizedU8>>(),</div><div class="diff-added">+        ];</div><div class="diff-added">+        if errors_allowed_for.contains(&TypeId::of::<I>()) {</div><div class="diff-added">+            let precision = 0.25;</div><div class="diff-added">+            scores.iter_mut().for_each(|score| {</div><div class="diff-added">+                score.score = (score.score / precision).round() * precision;</div><div class="diff-added">+            });</div><div class="diff-added">+            scores</div><div class="diff-added">+        } else {</div><div class="diff-added">+            scores</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn test_empty_query<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram(InvertedIndexRam::empty());</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector::default(), // empty query vector</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            HardwareCounterCell::new(),</div><div class="diff-added">+        );</div><div class="diff-added">+        assert_eq!(search_context.search(&match_all), Vec::new());</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // len(QueryVector)=3 * len(vector)=3 => 3*3 => 9</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 9);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_update_test<I: InvertedIndex + 'static>() {</div><div class="diff-added">+        if TypeId::of::<I>() != TypeId::of::<InvertedIndexRam>() {</div><div class="diff-added">+            // Only InvertedIndexRam supports upserts</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let mut index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // update index with new point</div><div class="diff-added">+        index.index.upsert(</div><div class="diff-added">+            4,</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![40.0, 40.0, 40.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            None,</div><div class="diff-added">+        );</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            search_context.search(&match_all),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 120.0,</div><div class="diff-added">+                    idx: 4</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_hot_key_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 1.0)].into());</div><div class="diff-added">+            builder.add(5, [(1, 2.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 3.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 4.0)].into());</div><div class="diff-added">+            builder.add(8, [(1, 5.0)].into());</div><div class="diff-added">+            builder.add(9, [(1, 6.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+        // [ID=1] (Retrieve all 9 Vectors) => 9</div><div class="diff-added">+        // [ID=2] (Retrieve 1-3)           => 3</div><div class="diff-added">+        // [ID=3] (Retrieve 1-3)           => 3</div><div class="diff-added">+        //                       3 + 3 + 9 => 15</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 15);</div><div class="diff-added">+</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            4,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset { score: 6.0, idx: 9 },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // No difference to previous calculation because it's the same amount of score</div><div class="diff-added">+        // calculations when increasing the "top" parameter.</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 15);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_single_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_under_prune_test<I: InvertedIndex>() {</div><div class="diff-added">+        if !I::Iter::reliable_max_next_weight() {</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 40.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // one would expect this to prune up to `6` but it does not happen it practice because we are under pruning by design</div><div class="diff-added">+        // we should actually check the best score up to `6` - 1 only instead of the max possible score (40.0)</div><div class="diff-added">+        assert!(!search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(40.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 2); // 6, 7</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Generates a random inverted index with `num_vectors` vectors</div><div class="diff-added">+    #[allow(dead_code)]</div><div class="diff-added">+    fn random_inverted_index<R: Rng + ?Sized>(</div><div class="diff-added">+        rnd_gen: &mut R,</div><div class="diff-added">+        num_vectors: u32,</div><div class="diff-added">+        max_sparse_dimension: usize,</div><div class="diff-added">+    ) -> InvertedIndexRam {</div><div class="diff-added">+        let mut inverted_index_ram = InvertedIndexRam::empty();</div><div class="diff-added">+</div><div class="diff-added">+        for i in 1..=num_vectors {</div><div class="diff-added">+            let SparseVector { indices, values } =</div><div class="diff-added">+                random_sparse_vector(rnd_gen, max_sparse_dimension);</div><div class="diff-added">+            let vector = RemappedSparseVector::new(indices, values).unwrap();</div><div class="diff-added">+            inverted_index_ram.upsert(i, vector, None);</div><div class="diff-added">+        }</div><div class="diff-added">+        inverted_index_ram</div><div class="diff-added">+    }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    