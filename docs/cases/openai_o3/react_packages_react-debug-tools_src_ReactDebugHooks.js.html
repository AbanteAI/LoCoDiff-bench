<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <p><a href="../../models/openai_o3.html">‚Üê Back to o3 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 79722</p>
                <p><strong>Native Completion Tokens:</strong> 5000</p>
                <p><strong>Native Tokens Reasoning:</strong> 192</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $1.047081</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected)+++ react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual)@@ -10,7 +10,6 @@ import type {</div><div>   Awaited,</div><div>   ReactContext,</div><div class="diff-removed">-  StartTransitionOptions,</div><div>   Usable,</div><div>   Thenable,</div><div>   ReactDebugInfo,</div><div class="diff-info">@@ -25,7 +24,6 @@ </div><div> import ErrorStackParser from 'error-stack-parser';</div><div> import assign from 'shared/assign';</div><div class="diff-removed">-import ReactSharedInternals from 'shared/ReactSharedInternals';</div><div> import {</div><div>   FunctionComponent,</div><div>   SimpleMemoComponent,</div><div class="diff-info">@@ -61,16 +59,26 @@ </div><div> let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div> </div><div class="diff-added">+type MemoCache = {</div><div class="diff-added">+  data: Array<Array<mixed>>,</div><div class="diff-added">+  index: number,</div><div class="diff-added">+};</div><div class="diff-added">+</div><div class="diff-added">+type FunctionComponentUpdateQueue = {</div><div class="diff-added">+  memoCache?: MemoCache | null,</div><div class="diff-added">+};</div><div class="diff-added">+</div><div> type Hook = {</div><div>   memoizedState: any,</div><div>   next: Hook | null,</div><div class="diff-added">+  updateQueue: FunctionComponentUpdateQueue | null,</div><div> };</div><div> </div><div> function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div>   // This initializes a cache of all primitive hooks so that the top</div><div>   // most stack frames added by calling the primitive hook can be removed.</div><div>   if (primitiveStackCache === null) {</div><div class="diff-removed">-    const cache = new Map<string, Array<any>>();</div><div class="diff-added">+    const cache = new Map();</div><div>     let readHookLog;</div><div>     try {</div><div>       // Use all hooks here to add them to the hook log.</div><div class="diff-info">@@ -104,6 +112,12 @@         // This type check is for Flow only.</div><div>         Dispatcher.useMemoCache(0);</div><div>       }</div><div class="diff-added">+      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-added">+        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-added">+      }</div><div class="diff-added">+      if (typeof Dispatcher.useResourceEffect === 'function') {</div><div class="diff-added">+        Dispatcher.useResourceEffect(() => ({}), []);</div><div class="diff-added">+      }</div><div>       if (typeof Dispatcher.use === 'function') {</div><div>         // This type check is for Flow only.</div><div>         Dispatcher.use(</div><div class="diff-info">@@ -128,8 +142,9 @@ </div><div>       Dispatcher.useId();</div><div> </div><div class="diff-removed">-      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-removed">-        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-added">+      if (typeof Dispatcher.useHostTransitionStatus === 'function') {</div><div class="diff-added">+        // This type check is for Flow only.</div><div class="diff-added">+        Dispatcher.useHostTransitionStatus();</div><div>       }</div><div>     } finally {</div><div>       readHookLog = hookLog;</div><div class="diff-info">@@ -158,8 +173,6 @@ </div><div> function readContext<T>(context: ReactContext<T>): T {</div><div>   if (currentFiber === null) {</div><div class="diff-removed">-    // Hook inspection without access to the Fiber tree</div><div class="diff-removed">-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.</div><div>     return context._currentValue;</div><div>   } else {</div><div>     if (currentContextDependency === null) {</div><div class="diff-info">@@ -169,17 +182,11 @@     }</div><div> </div><div>     let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div>     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div>       value = ((currentContextDependency.memoizedValue: any): T);</div><div> </div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div>       currentContextDependency = currentContextDependency.next;</div><div>     } else {</div><div class="diff-removed">-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-removed">-      // Multiple reads of the same context were also only tracked as a single dependency.</div><div class="diff-removed">-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.</div><div>       value = context._currentValue;</div><div>     }</div><div> </div><div class="diff-info">@@ -199,7 +206,6 @@ </div><div> function use<T>(usable: Usable<T>): T {</div><div>   if (usable !== null && typeof usable === 'object') {</div><div class="diff-removed">-    // $FlowFixMe[method-unbinding]</div><div>     if (typeof usable.then === 'function') {</div><div>       const thenable: Thenable<any> = (usable: any);</div><div>       switch (thenable.status) {</div><div class="diff-info">@@ -221,8 +227,6 @@           throw rejectedError;</div><div>         }</div><div>       }</div><div class="diff-removed">-      // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-      // but we can still emit anything up until this point.</div><div>       hookLog.push({</div><div>         displayName: null,</div><div>         primitive: 'Unresolved',</div><div class="diff-info">@@ -250,7 +254,6 @@     }</div><div>   }</div><div> </div><div class="diff-removed">-  // eslint-disable-next-line react-internal/safe-string-coercion</div><div>   throw new Error('An unsupported type was passed to use(): ' + String(usable));</div><div> }</div><div> </div><div class="diff-info">@@ -275,8 +278,7 @@     hook !== null</div><div>       ? hook.memoizedState</div><div>       : typeof initialState === 'function'</div><div class="diff-removed">-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-removed">-          initialState()</div><div class="diff-added">+        ? initialState()</div><div>         : initialState;</div><div>   hookLog.push({</div><div>     displayName: null,</div><div class="diff-info">@@ -390,10 +392,6 @@   inputs: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div class="diff-removed">-  // We don't actually store the instance anywhere if there is no ref callback</div><div class="diff-removed">-  // and if there is a ref callback it might not store it but if it does we</div><div class="diff-removed">-  // have no way of knowing where. So let's only enable introspection of the</div><div class="diff-removed">-  // ref itself if it is using the object form.</div><div>   let instance: ?T = undefined;</div><div>   if (ref !== null && typeof ref === 'object') {</div><div>     instance = ref.current;</div><div class="diff-info">@@ -432,7 +430,9 @@   return callback;</div><div> }</div><div> </div><div class="diff-removed">-function useMemo<T>(</div><div class="diff-added">+function useMemo<</div><div class="diff-added">+  T,</div><div class="diff-added">+>(</div><div>   nextCreate: () => T,</div><div>   inputs: Array<mixed> | void | null,</div><div> ): T {</div><div class="diff-info">@@ -454,9 +454,6 @@   getSnapshot: () => T,</div><div>   getServerSnapshot?: () => T,</div><div> ): T {</div><div class="diff-removed">-  // useSyncExternalStore() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div>   nextHook(); // SyncExternalStore</div><div>   nextHook(); // Effect</div><div>   const value = getSnapshot();</div><div class="diff-info">@@ -475,9 +472,6 @@   boolean,</div><div>   (callback: () => void, options?: StartTransitionOptions) => void,</div><div> ] {</div><div class="diff-removed">-  // useTransition() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div>   const stateHook = nextHook();</div><div>   nextHook(); // Callback</div><div> </div><div class="diff-info">@@ -520,36 +514,6 @@     dispatcherHookName: 'Id',</div><div>   });</div><div>   return id;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-removed">-// it should not be called directly in user-generated code</div><div class="diff-removed">-function useMemoCache(size: number): Array<mixed> {</div><div class="diff-removed">-  const fiber = currentFiber;</div><div class="diff-removed">-  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-removed">-  if (fiber == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const memoCache =</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-removed">-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-removed">-  if (memoCache == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  let data = memoCache.data[memoCache.index];</div><div class="diff-removed">-  if (data === undefined) {</div><div class="diff-removed">-    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-removed">-    for (let i = 0; i < size; i++) {</div><div class="diff-removed">-      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div class="diff-removed">-  memoCache.index++;</div><div class="diff-removed">-  return data;</div><div> }</div><div> </div><div> function useOptimistic<S, A>(</div><div class="diff-info">@@ -592,7 +556,6 @@     if (</div><div>       typeof actionResult === 'object' &&</div><div>       actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div>       typeof actionResult.then === 'function'</div><div>     ) {</div><div>       const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-info">@@ -609,8 +572,6 @@           break;</div><div>         }</div><div>         default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div>           error = SuspenseException;</div><div>           debugInfo =</div><div>             thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-info">@@ -636,11 +597,7 @@     throw error;</div><div>   }</div><div> </div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div>   const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div class="diff-info">@@ -662,7 +619,6 @@     if (</div><div>       typeof actionResult === 'object' &&</div><div>       actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div>       typeof actionResult.then === 'function'</div><div>     ) {</div><div>       const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-info">@@ -679,8 +635,6 @@           break;</div><div>         }</div><div>         default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div>           error = SuspenseException;</div><div>           debugInfo =</div><div>             thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-info">@@ -706,19 +660,14 @@     throw error;</div><div>   }</div><div> </div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div>   const state = ((value: any): Awaited<S>);</div><div> </div><div class="diff-removed">-  // TODO: support displaying pending value</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div> function useHostTransitionStatus(): TransitionStatus {</div><div>   const status = readContext<TransitionStatus>(</div><div class="diff-removed">-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue</div><div>     ({</div><div class="diff-removed">-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.</div><div>       _currentValue: null,</div><div>     }: ReactContext<TransitionStatus>),</div><div>   );</div><div class="diff-info">@@ -757,37 +706,32 @@   useContext,</div><div>   useEffect,</div><div>   useImperativeHandle,</div><div class="diff-added">+  useId,</div><div class="diff-added">+  useCacheRefresh,</div><div class="diff-added">+  useActionState,</div><div class="diff-added">+  useDebugValue,</div><div class="diff-added">+  useDeferredValue,</div><div class="diff-added">+  useEffectEvent,</div><div class="diff-added">+  useFormState,</div><div class="diff-added">+  useHostTransitionStatus,</div><div class="diff-added">+  useInsertionEffect,</div><div>   useLayoutEffect,</div><div class="diff-removed">-  useInsertionEffect,</div><div>   useMemo,</div><div class="diff-added">+  useMemoCache,</div><div class="diff-added">+  useOptimistic,</div><div>   useReducer,</div><div>   useRef,</div><div>   useState,</div><div class="diff-removed">-  useDebugValue,</div><div class="diff-removed">-  useDeferredValue,</div><div class="diff-added">+  useSyncExternalStore,</div><div>   useTransition,</div><div class="diff-removed">-  useSyncExternalStore,</div><div class="diff-removed">-  useId,</div><div class="diff-removed">-  useHostTransitionStatus,</div><div class="diff-removed">-  useFormState,</div><div class="diff-removed">-  useActionState,</div><div class="diff-removed">-  useOptimistic,</div><div class="diff-removed">-  useMemoCache,</div><div class="diff-removed">-  useCacheRefresh,</div><div class="diff-removed">-  useEffectEvent,</div><div> };</div><div> </div><div class="diff-removed">-// create a proxy to throw a custom error</div><div class="diff-removed">-// in case future versions of React adds more hooks</div><div> const DispatcherProxyHandler = {</div><div>   get(target: DispatcherType, prop: string) {</div><div>     if (target.hasOwnProperty(prop)) {</div><div class="diff-removed">-      // $FlowFixMe[invalid-computed-prop]</div><div>       return target[prop];</div><div>     }</div><div>     const error = new Error('Missing method in Dispatcher: ' + prop);</div><div class="diff-removed">-    // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-    // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div>     error.name = 'ReactDebugToolsUnsupportedHookError';</div><div>     throw error;</div><div>   },</div><div class="diff-info">@@ -822,524 +766,4 @@ // Don't assume</div><div> //</div><div> // We can't assume that stack frames are nth steps away from anything.</div><div class="diff-removed">-// E.g. we can't assume that the root call shares all frames with the stack</div><div class="diff-removed">-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`</div><div class="diff-removed">-// in a wrapper constructor like a polyfill. That'll add an extra frame.</div><div class="diff-removed">-// Similar things can happen with the call to the dispatcher. The top frame</div><div class="diff-removed">-// may not be the primitive.</div><div class="diff-removed">-//</div><div class="diff-removed">-// We also can't assume that the last frame of the root call is the same</div><div class="diff-removed">-// frame as the last frame of the hook call because long stack traces can be</div><div class="diff-removed">-// truncated to a stack trace limit.</div><div class="diff-removed">-</div><div class="diff-removed">-let mostLikelyAncestorIndex = 0;</div><div class="diff-removed">-</div><div class="diff-removed">-function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {</div><div class="diff-removed">-  const source = rootStack[rootIndex].source;</div><div class="diff-removed">-  hookSearch: for (let i = 0; i < hookStack.length; i++) {</div><div class="diff-removed">-    if (hookStack[i].source === source) {</div><div class="diff-removed">-      // This looks like a match. Validate that the rest of both stack match up.</div><div class="diff-removed">-      for (</div><div class="diff-removed">-        let a = rootIndex + 1, b = i + 1;</div><div class="diff-removed">-        a < rootStack.length && b < hookStack.length;</div><div class="diff-removed">-        a++, b++</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        if (hookStack[b].source !== rootStack[a].source) {</div><div class="diff-removed">-          // If not, give up and try a different match.</div><div class="diff-removed">-          continue hookSearch;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      return i;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function findCommonAncestorIndex(rootStack: any, hookStack: any) {</div><div class="diff-removed">-  let rootIndex = findSharedIndex(</div><div class="diff-removed">-    hookStack,</div><div class="diff-removed">-    rootStack,</div><div class="diff-removed">-    mostLikelyAncestorIndex,</div><div class="diff-removed">-  );</div><div class="diff-removed">-  if (rootIndex !== -1) {</div><div class="diff-removed">-    return rootIndex;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.</div><div class="diff-removed">-  // If that takes more than 5 frames, something probably went wrong.</div><div class="diff-removed">-  for (let i = 0; i < rootStack.length && i < 5; i++) {</div><div class="diff-removed">-    rootIndex = findSharedIndex(hookStack, rootStack, i);</div><div class="diff-removed">-    if (rootIndex !== -1) {</div><div class="diff-removed">-      mostLikelyAncestorIndex = i;</div><div class="diff-removed">-      return rootIndex;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function isReactWrapper(functionName: any, wrapperName: string) {</div><div class="diff-removed">-  const hookName = parseHookName(functionName);</div><div class="diff-removed">-  if (wrapperName === 'HostTransitionStatus') {</div><div class="diff-removed">-    return hookName === wrapperName || hookName === 'FormStatus';</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  return hookName === wrapperName;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  const stackCache = getPrimitiveStackCache();</div><div class="diff-removed">-  const primitiveStack = stackCache.get(hook.primitive);</div><div class="diff-removed">-  if (primitiveStack === undefined) {</div><div class="diff-removed">-    return -1;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {</div><div class="diff-removed">-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack</div><div class="diff-removed">-    // For React Native (uses Hermes), these source fields will be identical and skipped</div><div class="diff-removed">-    if (primitiveStack[i].source !== hookStack[i].source) {</div><div class="diff-removed">-      // If the next two frames are functions called `useX` then we assume that they're part of the</div><div class="diff-removed">-      // wrappers that the React package or other packages adds around the dispatcher.</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        i < hookStack.length - 1 &&</div><div class="diff-removed">-        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        i++;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        i < hookStack.length - 1 &&</div><div class="diff-removed">-        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        i++;</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      return i;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  // Get the stack trace between the primitive hook function and</div><div class="diff-removed">-  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-removed">-  const hookStack = ErrorStackParser.parse(hook.stackError);</div><div class="diff-removed">-  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div class="diff-removed">-  const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    rootIndex === -1 ||</div><div class="diff-removed">-    primitiveIndex === -1 ||</div><div class="diff-removed">-    rootIndex - primitiveIndex < 2</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    if (primitiveIndex === -1) {</div><div class="diff-removed">-      // Something went wrong. Give up.</div><div class="diff-removed">-      return [null, null];</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      return [hookStack[primitiveIndex - 1], null];</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return [</div><div class="diff-removed">-    hookStack[primitiveIndex - 1],</div><div class="diff-removed">-    hookStack.slice(primitiveIndex, rootIndex - 1),</div><div class="diff-removed">-  ];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function parseHookName(functionName: void | string): string {</div><div class="diff-removed">-  if (!functionName) {</div><div class="diff-removed">-    return '';</div><div class="diff-removed">-  }</div><div class="diff-removed">-  let startIndex = functionName.lastIndexOf('[as ');</div><div class="diff-removed">-</div><div class="diff-removed">-  if (startIndex !== -1) {</div><div class="diff-removed">-    // Workaround for sourcemaps in Jest and Chrome.</div><div class="diff-removed">-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"</div><div class="diff-removed">-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"</div><div class="diff-removed">-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));</div><div class="diff-removed">-  }</div><div class="diff-removed">-  startIndex = functionName.lastIndexOf('.');</div><div class="diff-removed">-  if (startIndex === -1) {</div><div class="diff-removed">-    startIndex = 0;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    startIndex += 1;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('unstable_')) {</div><div class="diff-removed">-    startIndex += 'unstable_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('experimental_')) {</div><div class="diff-removed">-    startIndex += 'experimental_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex, startIndex + 3) === 'use') {</div><div class="diff-removed">-    if (functionName.length - startIndex === 3) {</div><div class="diff-removed">-      return 'Use';</div><div class="diff-removed">-    }</div><div class="diff-removed">-    startIndex += 3;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return functionName.slice(startIndex);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function buildTree(</div><div class="diff-removed">-  rootStack: any,</div><div class="diff-removed">-  readHookLog: Array<HookLogEntry>,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const rootChildren: Array<HooksNode> = [];</div><div class="diff-removed">-  let prevStack = null;</div><div class="diff-removed">-  let levelChildren = rootChildren;</div><div class="diff-removed">-  let nativeHookID = 0;</div><div class="diff-removed">-  const stackOfChildren = [];</div><div class="diff-removed">-  for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-    const hook = readHookLog[i];</div><div class="diff-removed">-    const parseResult = parseTrimmedStack(rootStack, hook);</div><div class="diff-removed">-    const primitiveFrame = parseResult[0];</div><div class="diff-removed">-    const stack = parseResult[1];</div><div class="diff-removed">-    let displayName = hook.displayName;</div><div class="diff-removed">-    if (displayName === null && primitiveFrame !== null) {</div><div class="diff-removed">-      displayName =</div><div class="diff-removed">-        parseHookName(primitiveFrame.functionName) ||</div><div class="diff-removed">-        // Older versions of React do not have sourcemaps.</div><div class="diff-removed">-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div class="diff-removed">-        parseHookName(hook.dispatcherHookName);</div><div class="diff-removed">-    }</div><div class="diff-removed">-    if (stack !== null) {</div><div class="diff-removed">-      // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-removed">-      // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div class="diff-removed">-      let commonSteps = 0;</div><div class="diff-removed">-      if (prevStack !== null) {</div><div class="diff-removed">-        // Compare the current level's stack to the new stack.</div><div class="diff-removed">-        while (commonSteps < stack.length && commonSteps < prevStack.length) {</div><div class="diff-removed">-          const stackSource = stack[stack.length - commonSteps - 1].source;</div><div class="diff-removed">-          const prevSource =</div><div class="diff-removed">-            prevStack[prevStack.length - commonSteps - 1].source;</div><div class="diff-removed">-          if (stackSource !== prevSource) {</div><div class="diff-removed">-            break;</div><div class="diff-removed">-          }</div><div class="diff-removed">-          commonSteps++;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // Pop back the stack as many steps as were not common.</div><div class="diff-removed">-        for (let j = prevStack.length - 1; j > commonSteps; j--) {</div><div class="diff-removed">-          // $FlowFixMe[incompatible-type]</div><div class="diff-removed">-          levelChildren = stackOfChildren.pop();</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // The remaining part of the new stack are custom hooks. Push them</div><div class="diff-removed">-      // to the tree.</div><div class="diff-removed">-      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div class="diff-removed">-        const children: Array<HooksNode> = [];</div><div class="diff-removed">-        const stackFrame = stack[j];</div><div class="diff-removed">-        const levelChild: HooksNode = {</div><div class="diff-removed">-          id: null,</div><div class="diff-removed">-          isStateEditable: false,</div><div class="diff-removed">-          name: parseHookName(stack[j - 1].functionName),</div><div class="diff-removed">-          value: undefined,</div><div class="diff-removed">-          subHooks: children,</div><div class="diff-removed">-          debugInfo: null,</div><div class="diff-removed">-          hookSource: {</div><div class="diff-removed">-            lineNumber: stackFrame.lineNumber,</div><div class="diff-removed">-            columnNumber: stackFrame.columnNumber,</div><div class="diff-removed">-            functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div class="diff-removed">-          },</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        levelChildren.push(levelChild);</div><div class="diff-removed">-        stackOfChildren.push(levelChildren);</div><div class="diff-removed">-        levelChildren = children;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      prevStack = stack;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-removed">-    const id =</div><div class="diff-removed">-      primitive === 'Context' ||</div><div class="diff-removed">-      primitive === 'Context (use)' ||</div><div class="diff-removed">-      primitive === 'DebugValue' ||</div><div class="diff-removed">-      primitive === 'Promise' ||</div><div class="diff-removed">-      primitive === 'Unresolved' ||</div><div class="diff-removed">-      primitive === 'HostTransitionStatus'</div><div class="diff-removed">-        ? null</div><div class="diff-removed">-        : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-removed">-    const levelChild: HooksNode = {</div><div class="diff-removed">-      id,</div><div class="diff-removed">-      isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-removed">-      value: hook.value,</div><div class="diff-removed">-      subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-removed">-      hookSource: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    const hookSource: HookSource = {</div><div class="diff-removed">-      lineNumber: null,</div><div class="diff-removed">-      functionName: null,</div><div class="diff-removed">-      fileName: null,</div><div class="diff-removed">-      columnNumber: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChildren.push(levelChild);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-removed">-  processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div class="diff-removed">-  return rootChildren;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-removed">-function processDebugValues(</div><div class="diff-removed">-  hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-  for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-removed">-    const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-removed">-      hooksTree.splice(i, 1);</div><div class="diff-removed">-      i--;</div><div class="diff-removed">-      debugValueHooksNodes.push(hooksNode);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div class="diff-removed">-  if (parentHooksNode !== null) {</div><div class="diff-removed">-    if (debugValueHooksNodes.length === 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-removed">-    } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    error instanceof Error &&</div><div class="diff-removed">-    error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-  wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-removed">-  wrapperError.cause = error;</div><div class="diff-removed">-  throw wrapperError;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooks<Props>(</div><div class="diff-removed">-  renderFunction: Props => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-removed">-  let current: null | Fiber = fiber;</div><div class="diff-removed">-  while (current) {</div><div class="diff-removed">-    if (current.tag === ContextProvider) {</div><div class="diff-removed">-      let context: ReactContext<any> = current.type;</div><div class="diff-removed">-      if ((context: any)._context !== undefined) {</div><div class="diff-removed">-        // Support inspection of pre-19+ providers.</div><div class="diff-removed">-        context = (context: any)._context;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (!contextMap.has(context)) {</div><div class="diff-removed">-        // Store the current value that we're going to restore later.</div><div class="diff-removed">-        contextMap.set(context, context._currentValue);</div><div class="diff-removed">-        // Set the inner most provider value on the context.</div><div class="diff-removed">-        context._currentValue = current.memoizedProps.value;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    current = current.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {</div><div class="diff-removed">-  contextMap.forEach((value, context) => (context._currentValue = value));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-removed">-  renderFunction: (Props, Ref) => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  ref: Ref,</div><div class="diff-removed">-  currentDispatcher: CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props, ref);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function resolveDefaultProps(Component: any, baseProps: any) {</div><div class="diff-removed">-  if (Component && Component.defaultProps) {</div><div class="diff-removed">-    // Resolve default props. Taken from ReactElement</div><div class="diff-removed">-    const props = assign({}, baseProps);</div><div class="diff-removed">-    const defaultProps = Component.defaultProps;</div><div class="diff-removed">-    for (const propName in defaultProps) {</div><div class="diff-removed">-      if (props[propName] === undefined) {</div><div class="diff-removed">-        props[propName] = defaultProps[propName];</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    return props;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return baseProps;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooksOfFiber(</div><div class="diff-removed">-  fiber: Fiber,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    fiber.tag !== FunctionComponent &&</div><div class="diff-removed">-    fiber.tag !== SimpleMemoComponent &&</div><div class="diff-removed">-    fiber.tag !== ForwardRef</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unknown Fiber. Needs to be a function component to inspect hooks.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div class="diff-removed">-  getPrimitiveStackCache();</div><div class="diff-removed">-</div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div class="diff-removed">-  currentHook = (fiber.memoizedState: Hook);</div><div class="diff-removed">-  currentFiber = fiber;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`</div><div class="diff-removed">-    const dependencies = currentFiber.dependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {</div><div class="diff-removed">-    const contextDependencies = (currentFiber: any).contextDependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      contextDependencies !== null ? contextDependencies.first : null;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unsupported React version. This is a bug in React Debug Tools.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const type = fiber.type;</div><div class="diff-removed">-  let props = fiber.memoizedProps;</div><div class="diff-removed">-  if (type !== fiber.elementType) {</div><div class="diff-removed">-    props = resolveDefaultProps(type, props);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Only used for versions of React without memoized context value in context dependencies.</div><div class="diff-removed">-  const contextMap = new Map<ReactContext<any>, any>();</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      currentContextDependency !== null &&</div><div class="diff-removed">-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      setupContexts(contextMap, fiber);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (fiber.tag === ForwardRef) {</div><div class="diff-removed">-      return inspectHooksOfForwardRef(</div><div class="diff-removed">-        type.render,</div><div class="diff-removed">-        props,</div><div class="diff-removed">-        fiber.ref,</div><div class="diff-removed">-        currentDispatcher,</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return inspectHooks(type, props, currentDispatcher);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    currentFiber = null;</div><div class="diff-removed">-    currentHook = null;</div><div class="diff-removed">-    currentContextDependency = null;</div><div class="diff-removed">-</div><div class="diff-removed">-    restoreContexts(contextMap);</div><div class="diff-removed">-  }</div><div class="diff-removed">-}+...</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    