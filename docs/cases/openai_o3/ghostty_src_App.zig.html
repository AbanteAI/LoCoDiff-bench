<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/App.zig - o3</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/App.zig</h1>
        <h2>Model: o3</h2>
        <p><a href="../../models/openai_o3.html">All o3 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> o3</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 66425</p>
                <p><strong>Native Prompt Tokens:</strong> 66628</p>
                <p><strong>Native Completion Tokens:</strong> 5740</p>
                <p><strong>Native Tokens Reasoning:</strong> 3072</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.9406740000000001</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_o3/ghostty_src_App.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_o3/ghostty_src_App.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_o3/ghostty_src_App.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 6a32b56a..8b02d4eb 100644</div><div class="diff-header">--- a/ghostty_src_App.zig_expectedoutput.txt (expected):tmp/tmpwty29f51_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_App.zig_extracted.txt (actual):tmp/tmp1r04lp3p_actual.txt	</div><div class="diff-info">@@ -1,101 +1,82 @@</div><div class="diff-removed">-//! App is the primary GUI application for ghostty. This builds the window,</div><div class="diff-removed">-//! sets up the renderer, etc. The primary run loop is started by calling</div><div class="diff-removed">-//! the "run" function.</div><div> const App = @This();</div><div> </div><div> const std = @import("std");</div><div class="diff-removed">-const builtin = @import("builtin");</div><div> const assert = std.debug.assert;</div><div> const Allocator = std.mem.Allocator;</div><div class="diff-added">+</div><div> const build_config = @import("build_config.zig");</div><div class="diff-removed">-const apprt = @import("apprt.zig");</div><div class="diff-added">+</div><div class="diff-added">+const apprt   = @import("apprt.zig");</div><div> const Surface = @import("Surface.zig");</div><div class="diff-removed">-const tracy = @import("tracy");</div><div class="diff-removed">-const input = @import("input.zig");</div><div class="diff-added">+</div><div class="diff-added">+const tracy    = @import("tracy");</div><div class="diff-added">+const input    = @import("input.zig");</div><div> const configpkg = @import("config.zig");</div><div class="diff-removed">-const Config = configpkg.Config;</div><div class="diff-added">+const Config    = configpkg.Config;</div><div class="diff-added">+</div><div> const BlockingQueue = @import("datastruct/main.zig").BlockingQueue;</div><div class="diff-removed">-const renderer = @import("renderer.zig");</div><div class="diff-removed">-const font = @import("font/main.zig");</div><div class="diff-added">+</div><div class="diff-added">+const renderer    = @import("renderer.zig");</div><div class="diff-added">+const font        = @import("font/main.zig");</div><div> const internal_os = @import("os/main.zig");</div><div class="diff-added">+</div><div> const macos = @import("macos");</div><div class="diff-removed">-const objc = @import("objc");</div><div class="diff-added">+const objc  = @import("objc");</div><div> </div><div> const log = std.log.scoped(.app);</div><div> </div><div> const SurfaceList = std.ArrayListUnmanaged(*apprt.Surface);</div><div> </div><div class="diff-removed">-/// General purpose allocator</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// GLOBAL/STRUCT STATE</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div class="diff-added">+// General purpose allocator</div><div> alloc: Allocator,</div><div> </div><div class="diff-removed">-/// The list of surfaces that are currently active.</div><div class="diff-added">+// List of active surfaces</div><div> surfaces: SurfaceList,</div><div> </div><div class="diff-removed">-/// This is true if the app that Ghostty is in is focused. This may</div><div class="diff-removed">-/// mean that no surfaces (terminals) are focused but the app is still</div><div class="diff-removed">-/// focused, i.e. may an about window. On macOS, this concept is known</div><div class="diff-removed">-/// as the "active" app while focused windows are known as the</div><div class="diff-removed">-/// "main" window.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This is used to determine if keyboard shortcuts that are non-global</div><div class="diff-removed">-/// should be processed. If the app is not focused, then we don't want</div><div class="diff-removed">-/// to process keyboard shortcuts that are not global.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This defaults to true since we assume that the app is focused when</div><div class="diff-removed">-/// Ghostty is initialized but a well behaved apprt should call</div><div class="diff-removed">-/// focusEvent to set this to the correct value right away.</div><div class="diff-added">+// Whether the application (not necessarily a surface) has focus</div><div> focused: bool = true,</div><div> </div><div class="diff-removed">-/// The last focused surface. This surface may not be valid;</div><div class="diff-removed">-/// you must always call hasSurface to validate it.</div><div class="diff-added">+// Last focused surface (may be invalid, check with hasSurface)</div><div> focused_surface: ?*Surface = null,</div><div> </div><div class="diff-removed">-/// The mailbox that can be used to send this thread messages. Note</div><div class="diff-removed">-/// this is a blocking queue so if it is full you will get errors (or block).</div><div class="diff-removed">-mailbox: Mailbox.Queue,</div><div class="diff-added">+// Message queue for cross-thread communication</div><div class="diff-added">+mailbox: BlockingQueue(Message, 64).Queue,</div><div> </div><div class="diff-removed">-/// The set of font GroupCache instances shared by surfaces with the</div><div class="diff-removed">-/// same font configuration.</div><div class="diff-added">+// Shared font grid cache (lifetime == App lifetime)</div><div> font_grid_set: font.SharedGridSet,</div><div> </div><div class="diff-removed">-// Used to rate limit desktop notifications. Some platforms (notably macOS) will</div><div class="diff-removed">-// run out of resources if desktop notifications are sent too fast and the OS</div><div class="diff-removed">-// will kill Ghostty.</div><div class="diff-removed">-last_notification_time: ?std.time.Instant = null,</div><div class="diff-removed">-last_notification_digest: u64 = 0,</div><div class="diff-added">+// Rate-limit helpers for desktop notifications</div><div class="diff-added">+last_notification_time  : ?std.time.Instant = null,</div><div class="diff-added">+last_notification_digest: u64               = 0,</div><div> </div><div class="diff-removed">-/// The conditional state of the configuration. See the equivalent field</div><div class="diff-removed">-/// in the Surface struct for more information. In this case, this applies</div><div class="diff-removed">-/// to the app-level config and as a default for new surfaces.</div><div class="diff-removed">-config_conditional_state: configpkg.ConditionalState,</div><div class="diff-added">+// Default conditional state for config (light/dark, â€¦)</div><div class="diff-added">+config_conditional_state: configpkg.ConditionalState = .{},</div><div> </div><div class="diff-removed">-/// Set to false once we've created at least one surface. This</div><div class="diff-removed">-/// never goes true again. This can be used by surfaces to determine</div><div class="diff-removed">-/// if they are the first surface.</div><div class="diff-added">+// False after first surface is created</div><div> first: bool = true,</div><div> </div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// INIT/DEINIT</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div> pub const CreateError = Allocator.Error || font.SharedGridSet.InitError;</div><div> </div><div class="diff-removed">-/// Initialize the main app instance. This creates the main window, sets</div><div class="diff-removed">-/// up the renderer state, compiles the shaders, etc. This is the primary</div><div class="diff-removed">-/// "startup" logic.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// After calling this function, well behaved apprts should then call</div><div class="diff-removed">-/// `focusEvent` to set the initial focus state of the app.</div><div class="diff-removed">-pub fn create(</div><div class="diff-removed">-    alloc: Allocator,</div><div class="diff-removed">-) CreateError!*App {</div><div class="diff-added">+pub fn create(alloc: Allocator) CreateError!*App {</div><div>     var app = try alloc.create(App);</div><div>     errdefer alloc.destroy(app);</div><div> </div><div class="diff-removed">-    var font_grid_set = try font.SharedGridSet.init(alloc);</div><div class="diff-removed">-    errdefer font_grid_set.deinit();</div><div class="diff-added">+    var grid_set = try font.SharedGridSet.init(alloc);</div><div class="diff-added">+    errdefer grid_set.deinit();</div><div> </div><div>     app.* = .{</div><div class="diff-removed">-        .alloc = alloc,</div><div class="diff-removed">-        .surfaces = .{},</div><div class="diff-removed">-        .mailbox = .{},</div><div class="diff-removed">-        .font_grid_set = font_grid_set,</div><div class="diff-added">+        .alloc              = alloc,</div><div class="diff-added">+        .surfaces           = .{},</div><div class="diff-added">+        .mailbox            = .{},</div><div class="diff-added">+        .font_grid_set      = grid_set,</div><div>         .config_conditional_state = .{},</div><div>     };</div><div>     errdefer app.surfaces.deinit(alloc);</div><div class="diff-info">@@ -104,63 +85,40 @@ pub fn create(</div><div> }</div><div> </div><div> pub fn destroy(self: *App) void {</div><div class="diff-removed">-    // Clean up all our surfaces</div><div class="diff-removed">-    for (self.surfaces.items) |surface| surface.deinit();</div><div class="diff-added">+    for (self.surfaces.items) |s| s.deinit();</div><div>     self.surfaces.deinit(self.alloc);</div><div> </div><div class="diff-removed">-    // Clean up our font group cache</div><div class="diff-removed">-    // We should have zero items in the grid set at this point because</div><div class="diff-removed">-    // destroy only gets called when the app is shutting down and this</div><div class="diff-removed">-    // should gracefully close all surfaces.</div><div class="diff-added">+    // All grids should be gone by now</div><div>     assert(self.font_grid_set.count() == 0);</div><div>     self.font_grid_set.deinit();</div><div> </div><div>     self.alloc.destroy(self);</div><div> }</div><div> </div><div class="diff-removed">-/// Tick ticks the app loop. This will drain our mailbox and process those</div><div class="diff-removed">-/// events. This should be called by the application runtime on every loop</div><div class="diff-removed">-/// tick.</div><div class="diff-removed">-pub fn tick(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-removed">-    // If any surfaces are closing, destroy them</div><div class="diff-removed">-    var i: usize = 0;</div><div class="diff-removed">-    while (i < self.surfaces.items.len) {</div><div class="diff-removed">-        const surface = self.surfaces.items[i];</div><div class="diff-removed">-        if (surface.shouldClose()) {</div><div class="diff-removed">-            surface.close(false);</div><div class="diff-removed">-            continue;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        i += 1;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Drain our mailbox</div><div class="diff-removed">-    try self.drainMailbox(rt_app);</div><div class="diff-removed">-}</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// CONFIG HANDLING</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div> </div><div class="diff-removed">-/// Update the configuration associated with the app. This can only be</div><div class="diff-removed">-/// called from the main thread. The caller owns the config memory. The</div><div class="diff-removed">-/// memory can be freed immediately when this returns.</div><div class="diff-removed">-pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void {</div><div class="diff-removed">-    // Go through and update all of the surface configurations.</div><div class="diff-removed">-    for (self.surfaces.items) |surface| {</div><div class="diff-removed">-        try surface.core_surface.handleMessage(.{ .change_config = config });</div><div class="diff-removed">-    }</div><div class="diff-added">+pub fn updateConfig(</div><div class="diff-added">+    self   : *App,</div><div class="diff-added">+    rt_app : *apprt.App,</div><div class="diff-added">+    config : *const Config,</div><div class="diff-added">+) !void {</div><div class="diff-added">+    // Propagate to all existing surfaces</div><div class="diff-added">+    for (self.surfaces.items) |s|</div><div class="diff-added">+        try s.core_surface.handleMessage(.{ .change_config = config });</div><div> </div><div class="diff-removed">-    // Apply our conditional state. If we fail to apply the conditional state</div><div class="diff-removed">-    // then we log and attempt to move forward with the old config.</div><div class="diff-removed">-    // We only apply this to the app-level config because the surface</div><div class="diff-removed">-    // config applies its own conditional state.</div><div class="diff-removed">-    var applied_: ?configpkg.Config = config.changeConditionalState(</div><div class="diff-added">+    // Apply conditional state to app-level config</div><div class="diff-added">+    var tmp_cfg: ?Config = config.changeConditionalState(</div><div>         self.config_conditional_state,</div><div class="diff-removed">-    ) catch |err| err: {</div><div class="diff-removed">-        log.warn("failed to apply conditional state to config err={}", .{err});</div><div class="diff-removed">-        break :err null;</div><div class="diff-added">+    ) catch |e| blk: {</div><div class="diff-added">+        log.warn("failed to apply conditional state: {}", .{e});</div><div class="diff-added">+        break :blk null;</div><div>     };</div><div class="diff-removed">-    defer if (applied_) |*c| c.deinit();</div><div class="diff-removed">-    const applied: *const configpkg.Config = if (applied_) |*c| c else config;</div><div class="diff-added">+    defer if (tmp_cfg) |*c| c.deinit();</div><div class="diff-added">+    const applied: *const Config = if (tmp_cfg) |*c| c else config;</div><div> </div><div class="diff-removed">-    // Notify the apprt that the app has changed configuration.</div><div class="diff-added">+    // Notify apprt</div><div>     _ = try rt_app.performAction(</div><div>         .app,</div><div>         .config_change,</div><div class="diff-info">@@ -168,416 +126,232 @@ pub fn updateConfig(self: *App, rt_app: *apprt.App, config: *const Config) !void</div><div>     );</div><div> }</div><div> </div><div class="diff-removed">-/// Add an initialized surface. This is really only for the runtime</div><div class="diff-removed">-/// implementations to call and should NOT be called by general app users.</div><div class="diff-removed">-/// The surface must be from the pool.</div><div class="diff-removed">-pub fn addSurface(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_surface: *apprt.Surface,</div><div class="diff-removed">-) Allocator.Error!void {</div><div class="diff-removed">-    try self.surfaces.append(self.alloc, rt_surface);</div><div class="diff-removed">-</div><div class="diff-removed">-    // Since we have non-zero surfaces, we can cancel the quit timer.</div><div class="diff-removed">-    // It is up to the apprt if there is a quit timer at all and if it</div><div class="diff-removed">-    // should be canceled.</div><div class="diff-removed">-    _ = rt_surface.app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .quit_timer,</div><div class="diff-removed">-        .stop,</div><div class="diff-removed">-    ) catch |err| {</div><div class="diff-removed">-        log.warn("error stopping quit timer err={}", .{err});</div><div class="diff-removed">-    };</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// SURFACE MANAGEMENT</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div class="diff-added">+pub fn addSurface(self: *App, rt: *apprt.Surface) Allocator.Error!void {</div><div class="diff-added">+    try self.surfaces.append(self.alloc, rt);</div><div class="diff-added">+</div><div class="diff-added">+    // Cancel quit timer (if any)</div><div class="diff-added">+    _ = rt.app.performAction(.app, .quit_timer, .stop) catch |e|</div><div class="diff-added">+        log.warn("stop quit-timer failed: {}", .{e});</div><div> }</div><div> </div><div class="diff-removed">-/// Delete the surface from the known surface list. This will NOT call the</div><div class="diff-removed">-/// destructor or free the memory.</div><div class="diff-removed">-pub fn deleteSurface(self: *App, rt_surface: *apprt.Surface) void {</div><div class="diff-removed">-    // If this surface is the focused surface then we need to clear it.</div><div class="diff-removed">-    // There was a bug where we relied on hasSurface to return false and</div><div class="diff-removed">-    // just let focused surface be but the allocator was reusing addresses</div><div class="diff-removed">-    // after free and giving false positives, so we must clear it.</div><div class="diff-removed">-    if (self.focused_surface) |focused| {</div><div class="diff-removed">-        if (focused == &rt_surface.core_surface) {</div><div class="diff-removed">-            self.focused_surface = null;</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-added">+pub fn deleteSurface(self: *App, rt: *apprt.Surface) void {</div><div class="diff-added">+    if (self.focused_surface) |f| if (f == &rt.core_surface) self.focused_surface = null;</div><div> </div><div>     var i: usize = 0;</div><div>     while (i < self.surfaces.items.len) {</div><div class="diff-removed">-        if (self.surfaces.items[i] == rt_surface) {</div><div class="diff-added">+        if (self.surfaces.items[i] == rt) {</div><div>             _ = self.surfaces.swapRemove(i);</div><div class="diff-removed">-            continue;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        i += 1;</div><div class="diff-added">+        } else i += 1;</div><div>     }</div><div> </div><div class="diff-removed">-    // If we have no surfaces, we can start the quit timer. It is up to the</div><div class="diff-removed">-    // apprt to determine if this is necessary.</div><div class="diff-removed">-    if (self.surfaces.items.len == 0) _ = rt_surface.app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .quit_timer,</div><div class="diff-removed">-        .start,</div><div class="diff-removed">-    ) catch |err| {</div><div class="diff-removed">-        log.warn("error starting quit timer err={}", .{err});</div><div class="diff-removed">-    };</div><div class="diff-added">+    if (self.surfaces.items.len == 0)</div><div class="diff-added">+        _ = rt.app.performAction(.app, .quit_timer, .start) catch |e|</div><div class="diff-added">+            log.warn("start quit-timer failed: {}", .{e});</div><div> }</div><div> </div><div class="diff-removed">-/// The last focused surface. This is only valid while on the main thread</div><div class="diff-removed">-/// before tick is called.</div><div> pub fn focusedSurface(self: *const App) ?*Surface {</div><div class="diff-removed">-    const surface = self.focused_surface orelse return null;</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return null;</div><div class="diff-removed">-    return surface;</div><div class="diff-added">+    const s = self.focused_surface orelse return null;</div><div class="diff-added">+    return if (self.hasSurface(s)) s else null;</div><div> }</div><div> </div><div class="diff-removed">-/// Returns true if confirmation is needed to quit the app. It is up to</div><div class="diff-removed">-/// the apprt to call this.</div><div> pub fn needsConfirmQuit(self: *const App) bool {</div><div class="diff-removed">-    for (self.surfaces.items) |v| {</div><div class="diff-removed">-        if (v.core_surface.needsConfirmQuit()) return true;</div><div class="diff-added">+    for (self.surfaces.items) |s|</div><div class="diff-added">+        if (s.core_surface.needsConfirmQuit()) return true;</div><div class="diff-added">+    return false;</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// EVENT LOOP</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div class="diff-added">+pub fn tick(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-added">+    // Close finished surfaces</div><div class="diff-added">+    var i: usize = 0;</div><div class="diff-added">+    while (i < self.surfaces.items.len) {</div><div class="diff-added">+        const s = self.surfaces.items[i];</div><div class="diff-added">+        if (s.shouldClose()) s.close() else i += 1;</div><div>     }</div><div> </div><div class="diff-removed">-    return false;</div><div class="diff-added">+    try self.drainMailbox(rt_app);</div><div> }</div><div> </div><div class="diff-removed">-/// Drain the mailbox.</div><div> fn drainMailbox(self: *App, rt_app: *apprt.App) !void {</div><div class="diff-removed">-    while (self.mailbox.pop()) |message| {</div><div class="diff-removed">-        log.debug("mailbox message={s}", .{@tagName(message)});</div><div class="diff-removed">-        switch (message) {</div><div class="diff-removed">-            .open_config => try self.performAction(rt_app, .open_config),</div><div class="diff-removed">-            .new_window => |msg| try self.newWindow(rt_app, msg),</div><div class="diff-removed">-            .close => |surface| self.closeSurface(surface),</div><div class="diff-removed">-            .surface_message => |msg| try self.surfaceMessage(msg.surface, msg.message),</div><div class="diff-removed">-            .redraw_surface => |surface| self.redrawSurface(rt_app, surface),</div><div class="diff-removed">-            .redraw_inspector => |surface| self.redrawInspector(rt_app, surface),</div><div class="diff-removed">-</div><div class="diff-removed">-            // If we're quitting, then we set the quit flag and stop</div><div class="diff-removed">-            // draining the mailbox immediately. This lets us defer</div><div class="diff-removed">-            // mailbox processing to the next tick so that the apprt</div><div class="diff-removed">-            // can try to quit as quickly as possible.</div><div class="diff-added">+    while (self.mailbox.pop()) |m| {</div><div class="diff-added">+        log.debug("mailbox {}", .{@tagName(m)});</div><div class="diff-added">+        switch (m) {</div><div class="diff-added">+            .open_config         => try self.performAction(rt_app, .open_config),</div><div class="diff-added">+            .new_window          => |msg| try self.newWindow(rt_app, msg),</div><div class="diff-added">+            .close               => |s|  self.closeSurface(s),</div><div class="diff-added">+            .surface_message     => |p|  try self.surfaceMessage(p.surface, p.message),</div><div class="diff-added">+            .redraw_surface      => |s|  self.redrawSurface(rt_app, s),</div><div class="diff-added">+            .redraw_inspector    => |s|  self.redrawInspector(rt_app, s),</div><div class="diff-added">+</div><div>             .quit => {</div><div class="diff-removed">-                log.info("quit message received, short circuiting mailbox drain", .{});</div><div class="diff-removed">-                try self.performAction(rt_app, .quit);</div><div class="diff-added">+                log.info("quit message â€“ abort remaining mailbox", .{});</div><div class="diff-added">+                _ = try rt_app.performAction(.app, .quit, {});</div><div>                 return;</div><div>             },</div><div>         }</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-pub fn closeSurface(self: *App, surface: *Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return;</div><div class="diff-removed">-    surface.close();</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub fn focusSurface(self: *App, surface: *Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(surface)) return;</div><div class="diff-removed">-    self.focused_surface = surface;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn redrawSurface(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-removed">-    rt_app.redrawSurface(surface);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn redrawInspector(self: *App, rt_app: *apprt.App, surface: *apprt.Surface) void {</div><div class="diff-removed">-    if (!self.hasSurface(&surface.core_surface)) return;</div><div class="diff-removed">-    rt_app.redrawInspector(surface);</div><div class="diff-removed">-}</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// WINDOW/FOCUS EVENTS</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div> </div><div class="diff-removed">-/// Create a new window</div><div class="diff-removed">-pub fn newWindow(self: *App, rt_app: *apprt.App, msg: Message.NewWindow) !void {</div><div class="diff-removed">-    const target: apprt.Target = target: {</div><div class="diff-removed">-        const parent = msg.parent orelse break :target .app;</div><div class="diff-removed">-        if (self.hasSurface(parent)) break :target .{ .surface = parent };</div><div class="diff-removed">-        break :target .app;</div><div class="diff-added">+pub fn newWindow(self: *App, rt: *apprt.App, msg: Message.NewWindow) !void {</div><div class="diff-added">+    const tgt: apprt.Target = blk: {</div><div class="diff-added">+        const p = msg.parent orelse break :blk .app;</div><div class="diff-added">+        break :blk if (self.hasSurface(p)) .{ .surface = p } else .app;</div><div>     };</div><div class="diff-removed">-</div><div class="diff-removed">-    _ = try rt_app.performAction(</div><div class="diff-removed">-        target,</div><div class="diff-removed">-        .new_window,</div><div class="diff-removed">-        {},</div><div class="diff-removed">-    );</div><div class="diff-added">+    _ = try rt.performAction(tgt, .new_window, {});</div><div> }</div><div> </div><div class="diff-removed">-/// Handle an app-level focus event. This should be called whenever</div><div class="diff-removed">-/// the focus state of the entire app containing Ghostty changes.</div><div class="diff-removed">-/// This is separate from surface focus events. See the `focused`</div><div class="diff-removed">-/// field for more information.</div><div> pub fn focusEvent(self: *App, focused: bool) void {</div><div class="diff-removed">-    // Prevent redundant focus events</div><div>     if (self.focused == focused) return;</div><div class="diff-removed">-</div><div class="diff-removed">-    log.debug("focus event focused={}", .{focused});</div><div class="diff-added">+    log.debug("app focus={}", .{focused});</div><div>     self.focused = focused;</div><div> }</div><div> </div><div class="diff-removed">-/// Returns true if the given key event would trigger a keybinding</div><div class="diff-removed">-/// if it were to be processed. This is useful for determining if</div><div class="diff-removed">-/// a key event should be sent to the terminal or not.</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// KEY INPUT</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div> pub fn keyEventIsBinding(</div><div class="diff-removed">-    self: *App,</div><div class="diff-added">+    self  : *App,</div><div>     rt_app: *apprt.App,</div><div class="diff-removed">-    event: input.KeyEvent,</div><div class="diff-added">+    e     : input.KeyEvent,</div><div> ) bool {</div><div>     _ = self;</div><div class="diff-removed">-</div><div class="diff-removed">-    switch (event.action) {</div><div class="diff-removed">-        .release => return false,</div><div class="diff-removed">-        .press, .repeat => {},</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we have a keybinding for this event then we return true.</div><div class="diff-removed">-    return rt_app.config.keybind.set.getEvent(event) != null;</div><div class="diff-added">+    return e.action != .release and rt_app.config.keybind.set.getEvent(e) != null;</div><div> }</div><div> </div><div class="diff-removed">-/// Handle a key event at the app-scope. If this key event is used,</div><div class="diff-removed">-/// this will return true and the caller shouldn't continue processing</div><div class="diff-removed">-/// the event. If the event is not used, this will return false.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// If the app currently has focus then all key events are processed.</div><div class="diff-removed">-/// If the app does not have focus then only global key events are</div><div class="diff-removed">-/// processed.</div><div> pub fn keyEvent(</div><div class="diff-removed">-    self: *App,</div><div class="diff-added">+    self  : *App,</div><div>     rt_app: *apprt.App,</div><div class="diff-removed">-    event: input.KeyEvent,</div><div class="diff-added">+    e     : input.KeyEvent,</div><div> ) bool {</div><div class="diff-removed">-    switch (event.action) {</div><div class="diff-removed">-        // We don't care about key release events.</div><div class="diff-removed">-        .release => return false,</div><div class="diff-removed">-</div><div class="diff-removed">-        // Continue processing key press events.</div><div class="diff-removed">-        .press, .repeat => {},</div><div class="diff-removed">-    }</div><div class="diff-added">+    if (e.action == .release) return false;</div><div> </div><div class="diff-removed">-    // Get the keybind entry for this event. We don't support key sequences</div><div class="diff-removed">-    // so we can look directly in the top-level set.</div><div class="diff-removed">-    const entry = rt_app.config.keybind.set.getEvent(event) orelse return false;</div><div class="diff-removed">-    const leaf: input.Binding.Set.Leaf = switch (entry.value_ptr.*) {</div><div class="diff-removed">-        // Sequences aren't supported. Our configuration parser verifies</div><div class="diff-removed">-        // this for global keybinds but we may still get an entry for</div><div class="diff-removed">-        // a non-global keybind.</div><div class="diff-added">+    const entry = rt_app.config.keybind.set.getEvent(e) orelse return false;</div><div class="diff-added">+    const leaf  = switch (entry.value_ptr.*) {</div><div>         .leader => return false,</div><div class="diff-removed">-</div><div class="diff-removed">-        // Leaf entries are good</div><div class="diff-removed">-        .leaf => |leaf| leaf,</div><div class="diff-added">+        .leaf   => |l| l,</div><div>     };</div><div> </div><div class="diff-removed">-    // If we aren't focused, then we only process global keybinds.</div><div class="diff-added">+    // If app not focused only allow global bindings</div><div>     if (!self.focused and !leaf.flags.global) return false;</div><div> </div><div class="diff-removed">-    // Global keybinds are done using performAll so that they</div><div class="diff-removed">-    // can target all surfaces too.</div><div>     if (leaf.flags.global) {</div><div class="diff-removed">-        self.performAllAction(rt_app, leaf.action) catch |err| {</div><div class="diff-removed">-            log.warn("error performing global keybind action action={s} err={}", .{</div><div class="diff-removed">-                @tagName(leaf.action),</div><div class="diff-removed">-                err,</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-added">+        self.performAllAction(rt_app, leaf.action) catch |er|</div><div class="diff-added">+            log.warn("global action {} failed: {}", .{@tagName(leaf.action), er});</div><div>         return true;</div><div>     }</div><div> </div><div class="diff-removed">-    // Must be focused to process non-global keybinds</div><div class="diff-removed">-    assert(self.focused);</div><div class="diff-removed">-    assert(!leaf.flags.global);</div><div class="diff-removed">-</div><div class="diff-removed">-    // If we are focused, then we process keybinds only if they are</div><div class="diff-removed">-    // app-scoped. Otherwise, we do nothing. Surface-scoped should</div><div class="diff-removed">-    // be processed by Surface.keyEvent.</div><div class="diff-removed">-    const app_action = leaf.action.scoped(.app) orelse return false;</div><div class="diff-removed">-    self.performAction(rt_app, app_action) catch |err| {</div><div class="diff-removed">-        log.warn("error performing app keybind action action={s} err={}", .{</div><div class="diff-removed">-            @tagName(app_action),</div><div class="diff-removed">-            err,</div><div class="diff-removed">-        });</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-added">+    // App-scoped binding</div><div class="diff-added">+    const app_act = leaf.action.scoped(.app) orelse return false;</div><div class="diff-added">+    self.performAction(rt_app, app_act) catch |er|</div><div class="diff-added">+        log.warn("app action {} failed: {}", .{@tagName(app_act), er});</div><div>     return true;</div><div> }</div><div> </div><div class="diff-removed">-/// Call to notify Ghostty that the color scheme for the app has changed.</div><div class="diff-removed">-/// "Color scheme" in this case refers to system themes such as "light/dark".</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// COLOR SCHEME</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div> pub fn colorSchemeEvent(</div><div class="diff-removed">-    self: *App,</div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    scheme: apprt.ColorScheme,</div><div class="diff-added">+    self : *App,</div><div class="diff-added">+    rt   : *apprt.App,</div><div class="diff-added">+    sch  : apprt.ColorScheme,</div><div> ) !void {</div><div class="diff-removed">-    const new_scheme: configpkg.ConditionalState.Theme = switch (scheme) {</div><div class="diff-removed">-        .light => .light,</div><div class="diff-removed">-        .dark => .dark,</div><div class="diff-added">+    const th: configpkg.ConditionalState.Theme = switch (sch) {</div><div class="diff-added">+        .light => .light, .dark => .dark,</div><div>     };</div><div class="diff-added">+    if (self.config_conditional_state.theme == th) return;</div><div> </div><div class="diff-removed">-    // If our scheme didn't change, then we don't do anything.</div><div class="diff-removed">-    if (self.config_conditional_state.theme == new_scheme) return;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Setup our conditional state which has the current color theme.</div><div class="diff-removed">-    self.config_conditional_state.theme = new_scheme;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Request our configuration be reloaded because the new scheme may</div><div class="diff-removed">-    // impact the colors of the app.</div><div class="diff-removed">-    _ = try rt_app.performAction(</div><div class="diff-removed">-        .app,</div><div class="diff-removed">-        .reload_config,</div><div class="diff-removed">-        .{ .soft = true },</div><div class="diff-removed">-    );</div><div class="diff-added">+    self.config_conditional_state.theme = th;</div><div class="diff-added">+    _ = try rt.performAction(.app, .reload_config, .{ .soft = true });</div><div> }</div><div> </div><div class="diff-removed">-/// Perform a binding action. This only accepts actions that are scoped</div><div class="diff-removed">-/// to the app. Callers can use performAllAction to perform any action</div><div class="diff-removed">-/// and any non-app-scoped actions will be performed on all surfaces.</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// ACTIONS</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div> pub fn performAction(</div><div class="diff-removed">-    self: *App,</div><div class="diff-added">+    self  : *App,</div><div>     rt_app: *apprt.App,</div><div class="diff-removed">-    action: input.Binding.Action.Scoped(.app),</div><div class="diff-added">+    act   : input.Binding.Action.Scoped(.app),</div><div> ) !void {</div><div class="diff-removed">-    switch (action) {</div><div class="diff-removed">-        .unbind => unreachable,</div><div class="diff-removed">-        .ignore => {},</div><div class="diff-removed">-        .quit => _ = try rt_app.performAction(.app, .quit, {}),</div><div class="diff-removed">-        .new_window => _ = try self.newWindow(rt_app, .{ .parent = null }),</div><div class="diff-removed">-        .open_config => _ = try rt_app.performAction(.app, .open_config, {}),</div><div class="diff-removed">-        .reload_config => _ = try rt_app.performAction(.app, .reload_config, .{}),</div><div class="diff-removed">-        .close_all_windows => _ = try rt_app.performAction(.app, .close_all_windows, {}),</div><div class="diff-added">+    switch (act) {</div><div class="diff-added">+        .unbind                => unreachable,</div><div class="diff-added">+        .ignore                => {},</div><div class="diff-added">+        .quit                  => _ = try rt_app.performAction(.app, .quit, {}),</div><div class="diff-added">+        .new_window            => try self.newWindow(rt_app, .{ .parent = null }),</div><div class="diff-added">+        .open_config           => _ = try rt_app.performAction(.app, .open_config, {}),</div><div class="diff-added">+        .reload_config         => _ = try rt_app.performAction(.app, .reload_config, .{}),</div><div class="diff-added">+        .close_all_windows     => _ = try rt_app.performAction(.app, .close_all_windows, {}),</div><div>         .toggle_quick_terminal => _ = try rt_app.performAction(.app, .toggle_quick_terminal, {}),</div><div class="diff-removed">-        .toggle_visibility => _ = try rt_app.performAction(.app, .toggle_visibility, {}),</div><div class="diff-added">+        .toggle_visibility     => _ = try rt_app.performAction(.app, .toggle_visibility, {}),</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-/// Perform an app-wide binding action. If the action is surface-specific</div><div class="diff-removed">-/// then it will be performed on all surfaces. To perform only app-scoped</div><div class="diff-removed">-/// actions, use performAction.</div><div> pub fn performAllAction(</div><div class="diff-removed">-    self: *App,</div><div class="diff-added">+    self  : *App,</div><div>     rt_app: *apprt.App,</div><div class="diff-removed">-    action: input.Binding.Action,</div><div class="diff-added">+    act   : input.Binding.Action,</div><div> ) !void {</div><div class="diff-removed">-    switch (action.scope()) {</div><div class="diff-removed">-        // App-scoped actions are handled by the app so that they aren't</div><div class="diff-removed">-        // repeated for each surface (since each surface forwards</div><div class="diff-removed">-        // app-scoped actions back up).</div><div class="diff-removed">-        .app => try self.performAction(</div><div class="diff-removed">-            rt_app,</div><div class="diff-removed">-            action.scoped(.app).?, // asserted through the scope match</div><div class="diff-removed">-        ),</div><div class="diff-removed">-</div><div class="diff-removed">-        // Surface-scoped actions are performed on all surfaces. Errors</div><div class="diff-removed">-        // are logged but processing continues.</div><div class="diff-removed">-        .surface => for (self.surfaces.items) |surface| {</div><div class="diff-removed">-            _ = surface.core_surface.performBindingAction(action) catch |err| {</div><div class="diff-removed">-                log.warn("error performing binding action on surface ptr={X} err={}", .{</div><div class="diff-removed">-                    @intFromPtr(surface),</div><div class="diff-removed">-                    err,</div><div class="diff-removed">-                });</div><div class="diff-removed">-            };</div><div class="diff-removed">-        },</div><div class="diff-added">+    switch (act.scope()) {</div><div class="diff-added">+        .app     => try self.performAction(rt_app, act.scoped(.app).?),</div><div class="diff-added">+        .surface => for (self.surfaces.items) |s|</div><div class="diff-added">+            _ = s.core_surface.performBindingAction(act) catch |er|</div><div class="diff-added">+                log.warn("surface {} action failed: {}", .{@intFromPtr(s), er});</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-/// Handle a window message</div><div class="diff-removed">-fn surfaceMessage(self: *App, surface: *Surface, msg: apprt.surface.Message) !void {</div><div class="diff-removed">-    // We want to ensure our window is still active. Window messages</div><div class="diff-removed">-    // are quite rare and we normally don't have many windows so we do</div><div class="diff-removed">-    // a simple linear search here.</div><div class="diff-removed">-    if (self.hasSurface(surface)) {</div><div class="diff-removed">-        try surface.handleMessage(msg);</div><div class="diff-removed">-    }</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// SURFACE FORWARDERS</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div> </div><div class="diff-removed">-    // Window was not found, it probably quit before we handled the message.</div><div class="diff-removed">-    // Not a problem.</div><div class="diff-added">+fn surfaceMessage(self: *App, win: *Surface, msg: apprt.surface.Message) !void {</div><div class="diff-added">+    if (self.hasSurface(win)) try win.handleMessage(msg);</div><div> }</div><div> </div><div class="diff-removed">-fn hasSurface(self: *const App, surface: *const Surface) bool {</div><div class="diff-removed">-    for (self.surfaces.items) |v| {</div><div class="diff-removed">-        if (&v.core_surface == surface) return true;</div><div class="diff-removed">-    }</div><div class="diff-added">+fn redrawSurface(self: *App, rt: *apprt.App, s: *apprt.Surface) void {</div><div class="diff-added">+    if (self.hasSurface(&s.core_surface)) rt.redrawSurface(s);</div><div class="diff-added">+}</div><div> </div><div class="diff-removed">-    return false;</div><div class="diff-added">+fn redrawInspector(self: *App, rt: *apprt.App, s: *apprt.Surface) void {</div><div class="diff-added">+    if (self.hasSurface(&s.core_surface)) rt.redrawInspector(s);</div><div> }</div><div> </div><div class="diff-removed">-/// The message types that can be sent to the app thread.</div><div class="diff-removed">-pub const Message = union(enum) {</div><div class="diff-removed">-    // Open the configuration file</div><div class="diff-removed">-    open_config: void,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create a new terminal window.</div><div class="diff-removed">-    new_window: NewWindow,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Close a surface. This notifies the runtime that a surface</div><div class="diff-removed">-    /// should close.</div><div class="diff-removed">-    close: *Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Quit</div><div class="diff-removed">-    quit: void,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// A message for a specific surface.</div><div class="diff-removed">-    surface_message: struct {</div><div class="diff-removed">-        surface: *Surface,</div><div class="diff-removed">-        message: apprt.surface.Message,</div><div class="diff-removed">-    },</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Redraw a surface. This only has an effect for runtimes that</div><div class="diff-removed">-    /// use single-threaded draws. To redraw a surface for all runtimes,</div><div class="diff-removed">-    /// wake up the renderer thread. The renderer thread will send this</div><div class="diff-removed">-    /// message if it needs to.</div><div class="diff-removed">-    redraw_surface: *apprt.Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Redraw the inspector. This is called whenever some non-OS event</div><div class="diff-removed">-    /// causes the inspector to need to be redrawn.</div><div class="diff-removed">-    redraw_inspector: *apprt.Surface,</div><div class="diff-removed">-</div><div class="diff-removed">-    const NewWindow = struct {</div><div class="diff-removed">-        /// The parent surface</div><div class="diff-removed">-        parent: ?*Surface = null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-};</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// HELPERS</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+</div><div class="diff-added">+fn hasSurface(self: *const App, s: *const Surface) bool {</div><div class="diff-added">+    for (self.surfaces.items) |v|</div><div class="diff-added">+        if (&v.core_surface == s) return true;</div><div class="diff-added">+    return false;</div><div class="diff-added">+}</div><div> </div><div class="diff-removed">-/// Mailbox is the way that other threads send the app thread messages.</div><div class="diff-removed">-pub const Mailbox = struct {</div><div class="diff-removed">-    /// The type used for sending messages to the app thread.</div><div class="diff-removed">-    pub const Queue = BlockingQueue(Message, 64);</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div class="diff-added">+// MAILBOX MESSAGE TYPES</div><div class="diff-added">+///////////////////////////////////////////////////////////////////////////////</div><div> </div><div class="diff-removed">-    rt_app: *apprt.App,</div><div class="diff-removed">-    mailbox: *Queue,</div><div class="diff-added">+pub const Message = union(enum) {</div><div class="diff-added">+    open_config : void,</div><div class="diff-added">+    new_window  : NewWindow,</div><div class="diff-added">+    close       : *Surface,</div><div> </div><div class="diff-removed">-    /// Send a message to the surface.</div><div class="diff-removed">-    pub fn push(self: Mailbox, msg: Message, timeout: Queue.Timeout) Queue.Size {</div><div class="diff-removed">-        const result = self.mailbox.push(msg, timeout);</div><div class="diff-added">+    surface_message   : struct { surface: *Surface, message: apprt.surface.Message },</div><div class="diff-added">+    redraw_surface    : *apprt.Surface,</div><div class="diff-added">+    redraw_inspector  : *apprt.Surface,</div><div> </div><div class="diff-removed">-        // Wake up our app loop</div><div class="diff-removed">-        self.rt_app.wakeup();</div><div class="diff-added">+    quit : void,</div><div> </div><div class="diff-removed">-        return result;</div><div class="diff-removed">-    }</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-// Wasm API.</div><div class="diff-removed">-pub const Wasm = if (!builtin.target.isWasm()) struct {} else struct {</div><div class="diff-removed">-    const wasm = @import("os/wasm.zig");</div><div class="diff-removed">-    const alloc = wasm.alloc;</div><div class="diff-removed">-</div><div class="diff-removed">-    // export fn app_new(config: *Config) ?*App {</div><div class="diff-removed">-    //     return app_new_(config) catch |err| { log.err("error initializing app err={}", .{err});</div><div class="diff-removed">-    //         return null;</div><div class="diff-removed">-    //     };</div><div class="diff-removed">-    // }</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // fn app_new_(config: *Config) !*App {</div><div class="diff-removed">-    //     const app = try App.create(alloc, config);</div><div class="diff-removed">-    //     errdefer app.destroy();</div><div class="diff-removed">-    //</div><div class="diff-removed">-    //     const result = try alloc.create(App);</div><div class="diff-removed">-    //     result.* = app;</div><div class="diff-removed">-    //     return result;</div><div class="diff-removed">-    // }</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // export fn app_free(ptr: ?*App) void {</div><div class="diff-removed">-    //     if (ptr) |v| {</div><div class="diff-removed">-    //         v.destroy();</div><div class="diff-removed">-    //         alloc.destroy(v);</div><div class="diff-removed">-    //     }</div><div class="diff-removed">-    // }</div><div class="diff-added">+    const NewWindow = struct { parent: ?*Surface = null };</div><div> };</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    