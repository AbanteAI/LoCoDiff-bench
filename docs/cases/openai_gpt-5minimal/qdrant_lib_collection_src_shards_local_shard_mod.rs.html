<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - GPT-5 (minimal)</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: GPT-5 (minimal)</h2>
        <p><a href="../../models/openai_gpt-5minimal.html">All GPT-5 (minimal) Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT-5 (minimal)</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 59478</p>
                <p><strong>Native Completion Tokens:</strong> 9721</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.008577875</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-5minimal/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-5minimal/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-5minimal/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb38..23e1193ca 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmp67b40k6s_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpzvusmvf4_actual.txt	</div><div class="diff-info">@@ -313,6 +313,7 @@ impl LocalShard {</div><div>         // Uncomment it if you need to debug segment loading.</div><div>         // let semaphore = Arc::new(parking_lot::Mutex::new(()));</div><div> </div><div class="diff-added">+//         for entry in segment_dirs {</div><div>         for segment_path in segment_paths {</div><div>             let payload_index_schema = payload_index_schema.clone();</div><div>             // let semaphore_clone = semaphore.clone();</div><div class="diff-info">@@ -698,7 +699,6 @@ impl LocalShard {</div><div>                     }</div><div>                 }</div><div>             }</div><div class="diff-removed">-</div><div>             // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div>             // consistency, if we happened to only apply *past* operations to a segment with newer</div><div>             // version.</div><div class="diff-info">@@ -720,35 +720,6 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div>         let config = self.collection_config.read().await;</div><div>         let mut update_handler = self.update_handler.lock().await;</div><div class="diff-info">@@ -868,6 +839,9 @@ impl LocalShard {</div><div>             rx.await?;</div><div>         }</div><div> </div><div class="diff-added">+        let collection_path = self.path.parent().map(Path::to_path_buf).ok_or_else(|| {</div><div class="diff-added">+            CollectionError::service_error("Failed to determine collection path for shard")</div><div class="diff-added">+        })?;</div><div>         let segments_path = Self::segments_path(&self.path);</div><div>         let collection_params = self.collection_config.read().await.params.clone();</div><div>         let temp_path = temp_path.to_owned();</div><div class="diff-info">@@ -1017,6 +991,81 @@ impl LocalShard {</div><div>         SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div>     }</div><div> </div><div class="diff-added">+    /// Check data consistency for all segments</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// Returns an error at the first inconsistent segment</div><div class="diff-added">+    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-added">+        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-added">+        let segments = self.segments.read();</div><div class="diff-added">+        for (_idx, segment) in segments.iter() {</div><div class="diff-added">+            match segment {</div><div class="diff-added">+                LockedSegment::Original(raw_segment) => {</div><div class="diff-added">+                    let segment_guard = raw_segment.read();</div><div class="diff-added">+                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-added">+                        log::error!(</div><div class="diff-added">+                            "Segment {:?} is inconsistent: {}",</div><div class="diff-added">+                            segment_guard.current_path,</div><div class="diff-added">+                            err</div><div class="diff-added">+                        );</div><div class="diff-added">+                        return Err(err.into());</div><div class="diff-added">+                    }</div><div class="diff-added">+                }</div><div class="diff-added">+                LockedSegment::Proxy(_) => {</div><div class="diff-added">+                    return Err(CollectionError::service_error(</div><div class="diff-added">+                        "Proxy segment found in check_data_consistency",</div><div class="diff-added">+                    ));</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Get the recovery point for the current shard</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-added">+    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-added">+        self.wal.recovery_point().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Update the cutoff point on the current shard</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// This also updates the highest seen clocks.</div><div class="diff-added">+    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-added">+        self.wal.update_cutoff(cutoff).await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-added">+    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-added">+    /// - context: the context of the operation to add on the error message</div><div class="diff-added">+    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// Returns an error if the rate limit is exceeded.</div><div class="diff-added">+    fn check_read_rate_limiter<F>(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-added">+        context: &str,</div><div class="diff-added">+        cost_fn: F,</div><div class="diff-added">+    ) -> CollectionResult<()></div><div class="diff-added">+    where</div><div class="diff-added">+        F: FnOnce() -> usize,</div><div class="diff-added">+    {</div><div class="diff-added">+        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-added">+        if hw_measurement_acc.is_disposable() {</div><div class="diff-added">+            return Ok(());</div><div class="diff-added">+        }</div><div class="diff-added">+        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-added">+            let cost = cost_fn();</div><div class="diff-added">+            rate_limiter</div><div class="diff-added">+                .lock()</div><div class="diff-added">+                .try_consume(cost as f64)</div><div class="diff-added">+                .map_err(|err| {</div><div class="diff-added">+                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-added">+                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-added">+                })?;</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div>         {</div><div>             let segments = self.segments().read();</div><div class="diff-info">@@ -1108,52 +1157,6 @@ impl LocalShard {</div><div>     pub fn update_tracker(&self) -> &UpdateTracker {</div><div>         &self.update_tracker</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_read_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        context: &str,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-removed">-                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div> }</div><div> </div><div> impl Drop for LocalShard {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    