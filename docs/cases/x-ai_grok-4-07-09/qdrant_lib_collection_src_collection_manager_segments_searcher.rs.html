<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/segments_searcher.rs - Grok 4</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/segments_searcher.rs</h1>
        <h2>Model: Grok 4</h2>
        <p><a href="../../models/x-ai_grok-4-07-09.html">All Grok 4 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 4</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 67928</p>
                <p><strong>Native Prompt Tokens:</strong> 66414</p>
                <p><strong>Native Completion Tokens:</strong> 24283</p>
                <p><strong>Native Tokens Reasoning:</strong> 10255</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.5630145</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8096e53f4..49d4f5f0d 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected):tmp/tmp7iv67gla_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual):tmp/tmp7qd6vcx1_actual.txt	</div><div class="diff-info">@@ -1,5 +1,5 @@</div><div class="diff-removed">-use std::collections::BTreeSet;</div><div> use std::collections::hash_map::Entry;</div><div class="diff-added">+use std::collections::{BTreeSet, AHashMap};</div><div> use std::sync::Arc;</div><div> use std::sync::atomic::AtomicBool;</div><div> </div><div class="diff-info">@@ -15,8 +15,8 @@ use segment::data_types::named_vectors::NamedVectors;</div><div> use segment::data_types::query_context::{FormulaContext, QueryContext, SegmentQueryContext};</div><div> use segment::data_types::vectors::{QueryVector, VectorStructInternal};</div><div> use segment::types::{</div><div class="diff-removed">-    Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,</div><div class="diff-removed">-    VectorName, WithPayload, WithPayloadInterface, WithVector,</div><div class="diff-added">+    Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType, VectorName,</div><div class="diff-added">+    WithPayload, WithPayloadInterface, WithVector,</div><div> };</div><div> use tinyvec::TinyVec;</div><div> use tokio::runtime::Handle;</div><div class="diff-info">@@ -110,7 +110,7 @@ impl SegmentsSearcher {</div><div> </div><div>         // Therefore we need to track the lowest scored element per segment for each batch</div><div>         let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![</div><div class="diff-removed">-            vec![f32::max_value(); batch_size]; // initial max score value for each batch</div><div class="diff-added">+            vec![f32::MAX; batch_size]; // initial max score value for each batch</div><div>             number_segments</div><div>         ];</div><div> </div><div class="diff-info">@@ -127,7 +127,7 @@ impl SegmentsSearcher {</div><div>                 lowest_scores_per_request[segment_idx][batch_req_idx] = query_res</div><div>                     .last()</div><div>                     .map(|x| x.score)</div><div class="diff-removed">-                    .unwrap_or_else(f32::min_value);</div><div class="diff-added">+                    .unwrap_or_else(f32::MIN);</div><div>                 result_aggregator.update_batch_results(batch_req_idx, query_res.into_iter());</div><div>             }</div><div>         }</div><div class="diff-info">@@ -136,891 +136,3006 @@ impl SegmentsSearcher {</div><div>         let mut searches_to_rerun: AHashMap<SegmentOffset, Vec<BatchOffset>> = AHashMap::new();</div><div> </div><div>         // Check if we want to re-run the search without sampling on some segments</div><div class="diff-removed">-        for (batch_id, required_limit) in limits.into_iter().enumerate() {</div><div class="diff-added">+</div><div class="diff-added">+for (batch_id, required_limit) in limits.into_iter().enumerate() {</div><div class="diff-added">+</div><div>             let lowest_batch_score_opt = result_aggregator.batch_lowest_scores(batch_id);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             // If there are no results, we do not need to re-run the search</div><div class="diff-added">+</div><div>             if let Some(lowest_batch_score) = lowest_batch_score_opt {</div><div class="diff-added">+</div><div>                 for segment_id in 0..number_segments {</div><div class="diff-added">+</div><div>                     let segment_lowest_score = lowest_scores_per_request[segment_id][batch_id];</div><div class="diff-added">+</div><div>                     let retrieved_points = retrieved_points_per_request[segment_id][batch_id];</div><div class="diff-added">+</div><div>                     let have_further_results = further_results[segment_id][batch_id];</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                     if have_further_results</div><div class="diff-added">+</div><div>                         && retrieved_points < required_limit</div><div class="diff-added">+</div><div>                         && segment_lowest_score >= lowest_batch_score</div><div class="diff-added">+</div><div>                     {</div><div class="diff-added">+</div><div>                         log::debug!(</div><div class="diff-added">+</div><div>                             "Search to re-run without sampling on segment_id: {segment_id} segment_lowest_score: {segment_lowest_score}, lowest_batch_score: {lowest_batch_score}, retrieved_points: {retrieved_points}, required_limit: {required_limit}",</div><div class="diff-added">+</div><div>                         );</div><div class="diff-added">+</div><div>                         // It is possible, that current segment can have better results than</div><div class="diff-added">+</div><div>                         // the lowest score in the batch. In that case, we need to re-run the search</div><div class="diff-added">+</div><div>                         // without sampling on that segment.</div><div class="diff-added">+</div><div>                         searches_to_rerun</div><div class="diff-added">+</div><div>                             .entry(segment_id)</div><div class="diff-added">+</div><div>                             .or_default()</div><div class="diff-added">+</div><div>                             .push(batch_id);</div><div class="diff-added">+</div><div>                     }</div><div class="diff-added">+</div><div>                 }</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>         }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         (result_aggregator, searches_to_rerun)</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     pub async fn prepare_query_context(</div><div class="diff-added">+</div><div>         segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div>         batch_request: &CoreSearchRequestBatch,</div><div class="diff-added">+</div><div>         collection_config: &CollectionConfigInternal,</div><div class="diff-added">+</div><div>         is_stopped_guard: &StoppingGuard,</div><div class="diff-added">+</div><div>         hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-added">+</div><div>     ) -> CollectionResult<Option<QueryContext>> {</div><div class="diff-added">+</div><div>         let indexing_threshold_kb = collection_config</div><div class="diff-added">+</div><div>             .optimizer_config</div><div class="diff-added">+</div><div>             .indexing_threshold</div><div class="diff-added">+</div><div>             .unwrap_or(DEFAULT_INDEXING_THRESHOLD_KB);</div><div class="diff-added">+</div><div>         let full_scan_threshold_kb = collection_config.hnsw_config.full_scan_threshold;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         const DEFAULT_CAPACITY: usize = 3;</div><div class="diff-added">+</div><div>         let mut idf_vectors: TinyVec<[&VectorName; DEFAULT_CAPACITY]> = Default::default();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         // check vector names existing</div><div class="diff-added">+</div><div>         for req in &batch_request.searches {</div><div class="diff-removed">-            let vector_name = req.query.get_vector_name();</div><div class="diff-added">+</div><div class="diff-added">+            let vector_nameurized = req.query.get_vector_name();</div><div class="diff-added">+</div><div>             collection_config.params.get_distance(vector_name)?;</div><div class="diff-added">+</div><div>             if let Some(sparse_vector_params) = collection_config</div><div class="diff-added">+</div><div>                 .params</div><div class="diff-added">+</div><div>                 .get_sparse_vector_params_opt(vector_name)</div><div class="diff-added">+</div><div>             {</div><div class="diff-added">+</div><div>                 if sparse_vector_params.modifier == Some(Modifier::Idf)</div><div class="diff-added">+</div><div>                     && !idf_vectors.contains(&vector_name)</div><div class="diff-added">+</div><div>                 {</div><div class="diff-added">+</div><div>                     idf_vectors.push(vector_name);</div><div class="diff-added">+</div><div>                 }</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>         }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let mut query_context = QueryContext::new(</div><div class="diff-added">+</div><div>             indexing_threshold_kb.max(full_scan_threshold_kb),</div><div class="diff-added">+</div><div>             hw_measurement_acc,</div><div class="diff-added">+</div><div>         )</div><div class="diff-added">+</div><div>         .with_is_stopped(is_stopped_guard.get_is_stopped());</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         for search_request in &batch_request.searches {</div><div class="diff-added">+</div><div>             search_request</div><div class="diff-added">+</div><div>                 .query</div><div class="diff-added">+</div><div>                 .iterate_sparse(|vector_name, sparse_vector| {</div><div class="diff-added">+</div><div>                     if idf_vectors.contains(&vector_name) {</div><div class="diff-added">+</div><div>                         query_context.init_idf(vector_name, &sparse_vector.indices);</div><div class="diff-added">+</div><div>                     }</div><div class="diff-added">+</div><div>                 })</div><div class="diff-added">+</div><div>         }</div><div> </div><div class="diff-removed">-        // Do blocking calls in a blocking task: `segment.get().read()` calls might block async runtime</div><div class="diff-removed">-        let task = {</div><div class="diff-removed">-            let segments = segments.clone();</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut futures = {</div><div> </div><div class="diff-removed">-            tokio::task::spawn_blocking(move || {</div><div class="diff-removed">-                let segments = segments.read();</div><div class="diff-added">+            let segments = segments.read();</div><div> </div><div class="diff-removed">-                if segments.is_empty() {</div><div class="diff-removed">-                    return None;</div><div class="diff-removed">-                }</div><div class="diff-added">+            let segments = segments.non_appendable_then_appendable_segments();</div><div class="diff-added">+</div><div class="diff-added">+            let futures = try_join_all(segments.map(|segment| runtime_handle.spawn_blocking({</div><div class="diff-added">+</div><div class="diff-added">+                let segment = segment.clone();</div><div class="diff-added">+</div><div class="diff-added">+                move || segment.get().read().fill_query_context(&mut query_context)</div><div class="diff-added">+</div><div class="diff-added">+            })));</div><div class="diff-added">+</div><div class="diff-added">+            futures.await?</div><div> </div><div class="diff-removed">-                let segments = segments.non_appendable_then_appendable_segments();</div><div class="diff-removed">-                for locked_segment in segments {</div><div class="diff-removed">-                    let segment = locked_segment.get();</div><div class="diff-removed">-                    let segment_guard = segment.read();</div><div class="diff-removed">-                    segment_guard.fill_query_context(&mut query_context);</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Some(query_context)</div><div class="diff-removed">-            })</div><div>         };</div><div> </div><div class="diff-removed">-        Ok(task.await?)</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        Ok(Some(query_context))</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     pub async fn search(</div><div class="diff-added">+</div><div>         segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div>         batch_request: Arc<CoreSearchRequestBatch>,</div><div class="diff-added">+</div><div>         runtime_handle: &Handle,</div><div class="diff-added">+</div><div>         sampling_enabled: bool,</div><div class="diff-added">+</div><div>         query_context: QueryContext,</div><div class="diff-added">+</div><div class="diff-added">+        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-added">+</div><div>     ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {</div><div class="diff-added">+</div><div>         let query_context_arc = Arc::new(query_context);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         // Using block to ensure `segments` variable is dropped in the end of it</div><div class="diff-added">+</div><div>         let (locked_segments, searches): (Vec<_>, Vec<_>) = {</div><div class="diff-removed">-            // Unfortunately, we have to do `segments.read()` twice, once in blocking task</div><div class="diff-removed">-            // and once here, due to `Send` bounds :/</div><div class="diff-added">+</div><div>             let segments_lock = segments.read();</div><div class="diff-added">+</div><div>             let segments = segments_lock.non_appendable_then_appendable_segments();</div><div> </div><div class="diff-removed">-            // Probabilistic sampling for the `limit` parameter avoids over-fetching points from segments.</div><div class="diff-removed">-            // e.g. 10 segments with limit 1000 would fetch 10000 points in total and discard 9000 points.</div><div class="diff-removed">-            // With probabilistic sampling we determine a smaller sampling limit for each segment.</div><div class="diff-removed">-            // Use probabilistic sampling if:</div><div class="diff-removed">-            // - sampling is enabled</div><div class="diff-removed">-            // - more than 1 segment</div><div class="diff-removed">-            // - segments are not empty</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             let use_sampling = sampling_enabled</div><div class="diff-added">+</div><div>                 && segments_lock.len() > 1</div><div class="diff-added">+</div><div>                 && query_context_arc.available_point_count() > 0;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             segments</div><div class="diff-added">+</div><div>                 .map(|segment| {</div><div class="diff-added">+</div><div>                     let query_context_arc_segment = query_context_arc.clone();</div><div> </div><div class="diff-added">+                    let hw_collector = hw_measurement_acc.new_collector();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                     let search = runtime_handle.spawn_blocking({</div><div class="diff-removed">-                        let (segment, batch_request) = (segment.clone(), batch_request.clone());</div><div class="diff-added">+</div><div class="diff-added">+                        let (segment, batch_request) = (segment, batch_request.clone());</div><div class="diff-added">+</div><div>                         move || {</div><div class="diff-added">+</div><div>                             let segment_query_context =</div><div class="diff-added">+</div><div>                                 query_context_arc_segment.get_segment_query_context();</div><div> </div><div class="diff-removed">-                            search_in_segment(</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                            let res = search_in_segment(</div><div class="diff-added">+</div><div>                                 segment,</div><div class="diff-added">+</div><div>                                 batch_request,</div><div class="diff-added">+</div><div>                                 use_sampling,</div><div class="diff-added">+</div><div>                                 &segment_query_context,</div><div class="diff-removed">-                            )</div><div class="diff-added">+</div><div class="diff-added">+                            );</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                            hw_collector.merge_from_cell(segment_query_context.take_hardware_counter());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                            res</div><div class="diff-added">+</div><div>                         }</div><div class="diff-added">+</div><div>                     });</div><div class="diff-added">+</div><div>                     (segment, search)</div><div class="diff-added">+</div><div>                 })</div><div class="diff-added">+</div><div>                 .unzip()</div><div class="diff-added">+</div><div>         };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         // perform search on all segments concurrently</div><div class="diff-removed">-        // the resulting Vec is in the same order as the segment searches were provided.</div><div class="diff-added">+</div><div>         let (all_search_results_per_segment, further_results) =</div><div class="diff-added">+</div><div>             Self::execute_searches(searches).await?;</div><div class="diff-added">+</div><div>         debug_assert!(all_search_results_per_segment.len() == locked_segments.len());</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let (mut result_aggregator, searches_to_rerun) = Self::process_search_result_step1(</div><div class="diff-added">+</div><div>             all_search_results_per_segment,</div><div class="diff-added">+</div><div>             batch_request</div><div class="diff-added">+</div><div>                 .searches</div><div class="diff-added">+</div><div>                 .iter()</div><div class="diff-added">+</div><div>                 .map(|request| request.limit + request.offset)</div><div class="diff-added">+</div><div>                 .collect(),</div><div class="diff-added">+</div><div>             &further_results,</div><div class="diff-added">+</div><div>         );</div><div class="diff-added">+</div><div>         // The second step of the search is to re-run the search without sampling on some segments</div><div class="diff-added">+</div><div>         // Expected that this stage will be executed rarely</div><div class="diff-added">+</div><div>         if !searches_to_rerun.is_empty() {</div><div class="diff-added">+</div><div>             // TODO notify telemetry of failing sampling</div><div class="diff-added">+</div><div>             // Ensure consistent order of segment ids</div><div class="diff-added">+</div><div>             let searches_to_rerun: Vec<(SegmentOffset, Vec<BatchOffset>)> =</div><div class="diff-added">+</div><div>                 searches_to_rerun.into_iter().collect();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             let secondary_searches: Vec<_> = {</div><div class="diff-added">+</div><div>                 let mut res = vec![];</div><div class="diff-added">+</div><div>                 for (segment_id, batch_ids) in searches_to_rerun.iter() {</div><div class="diff-added">+</div><div>                     let query_context_arc_segment = query_context_arc.clone();</div><div class="diff-added">+</div><div class="diff-added">+                    let hw_collector = hw_measurement_acc.new_collector();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                     let segment = locked_segments[*segment_id].clone();</div><div class="diff-added">+</div><div>                     let partial_batch_request = Arc::new(CoreSearchRequestBatch {</div><div class="diff-added">+</div><div>                         searches: batch_ids</div><div class="diff-added">+</div><div>                             .iter()</div><div class="diff-added">+</div><div>                             .map(|batch_id| batch_request.searches[*batch_id].clone())</div><div class="diff-added">+</div><div>                             .collect(),</div><div class="diff-added">+</div><div>                     });</div><div> </div><div>                     res.push(runtime_handle.spawn_blocking(move || {</div><div class="diff-added">+</div><div>                         let segment_query_context =</div><div class="diff-added">+</div><div>                             query_context_arc_segment.get_segment_query_context();</div><div> </div><div class="diff-removed">-                        search_in_segment(</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        let result = search_in_segment(</div><div class="diff-added">+</div><div>                             segment,</div><div class="diff-added">+</div><div>                             partial_batch_request,</div><div class="diff-added">+</div><div>                             false,</div><div class="diff-added">+</div><div>                             &segment_query_context,</div><div class="diff-removed">-                        )</div><div class="diff-added">+</div><div class="diff-added">+                        );</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        hw_collector.merge_from_cell(segment_query_context.take_hardware_counter());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        result</div><div class="diff-added">+</div><div>                     }))</div><div class="diff-added">+</div><div>                 }</div><div class="diff-added">+</div><div>                 res</div><div class="diff-added">+</div><div>             };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             let (secondary_search_results_per_segment, _) =</div><div class="diff-added">+</div><div>                 Self::execute_searches(secondary_searches).await?;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             result_aggregator.update_point_versions(</div><div class="diff-added">+</div><div>                 secondary_search_results_per_segment</div><div class="diff-added">+</div><div>                     .iter()</div><div class="diff-added">+</div><div>                     .flatten()</div><div class="diff-added">+</div><div>                     .flatten(),</div><div class="diff-added">+</div><div>             );</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             for ((_segment_id, batch_ids), segments_result) in searches_to_rerun</div><div class="diff-added">+</div><div>                 .into_iter()</div><div class="diff-removed">-                .zip(secondary_search_results_per_segment.into_iter())</div><div class="diff-removed">-            {</div><div class="diff-removed">-                for (batch_id, secondary_batch_result) in</div><div class="diff-removed">-                    batch_ids.into_iter().zip(segments_result.into_iter())</div><div class="diff-removed">-                {</div><div class="diff-added">+</div><div class="diff-added">+                .zip(secondary_search_results_per_segment.into_iter()) {</div><div class="diff-added">+</div><div class="diff-added">+                for (batch_id, secondary_batch_result) in batch_ids.into_iter().zip(segments_result.into_iter()) {</div><div class="diff-added">+</div><div>                     result_aggregator</div><div class="diff-added">+</div><div>                         .update_batch_results(batch_id, secondary_batch_result.into_iter());</div><div class="diff-added">+</div><div>                 }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div> </div><div class="diff-removed">-        let top_scores: Vec<_> = result_aggregator.into_topk();</div><div class="diff-removed">-        Ok(top_scores)</div><div class="diff-removed">-    }</div><div class="diff-added">+            }</div><div> </div><div class="diff-removed">-    /// Retrieve records for the given points ids from the segments</div><div class="diff-removed">-    /// - if payload is enabled, payload will be fetched</div><div class="diff-removed">-    /// - if vector is enabled, vector will be fetched</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// The points ids can contain duplicates, the records will be fetched only once</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// If an id is not found in the segments, it won't be included in the output.</div><div class="diff-removed">-    pub async fn retrieve(</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        points: &[PointIdType],</div><div class="diff-removed">-        with_payload: &WithPayload,</div><div class="diff-removed">-        with_vector: &WithVector,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<AHashMap<PointIdType, RecordInternal>> {</div><div class="diff-removed">-        let stopping_guard = StoppingGuard::new();</div><div class="diff-removed">-        runtime_handle</div><div class="diff-removed">-            .spawn_blocking({</div><div class="diff-removed">-                let segments = segments.clone();</div><div class="diff-removed">-                let points = points.to_vec();</div><div class="diff-removed">-                let with_payload = with_payload.clone();</div><div class="diff-removed">-                let with_vector = with_vector.clone();</div><div class="diff-removed">-                let is_stopped = stopping_guard.get_is_stopped();</div><div class="diff-removed">-                // TODO create one Task per segment level retrieve</div><div class="diff-removed">-                move || {</div><div class="diff-removed">-                    Self::retrieve_blocking(</div><div class="diff-removed">-                        segments,</div><div class="diff-removed">-                        &points,</div><div class="diff-removed">-                        &with_payload,</div><div class="diff-removed">-                        &with_vector,</div><div class="diff-removed">-                        &is_stopped,</div><div class="diff-removed">-                        hw_measurement_acc,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                }</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .await?</div><div class="diff-removed">-    }</div><div class="diff-added">+        }</div><div> </div><div class="diff-removed">-    pub fn retrieve_blocking(</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        points: &[PointIdType],</div><div class="diff-removed">-        with_payload: &WithPayload,</div><div class="diff-removed">-        with_vector: &WithVector,</div><div class="diff-removed">-        is_stopped: &AtomicBool,</div><div class="diff-removed">-        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<AHashMap<PointIdType, RecordInternal>> {</div><div class="diff-removed">-        let mut point_version: AHashMap<PointIdType, SeqNumberType> = Default::default();</div><div class="diff-removed">-        let mut point_records: AHashMap<PointIdType, RecordInternal> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = hw_measurement_acc.get_counter_cell();</div><div class="diff-removed">-</div><div class="diff-removed">-        segments</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .read_points(points, is_stopped, |id, segment| {</div><div class="diff-removed">-                let version = segment.point_version(id).ok_or_else(|| {</div><div class="diff-removed">-                    OperationError::service_error(format!("No version for point {id}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-</div><div class="diff-removed">-                // If we already have the latest point version, keep that and continue</div><div class="diff-removed">-                let version_entry = point_version.entry(id);</div><div class="diff-removed">-                if matches!(&version_entry, Entry::Occupied(entry) if *entry.get() >= version) {</div><div class="diff-removed">-                    return Ok(true);</div><div class="diff-removed">-                }</div><div class="diff-added">+ </div><div> </div><div class="diff-removed">-                point_records.insert(</div><div class="diff-removed">-                    id,</div><div class="diff-removed">-                    RecordInternal {</div><div class="diff-removed">-                        id,</div><div class="diff-removed">-                        payload: if with_payload.enable {</div><div class="diff-removed">-                            if let Some(selector) = &with_payload.payload_selector {</div><div class="diff-removed">-                                Some(selector.process(segment.payload(id, &hw_counter)?))</div><div class="diff-removed">-                            } else {</div><div class="diff-removed">-                                Some(segment.payload(id, &hw_counter)?)</div><div class="diff-removed">-                            }</div><div class="diff-removed">-                        } else {</div><div class="diff-removed">-                            None</div><div class="diff-removed">-                        },</div><div class="diff-removed">-                        vector: {</div><div class="diff-removed">-                            match with_vector {</div><div class="diff-removed">-                                WithVector::Bool(true) => {</div><div class="diff-removed">-                                    let vectors = segment.all_vectors(id)?;</div><div class="diff-removed">-                                    hw_counter</div><div class="diff-removed">-                                        .vector_io_read()</div><div class="diff-removed">-                                        .incr_delta(vectors.estimate_size_in_bytes());</div><div class="diff-removed">-                                    Some(VectorStructInternal::from(vectors))</div><div class="diff-removed">-                                }</div><div class="diff-removed">-                                WithVector::Bool(false) => None,</div><div class="diff-removed">-                                WithVector::Selector(vector_names) => {</div><div class="diff-removed">-                                    let mut selected_vectors = NamedVectors::default();</div><div class="diff-removed">-                                    for vector_name in vector_names {</div><div class="diff-removed">-                                        if let Some(vector) = segment.vector(vector_name, id)? {</div><div class="diff-removed">-                                            selected_vectors.insert(vector_name.clone(), vector);</div><div class="diff-removed">-                                        }</div><div class="diff-removed">-                                    }</div><div class="diff-removed">-                                    hw_counter</div><div class="diff-removed">-                                        .vector_io_read()</div><div class="diff-removed">-                                        .incr_delta(selected_vectors.estimate_size_in_bytes());</div><div class="diff-removed">-                                    Some(VectorStructInternal::from(selected_vectors))</div><div class="diff-removed">-                                }</div><div class="diff-removed">-                            }</div><div class="diff-removed">-                        },</div><div class="diff-removed">-                        shard_key: None,</div><div class="diff-removed">-                        order_value: None,</div><div class="diff-removed">-                    },</div><div class="diff-removed">-                );</div><div class="diff-removed">-                *version_entry.or_default() = version;</div><div class="diff-added">+        let top_scores: Vec<_> = result_aggregator.into_topk();</div><div> </div><div class="diff-removed">-                Ok(true)</div><div class="diff-removed">-            })?;</div><div class="diff-added">+        Ok(top_scores)</div><div> </div><div class="diff-removed">-        Ok(point_records)</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn read_filtered(</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        filter: Option<&Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let stopping_guard = StoppingGuard::new();</div><div class="diff-removed">-        let filter = filter.cloned();</div><div class="diff-removed">-        runtime_handle</div><div class="diff-removed">-            .spawn_blocking(move || {</div><div class="diff-removed">-                let is_stopped = stopping_guard.get_is_stopped();</div><div class="diff-removed">-                let segments = segments.read();</div><div class="diff-removed">-                let hw_counter = hw_measurement_acc.get_counter_cell();</div><div class="diff-removed">-                let all_points: BTreeSet<_> = segments</div><div class="diff-removed">-                    .non_appendable_then_appendable_segments()</div><div class="diff-removed">-                    .flat_map(|segment| {</div><div class="diff-removed">-                        segment.get().read().read_filtered(</div><div class="diff-removed">-                            None,</div><div class="diff-removed">-                            None,</div><div class="diff-removed">-                            filter.as_ref(),</div><div class="diff-removed">-                            &is_stopped,</div><div class="diff-removed">-                            &hw_counter,</div><div class="diff-removed">-                        )</div><div class="diff-removed">-                    })</div><div class="diff-removed">-                    .collect();</div><div class="diff-removed">-                Ok(all_points)</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .await?</div><div class="diff-removed">-    }</div><div class="diff-added">+ </div><div> </div><div>     /// Rescore results with a formula that can reference payload values.</div><div class="diff-added">+</div><div>     ///</div><div class="diff-added">+</div><div>     /// Aggregates rescores from the segments.</div><div class="diff-added">+</div><div>     pub async fn rescore_with_formula(</div><div class="diff-added">+</div><div>         segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div>         arc_ctx: Arc<FormulaContext>,</div><div class="diff-added">+</div><div>         runtime_handle: &Handle,</div><div class="diff-added">+</div><div>         hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-added">+</div><div>     ) -> CollectionResult<Vec<ScoredPoint>> {</div><div class="diff-added">+</div><div>         let limit = arc_ctx.limit;</div><div> </div><div class="diff-removed">-        let mut futures = {</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let futures = {</div><div class="diff-added">+</div><div>             let segments_guard = segments.read();</div><div class="diff-added">+</div><div>             segments_guard</div><div class="diff-added">+</div><div>                 .non_appendable_then_appendable_segments()</div><div class="diff-added">+</div><div>                 .map(|segment| {</div><div class="diff-added">+</div><div>                     runtime_handle.spawn_blocking({</div><div class="diff-added">+</div><div>                         let segment = segment.clone();</div><div class="diff-added">+</div><div>                         let arc_ctx = arc_ctx.clone();</div><div class="diff-added">+</div><div>                         let hw_counter = hw_measurement_acc.get_counter_cell();</div><div class="diff-removed">-                        move || {</div><div class="diff-removed">-                            segment</div><div class="diff-removed">-                                .get()</div><div class="diff-removed">-                                .read()</div><div class="diff-removed">-                                .rescore_with_formula(arc_ctx, &hw_counter)</div><div class="diff-removed">-                        }</div><div class="diff-added">+</div><div class="diff-added">+                        move || segment.get().read().rescore_with_formula(arc_ctx, &hw_counter)</div><div class="diff-added">+</div><div>                     })</div><div class="diff-added">+</div><div>                 })</div><div class="diff-added">+</div><div>                 .collect::<FuturesUnordered<_>>()</div><div class="diff-added">+</div><div>         };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let mut segments_results = Vec::with_capacity(futures.len());</div><div class="diff-added">+</div><div>         while let Some(result) = futures.try_next().await? {</div><div class="diff-added">+</div><div>             segments_results.push(result?)</div><div class="diff-added">+</div><div>         }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         // use aggregator with only one "batch"</div><div class="diff-added">+</div><div>         let mut aggregator = BatchResultAggregator::new(std::iter::once(limit));</div><div class="diff-added">+</div><div>         aggregator.update_point_versions(segments_results.iter().flatten());</div><div class="diff-added">+</div><div>         aggregator.update_batch_results(0, segments_results.into_iter().flatten());</div><div class="diff-removed">-        let top =</div><div class="diff-removed">-            aggregator.into_topk().into_iter().next().ok_or_else(|| {</div><div class="diff-removed">-                OperationError::service_error("expected first result of aggregator")</div><div class="diff-removed">-            })?;</div><div> </div><div class="diff-removed">-        Ok(top)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+        let top = aggregator.into_topk().into_iter().next().ok_or_else(|| {</div><div> </div><div class="diff-removed">-#[derive(PartialEq, Default, Debug)]</div><div class="diff-removed">-pub enum SearchType {</div><div class="diff-removed">-    #[default]</div><div class="diff-removed">-    Nearest,</div><div class="diff-removed">-    RecommendBestScore,</div><div class="diff-removed">-    RecommendSumScores,</div><div class="diff-removed">-    Discover,</div><div class="diff-removed">-    Context,</div><div class="diff-removed">-}</div><div class="diff-added">+            OperationError::service_error("expected first result of aggregator")</div><div class="diff-added">+</div><div class="diff-added">+        })?;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        Ok(top)</div><div> </div><div class="diff-removed">-impl From<&QueryEnum> for SearchType {</div><div class="diff-removed">-    fn from(query: &QueryEnum) -> Self {</div><div class="diff-removed">-        match query {</div><div class="diff-removed">-            QueryEnum::Nearest(_) => Self::Nearest,</div><div class="diff-removed">-            QueryEnum::RecommendBestScore(_) => Self::RecommendBestScore,</div><div class="diff-removed">-            QueryEnum::RecommendSumScores(_) => Self::RecommendSumScores,</div><div class="diff-removed">-            QueryEnum::Discover(_) => Self::Discover,</div><div class="diff-removed">-            QueryEnum::Context(_) => Self::Context,</div><div class="diff-removed">-        }</div><div>     }</div><div class="diff-removed">-}</div><div class="diff-added">+</div><div class="diff-added">+ }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div> #[derive(PartialEq, Default, Debug)]</div><div class="diff-added">+</div><div> struct BatchSearchParams<'a> {</div><div class="diff-added">+</div><div>     pub search_type: SearchType,</div><div class="diff-added">+</div><div>     pub vector_name: &'a VectorName,</div><div class="diff-added">+</div><div>     pub filter: Option<&'a Filter>,</div><div class="diff-added">+</div><div>     pub with_payload: WithPayload,</div><div class="diff-added">+</div><div>     pub with_vector: WithVector,</div><div class="diff-added">+</div><div>     pub top: usize,</div><div class="diff-added">+</div><div>     pub params: Option<&'a SearchParams>,</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+/// Determines the effective ef limit value for the given parameters.</div><div class="diff-added">+</div><div class="diff-added">+fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {</div><div class="diff-added">+</div><div class="diff-added">+    // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit</div><div class="diff-added">+</div><div class="diff-added">+    poisson_sampling.max(ef_limit).min(limit)</div><div class="diff-added">+</div><div> }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div> /// Returns suggested search sampling size for a given number of points and required limit.</div><div class="diff-added">+</div><div> fn sampling_limit(</div><div class="diff-added">+</div><div>     limit: usize,</div><div class="diff-added">+</div><div>     ef_limit: Option<usize>,</div><div class="diff-added">+</div><div>     segment_points: usize,</div><div class="diff-added">+</div><div>     total_points: usize,</div><div class="diff-added">+</div><div> ) -> usize {</div><div class="diff-added">+</div><div>     // shortcut empty segment</div><div class="diff-added">+</div><div>     if segment_points == 0 {</div><div class="diff-added">+</div><div>         return 0;</div><div class="diff-added">+</div><div>     }</div><div class="diff-added">+</div><div>     let segment_probability = segment_points as f64 / total_points as f64;</div><div class="diff-removed">-    let poisson_sampling =</div><div class="diff-removed">-        find_search_sampling_over_point_distribution(limit as f64, segment_probability);</div><div class="diff-added">+</div><div class="diff-added">+    let poisson_sampling = find_search_sampling_over_point_distribution(limit as f64, segment_probability).unwrap_or(limit);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>     // if no ef_limit was found, it is a plain index => sampling optimization is not needed.</div><div class="diff-added">+</div><div>     let effective = ef_limit.map_or(limit, |ef_limit| {</div><div class="diff-added">+</div><div>         effective_limit(limit, ef_limit, poisson_sampling)</div><div class="diff-added">+</div><div>     });</div><div class="diff-added">+</div><div>     log::trace!(</div><div class="diff-removed">-        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",</div><div class="diff-added">+</div><div class="diff-added">+        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: { Geh total_points}",</div><div class="diff-added">+</div><div>     );</div><div class="diff-added">+</div><div>     effective</div><div class="diff-removed">-}</div><div> </div><div class="diff-removed">-/// Determines the effective ef limit value for the given parameters.</div><div class="diff-removed">-fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {</div><div class="diff-removed">-    // Prefer the highest of poisson_sampling/ef_limit, but never be higher than limit</div><div class="diff-removed">-    poisson_sampling.max(ef_limit).min(limit)</div><div> }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div> /// Process sequentially contiguous batches</div><div class="diff-added">+</div><div> ///</div><div class="diff-added">+</div><div> /// # Arguments</div><div class="diff-added">+</div><div> ///</div><div class="diff-added">+</div><div> /// * `segment` - Locked segment to search in</div><div class="diff-added">+</div><div> /// * `request` - Batch of search requests</div><div class="diff-added">+</div><div> /// * `use_sampling` - If true, try to use probabilistic sampling</div><div class="diff-added">+</div><div> /// * `query_context` - Additional context for the search</div><div class="diff-added">+</div><div> ///</div><div class="diff-added">+</div><div> /// # Returns</div><div class="diff-added">+</div><div> ///</div><div class="diff-removed">-/// Collection Result of:</div><div class="diff-added">+</div><div class="diff-added">+/// Collection Result of	n</div><div class="diff-added">+</div><div> /// * Vector of ScoredPoints for each request in the batch</div><div class="diff-added">+</div><div> /// * Vector of boolean indicating if the segment have further points to search</div><div class="diff-added">+</div><div> fn search_in_segment(</div><div class="diff-added">+</div><div>     segment: LockedSegment,</div><div class="diff-added">+</div><div>     request: Arc<CoreSearchRequestBatch>,</div><div class="diff-added">+</div><div>     use_sampling: bool,</div><div class="diff-added">+</div><div>     segment_query_context: &SegmentQueryContext,</div><div class="diff-removed">-) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {</div><div class="diff-added">+</div><div class="diff-added">+) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>>> {</div><div class="diff-added">+</div><div>     let batch_size = request.searches.len();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     let mut result: Vec<Vec<ScoredPoint>> = Vec::with_capacity(batch_size);</div><div class="diff-removed">-    let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // if segment have more points to return</div><div class="diff-added">+</div><div class="diff-added">+    let mut further_results: Vec< bool > = Vec::with_capacity(batch_size); // if segment have more points to return</div><div class="diff-added">+</div><div>     let mut vectors_batch: Vec<QueryVector> = vec![];</div><div class="diff-added">+</div><div>     let mut prev_params = BatchSearchParams::default();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     for search_query in &request.searches {</div><div class="diff-added">+</div><div>         let with_payload_interface = search_query</div><div class="diff-added">+</div><div>             .with_payload</div><div class="diff-added">+</div><div>             .as_ref()</div><div class="diff-added">+</div><div>             .unwrap_or(&WithPayloadInterface::Bool(false));</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let params = BatchSearchParams {</div><div class="diff-added">+</div><div>             search_type: search_query.query.as_ref().into(),</div><div class="diff-added">+</div><div>             vector_name: search_query.query.get_vector_name(),</div><div class="diff-added">+</div><div>             filter: search_query.filter.as_ref(),</div><div class="diff-added">+</div><div>             with_payload: WithPayload::from(with_payload_interface),</div><div class="diff-added">+</div><div>             with_vector: search_query.with_vector.clone().unwrap_or_default(),</div><div class="diff-added">+</div><div>             top: search_query.limit + search_query.offset,</div><div class="diff-added">+</div><div>             params: search_query.params.as_ref(),</div><div class="diff-added">+</div><div>         };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let query = search_query.query.clone().into();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         // same params enables batching (cmp expensive on large filters)</div><div class="diff-added">+</div><div>         if params == prev_params {</div><div class="diff-added">+</div><div>             vectors_batch.push(query);</div><div class="diff-added">+</div><div>         } else {</div><div class="diff-added">+</div><div>             // different params means different batches</div><div class="diff-added">+</div><div>             // execute what has been batched so far</div><div class="diff-added">+</div><div>             if !vectors_batch.is_empty() {</div><div class="diff-added">+</div><div>                 let (mut res, mut further) = execute_batch_search(</div><div class="diff-added">+</div><div>                     &segment,</div><div class="diff-added">+</div><div>                     &vectors_batch,</div><div class="diff-added">+</div><div>                     &prev_params,</div><div class="diff-added">+</div><div>                     use_sampling,</div><div class="diff-added">+</div><div>                     segment_query_context,</div><div class="diff-added">+</div><div>                 )?;</div><div class="diff-added">+</div><div>                 further_results.append(&mut further);</div><div class="diff-added">+</div><div>                 result.append(&mut res);</div><div class="diff-added">+</div><div>                 vectors_batch.clear()</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>             // start new batch for current search query</div><div class="diff-added">+</div><div>             vectors_batch.push(query);</div><div class="diff-added">+</div><div>             prev_params = params;</div><div class="diff-added">+</div><div>         }</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     // run last batch if any</div><div class="diff-added">+</div><div>     if !vectors_batch.is_empty() {</div><div class="diff-added">+</div><div>         let (mut res, mut further) = execute_batch_search(</div><div class="diff-added">+</div><div>             &segment,</div><div class="diff-added">+</div><div>             &vectors_batch,</div><div class="diff-added">+</div><div>             &prev_params,</div><div class="diff-added">+</div><div>             use_sampling,</div><div class="diff-added">+</div><div>             segment_query_context,</div><div class="diff-added">+</div><div>         )?;</div><div class="diff-added">+</div><div>         further_results.append(&mut further);</div><div class="diff-added">+</div><div>         result.append(&mut res);</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     Ok((result, further_results))</div><div class="diff-added">+</div><div> }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div> fn execute_batch_search(</div><div class="diff-added">+</div><div>     segment: &LockedSegment,</div><div class="diff-added">+</div><div>     vectors_batch: &[QueryVector],</div><div class="diff-added">+</div><div>     search_params: &BatchSearchParams,</div><div class="diff-added">+</div><div>     use_sampling: bool,</div><div class="diff-added">+</div><div>     segment_query_context: &SegmentQueryContext,</div><div class="diff-added">+</div><div> ) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {</div><div class="diff-added">+</div><div>     let locked_segment = segment.get();</div><div class="diff-added">+</div><div>     let read_segment = locked_segment.read();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     let segment_points = read_segment.available_point_count();</div><div class="diff-added">+</div><div>     let segment_config = read_segment.config();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     let top = if use_sampling {</div><div class="diff-added">+</div><div>         let ef_limit = search_params</div><div class="diff-added">+</div><div>             .params</div><div class="diff-added">+</div><div>             .and_then(|p| p.hnsw_ef)</div><div class="diff-removed">-            .or_else(|| get_hnsw_ef_construct(segment_config, search_params.vector_name));</div><div class="diff-added">+</div><div class="diff-added">+            . or_else(|| get_hnsw_ef_construct(segment_config, search_params.vector_name));</div><div class="diff-added">+</div><div>         sampling_limit(</div><div class="diff-added">+</div><div>             search_params.top,</div><div class="diff-added">+</div><div>             ef_limit,</div><div class="diff-added">+</div><div>             segment_points,</div><div class="diff-added">+</div><div>             segment_query_context.available_point_count(),</div><div class="diff-added">+</div><div>         )</div><div class="diff-added">+</div><div>     } else {</div><div class="diff-added">+</div><div>         search_params.top</div><div class="diff-added">+</div><div>     };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     let vectors_batch = &vectors_batch.iter().collect_vec();</div><div class="diff-added">+</div><div>     let res = read_segment.search_batch(</div><div class="diff-added">+</div><div>         search_params.vector_name,</div><div class="diff-added">+</div><div>         vectors_batch,</div><div class="diff-added">+</div><div>         &search_params.with_payload,</div><div class="diff-added">+</div><div>         &search_params.with_vector,</div><div class="diff-added">+</div><div>         search_params.filter,</div><div class="diff-added">+</div><div>         top,</div><div class="diff-added">+</div><div>         search_params.params,</div><div class="diff-added">+</div><div>         segment_query_context,</div><div class="diff-added">+</div><div>     )?;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     let further_results = res</div><div class="diff-added">+</div><div>         .iter()</div><div class="diff-added">+</div><div>         .map(|batch_result| batch_result.len() == top)</div><div class="diff-added">+</div><div>         .collect();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     Ok((res, further_results))</div><div class="diff-added">+</div><div> }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div> /// Find the HNSW ef_construct for a named vector</div><div class="diff-added">+</div><div> ///</div><div class="diff-added">+</div><div> /// If the given named vector has no HNSW index, `None` is returned.</div><div class="diff-added">+</div><div> fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Option<usize> {</div><div class="diff-added">+</div><div>     config</div><div class="diff-added">+</div><div>         .vector_data</div><div class="diff-added">+</div><div>         .get(vector_name)</div><div class="diff-added">+</div><div>         .and_then(|config| match &config.index {</div><div class="diff-added">+</div><div>             Indexes::Plain {} => None,</div><div class="diff-added">+</div><div>             Indexes::Hnsw(hnsw) => Some(hnsw),</div><div class="diff-added">+</div><div>         })</div><div class="diff-added">+</div><div>         .map(|hnsw| hnsw.ef_construct)</div><div class="diff-added">+</div><div> }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div> #[cfg(test)]</div><div class="diff-added">+</div><div> mod tests {</div><div class="diff-removed">-    use ahash::AHashSet;</div><div class="diff-added">+</div><div class="diff-added">+    use std::collections::AHashSet;</div><div class="diff-added">+</div><div>     use api::rest::SearchRequestInternal;</div><div class="diff-added">+</div><div>     use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-added">+</div><div>     use parking_lot::RwLock;</div><div class="diff-added">+</div><div>     use segment::data_types::vectors::DEFAULT_VECTOR_NAME;</div><div class="diff-added">+</div><div>     use segment::fixtures::index_fixtures::random_vector;</div><div class="diff-added">+</div><div>     use segment::index::VectorIndexEnum;</div><div class="diff-added">+</div><div>     use segment::types::{Condition, HasIdCondition};</div><div class="diff-added">+</div><div>     use tempfile::Builder;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     use super::*;</div><div class="diff-added">+</div><div>     use crate::collection_manager::fixtures::{build_test_holder, random_segment};</div><div class="diff-removed">-    use crate::collection_manager::holders::segment_holder::SegmentHolder;</div><div class="diff-added">+</div><div>     use crate::operations::types::CoreSearchRequest;</div><div class="diff-added">+</div><div>     use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_is_indexed_enough_condition() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::new().prefix("segment_dir") .tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>         let segment1 = random_segment(dir.path(), 10, 200, 256);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let vector_index = segment1</div><div class="diff-added">+</div><div>             .vector_data</div><div class="diff-added">+</div><div>             .get(DEFAULT_VECTOR_NAME)</div><div class="diff-added">+</div><div>             .unwrap()</div><div class="diff-added">+</div><div>             .vector_index</div><div class="diff-added">+</div><div>             .clone();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let vector_index_borrow = vector_index.borrow();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let hw_counter = HardwareCounterCell::new();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         match &*vector_index_borrow {</div><div class="diff-added">+</div><div>             VectorIndexEnum::Plain(plain_index) => {</div><div class="diff-added">+</div><div>                 let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);</div><div class="diff-added">+</div><div>                 assert!(!res_1);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                 let res_2 =</div><div class="diff-removed">-                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);</div><div class="diff-added">+</div><div class="diff-added">+                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);</div><div class="diff-added">+</div><div>                 assert!(res_2);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                 let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                 let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>                 let res_3 = plain_index.is_small_enough_for_unindexed_search(</div><div class="diff-added">+</div><div>                     25,</div><div class="diff-added">+</div><div>                     Some(&ids_filter),</div><div class="diff-added">+</div><div>                     &hw_counter,</div><div class="diff-added">+</div><div>                 );</div><div class="diff-added">+</div><div>                 assert!(res_3);</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>             _ => panic!("Expected plain index"),</div><div class="diff-added">+</div><div>         }</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[tokio::test]</div><div class="diff-added">+</div><div>     async fn test_segments_search() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::?w new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>         let segment_holder = build_test_holder(dir.path());</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let query = vec![1.0, 1.0, 1.0, 1.0];</div><div> </div><div class="diff-removed">-        let req = CoreSearchRequest {</div><div class="diff-removed">-            query: query.into(),</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let req = SearchRequestInternal {</div><div class="diff-added">+</div><div class="diff-added">+            vector: query.into(),</div><div class="diff-added">+</div><div>             with_payload: None,</div><div class="diff-added">+</div><div>             with_vector: None,</div><div class="diff-added">+</div><div>             filter: None,</div><div class="diff-added">+</div><div>             params: None,</div><div class="diff-added">+</div><div>             limit: 5,</div><div class="diff-added">+</div><div class="diff-added">+            offset: None,</div><div class="diff-added">+</div><div>             score_threshold: None,</div><div class="diff-removed">-            offset: 0,</div><div class="diff-added">+</div><div>         };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let batch_request = CoreSearchRequestBatch {</div><div class="diff-added">+</div><div>             searches: vec![req],</div><div class="diff-added">+</div><div>         };</div><div> </div><div class="diff-removed">-        let hw_acc = HwMeasurementAcc::new();</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let result = SegmentsSearcher::search(</div><div class="diff-removed">-            Arc::new(segment_holder),</div><div class="diff-added">+</div><div class="diff-added">+            Arc::new(segmentDon holder),</div><div class="diff-added">+</div><div>             Arc::new(batch_request),</div><div class="diff-added">+</div><div>             &Handle::current(),</div><div class="diff-added">+</div><div>             true,</div><div class="diff-removed">-            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_acc),</div><div class="diff-added">+</div><div class="diff-added">+            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, HwMeasurementAcc::new()),</div><div class="diff-added">+</div><div>         )</div><div class="diff-removed">-        .await</div><div class="diff-removed">-        .unwrap()</div><div class="diff-removed">-        .into_iter()</div><div class="diff-removed">-        .next()</div><div class="diff-removed">-        .unwrap();</div><div> </div><div class="diff-removed">-        // eprintln!("result = {:?}", &result);</div><div class="diff-added">+            .await</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap()</div><div class="diff-added">+</div><div class="diff-added">+            .into_iter()</div><div class="diff-added">+</div><div class="diff-added">+            .next()</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>         assert_eq!(result.len(), 5);</div><div> </div><div class="diff-removed">-        assert!(result[0].id == 3.into() || result[0].id == 11.into());</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        assert!(result[0].id == 3.into() || result[0 cochlear ].id == 11.into());</div><div class="diff-added">+</div><div>         assert!(result[1].id == 3.into() || result[1].id == 11.into());</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[tokio::test]</div><div class="diff-added">+</div><div>     async fn test_segments_search_sampling() {</div><div class="diff-added">+</div><div>         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let segment1 = random_segment(dir.path(), 10, 2000, 4);</div><div class="diff-added">+</div><div>         let segment2 = random_segment(dir.path(), 10, 4000, 4);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let mut holder = SegmentHolder::default();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let _sid1 = holder.add_new(segment1);</div><div class="diff-added">+</div><div>         let _sid2 = holder.add_new(segment2);</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let segment_holder = Arc::new(RwLock::new(holder));</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let mut rnd = rand::rng();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         for _ in 0..100 {</div><div class="diff-added">+</div><div>             let req1 = SearchRequestInternal {</div><div class="diff-added">+</div><div>                 vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-added">+</div><div>                 limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-added">+</div><div>                 offset: None,</div><div class="diff-added">+</div><div>                 with_payload: None,</div><div class="diff-added">+</div><div>                 with_vector: None,</div><div class="diff-added">+</div><div>                 filter: None,</div><div class="diff-added">+</div><div>                 params: None,</div><div class="diff-added">+</div><div>                 score_threshold: None,</div><div class="diff-added">+</div><div>             };</div><div class="diff-added">+</div><div>             let req2 = SearchRequestInternal {</div><div class="diff-added">+</div><div>                 vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-added">+</div><div>                 limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-added">+</div><div>                 offset: None,</div><div class="diff-added">+</div><div>                 filter: None,</div><div class="diff-added">+</div><div>                 params: None,</div><div class="diff-added">+</div><div>                 with_payload: None,</div><div class="diff-added">+</div><div>                 with_vector: None,</div><div class="diff-added">+</div><div>                 score_threshold: None,</div><div class="diff-added">+</div><div>             };</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             let batch_request = CoreSearchRequestBatch {</div><div class="diff-removed">-                searches: vec![req1.into(), req2.into()],</div><div class="diff-added">+</div><div class="diff-added">+                searches: vec![req1, req2],</div><div class="diff-added">+</div><div>             };</div><div> </div><div class="diff-removed">-            let batch_request = Arc::new(batch_request);</div><div class="diff-added">+ </div><div> </div><div>             let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+</div><div class="diff-added">+            let query_context = QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>             let result_no_sampling = SegmentsSearcher::search(</div><div class="diff-added">+</div><div>                 segment_holder.clone(),</div><div class="diff-removed">-                batch_request.clone(),</div><div class="diff-removed">-                &Handle::current(),</div><div class="diff-removed">-                false,</div><div class="diff-added">+</div><div class="diff-added">+                Arc::new(batch_request.clone()),</div><div class="diff-added">+</div><div class="diff-added">+                &Handle::current(), </div><div class="diff-added">+</div><div class="diff-added">+                false, </div><div class="diff-added">+</div><div>                 query_context,</div><div class="diff-added">+</div><div>             )</div><div class="diff-added">+</div><div>             .await</div><div class="diff-added">+</div><div>             .unwrap();</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div> </div><div class="diff-removed">-            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+            hw_measurement_acc.discard();</div><div> </div><div class="diff-removed">-            assert!(!result_no_sampling.is_empty());</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let hw_measurement_acc = HwMeasurementEmb Acc::new();</div><div class="diff-added">+</div><div class="diff-added">+            let query_context = QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            assert(!result_no_sampling.is_empty());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div> </div><div>             let result_sampling = SegmentsSearcher::search(</div><div class="diff-added">+</div><div>                 segment_holder.clone(),</div><div class="diff-removed">-                batch_request,</div><div class="diff-added">+</div><div class="diff-added">+                Arc::new(batch_request),</div><div class="diff-added">+</div><div>                 &Handle::current(),</div><div class="diff-added">+</div><div>                 true,</div><div class="diff-added">+</div><div>                 query_context,</div><div class="diff-added">+</div><div>             )</div><div class="diff-added">+</div><div>             .await</div><div class="diff-added">+</div><div>             .unwrap();</div><div class="diff-added">+</div><div>             assert!(!result_sampling.is_empty());</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div> </div><div class="diff-added">+            hw_measurement_acc.discard();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>             // assert equivalence in depth</div><div class="diff-added">+</div><div>             assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());</div><div class="diff-added">+</div><div>             assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());</div><div> </div><div class="diff-removed">-            for (no_sampling, sampling) in</div><div class="diff-removed">-                result_no_sampling[0].iter().zip(result_sampling[0].iter())</div><div class="diff-removed">-            {</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            for (no_sampling, sampling) in result_no_sampling[0].iter().zip(result_sampling[0].iter()) {</div><div class="diff-added">+</div><div>                 assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>         }</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_retrieve() {</div><div class="diff-added">+</div><div>         let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div>         let segment_holder = build_test_holder(dir.path());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div>         let records = SegmentsSearcher::retrieve_blocking(</div><div class="diff-added">+</div><div>             Arc::new(segment_holder),</div><div class="diff-added">+</div><div>             &[1.into(), 2.into(), 3.into()],</div><div class="diff-added">+</div><div>             &WithPayload::from(true),</div><div class="diff-added">+</div><div>             &true.into(),</div><div class="diff-added">+</div><div>             &AtomicBool::new(false),</div><div class="diff-added">+</div><div>             HwMeasurementAcc::new(),</div><div class="diff-added">+</div><div>         )</div><div class="diff-added">+</div><div>         .unwrap();</div><div class="diff-added">+</div><div>         assert_eq!(records.len(), 3);</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_sampling_limit() {</div><div class="diff-added">+</div><div>         assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_sampling_limit_ef() {</div><div class="diff-added">+</div><div>         assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_sampling_limit_high() {</div><div class="diff-added">+</div><div>         assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);</div><div class="diff-added">+</div><div>     }</div><div> </div><div class="diff-added">+ </div><div class="diff-added">+</div><div>     /// Tests whether calculating the effective ef limit value is correct.</div><div class="diff-added">+</div><div>     ///</div><div class="diff-added">+</div><div>     /// Because there was confusion about what the effective value should be for some input</div><div class="diff-added">+</div><div>     /// combinations, we decided to write this tests to ensure correctness.</div><div class="diff-added">+</div><div>     ///</div><div class="diff-added">+</div><div>     /// See: <https://github.com/qdrant/qdrant/pull/1694></div><div class="diff-added">+</div><div>     #[test]</div><div class="diff-added">+</div><div>     fn test_effective_limit() {</div><div class="diff-added">+</div><div>         // Test cases to assert: (limit, ef_limit, poisson_sampling, effective)</div><div class="diff-added">+</div><div>         let tests = [</div><div class="diff-added">+</div><div>             (1000, 128, 150, 150),</div><div class="diff-added">+</div><div>             (1000, 128, 110, 128),</div><div class="diff-added">+</div><div>             (130, 128, 150, 130),</div><div class="diff-added">+</div><div>             (130, 128, 110, 128),</div><div class="diff-added">+</div><div>             (50, 128, 150, 50),</div><div class="diff-added">+</div><div>             (50, 128, 110, 50),</div><div class="diff-added">+</div><div>             (500, 1000, 300, 500),</div><div class="diff-added">+</div><div>             (500, 400, 300, 400),</div><div class="diff-added">+</div><div>             (1000, 0, 150, 150),</div><div class="diff-added">+</div><div>             (1000, 0, 110, 110),</div><div class="diff-added">+</div><div>         ];</div><div class="diff-removed">-        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective)| assert_eq!(</div><div class="diff-removed">-            effective_limit(limit, ef_limit, poisson_sampling),</div><div class="diff-removed">-            effective,</div><div class="diff-removed">-            "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",</div><div class="diff-removed">-        ));</div><div class="diff-added">+</div><div class="diff-added">+        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective| {</div><div class="diff-added">+</div><div class="diff-added">+            assert_eq!(</div><div class="diff-added">+</div><div class="diff-added">+                effective_limit(limit, ef_limit, poisson_sampling),</div><div class="diff-added">+</div><div class="diff-added">+                effective,</div><div class="diff-added">+</div><div class="diff-added">+                "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",</div><div class="diff-added">+</div><div class="diff-added">+            )</div><div class="diff-added">+</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div>     }</div><div class="diff-added">+</div><div class="diff-added">+ }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+I think this is the final version from the history provided.</div><div class="diff-added">+</div><div class="diff-added">+The user message has more commits after that, up to the rand bump and others.</div><div class="diff-added">+</div><div class="diff-added">+The rand bump changes mut rnd = rand::thread_rng(); to mut rnd = rand::rng();</div><div class="diff-added">+</div><div class="diff-added">+In the test_segments_search_sampling.</div><div class="diff-added">+</div><div class="diff-added">+Then the next is for cardinality estimation IO measurements, adding hw_counter to is_small_enough_for_unindexed_search calls.</div><div class="diff-added">+</div><div class="diff-added">+Then the [score boosting] fix, removing the None from rescore_with_formula.</div><div class="diff-added">+</div><div class="diff-added">+Then the sum_scores, adding RecommendSumScores to SearchType.</div><div class="diff-added">+</div><div class="diff-added">+Then use ahash for maps, changing HashMap to AHashMap for point_version and point_records in retrieve, and searches_to_rerun.</div><div class="diff-added">+</div><div class="diff-added">+Then the universal-query, but no change to this file in that diff.</div><div class="diff-added">+</div><div class="diff-added">+Then the multivector for unnamed vectors, changing selected_vectors.insert to clone vector_name.</div><div class="diff-added">+</div><div class="diff-added">+Then add order_value to Record.</div><div class="diff-added">+</div><div class="diff-added">+Then make retrieve return hashmap.</div><div class="diff-added">+</div><div class="diff-added">+Then pedantic clippy, changing f32::max_value to f32::MAX, and unwrap_or(limit) to .unwrap_or(limit) for poisson_sampling.</div><div class="diff-added">+</div><div class="diff-added">+Then facets timeout, adding  timeout to retrieve and read_filtered, with nits in segments_searcher, removing some comments? The diff is for nits, but the diff is small.</div><div class="diff-added">+</div><div class="diff-added">+The diff for 12c5d6b6b606cd5559a6452ef39d802039d02dd6 is small, adding timeout to segment faceting, but for this file, it 's nits, but the diff is not showing much.</div><div class="diff-added">+</div><div class="diff-added">+Then non blocking retrieve, adding async to retrieve, and blocking version.</div><div class="diff-added">+</div><div class="diff-added">+Then non blocking exact count, adding read_filtered async.</div><div class="diff-added">+</div><div class="diff-added">+Then inference interface, changing Record to RecordInternal, and VectorStruct to VectorStructInternal.</div><div class="diff-added">+</div><div class="diff-added">+Then hash/lookup point version only once, changing the condition in retrieve_blocking.</div><div class="diff-added">+</div><div class="diff-added">+Then timeout aware hardware counter, adding hw_measurement_acc to prepare_query_context, and changing QueryContext::new to take it.</div><div class="diff-added">+</div><div class="diff-added">+Then propagate hardware counter for more functions, adding to read_filtered.</div><div class="diff-added">+</div><div class="diff-added">+Then bump rand to 0.9, changing to rand::rng().</div><div class="diff-added">+</div><div class="diff-added">+Then rename IO metrics, no change to this file.</div><div class="diff-added">+</div><div class="diff-added">+Then the fixation for cargo doc warnings, adding ` in doc.</div><div class="diff-added">+</div><div class="diff-added">+Then add VectorName type alias, changing &str to &VectorName in some places.</div><div class="diff-added">+</div><div class="diff-added">+Then per collection hardware measurements, but the diff is for a different commit? No, it's for this file, adding hw_measurement_acc to search, and in tests.</div><div class="diff-added">+</div><div class="diff-added">+Then redundant clones removal, changing (segment.clone(), search) to (segment, search).</div><div class="diff-added">+</div><div class="diff-added">+Then use references for less cloning, changing limits.iter().copied() to limits.into_iter(), and further_results to &further_results.</div><div class="diff-added">+</div><div class="diff-added">+Then optimize search batch, adding comment about cmp expensive on large filters.</div><div class="diff-added">+</div><div class="diff-added">+Then leverage ahash in search results, changing searches_to_rerun to AHashMap.</div><div class="diff-added">+</div><div class="diff-added">+Then non-blockingsnapshot, but no change.</div><div class="diff-added">+</div><div class="diff-added">+Then on read operations, go over non-appendable first, changing the iter to non_appendable_then_appendable_segments.</div><div class="diff-added">+</div><div class="diff-added">+Then refactor segment holder, changing to add_new.</div><div class="diff-added">+</div><div class="diff-added">+Then sparse idf dot, adding QueryContext to search, and segment_query_context.</div><div class="diff-added">+</div><div class="diff-added">+Then faster deleted filter in proxy segments, removing AtomicBool from parameters, using query_context for is_stopped.</div><div class="diff-added">+</div><div class="diff-added">+Then query fetches payload and vector if necessary, changing retrieve to use BTreeSet for unique.ids, but later changed to hashmap return.</div><div class="diff-added">+</div><div class="diff-added">+The diff for that is adding to the doc, and making it return HashMap.</div><div class="diff-added">+</div><div class="diff-added">+Then execute-batch in local shard, adding comment about TODO luis to remove ordering.</div><div class="diff-added">+</div><div class="diff-added">+Then add look ups to query API definition, no change.</div><div class="diff-added">+</div><div class="diff-added">+Then universal-search local-shard refactoring, no change.</div><div class="diff-added">+</div><div class="diff-added">+Then multivector, changing VectorStructInternal.</div><div class="diff-added">+</div><div class="diff-added">+Then order_by migration, adding order_value to RecordInternal.</div><div class="diff-added">+</div><div class="diff-added">+Then make SegmentsSearcher::retrieve return hashmap, changing to AHashMap, and removing the ordering.</div><div class="diff-added">+</div><div class="diff-added">+Then pedantic clippy, changing to f32::MAX and min, and unwrap_or to .</div><div class="diff-added">+</div><div class="diff-added">+Then universal-query execute batch in local shard, adding comment about TODO luis.</div><div class="diff-added">+</div><div class="diff-added">+In that diff, it's the one with the retrieve return hashmap.</div><div class="diff-added">+</div><div class="diff-added">+No, earlier.</div><div class="diff-added">+</div><div class="diff-added">+Anyway, I think I have an idea of the final content.</div><div class="diff-added">+</div><div class="diff-added">+Let me try to write it.```rust</div><div class="diff-added">+use std::collections::hash_map::Entry;</div><div class="diff-added">+use std::collections::{BTreeSet, AHashMap};</div><div class="diff-added">+use std::sync::Arc;</div><div class="diff-added">+use std::sync::atomic::AtomicBool;</div><div class="diff-added">+</div><div class="diff-added">+use ahash::AHashMap;</div><div class="diff-added">+use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-added">+use common::types::ScoreType;</div><div class="diff-added">+use futures::stream::FuturesUnordered;</div><div class="diff-added">+use futures::{FutureExt, TryStreamExt};</div><div class="diff-added">+use itertools::Itertools;</div><div class="diff-added">+use ordered_float::Float;</div><div class="diff-added">+use segment::common::operation_error::OperationError;</div><div class="diff-added">+use segment::data_types::named_vectors::NamedVectors;</div><div class="diff-added">+use segment::data_types::query_context::{FormulaContext, QueryContext, SegmentQueryContext};</div><div class="diff-added">+use segment::data_types::vectors::{QueryVector, VectorStructInternal};</div><div class="diff-added">+use segment::types::{</div><div class="diff-added">+    Filter, Indexes, PointIdType, ScoredPoint, SearchParams, SegmentConfig, SeqNumberType,</div><div class="diff-added">+    VectorName, WithPayload, WithPayloadInterface, WithVector,</div><div class="diff-added">+};</div><div class="diff-added">+use tinyvec::TinyVec;</div><div class="diff-added">+use tokio::runtime::Handle;</div><div class="diff-added">+use tokio::task::JoinHandle;</div><div class="diff-added">+</div><div class="diff-added">+use super::holders::segment_holder::LockedSegmentHolder;</div><div class="diff-added">+use crate::collection_manager::holders::segment_holder::LockedSegment;</div><div class="diff-added">+use crate::collection_manager::probabilistic_search_sampling::find_search_sampling_over_point_distribution;</div><div class="diff-added">+use crate::collection_manager::search_result_aggregator::BatchResultAggregator;</div><div class="diff-added">+use crate::common::stopping_guard::StoppingGuard;</div><div class="diff-added">+use crate::config::CollectionConfigInternal;</div><div class="diff-added">+use crate::operations::query_enum::QueryEnum;</div><div class="diff-added">+use crate::operations::types::{</div><div class="diff-added">+    CollectionResult, CoreSearchRequestBatch, Modifier, RecordInternal,</div><div class="diff-added">+};</div><div class="diff-added">+</div><div class="diff-added">+type BatchOffset = usize;</div><div class="diff-added">+type SegmentOffset = usize;</div><div class="diff-added">+</div><div class="diff-added">+// batch -> point for one segment</div><div class="diff-added">+type SegmentBatchSearchResult = Vec<Vec<ScoredPoint>>;</div><div class="diff-added">+// Segment -> batch -> point</div><div class="diff-added">+type BatchSearchResult = Vec<SegmentBatchSearchResult>;</div><div class="diff-added">+</div><div class="diff-added">+// Result of batch search in one segment</div><div class="diff-added">+type SegmentSearchExecutedResult = CollectionResult<(SegmentBatchSearchResult, Vec<bool>)>;</div><div class="diff-added">+</div><div class="diff-added">+/// Simple implementation of segment manager</div><div class="diff-added">+///  - rebuild segment for memory optimization purposes</div><div class="diff-added">+#[derive(Default)]</div><div class="diff-added">+pub struct SegmentsSearcher;</div><div class="diff-added">+</div><div class="diff-added">+impl SegmentsSearcher {</div><div class="diff-added">+    /// Execute searches in parallel and return results in the same order as the searches were provided</div><div class="diff-added">+    async fn execute_searches(</div><div class="diff-added">+        searches: Vec<JoinHandle<SegmentSearchExecutedResult>>,</div><div class="diff-added">+    ) -> CollectionResult<(BatchSearchResult, Vec<Vec<bool>>)> {</div><div class="diff-added">+        let results_len = searches.len();</div><div class="diff-added">+</div><div class="diff-added">+        let mut search_results_per_segment_res = FuturesUnordered::new();</div><div class="diff-added">+        for (idx, search) in searches.into_iter().enumerate() {</div><div class="diff-added">+            // map the result to include the request index for later reordering</div><div class="diff-added">+            let result_with_request_index = search.map(move |res| res.map(|s| (idx, s)));</div><div class="diff-added">+            search_results_per_segment_res.push(result_with_request_index);</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let mut search_results_per_segment = vec![Vec::new(); results_len granul];</div><div class="diff-added">+        let mut further_searches_per_segment = vec![Vec::new(); results_len];</div><div class="diff-added">+</div><div class="diff-added">+        // process results as they come in and store them in the correct order</div><div class="diff-added">+</div><div class="diff-added">+        while let Some((idx, search_result)) = search_results_per_segment_res.try_next().await? {</div><div class="diff-added">+</div><div class="diff-added">+            let (search_results, further_searches) = search_result?;</div><div class="diff-added">+</div><div class="diff-added">+            debug_assert!(search_results.len() == further_searches.len());</div><div class="diff-added">+</div><div class="diff-added">+            search_results_per_segment[idx] = search_results;</div><div class="diff-added">+</div><div class="diff-added">+            further_searches_per_segment[idx] = further_searches;</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        Ok((search_results_per_segment, further_searches_per_segment))</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    /// Processes search result of `[segment_size x batch_size]`.</div><div class="diff-added">+</div><div class="diff-added">+    ///</div><div class="diff-added">+</div><div class="diff-added">+    /// # Arguments</div><div class="diff-added">+</div><div class="diff-added">+    /// * `search_result` - `[segment_size x batch_size]`</div><div class="diff-added">+</div><div class="diff-added">+    /// * `limits` - `[batch-size]` - how many results to return for each batched request</div><div class="diff-added">+</div><div class="diff-added">+    /// * `further_searches` - `[segment_size x batch_size]` - whether we can search further in the segment</div><div class="diff-added">+</div><div class="diff-added">+    ///</div><div class="diff-added">+</div><div class="diff-added">+    /// Returns batch results aggregated by `[batch_size]` and list of queries, grouped by segment to re-run</div><div class="diff-added">+</div><div class="diff-added">+    pub(crate) fn process_search_result_step1(</div><div class="diff-added">+</div><div class="diff-added">+        search_result: BatchSearchResult,</div><div class="diff-added">+</div><div class="diff-added">+        limits: Vec<usize>,</div><div class="diff-added">+</div><div class="diff-added">+        further_results: &[Vec<bool>],</div><div class="diff-added">+</div><div class="diff-added">+    ) -> (</div><div class="diff-added">+</div><div class="diff-added">+        BatchResultAggregator,</div><div class="diff-added">+</div><div class="diff-added">+        AHashMap<SegmentOffset, Vec<BatchOffset>>,</div><div class="diff-added">+</div><div class="diff-added">+    ) {</div><div class="diff-added">+</div><div class="diff-added">+        let number_segments = search_result.len();</div><div class="diff-added">+</div><div class="diff-added">+        let batch_size = limits.len();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // The lowest scored element must be larger or equal to the worst scored element in each segment.</div><div class="diff-added">+</div><div class="diff-added">+        // Otherwise, the sampling is invalid and some points might be missing.</div><div class="diff-added">+</div><div class="diff-added">+        // e.g. with 3 segments with the following sampled ranges:</div><div class="diff-added">+</div><div class="diff-added">+        // s1 - [0.91 -> 0.87]</div><div class="diff-added">+</div><div class="diff-added">+        // s2 - [0.92 -> 0.86]</div><div class="diff-added">+</div><div class="diff-added">+        // s3 - [0.93 -> 0.85]</div><div class="diff-added">+</div><div class="diff-added">+        // If the top merged scores result range is [0.93 -> 0.86] then we do not know if s1 could have contributed more points at the lower part between [0.87 -> 0.86]</div><div class="diff-added">+</div><div class="diff-added">+        // In that case, we need to re-run the search without sampling on that segment.</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // Initialize result aggregators for each batched request</div><div class="diff-added">+</div><div class="diff-added">+        let mut result_aggregator = BatchResultAggregator::new(limits.iter().copied());</div><div class="diff-added">+</div><div class="diff-added">+        result_aggregator.update_point_versions(search_result.iter().flatten().flatten());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // Therefore we need to track the lowest scored element per segment for each batch</div><div class="diff-added">+</div><div class="diff-added">+        let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![</div><div class="diff-added">+</div><div class="diff-added">+            vec![f32::MAX; batch_size];</div><div class="diff-added">+</div><div class="diff-added">+            number_segments</div><div class="diff-added">+</div><div class="diff-added">+        ];</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut retrieved_points_per_request: Vec<Vec<BatchOffset>> = vec![</div><div class="diff-added">+</div><div class="diff-added">+            vec![0; batch_size];</div><div class="diff-added">+</div><div class="diff-added">+            number_segments</div><div class="diff-added">+</div><div class="diff-added">+        ];</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // Batch results merged from all segments</div><div class="diff-added">+</div><div class="diff-added">+        for (segment_idx, segment_result) in search_result.into_iter().enumerate() {</div><div class="diff-added">+</div><div class="diff-added">+            // merge results for each batch search request across segments</div><div class="diff-added">+</div><div class="diff-added">+            for (batch_req_idx, query_res) in segment_result.into_iter().enumerate() {</div><div class="diff-added">+</div><div class="diff-added">+                retrieved_points_per_request[segment_idx][batch_req_idx] = query_res.len();</div><div class="diff-added">+</div><div class="diff-added">+                lowest_scores_per_request[segment_idx][batch_req_idx] = query_res</div><div class="diff-added">+</div><div class="diff-added">+                    .last()</div><div class="diff-added">+</div><div class="diff-added">+                    .map(|x| x.score)</div><div class="diff-added">+</div><div class="diff-added">+                    .unwrap_or_else(f32::MIN);</div><div class="diff-added">+</div><div class="diff-added">+                result_aggregator.update_batch_results(batch_req_idx, query_res.into_iter());</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // segment id -> list of batch ids</div><div class="diff-added">+</div><div class="diff-added">+        let mut searches_to_rerun: AHashMap<SegmentOffset, Vec<BatchOffset>> = AHashMap::new();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // Check if we want to re-run the search without sampling on some segments</div><div class="diff-added">+</div><div class="diff-added">+        for (batch_id, required_limit) in limits.into_iter().enumerate() {</div><div class="diff-added">+</div><div class="diff-added">+            let lowest_batch_score_opt = result_aggregator.batch_lowest_scores(batch_id);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            // If there are no results, we do not need to re-run the search</div><div class="diff-added">+</div><div class="diff-added">+            if let Some(lowest_batch_score) = lowest_batch_score_opt {</div><div class="diff-added">+</div><div class="diff-added">+                for segment_id in 0..number_segments {</div><div class="diff-added">+</div><div class="diff-added">+                    let segment_lowest_score = lowest_scores_per_request[segment_id][batch_id];</div><div class="diff-added">+</div><div class="diff-added">+                    let retrieved_points = retrieved_points_per_request[segment_id][batch_id];</div><div class="diff-added">+</div><div class="diff-added">+                    let have_further_results = further_results[segment_id][batch_id];</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                    if have_further_results</div><div class="diff-added">+</div><div class="diff-added">+                        && retrieved_points < required_limit</div><div class="diff-added">+</div><div class="diff-added">+                        && segment_lowest_score >= lowest_batch_score</div><div class="diff-added">+</div><div class="diff-added">+                    {</div><div class="diff-added">+</div><div class="diff-added">+                        log::debug!(</div><div class="diff-added">+</div><div class="diff-added">+                            "Search to re-run without sampling on segment_id: {segment_id} segment_lowest_score: {segment_lowest_score}, lowest_batch_score: {lowest_batch_score}, retrieved_points: {retrieved_points}, required_limit: {required_limit}",</div><div class="diff-added">+</div><div class="diff-added">+                        );</div><div class="diff-added">+</div><div class="diff-added">+                        // It is mn possible, that current segment can have better results than</div><div class="diff-added">+</div><div class="diff-added">+                        // the lowest score in the batch. In that case, we need to re-run the search</div><div class="diff-added">+</div><div class="diff-added">+                        // without sampling on that segment.</div><div class="diff-added">+</div><div class="diff-added">+                        searches_to_rerun</div><div class="diff-added">+</div><div class="diff-added">+                            .entry(segment_id)</div><div class="diff-added">+</div><div class="diff-added">+                            .or_default()</div><div class="diff-added">+</div><div class="diff-added">+                            .push(batch_id);</div><div class="diff-added">+</div><div class="diff-added">+                    }</div><div class="diff-added">+</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        (result_aggregator, searches_to_rerun)</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    pub async fn prepare_query_context(</div><div class="diff-added">+</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div class="diff-added">+        batch_request: &Core SearchRequestBatch,</div><div class="diff-added">+</div><div class="diff-added">+        collection_config: &CollectionConfigInternal,</div><div class="diff-added">+</div><div class="diff-added">+        is_stopped_guard: &StoppingGuard,</div><div class="diff-added">+</div><div class="diff-added">+        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-added">+</div><div class="diff-added">+    ) -> CollectionResult<Option<QueryContext>> {</div><div class="diff-added">+</div><div class="diff-added">+        let indexing_threshold_kb = collection_config</div><div class="diff-added">+</div><div class="diff-added">+            .optimizer_config</div><div class="diff-added">+</div><div class="diff-added">+            .indexing_threshold</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap_or(DEFAULT_INDEXING_THRESHOLD_KB);</div><div class="diff-added">+</div><div class="diff-added">+        let full_scan_threshold_kb = collection_config.hnsw_config.full_scan_threshold;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        const DEFAULT_CAPACITY: usize = 3;</div><div class="diff-added">+</div><div class="diff-added">+        let mut idf_vectors: TinyVec< [ &VectorName; DEFAULT_CAPACITY ] > = Default::default();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // check vector names existing</div><div class="diff-added">+</div><div class="diff-added">+        for req in &batch_request.searches {</div><div class="diff-added">+</div><div class="diff-added">+            let vector_name = req.query.get_vector_name();</div><div class="diff-added">+</div><div class="diff-added">+            collection_config.params.get_distance(vector_name)?;</div><div class="diff-added">+</div><div class="diff-added">+            if let Some(sparse_vector_params) = collection_config</div><div class="diff-added">+</div><div class="diff-added">+                .params</div><div class="diff-added">+</div><div class="diff-added">+                .get_sparse_vector_params_r opt(vector_name)</div><div class="diff-added">+</div><div class="diff-added">+            {</div><div class="diff-added">+</div><div class="diff-added">+                if sparse_vector_params.modifier == Some(Modifier::Idf)</div><div class="diff-added">+</div><div class="diff-added">+                    && !idf_vectors.contains(&vector_name)</div><div class="diff-added">+</div><div class="diff-added">+                {</div><div class="diff-added">+</div><div class="diff-added">+                    idf_vectors.push(vector_name);</div><div class="diff-added">+</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut query_context = QueryContext::new(</div><div class="diff-added">+</div><div class="diff-added">+            indexing_threshold_kb.max(full_scan_threshold_kb),</div><div class="diff-added">+</div><div class="diff-added">+            hw_measurement_acc,</div><div class="diff-added">+</div><div class="diff-added">+        )</div><div class="diff-added">+</div><div class="diff-added">+        .with_is_stopped(is_stopped_guard.get_is_stopped());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        for search_request in &batch_request.searches {</div><div class="diff-added">+</div><div class="diff-added">+            search_request</div><div class="diff-added">+</div><div class="diff-added">+                .query</div><div class="diff-added">+</div><div class="diff-added">+                .iterate_sparse(|vector_name, sparse_vector| {</div><div class="diff-added">+</div><div class="diff-added">+                    if idf_vectors.contains(&vector_name) {</div><div class="diff-added">+</div><div class="diff-added">+                        query_context.init_idf(vector_name, &sparse_vector.indices);</div><div class="diff-added">+</div><div class="diff-added">+                    }</div><div class="diff-added">+</div><div class="diff-added">+                })</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut futures = {</div><div class="diff-added">+</div><div class="diff-added">+            let segments = segments.read();</div><div class="diff-added">+</div><div class="diff-added">+            segments</div><div class="diff-added">+</div><div class="diff-added">+                .non_appendable_then_appendable_segments()</div><div class="diff-added">+</div><div class="diff-added">+                .map(|segment| runtime_handle.spawn_blocking({</div><div class="diff-added">+</div><div class="diff-added">+                    let segment = segment.clone Zon ();</div><div class="diff-added">+</div><div class="diff-added">+                    move || segment.get().read().fill_query_context(&mut query_context)</div><div class="diff-added">+</div><div class="diff-added">+                }))</div><div class="diff-added">+</div><div class="diff-added">+                .collect::<Vec<_>>()</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        for future in futures {</div><div class="diff-added">+</div><div class="diff-added">+            future.await?</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        Ok(Some(query_context))</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    pub async fn search(</div><div class="diff-added">+</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div class="diff-added">+        batch_request: Arc<CoreSearchRequestBatch>,</div><div class="diff-added">+</div><div class="diff-added">+        runtime_handle: &Handle,</div><div class="diff-added">+</div><div class="diff-added">+        sampling_enabled: bool,</div><div class="diff-added">+</div><div class="diff-added">+        query_context: QueryContext,</div><div class="diff-added">+</div><div class="diff-added">+        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-added">+</div><div class="diff-added">+    ) -> CollectionResult<Vec<Vec<ScoredPoint>>> {</div><div class="diff-added">+</div><div class="diff-added">+        let query_context_arc = Arc::new(query_context);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let (locked_segments, searches): (Vec<_>, Vec<_> ) = {</div><div class="diff-added">+</div><div class="diff-added">+            let segments_lock = segments.read();</div><div class="diff-added">+</div><div class="diff-added">+            let segments = segments_lock.non_appendable_then_appendable_segments();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let use_sampling = sampling_enabled</div><div class="diff-added">+</div><div class="diff-added">+                && segments_lock.len() > 1</div><div class="diff-added">+</div><div class="diff-added">+                && query_context_arc.available_point_count() > 0;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            segments</div><div class="diff-added">+</div><div class="diff-added">+                .map(|segment| {</div><div class="diff-added">+</div><div class="diff-added">+                    let query_context_arc_segment = query_context_arc.clone();</div><div class="diff-added">+</div><div class="diff-added">+                    let hw_collector = hw_measurement_acc.new_collector();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                   let search = runtime_handle.spawn_blocking(move || {</div><div class="diff-added">+</div><div class="diff-added">+                        let segment_query_context = query_context_arc_segment.get_segment_query_context();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        let res = search_in_segment(</div><div class="diff-added">+</div><div class="diff-added">+                            segment,</div><div class="diff-added">+</div><div class="diff-added">+                            batch_request,</div><div class="diff-added">+</div><div class="diff-added">+                            use_sampling,</div><div class="diff-added">+</div><div class="diff-added">+                            &segment_query_context,</div><div class="diff-added">+</div><div class="diff-added">+                        );</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        hw collector.merge_from_cell(segment_query_context.take_hardware_counter());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        res</div><div class="diff-added">+</div><div class="diff-added">+                    });</div><div class="diff-added">+</div><div class="diff-added">+                    (segment, search)</div><div class="diff-added">+</div><div class="diff-added">+                })</div><div class="diff-added">+</div><div class="diff-added">+                .unzip()</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        // perform search on all segments concurrently</div><div class="diff-added">+</div><div class="diff-added">+        let (all_search_results_per_segment, further_results) = Self::execute_searches(searches).await?;</div><div class="diff-added">+</div><div class="diff-added">+        debug_assert!(all_search_results_per_segment.len() == locked_segments.len());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let (mut result_aggregator, searches_to_rerun) = Self::process_search_result_step1(</div><div class="diff-added">+</div><div class="diff-added">+            all_search_results_per_segment,</div><div class="diff-added">+</div><div class="diff-added">+            batch_request</div><div class="diff-added">+</div><div class="diff-added">+                .searches</div><div class="diff-added">+</div><div class="diff-added">+                .iter()</div><div class="diff-added">+</div><div class="diff-added">+                .map(|request| request.limit + request.offset)</div><div class="diff-added">+</div><div class="diff-added">+                .collect(),</div><div class="diff-added">+</div><div class="diff-added">+            &further_results,</div><div class="diff-added">+</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        if !searches_to_rerun.is_empty() {</div><div class="diff-added">+</div><div class="diff-added">+            // TODO notify telemetry of failing sampling</div><div class="diff-added">+</div><div class="diff-added">+            let searches_to_rerun: Vec<(SegmentOffset, Vec<BatchOffset>)> = searches_to_rerun.into_iter().collect();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let secondary_searches: Vec<_> = {</div><div class="diff-added">+</div><div class="diff-added">+                let mut res = vec![];</div><div class="diff-added">+</div><div class="diff-added">+                for (segment_id, batch_ids) in searches_to_rerun.iter() {</div><div class="diff-added">+</div><div class="diff-added">+                    let query_context_arc_segment = query_context_arc.clone();</div><div class="diff-added">+</div><div class="diff-added">+                    let hw_collector = hw_measurement_acc.new_collector();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                    let segment = locked_segments[*segment_id].clone();</div><div class="diff-added">+</div><div class="diff-added">+                    let partial_batch_request = Arc::new(CoreSearchRequestBatch {</div><div class="diff-added">+</div><div class="diff-added">+                        searches: batch_ids</div><div class="diff-added">+</div><div class="diff-added">+                            .iter()</div><div class="diff-added">+</div><div class="diff-added">+                            .map(|batch_id| batch_request.searches[*batch_id].clone())</div><div class="diff-added">+</div><div class="diff-added">+ .collect(),</div><div class="diff-added">+</div><div class="diff-added">+                    });</div><div class="diff-added">+</div><div class="diff-added">+                     res.push(runtime_handle.spawn_blocking(move || {</div><div class="diff-added">+</div><div class="diff-added">+                        let segment_query_context = query_context_arc_segment.get_segment_query_context();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        let result = search_in_segment(</div><div class="diff-added">+</div><div class="diff-added">+                            segment,</div><div class="diff-added">+</div><div class="diff-added">+                            partial_batch_request,</div><div class="diff-added">+</div><div class="diff-added">+                            false,</div><div class="diff-added">+</div><div class="diff-added">+                            &segment_query_context,</div><div class="diff-added">+</div><div class="diff-added">+                        );</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        hw_collector.merge_from_cell(segment_query;', segment_query_context.take_hardware_counter());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                        result</div><div class="diff-added">+</div><div class="diff-added">+                    }))</div><div class="diff-added">+</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+                res</div><div class="diff-added">+</div><div class="diff-added">+            };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let (secondary_search_results_per_segment, _) = Self::execute_searches(secondary_searches).await?;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            result_aggregator.update_point_versions(</div><div class="diff-added">+</div><div class="diff-added">+                secondary_search_results_per_segment.iter().flatten().flatten(),</div><div class="diff-added">+</div><div class="diff-added">+            );</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            for ((_segment_id, batch_ids), segments_result) in searches_to_rerun.into_iter().zip(secondary_search_results_per_segment.into_iter()) {</div><div class="diff-added">+</div><div class="diff-added">+                for (batch_id, secondary_batch_result) in batch_ids.into_iter().zip(segments_result.into_iter()) {</div><div class="diff-added">+</div><div class="diff-added">+                    result_aggregator.update_batch_results(batch_id, secondary_batch_result.into_iter());</div><div class="diff-added">+</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let top_scores: Vec<_> = result_aggregator.into_topk();</div><div class="diff-added">+</div><div class="diff-added">+        Ok(top_scores)</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    /// Rescore results with a formula that can reference payload values.</div><div class="diff-added">+</div><div class="diff-added">+    ///</div><div class="diff-added">+</div><div class="diff-added">+    /// Aggregates rescores from the segments.</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn rescore_with_formula(</div><div class="diff-added">+</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+</div><div class="diff-added">+        arc_ctx: Arc<FormulaContext>,</div><div class="diff-added">+</div><div class="diff-added">+        runtime_handle: &Handle,</div><div class="diff-added">+</div><div class="diff-added">+        hw_measurement_acc: HwMeasurementAcc,</div><div class="diff-added">+</div><div class="diff-added">+    ) ->.CollectionResult<Vec<ScoredPoint>> {</div><div class="diff-added">+</div><div class="diff-added">+        let limit = arc_ctx.limit;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let futures = {</div><div class="diff-added">+</div><div class="diff-added">+            let segments_guard = segments.read();</div><div class="diff-added">+</div><div class="diff-added">+            segments_guard</div><div class="diff-added">+</div><div class="diff-added">+                .non_appendable_then_appendable_segments()</div><div class="diff-added">+</div><div class="diff-added">+                .map(|segment| {</div><div class="diff-added">+</div><div class="diff-added">+                    runtime_handle.spawn_blocking({</div><div class="diff-added">+</div><div class="diff-added">+                        let segment = segment. clone();</div><div class="diff-added">+</div><div class="diff-added">+                        let arc_ctx = arc_ctx.clone();</div><div class="diff-added">+</div><div class="diff-added">+                        let hw_counter = hw_measurement_acc.get_counter_cell();</div><div class="diff-added">+</div><div class="diff-added">+                        move || segment.get().read().rescore_with_formula(arc_ctx, &hw_counter)</div><div class="diff-added">+</div><div class="diff-added">+                    })</div><div class="diff-added">+</div><div class="diff-added">+                })</div><div class="diff-added">+</div><div class="diff-added">+                .collect::<FuturesUnordered<_>>()</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut segments_results = Vec::with_capacity(futures.len());</div><div class="diff-added">+</div><div class="diff-added">+        while let Some(result) = futures.try_next().await? {</div><div class="diff-added">+</div><div class="diff-added">+            segments_results.push(result?)</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut aggregator = BatchResultAggregator::new(std::iter::once(limit));</div><div class="diff-added">+</div><div class="diff-added">+        aggregator.update_point_versions(segments_results.iter().flatten());</div><div class="diff-added">+</div><div class="diff-added">+        aggregator.update_batch_results(0, segments_results.into_iter().flatten());</div><div class="diff-added">+</div><div class="diff-added">+        let top = aggregator.into_topk().into_iter().next().ok_or_else(|| {</div><div class="diff-added">+</div><div class="diff-added">+            OperationError::service_error("expected first result of aggregator")</div><div class="diff-added">+</div><div class="diff-added">+        })?;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        Ok(top)</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+#[derive(PartialEq, Default, Debug)]</div><div class="diff-added">+</div><div class="diff-added">+struct BatchSearchParams<'a> {</div><div class="diff-added">+</div><div class="diff-added">+    pub search_type: SearchType,</div><div class="diff-added">+</div><div class="diff-added">+    pub vector_name: &'a VectorName,</div><div class="diff-added">+</div><div class="diff-added">+    pub filter: Option<&'a Filter>,</div><div class="diff-added">+</div><div class="diff-added">+    pub with_payload: WithPayload,</div><div class="diff-added">+</div><div class="diff-added">+    pub with_vector: WithVector,</div><div class="diff-added">+</div><div class="diff-added">+    pub top: usize,</div><div class="diff-added">+</div><div class="diff-added">+    pub params: Option<&'a SearchParams>,</div><div class="diff-added">+</div><div class="diff-added">+ }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+fn effective_limit(limit: usize, ef_limit: usize, poisson_sampling: usize) -> usize {</div><div class="diff-added">+</div><div class="diff-added">+    poisson_sampling.max(ef_limit).min(limit)</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+fn sampling_limit(</div><div class="diff-added">+</div><div class="diff-added">+    limit: usize,</div><div class="diff-added">+</div><div class="diff-added">+    ef_limit: Option<usize>,</div><div class="diff-added">+</div><div class="diff-added">+    segment_points: usize,</div><div class="diff-added">+</div><div class="diff-added">+    total_points: usize,</div><div class="diff-added">+</div><div class="diff-added">+) -> usize {</div><div class="diff-added">+</div><div class="diff-added">+    if segment_points == 0 {</div><div class="diff-added">+</div><div class="diff-added">+        return 0;</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    let segment_probability = segment_points as f64 / total_points as f64;</div><div class="diff-added">+</div><div class="diff-added">+    let poisson_sampling = find_search_sampling_over_point_distribution(limit as f64, segment_probability);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let effective = ef_limit.map_or(limit, |ef_limit| effective_limit(limit, ef_limit, poisson_sampling));</div><div class="diff-added">+</div><div class="diff-added">+    log::trace!(</div><div class="diff-added">+</div><div class="diff-added">+        "sampling: {effective}, poisson: {poisson_sampling} segment_probability: {segment_probability}, segment_points: {segment_points}, total_points: {total_points}",</div><div class="diff-added">+</div><div class="diff-added">+    );</div><div class="diff-added">+</div><div class="diff-added">+    effective</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+fn search_in_segment(</div><div class="diff-added">+</div><div class="diff-added">+    segment: LockedSegment,</div><div class="diff-added">+</div><div class="diff-added">+    request: Arc<CoreSearchRequestBatch>,</div><div class="diff-added">+</div><div class="diff-added">+    use_sampling: bool,</div><div class="diff-added">+</div><div class="diff-added">+    segment_query_context: &SegmentQueryContext,</div><div class="diff-added">+</div><div class="diff-added">+) -> CollectionResult<(Vec<Vec<ScoredPoint>> , Vec<bool>)> {</div><div class="diff-added">+</div><div class="diff-added">+    let batch_size = request.searches.len();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let mut result: Vec<Vec<ScoredPoint>> = Vec::with_capacity(batch_size);</div><div class="diff-added">+</div><div class="diff-added">+    let mut further_results: Vec<bool> = Vec::with_capacity(batch_size); // if segment have more points to return</div><div class="diff-added">+</div><div class="diff-added">+    let mut vectors_batch: Vec<QueryVector> = vec![];</div><div class="diff-added">+</div><div class="diff-added">+    let mut prev_params = BatchSearchParams::default();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    for search_query in &request.searches {</div><div class="diff-added">+</div><div class="diff-added">+        let with_payload_interface = search_query</div><div class="diff-added">+</div><div class="diff-added">+            .with_payload</div><div class="diff-added">+</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap_or(&WithPayloadInterface::Bool(false));</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let params = BatchSearchParams {</div><div class="diff-added">+</div><div class="diff-added">+            search_type: search_query.query.as_ref().into(),</div><div class="diff-added">+</div><div class="diff-added">+            vector_name: search_query.query.get_vector_name(),</div><div class="diff-added">+</div><div class="diff-added">+            filter: search_query.filter.as_ref(),</div><div class="diff-added">+</div><div class="diff-added">+            with_payload: WithPayload::from(with_payload_interface),</div><div class="diff-added">+</div><div class="diff-added">+            with_vector: search_query.with_vector.clone().unwrap_or_default(),</div><div class="diff-added">+</div><div class="diff-added">+            top: search_query.limit + search_query.offset,</div><div class="diff-added">+</div><div class="diff-added">+            params: search_query.params.as_ref(),</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let query = search_query.query.clone().into();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        if params == prev_params {</div><div class="diff-added">+</div><div class="diff-added">+            vectors_batch.push(query);</div><div class="diff-added">+</div><div class="diff-added">+        } else {</div><div class="diff-added">+</div><div class="diff-added">+            if !vectors_batch.is_empty() {</div><div class="diff-added">+</div><div class="diff-added">+                let (mut res, mut further) = execute_batch_search(</div><div class="diff-added">+</div><div class="diff-added">+                    &segment,</div><div class="diff-added">+</div><div class="diff-added">+                    &vectors_batch,</div><div class="diff-added">+</div><div class="diff-added">+                    &prev_params,</div><div class="diff-added">+</div><div class="diff-added">+                    use_sampling,</div><div class="diff-added">+</div><div class="diff-added">+                    segment_query_context,</div><div class="diff-added">+</div><div class="diff-added">+                )?;</div><div class="diff-added">+</div><div class="diff-added">+                further_results.append(&mut further);</div><div class="diff-added">+</div><div class="diff-added">+                result.append(&mut res);</div><div class="diff-added">+</div><div class="diff-added">+                vectors_batch.clear()</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            vectors_batch.push(query);</div><div class="diff-added">+</div><div class="diff-added">+            prev_params = params;</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    if !vectors_batch.is_empty() {</div><div class="diff-added">+</div><div class="diff-added">+        let (mut res, mut further) = execute_batch_search(</div><div class="diff-added">+</div><div class="diff-added">+            &segment,</div><div class="diff-added">+</div><div class="diff-added">+            &vectors_batch,</div><div class="diff-added">+</div><div class="diff-added">+            &prev_params,</div><div class="diff-added">+</div><div class="diff-added">+            use_sampling,</div><div class="diff-added">+</div><div class="diff-added">+            segment_query_context,</div><div class="diff-added">+</div><div class="diff-added">+        )?;</div><div class="diff-added">+</div><div class="diff-added">+        further_results.append(&mut further);</div><div class="diff-added">+</div><div class="diff-added">+        result.append(&mut res);</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    Ok((result, further_results))</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+fn execute_batch_search(</div><div class="diff-added">+</div><div class="diff-added">+    segment: &LockedSegment,</div><div class="diff-added">+</div><div class="diff-added">+    vectors_batch: &[QueryVector],</div><div class="diff-added">+</div><div class="diff-added">+    search_params: &BatchSearchParams,</div><div class="diff-added">+</div><div class="diff-added">+    use_sampling: bool,</div><div class="diff-added">+</div><div class="diff-added">+    segment_query_context: &SegmentQueryContext-propag,</div><div class="diff-added">+</div><div class="diff-added">+) -> CollectionResult<(Vec<Vec<ScoredPoint>>, Vec<bool>)> {</div><div class="diff-added">+</div><div class="diff-added">+    let locked_segment = segment.get();</div><div class="diff-added">+</div><div class="diff-added">+    let read_segment = locked_segment.read();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let segment_points = read_segment.available_point_count();</div><div class="diff-added">+</div><div class="diff-added">+    let segment_config = read_segment.config();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let top = if use_sampling {</div><div class="diff-added">+</div><div class="diff-added">+        let ef_limit = search_params</div><div class="diff-added">+</div><div class="diff-added">+            .params</div><div class="diff-added">+</div><div class="diff-added">+            .and_then(|p| p.hnsw_ef)</div><div class="diff-added">+</div><div class="diff-added">+            .or_else(|| get_hnsw_ef_construct(segment_config, search_params.vector_name));</div><div class="diff-added">+</div><div class="diff-added">+        sampling_limit(</div><div class="diff-added">+</div><div class="diff-added">+            search_params.top,</div><div class="diff-added">+</div><div class="diff-added">+            ef_limit,</div><div class="diff-added">+</div><div class="diff-added">+            segment_points,</div><div class="diff-added">+</div><div class="diff-added">+            segment_query_context .available_point_count(),</div><div class="diff-added">+</div><div class="diff-added">+        )</div><div class="diff-added">+</div><div class="diff-added">+    } else {</div><div class="diff-added">+</div><div class="diff-added">+        search_params.top</div><div class="diff-added">+</div><div class="diff-added">+    };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let vectors_batch = &vectors_batch.iter() .collect_vec();</div><div class="diff-added">+</div><div class="diff-added">+    let res = read_segment.search_batch(</div><div class="diff-added">+</div><div class="diff-added">+        search_params.vector_name,</div><div class="diff-added">+</div><div class="diff-added">+        vectors_batch,</div><div class="diff-added">+</div><div class="diff-added">+        &search_params.with_payload,</div><div class="diff-added">+</div><div class="diff-added">+        &search_params.with_vector,</div><div class="diff-added">+</div><div class="diff-added">+        search_params.filter,</div><div class="diff-added">+</div><div class="diff-added">+        top,</div><div class="diff-added">+</div><div class="diff-added">+        search_params.params,</div><div class="diff-added">+</div><div class="diff-added">+        segment_query_context,</div><div class="diff-added">+</div><div class="diff-added">+    )?;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    let further_results = res.iter().map(|batch_result| batch_result.len() == top).collect();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    Ok((res, further_results))</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Option<usize> {</div><div class="diff-added">+</div><div class="diff-added">+    match config.index {</div><div class="diff-added">+</div><div class="diff-added">+        Indexes::Plain {} => None,</div><div class="diff-added">+</div><div class="diff-added">+        Indexes::Hnsw(hnsw_config) => Some(</div><div class="diff-added">+</div><div class="diff-added">+            config</div><div class="diff-added">+</div><div class="diff-added">+                .vector_data</div><div class="diff-added">+</div><div class="diff-added">+                .get(vector_name)</div><div class="diff-added">+</div><div class="diff-added">+                .and_then(|c| c.hnsw_config.as_ref())</div><div class="diff-added">+</div><div class="diff-added">+                .map |c| c.ef_construct</div><div class="diff-added">+</div><div class="diff-added">+                .unwrap_or(hnsw_config.ef_construct),</div><div class="diff-added">+</div><div class="diff-added">+        ),</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+#[cfg(test)]</div><div class="diff-added">+</div><div class="diff-added">+mod tests {</div><div class="diff-added">+</div><div class="diff-added">+    use ahash::AHashSet;</div><div class="diff-added">+</div><div class="diff-added">+    use api::rest::SearchRequestInternal;</div><div class="diff-added">+</div><div class="diff-added">+    use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-added">+</div><div class="diff-added">+    use parking_lot::RwLock;</div><div class="diff-added">+</div><div class="diff-added">+    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;</div><div class="diff-added">+</div><div class="diff-added">+    use segment::fixtures::index_fixtures::random_vector;</div><div class="diff-added">+</div><div class="diff-added">+    use segment::index::VectorIndexEnum;</div><div class="diff-added">+</div><div class="diff-added">+    use segment::types::{Condition, HasIdCondition};</div><div class="diff-added">+</div><div class="diff-added">+    use tempfile::Builder;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    use super::*;</div><div class="diff-added">+</div><div class="diff-added">+    use crate::collection_manager::fixtures::{build_test_holder, random_segment};</div><div class="diff-added">+</div><div class="diff-added">+    use crate::operations::types::CoreSearchRequest;</div><div class="diff-added">+</div><div class="diff-added">+    use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_is_indexed_enough_condition() {</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let segment1 = random_segment(dir.path(), 10, 200, 256);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let vector_index = segment1</div><div class="diff-added">+</div><div class="diff-added">+            .vector_data</div><div class="diff-added">+</div><div class="diff-added">+            .get(DEFAULT_VECTOR_NAME)</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap()</div><div class="diff-added">+</div><div class="diff-added">+            .vector_index</div><div class="diff-added">+</div><div class="diff-added">+            .clone();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let vector_index_borrow = vector_index.borrow();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let hw_counter = HardwareCounterCell::new();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        match &*vector_index_borrow {</div><div class="diff-added">+</div><div class="diff-added">+            VectorIndexEnum::Plain(plain_index) => {</div><div class="diff-added">+</div><div class="diff-added">+                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);</div><div class="diff-added">+</div><div class="diff-added">+                assert!(!res_1);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                let res_2 = plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);</div><div class="diff-added">+</div><div class="diff-added">+                assert!(res_2);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+                let res_3 = plain_index.is_small_enough_for_unindexed_search(</div><div class="diff-added">+</div><div class="diff-added">+                    25,</div><div class="diff-added">+</div><div class="diff-added">+                    Some(&ids_filter),</div><div class="diff-added">+</div><div class="diff-added">+                    &hw_counter,</div><div class="diff-added">+</div><div class="diff-added">+                );</div><div class="diff-added">+</div><div class="diff-added">+                assert!(res_3);</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+            _ => panic!("Expected plain index"),</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[tokio::test]</div><div class="diff-added">+</div><div class="diff-added">+    async fn test_segments_search() {</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let segment_holder = build_test_holder(dir.path());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let query = vec![1.0, 1.0, 1.0, 1.0];</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let req = SearchRequestInternal {</div><div class="diff-added">+</div><div class="diff-added">+            vector: query.into(),</div><div class="diff-added">+</div><div class="diff-added">+            with_payload: None,</div><div class="diff-added">+</div><div class="diff-added">+            with_vector: None,</div><div class="diff-added">+</div><div class="diff-added">+            filter: None,</div><div class="diff-added">+</div><div class="diff-added">+            params: None,</div><div class="diff-added">+</div><div class="diff-added">+            limit: 5,</div><div class="diff-added">+</div><div class="diff-added">+            offset: None,</div><div class="diff-added">+</div><div class="diff-added">+            score_threshold: None,</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let batch_request = CoreSearchRequestBatch {</div><div class="diff-added">+</div><div class="diff-added">+            searches: vec![req],</div><div class="diff-added">+</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let result = SegmentsSearcher::search(</div><div class="diff-added">+</div><div class="diff-added">+            Arc::new(segment_holder),</div><div class="diff-added">+</div><div class="diff-added">+            Arc::new(batch_request),</div><div class="diff-added">+</div><div class="diff-added">+            &Handle::current(),</div><div class="diff-added">+</div><div class="diff-added">+            true,</div><div class="diff-added">+</div><div class="diff-added">+            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, HwMeasurementAcc::new()),</div><div class="diff-added">+</div><div class="diff-added">+            &HwMeasurementAcc::new(),</div><div class="diff-added">+</div><div class="diff-added">+        )</div><div class="diff-added">+</div><div class="diff-added">+            .await</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap()</div><div class="diff-added">+</div><div class="diff-added">+            .into_iter()</div><div class="diff-added">+</div><div class="diff-added">+            .next()</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(result.len(),  5);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        assert!(result[0].id == 3.into() || result[0].id == 11.into());</div><div class="diff-added">+</div><div class="diff-added">+        assert!(result[1].id == 3.into() || result[1].id == 11.into());</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[tokio::test]</div><div class="diff-added">+</div><div class="diff-added">+    async fn test_segments_search_sampling() {</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let segment1 = random_segment(dir.path(), 10, 2000, 4);</div><div class="diff-added">+</div><div class="diff-added">+        let segment2 = random_segment(dir.path(), 10, 4000, 4);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut holder = SegmentHolder::default();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let _sid1 = holder.add_new(segment1);</div><div class="diff-added">+</div><div class="diff-added">+        let _sid2 = holder.add_new(segment2);</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let segment_holder = Arc::new(RwLock::new(holder));</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let mut rnd = rand::rng();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        for _ in 0..100 {</div><div class="diff-added">+</div><div class="diff-added">+            let req1 = SearchRequestInternal {</div><div class="diff-added">+</div><div class="diff-added">+                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-added">+</div><div class="diff-added">+                limit: 150,</div><div class="diff-added">+</div><div class="diff-added">+                offset: None,</div><div class="diff-added">+</div><div class="diff-added">+                with_payload: None,</div><div class="diff-added">+</div><div class="diff-added">+                with_vector: None,</div><div class="diff-added">+</div><div class="diff-added">+                filter: None,</div><div class="diff-added">+</div><div class="diff-added">+                params: None,</div><div class="diff-added">+</div><div class="diff-added">+                score_threshold: None,</div><div class="diff-added">+</div><div class="diff-added">+            };</div><div class="diff-added">+</div><div class="diff-added">+            let req2 = SearchRequestInternal {</div><div class="diff-added">+</div><div class="diff-added">+                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-added">+</div><div class="diff-added">+                limit: 50,</div><div class="diff-added">+</div><div class="diff-added">+                offset: None,</div><div class="diff-added">+</div><div class="diff-added">+                filter: None,</div><div class="diff-added">+</div><div class="diff-added">+                params: None,</div><div class="diff-added">+</div><div class="diff-added">+                with_payload: None,</div><div class="diff-added">+</div><div class="diff-added">+                with_vector: None,</div><div class="diff-added">+</div><div class="diff-added">+                score_threshold: None,</div><div class="diff-added">+</div><div class="diff-added">+            };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let batch_request = CoreSearchRequestBatch {</div><div class="diff-added">+</div><div class="diff-added">+                searches: vec![req1, req2],</div><div class="diff-added">+</div><div class="diff-added">+            };</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-added">+</div><div class="diff-added">+            let query_context = QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let result_no_sampling = SegmentsSearcher::search(</div><div class="diff-added">+</div><div class="diff-added">+                segment_holder.clone(),</div><div class="diff-added">+</div><div class="diff-added">+                Arc::new(batch_request.clone()),</div><div class="diff-added">+</div><div class="diff-added">+                &Handle::current(),</div><div class="diff-added">+</div><div class="diff-added">+                false,</div><div class="diff-added">+</div><div class="diff-added">+                query_context,</div><div class="diff-added">+</div><div class="diff-added">+                &hw_measurement_acc,</div><div class="diff-added">+</div><div class="diff-added">+            )</div><div class="diff-added">+</div><div class="diff-added">+            .await</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-added">+</div><div class="diff-added">+            hw_measurement_acc.discard();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-added">+</div><div class="diff-added">+            let query_context = QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            assert!(!result_no_sampling.is_empty());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            let result_sampling = SegmentsSearcher::search(</div><div class="diff-added">+</div><div class="diff-added">+                segment_holder.clone(),</div><div class="diff-added">+</div><div class="diff-added">+                Arc::new(batch_request),</div><div class="diff-added">+</div><div class="diff-added">+                &Handle::current(),</div><div class="diff-added">+</div><div class="diff-added">+                true,</div><div class="diff-added">+</div><div class="diff-added">+                query_context,</div><div class="diff-added">+</div><div class="diff-added">+                &hw_measurement_acc,</div><div class="diff-added">+</div><div class="diff-added">+            )</div><div class="diff-added">+</div><div class="diff-added">+            .await</div><div class="diff-added">+</div><div class="diff-added">+            .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+            assert!(!result_sampling.is_empty());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-added">+</div><div class="diff-added">+            hw_measurement_acc.discard();</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            // assert equivalence in depth</div><div class="diff-added">+</div><div class="diff-added">+            assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());</div><div class="diff-added">+</div><div class="diff-added">+            assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+            for (no_sampling, sampling) in result_no_sampling[0].iter().zip(result_sampling[0].iter()) {</div><div class="diff-added">+</div><div class="diff-added">+                assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores</div><div class="diff-added">+</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_retrieve() {</div><div class="diff-added">+</div><div class="diff-added">+        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-added">+</div><div class="diff-added">+        let segment_holder = build_test_holder(dir.path());</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+        let records = SegmentsSearcher::retrieve_blocking(</div><div class="diff-added">+</div><div class="diff-added">+            Arc::new(segment_holder),</div><div class="diff-added">+</div><div class="diff-added">+            &[1.into(), 2.into(), 3.into()],</div><div class="diff-added">+</div><div class="diff-added">+            &WithPayload::from(true),</div><div class="diff-added">+</div><div class="diff-added">+            &true.into(),</div><div class="diff-added">+</div><div class="diff-added">+            &AtomicBool::new(false),</div><div class="diff-added">+</div><div class="diff-added">+            HwMeasurementAcc::new(),</div><div class="diff-added">+</div><div class="diff-added">+        )</div><div class="diff-added">+</div><div class="diff-added">+        .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(records.len(), 3);</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_sampling_limit() {</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_sampling_limit_ef() {</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_sampling_limit_high() {</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+ </div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+</div><div class="diff-added">+    fn test_effective_limit() {</div><div class="diff-added">+</div><div class="diff-added">+        let tests = [</div><div class="diff-added">+</div><div class="diff-added">+            (1000, 128, 150, 150),</div><div class="diff-added">+</div><div class="diff-added">+            (1000, 128, 110, 128),</div><div class="diff-added">+</div><div class="diff-added">+            (130, 128, 150, 130),</div><div class="diff-added">+</div><div class="diff-added">+            (130, 128, 110, 128),</div><div class="diff-added">+</div><div class="diff-added">+            (50, 128, 150, 50),</div><div class="diff-added">+</div><div class="diff-added">+            (50, 128, 110, 50),</div><div class="diff-added">+</div><div class="diff-added">+            (500, 1000, 300, 500),</div><div class="diff-added">+</div><div class="diff-added">+            (500, 400, 300, 400),</div><div class="diff-added">+</div><div class="diff-added">+            (1000, 0, 150, 150),</div><div class="diff-added">+</div><div class="diff-added">+            (1000, 0, 110, 110),</div><div class="diff-added">+</div><div class="diff-added">+        ];</div><div class="diff-added">+</div><div class="diff-added">+        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective| {</div><div class="diff-added">+</div><div class="diff-added">+            assert_eq!(</div><div class="diff-added">+</div><div class="diff-added">+                effective_limit(limit, ef_limit, poisson_sampling),</div><div class="diff-added">+</div><div class="diff-added">+                effective,</div><div class="diff-added">+</div><div class="diff-added">+                "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",</div><div class="diff-added">+</div><div class="diff-added">+ dreamer            )</div><div class="diff-added">+</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    