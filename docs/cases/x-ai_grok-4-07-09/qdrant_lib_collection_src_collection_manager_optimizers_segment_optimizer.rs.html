<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/segment_optimizer.rs - Grok 4</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/segment_optimizer.rs</h1>
        <h2>Model: Grok 4</h2>
        <p><a href="../../models/x-ai_grok-4-07-09.html">All Grok 4 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 4</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56534</p>
                <p><strong>Native Prompt Tokens:</strong> 55197</p>
                <p><strong>Native Completion Tokens:</strong> 16099</p>
                <p><strong>Native Tokens Reasoning:</strong> 11677</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.40660125</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index a458d5593..0c79c1e1f 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_expectedoutput.txt (expected):tmp/tmp24yblyoy_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_segment_optimizer.rs_extracted.txt (actual):tmp/tmpx7ijnb7l_actual.txt	</div><div class="diff-info">@@ -6,6 +6,7 @@ use std::sync::atomic::{AtomicBool, Ordering};</div><div> </div><div> use common::budget::{ResourceBudget, ResourcePermit};</div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-added">+use common::cpu::CpuPermit;</div><div> use common::disk::dir_size;</div><div> use io::storage_version::StorageVersion;</div><div> use itertools::Itertools;</div><div class="diff-info">@@ -26,7 +27,6 @@ use crate::collection_manager::holders::segment_holder::{</div><div>     LockedSegment, LockedSegmentHolder, SegmentId,</div><div> };</div><div> use crate::config::CollectionParams;</div><div class="diff-removed">-use crate::operations::config_diff::DiffConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult};</div><div> </div><div> const BYTES_IN_KB: usize = 1024;</div><div class="diff-info">@@ -130,7 +130,8 @@ pub trait SegmentOptimizer {</div><div>             let locked_segment = segment.read();</div><div> </div><div>             for vector_name in locked_segment.vector_names() {</div><div class="diff-removed">-                let vector_size = locked_segment.available_vectors_size_in_bytes(&vector_name)?;</div><div class="diff-added">+                let vector_size =</div><div class="diff-added">+                    locked_segment.available_vectors_size_in_bytes(&vector_name)?;</div><div>                 let size = bytes_count_by_vector_name.entry(vector_name).or_insert(0);</div><div>                 *size += vector_size;</div><div>             }</div><div class="diff-info">@@ -186,12 +187,11 @@ pub trait SegmentOptimizer {</div><div>             _ => {</div><div>                 log::warn!(</div><div>                     "Could not estimate available storage space in `{}`; will try optimizing anyway",</div><div class="diff-removed">-                    self.name()</div><div class="diff-added">+                    self.temp_path().display()</div><div>                 );</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Example: maximal_vector_store_size_bytes = 10200 * dim * VECTOR_ELEMENT_SIZE</div><div>         let maximal_vector_store_size_bytes = bytes_count_by_vector_name</div><div>             .values()</div><div>             .max()</div><div class="diff-info">@@ -262,30 +262,27 @@ pub trait SegmentOptimizer {</div><div>             });</div><div>         }</div><div> </div><div class="diff-removed">-        sparse_vector_data</div><div class="diff-removed">-            .iter_mut()</div><div class="diff-removed">-            .for_each(|(vector_name, config)| {</div><div class="diff-removed">-                // Assign sparse index on disk</div><div class="diff-removed">-                if let Some(sparse_config) = &collection_params.sparse_vectors {</div><div class="diff-removed">-                    if let Some(params) = sparse_config.get(vector_name) {</div><div class="diff-removed">-                        let config_on_disk = params</div><div class="diff-removed">-                            .index</div><div class="diff-removed">-                            .and_then(|index_params| index_params.on_disk)</div><div class="diff-removed">-                            .unwrap_or(threshold_is_on_disk);</div><div class="diff-removed">-</div><div class="diff-removed">-                        // If mmap OR index is exceeded</div><div class="diff-removed">-                        let is_big = threshold_is_on_disk || threshold_is_indexed;</div><div class="diff-removed">-</div><div class="diff-removed">-                        let index_type = match (is_big, config_on_disk) {</div><div class="diff-removed">-                            (true, true) => SparseIndexType::Mmap, // Big and configured on disk</div><div class="diff-removed">-                            (true, false) => SparseIndexType::ImmutableRam, // Big and not on disk nor reached threshold</div><div class="diff-removed">-                            (false, _) => SparseIndexType::MutableRam,      // Small</div><div class="diff-removed">-                        };</div><div class="diff-removed">-</div><div class="diff-removed">-                        config.index.index_type = index_type;</div><div class="diff-removed">-                    }</div><div class="diff-added">+        sparse_vector_data.iter_mut().for_each(|(vector_name, config)| {</div><div class="diff-added">+            // Assign sparse index on disk</div><div class="diff-added">+            if let Some(sparse_config) = &collection_params.sparse_vectors {</div><div class="diff-added">+                if let Some(params) = sparse_config.get(vector_name) {</div><div class="diff-added">+                    let config_on_disk = params</div><div class="diff-added">+                        .index</div><div class="diff-added">+                        .and_then(|index_params| index_params.on_disk)</div><div class="diff-added">+                        .unwrap_or(threshold_is_on_disk);</div><div class="diff-added">+</div><div class="diff-added">+                    let is_big = threshold_is_on_disk || threshold_is_indexed;</div><div class="diff-added">+</div><div class="diff-added">+                    let index_type = match (is_big, config_on_disk) {</div><div class="diff-added">+                        (true, true) => SparseIndexType::Mmap, // Big and configured on disk</div><div class="diff-added">+                        (true, false) => SparseIndexType::ImmutableRam, // Big and not on disk nor reached threshold</div><div class="diff-added">+                        (false, _) => SparseIndexType::MutableRam,      // Small</div><div class="diff-added">+                    };</div><div class="diff-added">+</div><div class="diff-added">+                    config.index.index_type = index_type;</div><div>                 }</div><div class="diff-removed">-            });</div><div class="diff-added">+            }</div><div class="diff-added">+        });</div><div> </div><div>         let optimized_config = SegmentConfig {</div><div>             vector_data,</div><div class="diff-info">@@ -305,7 +302,7 @@ pub trait SegmentOptimizer {</div><div>     /// # Arguments</div><div>     ///</div><div>     /// * `segments` - segment holder</div><div class="diff-removed">-    /// * `proxy_ids` - ids of poxy-wrapped segment to restore</div><div class="diff-added">+    /// * `proxy_ids` - ids of proxy-wrapped segment to restore</div><div>     ///</div><div>     /// # Result</div><div>     ///</div><div class="diff-info">@@ -502,281 +499,95 @@ pub trait SegmentOptimizer {</div><div>                 description: "optimization cancelled while waiting for budget".to_string(),</div><div>             })?;</div><div> </div><div class="diff-removed">-        let mut optimized_segment: Segment =</div><div class="diff-removed">-            segment_builder.build(indexing_permit, stopped, hw_counter)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Delete points</div><div class="diff-removed">-        let deleted_points_snapshot = proxy_deleted_points</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(point_id, versions)| (*point_id, *versions))</div><div class="diff-removed">-            .collect::<Vec<_>>();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Apply index changes before point deletions</div><div class="diff-removed">-        // Point deletions bump the segment version, can cause index changes to be ignored</div><div class="diff-removed">-        let old_optimized_segment_version = optimized_segment.version();</div><div class="diff-removed">-        for (field_name, change) in proxy_changed_indexes.read().iter_ordered() {</div><div class="diff-removed">-            debug_assert!(</div><div class="diff-removed">-                change.version() >= old_optimized_segment_version,</div><div class="diff-removed">-                "proxied index change should have newer version than segment",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            match change {</div><div class="diff-removed">-                ProxyIndexChange::Create(schema, version) => {</div><div class="diff-removed">-                    optimized_segment.create_field_index(</div><div class="diff-removed">-                        *version,</div><div class="diff-removed">-                        field_name,</div><div class="diff-removed">-                        Some(schema),</div><div class="diff-removed">-                        hw_counter,</div><div class="diff-removed">-                    )?;</div><div class="diff-removed">-                }</div><div class="diff-removed">-                ProxyIndexChange::Delete(version) => {</div><div class="diff-removed">-                    optimized_segment.delete_field_index(*version, field_name)?;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-            self.check_cancellation(stopped)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        for (point_id, versions) in deleted_points_snapshot {</div><div class="diff-removed">-            optimized_segment</div><div class="diff-removed">-                .delete_point(versions.operation_version, point_id, hw_counter)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(optimized_segment)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Performs optimization of collections's segments, including:</div><div class="diff-removed">-    ///     - Segment rebuilding</div><div class="diff-removed">-    ///     - Segment joining</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Arguments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// * `segments` - segments holder</div><div class="diff-removed">-    /// * `ids` - list of segment ids to perform optimization on. All segments will be merged into single one</div><div class="diff-removed">-    /// * `stopped` - flag for early stopping of the optimization. If appears to be `true` - optimization process should be cancelled, all segments unwrapped.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Result</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// New optimized segment should be added into `segments`.</div><div class="diff-removed">-    /// If there were any record changes during the optimization - an additional plain segment will be created.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns id of the created optimized segment. If no optimization was done - returns None</div><div class="diff-removed">-    fn optimize(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        ids: Vec<SegmentId>,</div><div class="diff-removed">-        permit: ResourcePermit,</div><div class="diff-removed">-        resource_budget: ResourceBudget,</div><div class="diff-removed">-        stopped: &AtomicBool,</div><div class="diff-removed">-    ) -> CollectionResult<usize> {</div><div class="diff-removed">-        check_process_stopped(stopped)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut timer = ScopeDurationMeasurer::new(self.get_telemetry_counter());</div><div class="diff-removed">-        timer.set_success(false);</div><div class="diff-removed">-</div><div class="diff-removed">-        // On the one hand - we want to check consistently if all provided segments are</div><div class="diff-removed">-        // available for optimization (not already under one) and we want to do it before creating a temp segment</div><div class="diff-removed">-        // which is an expensive operation. So we can't not unlock `segments` after the check and before the insert.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // On the other hand - we do not want to hold write lock during the segment creation.</div><div class="diff-removed">-        // Solution in the middle - is a upgradable lock. It ensures consistency after the check and allows to perform read operation.</div><div class="diff-removed">-        let segments_lock = segments.upgradable_read();</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizing_segments: Vec<_> = ids</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .cloned()</div><div class="diff-removed">-            .map(|id| segments_lock.get(id))</div><div class="diff-removed">-            .filter_map(|x| x.cloned())</div><div class="diff-removed">-            .collect();</div><div class="diff-added">+        let mut optimized_segment: Segment = segment_builder.build(indexing_permit, stopped, hw_counter)?;</div><div> </div><div class="diff-removed">-        // Check if all segments are not under other optimization or some ids are missing</div><div class="diff-removed">-        let all_segments_ok = optimizing_segments.len() == ids.len()</div><div class="diff-removed">-            && optimizing_segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .all(|s| matches!(s, LockedSegment::Original(_)));</div><div class="diff-removed">-</div><div class="diff-removed">-        if !all_segments_ok {</div><div class="diff-removed">-            // Cancel the optimization</div><div class="diff-removed">-            return Ok(0);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        check_process_stopped(stopped)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::disposable(); // Internal operation, no measurement needed!</div><div class="diff-removed">-</div><div class="diff-removed">-        let tmp_segment = self.temp_segment(false)?;</div><div class="diff-removed">-        let proxy_deleted_points = proxy_segment::LockedRmSet::default();</div><div class="diff-removed">-        let proxy_index_changes = proxy_segment::LockedIndexChanges::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut proxies = Vec::new();</div><div class="diff-removed">-        for sg in optimizing_segments.iter() {</div><div class="diff-removed">-            let mut proxy = ProxySegment::new(</div><div class="diff-removed">-                sg.clone(),</div><div class="diff-removed">-                tmp_segment.clone(),</div><div class="diff-removed">-                Arc::clone(&proxy_deleted_points),</div><div class="diff-removed">-                Arc::clone(&proxy_index_changes),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            // Wrapped segment is fresh, so it has no operations</div><div class="diff-removed">-            // Operation with number 0 will be applied</div><div class="diff-removed">-            proxy.replicate_field_indexes(0, &hw_counter)?;</div><div class="diff-removed">-            proxies.push(proxy);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Save segment version once all payload indices have been converted</div><div class="diff-removed">-        // If this ends up not being saved due to a crash, the segment will not be used</div><div class="diff-removed">-        match &tmp_segment {</div><div class="diff-removed">-            LockedSegment::Original(segment) => {</div><div class="diff-removed">-                let segment_path = &segment.read().current_path;</div><div class="diff-removed">-                SegmentVersion::save(segment_path)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-            LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let proxy_ids: Vec<_> = {</div><div class="diff-removed">-            // Exclusive lock for the segments operations.</div><div class="diff-removed">-            let mut write_segments = RwLockUpgradableReadGuard::upgrade(segments_lock);</div><div class="diff-removed">-            let mut proxy_ids = Vec::new();</div><div class="diff-removed">-            for (mut proxy, idx) in proxies.into_iter().zip(ids.iter().cloned()) {</div><div class="diff-removed">-                // replicate_field_indexes for the second time,</div><div class="diff-removed">-                // because optimized segments could have been changed.</div><div class="diff-removed">-                // The probability is small, though,</div><div class="diff-removed">-                // so we can afford this operation under the full collection write lock</div><div class="diff-removed">-                proxy.replicate_field_indexes(0, &hw_counter)?; // Slow only in case the index is change in the gap between two calls</div><div class="diff-removed">-                proxy_ids.push(write_segments.swap_new(proxy, &[idx]).0);</div><div class="diff-removed">-            }</div><div class="diff-removed">-            proxy_ids</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(e) = check_process_stopped(stopped) {</div><div class="diff-removed">-            self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-            return Err(CollectionError::from(e));</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // ---- SLOW PART -----</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut optimized_segment = match self.build_new_segment(</div><div class="diff-removed">-            &optimizing_segments,</div><div class="diff-removed">-            Arc::clone(&proxy_deleted_points),</div><div class="diff-removed">-            Arc::clone(&proxy_index_changes),</div><div class="diff-removed">-            permit,</div><div class="diff-removed">-            resource_budget,</div><div class="diff-removed">-            stopped,</div><div class="diff-removed">-            &hw_counter,</div><div class="diff-removed">-        ) {</div><div class="diff-removed">-            Ok(segment) => segment,</div><div class="diff-removed">-            Err(error) => {</div><div class="diff-removed">-                if matches!(error, CollectionError::Cancelled { .. }) {</div><div class="diff-removed">-                    self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-                    return Err(error);</div><div class="diff-removed">-                }</div><div class="diff-removed">-                return Err(error);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        };</div><div class="diff-added">+        let deleted_points.snapshot = proxy_deleted_points.read().iter().map(|(point_id, versions)| (*point_id, *versions)).collect::<Vec<_>> ();</div><div> </div><div>         // Avoid unnecessary point removing in the critical section:</div><div>         // - save already removed points while avoiding long read locks</div><div>         // - exclude already removed points from post-optimization removing</div><div>         let already_remove_points = {</div><div class="diff-removed">-            let mut all_removed_points: HashSet<_> =</div><div class="diff-removed">-                proxy_deleted_points.read().keys().copied().collect();</div><div class="diff-added">+</div><div class="diff-added">+let mut all_removed_points: HashSet<_> = proxy_deleted_points.read() .keys().copied().collect();</div><div class="diff-added">+</div><div>             for existing_point in optimized_segment.iter_points() {</div><div class="diff-added">+</div><div>                 all_removed_points.remove(&existing_point);</div><div class="diff-added">+</div><div>             }</div><div class="diff-added">+</div><div>             all_removed_points</div><div class="diff-removed">-        };</div><div> </div><div class="diff-removed">-        // ---- SLOW PART ENDS HERE -----</div><div class="diff-added">+        };</div><div> </div><div class="diff-removed">-        if let Err(e) = check_process_stopped(stopped) {</div><div class="diff-removed">-            self.handle_cancellation(&segments, &proxy_ids, tmp_segment)?;</div><div class="diff-removed">-            return Err(CollectionError::from(e));</div><div class="diff-removed">-        }</div><div class="diff-added">+        check_process_stopped(stopped).inspect_err(|_| self.handle_cancellation(&segments, &proxy_ids, tmp_segment))?;</div><div> </div><div>         {</div><div class="diff-removed">-            // This block locks all operations with collection. It should be fast</div><div class="diff-removed">-            let mut write_segments_guard = segments.write();</div><div> </div><div class="diff-removed">-            // Apply index changes before point deletions</div><div class="diff-removed">-            // Point deletions bump the segment version, can cause index changes to be ignored</div><div class="diff-removed">-            for (field_name, change) in proxy_index_changes.read().iter_ordered() {</div><div class="diff-removed">-                // Warn: change version might be lower than the segment version,</div><div class="diff-removed">-                // because we might already applied the change earlier in optimization.</div><div class="diff-removed">-                // Applied optimizations are not removed from `proxy_index_changes`.</div><div class="diff-removed">-                match change {</div><div class="diff-removed">-                    ProxyIndexChange::Create(schema, version) => {</div><div class="diff-removed">-                        optimized_segment.create_field_index(</div><div class="diff-removed">-                            *version,</div><div class="diff-removed">-                            field_name,</div><div class="diff-removed">-                            Some(schema),</div><div class="diff-removed">-                            &hw_counter,</div><div class="diff-removed">-                        )?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    ProxyIndexChange::Delete(version) => {</div><div class="diff-removed">-                        optimized_segment.delete_field_index(*version, field_name)?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                self.check_cancellation(stopped)?;</div><div class="diff-removed">-            }</div><div class="diff-added">+            let mut write_segments_guard = segments.write();</div><div> </div><div>             let deleted_points = proxy_deleted_points.read();</div><div class="diff-removed">-            let points_diff = deleted_points</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .filter(|&(point_id, _version)| !already_remove_points.contains(point_id));</div><div class="diff-added">+</div><div class="diff-added">+            let points_diff = deleted_points.iter().filter(|&(point_id, _version)| !already_remove_points.contains(point_id));</div><div class="diff-added">+</div><div>             for (&point_id, &versions) in points_diff {</div><div class="diff-removed">-                // Delete points here with their operation version, that'll bump the optimized</div><div class="diff-removed">-                // segment version and will ensure we flush the new changes</div><div class="diff-removed">-                debug_assert!(</div><div class="diff-removed">-                    versions.operation_version</div><div class="diff-removed">-                        >= optimized_segment.point_version(point_id).unwrap_or(0),</div><div class="diff-removed">-                    "proxied point deletes should have newer version than point in segment",</div><div class="diff-removed">-                );</div><div class="diff-removed">-                optimized_segment</div><div class="diff-removed">-                    .delete_point(versions.operation_version, point_id, &hw_counter)</div><div class="diff-removed">-                    .unwrap();</div><div class="diff-added">+</div><div class="diff-added">+                debug_assert!(versions.operation_version >= optimized_segment.point_version(point_id).unwrap_or(0), "proxied point deletes should have newer version than point in segment");</div><div class="diff-added">+</div><div class="diff-added">+                optimized_segment.delete_point(versions.operation_version, point_id, hw_counter).unwrap();</div><div class="diff-added">+</div><div>             }</div><div> </div><div>             let point_count = optimized_segment.available_point_count();</div><div> </div><div>             let (_, proxies) = write_segments_guard.swap_new(optimized_segment, &proxy_ids);</div><div class="diff-removed">-            debug_assert_eq!(</div><div class="diff-removed">-                proxies.len(),</div><div class="diff-removed">-                proxy_ids.len(),</div><div class="diff-removed">-                "swapped different number of proxies on unwrap, missing or incorrect segment IDs?",</div><div class="diff-removed">-            );</div><div class="diff-added">+</div><div class="diff-added">+            debug_assert_eq!(proxies.len(), proxy_ids.len(), "swapped different number of proxies on unwrap, missing or incorrect segment IDs?",);</div><div> </div><div>             let has_appendable_segments = write_segments_guard.has_appendable_segment();</div><div> </div><div class="diff-removed">-            // Release reference counter of the optimized segments</div><div>             drop(optimizing_segments);</div><div> </div><div class="diff-removed">-            // Append a temp segment to collection if it is not empty or there is no other appendable segment</div><div class="diff-removed">-            if !has_appendable_segments || !tmp_segment.get().read().is_empty() {</div><div class="diff-added">+            let had_appendable_segments = has_appendable_segments;</div><div class="diff-added">+</div><div class="diff-added">+            if !had_appendable_segments || !tmp_segment.get().read().is_empty()  {</div><div class="diff-added">+</div><div>                 write_segments_guard.add_new_locked(tmp_segment);</div><div> </div><div class="diff-removed">-                // unlock collection for search and updates</div><div>                 drop(write_segments_guard);</div><div class="diff-removed">-                // After the collection is unlocked - we can remove data as slow as we want.</div><div> </div><div class="diff-removed">-                // Only remove data after we ensure the consistency of the collection.</div><div class="diff-removed">-                // If remove fails - we will still have operational collection with reported error.</div><div>                 for proxy in proxies {</div><div class="diff-added">+</div><div>                     proxy.drop_data()?;</div><div class="diff-added">+</div><div class="diff-added">+                    proxy.advise_dontneed()?;</div><div class="diff-added">+</div><div>                 }</div><div class="diff-added">+</div><div>             } else {</div><div class="diff-removed">-                // unlock collection for search and updates</div><div class="diff-removed">-                drop(write_segments_guard);</div><div class="diff-removed">-                // After the collection is unlocked - we can remove data as slow as we want.</div><div> </div><div class="diff-removed">-                // Proxy contains pointer to the `tmp_segment`, so they should be removed first</div><div class="diff-added">+                drop(write_segments_guard); </div><div class="diff-added">+</div><div>                 for proxy in proxies {</div><div class="diff-added">+</div><div>                     proxy.drop_data()?;</div><div class="diff-added">+</div><div class="diff-added">+                    proxy.advise_dontneed()?;</div><div class="diff-added">+</div><div>                 }</div><div class="diff-added">+</div><div>                 tmp_segment.drop_data()?;</div><div class="diff-added">+</div><div class="diff-added">+                tmp_segment.get().read().advise_dontneed()?;</div><div class="diff-added">+</div><div>             }</div><div> </div><div>             timer.set_success(true);</div><div> </div><div>             Ok(point_count)</div><div class="diff-added">+</div><div>         }</div><div class="diff-added">+</div><div>     }</div><div class="diff-added">+</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    