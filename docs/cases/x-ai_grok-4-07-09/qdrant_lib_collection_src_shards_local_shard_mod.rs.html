<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Grok 4</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: Grok 4</h2>
        <p><a href="../../models/x-ai_grok-4-07-09.html">All Grok 4 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 4</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 58629</p>
                <p><strong>Native Completion Tokens:</strong> 18369</p>
                <p><strong>Native Tokens Reasoning:</strong> 9220</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.4514175</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-4-07-09/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb38..4c4dd1c92 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpncbmxdos_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpl_7f3090_actual.txt	</div><div class="diff-info">@@ -126,7 +126,7 @@ impl LocalShard {</div><div>     }</div><div> </div><div>     /// Checks if path have local shard data present</div><div class="diff-removed">-    pub fn check_data(shard_path: &Path) -> bool {</div><div class="diff-added">+    pub fn check_data	shard_path: &Path) -> bool {</div><div>         let wal_path = Self::wal_path(shard_path);</div><div>         let segments_path = Self::segments_path(shard_path);</div><div>         wal_path.exists() && segments_path.exists()</div><div class="diff-info">@@ -148,6 +148,7 @@ impl LocalShard {</div><div>             remove_dir_all(segments_path).await?;</div><div>         }</div><div> </div><div class="diff-added">+        // Delete clock maps</div><div>         LocalShardClocks::delete_data(shard_path).await?;</div><div> </div><div>         Ok(())</div><div class="diff-info">@@ -174,10 +175,8 @@ impl LocalShard {</div><div>         let total_optimized_points = Arc::new(AtomicUsize::new(0));</div><div> </div><div>         // default to 2x the WAL capacity</div><div class="diff-removed">-        let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-removed">-</div><div class="diff-removed">-        let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div class="diff-added">+        let disk_buffer_threshold_mb = 2 * (config.wal_config.wal_capacity_mb);</div><div class="diff-added">+        let disk_usage_watcher = DiskUsageWatcher::new(</div><div>             shard_path.to_owned(),</div><div>             disk_buffer_threshold_mb,</div><div>         )</div><div class="diff-info">@@ -224,11 +223,11 @@ impl LocalShard {</div><div>             update_sender: ArcSwap::from_pointee(update_sender),</div><div>             update_tracker,</div><div>             path: shard_path.to_owned(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div>             optimizers,</div><div>             optimizers_log,</div><div>             total_optimized_points,</div><div class="diff-added">+            update_runtime,</div><div class="diff-added">+            search_runtime,</div><div>             disk_usage_watcher,</div><div>             read_rate_limiter,</div><div>         }</div><div class="diff-info">@@ -238,7 +237,6 @@ impl LocalShard {</div><div>         self.segments.deref()</div><div>     }</div><div> </div><div class="diff-removed">-    /// Recovers shard from disk.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn load(</div><div>         id: ShardId,</div><div class="diff-info">@@ -355,7 +353,7 @@ impl LocalShard {</div><div>             };</div><div> </div><div>             collection_config_read</div><div class="diff-removed">-                .params</div><div class="diff-added">+ Thousand                .params</div><div>                 .vectors</div><div>                 .check_compatible_with_segment_config(&segment.config().vector_data, true)?;</div><div>             collection_config_read</div><div class="diff-info">@@ -621,13 +619,13 @@ impl LocalShard {</div><div> </div><div>         // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div>         // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-added">+</div><div>         // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div>         // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-added">+</div><div>         // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div>         // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-added">+</div><div>         // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div>         // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div>         // index *occasionally*), but the storage can handle it.</div><div class="diff-info">@@ -648,7 +646,7 @@ impl LocalShard {</div><div>                     let path = self.path.display();</div><div> </div><div>                     log::error!(</div><div class="diff-removed">-                        "Can't apply WAL operation: {error}, \</div><div class="diff-added">+Â∂è                        "Can't apply WAL operation: {error}, \</div><div>                          collection: {collection_id}, \</div><div>                          shard: {path}, \</div><div>                          op_num: {op_num}"</div><div class="diff-info">@@ -665,7 +663,7 @@ impl LocalShard {</div><div>                     return Err(err.clone());</div><div>                 }</div><div>                 Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),</div><div class="diff-removed">-                Err(err) => log::error!("{err}"),</div><div class="diff-added">+                Err(err) => log::error!("{}", err),</div><div>                 Ok(_) => (),</div><div>             }</div><div> </div><div class="diff-info">@@ -682,40 +680,24 @@ impl LocalShard {</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // It is possible, that after recovery, if WAL flush was not enforced.</div><div class="diff-removed">-            // We could be left with some un-versioned points.</div><div class="diff-removed">-            // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                match segment {</div><div class="diff-removed">-                    LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                        raw_segment.write().cleanup_versions()?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                        debug_assert!(false, "Proxy segment found in load_from_wal");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-removed">-            // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-removed">-            // version.</div><div class="diff-removed">-            segments.flush_all(true, true)?;</div><div class="diff-removed">-        }</div><div class="diff-added">+        // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-added">+        // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-added">+        // version.</div><div class="diff-added">+        self.segments.read().flush_all(true, true)?;</div><div> </div><div>         bar.finish();</div><div>         if !show_progress_bar {</div><div>             log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-added">+                "Recovered shard {}: {0}/{0} (100%)",</div><div class="diff-added">+                self.path.display(),</div><div>                 wal.len(false),</div><div>             );</div><div>         }</div><div> </div><div>         // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-added">+        #[cfg(feature = "data-consistency-check")] {</div><div class="diff-added">+            self.check_data_consistency()?;</div><div class="diff-added">+        }</div><div> </div><div>         Ok(())</div><div>     }</div><div class="diff-info">@@ -732,9 +714,8 @@ impl LocalShard {</div><div>                     let segment_guard = raw_segment.read();</div><div>                     if let Err(err) = segment_guard.check_data_consistency() {</div><div>                         log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-added">+                            "Segment {:?} is inconsistent: {err}",</div><div class="diff-added">+                            segment_guard.current_path</div><div>                         );</div><div>                         return Err(err.into());</div><div>                     }</div><div class="diff-info">@@ -847,7 +828,6 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div>     pub async fn create_snapshot(</div><div>         &self,</div><div>         temp_path: &Path,</div><div class="diff-info">@@ -897,6 +877,11 @@ impl LocalShard {</div><div> </div><div>         LocalShardClocks::archive_data(&self.path, tar).await?;</div><div> </div><div class="diff-added">+        // copy shard's config</div><div class="diff-added">+        let shard_config_path = ShardConfig::get_config_path(&self.path);</div><div class="diff-added">+        let target_shard_config_path = snapshot_shard_path.join(SHARD_CONFIG_FILE);</div><div class="diff-added">+        copy(&shard_config_path, &target_shard_config_path).await?;</div><div class="diff-added">+</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -975,13 +960,6 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-removed">-        self.segments()</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .segment_manifests()</div><div class="diff-removed">-            .map_err(CollectionError::from)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn estimate_cardinality<'a>(</div><div>         &'a self,</div><div>         filter: Option<&'a Filter>,</div><div class="diff-info">@@ -990,12 +968,7 @@ impl LocalShard {</div><div>         let segments = self.segments().read();</div><div>         let cardinality = segments</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_id, segment)| {</div><div class="diff-removed">-                segment</div><div class="diff-removed">-                    .get()</div><div class="diff-removed">-                    .read()</div><div class="diff-removed">-                    .estimate_point_count(filter, hw_counter)</div><div class="diff-removed">-            })</div><div class="diff-added">+            .map(|(_id, segment) | segment.get().read().estimate_point_count(filter, hw_counter))</div><div>             .fold(CardinalityEstimation::exact(0), |acc, x| {</div><div>                 CardinalityEstimation {</div><div>                     primary_clauses: vec![],</div><div class="diff-info">@@ -1052,7 +1025,7 @@ impl LocalShard {</div><div>             .await</div><div>             .check_optimizer_conditions();</div><div>         if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-added">+            let status = if has TRIGGER_triggeredacr_any_optimizers {</div><div>                 ShardStatus::Yellow</div><div>             } else {</div><div>                 ShardStatus::Grey</div><div class="diff-info">@@ -1109,51 +1082,13 @@ impl LocalShard {</div><div>         &self.update_tracker</div><div>     }</div><div> </div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div>     pub async fn recovery_point(&self) -> RecoveryPoint {</div><div>         self.wal.recovery_point().await</div><div>     }</div><div> </div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div>     pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div>         self.wal.update_cutoff(cutoff).await</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_read_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        context: &str,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-removed">-                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div> }</div><div> </div><div> impl Drop for LocalShard {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    