<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - DeepSeek R1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/deepseek_deepseek-r1.html">‚Üê Back to DeepSeek R1 Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 61379</p>
                <p><strong>Native Completion Tokens:</strong> 8129</p>
                <p><strong>Native Tokens Reasoning:</strong> 662</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.05086588</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -1,8 +1,8 @@ use std::cmp::min;</div><div> use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div class="diff-added">+use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> use std::sync::Arc;</div><div class="diff-removed">-use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> </div><div> use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-info">@@ -16,10 +16,10 @@ use segment::types::SeqNumberType;</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::{self, Receiver, Sender};</div><div class="diff-removed">-use tokio::sync::{Mutex as TokioMutex, oneshot};</div><div class="diff-added">+use tokio::sync::{oneshot, Mutex as TokioMutex};</div><div> use tokio::task::{self, JoinHandle};</div><div> use tokio::time::error::Elapsed;</div><div class="diff-removed">-use tokio::time::{Duration, timeout};</div><div class="diff-added">+use tokio::time::{timeout, Duration};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_manager::collection_updater::CollectionUpdater;</div><div class="diff-info">@@ -28,11 +28,11 @@     OptimizerThresholds, SegmentOptimizer,</div><div> };</div><div> use crate::collection_manager::optimizers::{Tracker, TrackerLog, TrackerStatus};</div><div class="diff-removed">-use crate::common::stoppable_task::{StoppableTaskHandle, spawn_stoppable};</div><div class="diff-added">+use crate::common::stoppable_task::{spawn_stoppable, StoppableTaskHandle};</div><div> use crate::config::CollectionParams;</div><div class="diff-removed">-use crate::operations::CollectionUpdateOperations;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult};</div><div class="diff-added">+use crate::operations::CollectionUpdateOperations;</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::local_shard::LocalShardClocks;</div><div> use crate::wal::WalError;</div><div class="diff-info">@@ -111,9 +111,9 @@     runtime_handle: Handle,</div><div>     /// WAL, required for operations</div><div>     wal: LockedWal,</div><div class="diff-removed">-    /// Always keep this WAL version and later and prevent acknowledging/truncating from the WAL.</div><div class="diff-removed">-    /// This is used when other bits of code still depend on information in the WAL, such as the</div><div class="diff-removed">-    /// queue proxy shard.</div><div class="diff-added">+    /// Maximum version to acknowledge to WAL to prevent truncating too early</div><div class="diff-added">+    /// This is used when another part still relies on part of the WAL, such as the queue proxy</div><div class="diff-added">+    /// shard.</div><div>     /// Defaults to `u64::MAX` to allow acknowledging all confirmed versions.</div><div>     pub(super) wal_keep_from: Arc<AtomicU64>,</div><div>     optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-info">@@ -187,7 +187,7 @@         self.update_worker = Some(self.runtime_handle.spawn(Self::update_worker_fn(</div><div>             update_receiver,</div><div>             tx,</div><div class="diff-removed">-            self.wal.clone(),</div><div class="diff-added">+            self.payload_index_schema.clone(),</div><div>             self.segments.clone(),</div><div>         )));</div><div>         let (flush_tx, flush_rx) = oneshot::channel();</div><div class="diff-info">@@ -333,7 +333,6 @@                 let segments = segments.clone();</div><div>                 let nsi = nonoptimal_segment_ids.clone();</div><div>                 scheduled_segment_ids.extend(&nsi);</div><div class="diff-removed">-                let callback = callback.clone();</div><div> </div><div>                 let handle = spawn_stoppable(</div><div>                     // Stoppable task</div><div class="diff-info">@@ -372,6 +371,8 @@                                         false</div><div>                                     }</div><div>                                     _ => {</div><div class="diff-added">+                                        // Save only the first error</div><div class="diff-added">+                                        // If is more likely to be the real cause of all further problems</div><div>                                         segments.write().report_optimizer_error(error.clone());</div><div> </div><div>                                         // Error of the optimization can not be handled by API user</div><div class="diff-info">@@ -409,7 +410,6 @@                 handles.push(handle);</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div>         handles</div><div>     }</div><div> </div><div class="diff-info">@@ -505,6 +505,7 @@         );</div><div>         let mut handles = optimization_handles.lock().await;</div><div>         handles.append(&mut new_handles);</div><div class="diff-added">+        handles.retain(|h| !h.is_finished())</div><div>     }</div><div> </div><div>     /// Cleanup finalized optimization task handles</div><div class="diff-info">@@ -679,7 +680,7 @@     async fn update_worker_fn(</div><div>         mut receiver: Receiver<UpdateSignal>,</div><div>         optimize_sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>         segments: LockedSegmentHolder,</div><div>     ) {</div><div>         while let Some(signal) = receiver.recv().await {</div><div class="diff-info">@@ -692,9 +693,10 @@                     hw_measurements,</div><div>                 }) => {</div><div>                     let flush_res = if wait {</div><div class="diff-removed">-                        wal.lock().await.flush().map_err(|err| {</div><div class="diff-added">+                        segments.read().flush_all(false, false).map_err(|err| {</div><div>                             CollectionError::service_error(format!(</div><div class="diff-removed">-                                "Can't flush WAL before operation {op_num} - {err}"</div><div class="diff-added">+                                "Can't flush segments before operation {} - {}",</div><div class="diff-added">+                                op_num, err</div><div>                             ))</div><div>                         })</div><div>                     } else {</div><div class="diff-info">@@ -754,6 +756,7 @@             .unwrap_or_else(|_| debug!("Optimizer already stopped"));</div><div>     }</div><div> </div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div>     async fn flush_worker(</div><div>         segments: LockedSegmentHolder,</div><div>         wal: LockedWal,</div><div class="diff-info">@@ -772,7 +775,7 @@                     debug!("Stopping flush worker for shard {}", shard_path.display());</div><div>                     return;</div><div>                 }</div><div class="diff-removed">-            }</div><div class="diff-added">+            };</div><div> </div><div>             trace!("Attempting flushing");</div><div>             let wal_flash_job = wal.lock().await.flush_async();</div><div class="diff-info">@@ -811,7 +814,7 @@ </div><div>             let ack = confirmed_version.min(keep_from.saturating_sub(1));</div><div> </div><div class="diff-removed">-            if let Err(err) = clocks.store_if_changed(&shard_path).await {</div><div class="diff-added">+            if let Err(err) = clocks.store(&shard_path).await {</div><div>                 log::warn!("Failed to store clock maps to disk: {err}");</div><div>                 segments.write().report_optimizer_error(err);</div><div>             }</div><div class="diff-info">@@ -837,7 +840,7 @@     }</div><div> }</div><div> </div><div class="diff-removed">-/// Trigger optimizers when CPU budget is available</div><div class="diff-added">+/// Trigger optimizers when resource budget is available</div><div> fn trigger_optimizers_on_resource_budget(</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     desired_cpus: usize,</div><div class="diff-info">@@ -845,11 +848,11 @@     sender: Sender<OptimizerSignal>,</div><div> ) -> JoinHandle<()> {</div><div>     task::spawn(async move {</div><div class="diff-removed">-        log::trace!("Skipping optimization checks, waiting for CPU budget to be available");</div><div class="diff-added">+        log::trace!("Skipping optimization checks, waiting for resource budget to be available");</div><div>         optimizer_resource_budget</div><div>             .notify_on_budget_available(desired_cpus, desired_io)</div><div>             .await;</div><div class="diff-removed">-        log::trace!("Continue optimization checks, new CPU budget available");</div><div class="diff-added">+        log::trace!("Continue optimization checks, new resource budget available");</div><div> </div><div>         // Trigger optimizers with Nop operation</div><div>         sender.send(OptimizerSignal::Nop).await.unwrap_or_else(|_| {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    