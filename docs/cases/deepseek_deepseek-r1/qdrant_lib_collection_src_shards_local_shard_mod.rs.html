<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - DeepSeek R1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: DeepSeek R1</h2>
        <p><a href="../../models/deepseek_deepseek-r1.html">All DeepSeek R1 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 63941</p>
                <p><strong>Native Completion Tokens:</strong> 4743</p>
                <p><strong>Native Tokens Reasoning:</strong> 1140</p>
                <p><strong>Native Finish Reason:</strong> None</p>
                <p><strong>Cost:</strong> $0.04231024</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb3..3015347b 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpgfth8h0r_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpqe32lg7o_actual.txt	</div><div class="diff-info">@@ -34,6 +34,7 @@ use segment::types::{</div><div>     Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,</div><div>     SnapshotFormat,</div><div> };</div><div class="diff-added">+use segment::vector_storage::common::get_async_scorer;</div><div> use tokio::fs::{create_dir_all, remove_dir_all, remove_file};</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::Sender;</div><div class="diff-info">@@ -71,11 +72,8 @@ use crate::wal_delta::{LockedWal, RecoverableWal};</div><div> const WAL_LOAD_REPORT_EVERY: Duration = Duration::from_secs(60);</div><div> </div><div> const WAL_PATH: &str = "wal";</div><div class="diff-removed">-</div><div> const SEGMENTS_PATH: &str = "segments";</div><div class="diff-removed">-</div><div> const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";</div><div class="diff-removed">-</div><div> const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";</div><div> </div><div> /// LocalShard</div><div class="diff-info">@@ -148,6 +146,7 @@ impl LocalShard {</div><div>             remove_dir_all(segments_path).await?;</div><div>         }</div><div> </div><div class="diff-added">+        // Delete clock maps</div><div>         LocalShardClocks::delete_data(shard_path).await?;</div><div> </div><div>         Ok(())</div><div class="diff-info">@@ -176,7 +175,7 @@ impl LocalShard {</div><div>         // default to 2x the WAL capacity</div><div>         let disk_buffer_threshold_mb =</div><div>             2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-removed">-</div><div class="diff-added">+        </div><div>         let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div>             shard_path.to_owned(),</div><div>             disk_buffer_threshold_mb,</div><div class="diff-info">@@ -234,10 +233,6 @@ impl LocalShard {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Recovers shard from disk.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn load(</div><div class="diff-info">@@ -411,864 +406,4 @@ impl LocalShard {</div><div>             )?;</div><div>         }</div><div> </div><div class="diff-removed">-        let local_shard = LocalShard::new(</div><div class="diff-removed">-            segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            clocks,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Apply outstanding operations from WAL</div><div class="diff-removed">-        local_shard.load_from_wal(collection_id).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(local_shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn shard_path(&self) -> PathBuf {</div><div class="diff-removed">-        self.path.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn wal_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(WAL_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn segments_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(SEGMENTS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build_local(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        // initialize local shard config file</div><div class="diff-removed">-        let local_shard_config = ShardConfig::new_replica_set();</div><div class="diff-removed">-        let shard = Self::build(</div><div class="diff-removed">-            id,</div><div class="diff-removed">-            collection_id,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            effective_optimizers_config,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await?;</div><div class="diff-removed">-        local_shard_config.save(shard_path)?;</div><div class="diff-removed">-        Ok(shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        let config = collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal_path = Self::wal_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&wal_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard wal directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&segments_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard segments directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut segment_holder = SegmentHolder::default();</div><div class="diff-removed">-        let mut build_handlers = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_params = config.params.to_base_vector_data()?;</div><div class="diff-removed">-        let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div class="diff-removed">-        let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        for _sid in 0..segment_number {</div><div class="diff-removed">-            let path_clone = segments_path.clone();</div><div class="diff-removed">-            let segment_config = SegmentConfig {</div><div class="diff-removed">-                vector_data: vector_params.clone(),</div><div class="diff-removed">-                sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-removed">-                payload_storage_type: config.params.payload_storage_type(),</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let segment = thread::Builder::new()</div><div class="diff-removed">-                .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            build_handlers.push(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let join_results = build_handlers</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|handler| handler.join())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for join_result in join_results {</div><div class="diff-removed">-            let segment = join_result.map_err(|err| {</div><div class="diff-removed">-                let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-removed">-                let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-removed">-</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Segment DB create panicked{separator}{message}",</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })??;</div><div class="diff-removed">-</div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-removed">-            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection = LocalShard::new(</div><div class="diff-removed">-            segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            LocalShardClocks::default(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(collection)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn stop_flush_worker(&self) {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.stop_flush_worker()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.wait_workers_stops().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Loads latest collection operations from WAL</div><div class="diff-removed">-    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-removed">-        let wal = self.wal.wal.lock().await;</div><div class="diff-removed">-        let bar = ProgressBar::new(wal.len(false));</div><div class="diff-removed">-</div><div class="diff-removed">-        let progress_style = ProgressStyle::default_bar()</div><div class="diff-removed">-            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")</div><div class="diff-removed">-            .expect("Failed to create progress style");</div><div class="diff-removed">-        bar.set_style(progress_style);</div><div class="diff-removed">-</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Recovering shard {} starting reading WAL from {}",</div><div class="diff-removed">-            self.path.display(),</div><div class="diff-removed">-            wal.first_index(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.set_message(format!("Recovering collection {collection_id}"));</div><div class="diff-removed">-        let segments = self.segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Fall back to basic text output if the progress bar is hidden (e.g. not a tty)</div><div class="diff-removed">-        let show_progress_bar = !bar.is_hidden();</div><div class="diff-removed">-        let mut last_progress_report = Instant::now();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovering shard {}: 0/{} (0%)",</div><div class="diff-removed">-                self.path.display(),</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div class="diff-removed">-        // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div class="diff-removed">-        // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div class="diff-removed">-        // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div class="diff-removed">-        // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div class="diff-removed">-        // index *occasionally*), but the storage can handle it.</div><div class="diff-removed">-</div><div class="diff-removed">-        for (op_num, update) in wal.read_all(false) {</div><div class="diff-removed">-            if let Some(clock_tag) = update.clock_tag {</div><div class="diff-removed">-                newest_clocks.advance_clock(clock_tag);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate `CollectionError::ServiceError`, but skip other error types.</div><div class="diff-removed">-            match &CollectionUpdater::update(</div><div class="diff-removed">-                segments,</div><div class="diff-removed">-                op_num,</div><div class="diff-removed">-                update.operation,</div><div class="diff-removed">-                &HardwareCounterCell::disposable(), // Internal operation, no measurement needed.</div><div class="diff-removed">-            ) {</div><div class="diff-removed">-                Err(err @ CollectionError::ServiceError { error, backtrace }) => {</div><div class="diff-removed">-                    let path = self.path.display();</div><div class="diff-removed">-</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Can't apply WAL operation: {error}, \</div><div class="diff-removed">-                         collection: {collection_id}, \</div><div class="diff-removed">-                         shard: {path}, \</div><div class="diff-removed">-                         op_num: {op_num}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-</div><div class="diff-removed">-                    if let Some(backtrace) = &backtrace {</div><div class="diff-removed">-                        log::error!("Backtrace: {backtrace}");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::OutOfMemory { .. }) => {</div><div class="diff-removed">-                    log::error!("{err}");</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),</div><div class="diff-removed">-                Err(err) => log::error!("{err}"),</div><div class="diff-removed">-                Ok(_) => (),</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Update progress bar or show text progress every WAL_LOAD_REPORT_EVERY</div><div class="diff-removed">-            bar.inc(1);</div><div class="diff-removed">-            if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div class="diff-removed">-                let progress = bar.position();</div><div class="diff-removed">-                log::info!(</div><div class="diff-removed">-                    "{progress}/{} ({}%)",</div><div class="diff-removed">-                    wal.len(false),</div><div class="diff-removed">-                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                last_progress_report = Instant::now();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // It is possible, that after recovery, if WAL flush was not enforced.</div><div class="diff-removed">-            // We could be left with some un-versioned points.</div><div class="diff-removed">-            // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                match segment {</div><div class="diff-removed">-                    LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                        raw_segment.write().cleanup_versions()?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                        debug_assert!(false, "Proxy segment found in load_from_wal");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-removed">-            // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-removed">-            // version.</div><div class="diff-removed">-            segments.flush_all(true, true)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.finish();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        // makes sure that the Stop signal is the last one in this channel</div><div class="diff-removed">-        let old_sender = self.update_sender.swap(Arc::new(update_sender));</div><div class="diff-removed">-        old_sender.send(UpdateSignal::Stop).await?;</div><div class="diff-removed">-        update_handler.stop_flush_worker();</div><div class="diff-removed">-</div><div class="diff-removed">-        update_handler.wait_workers_stops().await?;</div><div class="diff-removed">-        let new_optimizers = build_optimizers(</div><div class="diff-removed">-            &self.path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &config.optimizer_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        update_handler.optimizers = new_optimizers;</div><div class="diff-removed">-        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div class="diff-removed">-        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div class="diff-removed">-    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-removed">-            if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update read rate limiter</div><div class="diff-removed">-                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-removed">-                    let new_read_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-removed">-                    self.read_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-removed">-                    return;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // remove read rate limiter for all other situations</div><div class="diff-removed">-        self.read_rate_limiter.take();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn trigger_optimizers(&self) {</div><div class="diff-removed">-        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-removed">-        // - If receiver is already dead - we do not care</div><div class="diff-removed">-        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Finishes ongoing update tasks</div><div class="diff-removed">-    pub async fn stop_gracefully(&self) {</div><div class="diff-removed">-        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-removed">-            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.stop_flush_worker().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-removed">-            log::warn!("Update workers failed with: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div class="diff-removed">-        // Read dir first as the directory contents would change during restore</div><div class="diff-removed">-        let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Filter out hidden entries</div><div class="diff-removed">-        let entries = entries.into_iter().filter(|entry| {</div><div class="diff-removed">-            let is_hidden = entry</div><div class="diff-removed">-                .file_name()</div><div class="diff-removed">-                .to_str()</div><div class="diff-removed">-                .is_some_and(|s| s.starts_with('.'));</div><div class="diff-removed">-            if is_hidden {</div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Ignoring hidden segment in local shard during snapshot recovery: {}",</div><div class="diff-removed">-                    entry.path().display(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-            !is_hidden</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        for entry in entries {</div><div class="diff-removed">-            Segment::restore_snapshot_in_place(&entry.path())?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div class="diff-removed">-    pub async fn create_snapshot(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-        format: SnapshotFormat,</div><div class="diff-removed">-        save_wal: bool,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        let wal = self.wal.wal.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if !save_wal {</div><div class="diff-removed">-            // If we are not saving WAL, we still need to make sure that all submitted by this point</div><div class="diff-removed">-            // updates have made it to the segments. So we use the Plunger to achieve that.</div><div class="diff-removed">-            // It will notify us when all submitted updates so far have been processed.</div><div class="diff-removed">-            let (tx, rx) = oneshot::channel();</div><div class="diff-removed">-            let plunger = UpdateSignal::Plunger(tx);</div><div class="diff-removed">-            self.update_sender.load().send(plunger).await?;</div><div class="diff-removed">-            rx.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(&self.path);</div><div class="diff-removed">-        let collection_params = self.collection_config.read().await.params.clone();</div><div class="diff-removed">-        let temp_path = temp_path.to_owned();</div><div class="diff-removed">-        let payload_index_schema = self.payload_index_schema.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar_c = tar.clone();</div><div class="diff-removed">-        tokio::task::spawn_blocking(move || {</div><div class="diff-removed">-            // Do not change segments while snapshotting</div><div class="diff-removed">-            SegmentHolder::snapshot_all_segments(</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                Some(&collection_params),</div><div class="diff-removed">-                &payload_index_schema.read().clone(),</div><div class="diff-removed">-                &temp_path,</div><div class="diff-removed">-                &tar_c.descend(Path::new(SEGMENTS_PATH))?,</div><div class="diff-removed">-                format,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if save_wal {</div><div class="diff-removed">-                // snapshot all shard's WAL</div><div class="diff-removed">-                Self::snapshot_wal(wal, &tar_c)</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                Self::snapshot_empty_wal(wal, &temp_path, &tar_c)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .await??;</div><div class="diff-removed">-</div><div class="diff-removed">-        LocalShardClocks::archive_data(&self.path, tar).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create empty WAL which is compatible with currently stored data</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_empty_wal(</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let (segment_capacity, latest_op_num) = {</div><div class="diff-removed">-            let wal_guard = wal.blocking_lock();</div><div class="diff-removed">-            (wal_guard.segment_capacity(), wal_guard.last_index())</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = tempfile::tempdir_in(temp_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can not create temporary directory for WAL: {err}",</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Wal::generate_empty_wal_starting_at_index(</div><div class="diff-removed">-            temp_dir.path(),</div><div class="diff-removed">-            &WalOptions {</div><div class="diff-removed">-                segment_capacity,</div><div class="diff-removed">-                segment_queue_len: 0,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            latest_op_num,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Error while create empty WAL: {err}"))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-            })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// snapshot WAL</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        // lock wal during snapshot</div><div class="diff-removed">-        let mut wal_guard = wal.blocking_lock();</div><div class="diff-removed">-        wal_guard.flush()?;</div><div class="diff-removed">-        let source_wal_path = wal_guard.path();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar = tar.descend(Path::new(WAL_PATH))?;</div><div class="diff-removed">-        for entry in std::fs::read_dir(source_wal_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-        })? {</div><div class="diff-removed">-            let entry = entry.map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if entry.file_name() == ".wal" {</div><div class="diff-removed">-                // This sentinel file is used for WAL locking. Trying to archive</div><div class="diff-removed">-                // or open it will cause the following error on Windows:</div><div class="diff-removed">-                // > The process cannot access the file because another process</div><div class="diff-removed">-                // > has locked a portion of the file. (os error 33)</div><div class="diff-removed">-                // https://github.com/qdrant/wal/blob/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual)::new(&entry.file_name()))</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-removed">-        self.segments()</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .segment_manifests()</div><div class="diff-removed">-            .map_err(CollectionError::from)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn estimate_cardinality<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CollectionResult<CardinalityEstimation> {</div><div class="diff-removed">-        let segments = self.segments().read();</div><div class="diff-removed">-        let cardinality = segments</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_id, segment)| {</div><div class="diff-removed">-                segment</div><div class="diff-removed">-                    .get()</div><div class="diff-removed">-                    .read()</div><div class="diff-removed">-                    .estimate_point_count(filter, hw_counter)</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .fold(CardinalityEstimation::exact(0), |acc, x| {</div><div class="diff-removed">-                CardinalityEstimation {</div><div class="diff-removed">-                    primary_clauses: vec![],</div><div class="diff-removed">-                    min: acc.min + x.min,</div><div class="diff-removed">-                    exp: acc.exp + x.exp,</div><div class="diff-removed">-                    max: acc.max + x.max,</div><div class="diff-removed">-                }</div><div class="diff-removed">-            });</div><div class="diff-removed">-        Ok(cardinality)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn read_filtered<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_counter: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Red status on failed operation or optimizer error</div><div class="diff-removed">-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {</div><div class="diff-removed">-                let optimizer_status = segments</div><div class="diff-removed">-                    .optimizer_errors</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .map_or(OptimizersStatus::Ok, |err| {</div><div class="diff-removed">-                        OptimizersStatus::Error(err.to_string())</div><div class="diff-removed">-                    });</div><div class="diff-removed">-                return (ShardStatus::Red, optimizer_status);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Yellow status if we have a special segment, indicates a proxy segment used during optimization</div><div class="diff-removed">-            // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div class="diff-removed">-            let has_special_segment = segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-removed">-                .any(|segment_type| segment_type == SegmentType::Special);</div><div class="diff-removed">-            if has_special_segment {</div><div class="diff-removed">-                return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Yellow or grey status if there are pending optimizations</div><div class="diff-removed">-        // Grey if optimizers were not triggered yet after restart,</div><div class="diff-removed">-        // we don't automatically trigger them to prevent a crash loop</div><div class="diff-removed">-        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self</div><div class="diff-removed">-            .update_handler</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .check_optimizer_conditions();</div><div class="diff-removed">-        if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-removed">-                ShardStatus::Yellow</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                ShardStatus::Grey</div><div class="diff-removed">-            };</div><div class="diff-removed">-            return (status, OptimizersStatus::Ok);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Green status because everything is fine</div><div class="diff-removed">-        (ShardStatus::Green, OptimizersStatus::Ok)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_info(&self) -> ShardInfoInternal {</div><div class="diff-removed">-        let collection_config = self.collection_config.read().await.clone();</div><div class="diff-removed">-        let mut vectors_count = 0;</div><div class="diff-removed">-        let mut indexed_vectors_count = 0;</div><div class="diff-removed">-        let mut points_count = 0;</div><div class="diff-removed">-        let mut segments_count = 0;</div><div class="diff-removed">-        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                segments_count += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_info = segment.get().read().info();</div><div class="diff-removed">-</div><div class="diff-removed">-                vectors_count += segment_info.num_vectors;</div><div class="diff-removed">-                indexed_vectors_count += segment_info.num_indexed_vectors;</div><div class="diff-removed">-                points_count += segment_info.num_points;</div><div class="diff-removed">-                for (key, val) in segment_info.index_schema {</div><div class="diff-removed">-                    schema</div><div class="diff-removed">-                        .entry(key)</div><div class="diff-removed">-                        .and_modify(|entry| entry.points += val.points)</div><div class="diff-removed">-                        .or_insert(val);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let (status, optimizer_status) = self.local_shard_status().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        ShardInfoInternal {</div><div class="diff-removed">-            status,</div><div class="diff-removed">-            optimizer_status,</div><div class="diff-removed">-            vectors_count,</div><div class="diff-removed">-            indexed_vectors_count,</div><div class="diff-removed">-            points_count,</div><div class="diff-removed">-            segments_count,</div><div class="diff-removed">-            config: collection_config,</div><div class="diff-removed">-            payload_schema: schema,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_read_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        context: &str,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-removed">-                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl Drop for LocalShard {</div><div class="diff-removed">-    fn drop(&mut self) {</div><div class="diff-removed">-        thread::scope(|s| {</div><div class="diff-removed">-            let handle = thread::Builder::new()</div><div class="diff-removed">-                .name("drop-shard".to_string())</div><div class="diff-removed">-                .spawn_scoped(s, || {</div><div class="diff-removed">-                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.</div><div class="diff-removed">-                    self.update_runtime</div><div class="diff-removed">-                        .block_on(async { self.stop_gracefully().await })</div><div class="diff-removed">-                });</div><div class="diff-removed">-            handle.expect("Failed to create thread for shard drop");</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Convenience struct for combining clock maps belonging to a shard</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Holds a clock map for tracking the highest clocks and the cutoff clocks.</div><div class="diff-removed">-#[derive(Clone, Debug, Default)]</div><div class="diff-removed">-pub struct LocalShardClocks {</div><div class="diff-removed">-    newest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-removed">-    oldest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl LocalShardClocks {</div><div class="diff-removed">-    fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {</div><div class="diff-removed">-        Self {</div><div class="diff-removed">-            newest_clocks: Arc::new(Mutex::new(newest_clocks)),</div><div class="diff-removed">-            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Load clock maps from disk</div><div class="diff-removed">-    pub fn load(shard_path: &Path) -> CollectionResult<Self> {</div><div class="diff-removed">-        let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let oldest_clocks = ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(Self::new(newest_clocks, oldest_clocks))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Persist clock maps to disk</div><div class="diff-removed">-    pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        self.oldest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.newest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Put clock data from the disk into an archive.</div><div class="diff-removed">-    pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&newest_clocks_from, Path::new(NEWEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&oldest_clocks_from, Path::new(OLDEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Move clock data on disk from one shard path to another.</div><div class="diff-removed">-    pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            let newest_clocks_to = Self::newest_clocks_path(to);</div><div class="diff-removed">-            move_file(newest_clocks_from, newest_clocks_to).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            let oldest_clocks_to = Self::oldest_clocks_path(to);</div><div class="diff-removed">-            move_file(oldest_clocks_from, oldest_clocks_to).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Delete clock data from disk at the given shard path.</div><div class="diff-removed">-    pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_path = Self::newest_clocks_path(shard_path);</div><div class="diff-removed">-        let oldest_clocks_path = Self::oldest_clocks_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(newest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(oldest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn newest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(NEWEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn oldest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(OLDEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+        let local_shard = LocalShard::new(</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    