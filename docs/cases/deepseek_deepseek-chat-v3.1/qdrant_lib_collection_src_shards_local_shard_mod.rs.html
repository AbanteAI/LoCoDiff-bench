<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - DeepSeek Chat v3.1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: DeepSeek Chat v3.1</h2>
        <p><a href="../../models/deepseek_deepseek-chat-v3.1.html">All DeepSeek Chat v3.1 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek Chat v3.1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 63940</p>
                <p><strong>Native Completion Tokens:</strong> 8600</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.019668</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb38..be83fdb43 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpqqms7p4i_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmp8zt7fw78_actual.txt	</div><div class="diff-info">@@ -26,6 +26,7 @@ use indicatif::{ProgressBar, ProgressStyle};</div><div> use itertools::Itertools;</div><div> use parking_lot::{Mutex as ParkingMutex, RwLock};</div><div> use segment::data_types::segment_manifest::SegmentManifests;</div><div class="diff-added">+use segment::data_types::vectors::VectorElementType;</div><div> use segment::entry::entry_point::SegmentEntry as _;</div><div> use segment::index::field_index::CardinalityEstimation;</div><div> use segment::segment::Segment;</div><div class="diff-info">@@ -34,6 +35,7 @@ use segment::types::{</div><div>     Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,</div><div>     SnapshotFormat,</div><div> };</div><div class="diff-added">+use segment::vector_storage::common::get_async_scorer;</div><div> use tokio::fs::{create_dir_all, remove_dir_all, remove_file};</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::Sender;</div><div class="diff-info">@@ -772,7 +774,6 @@ impl LocalShard {</div><div>         update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div>         update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div>         update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div>         self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div> </div><div>         Ok(())</div><div class="diff-info">@@ -900,6 +901,13 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-added">+    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-added">+        self.segments()</div><div class="diff-added">+            .read()</div><div class="diff-added">+            .segment_manifests()</div><div class="diff-added">+            .map_err(CollectionError::from)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     /// Create empty WAL which is compatible with currently stored data</div><div>     ///</div><div>     /// # Panics</div><div class="diff-info">@@ -975,13 +983,6 @@ impl LocalShard {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div class="diff-removed">-        self.segments()</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .segment_manifests()</div><div class="diff-removed">-            .map_err(CollectionError::from)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn estimate_cardinality<'a>(</div><div>         &'a self,</div><div>         filter: Option<&'a Filter>,</div><div class="diff-info">@@ -1009,266 +1010,4 @@ impl LocalShard {</div><div> </div><div>     pub async fn read_filtered<'a>(</div><div>         &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_counter: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Red status on failed operation or optimizer error</div><div class="diff-removed">-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {</div><div class="diff-removed">-                let optimizer_status = segments</div><div class="diff-removed">-                    .optimizer_errors</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .map_or(OptimizersStatus::Ok, |err| {</div><div class="diff-removed">-                        OptimizersStatus::Error(err.to_string())</div><div class="diff-removed">-                    });</div><div class="diff-removed">-                return (ShardStatus::Red, optimizer_status);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Yellow status if we have a special segment, indicates a proxy segment used during optimization</div><div class="diff-removed">-            // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div class="diff-removed">-            let has_special_segment = segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-removed">-                .any(|segment_type| segment_type == SegmentType::Special);</div><div class="diff-removed">-            if has_special_segment {</div><div class="diff-removed">-                return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Yellow or grey status if there are pending optimizations</div><div class="diff-removed">-        // Grey if optimizers were not triggered yet after restart,</div><div class="diff-removed">-        // we don't automatically trigger them to prevent a crash loop</div><div class="diff-removed">-        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self</div><div class="diff-removed">-            .update_handler</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .check_optimizer_conditions();</div><div class="diff-removed">-        if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-removed">-                ShardStatus::Yellow</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                ShardStatus::Grey</div><div class="diff-removed">-            };</div><div class="diff-removed">-            return (status, OptimizersStatus::Ok);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Green status because everything is fine</div><div class="diff-removed">-        (ShardStatus::Green, OptimizersStatus::Ok)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_info(&self) -> ShardInfoInternal {</div><div class="diff-removed">-        let collection_config = self.collection_config.read().await.clone();</div><div class="diff-removed">-        let mut vectors_count = 0;</div><div class="diff-removed">-        let mut indexed_vectors_count = 0;</div><div class="diff-removed">-        let mut points_count = 0;</div><div class="diff-removed">-        let mut segments_count = 0;</div><div class="diff-removed">-        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                segments_count += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_info = segment.get().read().info();</div><div class="diff-removed">-</div><div class="diff-removed">-                vectors_count += segment_info.num_vectors;</div><div class="diff-removed">-                indexed_vectors_count += segment_info.num_indexed_vectors;</div><div class="diff-removed">-                points_count += segment_info.num_points;</div><div class="diff-removed">-                for (key, val) in segment_info.index_schema {</div><div class="diff-removed">-                    schema</div><div class="diff-removed">-                        .entry(key)</div><div class="diff-removed">-                        .and_modify(|entry| entry.points += val.points)</div><div class="diff-removed">-                        .or_insert(val);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let (status, optimizer_status) = self.local_shard_status().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        ShardInfoInternal {</div><div class="diff-removed">-            status,</div><div class="diff-removed">-            optimizer_status,</div><div class="diff-removed">-            vectors_count,</div><div class="diff-removed">-            indexed_vectors_count,</div><div class="diff-removed">-            points_count,</div><div class="diff-removed">-            segments_count,</div><div class="diff-removed">-            config: collection_config,</div><div class="diff-removed">-            payload_schema: schema,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-removed">-    /// - hw_measurement_acc: the current hardware measurement accumulator</div><div class="diff-removed">-    /// - context: the context of the operation to add on the error message</div><div class="diff-removed">-    /// - cost_fn: the cost of the operation called lazily</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error if the rate limit is exceeded.</div><div class="diff-removed">-    fn check_read_rate_limiter<F>(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        hw_measurement_acc: &HwMeasurementAcc,</div><div class="diff-removed">-        context: &str,</div><div class="diff-removed">-        cost_fn: F,</div><div class="diff-removed">-    ) -> CollectionResult<()></div><div class="diff-removed">-    where</div><div class="diff-removed">-        F: FnOnce() -> usize,</div><div class="diff-removed">-    {</div><div class="diff-removed">-        // Do not rate limit internal operation tagged with disposable measurement</div><div class="diff-removed">-        if hw_measurement_acc.is_disposable() {</div><div class="diff-removed">-            return Ok(());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if let Some(rate_limiter) = &self.read_rate_limiter {</div><div class="diff-removed">-            let cost = cost_fn();</div><div class="diff-removed">-            rate_limiter</div><div class="diff-removed">-                .lock()</div><div class="diff-removed">-                .try_consume(cost as f64)</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    log::debug!("Read rate limit error on {context} with {err:?}");</div><div class="diff-removed">-                    CollectionError::rate_limit_error(err, cost, false)</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl Drop for LocalShard {</div><div class="diff-removed">-    fn drop(&mut self) {</div><div class="diff-removed">-        thread::scope(|s| {</div><div class="diff-removed">-            let handle = thread::Builder::new()</div><div class="diff-removed">-                .name("drop-shard".to_string())</div><div class="diff-removed">-                .spawn_scoped(s, || {</div><div class="diff-removed">-                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.</div><div class="diff-removed">-                    self.update_runtime</div><div class="diff-removed">-                        .block_on(async { self.stop_gracefully().await })</div><div class="diff-removed">-                });</div><div class="diff-removed">-            handle.expect("Failed to create thread for shard drop");</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Convenience struct for combining clock maps belonging to a shard</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Holds a clock map for tracking the highest clocks and the cutoff clocks.</div><div class="diff-removed">-#[derive(Clone, Debug, Default)]</div><div class="diff-removed">-pub struct LocalShardClocks {</div><div class="diff-removed">-    newest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-removed">-    oldest_clocks: Arc<Mutex<ClockMap>>,</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl LocalShardClocks {</div><div class="diff-removed">-    fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {</div><div class="diff-removed">-        Self {</div><div class="diff-removed">-            newest_clocks: Arc::new(Mutex::new(newest_clocks)),</div><div class="diff-removed">-            oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // Load clock maps from disk</div><div class="diff-removed">-    pub fn load(shard_path: &Path) -> CollectionResult<Self> {</div><div class="diff-removed">-        let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let oldest_clocks = ClockMap::load_or_default(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(Self::new(newest_clocks, oldest_clocks))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Persist clock maps to disk</div><div class="diff-removed">-    pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        self.oldest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::oldest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        self.newest_clocks</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .store_if_changed(&Self::newest_clocks_path(shard_path))?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Put clock data from the disk into an archive.</div><div class="diff-removed">-    pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&newest_clocks_from, Path::new(NEWEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            tar.append_file(&oldest_clocks_from, Path::new(OLDEST_CLOCKS_PATH))</div><div class="diff-removed">-                .await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Move clock data on disk from one shard path to another.</div><div class="diff-removed">-    pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_from = Self::newest_clocks_path(from);</div><div class="diff-removed">-        let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_from.exists() {</div><div class="diff-removed">-            let newest_clocks_to = Self::newest_clocks_path(to);</div><div class="diff-removed">-            move_file(newest_clocks_from, newest_clocks_to).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_from.exists() {</div><div class="diff-removed">-            let oldest_clocks_to = Self::oldest_clocks_path(to);</div><div class="diff-removed">-            move_file(oldest_clocks_from, oldest_clocks_to).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Delete clock data from disk at the given shard path.</div><div class="diff-removed">-    pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        let newest_clocks_path = Self::newest_clocks_path(shard_path);</div><div class="diff-removed">-        let oldest_clocks_path = Self::oldest_clocks_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        if newest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(newest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        if oldest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(oldest_clocks_path).await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn newest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(NEWEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn oldest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(OLDEST_CLOCKS_PATH)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+        filter: Option</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    