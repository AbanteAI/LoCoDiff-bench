<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - DeepSeek Chat v3.1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <h2>Model: DeepSeek Chat v3.1</h2>
        <p><a href="../../models/deepseek_deepseek-chat-v3.1.html">All DeepSeek Chat v3.1 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek Chat v3.1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Native Prompt Tokens:</strong> 82067</p>
                <p><strong>Native Completion Tokens:</strong> 7706</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> None</p>
                <p><strong>Cost:</strong> $0.0225782</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-chat-v3.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 2048a82a3..7a8cef447 100644</div><div class="diff-header">--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpk654qrhr_expected.txt	</div><div class="diff-header">+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmpee7tu0ox_actual.txt	</div><div class="diff-info">@@ -10,6 +10,7 @@</div><div> import type {</div><div>   Awaited,</div><div>   ReactContext,</div><div class="diff-added">+  ReactProviderType,</div><div>   StartTransitionOptions,</div><div>   Usable,</div><div>   Thenable,</div><div class="diff-info">@@ -78,10 +79,6 @@ function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div>       Dispatcher.useState(null);</div><div>       Dispatcher.useReducer((s: mixed, a: mixed) => s, null);</div><div>       Dispatcher.useRef(null);</div><div class="diff-removed">-      if (typeof Dispatcher.useCacheRefresh === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useCacheRefresh();</div><div class="diff-removed">-      }</div><div>       Dispatcher.useLayoutEffect(() => {});</div><div>       Dispatcher.useInsertionEffect(() => {});</div><div>       Dispatcher.useEffect(() => {});</div><div class="diff-info">@@ -239,9 +236,9 @@ function use<T>(usable: Usable<T>): T {</div><div> </div><div>       hookLog.push({</div><div>         displayName: context.displayName || 'Context',</div><div class="diff-removed">-        primitive: 'Context (use)',</div><div class="diff-added">+        primitive: 'Context (use',</div><div>         stackError: new Error(),</div><div class="diff-removed">-        value,</div><div class="diff-added">+        value: value,</div><div>         debugInfo: null,</div><div>         dispatcherHookName: 'Use',</div><div>       });</div><div class="diff-info">@@ -371,7 +368,7 @@ function useInsertionEffect(</div><div> </div><div> function useEffect(</div><div>   create: () => (() => void) | void,</div><div class="diff-removed">-  deps: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -449,6 +446,36 @@ function useMemo<T>(</div><div>   return value;</div><div> }</div><div> </div><div class="diff-added">+// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-added">+// it should not be called directly in user-generated code</div><div class="diff-added">+function useMemoCache(size: number): Array<mixed> {</div><div class="diff-added">+  const fiber = currentFiber;</div><div class="diff-added">+  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-added">+  if (fiber == null) {</div><div class="diff-added">+    return [];</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  const memoCache =</div><div class="diff-added">+    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-added">+    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-added">+  if (memoCache == null) {</div><div class="diff-added">+    return [];</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  let data = memoCache.data[memoCache.index];</div><div class="diff-added">+  if (data === undefined) {</div><div class="diff-added">+    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-added">+    for (let i = 0; i < size; i++) {</div><div class="diff-added">+      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-added">+    }</div><div class="diff-added">+  }</div><div class="diff-added">+</div><div class="diff-added">+  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-added">+</div><div class="diff-added">+  memoCache.index++;</div><div class="diff-added">+  return data;</div><div class="diff-added">+}</div><div class="diff-added">+</div><div> function useSyncExternalStore<T>(</div><div>   subscribe: (() => void) => () => void,</div><div>   getSnapshot: () => T,</div><div class="diff-info">@@ -522,36 +549,6 @@ function useId(): string {</div><div>   return id;</div><div> }</div><div> </div><div class="diff-removed">-// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-removed">-// it should not be called directly in user-generated code</div><div class="diff-removed">-function useMemoCache(size: number): Array<mixed> {</div><div class="diff-removed">-  const fiber = currentFiber;</div><div class="diff-removed">-  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-removed">-  if (fiber == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const memoCache =</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-removed">-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-removed">-  if (memoCache == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  let data = memoCache.data[memoCache.index];</div><div class="diff-removed">-  if (data === undefined) {</div><div class="diff-removed">-    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-removed">-    for (let i = 0; i < size; i++) {</div><div class="diff-removed">-      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div class="diff-removed">-  memoCache.index++;</div><div class="diff-removed">-  return data;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> function useOptimistic<S, A>(</div><div>   passthrough: S,</div><div>   reducer: ?(S, A) => S,</div><div class="diff-info">@@ -978,368 +975,4 @@ function parseHookName(functionName: void | string): string {</div><div> </div><div> function buildTree(</div><div>   rootStack: any,</div><div class="diff-removed">-  readHookLog: Array<HookLogEntry>,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const rootChildren: Array<HooksNode> = [];</div><div class="diff-removed">-  let prevStack = null;</div><div class="diff-removed">-  let levelChildren = rootChildren;</div><div class="diff-removed">-  let nativeHookID = 0;</div><div class="diff-removed">-  const stackOfChildren = [];</div><div class="diff-removed">-  for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-    const hook = readHookLog[i];</div><div class="diff-removed">-    const parseResult = parseTrimmedStack(rootStack, hook);</div><div class="diff-removed">-    const primitiveFrame = parseResult[0];</div><div class="diff-removed">-    const stack = parseResult[1];</div><div class="diff-removed">-    let displayName = hook.displayName;</div><div class="diff-removed">-    if (displayName === null && primitiveFrame !== null) {</div><div class="diff-removed">-      displayName =</div><div class="diff-removed">-        parseHookName(primitiveFrame.functionName) ||</div><div class="diff-removed">-        // Older versions of React do not have sourcemaps.</div><div class="diff-removed">-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div class="diff-removed">-        parseHookName(hook.dispatcherHookName);</div><div class="diff-removed">-    }</div><div class="diff-removed">-    if (stack !== null) {</div><div class="diff-removed">-      // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-removed">-      // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div class="diff-removed">-      let commonSteps = 0;</div><div class="diff-removed">-      if (prevStack !== null) {</div><div class="diff-removed">-        // Compare the current level's stack to the new stack.</div><div class="diff-removed">-        while (commonSteps < stack.length && commonSteps < prevStack.length) {</div><div class="diff-removed">-          const stackSource = stack[stack.length - commonSteps - 1].source;</div><div class="diff-removed">-          const prevSource =</div><div class="diff-removed">-            prevStack[prevStack.length - commonSteps - 1].source;</div><div class="diff-removed">-          if (stackSource !== prevSource) {</div><div class="diff-removed">-            break;</div><div class="diff-removed">-          }</div><div class="diff-removed">-          commonSteps++;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // Pop back the stack as many steps as were not common.</div><div class="diff-removed">-        for (let j = prevStack.length - 1; j > commonSteps; j--) {</div><div class="diff-removed">-          // $FlowFixMe[incompatible-type]</div><div class="diff-removed">-          levelChildren = stackOfChildren.pop();</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // The remaining part of the new stack are custom hooks. Push them</div><div class="diff-removed">-      // to the tree.</div><div class="diff-removed">-      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div class="diff-removed">-        const children: Array<HooksNode> = [];</div><div class="diff-removed">-        const stackFrame = stack[j];</div><div class="diff-removed">-        const levelChild: HooksNode = {</div><div class="diff-removed">-          id: null,</div><div class="diff-removed">-          isStateEditable: false,</div><div class="diff-removed">-          name: parseHookName(stack[j - 1].functionName),</div><div class="diff-removed">-          value: undefined,</div><div class="diff-removed">-          subHooks: children,</div><div class="diff-removed">-          debugInfo: null,</div><div class="diff-removed">-          hookSource: {</div><div class="diff-removed">-            lineNumber: stackFrame.lineNumber,</div><div class="diff-removed">-            columnNumber: stackFrame.columnNumber,</div><div class="diff-removed">-            functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div class="diff-removed">-          },</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        levelChildren.push(levelChild);</div><div class="diff-removed">-        stackOfChildren.push(levelChildren);</div><div class="diff-removed">-        levelChildren = children;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      prevStack = stack;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-removed">-    const id =</div><div class="diff-removed">-      primitive === 'Context' ||</div><div class="diff-removed">-      primitive === 'Context (use)' ||</div><div class="diff-removed">-      primitive === 'DebugValue' ||</div><div class="diff-removed">-      primitive === 'Promise' ||</div><div class="diff-removed">-      primitive === 'Unresolved' ||</div><div class="diff-removed">-      primitive === 'HostTransitionStatus'</div><div class="diff-removed">-        ? null</div><div class="diff-removed">-        : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-removed">-    const levelChild: HooksNode = {</div><div class="diff-removed">-      id,</div><div class="diff-removed">-      isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-removed">-      value: hook.value,</div><div class="diff-removed">-      subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-removed">-      hookSource: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    const hookSource: HookSource = {</div><div class="diff-removed">-      lineNumber: null,</div><div class="diff-removed">-      functionName: null,</div><div class="diff-removed">-      fileName: null,</div><div class="diff-removed">-      columnNumber: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChildren.push(levelChild);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-removed">-  processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div class="diff-removed">-  return rootChildren;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-removed">-function processDebugValues(</div><div class="diff-removed">-  hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-  for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-removed">-    const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-removed">-      hooksTree.splice(i, 1);</div><div class="diff-removed">-      i--;</div><div class="diff-removed">-      debugValueHooksNodes.push(hooksNode);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div class="diff-removed">-  if (parentHooksNode !== null) {</div><div class="diff-removed">-    if (debugValueHooksNodes.length === 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-removed">-    } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    error instanceof Error &&</div><div class="diff-removed">-    error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-  wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-removed">-  wrapperError.cause = error;</div><div class="diff-removed">-  throw wrapperError;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooks<Props>(</div><div class="diff-removed">-  renderFunction: Props => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-removed">-  let current: null | Fiber = fiber;</div><div class="diff-removed">-  while (current) {</div><div class="diff-removed">-    if (current.tag === ContextProvider) {</div><div class="diff-removed">-      let context: ReactContext<any> = current.type;</div><div class="diff-removed">-      if ((context: any)._context !== undefined) {</div><div class="diff-removed">-        // Support inspection of pre-19+ providers.</div><div class="diff-removed">-        context = (context: any)._context;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (!contextMap.has(context)) {</div><div class="diff-removed">-        // Store the current value that we're going to restore later.</div><div class="diff-removed">-        contextMap.set(context, context._currentValue);</div><div class="diff-removed">-        // Set the inner most provider value on the context.</div><div class="diff-removed">-        context._currentValue = current.memoizedProps.value;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    current = current.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {</div><div class="diff-removed">-  contextMap.forEach((value, context) => (context._currentValue = value));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-removed">-  renderFunction: (Props, Ref) => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  ref: Ref,</div><div class="diff-removed">-  currentDispatcher: CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props, ref);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function resolveDefaultProps(Component: any, baseProps: any) {</div><div class="diff-removed">-  if (Component && Component.defaultProps) {</div><div class="diff-removed">-    // Resolve default props. Taken from ReactElement</div><div class="diff-removed">-    const props = assign({}, baseProps);</div><div class="diff-removed">-    const defaultProps = Component.defaultProps;</div><div class="diff-removed">-    for (const propName in defaultProps) {</div><div class="diff-removed">-      if (props[propName] === undefined) {</div><div class="diff-removed">-        props[propName] = defaultProps[propName];</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    return props;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return baseProps;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooksOfFiber(</div><div class="diff-removed">-  fiber: Fiber,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    fiber.tag !== FunctionComponent &&</div><div class="diff-removed">-    fiber.tag !== SimpleMemoComponent &&</div><div class="diff-removed">-    fiber.tag !== ForwardRef</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unknown Fiber. Needs to be a function component to inspect hooks.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div class="diff-removed">-  getPrimitiveStackCache();</div><div class="diff-removed">-</div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div class="diff-removed">-  currentHook = (fiber.memoizedState: Hook);</div><div class="diff-removed">-  currentFiber = fiber;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`</div><div class="diff-removed">-    const dependencies = currentFiber.dependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {</div><div class="diff-removed">-    const contextDependencies = (currentFiber: any).contextDependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      contextDependencies !== null ? contextDependencies.first : null;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unsupported React version. This is a bug in React Debug Tools.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const type = fiber.type;</div><div class="diff-removed">-  let props = fiber.memoizedProps;</div><div class="diff-removed">-  if (type !== fiber.elementType) {</div><div class="diff-removed">-    props = resolveDefaultProps(type, props);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Only used for versions of React without memoized context value in context dependencies.</div><div class="diff-removed">-  const contextMap = new Map<ReactContext<any>, any>();</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      currentContextDependency !== null &&</div><div class="diff-removed">-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      setupContexts(contextMap, fiber);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (fiber.tag === ForwardRef) {</div><div class="diff-removed">-      return inspectHooksOfForwardRef(</div><div class="diff-removed">-        type.render,</div><div class="diff-removed">-        props,</div><div class="diff-removed">-        fiber.ref,</div><div class="diff-removed">-        currentDispatcher,</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return inspectHooks(type, props, currentDispatcher);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    currentFiber = null;</div><div class="diff-removed">-    currentHook = null;</div><div class="diff-removed">-    currentContextDependency = null;</div><div class="diff-removed">-</div><div class="diff-removed">-    restoreContexts(contextMap);</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+  readHookLog: Array<HookLogEntry>,</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    