<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: Grok 3 Mini</h2>
        <p><a href="../../models/x-ai_grok-3-mini-beta.html">All Grok 3 Mini Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 3 Mini</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 58629</p>
                <p><strong>Native Completion Tokens:</strong> 6602</p>
                <p><strong>Native Tokens Reasoning:</strong> 941</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0208897</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb3..a36537f8 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmpkz4nv7oi_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmph0bs3oeu_actual.txt	</div><div class="diff-info">@@ -21,18 +21,20 @@ use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div> use common::rate_limiting::RateLimiter;</div><div class="diff-added">+use common::types::TelemetryDetail;</div><div> use common::{panic, tar_ext};</div><div> use indicatif::{ProgressBar, ProgressStyle};</div><div> use itertools::Itertools;</div><div> use parking_lot::{Mutex as ParkingMutex, RwLock};</div><div class="diff-removed">-use segment::data_types::segment_manifest::SegmentManifests;</div><div class="diff-added">+use segment::data_types::segment_manifest::{SegmentManifests, VersionedSegmentManifest};</div><div class="diff-added">+use segment::data_types::vectors::VectorElementType;</div><div> use segment::entry::entry_point::SegmentEntry as _;</div><div> use segment::index::field_index::CardinalityEstimation;</div><div> use segment::segment::Segment;</div><div> use segment::segment_constructor::{build_segment, load_segment};</div><div> use segment::types::{</div><div class="diff-removed">-    Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, SegmentConfig, SegmentType,</div><div class="diff-removed">-    SnapshotFormat,</div><div class="diff-added">+    CompressionRatio, Filter, PayloadIndexInfo, PayloadKeyType, PointIdType, QuantizationConfig,</div><div class="diff-added">+    SegmentConfig, SegmentType, SnapshotFormat,</div><div> };</div><div> use tokio::fs::{create_dir_all, remove_dir_all, remove_file};</div><div> use tokio::runtime::Handle;</div><div class="diff-info">@@ -41,7 +43,6 @@ use tokio::sync::{Mutex, RwLock as TokioRwLock, mpsc, oneshot};</div><div> use wal::{Wal, WalOptions};</div><div> </div><div> use self::clock_map::{ClockMap, RecoveryPoint};</div><div class="diff-removed">-use self::disk_usage_watcher::DiskUsageWatcher;</div><div> use super::update_tracker::UpdateTracker;</div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_manager::collection_updater::CollectionUpdater;</div><div class="diff-info">@@ -52,17 +53,17 @@ use crate::collection_manager::optimizers::TrackerLog;</div><div> use crate::collection_manager::segments_searcher::SegmentsSearcher;</div><div> use crate::common::file_utils::{move_dir, move_file};</div><div> use crate::config::CollectionConfigInternal;</div><div class="diff-removed">-use crate::operations::OperationWithClockTag;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{</div><div class="diff-removed">-    CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div class="diff-removed">-    check_sparse_compatible_with_segment_config,</div><div class="diff-added">+    check_sparse_compatible_with_segment_config, CollectionError, CollectionResult,</div><div class="diff-added">+    OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div> };</div><div class="diff-removed">-use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};</div><div class="diff-added">+use crate::operations::OperationWithClockTag;</div><div class="diff-added">+use crate::optimizers_builder::{build_optimizers, clear_temp_segments, OptimizersConfig};</div><div> use crate::save_on_disk::SaveOnDisk;</div><div class="diff-removed">-use crate::shards::CollectionId;</div><div> use crate::shards::shard::ShardId;</div><div> use crate::shards::shard_config::ShardConfig;</div><div class="diff-added">+use crate::shards::CollectionId;</div><div> use crate::update_handler::{Optimizer, UpdateHandler, UpdateSignal};</div><div> use crate::wal::SerdeWal;</div><div> use crate::wal_delta::{LockedWal, RecoverableWal};</div><div class="diff-info">@@ -117,8 +118,8 @@ impl LocalShard {</div><div>         let segments_from = Self::segments_path(from);</div><div>         let segments_to = Self::segments_path(to);</div><div> </div><div class="diff-removed">-        move_dir(wal_from, wal_to).await?;</div><div class="diff-removed">-        move_dir(segments_from, segments_to).await?;</div><div class="diff-added">+        move_dir(&wal_from, &wal_to).await?;</div><div class="diff-added">+        move_dir(&segments_from, &segments_to).await?;</div><div> </div><div>         LocalShardClocks::move_data(from, to).await?;</div><div> </div><div class="diff-info">@@ -139,17 +140,16 @@ impl LocalShard {</div><div>         // Delete WAL</div><div>         let wal_path = Self::wal_path(shard_path);</div><div>         if wal_path.exists() {</div><div class="diff-removed">-            remove_dir_all(wal_path).await?;</div><div class="diff-added">+            remove_dir_all(&wal_path).await?;</div><div>         }</div><div> </div><div>         // Delete segments</div><div>         let segments_path = Self::segments_path(shard_path);</div><div>         if segments_path.exists() {</div><div class="diff-removed">-            remove_dir_all(segments_path).await?;</div><div class="diff-added">+            remove_dir_all(&segments_path).await?;</div><div>         }</div><div> </div><div>         LocalShardClocks::delete_data(shard_path).await?;</div><div class="diff-removed">-</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -173,16 +173,6 @@ impl LocalShard {</div><div>         let optimizers_log = Arc::new(ParkingMutex::new(Default::default()));</div><div>         let total_optimized_points = Arc::new(AtomicUsize::new(0));</div><div> </div><div class="diff-removed">-        // default to 2x the WAL capacity</div><div class="diff-removed">-        let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-removed">-</div><div class="diff-removed">-        let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div class="diff-removed">-            shard_path.to_owned(),</div><div class="diff-removed">-            disk_buffer_threshold_mb,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div>         let mut update_handler = UpdateHandler::new(</div><div>             shared_storage_config.clone(),</div><div>             payload_index_schema.clone(),</div><div class="diff-info">@@ -195,8 +185,9 @@ impl LocalShard {</div><div>             locked_wal.clone(),</div><div>             config.optimizer_config.flush_interval_sec,</div><div>             config.optimizer_config.max_optimization_threads,</div><div class="diff-removed">-            clocks.clone(),</div><div class="diff-removed">-            shard_path.into(),</div><div class="diff-added">+            clocks,</div><div class="diff-added">+            shard_path.to_path_buf(),</div><div class="diff-added">+            disk_usage_watcher,</div><div>         );</div><div> </div><div>         let (update_sender, update_receiver) =</div><div class="diff-info">@@ -205,15 +196,6 @@ impl LocalShard {</div><div> </div><div>         let update_tracker = segment_holder.read().update_tracker();</div><div> </div><div class="diff-removed">-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .read_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(ParkingMutex::new)</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div>         Self {</div><div>             segments: segment_holder,</div><div>             collection_config,</div><div class="diff-info">@@ -224,20 +206,16 @@ impl LocalShard {</div><div>             update_sender: ArcSwap::from_pointee(update_sender),</div><div>             update_tracker,</div><div>             path: shard_path.to_owned(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div>             optimizers,</div><div>             optimizers_log,</div><div>             total_optimized_points,</div><div class="diff-added">+            update_runtime,</div><div class="diff-added">+            search_runtime,</div><div>             disk_usage_watcher,</div><div>             read_rate_limiter,</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Recovers shard from disk.</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn load(</div><div class="diff-info">@@ -251,7 +229,7 @@ impl LocalShard {</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-added">+    ) -> CollectionResult<Self> {</div><div>         let collection_config_read = collection_config.read().await;</div><div> </div><div>         let wal_path = Self::wal_path(shard_path);</div><div class="diff-info">@@ -280,7 +258,7 @@ impl LocalShard {</div><div>             })?;</div><div> </div><div>         // Grab segment paths, filter out hidden entries and non-directories</div><div class="diff-removed">-        let segment_paths = segment_paths</div><div class="diff-added">+        let segment_paths_clean = segment_paths</div><div>             .into_iter()</div><div>             .filter(|entry| {</div><div>                 let is_hidden = entry</div><div class="diff-info">@@ -289,7 +267,7 @@ impl LocalShard {</div><div>                     .is_some_and(|s| s.starts_with('.'));</div><div>                 if is_hidden {</div><div>                     log::debug!(</div><div class="diff-removed">-                        "Segments path entry prefixed with a period, ignoring: {}",</div><div class="diff-added">+                        "Segments path entry prefixed with a period, rejecting: {}",</div><div>                         entry.path().display(),</div><div>                     );</div><div>                 }</div><div class="diff-info">@@ -299,7 +277,7 @@ impl LocalShard {</div><div>                 let is_dir = entry.path().is_dir();</div><div>                 if !is_dir {</div><div>                     log::warn!(</div><div class="diff-removed">-                        "Segments path entry is not a directory, skipping: {}",</div><div class="diff-added">+                        "Segments path entry is not a directory, rejecting: {}",</div><div>                         entry.path().display(),</div><div>                     );</div><div>                 }</div><div class="diff-info">@@ -307,13 +285,15 @@ impl LocalShard {</div><div>             })</div><div>             .map(|entry| entry.path());</div><div> </div><div class="diff-added">+        let mut segment_holder = SegmentHolder::default();</div><div class="diff-added">+</div><div>         let mut load_handlers = vec![];</div><div> </div><div>         // This semaphore is used to limit the number of threads that load segments concurrently.</div><div>         // Uncomment it if you need to debug segment loading.</div><div>         // let semaphore = Arc::new(parking_lot::Mutex::new(()));</div><div> </div><div class="diff-removed">-        for segment_path in segment_paths {</div><div class="diff-added">+        for segment_path in segment_paths_clean {</div><div>             let payload_index_schema = payload_index_schema.clone();</div><div>             // let semaphore_clone = semaphore.clone();</div><div>             load_handlers.push(</div><div class="diff-info">@@ -340,8 +320,6 @@ impl LocalShard {</div><div>             );</div><div>         }</div><div> </div><div class="diff-removed">-        let mut segment_holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div>         for handler in load_handlers {</div><div>             let segment = handler.join().map_err(|err| {</div><div>                 CollectionError::service_error(format!(</div><div class="diff-info">@@ -371,27 +349,9 @@ impl LocalShard {</div><div>                 })</div><div>                 .unwrap_or(Ok(()))?;</div><div> </div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let res = segment_holder.deduplicate_points().await?;</div><div class="diff-removed">-        if res > 0 {</div><div class="diff-removed">-            log::debug!("Deduplicated {res} points");</div><div class="diff-added">+            segment_holder.add_new(segment); // We don't want to generate a new ID</div><div>         }</div><div> </div><div class="diff-removed">-        clear_temp_segments(shard_path);</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &collection_config_read.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &collection_config_read.hnsw_config,</div><div class="diff-removed">-            &collection_config_read.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(collection_config_read); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let clocks = LocalShardClocks::load(shard_path)?;</div><div class="diff-removed">-</div><div>         // Always make sure we have any appendable segments, needed for update operations</div><div>         if !segment_holder.has_appendable_segment() {</div><div>             debug_assert!(</div><div class="diff-info">@@ -450,13 +410,13 @@ impl LocalShard {</div><div>         collection_id: CollectionId,</div><div>         shard_path: &Path,</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div>         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-added">+    ) -> CollectionResult<Self> {</div><div>         // initialize local shard config file</div><div>         let local_shard_config = ShardConfig::new_replica_set();</div><div>         let shard = Self::build(</div><div class="diff-info">@@ -464,12 +424,12 @@ impl LocalShard {</div><div>             collection_id,</div><div>             shard_path,</div><div>             collection_config,</div><div class="diff-added">+            effective_optimizers_config,</div><div>             shared_storage_config,</div><div>             payload_index_schema,</div><div>             update_runtime,</div><div>             search_runtime,</div><div>             optimizer_resource_budget,</div><div class="diff-removed">-            effective_optimizers_config,</div><div>         )</div><div>         .await?;</div><div>         local_shard_config.save(shard_path)?;</div><div class="diff-info">@@ -477,26 +437,26 @@ impl LocalShard {</div><div>     }</div><div> </div><div>     /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div>     pub async fn build(</div><div>         id: ShardId,</div><div>         collection_id: CollectionId,</div><div>         shard_path: &Path,</div><div>         collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div>         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>         update_runtime: Handle,</div><div>         search_runtime: Handle,</div><div>         optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-added">+    ) -> CollectionResult<Self> {</div><div>         let config = collection_config.read().await;</div><div> </div><div>         let wal_path = Self::wal_path(shard_path);</div><div> </div><div>         create_dir_all(&wal_path).await.map_err(|err| {</div><div>             CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard wal directory. Error: {err}"</div><div class="diff-added">+                "Can't create shard WAL directory {}. Error: {err}",</div><div class="diff-added">+                wal_path.display(),</div><div>             ))</div><div>         })?;</div><div> </div><div class="diff-info">@@ -504,16 +464,17 @@ impl LocalShard {</div><div> </div><div>         create_dir_all(&segments_path).await.map_err(|err| {</div><div>             CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard segments directory. Error: {err}"</div><div class="diff-added">+                "Can't create shard segments directory {}. Error: {err}",</div><div class="diff-added">+                segments_path.display(),</div><div>             ))</div><div>         })?;</div><div> </div><div>         let mut segment_holder = SegmentHolder::default();</div><div>         let mut build_handlers = vec![];</div><div> </div><div class="diff-removed">-        let vector_params = config.params.to_base_vector_data()?;</div><div class="diff-removed">-        let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div class="diff-removed">-        let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-added">+        let vector_params = config.params.vectors.clone();</div><div class="diff-added">+        let sparse_vector_params = config.params.sparse_vectors.clone();</div><div class="diff-added">+        let segment_number = effective_optimizers_config.get_number_segments();</div><div> </div><div>         for _sid in 0..segment_number {</div><div>             let path_clone = segments_path.clone();</div><div class="diff-info">@@ -522,28 +483,22 @@ impl LocalShard {</div><div>                 sparse_vector_data: sparse_vector_params.clone(),</div><div>                 payload_storage_type: config.params.payload_storage_type(),</div><div>             };</div><div class="diff-added">+            let payload_index_schema = payload_index_schema.clone();</div><div>             let segment = thread::Builder::new()</div><div>                 .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-added">+                .spawn(move || build_segment(&path_clone, &segment_config, &payload_index_schema))</div><div>                 .unwrap();</div><div>             build_handlers.push(segment);</div><div>         }</div><div> </div><div class="diff-removed">-        let join_results = build_handlers</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|handler| handler.join())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for join_result in join_results {</div><div class="diff-added">+        for join_result in build_handlers.into_iter().map(|handler| handler.join()) {</div><div>             let segment = join_result.map_err(|err| {</div><div class="diff-removed">-                let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-added">+                let message = panic::downcast_str(&*err).unwrap_or("");</div><div>                 let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-removed">-</div><div>                 CollectionError::service_error(format!(</div><div>                     "Segment DB create panicked{separator}{message}",</div><div>                 ))</div><div>             })??;</div><div class="diff-removed">-</div><div>             segment_holder.add_new(segment);</div><div>         }</div><div> </div><div class="diff-info">@@ -558,9 +513,7 @@ impl LocalShard {</div><div>             &config.quantization_config,</div><div>         );</div><div> </div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection = LocalShard::new(</div><div class="diff-added">+        let local_shard = LocalShard::new(</div><div>             segment_holder,</div><div>             collection_config,</div><div>             shared_storage_config,</div><div class="diff-info">@@ -575,178 +528,7 @@ impl LocalShard {</div><div>         )</div><div>         .await;</div><div> </div><div class="diff-removed">-        Ok(collection)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn stop_flush_worker(&self) {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.stop_flush_worker()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.wait_workers_stops().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Loads latest collection operations from WAL</div><div class="diff-removed">-    pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-removed">-        let wal = self.wal.wal.lock().await;</div><div class="diff-removed">-        let bar = ProgressBar::new(wal.len(false));</div><div class="diff-removed">-</div><div class="diff-removed">-        let progress_style = ProgressStyle::default_bar()</div><div class="diff-removed">-            .template("{msg} [{elapsed_precise}] {wide_bar} {pos}/{len} (eta:{eta})")</div><div class="diff-removed">-            .expect("Failed to create progress style");</div><div class="diff-removed">-        bar.set_style(progress_style);</div><div class="diff-removed">-</div><div class="diff-removed">-        log::debug!(</div><div class="diff-removed">-            "Recovering shard {} starting reading WAL from {}",</div><div class="diff-removed">-            self.path.display(),</div><div class="diff-removed">-            wal.first_index(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.set_message(format!("Recovering collection {collection_id}"));</div><div class="diff-removed">-        let segments = self.segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Fall back to basic text output if the progress bar is hidden (e.g. not a tty)</div><div class="diff-removed">-        let show_progress_bar = !bar.is_hidden();</div><div class="diff-removed">-        let mut last_progress_report = Instant::now();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovering shard {}: 0/{} (0%)",</div><div class="diff-removed">-                self.path.display(),</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div class="diff-removed">-        // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div class="diff-removed">-        // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div class="diff-removed">-        // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div class="diff-removed">-        // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div class="diff-removed">-        // index *occasionally*), but the storage can handle it.</div><div class="diff-removed">-</div><div class="diff-removed">-        for (op_num, update) in wal.read_all(false) {</div><div class="diff-removed">-            if let Some(clock_tag) = update.clock_tag {</div><div class="diff-removed">-                newest_clocks.advance_clock(clock_tag);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate `CollectionError::ServiceError`, but skip other error types.</div><div class="diff-removed">-            match &CollectionUpdater::update(</div><div class="diff-removed">-                segments,</div><div class="diff-removed">-                op_num,</div><div class="diff-removed">-                update.operation,</div><div class="diff-removed">-                &HardwareCounterCell::disposable(), // Internal operation, no measurement needed.</div><div class="diff-removed">-            ) {</div><div class="diff-removed">-                Err(err @ CollectionError::ServiceError { error, backtrace }) => {</div><div class="diff-removed">-                    let path = self.path.display();</div><div class="diff-removed">-</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Can't apply WAL operation: {error}, \</div><div class="diff-removed">-                         collection: {collection_id}, \</div><div class="diff-removed">-                         shard: {path}, \</div><div class="diff-removed">-                         op_num: {op_num}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-</div><div class="diff-removed">-                    if let Some(backtrace) = &backtrace {</div><div class="diff-removed">-                        log::error!("Backtrace: {backtrace}");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::OutOfMemory { .. }) => {</div><div class="diff-removed">-                    log::error!("{err}");</div><div class="diff-removed">-                    return Err(err.clone());</div><div class="diff-removed">-                }</div><div class="diff-removed">-                Err(err @ CollectionError::NotFound { .. }) => log::warn!("{err}"),</div><div class="diff-removed">-                Err(err) => log::error!("{err}"),</div><div class="diff-removed">-                Ok(_) => (),</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Update progress bar or show text progress every WAL_LOAD_REPORT_EVERY</div><div class="diff-removed">-            bar.inc(1);</div><div class="diff-removed">-            if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div class="diff-removed">-                let progress = bar.position();</div><div class="diff-removed">-                log::info!(</div><div class="diff-removed">-                    "{progress}/{} ({}%)",</div><div class="diff-removed">-                    wal.len(false),</div><div class="diff-removed">-                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                last_progress_report = Instant::now();</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments.read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // It is possible, that after recovery, if WAL flush was not enforced.</div><div class="diff-removed">-            // We could be left with some un-versioned points.</div><div class="diff-removed">-            // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                match segment {</div><div class="diff-removed">-                    LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                        raw_segment.write().cleanup_versions()?;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                        debug_assert!(false, "Proxy segment found in load_from_wal");</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Force a flush after re-applying WAL operations, to ensure we maintain on-disk data</div><div class="diff-removed">-            // consistency, if we happened to only apply *past* operations to a segment with newer</div><div class="diff-removed">-            // version.</div><div class="diff-removed">-            segments.flush_all(true, true)?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        bar.finish();</div><div class="diff-removed">-        if !show_progress_bar {</div><div class="diff-removed">-            log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-removed">-                wal.len(false),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-added">+        Ok(local_shard)</div><div>     }</div><div> </div><div>     pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-info">@@ -772,14 +554,11 @@ impl LocalShard {</div><div>         update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div>         update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div>         update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div>         self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div> </div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div>     pub async fn on_strict_mode_config_update(&mut self) {</div><div>         let config = self.collection_config.read().await;</div><div> </div><div class="diff-info">@@ -819,162 +598,6 @@ impl LocalShard {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div class="diff-removed">-        // Read dir first as the directory contents would change during restore</div><div class="diff-removed">-        let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Filter out hidden entries</div><div class="diff-removed">-        let entries = entries.into_iter().filter(|entry| {</div><div class="diff-removed">-            let is_hidden = entry</div><div class="diff-removed">-                .file_name()</div><div class="diff-removed">-                .to_str()</div><div class="diff-removed">-                .is_some_and(|s| s.starts_with('.'));</div><div class="diff-removed">-            if is_hidden {</div><div class="diff-removed">-                log::debug!(</div><div class="diff-removed">-                    "Ignoring hidden segment in local shard during snapshot recovery: {}",</div><div class="diff-removed">-                    entry.path().display(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-            !is_hidden</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        for entry in entries {</div><div class="diff-removed">-            Segment::restore_snapshot_in_place(&entry.path())?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create snapshot for local shard into `target_path`</div><div class="diff-removed">-    pub async fn create_snapshot(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-        format: SnapshotFormat,</div><div class="diff-removed">-        save_wal: bool,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        let wal = self.wal.wal.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if !save_wal {</div><div class="diff-removed">-            // If we are not saving WAL, we still need to make sure that all submitted by this point</div><div class="diff-removed">-            // updates have made it to the segments. So we use the Plunger to achieve that.</div><div class="diff-removed">-            // It will notify us when all submitted updates so far have been processed.</div><div class="diff-removed">-            let (tx, rx) = oneshot::channel();</div><div class="diff-removed">-            let plunger = UpdateSignal::Plunger(tx);</div><div class="diff-removed">-            self.update_sender.load().send(plunger).await?;</div><div class="diff-removed">-            rx.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(&self.path);</div><div class="diff-removed">-        let collection_params = self.collection_config.read().await.params.clone();</div><div class="diff-removed">-        let temp_path = temp_path.to_owned();</div><div class="diff-removed">-        let payload_index_schema = self.payload_index_schema.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar_c = tar.clone();</div><div class="diff-removed">-        tokio::task::spawn_blocking(move || {</div><div class="diff-removed">-            // Do not change segments while snapshotting</div><div class="diff-removed">-            SegmentHolder::snapshot_all_segments(</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                &segments_path,</div><div class="diff-removed">-                Some(&collection_params),</div><div class="diff-removed">-                &payload_index_schema.read().clone(),</div><div class="diff-removed">-                &temp_path,</div><div class="diff-removed">-                &tar_c.descend(Path::new(SEGMENTS_PATH))?,</div><div class="diff-removed">-                format,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if save_wal {</div><div class="diff-removed">-                // snapshot all shard's WAL</div><div class="diff-removed">-                Self::snapshot_wal(wal, &tar_c)</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                Self::snapshot_empty_wal(wal, &temp_path, &tar_c)</div><div class="diff-removed">-            }</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .await??;</div><div class="diff-removed">-</div><div class="diff-removed">-        LocalShardClocks::archive_data(&self.path, tar).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Create empty WAL which is compatible with currently stored data</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_empty_wal(</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        temp_path: &Path,</div><div class="diff-removed">-        tar: &tar_ext::BuilderExt,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let (segment_capacity, latest_op_num) = {</div><div class="diff-removed">-            let wal_guard = wal.blocking_lock();</div><div class="diff-removed">-            (wal_guard.segment_capacity(), wal_guard.last_index())</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let temp_dir = tempfile::tempdir_in(temp_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can not create temporary directory for WAL: {err}",</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Wal::generate_empty_wal_starting_at_index(</div><div class="diff-removed">-            temp_dir.path(),</div><div class="diff-removed">-            &WalOptions {</div><div class="diff-removed">-                segment_capacity,</div><div class="diff-removed">-                segment_queue_len: 0,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            latest_op_num,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Error while create empty WAL: {err}"))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-            })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// snapshot WAL</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Panics</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function panics if called within an asynchronous execution context.</div><div class="diff-removed">-    pub fn snapshot_wal(wal: LockedWal, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div class="diff-removed">-        // lock wal during snapshot</div><div class="diff-removed">-        let mut wal_guard = wal.blocking_lock();</div><div class="diff-removed">-        wal_guard.flush()?;</div><div class="diff-removed">-        let source_wal_path = wal_guard.path();</div><div class="diff-removed">-</div><div class="diff-removed">-        let tar = tar.descend(Path::new(WAL_PATH))?;</div><div class="diff-removed">-        for entry in std::fs::read_dir(source_wal_path).map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-        })? {</div><div class="diff-removed">-            let entry = entry.map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Can't read WAL directory: {err}",))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-</div><div class="diff-removed">-            if entry.file_name() == ".wal" {</div><div class="diff-removed">-                // This sentinel file is used for WAL locking. Trying to archive</div><div class="diff-removed">-                // or open it will cause the following error on Windows:</div><div class="diff-removed">-                // > The process cannot access the file because another process</div><div class="diff-removed">-                // > has locked a portion of the file. (os error 33)</div><div class="diff-removed">-                // https://github.com/qdrant/wal/blob/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual)::new(&entry.file_name()))</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn segment_manifests(&self) -> CollectionResult<SegmentManifests> {</div><div>         self.segments()</div><div>             .read()</div><div class="diff-info">@@ -982,147 +605,6 @@ impl LocalShard {</div><div>             .map_err(CollectionError::from)</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn estimate_cardinality<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CollectionResult<CardinalityEstimation> {</div><div class="diff-removed">-        let segments = self.segments().read();</div><div class="diff-removed">-        let cardinality = segments</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_id, segment)| {</div><div class="diff-removed">-                segment</div><div class="diff-removed">-                    .get()</div><div class="diff-removed">-                    .read()</div><div class="diff-removed">-                    .estimate_point_count(filter, hw_counter)</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .fold(CardinalityEstimation::exact(0), |acc, x| {</div><div class="diff-removed">-                CardinalityEstimation {</div><div class="diff-removed">-                    primary_clauses: vec![],</div><div class="diff-removed">-                    min: acc.min + x.min,</div><div class="diff-removed">-                    exp: acc.exp + x.exp,</div><div class="diff-removed">-                    max: acc.max + x.max,</div><div class="diff-removed">-                }</div><div class="diff-removed">-            });</div><div class="diff-removed">-        Ok(cardinality)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn read_filtered<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: Option<&'a Filter>,</div><div class="diff-removed">-        runtime_handle: &Handle,</div><div class="diff-removed">-        hw_counter: HwMeasurementAcc,</div><div class="diff-removed">-    ) -> CollectionResult<BTreeSet<PointIdType>> {</div><div class="diff-removed">-        let segments = self.segments.clone();</div><div class="diff-removed">-        SegmentsSearcher::read_filtered(segments, filter, runtime_handle, hw_counter).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_status(&self) -> (ShardStatus, OptimizersStatus) {</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Red status on failed operation or optimizer error</div><div class="diff-removed">-            if !segments.failed_operation.is_empty() || segments.optimizer_errors.is_some() {</div><div class="diff-removed">-                let optimizer_status = segments</div><div class="diff-removed">-                    .optimizer_errors</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .map_or(OptimizersStatus::Ok, |err| {</div><div class="diff-removed">-                        OptimizersStatus::Error(err.to_string())</div><div class="diff-removed">-                    });</div><div class="diff-removed">-                return (ShardStatus::Red, optimizer_status);</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Yellow status if we have a special segment, indicates a proxy segment used during optimization</div><div class="diff-removed">-            // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div class="diff-removed">-            let has_special_segment = segments</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-removed">-                .any(|segment_type| segment_type == SegmentType::Special);</div><div class="diff-removed">-            if has_special_segment {</div><div class="diff-removed">-                return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Yellow or grey status if there are pending optimizations</div><div class="diff-removed">-        // Grey if optimizers were not triggered yet after restart,</div><div class="diff-removed">-        // we don't automatically trigger them to prevent a crash loop</div><div class="diff-removed">-        let (has_triggered_any_optimizers, has_suboptimal_optimizers) = self</div><div class="diff-removed">-            .update_handler</div><div class="diff-removed">-            .lock()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .check_optimizer_conditions();</div><div class="diff-removed">-        if has_suboptimal_optimizers {</div><div class="diff-removed">-            let status = if has_triggered_any_optimizers {</div><div class="diff-removed">-                ShardStatus::Yellow</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                ShardStatus::Grey</div><div class="diff-removed">-            };</div><div class="diff-removed">-            return (status, OptimizersStatus::Ok);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Green status because everything is fine</div><div class="diff-removed">-        (ShardStatus::Green, OptimizersStatus::Ok)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn local_shard_info(&self) -> ShardInfoInternal {</div><div class="diff-removed">-        let collection_config = self.collection_config.read().await.clone();</div><div class="diff-removed">-        let mut vectors_count = 0;</div><div class="diff-removed">-        let mut indexed_vectors_count = 0;</div><div class="diff-removed">-        let mut points_count = 0;</div><div class="diff-removed">-        let mut segments_count = 0;</div><div class="diff-removed">-        let mut schema: HashMap<PayloadKeyType, PayloadIndexInfo> = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-                segments_count += 1;</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_info = segment.get().read().info();</div><div class="diff-removed">-</div><div class="diff-removed">-                vectors_count += segment_info.num_vectors;</div><div class="diff-removed">-                indexed_vectors_count += segment_info.num_indexed_vectors;</div><div class="diff-removed">-                points_count += segment_info.num_points;</div><div class="diff-removed">-                for (key, val) in segment_info.index_schema {</div><div class="diff-removed">-                    schema</div><div class="diff-removed">-                        .entry(key)</div><div class="diff-removed">-                        .and_modify(|entry| entry.points += val.points)</div><div class="diff-removed">-                        .or_insert(val);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let (status, optimizer_status) = self.local_shard_status().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        ShardInfoInternal {</div><div class="diff-removed">-            status,</div><div class="diff-removed">-            optimizer_status,</div><div class="diff-removed">-            vectors_count,</div><div class="diff-removed">-            indexed_vectors_count,</div><div class="diff-removed">-            points_count,</div><div class="diff-removed">-            segments_count,</div><div class="diff-removed">-            config: collection_config,</div><div class="diff-removed">-            payload_schema: schema,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-removed">-    pub async fn recovery_point(&self) -> RecoveryPoint {</div><div class="diff-removed">-        self.wal.recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Update the cutoff point on the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-removed">-    pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div class="diff-removed">-        self.wal.update_cutoff(cutoff).await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Check if the read rate limiter allows the operation to proceed</div><div>     /// - hw_measurement_acc: the current hardware measurement accumulator</div><div>     /// - context: the context of the operation to add on the error message</div><div class="diff-info">@@ -1156,26 +638,15 @@ impl LocalShard {</div><div>     }</div><div> }</div><div> </div><div class="diff-removed">-impl Drop for LocalShard {</div><div class="diff-removed">-    fn drop(&mut self) {</div><div class="diff-removed">-        thread::scope(|s| {</div><div class="diff-removed">-            let handle = thread::Builder::new()</div><div class="diff-removed">-                .name("drop-shard".to_string())</div><div class="diff-removed">-                .spawn_scoped(s, || {</div><div class="diff-removed">-                    // Needs dedicated thread to avoid `Cannot start a runtime from within a runtime` error.</div><div class="diff-removed">-                    self.update_runtime</div><div class="diff-removed">-                        .block_on(async { self.stop_gracefully().await })</div><div class="diff-removed">-                });</div><div class="diff-removed">-            handle.expect("Failed to create thread for shard drop");</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+const NEWEST_CLOCKS_PATH: &str = "newest_clocks.json";</div><div class="diff-added">+</div><div class="diff-added">+const OLDEST_CLOCKS_PATH: &str = "oldest_clocks.json";</div><div> </div><div> /// Convenience struct for combining clock maps belonging to a shard</div><div> ///</div><div> /// Holds a clock map for tracking the highest clocks and the cutoff clocks.</div><div> #[derive(Clone, Debug, Default)]</div><div class="diff-removed">-pub struct LocalShardClocks {</div><div class="diff-added">+pub(crate) struct LocalShardClocks {</div><div>     newest_clocks: Arc<Mutex<ClockMap>>,</div><div>     oldest_clocks: Arc<Mutex<ClockMap>>,</div><div> }</div><div class="diff-info">@@ -1183,12 +654,11 @@ pub struct LocalShardClocks {</div><div> impl LocalShardClocks {</div><div>     fn new(newest_clocks: ClockMap, oldest_clocks: ClockMap) -> Self {</div><div>         Self {</div><div class="diff-removed">-            newest_clocks: Arc::new(Mutex::new(newest_clocks)),</div><div class="diff-added">+            newest_clocks: Arc::new(vertex),</div><div>             oldest_clocks: Arc::new(Mutex::new(oldest_clocks)),</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    // Load clock maps from disk</div><div>     pub fn load(shard_path: &Path) -> CollectionResult<Self> {</div><div>         let newest_clocks = ClockMap::load_or_default(&Self::newest_clocks_path(shard_path))?;</div><div> </div><div class="diff-info">@@ -1197,7 +667,6 @@ impl LocalShardClocks {</div><div>         Ok(Self::new(newest_clocks, oldest_clocks))</div><div>     }</div><div> </div><div class="diff-removed">-    /// Persist clock maps to disk</div><div>     pub async fn store_if_changed(&self, shard_path: &Path) -> CollectionResult<()> {</div><div>         self.oldest_clocks</div><div>             .lock()</div><div class="diff-info">@@ -1212,7 +681,6 @@ impl LocalShardClocks {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Put clock data from the disk into an archive.</div><div>     pub async fn archive_data(from: &Path, tar: &tar_ext::BuilderExt) -> CollectionResult<()> {</div><div>         let newest_clocks_from = Self::newest_clocks_path(from);</div><div>         let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div class="diff-info">@@ -1230,42 +698,40 @@ impl LocalShardClocks {</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Move clock data on disk from one shard path to another.</div><div>     pub async fn move_data(from: &Path, to: &Path) -> CollectionResult<()> {</div><div>         let newest_clocks_from = Self::newest_clocks_path(from);</div><div>         let oldest_clocks_from = Self::oldest_clocks_path(from);</div><div> </div><div>         if newest_clocks_from.exists() {</div><div>             let newest_clocks_to = Self::newest_clocks_path(to);</div><div class="diff-removed">-            move_file(newest_clocks_from, newest_clocks_to).await?;</div><div class="diff-added">+            move_file(&newest_clocks_from, &newest_clocks_to).await?;</div><div>         }</div><div> </div><div>         if oldest_clocks_from.exists() {</div><div>             let oldest_clocks_to = Self::oldest_clocks_path(to);</div><div class="diff-removed">-            move_file(oldest_clocks_from, oldest_clocks_to).await?;</div><div class="diff-added">+            move_file(&oldest_clocks_from, &oldest_clocks_to).await?;</div><div>         }</div><div> </div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Delete clock data from disk at the given shard path.</div><div>     pub async fn delete_data(shard_path: &Path) -> CollectionResult<()> {</div><div>         let newest_clocks_path = Self::newest_clocks_path(shard_path);</div><div>         let oldest_clocks_path = Self::oldest_clocks_path(shard_path);</div><div> </div><div>         if newest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(newest_clocks_path).await?;</div><div class="diff-added">+            remove_file(&newest_clocks_path).await?;</div><div>         }</div><div> </div><div>         if oldest_clocks_path.exists() {</div><div class="diff-removed">-            remove_file(oldest_clocks_path).await?;</div><div class="diff-added">+            remove_file(&oldest_clocks_path).await?;</div><div>         }</div><div> </div><div>         Ok(())</div><div>     }</div><div> </div><div>     fn newest_clocks_path(shard_path: &Path) -> PathBuf {</div><div class="diff-removed">-        shard_path.join(NEWEST_CLOCKS_PATH)</div><div class="diff-added">+        shard_path.join(NEWESH_CLOCKS_PATH)</div><div>     }</div><div> </div><div>     fn oldest_clocks_path(shard_path: &Path) -> PathBuf {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    