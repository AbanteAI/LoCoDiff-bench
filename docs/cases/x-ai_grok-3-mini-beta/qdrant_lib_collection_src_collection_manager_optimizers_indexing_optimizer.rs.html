<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs</h1>
        <p><a href="../../models/x-ai_grok-3-mini-beta.html">‚Üê Back to Grok 3 Mini Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 3 Mini</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58760</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 57098</p>
                <p><strong>Native Completion Tokens:</strong> 2671</p>
                <p><strong>Native Tokens Reasoning:</strong> 712</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0184649</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 237415b4..e2b51a78 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected):tmp/tmp6d3evjjd_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual):tmp/tmpy8yo8f2x_actual.txt	</div><div class="diff-info">@@ -29,7 +29,7 @@ pub struct IndexingOptimizer {</div><div>     collection_params: CollectionParams,</div><div>     hnsw_config: HnswConfig,</div><div>     quantization_config: Option<QuantizationConfig>,</div><div class="diff-removed">-    telemetry_durations_aggregator: Arc<Mutex<OperationDurationsAggregator>>,</div><div class="diff-added">+    telemetry_durations_aggregator: Mutex<OperationDurationsAggregator>,</div><div> }</div><div> </div><div> impl IndexingOptimizer {</div><div class="diff-info">@@ -60,33 +60,32 @@ impl IndexingOptimizer {</div><div>     ) -> Option<(SegmentId, usize)> {</div><div>         segments</div><div>             .iter()</div><div class="diff-removed">-            // Excluded externally, might already be scheduled for optimization</div><div>             .filter(|(idx, _)| !excluded_ids.contains(idx))</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div>                 let read_segment = segment_entry.read();</div><div>                 let vector_size = read_segment</div><div>                     .max_available_vectors_size_in_bytes()</div><div class="diff-removed">-                    .unwrap_or_default();</div><div class="diff-removed">-</div><div class="diff-added">+                    .unwrap_or(0);</div><div class="diff-added">+    </div><div>                 if read_segment.segment_type() == SegmentType::Special {</div><div>                     return None; // Never optimize already optimized segment</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                 let segment_config = read_segment.config();</div><div>                 let is_any_vector_indexed = segment_config.is_any_vector_indexed();</div><div>                 let is_any_on_disk = segment_config.is_any_on_disk();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                 if !(is_any_vector_indexed || is_any_on_disk) {</div><div>                     return None;</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                 Some((idx, vector_size))</div><div>             })</div><div class="diff-removed">-            .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes)</div><div class="diff-removed">-            .map(|(idx, size)| (*idx, size))</div><div class="diff-added">+            .min_by_key(|(_, vector_size)| *vector_size)</div><div class="diff-added">+            .map(|(idx, size)| (idx, size))</div><div>     }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>     fn worst_segment(</div><div>         &self,</div><div>         segments: LockedSegmentHolder,</div><div class="diff-info">@@ -95,21 +94,18 @@ impl IndexingOptimizer {</div><div>         let segments_read_guard = segments.read();</div><div>         let candidates: Vec<_> = segments_read_guard</div><div>             .iter()</div><div class="diff-removed">-            // Excluded externally, might already be scheduled for optimization</div><div>             .filter(|(idx, _)| !excluded_ids.contains(idx))</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div>                 let read_segment = segment_entry.read();</div><div class="diff-removed">-                let max_vector_size_bytes = read_segment</div><div class="diff-removed">-                    .max_available_vectors_size_in_bytes()</div><div class="diff-removed">-                    .unwrap_or_default();</div><div class="diff-removed">-</div><div class="diff-removed">-                let segment_config = read_segment.config();</div><div class="diff-removed">-</div><div class="diff-added">+                let vector_size = read_segment.max_available_vectors_size_in_bytes().unwrap_or(0);</div><div class="diff-added">+    </div><div>                 if read_segment.segment_type() == SegmentType::Special {</div><div>                     return None; // Never optimize already optimized segment</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div class="diff-added">+                let segment_config = read_segment.config();</div><div class="diff-added">+    </div><div>                 let indexing_threshold_bytes = self</div><div>                     .thresholds_config</div><div>                     .indexing_threshold_kb</div><div class="diff-info">@@ -119,7 +115,7 @@ impl IndexingOptimizer {</div><div>                     .memmap_threshold_kb</div><div>                     .saturating_mul(BYTES_IN_KB);</div><div>                 let mut require_optimization = false;</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                 for (vector_name, vector_config) in self.collection_params.vectors.params_iter() {</div><div>                     if let Some(vector_data) = segment_config.vector_data.get(vector_name) {</div><div>                         let is_indexed = vector_data.index.is_indexed();</div><div class="diff-info">@@ -127,10 +123,10 @@ impl IndexingOptimizer {</div><div>                         let storage_size_bytes = read_segment</div><div>                             .available_vectors_size_in_bytes(vector_name)</div><div>                             .unwrap_or_default();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                         let is_big_for_index = storage_size_bytes >= indexing_threshold_bytes;</div><div>                         let is_big_for_mmap = storage_size_bytes >= mmap_threshold_bytes;</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                         let optimize_for_index = is_big_for_index && !is_indexed;</div><div>                         let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk</div><div>                         {</div><div class="diff-info">@@ -138,14 +134,14 @@ impl IndexingOptimizer {</div><div>                         } else {</div><div>                             is_big_for_mmap && !is_on_disk</div><div>                         };</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                         if optimize_for_index || optimize_for_mmap {</div><div>                             require_optimization = true;</div><div>                             break;</div><div>                         }</div><div>                     }</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                 if !require_optimization {</div><div>                     if let Some(sparse_vectors_params) =</div><div>                         self.collection_params.sparse_vectors.as_ref()</div><div class="diff-info">@@ -156,17 +152,15 @@ impl IndexingOptimizer {</div><div>                             {</div><div>                                 let is_index_immutable =</div><div>                                     sparse_vector_data.index.index_type.is_immutable();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                                 let storage_size = read_segment</div><div>                                     .available_vectors_size_in_bytes(sparse_vector_name)</div><div>                                     .unwrap_or_default();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>                                 let is_big_for_index = storage_size >= indexing_threshold_bytes;</div><div>                                 let is_big_for_mmap = storage_size >= mmap_threshold_bytes;</div><div class="diff-removed">-</div><div class="diff-removed">-                                let is_big = is_big_for_index || is_big_for_mmap;</div><div class="diff-removed">-</div><div class="diff-removed">-                                if is_big && !is_index_immutable {</div><div class="diff-added">+    </div><div class="diff-added">+                                if is_big_for_index && !is_index_immutable {</div><div>                                     require_optimization = true;</div><div>                                     break;</div><div>                                 }</div><div class="diff-info">@@ -174,37 +168,37 @@ impl IndexingOptimizer {</div><div>                         }</div><div>                     }</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-removed">-                require_optimization.then_some((*idx, max_vector_size_bytes))</div><div class="diff-added">+    </div><div class="diff-added">+                require_optimization.then_some((idx, vector_size))</div><div>             })</div><div>             .collect();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         // Select the largest unindexed segment, return if none</div><div>         let selected_segment = candidates</div><div>             .iter()</div><div class="diff-removed">-            .max_by_key(|(_, vector_size_bytes)| *vector_size_bytes);</div><div class="diff-added">+            .max_by_key(|(_, vector_size)| *vector_size);</div><div>         if selected_segment.is_none() {</div><div>             return vec![];</div><div>         }</div><div>         let (selected_segment_id, selected_segment_size) = *selected_segment.unwrap();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         let number_of_segments = segments_read_guard.len();</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         // If the number of segments if equal or bigger than the default_segments_number</div><div>         // We want to make sure that we at least do not increase number of segments after optimization, thus we take more than one segment to optimize</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         if number_of_segments < self.default_segments_number {</div><div>             return vec![selected_segment_id];</div><div>         }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         // It is better for scheduling if indexing optimizer optimizes 2 segments.</div><div>         // Because result of the optimization is usually 2 segment - it should preserve</div><div>         // overall count of segments.</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         // Find the smallest unindexed to check if we can index together</div><div>         let smallest_unindexed = candidates</div><div>             .iter()</div><div class="diff-removed">-            .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes);</div><div class="diff-added">+            .min_by_key(|(_, vector_size)| *vector_size);</div><div>         if let Some((idx, size)) = smallest_unindexed {</div><div>             if *idx != selected_segment_id</div><div>                 && selected_segment_size + size</div><div class="diff-info">@@ -216,7 +210,7 @@ impl IndexingOptimizer {</div><div>                 return vec![selected_segment_id, *idx];</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         // Find smallest indexed to check if we can reindex together</div><div>         let smallest_indexed = Self::smallest_indexed_segment(&segments_read_guard, excluded_ids);</div><div>         if let Some((idx, size)) = smallest_indexed {</div><div class="diff-info">@@ -230,13 +224,13 @@ impl IndexingOptimizer {</div><div>                 return vec![selected_segment_id, idx];</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div class="diff-added">+    </div><div>         vec![selected_segment_id]</div><div>     }</div><div> }</div><div> </div><div> impl SegmentOptimizer for IndexingOptimizer {</div><div class="diff-removed">-    fn name(&self) -> &str {</div><div class="diff-added">+    fn name(&self) -> &'static str {</div><div>         "indexing"</div><div>     }</div><div> </div><div class="diff-info">@@ -275,733 +269,4 @@ impl SegmentOptimizer for IndexingOptimizer {</div><div>     fn get_telemetry_counter(&self) -> &Mutex<OperationDurationsAggregator> {</div><div>         &self.telemetry_durations_aggregator</div><div>     }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[cfg(test)]</div><div class="diff-removed">-mod tests {</div><div class="diff-removed">-    use std::collections::BTreeMap;</div><div class="diff-removed">-    use std::ops::Deref;</div><div class="diff-removed">-    use std::sync::Arc;</div><div class="diff-removed">-    use std::sync::atomic::AtomicBool;</div><div class="diff-removed">-</div><div class="diff-removed">-    use common::budget::ResourceBudget;</div><div class="diff-removed">-    use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-    use itertools::Itertools;</div><div class="diff-removed">-    use parking_lot::lock_api::RwLock;</div><div class="diff-removed">-    use rand::rng;</div><div class="diff-removed">-    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;</div><div class="diff-removed">-    use segment::entry::entry_point::SegmentEntry;</div><div class="diff-removed">-    use segment::fixtures::index_fixtures::random_vector;</div><div class="diff-removed">-    use segment::index::hnsw_index::num_rayon_threads;</div><div class="diff-removed">-    use segment::json_path::JsonPath;</div><div class="diff-removed">-    use segment::payload_json;</div><div class="diff-removed">-    use segment::segment_constructor::simple_segment_constructor::{VECTOR1_NAME, VECTOR2_NAME};</div><div class="diff-removed">-    use segment::types::{Distance, PayloadSchemaType, VectorNameBuf};</div><div class="diff-removed">-    use tempfile::Builder;</div><div class="diff-removed">-</div><div class="diff-removed">-    use super::*;</div><div class="diff-removed">-    use crate::collection_manager::fixtures::{random_multi_vec_segment, random_segment};</div><div class="diff-removed">-    use crate::collection_manager::holders::segment_holder::{LockedSegment, SegmentHolder};</div><div class="diff-removed">-    use crate::collection_manager::optimizers::config_mismatch_optimizer::ConfigMismatchOptimizer;</div><div class="diff-removed">-    use crate::collection_manager::segments_updater::{</div><div class="diff-removed">-        process_field_index_operation, process_point_operation,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    use crate::operations::point_ops::{</div><div class="diff-removed">-        BatchPersisted, BatchVectorStructPersisted, PointInsertOperationsInternal, PointOperations,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    use crate::operations::types::{VectorParams, VectorsConfig};</div><div class="diff-removed">-    use crate::operations::vector_params_builder::VectorParamsBuilder;</div><div class="diff-removed">-    use crate::operations::{CreateIndex, FieldIndexOperations};</div><div class="diff-removed">-</div><div class="diff-removed">-    fn init() {</div><div class="diff-removed">-        let _ = env_logger::builder().is_test(true).try_init();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_multi_vector_optimization() {</div><div class="diff-removed">-        init();</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let stopped = AtomicBool::new(false);</div><div class="diff-removed">-        let dim1 = 128;</div><div class="diff-removed">-        let dim2 = 256;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_dir = Builder::new().prefix("segments_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segments_temp_dir = Builder::new()</div><div class="diff-removed">-            .prefix("segments_temp_dir")</div><div class="diff-removed">-            .tempdir()</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        let mut opnum = 101..1000000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let large_segment =</div><div class="diff-removed">-            random_multi_vec_segment(segments_dir.path(), opnum.next().unwrap(), 200, dim1, dim2);</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_config = large_segment.segment_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let large_segment_id = holder.add_new(large_segment);</div><div class="diff-removed">-</div><div class="diff-removed">-        let vectors_config: BTreeMap<VectorNameBuf, VectorParams> = segment_config</div><div class="diff-removed">-            .vector_data</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(name, params)| {</div><div class="diff-removed">-                (</div><div class="diff-removed">-                    name.to_owned(),</div><div class="diff-removed">-                    VectorParamsBuilder::new(params.size as u64, params.distance).build(),</div><div class="diff-removed">-                )</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-            2,</div><div class="diff-removed">-            OptimizerThresholds {</div><div class="diff-removed">-                max_segment_size_kb: 300,</div><div class="diff-removed">-                memmap_threshold_kb: 1000,</div><div class="diff-removed">-                indexing_threshold_kb: 1000,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            segments_dir.path().to_owned(),</div><div class="diff-removed">-            segments_temp_dir.path().to_owned(),</div><div class="diff-removed">-            CollectionParams {</div><div class="diff-removed">-                vectors: VectorsConfig::Multi(vectors_config),</div><div class="diff-removed">-                ..CollectionParams::empty()</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let excluded_ids = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 50;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-</div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer</div><div class="diff-removed">-            .optimize(</div><div class="diff-removed">-                locked_holder.clone(),</div><div class="diff-removed">-                suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-removed">-                &stopped,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let infos = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-        let configs = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(infos.len(), 2);</div><div class="diff-removed">-        assert_eq!(configs.len(), 2);</div><div class="diff-removed">-</div><div class="diff-removed">-        let total_points: usize = infos.iter().map(|info| info.num_points).sum();</div><div class="diff-removed">-        let total_vectors: usize = infos.iter().map(|info| info.num_vectors).sum();</div><div class="diff-removed">-        assert_eq!(total_points, 200);</div><div class="diff-removed">-        assert_eq!(total_vectors, 400);</div><div class="diff-removed">-</div><div class="diff-removed">-        for config in configs {</div><div class="diff-removed">-            assert_eq!(config.vector_data.len(), 2);</div><div class="diff-removed">-            assert_eq!(config.vector_data.get(VECTOR1_NAME).unwrap().size, dim1);</div><div class="diff-removed">-            assert_eq!(config.vector_data.get(VECTOR2_NAME).unwrap().size, dim2);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_indexing_optimizer() {</div><div class="diff-removed">-        init();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut rng = rng();</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let payload_field: JsonPath = "number".parse().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let stopped = AtomicBool::new(false);</div><div class="diff-removed">-        let dim = 256;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_dir = Builder::new().prefix("segments_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segments_temp_dir = Builder::new()</div><div class="diff-removed">-            .prefix("segments_temp_dir")</div><div class="diff-removed">-            .tempdir()</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        let mut opnum = 101..1000000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let small_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 25, dim);</div><div class="diff-removed">-        let middle_low_segment =</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 90, dim);</div><div class="diff-removed">-        let middle_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim);</div><div class="diff-removed">-        let large_segment = random_segment(segments_dir.path(), opnum.next().unwrap(), 200, dim);</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_config = small_segment.segment_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let small_segment_id = holder.add_new(small_segment);</div><div class="diff-removed">-        let middle_low_segment_id = holder.add_new(middle_low_segment);</div><div class="diff-removed">-        let middle_segment_id = holder.add_new(middle_segment);</div><div class="diff-removed">-        let large_segment_id = holder.add_new(large_segment);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-            2,</div><div class="diff-removed">-            OptimizerThresholds {</div><div class="diff-removed">-                max_segment_size_kb: 300,</div><div class="diff-removed">-                memmap_threshold_kb: 1000,</div><div class="diff-removed">-                indexing_threshold_kb: 1000,</div><div class="diff-removed">-            },</div><div class="diff-removed">-            segments_dir.path().to_owned(),</div><div class="diff-removed">-            segments_temp_dir.path().to_owned(),</div><div class="diff-removed">-            CollectionParams {</div><div class="diff-removed">-                vectors: VectorsConfig::Single(</div><div class="diff-removed">-                    VectorParamsBuilder::new(</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].size as u64,</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].distance,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                    .build(),</div><div class="diff-removed">-                ),</div><div class="diff-removed">-                ..CollectionParams::empty()</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let excluded_ids = Default::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        // ---- check condition for MMap optimization</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 50;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&middle_low_segment_id));</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 1000;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 1000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 50;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 1000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-</div><div class="diff-removed">-        index_optimizer.thresholds_config.memmap_threshold_kb = 150;</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 50;</div><div class="diff-removed">-</div><div class="diff-removed">-        // ----- CREATE AN INDEXED FIELD ------</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        process_field_index_operation(</div><div class="diff-removed">-            locked_holder.deref(),</div><div class="diff-removed">-            opnum.next().unwrap(),</div><div class="diff-removed">-            &FieldIndexOperations::CreateIndex(CreateIndex {</div><div class="diff-removed">-                field_name: payload_field.clone(),</div><div class="diff-removed">-                field_schema: Some(PayloadSchemaType::Integer.into()),</div><div class="diff-removed">-            }),</div><div class="diff-removed">-            &hw_counter,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // ------ Plain -> Mmap & Indexed payload</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&large_segment_id));</div><div class="diff-removed">-        eprintln!("suggested_to_optimize = {suggested_to_optimize:#?}");</div><div class="diff-removed">-        index_optimizer</div><div class="diff-removed">-            .optimize(</div><div class="diff-removed">-                locked_holder.clone(),</div><div class="diff-removed">-                suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-removed">-                &stopped,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        eprintln!("Done");</div><div class="diff-removed">-</div><div class="diff-removed">-        // ------ Plain -> Indexed payload</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&middle_segment_id));</div><div class="diff-removed">-        index_optimizer</div><div class="diff-removed">-            .optimize(</div><div class="diff-removed">-                locked_holder.clone(),</div><div class="diff-removed">-                suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-removed">-                &stopped,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // ------- Keep smallest segment without changes</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div class="diff-removed">-        assert!(suggested_to_optimize.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            locked_holder.read().len(),</div><div class="diff-removed">-            3,</div><div class="diff-removed">-            "Testing no new segments were created"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let infos = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-        let configs = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        let indexed_count = infos</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .filter(|info| info.segment_type == SegmentType::Indexed)</div><div class="diff-removed">-            .count();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            indexed_count, 2,</div><div class="diff-removed">-            "Testing that 2 segments are actually indexed"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let on_disk_count = configs</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .filter(|config| config.is_any_on_disk())</div><div class="diff-removed">-            .count();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            on_disk_count, 1,</div><div class="diff-removed">-            "Testing that only largest segment is not Mmap"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_dirs = segments_dir.path().read_dir().unwrap().collect_vec();</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            segment_dirs.len(),</div><div class="diff-removed">-            locked_holder.read().len(),</div><div class="diff-removed">-            "Testing that new segments are persisted and old data is removed"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        for info in &infos {</div><div class="diff-removed">-            assert!(</div><div class="diff-removed">-                info.index_schema.contains_key(&payload_field),</div><div class="diff-removed">-                "Testing that payload is not lost"</div><div class="diff-removed">-            );</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                info.index_schema[&payload_field].data_type,</div><div class="diff-removed">-                PayloadSchemaType::Integer,</div><div class="diff-removed">-                "Testing that payload type is not lost"</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let point_payload = payload_json! {"number": 10000i64};</div><div class="diff-removed">-</div><div class="diff-removed">-        let batch = BatchPersisted {</div><div class="diff-removed">-            ids: vec![501.into(), 502.into(), 503.into()],</div><div class="diff-removed">-            vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-            payloads: Some(vec![</div><div class="diff-removed">-                Some(point_payload.clone()),</div><div class="diff-removed">-                Some(point_payload.clone()),</div><div class="diff-removed">-                Some(point_payload),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let insert_point_ops =</div><div class="diff-removed">-            PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div class="diff-removed">-</div><div class="diff-removed">-        let smallest_size = infos</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .min_by_key(|info| info.num_vectors)</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .num_vectors;</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        process_point_operation(</div><div class="diff-removed">-            locked_holder.deref(),</div><div class="diff-removed">-            opnum.next().unwrap(),</div><div class="diff-removed">-            insert_point_ops,</div><div class="diff-removed">-            &hw_counter,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let new_infos = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-        let new_smallest_size = new_infos</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .min_by_key(|info| info.num_vectors)</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .num_vectors;</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(</div><div class="diff-removed">-            new_smallest_size,</div><div class="diff-removed">-            smallest_size + 3,</div><div class="diff-removed">-            "Testing that new data is added to an appendable segment only"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        // ---- New appendable segment should be created if none left</div><div class="diff-removed">-</div><div class="diff-removed">-        // Index even the smallest segment</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-        index_optimizer.thresholds_config.indexing_threshold_kb = 20;</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-        assert!(suggested_to_optimize.contains(&small_segment_id));</div><div class="diff-removed">-        index_optimizer</div><div class="diff-removed">-            .optimize(</div><div class="diff-removed">-                locked_holder.clone(),</div><div class="diff-removed">-                suggested_to_optimize,</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-removed">-                &stopped,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let new_infos2 = locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut has_empty = false;</div><div class="diff-removed">-        for info in new_infos2 {</div><div class="diff-removed">-            has_empty |= info.num_vectors == 0;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            has_empty,</div><div class="diff-removed">-            "Testing that new segment is created if none left"</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let batch = BatchPersisted {</div><div class="diff-removed">-            ids: vec![601.into(), 602.into(), 603.into()],</div><div class="diff-removed">-            vectors: BatchVectorStructPersisted::Single(vec![</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-                random_vector(&mut rng, dim),</div><div class="diff-removed">-            ]),</div><div class="diff-removed">-            payloads: None,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let insert_point_ops =</div><div class="diff-removed">-            PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div class="diff-removed">-</div><div class="diff-removed">-        process_point_operation(</div><div class="diff-removed">-            locked_holder.deref(),</div><div class="diff-removed">-            opnum.next().unwrap(),</div><div class="diff-removed">-            insert_point_ops,</div><div class="diff-removed">-            &hw_counter,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Test that indexing optimizer maintain expected number of during the optimization duty</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_indexing_optimizer_with_number_of_segments() {</div><div class="diff-removed">-        init();</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let stopped = AtomicBool::new(false);</div><div class="diff-removed">-        let dim = 256;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_dir = Builder::new().prefix("segments_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segments_temp_dir = Builder::new()</div><div class="diff-removed">-            .prefix("segments_temp_dir")</div><div class="diff-removed">-            .tempdir()</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        let mut opnum = 101..1000000;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments = vec![</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-            random_segment(segments_dir.path(), opnum.next().unwrap(), 100, dim),</div><div class="diff-removed">-        ];</div><div class="diff-removed">-</div><div class="diff-removed">-        let number_of_segments = segments.len();</div><div class="diff-removed">-        let segment_config = segments[0].segment_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let _segment_ids: Vec<SegmentId> = segments</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|segment| holder.add_new(segment))</div><div class="diff-removed">-            .collect();</div><div class="diff-removed">-</div><div class="diff-removed">-        let locked_holder: Arc<RwLock<_, _>> = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-            number_of_segments, // Keep the same number of segments</div><div class="diff-removed">-            OptimizerThresholds {</div><div class="diff-removed">-                max_segment_size_kb: 1000,</div><div class="diff-removed">-                memmap_threshold_kb: 1000,</div><div class="diff-removed">-                indexing_threshold_kb: 10, // Always optimize</div><div class="diff-removed">-            },</div><div class="diff-removed">-            segments_dir.path().to_owned(),</div><div class="diff-removed">-            segments_temp_dir.path().to_owned(),</div><div class="diff-removed">-            CollectionParams {</div><div class="diff-removed">-                vectors: VectorsConfig::Single(</div><div class="diff-removed">-                    VectorParamsBuilder::new(</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].size as u64,</div><div class="diff-removed">-                        segment_config.vector_data[DEFAULT_VECTOR_NAME].distance,</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                    .build(),</div><div class="diff-removed">-                ),</div><div class="diff-removed">-                ..CollectionParams::empty()</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Index until all segments are indexed</div><div class="diff-removed">-        let mut numer_of_optimizations = 0;</div><div class="diff-removed">-        loop {</div><div class="diff-removed">-            let suggested_to_optimize =</div><div class="diff-removed">-                index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            if suggested_to_optimize.is_empty() {</div><div class="diff-removed">-                break;</div><div class="diff-removed">-            }</div><div class="diff-removed">-            log::debug!("suggested_to_optimize = {suggested_to_optimize:#?}");</div><div class="diff-removed">-</div><div class="diff-removed">-            let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-            index_optimizer</div><div class="diff-removed">-                .optimize(</div><div class="diff-removed">-                    locked_holder.clone(),</div><div class="diff-removed">-                    suggested_to_optimize,</div><div class="diff-removed">-                    permit,</div><div class="diff-removed">-                    budget.clone(),</div><div class="diff-removed">-                    &stopped,</div><div class="diff-removed">-                )</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            numer_of_optimizations += 1;</div><div class="diff-removed">-            assert!(numer_of_optimizations <= number_of_segments);</div><div class="diff-removed">-            let number_of_segments = locked_holder.read().len();</div><div class="diff-removed">-            log::debug!(</div><div class="diff-removed">-                "numer_of_optimizations = {numer_of_optimizations}, number_of_segments = {number_of_segments}"</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure that the total number of segments did not change</div><div class="diff-removed">-        assert_eq!(locked_holder.read().len(), number_of_segments);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// This tests things are as we expect when we define both `on_disk: false` and `memmap_threshold`</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Before this PR (<https://github.com/qdrant/qdrant/pull/3167>) such configuration would create an infinite optimization loop.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It tests whether:</div><div class="diff-removed">-    /// - the on_disk flag is preferred over memmap_threshold</div><div class="diff-removed">-    /// - the index optimizer and config mismatch optimizer don't conflict with this preference</div><div class="diff-removed">-    /// - there is no infinite optiization loop with the above configuration</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// In short, this is what happens in this test:</div><div class="diff-removed">-    /// - create randomized segment as base with `on_disk: false` and `memmap_threshold`</div><div class="diff-removed">-    /// - test that indexing optimizer and config mismatch optimizer dont trigger</div><div class="diff-removed">-    /// - test that current storage is in memory</div><div class="diff-removed">-    /// - change `on_disk: None`</div><div class="diff-removed">-    /// - test that indexing optimizer now wants to optimize for `memmap_threshold`</div><div class="diff-removed">-    /// - optimize with indexing optimizer to put storage on disk</div><div class="diff-removed">-    /// - test that config mismatch optimizer doesn't try to revert on disk storage</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_on_disk_memmap_threshold_conflict() {</div><div class="diff-removed">-        // Collection configuration</div><div class="diff-removed">-        let (point_count, dim) = (1000, 10);</div><div class="diff-removed">-        let thresholds_config = OptimizerThresholds {</div><div class="diff-removed">-            max_segment_size_kb: usize::MAX,</div><div class="diff-removed">-            memmap_threshold_kb: 10,</div><div class="diff-removed">-            indexing_threshold_kb: usize::MAX,</div><div class="diff-removed">-        };</div><div class="diff-removed">-        let mut collection_params = CollectionParams {</div><div class="diff-removed">-            vectors: VectorsConfig::Single(</div><div class="diff-removed">-                VectorParamsBuilder::new(dim as u64, Distance::Dot)</div><div class="diff-removed">-                    .with_on_disk(false)</div><div class="diff-removed">-                    .build(),</div><div class="diff-removed">-            ),</div><div class="diff-removed">-            ..CollectionParams::empty()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Base segment</div><div class="diff-removed">-        let temp_dir = Builder::new().prefix("segment_temp_dir").tempdir().unwrap();</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment = random_segment(dir.path(), 100, point_count, dim as usize);</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_id = holder.add_new(segment);</div><div class="diff-removed">-        let locked_holder: Arc<parking_lot::RwLock<_>> = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let hnsw_config = HnswConfig {</div><div class="diff-removed">-            m: 16,</div><div class="diff-removed">-            ef_construct: 100,</div><div class="diff-removed">-            full_scan_threshold: 10,</div><div class="diff-removed">-            max_indexing_threads: 0,</div><div class="diff-removed">-            on_disk: None,</div><div class="diff-removed">-            payload_m: None,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        {</div><div class="diff-removed">-            // Optimizers used in test</div><div class="diff-removed">-            let index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-                2,</div><div class="diff-removed">-                thresholds_config,</div><div class="diff-removed">-                dir.path().to_owned(),</div><div class="diff-removed">-                temp_dir.path().to_owned(),</div><div class="diff-removed">-                collection_params.clone(),</div><div class="diff-removed">-                hnsw_config.clone(),</div><div class="diff-removed">-                Default::default(),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            let config_mismatch_optimizer = ConfigMismatchOptimizer::new(</div><div class="diff-removed">-                thresholds_config,</div><div class="diff-removed">-                dir.path().to_owned(),</div><div class="diff-removed">-                temp_dir.path().to_owned(),</div><div class="diff-removed">-                collection_params.clone(),</div><div class="diff-removed">-                hnsw_config.clone(),</div><div class="diff-removed">-                Default::default(),</div><div class="diff-removed">-            );</div><div class="diff-removed">-</div><div class="diff-removed">-            // Index optimizer should not optimize and put storage back in memory, nothing changed</div><div class="diff-removed">-            let suggested_to_optimize =</div><div class="diff-removed">-                index_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                suggested_to_optimize.len(),</div><div class="diff-removed">-                0,</div><div class="diff-removed">-                "index optimizer should not run for index nor mmap"</div><div class="diff-removed">-            );</div><div class="diff-removed">-</div><div class="diff-removed">-            // Config mismatch optimizer should not try to change the current state</div><div class="diff-removed">-            let suggested_to_optimize = config_mismatch_optimizer</div><div class="diff-removed">-                .check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                suggested_to_optimize.len(),</div><div class="diff-removed">-                0,</div><div class="diff-removed">-                "config mismatch optimizer should not change anything"</div><div class="diff-removed">-            );</div><div class="diff-removed">-</div><div class="diff-removed">-            // Ensure segment is not on disk</div><div class="diff-removed">-            locked_holder</div><div class="diff-removed">-                .read()</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|(_, segment)| match segment {</div><div class="diff-removed">-                    LockedSegment::Original(s) => s.read(),</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .filter(|segment| segment.total_point_count() > 0)</div><div class="diff-removed">-                .for_each(|segment| {</div><div class="diff-removed">-                    assert!(</div><div class="diff-removed">-                        !segment.config().vector_data[DEFAULT_VECTOR_NAME]</div><div class="diff-removed">-                            .storage_type</div><div class="diff-removed">-                            .is_on_disk(),</div><div class="diff-removed">-                        "segment must not be on disk with mmap",</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                });</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Remove explicit on_disk flag and go back to default</div><div class="diff-removed">-        collection_params</div><div class="diff-removed">-            .vectors</div><div class="diff-removed">-            .get_params_mut(DEFAULT_VECTOR_NAME)</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .on_disk</div><div class="diff-removed">-            .take();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Optimizers used in test</div><div class="diff-removed">-        let index_optimizer = IndexingOptimizer::new(</div><div class="diff-removed">-            2,</div><div class="diff-removed">-            thresholds_config,</div><div class="diff-removed">-            dir.path().to_owned(),</div><div class="diff-removed">-            temp_dir.path().to_owned(),</div><div class="diff-removed">-            collection_params.clone(),</div><div class="diff-removed">-            hnsw_config.clone(),</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        let config_mismatch_optimizer = ConfigMismatchOptimizer::new(</div><div class="diff-removed">-            thresholds_config,</div><div class="diff-removed">-            dir.path().to_owned(),</div><div class="diff-removed">-            temp_dir.path().to_owned(),</div><div class="diff-removed">-            collection_params,</div><div class="diff-removed">-            hnsw_config,</div><div class="diff-removed">-            Default::default(),</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        let permit_cpu_count = num_rayon_threads(0);</div><div class="diff-removed">-        let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Use indexing optimizer to build mmap</div><div class="diff-removed">-        let changed = index_optimizer</div><div class="diff-removed">-            .optimize(</div><div class="diff-removed">-                locked_holder.clone(),</div><div class="diff-removed">-                vec![segment_id],</div><div class="diff-removed">-                permit,</div><div class="diff-removed">-                budget.clone(),</div><div class="diff-removed">-                &false.into(),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            changed > 0,</div><div class="diff-removed">-            "optimizer should have rebuilt this segment for mmap"</div><div class="diff-removed">-        );</div><div class="diff-removed">-        assert!(</div><div class="diff-removed">-            locked_holder.read().get(segment_id).is_none(),</div><div class="diff-removed">-            "optimized segment should be gone",</div><div class="diff-removed">-        );</div><div class="diff-removed">-        assert_eq!(locked_holder.read().len(), 2, "mmap must be built");</div><div class="diff-removed">-</div><div class="diff-removed">-        // Mismatch optimizer should not optimize yet, HNSW config is not changed yet</div><div class="diff-removed">-        let suggested_to_optimize =</div><div class="diff-removed">-            config_mismatch_optimizer.check_condition(locked_holder.clone(), &Default::default());</div><div class="diff-removed">-        assert_eq!(suggested_to_optimize.len(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Ensure new segment is on disk now</div><div class="diff-removed">-        locked_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .map(|(_, segment)| match segment {</div><div class="diff-removed">-                LockedSegment::Original(s) => s.read(),</div><div class="diff-removed">-                LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .filter(|segment| segment.total_point_count() > 0)</div><div class="diff-removed">-            .for_each(|segment| {</div><div class="diff-removed">-                assert!(</div><div class="diff-removed">-                    segment.config().vector_data[DEFAULT_VECTOR_NAME]</div><div class="diff-removed">-                        .storage_type</div><div class="diff-removed">-                        .is_on_disk(),</div><div class="diff-removed">-                    "segment must be on disk with mmap",</div><div class="diff-removed">-                );</div><div class="diff-removed">-            });</div><div class="diff-removed">-    }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    