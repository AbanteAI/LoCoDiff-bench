<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <p><a href="../../models/x-ai_grok-3-mini-beta.html">‚Üê Back to Grok 3 Mini Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 3 Mini</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 78755</p>
                <p><strong>Native Completion Tokens:</strong> 9004</p>
                <p><strong>Native Tokens Reasoning:</strong> 657</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0281285</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected)+++ react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual)@@ -10,6 +10,7 @@ import type {</div><div>   Awaited,</div><div>   ReactContext,</div><div class="diff-added">+  ReactProviderType,</div><div>   StartTransitionOptions,</div><div>   Usable,</div><div>   Thenable,</div><div class="diff-info">@@ -55,94 +56,11 @@ </div><div> // Primitives</div><div> </div><div class="diff-removed">-type BasicStateAction<S> = (S => S) | S;</div><div class="diff-added">+type BasicStateAction<S> = ((S) => S) | S;</div><div> </div><div> type Dispatch<A> = A => void;</div><div> </div><div> let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div class="diff-removed">-</div><div class="diff-removed">-type Hook = {</div><div class="diff-removed">-  memoizedState: any,</div><div class="diff-removed">-  next: Hook | null,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div class="diff-removed">-  // This initializes a cache of all primitive hooks so that the top</div><div class="diff-removed">-  // most stack frames added by calling the primitive hook can be removed.</div><div class="diff-removed">-  if (primitiveStackCache === null) {</div><div class="diff-removed">-    const cache = new Map<string, Array<any>>();</div><div class="diff-removed">-    let readHookLog;</div><div class="diff-removed">-    try {</div><div class="diff-removed">-      // Use all hooks here to add them to the hook log.</div><div class="diff-removed">-      Dispatcher.useContext(({_currentValue: null}: any));</div><div class="diff-removed">-      Dispatcher.useState(null);</div><div class="diff-removed">-      Dispatcher.useReducer((s: mixed, a: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useRef(null);</div><div class="diff-removed">-      if (typeof Dispatcher.useCacheRefresh === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useCacheRefresh();</div><div class="diff-removed">-      }</div><div class="diff-removed">-      Dispatcher.useLayoutEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useInsertionEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useImperativeHandle(undefined, () => null);</div><div class="diff-removed">-      Dispatcher.useDebugValue(null);</div><div class="diff-removed">-      Dispatcher.useCallback(() => {});</div><div class="diff-removed">-      Dispatcher.useTransition();</div><div class="diff-removed">-      Dispatcher.useSyncExternalStore(</div><div class="diff-removed">-        () => () => {},</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-      );</div><div class="diff-removed">-      Dispatcher.useDeferredValue(null);</div><div class="diff-removed">-      Dispatcher.useMemo(() => null);</div><div class="diff-removed">-      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);</div><div class="diff-removed">-      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useHostTransitionStatus();</div><div class="diff-removed">-      if (typeof Dispatcher.useMemoCache === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useMemoCache(0);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (typeof Dispatcher.use === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.use(</div><div class="diff-removed">-          ({</div><div class="diff-removed">-            $$typeof: REACT_CONTEXT_TYPE,</div><div class="diff-removed">-            _currentValue: null,</div><div class="diff-removed">-          }: any),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        Dispatcher.use({</div><div class="diff-removed">-          then() {},</div><div class="diff-removed">-          status: 'fulfilled',</div><div class="diff-removed">-          value: null,</div><div class="diff-removed">-        });</div><div class="diff-removed">-        try {</div><div class="diff-removed">-          Dispatcher.use(</div><div class="diff-removed">-            ({</div><div class="diff-removed">-              then() {},</div><div class="diff-removed">-            }: any),</div><div class="diff-removed">-          );</div><div class="diff-removed">-        } catch (x) {}</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      Dispatcher.useId();</div><div class="diff-removed">-</div><div class="diff-removed">-      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-removed">-        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } finally {</div><div class="diff-removed">-      readHookLog = hookLog;</div><div class="diff-removed">-      hookLog = [];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-      const hook = readHookLog[i];</div><div class="diff-removed">-      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));</div><div class="diff-removed">-    }</div><div class="diff-removed">-    primitiveStackCache = cache;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return primitiveStackCache;</div><div class="diff-removed">-}</div><div> </div><div> let currentFiber: null | Fiber = null;</div><div> let currentHook: null | Hook = null;</div><div class="diff-info">@@ -154,6 +72,10 @@     currentHook = hook.next;</div><div>   }</div><div>   return hook;</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+function getCacheForType<T>(resourceType: () => T): T {</div><div class="diff-added">+  throw new Error('Not implemented.');</div><div> }</div><div> </div><div> function readContext<T>(context: ReactContext<T>): T {</div><div class="diff-info">@@ -169,7 +91,6 @@     }</div><div> </div><div>     let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div>     if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div>       // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div>       value = ((currentContextDependency.memoizedValue: any): T);</div><div class="diff-info">@@ -178,8 +99,6 @@       currentContextDependency = currentContextDependency.next;</div><div>     } else {</div><div>       // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-removed">-      // Multiple reads of the same context were also only tracked as a single dependency.</div><div class="diff-removed">-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.</div><div>       value = context._currentValue;</div><div>     }</div><div> </div><div class="diff-info">@@ -238,7 +157,7 @@       const value = readContext(context);</div><div> </div><div>       hookLog.push({</div><div class="diff-removed">-        displayName: context.displayName || 'Context',</div><div class="diff-added">+        displayName: context.displayName || null,</div><div>         primitive: 'Context (use)',</div><div>         stackError: new Error(),</div><div>         value,</div><div class="diff-info">@@ -271,13 +190,13 @@   initialState: (() => S) | S,</div><div> ): [S, Dispatch<BasicStateAction<S>>] {</div><div>   const hook = nextHook();</div><div class="diff-removed">-  const state: S =</div><div class="diff-added">+  const state =</div><div>     hook !== null</div><div>       ? hook.memoizedState</div><div>       : typeof initialState === 'function'</div><div class="diff-removed">-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-removed">-          initialState()</div><div class="diff-removed">-        : initialState;</div><div class="diff-added">+      ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-added">+        initialState()</div><div class="diff-added">+      : initialState;</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'State',</div><div class="diff-info">@@ -341,7 +260,7 @@ </div><div> function useLayoutEffect(</div><div>   create: () => (() => void) | void,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  deps: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -355,8 +274,8 @@ }</div><div> </div><div> function useInsertionEffect(</div><div class="diff-removed">-  create: () => mixed,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  create: () => (() => void) | void,</div><div class="diff-added">+  deps: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -387,13 +306,9 @@ function useImperativeHandle<T>(</div><div>   ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,</div><div>   create: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  deps: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div class="diff-removed">-  // We don't actually store the instance anywhere if there is no ref callback</div><div class="diff-removed">-  // and if there is a ref callback it might not store it but if it does we</div><div class="diff-removed">-  // have no way of knowing where. So let's only enable introspection of the</div><div class="diff-removed">-  // ref itself if it is using the object form.</div><div>   let instance: ?T = undefined;</div><div>   if (ref !== null && typeof ref === 'object') {</div><div>     instance = ref.current;</div><div class="diff-info">@@ -419,7 +334,7 @@   });</div><div> }</div><div> </div><div class="diff-removed">-function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {</div><div class="diff-added">+function useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {</div><div>   const hook = nextHook();</div><div>   hookLog.push({</div><div>     displayName: null,</div><div class="diff-info">@@ -434,7 +349,7 @@ </div><div> function useMemo<T>(</div><div>   nextCreate: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-added">+  deps: Array<mixed> | void | null,</div><div> ): T {</div><div>   const hook = nextHook();</div><div>   const value = hook !== null ? hook.memoizedState[0] : nextCreate();</div><div class="diff-info">@@ -454,10 +369,6 @@   getSnapshot: () => T,</div><div>   getServerSnapshot?: () => T,</div><div> ): T {</div><div class="diff-removed">-  // useSyncExternalStore() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div class="diff-removed">-  nextHook(); // SyncExternalStore</div><div>   nextHook(); // Effect</div><div>   const value = getSnapshot();</div><div>   hookLog.push({</div><div class="diff-info">@@ -475,9 +386,6 @@   boolean,</div><div>   (callback: () => void, options?: StartTransitionOptions) => void,</div><div> ] {</div><div class="diff-removed">-  // useTransition() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div>   const stateHook = nextHook();</div><div>   nextHook(); // Callback</div><div> </div><div class="diff-info">@@ -520,36 +428,6 @@     dispatcherHookName: 'Id',</div><div>   });</div><div>   return id;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-removed">-// it should not be called directly in user-generated code</div><div class="diff-removed">-function useMemoCache(size: number): Array<mixed> {</div><div class="diff-removed">-  const fiber = currentFiber;</div><div class="diff-removed">-  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-removed">-  if (fiber == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const memoCache =</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-removed">-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-removed">-  if (memoCache == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  let data = memoCache.data[memoCache.index];</div><div class="diff-removed">-  if (data === undefined) {</div><div class="diff-removed">-    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-removed">-    for (let i = 0; i < size; i++) {</div><div class="diff-removed">-      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div class="diff-removed">-  memoCache.index++;</div><div class="diff-removed">-  return data;</div><div> }</div><div> </div><div> function useOptimistic<S, A>(</div><div class="diff-info">@@ -640,7 +518,6 @@   // i.e. we only reach this point with Awaited<S></div><div>   const state = ((value: any): Awaited<S>);</div><div> </div><div class="diff-removed">-  // TODO: support displaying pending value</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div class="diff-info">@@ -710,75 +587,35 @@   // i.e. we only reach this point with Awaited<S></div><div>   const state = ((value: any): Awaited<S>);</div><div> </div><div class="diff-removed">-  // TODO: support displaying pending value</div><div>   return [state, (payload: P) => {}, false];</div><div> }</div><div> </div><div class="diff-removed">-function useHostTransitionStatus(): TransitionStatus {</div><div class="diff-removed">-  const status = readContext<TransitionStatus>(</div><div class="diff-removed">-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue</div><div class="diff-removed">-    ({</div><div class="diff-removed">-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.</div><div class="diff-removed">-      _currentValue: null,</div><div class="diff-removed">-    }: ReactContext<TransitionStatus>),</div><div class="diff-removed">-  );</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'HostTransitionStatus',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: status,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'HostTransitionStatus',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  return status;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'EffectEvent',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: callback,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'EffectEvent',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  return callback;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> const Dispatcher: DispatcherType = {</div><div class="diff-added">+  use,</div><div>   readContext,</div><div class="diff-removed">-</div><div class="diff-removed">-  use,</div><div class="diff-added">+  useCacheRefresh,</div><div>   useCallback,</div><div>   useContext,</div><div>   useEffect,</div><div>   useImperativeHandle,</div><div class="diff-added">+  useDebugValue,</div><div>   useLayoutEffect,</div><div>   useInsertionEffect,</div><div>   useMemo,</div><div class="diff-added">+  useMemoCache,</div><div>   useReducer,</div><div>   useRef,</div><div>   useState,</div><div class="diff-removed">-  useDebugValue,</div><div class="diff-removed">-  useDeferredValue,</div><div>   useTransition,</div><div>   useSyncExternalStore,</div><div class="diff-added">+  useDeferredValue,</div><div>   useId,</div><div>   useHostTransitionStatus,</div><div>   useFormState,</div><div>   useActionState,</div><div class="diff-removed">-  useOptimistic,</div><div class="diff-removed">-  useMemoCache,</div><div class="diff-removed">-  useCacheRefresh,</div><div>   useEffectEvent,</div><div> };</div><div> </div><div class="diff-removed">-// create a proxy to throw a custom error</div><div class="diff-removed">-// in case future versions of React adds more hooks</div><div> const DispatcherProxyHandler = {</div><div>   get(target: DispatcherType, prop: string) {</div><div>     if (target.hasOwnProperty(prop)) {</div><div class="diff-info">@@ -786,8 +623,6 @@       return target[prop];</div><div>     }</div><div>     const error = new Error('Missing method in Dispatcher: ' + prop);</div><div class="diff-removed">-    // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-    // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div>     error.name = 'ReactDebugToolsUnsupportedHookError';</div><div>     throw error;</div><div>   },</div><div class="diff-info">@@ -795,9 +630,9 @@ </div><div> // `Proxy` may not exist on some platforms</div><div> const DispatcherProxy =</div><div class="diff-removed">-  typeof Proxy === 'undefined'</div><div class="diff-removed">-    ? Dispatcher</div><div class="diff-removed">-    : new Proxy(Dispatcher, DispatcherProxyHandler);</div><div class="diff-added">+  typeof Proxy === 'function'</div><div class="diff-added">+    ? new Proxy(Dispatcher, DispatcherProxyHandler)</div><div class="diff-added">+    : Dispatcher;</div><div> </div><div> // Inspect</div><div> </div><div class="diff-info">@@ -834,7 +669,11 @@ </div><div> let mostLikelyAncestorIndex = 0;</div><div> </div><div class="diff-removed">-function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {</div><div class="diff-added">+function findSharedIndex(</div><div class="diff-added">+  hookStack: Array<any>,</div><div class="diff-added">+  rootStack: Array<any>,</div><div class="diff-added">+  rootIndex: number,</div><div class="diff-added">+) {</div><div>   const source = rootStack[rootIndex].source;</div><div>   hookSearch: for (let i = 0; i < hookStack.length; i++) {</div><div>     if (hookStack[i].source === source) {</div><div class="diff-info">@@ -855,7 +694,7 @@   return -1;</div><div> }</div><div> </div><div class="diff-removed">-function findCommonAncestorIndex(rootStack: any, hookStack: any) {</div><div class="diff-added">+function findCommonAncestorIndex(rootStack: Array<any>, hookStack: Array<any>) {</div><div>   let rootIndex = findSharedIndex(</div><div>     hookStack,</div><div>     rootStack,</div><div class="diff-info">@@ -885,18 +724,14 @@   return hookName === wrapperName;</div><div> }</div><div> </div><div class="diff-removed">-function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {</div><div class="diff-added">+function findPrimitiveIndex(hookStack: Array<any>, hook: HookLogEntry) {</div><div>   const stackCache = getPrimitiveStackCache();</div><div>   const primitiveStack = stackCache.get(hook.primitive);</div><div>   if (primitiveStack === undefined) {</div><div>     return -1;</div><div>   }</div><div>   for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {</div><div class="diff-removed">-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack</div><div class="diff-removed">-    // For React Native (uses Hermes), these source fields will be identical and skipped</div><div>     if (primitiveStack[i].source !== hookStack[i].source) {</div><div class="diff-removed">-      // If the next two frames are functions called `useX` then we assume that they're part of the</div><div class="diff-removed">-      // wrappers that the React package or other packages adds around the dispatcher.</div><div>       if (</div><div>         i < hookStack.length - 1 &&</div><div>         isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-info">@@ -916,9 +751,7 @@   return -1;</div><div> }</div><div> </div><div class="diff-removed">-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  // Get the stack trace between the primitive hook function and</div><div class="diff-removed">-  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-added">+function parseTrimmedStack(rootStack: Array<any>, hook: HookLogEntry) {</div><div>   const hookStack = ErrorStackParser.parse(hook.stackError);</div><div>   const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div>   const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-info">@@ -977,13 +810,12 @@ }</div><div> </div><div> function buildTree(</div><div class="diff-removed">-  rootStack: any,</div><div class="diff-added">+  rootStack: Array<any>,</div><div>   readHookLog: Array<HookLogEntry>,</div><div> ): HooksTree {</div><div>   const rootChildren: Array<HooksNode> = [];</div><div>   let prevStack = null;</div><div>   let levelChildren = rootChildren;</div><div class="diff-removed">-  let nativeHookID = 0;</div><div>   const stackOfChildren = [];</div><div>   for (let i = 0; i < readHookLog.length; i++) {</div><div>     const hook = readHookLog[i];</div><div class="diff-info">@@ -1001,8 +833,7 @@     if (stack !== null) {</div><div>       // Note: The indices 0 <= n < length-1 will contain the names.</div><div>       // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div class="diff-added">+      // That's why we get the name from n - 1 and don't check the source of index 0.</div><div>       let commonSteps = 0;</div><div>       if (prevStack !== null) {</div><div>         // Compare the current level's stack to the new stack.</div><div class="diff-info">@@ -1025,144 +856,143 @@       // to the tree.</div><div>       for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div>         const children: Array<HooksNode> = [];</div><div class="diff-removed">-        const stackFrame = stack[j];</div><div>         const levelChild: HooksNode = {</div><div class="diff-removed">-          id: null,</div><div class="diff-removed">-          isStateEditable: false,</div><div class="diff-removed">-          name: parseHookName(stack[j - 1].functionName),</div><div class="diff-removed">-          value: undefined,</div><div class="diff-removed">-          subHooks: children,</div><div class="diff-removed">-          debugInfo: null,</div><div class="diff-removed">-          hookSource: {</div><div class="diff-removed">-            lineNumber: stackFrame.lineNumber,</div><div class="diff-removed">-            columnNumber: stackFrame.columnNumber,</div><div class="diff-removed">-            functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div class="diff-removed">-          },</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        levelChildren.push(levelChild);</div><div class="diff-removed">-        stackOfChildren.push(levelChildren);</div><div class="diff-removed">-        levelChildren = children;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      prevStack = stack;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-removed">-    const id =</div><div class="diff-removed">-      primitive === 'Context' ||</div><div class="diff-removed">-      primitive === 'Context (use)' ||</div><div class="diff-removed">-      primitive === 'DebugValue' ||</div><div class="diff-removed">-      primitive === 'Promise' ||</div><div class="diff-removed">-      primitive === 'Unresolved' ||</div><div class="diff-removed">-      primitive === 'HostTransitionStatus'</div><div class="diff-removed">-        ? null</div><div class="diff-removed">-        : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-removed">-    const levelChild: HooksNode = {</div><div class="diff-removed">-      id,</div><div class="diff-removed">-      isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-removed">-      value: hook.value,</div><div class="diff-removed">-      subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-removed">-      hookSource: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    const hookSource: HookSource = {</div><div class="diff-removed">-      lineNumber: null,</div><div class="diff-removed">-      functionName: null,</div><div class="diff-removed">-      fileName: null,</div><div class="diff-removed">-      columnNumber: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChildren.push(levelChild);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-removed">-  processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div class="diff-removed">-  return rootChildren;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-removed">-function processDebugValues(</div><div class="diff-removed">-  hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-  for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-removed">-    const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-removed">-      hooksTree.splice(i, 1);</div><div class="diff-removed">-      i--;</div><div class="diff-removed">-      debugValueHooksNodes.push(hooksNode);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div class="diff-removed">-  if (parentHooksNode !== null) {</div><div class="diff-removed">-    if (debugValueHooksNodes.length === 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-removed">-    } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    error instanceof Error &&</div><div class="diff-removed">-    error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-  wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-removed">-  wrapperError.cause = error;</div><div class="diff-removed">-  throw wrapperError;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+           id: null,</div><div class="diff-added">+           isStateEditable: false,</div><div class="diff-added">+           name: parseHookName(stack[j - 1].functionName),</div><div class="diff-added">+           value: undefined,</div><div class="diff-added">+           subHooks: children,</div><div class="diff-added">+           debugInfo: null,</div><div class="diff-added">+           hookSource: {</div><div class="diff-added">+             lineNumber: stack[j].lineNumber,</div><div class="diff-added">+             columnNumber: stack[j].columnNumber,</div><div class="diff-added">+             functionName: stack[j].functionName,</div><div class="diff-added">+             fileName: stack[j].fileName,</div><div class="diff-added">+           },</div><div class="diff-added">+         };</div><div class="diff-added">+ </div><div class="diff-added">+         levelChildren.push(levelChild);</div><div class="diff-added">+         stackOfChildren.push(levelChildren);</div><div class="diff-added">+         levelChildren = children;</div><div class="diff-added">+       }</div><div class="diff-added">+       prevStack = stack;</div><div class="diff-added">+     }</div><div class="diff-added">+     const {primitive, debugInfo} = hook;</div><div class="diff-added">+ </div><div class="diff-added">+     // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-added">+     // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-added">+     const id =</div><div class="diff-added">+       primitive === 'Context' ||</div><div class="diff-added">+       primitive === 'Context (use)' ||</div><div class="diff-added">+       primitive === 'DebugValue' ||</div><div class="diff-added">+       primitive === 'Promise' ||</div><div class="diff-added">+       primitive === 'Unresolved' ||</div><div class="diff-added">+       primitive === 'HostTransitionStatus'</div><div class="diff-added">+         ? null</div><div class="diff-added">+         : nativeHookID++;</div><div class="diff-added">+ </div><div class="diff-added">+     // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-added">+     const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-added">+     const name = displayName || primitive;</div><div class="diff-added">+     const levelChild: HooksNode = {</div><div class="diff-added">+       id,</div><div class="diff-added">+       isStateEditable,</div><div class="diff-added">+       name,</div><div class="diff-added">+       value: hook.value,</div><div class="diff-added">+       subHooks: [],</div><div class="diff-added">+       debugInfo: debugInfo,</div><div class="diff-added">+       hookSource: null,</div><div class="diff-added">+     };</div><div class="diff-added">+ </div><div class="diff-added">+     const hookSource: HookSource = {</div><div class="diff-added">+       lineNumber: null,</div><div class="diff-added">+       functionName: null,</div><div class="diff-added">+       fileName: null,</div><div class="diff-added">+       columnNumber: null,</div><div class="diff-added">+     };</div><div class="diff-added">+     if (stack && stack.length >= 1) {</div><div class="diff-added">+       const stackFrame = stack[0];</div><div class="diff-added">+       hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-added">+       hookSource.functionName = stackFrame.functionName;</div><div class="diff-added">+       hookSource.fileName = stackFrame.fileName;</div><div class="diff-added">+       hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-added">+     }</div><div class="diff-added">+ </div><div class="diff-added">+     levelChild.hookSource = hookSource;</div><div class="diff-added">+ </div><div class="diff-added">+     levelChildren.push(levelChild);</div><div class="diff-added">+   }</div><div class="diff-added">+ </div><div class="diff-added">+   // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-added">+   processDebugValues(rootChildren, null);</div><div class="diff-added">+ </div><div class="diff-added">+   return rootChildren;</div><div class="diff-added">+ }</div><div class="diff-added">+ </div><div class="diff-added">+ // Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-added">+ // That hook adds user-provided values to the hooks tree,</div><div class="diff-added">+ // but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-added">+ // Instead they should be attributed to their parent custom hook.</div><div class="diff-added">+ // This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-added">+// function processDebugValues(</div><div class="diff-added">+ //   hooksTree: HooksTree,</div><div class="diff-added">+ //   parentHooksNode: HooksNode | null,</div><div class="diff-added">+ // ): void {</div><div class="diff-added">+ //   const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-added">+ //</div><div class="diff-added">+ //   for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-added">+ //     const hooksNode = hooksTree[i];</div><div class="diff-added">+ //     if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-added">+ //       hooksTree.splice(i, 1);</div><div class="diff-added">+ //       i--;</div><div class="diff-added">+ //       debugValueHooksNodes.push(hooksNode);</div><div class="diff-added">+ //     } else {</div><div class="diff-added">+ //       processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-added">+ //     }</div><div class="diff-added">+ //   }</div><div class="diff-added">+ //</div><div class="diff-added">+ //   // Bubble debug value labels to their custom hook owner.</div><div class="diff-added">+ //   // If there is no parent hook, just ignore them for now.</div><div class="diff-added">+ //   // (We may warn about this in the future.)</div><div class="diff-added">+ //   if (parentHooksNode !== null) {</div><div class="diff-added">+ //     if (debugValueHooksNodes.length === 1) {</div><div class="diff-added">+ //       parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-added">+ //     } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-added">+ //       parentHooksNode.value = debugValueHooksNodes.map(</div><div class="diff-added">+ //         ({ value }) => value,</div><div class="diff-added">+ //       );</div><div class="diff-added">+ //     }</div><div class="diff-added">+ //   }</div><div class="diff-added">+ // }</div><div class="diff-added">+ </div><div class="diff-added">+ function handleRenderFunctionError(error: any): void {</div><div class="diff-added">+   if (error === SuspenseException) {</div><div class="diff-added">+     // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-added">+     // the Hooks but we can at least show what ever we got so far.</div><div class="diff-added">+     return;</div><div class="diff-added">+   }</div><div class="diff-added">+   if (</div><div class="diff-added">+     error instanceof Error &&</div><div class="diff-added">+     error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-added">+   ) {</div><div class="diff-added">+     throw error;</div><div class="diff-added">+   }</div><div class="diff-added">+   // If the error is not caused by an unsupported feature, it means</div><div class="diff-added">+   // that the error is caused by user's code in renderFunction.</div><div class="diff-added">+   // In this case, we should wrap the original error inside a custom error</div><div class="diff-added">+   // so that devtools can give a clear message about it.</div><div class="diff-added">+   // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-added">+   const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-added">+     cause: error,</div><div class="diff-added">+   });</div><div class="diff-added">+   // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-added">+   // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-added">+   wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-added">+   // this stage-4 proposal is not supported by all environments yet. ($FlowFixMe[prop-missing] Flow doesn't have this type yet.)</div><div class="diff-added">+   wrapperError.cause = error;</div><div class="diff-added">+   throw wrapperError;</div><div class="diff-added">+ }</div><div class="diff-added">+ </div><div> export function inspectHooks<Props>(</div><div>   renderFunction: Props => React$Node,</div><div>   props: Props,</div><div class="diff-info">@@ -1179,7 +1009,6 @@ </div><div>   let readHookLog;</div><div>   let ancestorStackError;</div><div class="diff-removed">-</div><div>   try {</div><div>     ancestorStackError = new Error();</div><div>     renderFunction(props);</div><div class="diff-info">@@ -1188,7 +1017,6 @@   } finally {</div><div>     readHookLog = hookLog;</div><div>     hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div>     currentDispatcher.H = previousDispatcher;</div><div>   }</div><div>   const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-info">@@ -1220,7 +1048,7 @@ }</div><div> </div><div> function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-removed">-  renderFunction: (Props, Ref) => React$Node,</div><div class="diff-added">+  renderFunction: (Props, Ref) => ReactNode,</div><div>   props: Props,</div><div>   ref: Ref,</div><div>   currentDispatcher: CurrentDispatcherRef,</div><div class="diff-info">@@ -1281,8 +1109,6 @@   // Warm up the cache so that it doesn't consume the currentHook.</div><div>   getPrimitiveStackCache();</div><div> </div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div>   currentHook = (fiber.memoizedState: Hook);</div><div>   currentFiber = fiber;</div><div> </div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    