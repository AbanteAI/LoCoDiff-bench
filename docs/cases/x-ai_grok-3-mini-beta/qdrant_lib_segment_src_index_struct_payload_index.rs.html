<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/src/index/struct_payload_index.rs - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/src/index/struct_payload_index.rs</h1>
        <p><a href="../../models/x-ai_grok-3-mini-beta.html">‚Üê Back to Grok 3 Mini Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 3 Mini</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 82321</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 81561</p>
                <p><strong>Native Completion Tokens:</strong> 4771</p>
                <p><strong>Native Tokens Reasoning:</strong> 529</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0268538</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_segment_src_index_struct_payload_index.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_segment_src_index_struct_payload_index.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_segment_src_index_struct_payload_index.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_segment_src_index_struct_payload_index.rs_expectedoutput.txt (expected)+++ qdrant_lib_segment_src_index_struct_payload_index.rs_extracted.txt (actual)@@ -1,111 +1,53 @@-use std::collections::HashMap;</div><div class="diff-removed">-use std::fs::create_dir_all;</div><div class="diff-added">+use std::collections::{HashMap, HashSet};</div><div class="diff-added">+use std::fs::{create_dir_all, File, remove_file};</div><div> use std::path::{Path, PathBuf};</div><div> use std::sync::Arc;</div><div> </div><div class="diff-removed">-use ahash::AHashSet;</div><div> use atomic_refcell::AtomicRefCell;</div><div class="diff-removed">-use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-use common::counter::iterator_hw_measurement::HwMeasurementIteratorExt;</div><div class="diff-removed">-use common::flags::feature_flags;</div><div class="diff-removed">-use common::types::PointOffsetType;</div><div class="diff-removed">-use itertools::Either;</div><div class="diff-added">+use crate::index::field_index::{CardinalityEstimation, FieldIndex};</div><div class="diff-added">+use crate::index::payload_config::PayloadConfig;</div><div class="diff-added">+use crate::payload_storage::payload_storage::{ConditionChecker, PayloadStorage};</div><div class="diff-added">+use crate::index::field_index::field_index::PayloadFieldIndex;</div><div class="diff-added">+use crate::index::field_index::index_selector::index_selector;</div><div class="diff-added">+use crate::index::field_index::numeric_index::PersistedNumericIndex;</div><div class="diff-added">+use crate::types::{Filter, PayloadKeyType, FieldCondition};</div><div class="diff-added">+use crate::entry::entry_point::{OperationResult, OperationError};</div><div class="diff-added">+use std::collections::HashMap as HashMap2;</div><div class="diff-added">+use std::fs as std_fs;</div><div class="diff-added">+use std::io::Error;</div><div class="diff-added">+use std::path::Path;</div><div class="diff-added">+use std::sync::Arc;</div><div class="diff-added">+use atomic_refcell::AtomicRefCell;</div><div class="diff-added">+use itertools::Itertools;</div><div> use log::debug;</div><div class="diff-removed">-use parking_lot::RwLock;</div><div class="diff-removed">-use rocksdb::DB;</div><div class="diff-removed">-use schemars::_serde_json::Value;</div><div class="diff-removed">-</div><div class="diff-removed">-use super::field_index::FieldIndexBuilderTrait as _;</div><div class="diff-removed">-use super::field_index::facet_index::FacetIndexEnum;</div><div class="diff-removed">-use super::field_index::index_selector::{IndexSelector, IndexSelectorMmap, IndexSelectorRocksDb};</div><div class="diff-removed">-use crate::common::Flusher;</div><div class="diff-removed">-use crate::common::operation_error::{OperationError, OperationResult};</div><div class="diff-removed">-use crate::common::rocksdb_wrapper::open_db_with_existing_cf;</div><div class="diff-removed">-use crate::common::utils::IndexesMap;</div><div class="diff-removed">-use crate::id_tracker::IdTrackerSS;</div><div class="diff-removed">-use crate::index::PayloadIndex;</div><div class="diff-removed">-use crate::index::field_index::{</div><div class="diff-removed">-    CardinalityEstimation, FieldIndex, PayloadBlockCondition, PrimaryCondition,</div><div class="diff-removed">-};</div><div class="diff-removed">-use crate::index::payload_config::PayloadConfig;</div><div class="diff-removed">-use crate::index::query_estimator::estimate_filter;</div><div class="diff-removed">-use crate::index::query_optimization::payload_provider::PayloadProvider;</div><div class="diff-removed">-use crate::index::struct_filter_context::StructFilterContext;</div><div class="diff-removed">-use crate::index::visited_pool::VisitedPool;</div><div class="diff-removed">-use crate::json_path::JsonPath;</div><div class="diff-removed">-use crate::payload_storage::payload_storage_enum::PayloadStorageEnum;</div><div class="diff-removed">-use crate::payload_storage::{FilterContext, PayloadStorage};</div><div class="diff-removed">-use crate::telemetry::PayloadIndexTelemetry;</div><div class="diff-removed">-use crate::types::{</div><div class="diff-removed">-    Condition, FieldCondition, Filter, IsEmptyCondition, IsNullCondition, Payload,</div><div class="diff-removed">-    PayloadContainer, PayloadFieldSchema, PayloadKeyType, PayloadKeyTypeRef, PayloadSchemaType,</div><div class="diff-removed">-    VectorNameBuf, infer_collection_value_type, infer_value_type,</div><div class="diff-removed">-};</div><div class="diff-removed">-use crate::vector_storage::{VectorStorage, VectorStorageEnum};</div><div class="diff-removed">-</div><div class="diff-removed">-#[derive(Debug)]</div><div class="diff-removed">-enum StorageType {</div><div class="diff-removed">-    Appendable(Arc<RwLock<DB>>),</div><div class="diff-removed">-    NonAppendableRocksDb(Arc<RwLock<DB>>),</div><div class="diff-removed">-    NonAppendable,</div><div class="diff-added">+</div><div class="diff-added">+pub const PAYLOAD_FIELD_INDEX_PATH: &str = "fields";</div><div class="diff-added">+</div><div class="diff-added">+type IndexesMap = HashMap<PayloadKeyType, Vec<FieldIndex>>;</div><div class="diff-added">+</div><div class="diff-added">+pub struct StructPayloadIndex {</div><div class="diff-added">+    condition_checker: Arc<AtomicRefCell<dyn ConditionChecker>>,</div><div class="diff-added">+    vector_storage: Arc<AtomicRefCell<dyn VectorStorage>>,</div><div class="diff-added">+    payload: Arc<AtomicRefCell<dyn PayloadStorage>>,</div><div class="diff-added">+    id_mapper: Arc<AtomicRefCell<dyn IdMapper>>,</div><div class="diff-added">+    field_indexes: IndexesMap,</div><div class="diff-added">+    config: PayloadConfig,</div><div class="diff-added">+    path: PathBuf,</div><div class="diff-added">+    total_points: usize,</div><div> }</div><div> </div><div class="diff-removed">-/// `PayloadIndex` implementation, which actually uses index structures for providing faster search</div><div class="diff-removed">-#[derive(Debug)]</div><div class="diff-removed">-pub struct StructPayloadIndex {</div><div class="diff-removed">-    /// Payload storage</div><div class="diff-removed">-    pub(super) payload: Arc<AtomicRefCell<PayloadStorageEnum>>,</div><div class="diff-removed">-    /// Used for `has_id` condition and estimating cardinality</div><div class="diff-removed">-    pub(super) id_tracker: Arc<AtomicRefCell<IdTrackerSS>>,</div><div class="diff-removed">-    /// Vector storages for each field, used for `has_vector` condition</div><div class="diff-removed">-    pub(super) vector_storages: HashMap<VectorNameBuf, Arc<AtomicRefCell<VectorStorageEnum>>>,</div><div class="diff-removed">-    /// Indexes, associated with fields</div><div class="diff-removed">-    pub field_indexes: IndexesMap,</div><div class="diff-removed">-    config: PayloadConfig,</div><div class="diff-removed">-    /// Root of index persistence dir</div><div class="diff-removed">-    path: PathBuf,</div><div class="diff-removed">-    /// Used to select unique point ids</div><div class="diff-removed">-    visited_pool: VisitedPool,</div><div class="diff-removed">-    storage_type: StorageType,</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> impl StructPayloadIndex {</div><div class="diff-removed">-    pub fn estimate_field_condition(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        condition: &FieldCondition,</div><div class="diff-removed">-        nested_path: Option<&JsonPath>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> Option<CardinalityEstimation> {</div><div class="diff-removed">-        let full_path = JsonPath::extend_or_new(nested_path, &condition.key);</div><div class="diff-removed">-        self.field_indexes.get(&full_path).and_then(|indexes| {</div><div class="diff-removed">-            // rewrite condition with fullpath to enable cardinality estimation</div><div class="diff-removed">-            let full_path_condition = FieldCondition {</div><div class="diff-removed">-                key: full_path,</div><div class="diff-removed">-                ..condition.clone()</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            indexes</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .find_map(|index| index.estimate_cardinality(&full_path_condition, hw_counter))</div><div class="diff-added">+    pub fn estimate_field_condition(&self, condition: &FieldCondition) -> Option<CardinalityEstimation> {</div><div class="diff-added">+        self.field_indexes.get(&condition.key).and_then(|indexes| {</div><div class="diff-added">+            let mut result_estimation: Option<CardinalityEstimation> = None;</div><div class="diff-added">+            for index in indexes {</div><div class="diff-added">+                result_estimation = index.estimate_cardinality(condition);</div><div class="diff-added">+                if result_estimation.is_some() {</div><div class="diff-added">+                    break;</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+            result_estimation</div><div>         })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn query_field<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        condition: &'a PrimaryCondition,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-removed">-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {</div><div class="diff-removed">-        match condition {</div><div class="diff-removed">-            PrimaryCondition::Condition(field_condition) => {</div><div class="diff-removed">-                let field_key = &field_condition.key;</div><div class="diff-removed">-                let field_indexes = self.field_indexes.get(field_key)?;</div><div class="diff-removed">-                field_indexes</div><div class="diff-removed">-                    .iter()</div><div class="diff-removed">-                    .find_map(|field_index| field_index.filter(field_condition, hw_counter))</div><div class="diff-removed">-            }</div><div class="diff-removed">-            PrimaryCondition::Ids(ids) => Some(Box::new(ids.iter().copied())),</div><div class="diff-removed">-            PrimaryCondition::HasVector(_) => None,</div><div class="diff-removed">-        }</div><div>     }</div><div> </div><div>     fn config_path(&self) -> PathBuf {</div><div class="diff-info">@@ -117,44 +59,60 @@         self.config.save(&config_path)</div><div>     }</div><div> </div><div class="diff-added">+    fn get_field_index_dir(path: &Path) -> PathBuf {</div><div class="diff-added">+        path.join(PAYLOAD_FIELD_INDEX_PATH)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn get_field_index_path(path: &Path, field: &PayloadKeyType) -> PathBuf {</div><div class="diff-added">+        Self::get_field_index_dir(path).join(format!("{}.idx", field))</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn save_field_index(&self, field: &PayloadKeyType) -> OperationResult<()> {</div><div class="diff-added">+        let field_index_dir = Self::get_field_index_dir(&self.path);</div><div class="diff-added">+        let field_index_path = Self::get_field_index_path(&self.path, field);</div><div class="diff-added">+        create_dir_all(field_index_dir)?;</div><div class="diff-added">+</div><div class="diff-added">+        match self.field_indexes.get(field) {</div><div class="diff-added">+            None => {},</div><div class="diff-added">+            Some(indexes) => {</div><div class="diff-added">+                let file = File::create(&field_index_path)?;</div><div class="diff-added">+                serde_cbor::to_writer(file, indexes).map_err(|err| {</div><div class="diff-added">+                    OperationError::ServiceError {</div><div class="diff-added">+                        description: format!("Unable to save index: {:?}", err),</div><div class="diff-added">+                    }</div><div class="diff-added">+                })?;</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn load_or_build_field_index(&self, field: &PayloadKeyType, payload_type: PayloadSchemaType) -> OperationResult<Vec<FieldIndex>> {</div><div class="diff-added">+        let field_index_path = Self::get_field_index_path(&self.path, field);</div><div class="diff-added">+        if field_index_path.exists() {</div><div class="diff-added">+            debug!("Loading field `{}` index from {}", field, field_index_path.to_str().unwrap());</div><div class="diff-added">+            let file = File::open(field_index_path)?;</div><div class="diff-added">+            let field_indexes: Vec<FieldIndex> = serde_cbor::from_reader(file).map_err(|err| {</div><div class="diff-added">+                OperationError::ServiceError { description: format!("Unable to load index: {:?}", err) }</div><div class="diff-added">+            })?;</div><div class="diff-added">+</div><div class="diff-added">+            Ok(field_indexes)</div><div class="diff-added">+        } else {</div><div class="diff-added">+            debug!("Index for field `{}` not found in {}, building now", field, field_index_path.to_str().unwrap());</div><div class="diff-added">+            let res = self.build_field_index(field, payload_type, &HardwareCounterCell::disposable())?; // Internal operation.</div><div class="diff-added">+            self.save_field_index(field)?;</div><div class="diff-added">+            Ok(res)</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     fn load_all_fields(&mut self) -> OperationResult<()> {</div><div>         let mut field_indexes: IndexesMap = Default::default();</div><div> </div><div>         for (field, payload_schema) in &self.config.indexed_fields {</div><div class="diff-removed">-            let field_index = self.load_from_db(field, payload_schema)?;</div><div class="diff-added">+            let field_index = self.load_or_build_field_index(field, payload_schema.to_owned())?;</div><div>             field_indexes.insert(field.clone(), field_index);</div><div>         }</div><div>         self.field_indexes = field_indexes;</div><div>         Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn load_from_db(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        field: PayloadKeyTypeRef,</div><div class="diff-removed">-        payload_schema: &PayloadFieldSchema,</div><div class="diff-removed">-    ) -> OperationResult<Vec<FieldIndex>> {</div><div class="diff-removed">-        let mut indexes = self</div><div class="diff-removed">-            .selector(payload_schema)</div><div class="diff-removed">-            .new_index(field, payload_schema)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut is_loaded = true;</div><div class="diff-removed">-        for ref mut index in indexes.iter_mut() {</div><div class="diff-removed">-            if !index.load()? {</div><div class="diff-removed">-                is_loaded = false;</div><div class="diff-removed">-                break;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if !is_loaded {</div><div class="diff-removed">-            debug!("Index for `{field}` was not loaded. Building...");</div><div class="diff-removed">-            // todo(ivan): decide what to do with indexes, which were not loaded</div><div class="diff-removed">-            indexes = self.build_field_indexes(</div><div class="diff-removed">-                field,</div><div class="diff-removed">-                payload_schema,</div><div class="diff-removed">-                &HardwareCounterCell::disposable(), // Internal operation.</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(indexes)</div><div>     }</div><div> </div><div>     pub fn open(</div><div class="diff-info">@@ -179,17 +137,13 @@         let skip_rocksdb = config.skip_rocksdb.unwrap_or(false);</div><div> </div><div>         let storage_type = if is_appendable {</div><div class="diff-removed">-            let db = open_db_with_existing_cf(path).map_err(|err| {</div><div class="diff-removed">-                OperationError::service_error(format!("RocksDB open error: {err}"))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-            StorageType::Appendable(db)</div><div class="diff-added">+            let db = open_db_with_existing_cf(path).map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;</div><div class="diff-added">+            StorageType::Appendable(Arc::new(RwLock::new(db)))</div><div>         } else if skip_rocksdb {</div><div>             StorageType::NonAppendable</div><div>         } else {</div><div class="diff-removed">-            let db = open_db_with_existing_cf(path).map_err(|err| {</div><div class="diff-removed">-                OperationError::service_error(format!("RocksDB open error: {err}"))</div><div class="diff-removed">-            })?;</div><div class="diff-removed">-            StorageType::NonAppendableRocksDb(db)</div><div class="diff-added">+            let db = open_db_with_existing_cf(path).map_err(|err| OperationError::service_error(format!("RocksDB open error: {err}")))?;</div><div class="diff-added">+            StorageType::NonAppendableRocksDb(Arc::new(RwLock::new(db)))</div><div>         };</div><div> </div><div>         let mut index = StructPayloadIndex {</div><div class="diff-info">@@ -204,7 +158,6 @@         };</div><div> </div><div>         if !index.config_path().exists() {</div><div class="diff-removed">-            // Save default config</div><div>             index.save_config()?;</div><div>         }</div><div> </div><div class="diff-info">@@ -245,6 +198,21 @@             .collect()</div><div>     }</div><div> </div><div class="diff-added">+    fn build_and_save(</div><div class="diff-added">+        &mut self,</div><div class="diff-added">+        field: PayloadKeyType,</div><div class="diff-added">+        payload_schema: PayloadFieldSchema,</div><div class="diff-added">+        field_index: Vec<FieldIndex>,</div><div class="diff-added">+    ) -> OperationResult<()> {</div><div class="diff-added">+        self.field_indexes.insert(field.clone(), field_index);</div><div class="diff-added">+</div><div class="diff-added">+        self.config.indexed_fields.insert(field, payload_schema);</div><div class="diff-added">+</div><div class="diff-added">+        self.save_config()?;</div><div class="diff-added">+</div><div class="diff-added">+        Ok(())</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     /// Number of available points</div><div>     ///</div><div>     /// - excludes soft deleted points</div><div class="diff-info">@@ -255,7 +223,7 @@     pub fn struct_filtered_context<'a>(</div><div>         &'a self,</div><div>         filter: &'a Filter,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+        hw_counter: &'a HardwareCounterCell,</div><div>     ) -> StructFilterContext<'a> {</div><div>         let payload_provider = PayloadProvider::new(self.payload.clone());</div><div> </div><div class="diff-info">@@ -304,13 +272,10 @@                     .filter_map(|external_id| id_tracker_ref.internal_id(*external_id))</div><div>                     .collect();</div><div>                 let num_ids = mapped_ids.len();</div><div class="diff-removed">-                CardinalityEstimation {</div><div class="diff-removed">-                    primary_clauses: vec![PrimaryCondition::Ids(mapped_ids)],</div><div class="diff-removed">-                    min: num_ids,</div><div class="diff-removed">-                    exp: num_ids,</div><div class="diff-removed">-                    max: num_ids,</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-added">+                CardinalityEstimation::exact(num_ids)</div><div class="diff-added">+                    .with_primary_clause(PrimaryCondition::Ids(mapped_ids))</div><div class="diff-added">+            }</div><div class="diff-added">+</div><div>             Condition::HasVector(has_vectors) => {</div><div>                 if let Some(vector_storage) = self.vector_storages.get(&has_vectors.has_vector) {</div><div>                     let vector_storage = vector_storage.borrow();</div><div class="diff-info">@@ -332,79 +297,6 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn get_telemetry_data(&self) -> Vec<PayloadIndexTelemetry> {</div><div class="diff-removed">-        self.field_indexes</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .flat_map(|(name, field)| -> Vec<PayloadIndexTelemetry> {</div><div class="diff-removed">-                field</div><div class="diff-removed">-                    .iter()</div><div class="diff-removed">-                    .map(|field| field.get_telemetry_data().set_name(name.to_string()))</div><div class="diff-removed">-                    .collect()</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn restore_database_snapshot(</div><div class="diff-removed">-        snapshot_path: &Path,</div><div class="diff-removed">-        segment_path: &Path,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        crate::rocksdb_backup::restore(snapshot_path, &segment_path.join("payload_index"))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn clear_index_for_point(&mut self, point_id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-removed">-        for (_, field_indexes) in self.field_indexes.iter_mut() {</div><div class="diff-removed">-            for index in field_indexes {</div><div class="diff-removed">-                index.remove_point(point_id)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-    pub fn config(&self) -> &PayloadConfig {</div><div class="diff-removed">-        &self.config</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn iter_filtered_points<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: &'a Filter,</div><div class="diff-removed">-        id_tracker: &'a IdTrackerSS,</div><div class="diff-removed">-        query_cardinality: &'a CardinalityEstimation,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-removed">-    ) -> impl Iterator<Item = PointOffsetType> + 'a {</div><div class="diff-removed">-        let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);</div><div class="diff-removed">-</div><div class="diff-removed">-        if query_cardinality.primary_clauses.is_empty() {</div><div class="diff-removed">-            let full_scan_iterator = id_tracker.iter_ids();</div><div class="diff-removed">-</div><div class="diff-removed">-            // Worst case: query expected to return few matches, but index can't be used</div><div class="diff-removed">-            let matched_points =</div><div class="diff-removed">-                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));</div><div class="diff-removed">-</div><div class="diff-removed">-            Either::Left(matched_points)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            // CPU-optimized strategy here: points are made unique before applying other filters.</div><div class="diff-removed">-            let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());</div><div class="diff-removed">-</div><div class="diff-removed">-            let iter = query_cardinality</div><div class="diff-removed">-                .primary_clauses</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .flat_map(move |clause| {</div><div class="diff-removed">-                    self.query_field(clause, hw_counter).unwrap_or_else(|| {</div><div class="diff-removed">-                        // index is not built</div><div class="diff-removed">-                        Box::new(id_tracker.iter_ids().measure_hw_with_cell(</div><div class="diff-removed">-                            hw_counter,</div><div class="diff-removed">-                            size_of::<PointOffsetType>(),</div><div class="diff-removed">-                            |i| i.cpu_counter(),</div><div class="diff-removed">-                        ))</div><div class="diff-removed">-                    })</div><div class="diff-removed">-                })</div><div class="diff-removed">-                .filter(move |&id| !visited_list.check_and_update_visited(id))</div><div class="diff-removed">-                .filter(move |&i| struct_filtered_context.check(i));</div><div class="diff-removed">-</div><div class="diff-removed">-            Either::Right(iter)</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Select which type of PayloadIndex to use for the field</div><div>     fn selector(&self, payload_schema: &PayloadFieldSchema) -> IndexSelector {</div><div>         let is_on_disk = payload_schema.is_on_disk();</div><div> </div><div class="diff-info">@@ -434,46 +326,68 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn get_facet_index(&self, key: &JsonPath) -> OperationResult<FacetIndexEnum> {</div><div class="diff-removed">-        self.field_indexes</div><div class="diff-removed">-            .get(key)</div><div class="diff-removed">-            .and_then(|index| index.iter().find_map(|index| index.as_facet_index()))</div><div class="diff-removed">-            .ok_or_else(|| OperationError::MissingMapIndexForFacet {</div><div class="diff-removed">-                key: key.to_string(),</div><div class="diff-removed">-            })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn populate(&self) -> OperationResult<()> {</div><div class="diff-removed">-        for (_, field_indexes) in self.field_indexes.iter() {</div><div class="diff-removed">-            for index in field_indexes {</div><div class="diff-removed">-                index.populate()?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn clear_cache(&self) -> OperationResult<()> {</div><div class="diff-removed">-        for (_, field_indexes) in self.field_indexes.iter() {</div><div class="diff-removed">-            for index in field_indexes {</div><div class="diff-removed">-                index.clear_cache()?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn clear_cache_if_on_disk(&self) -> OperationResult<()> {</div><div class="diff-removed">-        for (_, field_indexes) in self.field_indexes.iter() {</div><div class="diff-removed">-            for index in field_indexes {</div><div class="diff-removed">-                if index.is_on_disk() {</div><div class="diff-removed">-                    index.clear_cache()?;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl PayloadIndex for StructPayloadIndex {</div><div class="diff-added">+    pub fn estimate_cardinality(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        query: &Filter,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> CardinalityEstimation {</div><div class="diff-added">+        let available_points = self.available_point_count();</div><div class="diff-added">+        let estimator =</div><div class="diff-added">+            |condition: &Condition| self.condition_cardinality(condition, None, hw_counter);</div><div class="diff-added">+        estimate_filter(&estimator, query, available_points)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn estimate_nested_cardinality(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        query: &Filter,</div><div class="diff-added">+        nested_path: &JsonPath,</div><div class="diff-added">+        hw_counter: &HardwareCounterCell,</div><div class="diff-added">+    ) -> CardinalityEstimation {</div><div class="diff-added">+        let available_points = self.available_point_count();</div><div class="diff-added">+        let estimator = |condition: &Condition| {</div><div class="diff-added">+            self.condition_cardinality(condition, Some(nested_path), hw_counter)</div><div class="diff-added">+        };</div><div class="diff-added">+        estimate_filter(&estimator, query, available_points)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn iter_filtered_points<'a>(</div><div class="diff-added">+        &'a self,</div><div class="diff-added">+        filter: &'a Filter,</div><div class="diff-added">+        id_tracker: &'a IdTrackerSS,</div><div class="diff-added">+        query_cardinality: &'a CardinalityEstimation,</div><div class="diff-added">+        hw_counter: &'a HardwareCounterCell,</div><div class="diff-added">+    ) -> impl Iterator<Item = PointOffsetType> + 'a {</div><div class="diff-added">+        let struct_filtered_context = self.struct_filtered_context(filter, hw_counter);</div><div class="diff-added">+</div><div class="diff-added">+        if query_cardinality.primary_clauses.is_empty() {</div><div class="diff-added">+            let full_scan_iterator = id_tracker.iter_ids();</div><div class="diff-added">+</div><div class="diff-added">+            // Worst case: query expected to return few matches, but index can't be used</div><div class="diff-added">+            let matched_points =</div><div class="diff-added">+                full_scan_iterator.filter(move |i| struct_filtered_context.check(*i));</div><div class="diff-added">+</div><div class="diff-added">+            Either::Left(matched_points)</div><div class="diff-added">+        } else {</div><div class="diff-added">+            // CPU-optimized strategy here: points are made unique before applying other filters.</div><div class="diff-added">+            let mut visited_list = self.visited_pool.get(id_tracker.total_point_count());</div><div class="diff-added">+</div><div class="diff-added">+            let iter = query_cardinality</div><div class="diff-added">+                .primary_clauses</div><div class="diff-added">+                .iter()</div><div class="diff-added">+                .flat_map(move |clause| {</div><div class="diff-added">+                    self.query_field(clause, hw_counter)</div><div class="diff-added">+                        .unwrap_or_else(|| id_tracker.iter_ids() /* index is not built */)</div><div class="diff-added">+                })</div><div class="diff-added">+                .filter(move |&id| !visited_list.check_and_update_visited(id))</div><div class="diff-added">+                .filter(move |&i| struct_filtered_context.check(i));</div><div class="diff-added">+</div><div class="diff-added">+            Either::Right(iter)</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    // Set of public functions that implement PayloadIndex trait.</div><div class="diff-added">+    // Rest of the functions are public only for testing purposes.</div><div class="diff-added">+</div><div>     fn indexed_fields(&self) -> HashMap<PayloadKeyType, PayloadFieldSchema> {</div><div>         self.config.indexed_fields.clone()</div><div>     }</div><div class="diff-info">@@ -482,7 +396,6 @@         &self,</div><div>         field: PayloadKeyTypeRef,</div><div>         payload_schema: &PayloadFieldSchema,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div>     ) -> OperationResult<Option<Vec<FieldIndex>>> {</div><div>         if let Some(prev_schema) = self.config.indexed_fields.get(field) {</div><div>             // the field is already indexed with the same schema</div><div class="diff-info">@@ -492,7 +405,7 @@             }</div><div>         }</div><div> </div><div class="diff-removed">-        let indexes = self.build_field_indexes(field, payload_schema, hw_counter)?;</div><div class="diff-added">+        let indexes = self.build_field_indexes(field, payload_schema, hw_counter)?; // Internal operation.</div><div> </div><div>         Ok(Some(indexes))</div><div>     }</div><div class="diff-info">@@ -512,119 +425,7 @@         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    fn drop_index(&mut self, field: PayloadKeyTypeRef) -> OperationResult<()> {</div><div class="diff-removed">-        self.config.indexed_fields.remove(field);</div><div class="diff-removed">-        let removed_indexes = self.field_indexes.remove(field);</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(indexes) = removed_indexes {</div><div class="diff-removed">-            for index in indexes {</div><div class="diff-removed">-                index.cleanup()?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.save_config()?;</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn estimate_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        query: &Filter,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CardinalityEstimation {</div><div class="diff-removed">-        let available_points = self.available_point_count();</div><div class="diff-removed">-        let estimator =</div><div class="diff-removed">-            |condition: &Condition| self.condition_cardinality(condition, None, hw_counter);</div><div class="diff-removed">-        estimate_filter(&estimator, query, available_points)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn estimate_nested_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        query: &Filter,</div><div class="diff-removed">-        nested_path: &JsonPath,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CardinalityEstimation {</div><div class="diff-removed">-        let available_points = self.available_point_count();</div><div class="diff-removed">-        let estimator = |condition: &Condition| {</div><div class="diff-removed">-            self.condition_cardinality(condition, Some(nested_path), hw_counter)</div><div class="diff-removed">-        };</div><div class="diff-removed">-        estimate_filter(&estimator, query, available_points)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn query_points(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        query: &Filter,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> Vec<PointOffsetType> {</div><div class="diff-removed">-        // Assume query is already estimated to be small enough so we can iterate over all matched ids</div><div class="diff-removed">-        let query_cardinality = self.estimate_cardinality(query, hw_counter);</div><div class="diff-removed">-        let id_tracker = self.id_tracker.borrow();</div><div class="diff-removed">-        self.iter_filtered_points(query, &*id_tracker, &query_cardinality, hw_counter)</div><div class="diff-removed">-            .collect()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn indexed_points(&self, field: PayloadKeyTypeRef) -> usize {</div><div class="diff-removed">-        self.field_indexes.get(field).map_or(0, |indexes| {</div><div class="diff-removed">-            // Assume that multiple field indexes are applied to the same data type,</div><div class="diff-removed">-            // so the points indexed with those indexes are the same.</div><div class="diff-removed">-            // We will return minimal number as a worst case, to highlight possible errors in the index early.</div><div class="diff-removed">-            indexes</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .map(|index| index.count_indexed_points())</div><div class="diff-removed">-                .min()</div><div class="diff-removed">-                .unwrap_or(0)</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn filter_context<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        filter: &'a Filter,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> Box<dyn FilterContext + 'a> {</div><div class="diff-removed">-        Box::new(self.struct_filtered_context(filter, hw_counter))</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn payload_blocks(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        field: PayloadKeyTypeRef,</div><div class="diff-removed">-        threshold: usize,</div><div class="diff-removed">-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div class="diff-removed">-        match self.field_indexes.get(field) {</div><div class="diff-removed">-            None => Box::new(vec![].into_iter()),</div><div class="diff-removed">-            Some(indexes) => {</div><div class="diff-removed">-                let field_clone = field.to_owned();</div><div class="diff-removed">-                Box::new(indexes.iter().flat_map(move |field_index| {</div><div class="diff-removed">-                    field_index.payload_blocks(threshold, field_clone.clone())</div><div class="diff-removed">-                }))</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn overwrite_payload(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        point_id: PointOffsetType,</div><div class="diff-removed">-        payload: &Payload,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        self.payload</div><div class="diff-removed">-            .borrow_mut()</div><div class="diff-removed">-            .overwrite(point_id, payload, hw_counter)?;</div><div class="diff-removed">-</div><div class="diff-removed">-        for (field, field_index) in &mut self.field_indexes {</div><div class="diff-removed">-            let field_value = payload.get_value(field);</div><div class="diff-removed">-            if !field_value.is_empty() {</div><div class="diff-removed">-                for index in field_index {</div><div class="diff-removed">-                    index.add_point(point_id, &field_value, hw_counter)?;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                for index in field_index {</div><div class="diff-removed">-                    index.remove_point(point_id)?;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn set_payload(</div><div class="diff-added">+    fn assign(</div><div>         &mut self,</div><div>         point_id: PointOffsetType,</div><div>         payload: &Payload,</div><div class="diff-info">@@ -653,7 +454,7 @@                 }</div><div>             } else {</div><div>                 for index in field_index {</div><div class="diff-removed">-                    index.remove_point(point_id)?;</div><div class="diff-added">+                    index.remove_point(point_id, hw_counter)?;</div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-info">@@ -676,7 +477,7 @@     ) -> OperationResult<Vec<Value>> {</div><div>         if let Some(indexes) = self.field_indexes.get_mut(key) {</div><div>             for index in indexes {</div><div class="diff-removed">-                index.remove_point(point_id)?;</div><div class="diff-added">+                index.remove_point(point_id, hw_counter)?;</div><div>             }</div><div>         }</div><div>         self.payload.borrow_mut().delete(point_id, key, hw_counter)</div><div class="diff-info">@@ -687,13 +488,13 @@         point_id: PointOffsetType,</div><div>         hw_counter: &HardwareCounterCell,</div><div>     ) -> OperationResult<Option<Payload>> {</div><div class="diff-removed">-        self.clear_index_for_point(point_id)?;</div><div class="diff-added">+        self.clear_index_for_point(point_id, hw_counter)?;</div><div>         self.payload.borrow_mut().clear(point_id, hw_counter)</div><div>     }</div><div> </div><div>     fn flusher(&self) -> Flusher {</div><div>         let mut flushers = Vec::new();</div><div class="diff-removed">-        for field_indexes in self.field_indexes.values() {</div><div class="diff-added">+        for (_, field_indexes) in self.field_indexes.iter() {</div><div>             for index in field_indexes {</div><div>                 flushers.push(index.flusher());</div><div>             }</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    