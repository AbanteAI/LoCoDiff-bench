<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - Grok 3 Mini</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/x-ai_grok-3-mini-beta.html">‚Üê Back to Grok 3 Mini Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Grok 3 Mini</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 60371</p>
                <p><strong>Native Completion Tokens:</strong> 12806</p>
                <p><strong>Native Tokens Reasoning:</strong> 7136</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.0245143</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/x-ai_grok-3-mini-beta/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -1,25 +1,23 @@ use std::cmp::min;</div><div> use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div class="diff-added">+use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> use std::sync::Arc;</div><div class="diff-removed">-use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> </div><div> use common::budget::ResourceBudget;</div><div class="diff-removed">-use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div> use common::counter::hardware_counter::HardwareCounterCell;</div><div> use common::panic;</div><div> use itertools::Itertools;</div><div> use log::{debug, error, info, trace, warn};</div><div> use parking_lot::Mutex;</div><div> use segment::common::operation_error::OperationResult;</div><div class="diff-removed">-use segment::index::hnsw_index::num_rayon_threads;</div><div> use segment::types::SeqNumberType;</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::{self, Receiver, Sender};</div><div class="diff-removed">-use tokio::sync::{Mutex as TokioMutex, oneshot};</div><div class="diff-added">+use tokio::sync::{oneshot, Mutex as TokioMutex};</div><div> use tokio::task::{self, JoinHandle};</div><div> use tokio::time::error::Elapsed;</div><div class="diff-removed">-use tokio::time::{Duration, timeout};</div><div class="diff-added">+use tokio::time::{timeout, Duration};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_manager::collection_updater::CollectionUpdater;</div><div class="diff-info">@@ -28,102 +26,62 @@     OptimizerThresholds, SegmentOptimizer,</div><div> };</div><div> use crate::collection_manager::optimizers::{Tracker, TrackerLog, TrackerStatus};</div><div class="diff-removed">-use crate::common::stoppable_task::{StoppableTaskHandle, spawn_stoppable};</div><div class="diff-added">+use crate::common::stoppable_task::{spawn_stoppable, StoppableTaskHandle};</div><div> use crate::config::CollectionParams;</div><div class="diff-removed">-use crate::operations::CollectionUpdateOperations;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult};</div><div class="diff-added">+use crate::operations::CollectionUpdateOperations;</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::local_shard::LocalShardClocks;</div><div> use crate::wal::WalError;</div><div> use crate::wal_delta::LockedWal;</div><div> </div><div class="diff-removed">-/// Interval at which the optimizer worker cleans up old optimization handles</div><div class="diff-removed">-///</div><div class="diff-removed">-/// The longer the duration, the longer it  takes for panicked tasks to be reported.</div><div> const OPTIMIZER_CLEANUP_INTERVAL: Duration = Duration::from_secs(5);</div><div> </div><div> pub type Optimizer = dyn SegmentOptimizer + Sync + Send;</div><div> </div><div class="diff-removed">-/// Information, required to perform operation and notify regarding the result</div><div> #[derive(Debug)]</div><div> pub struct OperationData {</div><div class="diff-removed">-    /// Sequential number of the operation</div><div>     pub op_num: SeqNumberType,</div><div class="diff-removed">-    /// Operation</div><div>     pub operation: CollectionUpdateOperations,</div><div class="diff-removed">-    /// If operation was requested to wait for result</div><div>     pub wait: bool,</div><div class="diff-removed">-    /// Callback notification channel</div><div>     pub sender: Option<oneshot::Sender<CollectionResult<usize>>>,</div><div class="diff-removed">-    pub hw_measurements: HwMeasurementAcc,</div><div class="diff-added">+    pub hw_measurements: common::counter::hardware_accumulator::HwMeasurementAcc,</div><div> }</div><div> </div><div class="diff-removed">-/// Signal, used to inform Updater process</div><div class="diff-removed">-#[derive(Debug)]</div><div> pub enum UpdateSignal {</div><div class="diff-removed">-    /// Requested operation to perform</div><div>     Operation(OperationData),</div><div class="diff-removed">-    /// Stop all optimizers and listening</div><div>     Stop,</div><div class="diff-removed">-    /// Empty signal used to trigger optimizers</div><div>     Nop,</div><div class="diff-removed">-    /// Ensures that previous updates are applied</div><div>     Plunger(oneshot::Sender<()>),</div><div> }</div><div> </div><div class="diff-removed">-/// Signal, used to inform Optimization process</div><div class="diff-removed">-#[derive(PartialEq, Eq, Clone, Copy)]</div><div> pub enum OptimizerSignal {</div><div class="diff-removed">-    /// Sequential number of the operation</div><div>     Operation(SeqNumberType),</div><div class="diff-removed">-    /// Stop all optimizers and listening</div><div class="diff-added">+    Nop,</div><div>     Stop,</div><div class="diff-removed">-    /// Empty signal used to trigger optimizers</div><div class="diff-removed">-    Nop,</div><div> }</div><div> </div><div class="diff-removed">-/// Structure, which holds object, required for processing updates of the collection</div><div> pub struct UpdateHandler {</div><div>     shared_storage_config: Arc<SharedStorageConfig>,</div><div>     payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-    /// List of used optimizers</div><div>     pub optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-    /// Log of optimizer statuses</div><div>     optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-removed">-    /// Total number of optimized points since last start</div><div>     total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-    /// Global CPU budget in number of cores for all optimization tasks.</div><div class="diff-removed">-    /// Assigns CPU permits to tasks to limit overall resource utilization.</div><div>     optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    /// How frequent can we flush data</div><div class="diff-removed">-    /// This parameter depends on the optimizer config and should be updated accordingly.</div><div class="diff-removed">-    pub flush_interval_sec: u64,</div><div class="diff-added">+    flush_interval_sec: u64,</div><div>     segments: LockedSegmentHolder,</div><div class="diff-removed">-    /// Process, that listens updates signals and perform updates</div><div>     update_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Process, that listens for post-update signals and performs optimization</div><div>     optimizer_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Process that periodically flushes segments and tries to truncate wal</div><div>     flush_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Sender to stop flush worker</div><div>     flush_stop: Option<oneshot::Sender<()>>,</div><div>     runtime_handle: Handle,</div><div class="diff-removed">-    /// WAL, required for operations</div><div>     wal: LockedWal,</div><div class="diff-removed">-    /// Always keep this WAL version and later and prevent acknowledging/truncating from the WAL.</div><div class="diff-removed">-    /// This is used when other bits of code still depend on information in the WAL, such as the</div><div class="diff-removed">-    /// queue proxy shard.</div><div class="diff-removed">-    /// Defaults to `u64::MAX` to allow acknowledging all confirmed versions.</div><div class="diff-removed">-    pub(super) wal_keep_from: Arc<AtomicU64>,</div><div class="diff-added">+    wal_keep_from: Arc<AtomicU64>,</div><div>     optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    /// Maximum number of concurrent optimization jobs in this update handler.</div><div class="diff-removed">-    /// This parameter depends on the optimizer config and should be updated accordingly.</div><div class="diff-removed">-    pub max_optimization_threads: Option<usize>,</div><div class="diff-removed">-    /// Highest and cutoff clocks for the shard WAL.</div><div class="diff-added">+    max_optimization_threads: Option<usize>,</div><div>     clocks: LocalShardClocks,</div><div>     shard_path: PathBuf,</div><div class="diff-removed">-    /// Whether we have ever triggered optimizers since starting.</div><div>     has_triggered_optimizers: Arc<AtomicBool>,</div><div> }</div><div> </div><div class="diff-info">@@ -158,7 +116,7 @@             flush_stop: None,</div><div>             runtime_handle,</div><div>             wal,</div><div class="diff-removed">-            wal_keep_from: Arc::new(u64::MAX.into()),</div><div class="diff-added">+            wal_keep_from: Arc::new(0.into()),</div><div>             flush_interval_sec,</div><div>             optimization_handles: Arc::new(TokioMutex::new(vec![])),</div><div>             max_optimization_threads,</div><div class="diff-info">@@ -203,16 +161,31 @@         self.flush_stop = Some(flush_tx);</div><div>     }</div><div> </div><div class="diff-added">+    pub fn stop_workers(self) -> JoinHandle<()> {</div><div class="diff-added">+        self.runtime_handle.spawn(async move {</div><div class="diff-added">+            if let Some(wal) = self.wal.into_inner() {</div><div class="diff-added">+                wal.shutdown().await;</div><div class="diff-added">+            }</div><div class="diff-added">+            if let Some(handle) = self.update_worker {</div><div class="diff-added">+                handle.await.unwrap();</div><div class="diff-added">+            }</div><div class="diff-added">+            if let Some(handle) = self.optimizer_worker {</div><div class="diff-added">+                handle.await.unwrap();</div><div class="diff-added">+            }</div><div class="diff-added">+            if let Some(handle) = self.flush_worker {</div><div class="diff-added">+                handle.await.unwrap();</div><div class="diff-added">+            }</div><div class="diff-added">+        })</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub fn stop_flush_worker(&mut self) {</div><div>         if let Some(flush_stop) = self.flush_stop.take() {</div><div>             if let Err(()) = flush_stop.send(()) {</div><div class="diff-removed">-                warn!("Failed to stop flush worker as it is already stopped.");</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Gracefully wait before all optimizations stop</div><div class="diff-removed">-    /// If some optimization is in progress - it will be finished before shutdown.</div><div class="diff-added">+                debug!("Failed to stop flush worker for shard {}", self.shard_path.display());</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub async fn wait_workers_stops(&mut self) -> CollectionResult<()> {</div><div>         let maybe_handle = self.update_worker.take();</div><div>         if let Some(handle) = maybe_handle {</div><div class="diff-info">@@ -226,24 +199,14 @@         if let Some(handle) = maybe_handle {</div><div>             handle.await?;</div><div>         }</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut opt_handles_guard = self.optimization_handles.lock().await;</div><div class="diff-removed">-        let opt_handles = std::mem::take(&mut *opt_handles_guard);</div><div class="diff-removed">-        let stopping_handles = opt_handles</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .filter_map(|h| h.stop())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for res in stopping_handles {</div><div class="diff-removed">-            res.await?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-added">+        Self::cleanup_optimization_handles(self.optimization_handles.clone()).await;</div><div class="diff-added">+        let mut update_clocks = self.clocks.highest.write().await;</div><div class="diff-added">+        update_clocks.apply_cutoff(self.clocks.cutoff.blocking_read());</div><div class="diff-added">+        let mut opt_handles_guard = self.optimization_handles.blocking_lock();</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    /// Checks if there are any failed operations.</div><div class="diff-removed">-    /// If so - attempts to re-apply all failed operations.</div><div class="diff-removed">-    async fn try_recover(segments: LockedSegmentHolder, wal: LockedWal) -> CollectionResult<usize> {</div><div class="diff-added">+    fn try_recover(segments: LockedSegmentHolder, wal: LockedWal) -> CollectionResult<usize> {</div><div>         // Try to re-apply everything starting from the first failed operation</div><div>         let first_failed_operation_option = segments.read().failed_operation.iter().cloned().min();</div><div>         match first_failed_operation_option {</div><div class="diff-info">@@ -255,17 +218,15 @@                         &segments,</div><div>                         op_num,</div><div>                         operation.operation,</div><div class="diff-removed">-                        &HardwareCounterCell::disposable(), // Internal operation, no measurement needed</div><div class="diff-added">+                        &operation.hw_measurements.get_counter_cell(), // Internal operation, no measurement needed</div><div>                     )?;</div><div>                 }</div><div>             }</div><div>         };</div><div class="diff-added">+</div><div>         Ok(0)</div><div>     }</div><div> </div><div class="diff-removed">-    /// Checks conditions for all optimizers until there is no suggested segment</div><div class="diff-removed">-    /// Starts a task for each optimization</div><div class="diff-removed">-    /// Returns handles for started tasks</div><div>     pub(crate) fn launch_optimization<F>(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>         optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-info">@@ -274,13 +235,12 @@         segments: LockedSegmentHolder,</div><div>         callback: F,</div><div>         limit: Option<usize>,</div><div class="diff-removed">-    ) -> Vec<StoppableTaskHandle<bool>></div><div class="diff-removed">-    where</div><div class="diff-added">+    ) where</div><div>         F: Fn(bool) + Send + Clone + Sync + 'static,</div><div>     {</div><div>         let mut scheduled_segment_ids = HashSet::<_>::default();</div><div>         let mut handles = vec![];</div><div class="diff-removed">-</div><div class="diff-added">+        </div><div>         'outer: for optimizer in optimizers.iter() {</div><div>             loop {</div><div>                 // Return early if we reached the optimization job limit</div><div class="diff-info">@@ -301,7 +261,9 @@                 // And use same amount of IO threads as CPUs</div><div>                 let max_indexing_threads = optimizer.hnsw_config().max_indexing_threads;</div><div>                 let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-removed">-                let Some(mut permit) = optimizer_resource_budget.try_acquire(0, desired_io) else {</div><div class="diff-added">+                let Some(mut permit) =</div><div class="diff-added">+                    optimizer_resource_budget.try_acquire(0, desired_io)</div><div class="diff-added">+                else {</div><div>                     // If there is no Resource budget, break outer loop and return early</div><div>                     // If we have no handles (no optimizations) trigger callback so that we wake up</div><div>                     // our optimization worker to try again later, otherwise it could get stuck</div><div class="diff-info">@@ -391,7 +353,7 @@                     },</div><div>                     // Panic handler</div><div>                     Some(Box::new(move |panic_payload| {</div><div class="diff-removed">-                        let message = panic::downcast_str(&panic_payload).unwrap_or("");</div><div class="diff-added">+                        let message = common::panic::downcast_str(&panic_payload).unwrap_or("");</div><div>                         let separator = if !message.is_empty() { ": " } else { "" };</div><div> </div><div>                         warn!(</div><div class="diff-info">@@ -507,40 +469,6 @@         handles.append(&mut new_handles);</div><div>     }</div><div> </div><div class="diff-removed">-    /// Cleanup finalized optimization task handles</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This finds and removes completed tasks from our list of optimization handles.</div><div class="diff-removed">-    /// It also propagates any panics (and unknown errors) so we properly handle them if desired.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It is essential to call this every once in a while for handling panics in time.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns true if any optimization handle was finished, joined and removed.</div><div class="diff-removed">-    async fn cleanup_optimization_handles(</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    ) -> bool {</div><div class="diff-removed">-        // Remove finished handles</div><div class="diff-removed">-        let finished_handles: Vec<_> = {</div><div class="diff-removed">-            let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-            (0..handles.len())</div><div class="diff-removed">-                .filter(|i| handles[*i].is_finished())</div><div class="diff-removed">-                .collect::<Vec<_>>()</div><div class="diff-removed">-                .into_iter()</div><div class="diff-removed">-                .rev()</div><div class="diff-removed">-                .map(|i| handles.swap_remove(i))</div><div class="diff-removed">-                .collect()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let finished_any = !finished_handles.is_empty();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Finalize all finished handles to propagate panics</div><div class="diff-removed">-        for handle in finished_handles {</div><div class="diff-removed">-            handle.join_and_handle_panic().await;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        finished_any</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div>     async fn optimization_worker_fn(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>         sender: Sender<OptimizerSignal>,</div><div class="diff-info">@@ -553,7 +481,6 @@         optimizer_resource_budget: ResourceBudget,</div><div>         max_handles: Option<usize>,</div><div>         has_triggered_optimizers: Arc<AtomicBool>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>     ) {</div><div>         let max_handles = max_handles.unwrap_or(usize::MAX);</div><div>         let max_indexing_threads = optimizers</div><div class="diff-info">@@ -561,7 +488,6 @@             .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div>             .unwrap_or_default();</div><div> </div><div class="diff-removed">-        // Asynchronous task to trigger optimizers once CPU budget is available again</div><div>         let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div> </div><div>         loop {</div><div class="diff-info">@@ -624,10 +550,7 @@                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            if Self::try_recover(segments.clone(), wal.clone())</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .is_err()</div><div class="diff-removed">-            {</div><div class="diff-added">+            if Self::try_recover(segments.clone(), wal.clone()).is_err() {</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-info">@@ -641,12 +564,14 @@                     .as_ref()</div><div>                     .is_some_and(|t| !t.is_finished());</div><div>                 if !trigger_active {</div><div class="diff-removed">-                    resource_available_trigger.replace(trigger_optimizers_on_resource_budget(</div><div class="diff-removed">-                        optimizer_resource_budget.clone(),</div><div class="diff-removed">-                        desired_cpus,</div><div class="diff-removed">-                        desired_io,</div><div class="diff-removed">-                        sender.clone(),</div><div class="diff-removed">-                    ));</div><div class="diff-added">+                    resource_available_trigger.replace(</div><div class="diff-added">+                        trigger_optimizers_on_resource_budget(</div><div class="diff-added">+                            optimizer_resource_budget.clone(),</div><div class="diff-added">+                            desired_cpus,</div><div class="diff-added">+                            desired_io,</div><div class="diff-added">+                            sender.clone(),</div><div class="diff-added">+                        ),</div><div class="diff-added">+                    );</div><div>                 }</div><div>                 continue;</div><div>             }</div><div class="diff-info">@@ -671,8 +596,7 @@                 &optimizer_resource_budget,</div><div>                 sender.clone(),</div><div>                 limit,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await;</div><div class="diff-added">+            ).await;</div><div>         }</div><div>     }</div><div> </div><div class="diff-info">@@ -714,14 +638,17 @@                         Ok(update_res) => optimize_sender</div><div>                             .send(OptimizerSignal::Operation(op_num))</div><div>                             .await</div><div class="diff-removed">-                            .and(Ok(update_res))</div><div class="diff-removed">-                            .map_err(|send_err| send_err.into()),</div><div class="diff-added">+                            .map(|()| update_res)</div><div class="diff-added">+                            .map_err(|err| {</div><div class="diff-added">+                                CollectionError::service_error(format!("{err}"))</div><div class="diff-added">+                            }),</div><div>                         Err(err) => Err(err),</div><div>                     };</div><div class="diff-removed">-</div><div>                     if let Some(feedback) = sender {</div><div>                         feedback.send(res).unwrap_or_else(|_| {</div><div class="diff-removed">-                            debug!("Can't report operation {op_num} result. Assume already not required");</div><div class="diff-added">+                            debug!(</div><div class="diff-added">+                                "Can't report operation {op_num} result. Assume already not required",</div><div class="diff-added">+                            );</div><div>                         });</div><div>                     };</div><div>                 }</div><div class="diff-info">@@ -732,14 +659,16 @@                         .unwrap_or_else(|_| debug!("Optimizer already stopped"));</div><div>                     break;</div><div>                 }</div><div class="diff-removed">-                UpdateSignal::Nop => optimize_sender</div><div class="diff-removed">-                    .send(OptimizerSignal::Nop)</div><div class="diff-removed">-                    .await</div><div class="diff-removed">-                    .unwrap_or_else(|_| {</div><div class="diff-removed">-                        info!(</div><div class="diff-removed">-                            "Can't notify optimizers, assume process is dead. Restart is required"</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                    }),</div><div class="diff-added">+                UpdateSignal::Nop => {</div><div class="diff-added">+                    optimize_sender</div><div class="diff-added">+                        .send(OptimizerSignal::Nop)</div><div class="diff-added">+                        .await</div><div class="diff-added">+                        .unwrap_or_else(|_| {</div><div class="diff-added">+                            debug!(</div><div class="diff-added">+                                "Can't notify optimizers, assume process is dead. Restart is required"</div><div class="diff-added">+                            );</div><div class="diff-added">+                        })</div><div class="diff-added">+                }</div><div>                 UpdateSignal::Plunger(callback_sender) => {</div><div>                     callback_sender.send(()).unwrap_or_else(|_| {</div><div>                         debug!("Can't notify sender, assume nobody is waiting anymore");</div><div class="diff-info">@@ -747,7 +676,7 @@                 }</div><div>             }</div><div>         }</div><div class="diff-removed">-        // Transmitter was destroyed</div><div class="diff-added">+</div><div>         optimize_sender</div><div>             .send(OptimizerSignal::Stop)</div><div>             .await</div><div class="diff-info">@@ -764,15 +693,13 @@         shard_path: PathBuf,</div><div>     ) {</div><div>         loop {</div><div class="diff-removed">-            // Stop flush worker on signal or if sender was dropped</div><div class="diff-removed">-            // Even if timer did not finish</div><div>             tokio::select! {</div><div>                 _ = tokio::time::sleep(Duration::from_secs(flush_interval_sec)) => {},</div><div>                 _ = &mut stop_receiver => {</div><div>                     debug!("Stopping flush worker for shard {}", shard_path.display());</div><div>                     return;</div><div>                 }</div><div class="diff-removed">-            }</div><div class="diff-added">+            };</div><div> </div><div>             trace!("Attempting flushing");</div><div>             let wal_flash_job = wal.lock().await.flush_async();</div><div class="diff-info">@@ -802,7 +729,7 @@             // This is to prevent truncating WAL entries that other bits of code still depend on</div><div>             // such as the queue proxy shard.</div><div>             // Default keep_from is `u64::MAX` to allow acknowledging all confirmed.</div><div class="diff-removed">-            let keep_from = wal_keep_from.load(std::sync::atomic::Ordering::Relaxed);</div><div class="diff-added">+            let keep_from = wal_keep_from.load(Ordering::Relaxed);</div><div> </div><div>             // If we should keep the first message, do not acknowledge at all</div><div>             if keep_from == 0 {</div><div class="diff-info">@@ -823,9 +750,6 @@         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Returns confirmed version after flush of all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Errors</div><div>     /// Returns an error on flush failure</div><div>     fn flush_segments(segments: LockedSegmentHolder) -> OperationResult<SeqNumberType> {</div><div>         let read_segments = segments.read();</div><div class="diff-info">@@ -835,25 +759,4 @@             Some(failed_operation) => min(failed_operation, flushed_version),</div><div>         })</div><div>     }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Trigger optimizers when CPU budget is available</div><div class="diff-removed">-fn trigger_optimizers_on_resource_budget(</div><div class="diff-removed">-    optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    desired_cpus: usize,</div><div class="diff-removed">-    desired_io: usize,</div><div class="diff-removed">-    sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-) -> JoinHandle<()> {</div><div class="diff-removed">-    task::spawn(async move {</div><div class="diff-removed">-        log::trace!("Skipping optimization checks, waiting for CPU budget to be available");</div><div class="diff-removed">-        optimizer_resource_budget</div><div class="diff-removed">-            .notify_on_budget_available(desired_cpus, desired_io)</div><div class="diff-removed">-            .await;</div><div class="diff-removed">-        log::trace!("Continue optimization checks, new CPU budget available");</div><div class="diff-removed">-</div><div class="diff-removed">-        // Trigger optimizers with Nop operation</div><div class="diff-removed">-        sender.send(OptimizerSignal::Nop).await.unwrap_or_else(|_| {</div><div class="diff-removed">-            log::info!("Can't notify optimizers, assume process is dead. Restart is required")</div><div class="diff-removed">-        });</div><div class="diff-removed">-    })</div><div> }</div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    