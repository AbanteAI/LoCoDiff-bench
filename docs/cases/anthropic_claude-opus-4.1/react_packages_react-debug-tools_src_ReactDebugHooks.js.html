<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - Claude Opus 4.1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <h2>Model: Claude Opus 4.1</h2>
        <p><a href="../../models/anthropic_claude-opus-4.1.html">All Claude Opus 4.1 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Claude Opus 4.1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Native Prompt Tokens:</strong> 101332</p>
                <p><strong>Native Completion Tokens:</strong> 669</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $1.570155</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-opus-4.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-opus-4.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-opus-4.1/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 2048a82a3..0e20e4081 100644</div><div class="diff-header">--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpb3bi8_rp_expected.txt	</div><div class="diff-header">+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmp__ellz84_actual.txt	</div><div class="diff-info">@@ -1,47 +1,3 @@</div><div class="diff-removed">-/**</div><div class="diff-removed">- * Copyright (c) Meta Platforms, Inc. and affiliates.</div><div class="diff-removed">- *</div><div class="diff-removed">- * This source code is licensed under the MIT license found in the</div><div class="diff-removed">- * LICENSE file in the root directory of this source tree.</div><div class="diff-removed">- *</div><div class="diff-removed">- * @flow</div><div class="diff-removed">- */</div><div class="diff-removed">-</div><div class="diff-removed">-import type {</div><div class="diff-removed">-  Awaited,</div><div class="diff-removed">-  ReactContext,</div><div class="diff-removed">-  StartTransitionOptions,</div><div class="diff-removed">-  Usable,</div><div class="diff-removed">-  Thenable,</div><div class="diff-removed">-  ReactDebugInfo,</div><div class="diff-removed">-} from 'shared/ReactTypes';</div><div class="diff-removed">-import type {</div><div class="diff-removed">-  ContextDependency,</div><div class="diff-removed">-  Dependencies,</div><div class="diff-removed">-  Fiber,</div><div class="diff-removed">-  Dispatcher as DispatcherType,</div><div class="diff-removed">-} from 'react-reconciler/src/ReactInternalTypes';</div><div class="diff-removed">-import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';</div><div class="diff-removed">-</div><div class="diff-removed">-import ErrorStackParser from 'error-stack-parser';</div><div class="diff-removed">-import assign from 'shared/assign';</div><div class="diff-removed">-import ReactSharedInternals from 'shared/ReactSharedInternals';</div><div class="diff-removed">-import {</div><div class="diff-removed">-  FunctionComponent,</div><div class="diff-removed">-  SimpleMemoComponent,</div><div class="diff-removed">-  ContextProvider,</div><div class="diff-removed">-  ForwardRef,</div><div class="diff-removed">-} from 'react-reconciler/src/ReactWorkTags';</div><div class="diff-removed">-import {</div><div class="diff-removed">-  REACT_MEMO_CACHE_SENTINEL,</div><div class="diff-removed">-  REACT_CONTEXT_TYPE,</div><div class="diff-removed">-} from 'shared/ReactSymbols';</div><div class="diff-removed">-import hasOwnProperty from 'shared/hasOwnProperty';</div><div class="diff-removed">-</div><div class="diff-removed">-type CurrentDispatcherRef = typeof ReactSharedInternals;</div><div class="diff-removed">-</div><div class="diff-removed">-// Used to track hooks called during a render</div><div class="diff-removed">-</div><div> type HookLogEntry = {</div><div>   displayName: string | null,</div><div>   primitive: string,</div><div class="diff-info">@@ -49,1297 +5,4 @@ type HookLogEntry = {</div><div>   value: mixed,</div><div>   debugInfo: ReactDebugInfo | null,</div><div>   dispatcherHookName: string,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-let hookLog: Array<HookLogEntry> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-// Primitives</div><div class="diff-removed">-</div><div class="diff-removed">-type BasicStateAction<S> = (S => S) | S;</div><div class="diff-removed">-</div><div class="diff-removed">-type Dispatch<A> = A => void;</div><div class="diff-removed">-</div><div class="diff-removed">-let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div class="diff-removed">-</div><div class="diff-removed">-type Hook = {</div><div class="diff-removed">-  memoizedState: any,</div><div class="diff-removed">-  next: Hook | null,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div class="diff-removed">-  // This initializes a cache of all primitive hooks so that the top</div><div class="diff-removed">-  // most stack frames added by calling the primitive hook can be removed.</div><div class="diff-removed">-  if (primitiveStackCache === null) {</div><div class="diff-removed">-    const cache = new Map<string, Array<any>>();</div><div class="diff-removed">-    let readHookLog;</div><div class="diff-removed">-    try {</div><div class="diff-removed">-      // Use all hooks here to add them to the hook log.</div><div class="diff-removed">-      Dispatcher.useContext(({_currentValue: null}: any));</div><div class="diff-removed">-      Dispatcher.useState(null);</div><div class="diff-removed">-      Dispatcher.useReducer((s: mixed, a: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useRef(null);</div><div class="diff-removed">-      if (typeof Dispatcher.useCacheRefresh === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useCacheRefresh();</div><div class="diff-removed">-      }</div><div class="diff-removed">-      Dispatcher.useLayoutEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useInsertionEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useImperativeHandle(undefined, () => null);</div><div class="diff-removed">-      Dispatcher.useDebugValue(null);</div><div class="diff-removed">-      Dispatcher.useCallback(() => {});</div><div class="diff-removed">-      Dispatcher.useTransition();</div><div class="diff-removed">-      Dispatcher.useSyncExternalStore(</div><div class="diff-removed">-        () => () => {},</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-      );</div><div class="diff-removed">-      Dispatcher.useDeferredValue(null);</div><div class="diff-removed">-      Dispatcher.useMemo(() => null);</div><div class="diff-removed">-      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);</div><div class="diff-removed">-      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useHostTransitionStatus();</div><div class="diff-removed">-      if (typeof Dispatcher.useMemoCache === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useMemoCache(0);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (typeof Dispatcher.use === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.use(</div><div class="diff-removed">-          ({</div><div class="diff-removed">-            $$typeof: REACT_CONTEXT_TYPE,</div><div class="diff-removed">-            _currentValue: null,</div><div class="diff-removed">-          }: any),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        Dispatcher.use({</div><div class="diff-removed">-          then() {},</div><div class="diff-removed">-          status: 'fulfilled',</div><div class="diff-removed">-          value: null,</div><div class="diff-removed">-        });</div><div class="diff-removed">-        try {</div><div class="diff-removed">-          Dispatcher.use(</div><div class="diff-removed">-            ({</div><div class="diff-removed">-              then() {},</div><div class="diff-removed">-            }: any),</div><div class="diff-removed">-          );</div><div class="diff-removed">-        } catch (x) {}</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      Dispatcher.useId();</div><div class="diff-removed">-</div><div class="diff-removed">-      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-removed">-        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } finally {</div><div class="diff-removed">-      readHookLog = hookLog;</div><div class="diff-removed">-      hookLog = [];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-      const hook = readHookLog[i];</div><div class="diff-removed">-      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));</div><div class="diff-removed">-    }</div><div class="diff-removed">-    primitiveStackCache = cache;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return primitiveStackCache;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-let currentFiber: null | Fiber = null;</div><div class="diff-removed">-let currentHook: null | Hook = null;</div><div class="diff-removed">-let currentContextDependency: null | ContextDependency<mixed> = null;</div><div class="diff-removed">-</div><div class="diff-removed">-function nextHook(): null | Hook {</div><div class="diff-removed">-  const hook = currentHook;</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    currentHook = hook.next;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return hook;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function readContext<T>(context: ReactContext<T>): T {</div><div class="diff-removed">-  if (currentFiber === null) {</div><div class="diff-removed">-    // Hook inspection without access to the Fiber tree</div><div class="diff-removed">-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.</div><div class="diff-removed">-    return context._currentValue;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    if (currentContextDependency === null) {</div><div class="diff-removed">-      throw new Error(</div><div class="diff-removed">-        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div class="diff-removed">-    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-removed">-      value = ((currentContextDependency.memoizedValue: any): T);</div><div class="diff-removed">-</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-removed">-      currentContextDependency = currentContextDependency.next;</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-removed">-      // Multiple reads of the same context were also only tracked as a single dependency.</div><div class="diff-removed">-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.</div><div class="diff-removed">-      value = context._currentValue;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return value;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-const SuspenseException: mixed = new Error(</div><div class="diff-removed">-  "Suspense Exception: This is not a real error! It's an implementation " +</div><div class="diff-removed">-    'detail of `use` to interrupt the current render. You must either ' +</div><div class="diff-removed">-    'rethrow it immediately, or move the `use` call outside of the ' +</div><div class="diff-removed">-    '`try/catch` block. Capturing without rethrowing will lead to ' +</div><div class="diff-removed">-    'unexpected behavior.\n\n' +</div><div class="diff-removed">-    'To handle async errors, wrap your component in an error boundary, or ' +</div><div class="diff-removed">-    "call the promise's `.catch` method and pass the result to `use`.",</div><div class="diff-removed">-);</div><div class="diff-removed">-</div><div class="diff-removed">-function use<T>(usable: Usable<T>): T {</div><div class="diff-removed">-  if (usable !== null && typeof usable === 'object') {</div><div class="diff-removed">-    // $FlowFixMe[method-unbinding]</div><div class="diff-removed">-    if (typeof usable.then === 'function') {</div><div class="diff-removed">-      const thenable: Thenable<any> = (usable: any);</div><div class="diff-removed">-      switch (thenable.status) {</div><div class="diff-removed">-        case 'fulfilled': {</div><div class="diff-removed">-          const fulfilledValue: T = thenable.value;</div><div class="diff-removed">-          hookLog.push({</div><div class="diff-removed">-            displayName: null,</div><div class="diff-removed">-            primitive: 'Promise',</div><div class="diff-removed">-            stackError: new Error(),</div><div class="diff-removed">-            value: fulfilledValue,</div><div class="diff-removed">-            debugInfo:</div><div class="diff-removed">-              thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div class="diff-removed">-            dispatcherHookName: 'Use',</div><div class="diff-removed">-          });</div><div class="diff-removed">-          return fulfilledValue;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          throw rejectedError;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-      // but we can still emit anything up until this point.</div><div class="diff-removed">-      hookLog.push({</div><div class="diff-removed">-        displayName: null,</div><div class="diff-removed">-        primitive: 'Unresolved',</div><div class="diff-removed">-        stackError: new Error(),</div><div class="diff-removed">-        value: thenable,</div><div class="diff-removed">-        debugInfo:</div><div class="diff-removed">-          thenable._debugInfo === undefined ? null : thenable._debugInfo,</div><div class="diff-removed">-        dispatcherHookName: 'Use',</div><div class="diff-removed">-      });</div><div class="diff-removed">-      throw SuspenseException;</div><div class="diff-removed">-    } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {</div><div class="diff-removed">-      const context: ReactContext<T> = (usable: any);</div><div class="diff-removed">-      const value = readContext(context);</div><div class="diff-removed">-</div><div class="diff-removed">-      hookLog.push({</div><div class="diff-removed">-        displayName: context.displayName || 'Context',</div><div class="diff-removed">-        primitive: 'Context (use)',</div><div class="diff-removed">-        stackError: new Error(),</div><div class="diff-removed">-        value,</div><div class="diff-removed">-        debugInfo: null,</div><div class="diff-removed">-        dispatcherHookName: 'Use',</div><div class="diff-removed">-      });</div><div class="diff-removed">-</div><div class="diff-removed">-      return value;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // eslint-disable-next-line react-internal/safe-string-coercion</div><div class="diff-removed">-  throw new Error('An unsupported type was passed to use(): ' + String(usable));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useContext<T>(context: ReactContext<T>): T {</div><div class="diff-removed">-  const value = readContext(context);</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: context.displayName || null,</div><div class="diff-removed">-    primitive: 'Context',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Context',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return value;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useState<S>(</div><div class="diff-removed">-  initialState: (() => S) | S,</div><div class="diff-removed">-): [S, Dispatch<BasicStateAction<S>>] {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  const state: S =</div><div class="diff-removed">-    hook !== null</div><div class="diff-removed">-      ? hook.memoizedState</div><div class="diff-removed">-      : typeof initialState === 'function'</div><div class="diff-removed">-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-removed">-          initialState()</div><div class="diff-removed">-        : initialState;</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'State',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: state,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'State',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return [state, (action: BasicStateAction<S>) => {}];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useReducer<S, I, A>(</div><div class="diff-removed">-  reducer: (S, A) => S,</div><div class="diff-removed">-  initialArg: I,</div><div class="diff-removed">-  init?: I => S,</div><div class="diff-removed">-): [S, Dispatch<A>] {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  let state;</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    state = hook.memoizedState;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    state = init !== undefined ? init(initialArg) : ((initialArg: any): S);</div><div class="diff-removed">-  }</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Reducer',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: state,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Reducer',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return [state, (action: A) => {}];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useRef<T>(initialValue: T): {current: T} {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  const ref = hook !== null ? hook.memoizedState : {current: initialValue};</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Ref',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: ref.current,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Ref',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return ref;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useCacheRefresh(): () => void {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'CacheRefresh',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: hook !== null ? hook.memoizedState : function refresh() {},</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'CacheRefresh',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return () => {};</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useLayoutEffect(</div><div class="diff-removed">-  create: () => (() => void) | void,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'LayoutEffect',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: create,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'LayoutEffect',</div><div class="diff-removed">-  });</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useInsertionEffect(</div><div class="diff-removed">-  create: () => mixed,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'InsertionEffect',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: create,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'InsertionEffect',</div><div class="diff-removed">-  });</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useEffect(</div><div class="diff-removed">-  create: () => (() => void) | void,</div><div class="diff-removed">-  deps: Array<mixed> | void | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Effect',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: create,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Effect',</div><div class="diff-removed">-  });</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useImperativeHandle<T>(</div><div class="diff-removed">-  ref: {current: T | null} | ((inst: T | null) => mixed) | null | void,</div><div class="diff-removed">-  create: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  // We don't actually store the instance anywhere if there is no ref callback</div><div class="diff-removed">-  // and if there is a ref callback it might not store it but if it does we</div><div class="diff-removed">-  // have no way of knowing where. So let's only enable introspection of the</div><div class="diff-removed">-  // ref itself if it is using the object form.</div><div class="diff-removed">-  let instance: ?T = undefined;</div><div class="diff-removed">-  if (ref !== null && typeof ref === 'object') {</div><div class="diff-removed">-    instance = ref.current;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'ImperativeHandle',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: instance,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'ImperativeHandle',</div><div class="diff-removed">-  });</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useDebugValue(value: any, formatterFn: ?(value: any) => any) {</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'DebugValue',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: typeof formatterFn === 'function' ? formatterFn(value) : value,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'DebugValue',</div><div class="diff-removed">-  });</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useCallback<T>(callback: T, inputs: Array<mixed> | void | null): T {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Callback',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: hook !== null ? hook.memoizedState[0] : callback,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Callback',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return callback;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useMemo<T>(</div><div class="diff-removed">-  nextCreate: () => T,</div><div class="diff-removed">-  inputs: Array<mixed> | void | null,</div><div class="diff-removed">-): T {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  const value = hook !== null ? hook.memoizedState[0] : nextCreate();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Memo',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Memo',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return value;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useSyncExternalStore<T>(</div><div class="diff-removed">-  subscribe: (() => void) => () => void,</div><div class="diff-removed">-  getSnapshot: () => T,</div><div class="diff-removed">-  getServerSnapshot?: () => T,</div><div class="diff-removed">-): T {</div><div class="diff-removed">-  // useSyncExternalStore() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div class="diff-removed">-  nextHook(); // SyncExternalStore</div><div class="diff-removed">-  nextHook(); // Effect</div><div class="diff-removed">-  const value = getSnapshot();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'SyncExternalStore',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'SyncExternalStore',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return value;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useTransition(): [</div><div class="diff-removed">-  boolean,</div><div class="diff-removed">-  (callback: () => void, options?: StartTransitionOptions) => void,</div><div class="diff-removed">-] {</div><div class="diff-removed">-  // useTransition() composes multiple hooks internally.</div><div class="diff-removed">-  // Advance the current hook index the same number of times</div><div class="diff-removed">-  // so that subsequent hooks have the right memoized state.</div><div class="diff-removed">-  const stateHook = nextHook();</div><div class="diff-removed">-  nextHook(); // Callback</div><div class="diff-removed">-</div><div class="diff-removed">-  const isPending = stateHook !== null ? stateHook.memoizedState : false;</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Transition',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: isPending,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Transition',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return [isPending, () => {}];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useDeferredValue<T>(value: T, initialValue?: T): T {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  const prevValue = hook !== null ? hook.memoizedState : value;</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'DeferredValue',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: prevValue,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'DeferredValue',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return prevValue;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useId(): string {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  const id = hook !== null ? hook.memoizedState : '';</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Id',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: id,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Id',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return id;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// useMemoCache is an implementation detail of Forget's memoization</div><div class="diff-removed">-// it should not be called directly in user-generated code</div><div class="diff-removed">-function useMemoCache(size: number): Array<mixed> {</div><div class="diff-removed">-  const fiber = currentFiber;</div><div class="diff-removed">-  // Don't throw, in case this is called from getPrimitiveStackCache</div><div class="diff-removed">-  if (fiber == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const memoCache =</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: updateQueue is mixed</div><div class="diff-removed">-    fiber.updateQueue != null ? fiber.updateQueue.memoCache : null;</div><div class="diff-removed">-  if (memoCache == null) {</div><div class="diff-removed">-    return [];</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  let data = memoCache.data[memoCache.index];</div><div class="diff-removed">-  if (data === undefined) {</div><div class="diff-removed">-    data = memoCache.data[memoCache.index] = new Array(size);</div><div class="diff-removed">-    for (let i = 0; i < size; i++) {</div><div class="diff-removed">-      data[i] = REACT_MEMO_CACHE_SENTINEL;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // We don't write anything to hookLog on purpose, so this hook remains invisible to users.</div><div class="diff-removed">-</div><div class="diff-removed">-  memoCache.index++;</div><div class="diff-removed">-  return data;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useOptimistic<S, A>(</div><div class="diff-removed">-  passthrough: S,</div><div class="diff-removed">-  reducer: ?(S, A) => S,</div><div class="diff-removed">-): [S, (A) => void] {</div><div class="diff-removed">-  const hook = nextHook();</div><div class="diff-removed">-  let state;</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    state = hook.memoizedState;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    state = passthrough;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'Optimistic',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: state,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'Optimistic',</div><div class="diff-removed">-  });</div><div class="diff-removed">-  return [state, (action: A) => {}];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useFormState<S, P>(</div><div class="diff-removed">-  action: (Awaited<S>, P) => S,</div><div class="diff-removed">-  initialState: Awaited<S>,</div><div class="diff-removed">-  permalink?: string,</div><div class="diff-removed">-): [Awaited<S>, (P) => void, boolean] {</div><div class="diff-removed">-  const hook = nextHook(); // FormState</div><div class="diff-removed">-  nextHook(); // PendingState</div><div class="diff-removed">-  nextHook(); // ActionQueue</div><div class="diff-removed">-  const stackError = new Error();</div><div class="diff-removed">-  let value;</div><div class="diff-removed">-  let debugInfo = null;</div><div class="diff-removed">-  let error = null;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    const actionResult = hook.memoizedState;</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      typeof actionResult === 'object' &&</div><div class="diff-removed">-      actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div class="diff-removed">-      typeof actionResult.then === 'function'</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-removed">-      switch (thenable.status) {</div><div class="diff-removed">-        case 'fulfilled': {</div><div class="diff-removed">-          value = thenable.value;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div class="diff-removed">-          error = SuspenseException;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          value = thenable;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    value = initialState;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'FormState',</div><div class="diff-removed">-    stackError: stackError,</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: debugInfo,</div><div class="diff-removed">-    dispatcherHookName: 'FormState',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  if (error !== null) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div class="diff-removed">-  const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div class="diff-removed">-  return [state, (payload: P) => {}, false];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useActionState<S, P>(</div><div class="diff-removed">-  action: (Awaited<S>, P) => S,</div><div class="diff-removed">-  initialState: Awaited<S>,</div><div class="diff-removed">-  permalink?: string,</div><div class="diff-removed">-): [Awaited<S>, (P) => void, boolean] {</div><div class="diff-removed">-  const hook = nextHook(); // FormState</div><div class="diff-removed">-  nextHook(); // PendingState</div><div class="diff-removed">-  nextHook(); // ActionQueue</div><div class="diff-removed">-  const stackError = new Error();</div><div class="diff-removed">-  let value;</div><div class="diff-removed">-  let debugInfo = null;</div><div class="diff-removed">-  let error = null;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hook !== null) {</div><div class="diff-removed">-    const actionResult = hook.memoizedState;</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      typeof actionResult === 'object' &&</div><div class="diff-removed">-      actionResult !== null &&</div><div class="diff-removed">-      // $FlowFixMe[method-unbinding]</div><div class="diff-removed">-      typeof actionResult.then === 'function'</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      const thenable: Thenable<Awaited<S>> = (actionResult: any);</div><div class="diff-removed">-      switch (thenable.status) {</div><div class="diff-removed">-        case 'fulfilled': {</div><div class="diff-removed">-          value = thenable.value;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        case 'rejected': {</div><div class="diff-removed">-          const rejectedError = thenable.reason;</div><div class="diff-removed">-          error = rejectedError;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        default:</div><div class="diff-removed">-          // If this was an uncached Promise we have to abandon this attempt</div><div class="diff-removed">-          // but we can still emit anything up until this point.</div><div class="diff-removed">-          error = SuspenseException;</div><div class="diff-removed">-          debugInfo =</div><div class="diff-removed">-            thenable._debugInfo === undefined ? null : thenable._debugInfo;</div><div class="diff-removed">-          value = thenable;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      value = (actionResult: any);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    value = initialState;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'ActionState',</div><div class="diff-removed">-    stackError: stackError,</div><div class="diff-removed">-    value: value,</div><div class="diff-removed">-    debugInfo: debugInfo,</div><div class="diff-removed">-    dispatcherHookName: 'ActionState',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  if (error !== null) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // value being a Thenable is equivalent to error being not null</div><div class="diff-removed">-  // i.e. we only reach this point with Awaited<S></div><div class="diff-removed">-  const state = ((value: any): Awaited<S>);</div><div class="diff-removed">-</div><div class="diff-removed">-  // TODO: support displaying pending value</div><div class="diff-removed">-  return [state, (payload: P) => {}, false];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useHostTransitionStatus(): TransitionStatus {</div><div class="diff-removed">-  const status = readContext<TransitionStatus>(</div><div class="diff-removed">-    // $FlowFixMe[prop-missing] `readContext` only needs _currentValue</div><div class="diff-removed">-    ({</div><div class="diff-removed">-      // $FlowFixMe[incompatible-cast] TODO: Incorrect bottom value without access to Fiber config.</div><div class="diff-removed">-      _currentValue: null,</div><div class="diff-removed">-    }: ReactContext<TransitionStatus>),</div><div class="diff-removed">-  );</div><div class="diff-removed">-</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'HostTransitionStatus',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: status,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'HostTransitionStatus',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  return status;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function useEffectEvent<Args, F: (...Array<Args>) => mixed>(callback: F): F {</div><div class="diff-removed">-  nextHook();</div><div class="diff-removed">-  hookLog.push({</div><div class="diff-removed">-    displayName: null,</div><div class="diff-removed">-    primitive: 'EffectEvent',</div><div class="diff-removed">-    stackError: new Error(),</div><div class="diff-removed">-    value: callback,</div><div class="diff-removed">-    debugInfo: null,</div><div class="diff-removed">-    dispatcherHookName: 'EffectEvent',</div><div class="diff-removed">-  });</div><div class="diff-removed">-</div><div class="diff-removed">-  return callback;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-const Dispatcher: DispatcherType = {</div><div class="diff-removed">-  readContext,</div><div class="diff-removed">-</div><div class="diff-removed">-  use,</div><div class="diff-removed">-  useCallback,</div><div class="diff-removed">-  useContext,</div><div class="diff-removed">-  useEffect,</div><div class="diff-removed">-  useImperativeHandle,</div><div class="diff-removed">-  useLayoutEffect,</div><div class="diff-removed">-  useInsertionEffect,</div><div class="diff-removed">-  useMemo,</div><div class="diff-removed">-  useReducer,</div><div class="diff-removed">-  useRef,</div><div class="diff-removed">-  useState,</div><div class="diff-removed">-  useDebugValue,</div><div class="diff-removed">-  useDeferredValue,</div><div class="diff-removed">-  useTransition,</div><div class="diff-removed">-  useSyncExternalStore,</div><div class="diff-removed">-  useId,</div><div class="diff-removed">-  useHostTransitionStatus,</div><div class="diff-removed">-  useFormState,</div><div class="diff-removed">-  useActionState,</div><div class="diff-removed">-  useOptimistic,</div><div class="diff-removed">-  useMemoCache,</div><div class="diff-removed">-  useCacheRefresh,</div><div class="diff-removed">-  useEffectEvent,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-// create a proxy to throw a custom error</div><div class="diff-removed">-// in case future versions of React adds more hooks</div><div class="diff-removed">-const DispatcherProxyHandler = {</div><div class="diff-removed">-  get(target: DispatcherType, prop: string) {</div><div class="diff-removed">-    if (target.hasOwnProperty(prop)) {</div><div class="diff-removed">-      // $FlowFixMe[invalid-computed-prop]</div><div class="diff-removed">-      return target[prop];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const error = new Error('Missing method in Dispatcher: ' + prop);</div><div class="diff-removed">-    // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-    // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-    error.name = 'ReactDebugToolsUnsupportedHookError';</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  },</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-// `Proxy` may not exist on some platforms</div><div class="diff-removed">-const DispatcherProxy =</div><div class="diff-removed">-  typeof Proxy === 'undefined'</div><div class="diff-removed">-    ? Dispatcher</div><div class="diff-removed">-    : new Proxy(Dispatcher, DispatcherProxyHandler);</div><div class="diff-removed">-</div><div class="diff-removed">-// Inspect</div><div class="diff-removed">-</div><div class="diff-removed">-export type HookSource = {</div><div class="diff-removed">-  lineNumber: number | null,</div><div class="diff-removed">-  columnNumber: number | null,</div><div class="diff-removed">-  fileName: string | null,</div><div class="diff-removed">-  functionName: string | null,</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-export type HooksNode = {</div><div class="diff-removed">-  id: number | null,</div><div class="diff-removed">-  isStateEditable: boolean,</div><div class="diff-removed">-  name: string,</div><div class="diff-removed">-  value: mixed,</div><div class="diff-removed">-  subHooks: Array<HooksNode>,</div><div class="diff-removed">-  debugInfo: null | ReactDebugInfo,</div><div class="diff-removed">-  hookSource: null | HookSource,</div><div class="diff-removed">-};</div><div class="diff-removed">-export type HooksTree = Array<HooksNode>;</div><div class="diff-removed">-</div><div class="diff-removed">-// Don't assume</div><div class="diff-removed">-//</div><div class="diff-removed">-// We can't assume that stack frames are nth steps away from anything.</div><div class="diff-removed">-// E.g. we can't assume that the root call shares all frames with the stack</div><div class="diff-removed">-// of a hook call. A simple way to demonstrate this is wrapping `new Error()`</div><div class="diff-removed">-// in a wrapper constructor like a polyfill. That'll add an extra frame.</div><div class="diff-removed">-// Similar things can happen with the call to the dispatcher. The top frame</div><div class="diff-removed">-// may not be the primitive.</div><div class="diff-removed">-//</div><div class="diff-removed">-// We also can't assume that the last frame of the root call is the same</div><div class="diff-removed">-// frame as the last frame of the hook call because long stack traces can be</div><div class="diff-removed">-// truncated to a stack trace limit.</div><div class="diff-removed">-</div><div class="diff-removed">-let mostLikelyAncestorIndex = 0;</div><div class="diff-removed">-</div><div class="diff-removed">-function findSharedIndex(hookStack: any, rootStack: any, rootIndex: number) {</div><div class="diff-removed">-  const source = rootStack[rootIndex].source;</div><div class="diff-removed">-  hookSearch: for (let i = 0; i < hookStack.length; i++) {</div><div class="diff-removed">-    if (hookStack[i].source === source) {</div><div class="diff-removed">-      // This looks like a match. Validate that the rest of both stack match up.</div><div class="diff-removed">-      for (</div><div class="diff-removed">-        let a = rootIndex + 1, b = i + 1;</div><div class="diff-removed">-        a < rootStack.length && b < hookStack.length;</div><div class="diff-removed">-        a++, b++</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        if (hookStack[b].source !== rootStack[a].source) {</div><div class="diff-removed">-          // If not, give up and try a different match.</div><div class="diff-removed">-          continue hookSearch;</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      return i;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function findCommonAncestorIndex(rootStack: any, hookStack: any) {</div><div class="diff-removed">-  let rootIndex = findSharedIndex(</div><div class="diff-removed">-    hookStack,</div><div class="diff-removed">-    rootStack,</div><div class="diff-removed">-    mostLikelyAncestorIndex,</div><div class="diff-removed">-  );</div><div class="diff-removed">-  if (rootIndex !== -1) {</div><div class="diff-removed">-    return rootIndex;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the most likely one wasn't a hit, try any other frame to see if it is shared.</div><div class="diff-removed">-  // If that takes more than 5 frames, something probably went wrong.</div><div class="diff-removed">-  for (let i = 0; i < rootStack.length && i < 5; i++) {</div><div class="diff-removed">-    rootIndex = findSharedIndex(hookStack, rootStack, i);</div><div class="diff-removed">-    if (rootIndex !== -1) {</div><div class="diff-removed">-      mostLikelyAncestorIndex = i;</div><div class="diff-removed">-      return rootIndex;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function isReactWrapper(functionName: any, wrapperName: string) {</div><div class="diff-removed">-  const hookName = parseHookName(functionName);</div><div class="diff-removed">-  if (wrapperName === 'HostTransitionStatus') {</div><div class="diff-removed">-    return hookName === wrapperName || hookName === 'FormStatus';</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  return hookName === wrapperName;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  const stackCache = getPrimitiveStackCache();</div><div class="diff-removed">-  const primitiveStack = stackCache.get(hook.primitive);</div><div class="diff-removed">-  if (primitiveStack === undefined) {</div><div class="diff-removed">-    return -1;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  for (let i = 0; i < primitiveStack.length && i < hookStack.length; i++) {</div><div class="diff-removed">-    // Note: there is no guarantee that we will find the top-most primitive frame in the stack</div><div class="diff-removed">-    // For React Native (uses Hermes), these source fields will be identical and skipped</div><div class="diff-removed">-    if (primitiveStack[i].source !== hookStack[i].source) {</div><div class="diff-removed">-      // If the next two frames are functions called `useX` then we assume that they're part of the</div><div class="diff-removed">-      // wrappers that the React package or other packages adds around the dispatcher.</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        i < hookStack.length - 1 &&</div><div class="diff-removed">-        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        i++;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        i < hookStack.length - 1 &&</div><div class="diff-removed">-        isReactWrapper(hookStack[i].functionName, hook.dispatcherHookName)</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        i++;</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      return i;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return -1;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  // Get the stack trace between the primitive hook function and</div><div class="diff-removed">-  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-removed">-  const hookStack = ErrorStackParser.parse(hook.stackError);</div><div class="diff-removed">-  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div class="diff-removed">-  const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    rootIndex === -1 ||</div><div class="diff-removed">-    primitiveIndex === -1 ||</div><div class="diff-removed">-    rootIndex - primitiveIndex < 2</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    if (primitiveIndex === -1) {</div><div class="diff-removed">-      // Something went wrong. Give up.</div><div class="diff-removed">-      return [null, null];</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      return [hookStack[primitiveIndex - 1], null];</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return [</div><div class="diff-removed">-    hookStack[primitiveIndex - 1],</div><div class="diff-removed">-    hookStack.slice(primitiveIndex, rootIndex - 1),</div><div class="diff-removed">-  ];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function parseHookName(functionName: void | string): string {</div><div class="diff-removed">-  if (!functionName) {</div><div class="diff-removed">-    return '';</div><div class="diff-removed">-  }</div><div class="diff-removed">-  let startIndex = functionName.lastIndexOf('[as ');</div><div class="diff-removed">-</div><div class="diff-removed">-  if (startIndex !== -1) {</div><div class="diff-removed">-    // Workaround for sourcemaps in Jest and Chrome.</div><div class="diff-removed">-    // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"</div><div class="diff-removed">-    // "Object.useHostTransitionStatus [as useFormStatus]" -> "useFormStatus"</div><div class="diff-removed">-    return parseHookName(functionName.slice(startIndex + '[as '.length, -1));</div><div class="diff-removed">-  }</div><div class="diff-removed">-  startIndex = functionName.lastIndexOf('.');</div><div class="diff-removed">-  if (startIndex === -1) {</div><div class="diff-removed">-    startIndex = 0;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    startIndex += 1;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('unstable_')) {</div><div class="diff-removed">-    startIndex += 'unstable_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex).startsWith('experimental_')) {</div><div class="diff-removed">-    startIndex += 'experimental_'.length;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (functionName.slice(startIndex, startIndex + 3) === 'use') {</div><div class="diff-removed">-    if (functionName.length - startIndex === 3) {</div><div class="diff-removed">-      return 'Use';</div><div class="diff-removed">-    }</div><div class="diff-removed">-    startIndex += 3;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return functionName.slice(startIndex);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function buildTree(</div><div class="diff-removed">-  rootStack: any,</div><div class="diff-removed">-  readHookLog: Array<HookLogEntry>,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const rootChildren: Array<HooksNode> = [];</div><div class="diff-removed">-  let prevStack = null;</div><div class="diff-removed">-  let levelChildren = rootChildren;</div><div class="diff-removed">-  let nativeHookID = 0;</div><div class="diff-removed">-  const stackOfChildren = [];</div><div class="diff-removed">-  for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-    const hook = readHookLog[i];</div><div class="diff-removed">-    const parseResult = parseTrimmedStack(rootStack, hook);</div><div class="diff-removed">-    const primitiveFrame = parseResult[0];</div><div class="diff-removed">-    const stack = parseResult[1];</div><div class="diff-removed">-    let displayName = hook.displayName;</div><div class="diff-removed">-    if (displayName === null && primitiveFrame !== null) {</div><div class="diff-removed">-      displayName =</div><div class="diff-removed">-        parseHookName(primitiveFrame.functionName) ||</div><div class="diff-removed">-        // Older versions of React do not have sourcemaps.</div><div class="diff-removed">-        // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div class="diff-removed">-        parseHookName(hook.dispatcherHookName);</div><div class="diff-removed">-    }</div><div class="diff-removed">-    if (stack !== null) {</div><div class="diff-removed">-      // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-removed">-      // The indices 1 <= n < length will contain the source locations.</div><div class="diff-removed">-      // That's why we get the name from n - 1 and don't check the source</div><div class="diff-removed">-      // of index 0.</div><div class="diff-removed">-      let commonSteps = 0;</div><div class="diff-removed">-      if (prevStack !== null) {</div><div class="diff-removed">-        // Compare the current level's stack to the new stack.</div><div class="diff-removed">-        while (commonSteps < stack.length && commonSteps < prevStack.length) {</div><div class="diff-removed">-          const stackSource = stack[stack.length - commonSteps - 1].source;</div><div class="diff-removed">-          const prevSource =</div><div class="diff-removed">-            prevStack[prevStack.length - commonSteps - 1].source;</div><div class="diff-removed">-          if (stackSource !== prevSource) {</div><div class="diff-removed">-            break;</div><div class="diff-removed">-          }</div><div class="diff-removed">-          commonSteps++;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // Pop back the stack as many steps as were not common.</div><div class="diff-removed">-        for (let j = prevStack.length - 1; j > commonSteps; j--) {</div><div class="diff-removed">-          // $FlowFixMe[incompatible-type]</div><div class="diff-removed">-          levelChildren = stackOfChildren.pop();</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // The remaining part of the new stack are custom hooks. Push them</div><div class="diff-removed">-      // to the tree.</div><div class="diff-removed">-      for (let j = stack.length - commonSteps - 1; j >= 1; j--) {</div><div class="diff-removed">-        const children: Array<HooksNode> = [];</div><div class="diff-removed">-        const stackFrame = stack[j];</div><div class="diff-removed">-        const levelChild: HooksNode = {</div><div class="diff-removed">-          id: null,</div><div class="diff-removed">-          isStateEditable: false,</div><div class="diff-removed">-          name: parseHookName(stack[j - 1].functionName),</div><div class="diff-removed">-          value: undefined,</div><div class="diff-removed">-          subHooks: children,</div><div class="diff-removed">-          debugInfo: null,</div><div class="diff-removed">-          hookSource: {</div><div class="diff-removed">-            lineNumber: stackFrame.lineNumber,</div><div class="diff-removed">-            columnNumber: stackFrame.columnNumber,</div><div class="diff-removed">-            functionName: stackFrame.functionName,</div><div class="diff-removed">-            fileName: stackFrame.fileName,</div><div class="diff-removed">-          },</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        levelChildren.push(levelChild);</div><div class="diff-removed">-        stackOfChildren.push(levelChildren);</div><div class="diff-removed">-        levelChildren = children;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      prevStack = stack;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    const {primitive, debugInfo} = hook;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For now, the "id" of stateful hooks is just the stateful hook index.</div><div class="diff-removed">-    // Custom hooks have no ids, nor do non-stateful native hooks (e.g. Context, DebugValue).</div><div class="diff-removed">-    const id =</div><div class="diff-removed">-      primitive === 'Context' ||</div><div class="diff-removed">-      primitive === 'Context (use)' ||</div><div class="diff-removed">-      primitive === 'DebugValue' ||</div><div class="diff-removed">-      primitive === 'Promise' ||</div><div class="diff-removed">-      primitive === 'Unresolved' ||</div><div class="diff-removed">-      primitive === 'HostTransitionStatus'</div><div class="diff-removed">-        ? null</div><div class="diff-removed">-        : nativeHookID++;</div><div class="diff-removed">-</div><div class="diff-removed">-    // For the time being, only State and Reducer hooks support runtime overrides.</div><div class="diff-removed">-    const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div class="diff-removed">-    const levelChild: HooksNode = {</div><div class="diff-removed">-      id,</div><div class="diff-removed">-      isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-removed">-      value: hook.value,</div><div class="diff-removed">-      subHooks: [],</div><div class="diff-removed">-      debugInfo: debugInfo,</div><div class="diff-removed">-      hookSource: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    const hookSource: HookSource = {</div><div class="diff-removed">-      lineNumber: null,</div><div class="diff-removed">-      functionName: null,</div><div class="diff-removed">-      fileName: null,</div><div class="diff-removed">-      columnNumber: null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChild.hookSource = hookSource;</div><div class="diff-removed">-</div><div class="diff-removed">-    levelChildren.push(levelChild);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div class="diff-removed">-  processDebugValues(rootChildren, null);</div><div class="diff-removed">-</div><div class="diff-removed">-  return rootChildren;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-removed">-function processDebugValues(</div><div class="diff-removed">-  hooksTree: HooksTree,</div><div class="diff-removed">-  parentHooksNode: HooksNode | null,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const debugValueHooksNodes: Array<HooksNode> = [];</div><div class="diff-removed">-</div><div class="diff-removed">-  for (let i = 0; i < hooksTree.length; i++) {</div><div class="diff-removed">-    const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-removed">-      hooksTree.splice(i, 1);</div><div class="diff-removed">-      i--;</div><div class="diff-removed">-      debugValueHooksNodes.push(hooksNode);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      processDebugValues(hooksNode.subHooks, hooksNode);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Bubble debug value labels to their custom hook owner.</div><div class="diff-removed">-  // If there is no parent hook, just ignore them for now.</div><div class="diff-removed">-  // (We may warn about this in the future.)</div><div class="diff-removed">-  if (parentHooksNode !== null) {</div><div class="diff-removed">-    if (debugValueHooksNodes.length === 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes[0].value;</div><div class="diff-removed">-    } else if (debugValueHooksNodes.length > 1) {</div><div class="diff-removed">-      parentHooksNode.value = debugValueHooksNodes.map(({value}) => value);</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div class="diff-removed">-  if (error === SuspenseException) {</div><div class="diff-removed">-    // An uncached Promise was used. We can't synchronously resolve the rest of</div><div class="diff-removed">-    // the Hooks but we can at least show what ever we got so far.</div><div class="diff-removed">-    return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    error instanceof Error &&</div><div class="diff-removed">-    error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw error;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  // If the error is not caused by an unsupported feature, it means</div><div class="diff-removed">-  // that the error is caused by user's code in renderFunction.</div><div class="diff-removed">-  // In this case, we should wrap the original error inside a custom error</div><div class="diff-removed">-  // so that devtools can give a clear message about it.</div><div class="diff-removed">-  // $FlowFixMe[extra-arg]: Flow doesn't know about 2nd argument of Error constructor</div><div class="diff-removed">-  const wrapperError = new Error('Error rendering inspected component', {</div><div class="diff-removed">-    cause: error,</div><div class="diff-removed">-  });</div><div class="diff-removed">-  // Note: This error name needs to stay in sync with react-devtools-shared</div><div class="diff-removed">-  // TODO: refactor this if we ever combine the devtools and debug tools packages</div><div class="diff-removed">-  wrapperError.name = 'ReactDebugToolsRenderError';</div><div class="diff-removed">-  // this stage-4 proposal is not supported by all environments yet.</div><div class="diff-removed">-  // $FlowFixMe[prop-missing] Flow doesn't have this type yet.</div><div class="diff-removed">-  wrapperError.cause = error;</div><div class="diff-removed">-  throw wrapperError;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooks<Props>(</div><div class="diff-removed">-  renderFunction: Props => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-removed">-  let current: null | Fiber = fiber;</div><div class="diff-removed">-  while (current) {</div><div class="diff-removed">-    if (current.tag === ContextProvider) {</div><div class="diff-removed">-      let context: ReactContext<any> = current.type;</div><div class="diff-removed">-      if ((context: any)._context !== undefined) {</div><div class="diff-removed">-        // Support inspection of pre-19+ providers.</div><div class="diff-removed">-        context = (context: any)._context;</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (!contextMap.has(context)) {</div><div class="diff-removed">-        // Store the current value that we're going to restore later.</div><div class="diff-removed">-        contextMap.set(context, context._currentValue);</div><div class="diff-removed">-        // Set the inner most provider value on the context.</div><div class="diff-removed">-        context._currentValue = current.memoizedProps.value;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    current = current.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function restoreContexts(contextMap: Map<ReactContext<any>, any>) {</div><div class="diff-removed">-  contextMap.forEach((value, context) => (context._currentValue = value));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function inspectHooksOfForwardRef<Props, Ref>(</div><div class="diff-removed">-  renderFunction: (Props, Ref) => React$Node,</div><div class="diff-removed">-  props: Props,</div><div class="diff-removed">-  ref: Ref,</div><div class="diff-removed">-  currentDispatcher: CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  const previousDispatcher = currentDispatcher.H;</div><div class="diff-removed">-  let readHookLog;</div><div class="diff-removed">-  currentDispatcher.H = DispatcherProxy;</div><div class="diff-removed">-  let ancestorStackError;</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    ancestorStackError = new Error();</div><div class="diff-removed">-    renderFunction(props, ref);</div><div class="diff-removed">-  } catch (error) {</div><div class="diff-removed">-    handleRenderFunctionError(error);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    readHookLog = hookLog;</div><div class="diff-removed">-    hookLog = [];</div><div class="diff-removed">-    currentDispatcher.H = previousDispatcher;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div class="diff-removed">-  return buildTree(rootStack, readHookLog);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function resolveDefaultProps(Component: any, baseProps: any) {</div><div class="diff-removed">-  if (Component && Component.defaultProps) {</div><div class="diff-removed">-    // Resolve default props. Taken from ReactElement</div><div class="diff-removed">-    const props = assign({}, baseProps);</div><div class="diff-removed">-    const defaultProps = Component.defaultProps;</div><div class="diff-removed">-    for (const propName in defaultProps) {</div><div class="diff-removed">-      if (props[propName] === undefined) {</div><div class="diff-removed">-        props[propName] = defaultProps[propName];</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    return props;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return baseProps;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function inspectHooksOfFiber(</div><div class="diff-removed">-  fiber: Fiber,</div><div class="diff-removed">-  currentDispatcher: ?CurrentDispatcherRef,</div><div class="diff-removed">-): HooksTree {</div><div class="diff-removed">-  // DevTools will pass the current renderer's injected dispatcher.</div><div class="diff-removed">-  // Other apps might compile debug hooks as part of their app though.</div><div class="diff-removed">-  if (currentDispatcher == null) {</div><div class="diff-removed">-    currentDispatcher = ReactSharedInternals;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    fiber.tag !== FunctionComponent &&</div><div class="diff-removed">-    fiber.tag !== SimpleMemoComponent &&</div><div class="diff-removed">-    fiber.tag !== ForwardRef</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unknown Fiber. Needs to be a function component to inspect hooks.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div class="diff-removed">-  getPrimitiveStackCache();</div><div class="diff-removed">-</div><div class="diff-removed">-  // Set up the current hook so that we can step through and read the</div><div class="diff-removed">-  // current state from them.</div><div class="diff-removed">-  currentHook = (fiber.memoizedState: Hook);</div><div class="diff-removed">-  currentFiber = fiber;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (hasOwnProperty.call(currentFiber, 'dependencies')) {</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use]: Flow thinks hasOwnProperty might have nulled `currentFiber`</div><div class="diff-removed">-    const dependencies = currentFiber.dependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_old')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_old;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'dependencies_new')) {</div><div class="diff-removed">-    const dependencies: Dependencies = (currentFiber: any).dependencies_new;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      dependencies !== null ? dependencies.firstContext : null;</div><div class="diff-removed">-  } else if (hasOwnProperty.call(currentFiber, 'contextDependencies')) {</div><div class="diff-removed">-    const contextDependencies = (currentFiber: any).contextDependencies;</div><div class="diff-removed">-    currentContextDependency =</div><div class="diff-removed">-      contextDependencies !== null ? contextDependencies.first : null;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    throw new Error(</div><div class="diff-removed">-      'Unsupported React version. This is a bug in React Debug Tools.',</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  const type = fiber.type;</div><div class="diff-removed">-  let props = fiber.memoizedProps;</div><div class="diff-removed">-  if (type !== fiber.elementType) {</div><div class="diff-removed">-    props = resolveDefaultProps(type, props);</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // Only used for versions of React without memoized context value in context dependencies.</div><div class="diff-removed">-  const contextMap = new Map<ReactContext<any>, any>();</div><div class="diff-removed">-  try {</div><div class="diff-removed">-    if (</div><div class="diff-removed">-      currentContextDependency !== null &&</div><div class="diff-removed">-      !hasOwnProperty.call(currentContextDependency, 'memoizedValue')</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      setupContexts(contextMap, fiber);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (fiber.tag === ForwardRef) {</div><div class="diff-removed">-      return inspectHooksOfForwardRef(</div><div class="diff-removed">-        type.render,</div><div class="diff-removed">-        props,</div><div class="diff-removed">-        fiber.ref,</div><div class="diff-removed">-        currentDispatcher,</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return inspectHooks(type, props, currentDispatcher);</div><div class="diff-removed">-  } finally {</div><div class="diff-removed">-    currentFiber = null;</div><div class="diff-removed">-    currentHook = null;</div><div class="diff-removed">-    currentContextDependency = null;</div><div class="diff-removed">-</div><div class="diff-removed">-    restoreContexts(contextMap);</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+};</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    