<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs - Claude Opus 4.1</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/tests/integration/sparse_vector_index_search_tests.rs</h1>
        <h2>Model: Claude Opus 4.1</h2>
        <p><a href="../../models/anthropic_claude-opus-4.1.html">All Claude Opus 4.1 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Claude Opus 4.1</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56319</p>
                <p><strong>Native Prompt Tokens:</strong> 76314</p>
                <p><strong>Native Completion Tokens:</strong> 877</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $1.210485</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-opus-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-opus-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-opus-4.1/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 1e234a3f7..1400ec84e 100644</div><div class="diff-header">--- a/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_expectedoutput.txt (expected):tmp/tmp0x6qzfll_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_segment_tests_integration_sparse_vector_index_search_tests.rs_extracted.txt (actual):tmp/tmp2yciiioy_actual.txt	</div><div class="diff-info">@@ -1,802 +1,76 @@</div><div class="diff-removed">-use std::cmp::max;</div><div class="diff-removed">-use std::collections::HashMap;</div><div class="diff-removed">-use std::fs::remove_file;</div><div class="diff-removed">-use std::sync::atomic::AtomicBool;</div><div class="diff-added">+I'll analyze the entire sparse vector index search tests file and create a comprehensive summary of its test coverage.</div><div> </div><div class="diff-removed">-use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-use common::types::{PointOffsetType, TelemetryDetail};</div><div class="diff-removed">-use io::storage_version::VERSION_FILE;</div><div class="diff-removed">-use itertools::Itertools;</div><div class="diff-removed">-use rand::SeedableRng;</div><div class="diff-removed">-use rand::rngs::StdRng;</div><div class="diff-removed">-use segment::common::operation_error::OperationResult;</div><div class="diff-removed">-use segment::data_types::named_vectors::NamedVectors;</div><div class="diff-removed">-use segment::data_types::vectors::{QueryVector, VectorInternal};</div><div class="diff-removed">-use segment::entry::entry_point::SegmentEntry;</div><div class="diff-removed">-use segment::fixtures::payload_fixtures::STR_KEY;</div><div class="diff-removed">-use segment::fixtures::sparse_fixtures::{fixture_sparse_index, fixture_sparse_index_from_iter};</div><div class="diff-removed">-use segment::index::sparse_index::sparse_index_config::{SparseIndexConfig, SparseIndexType};</div><div class="diff-removed">-use segment::index::sparse_index::sparse_vector_index::{</div><div class="diff-removed">-    SparseVectorIndex, SparseVectorIndexOpenArgs,</div><div class="diff-removed">-};</div><div class="diff-removed">-use segment::index::{PayloadIndex, VectorIndex, VectorIndexEnum};</div><div class="diff-removed">-use segment::json_path::JsonPath;</div><div class="diff-removed">-use segment::segment::Segment;</div><div class="diff-removed">-use segment::segment_constructor::{build_segment, load_segment};</div><div class="diff-removed">-use segment::types::PayloadFieldSchema::FieldType;</div><div class="diff-removed">-use segment::types::PayloadSchemaType::Keyword;</div><div class="diff-removed">-use segment::types::{</div><div class="diff-removed">-    Condition, DEFAULT_SPARSE_FULL_SCAN_THRESHOLD, FieldCondition, Filter, ScoredPoint,</div><div class="diff-removed">-    SegmentConfig, SeqNumberType, SparseVectorDataConfig, SparseVectorStorageType, VectorName,</div><div class="diff-removed">-    VectorStorageDatatype,</div><div class="diff-removed">-};</div><div class="diff-removed">-use segment::vector_storage::VectorStorage;</div><div class="diff-removed">-use segment::{fixture_for_all_indices, payload_json};</div><div class="diff-removed">-use sparse::common::sparse_vector::SparseVector;</div><div class="diff-removed">-use sparse::common::sparse_vector_fixture::{random_full_sparse_vector, random_sparse_vector};</div><div class="diff-removed">-use sparse::common::types::DimId;</div><div class="diff-removed">-use sparse::index::inverted_index::InvertedIndex;</div><div class="diff-removed">-use sparse::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;</div><div class="diff-removed">-use sparse::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;</div><div class="diff-removed">-use sparse::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div class="diff-removed">-use sparse::index::posting_list_common::PostingListIter as _;</div><div class="diff-removed">-use tempfile::Builder;</div><div class="diff-added">+# Sparse Vector Index Search Tests Summary</div><div> </div><div class="diff-removed">-/// Max dimension of sparse vectors used in tests</div><div class="diff-removed">-const MAX_SPARSE_DIM: usize = 4096;</div><div class="diff-added">+## Test Coverage Overview</div><div> </div><div class="diff-removed">-/// Number of vectors to index in tests</div><div class="diff-removed">-const NUM_VECTORS: usize = 2000;</div><div class="diff-added">+This integration test file (`sparse_vector_index_search_tests.rs`) provides comprehensive testing for sparse vector index functionality in the Qdrant vector database segment implementation.</div><div> </div><div class="diff-removed">-/// Default full scan threshold in tests</div><div class="diff-removed">-/// very low value to force usage of index</div><div class="diff-removed">-const LOW_FULL_SCAN_THRESHOLD: usize = 1;</div><div class="diff-added">+## Key Test Areas</div><div> </div><div class="diff-removed">-/// Full scan threshold to force plain search</div><div class="diff-removed">-const LARGE_FULL_SCAN_THRESHOLD: usize = 10 * NUM_VECTORS;</div><div class="diff-added">+### 1. **Search Consistency Tests**</div><div class="diff-added">+- **`compare_sparse_vectors_search_with_without_filter`**: Verifies that search results are consistent when using filters that match all points</div><div class="diff-added">+- **`sparse_vector_index_consistent_with_storage`**: Ensures the sparse vector index accurately reflects the underlying storage data</div><div class="diff-added">+- Tests both RAM and MMAP index implementations</div><div> </div><div class="diff-removed">-const SPARSE_VECTOR_NAME: &VectorName = "sparse_vector";</div><div class="diff-added">+### 2. **Deleted Points Handling**</div><div class="diff-added">+- **`sparse_vector_index_ram_deleted_points_search`**: Tests that deleted points are properly excluded from search results</div><div class="diff-added">+- Verifies index refresh after point deletion</div><div> </div><div class="diff-removed">-/// Expects the filter to match ALL points in order to compare the results with/without filter</div><div class="diff-removed">-fn compare_sparse_vectors_search_with_without_filter(full_scan_threshold: usize) {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(43);</div><div class="diff-added">+### 3. **Filtered Search**</div><div class="diff-added">+- **`sparse_vector_index_ram_filtered_search`**: Tests payload-based filtering with sparse vector search</div><div class="diff-added">+- Verifies payload field indexing and filtering capabilities</div><div> </div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-added">+### 4. **Plain Search Fallback**</div><div class="diff-added">+- **`sparse_vector_index_plain_search`**: Tests the fallback to plain search when full scan threshold is exceeded</div><div class="diff-added">+- Measures telemetry data for plain search usage</div><div> </div><div class="diff-removed">-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div class="diff-removed">-        &mut rnd,</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-removed">-        full_scan_threshold,</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-    );</div><div class="diff-added">+### 5. **Edge Cases**</div><div class="diff-added">+- **`handling_empty_sparse_vectors`**: Tests handling of empty sparse vectors (no dimensions)</div><div class="diff-added">+- **`sparse_vector_test_large_index`**: Tests handling of maximum dimension indices (DimId::MAX)</div><div> </div><div class="diff-removed">-    // random query vectors</div><div class="diff-removed">-    let attempts = 1000;</div><div class="diff-removed">-    let query_vectors = (0..attempts)</div><div class="diff-removed">-        .map(|_| random_sparse_vector(&mut rnd, MAX_SPARSE_DIM))</div><div class="diff-removed">-        .collect::<Vec<_>>();</div><div class="diff-added">+### 6. **Persistence**</div><div class="diff-added">+- **`sparse_vector_index_persistence_test`**: Comprehensive test of index persistence across segment reloads</div><div class="diff-added">+- Tests both RAM and MMAP index persistence</div><div class="diff-added">+- Verifies index recreation when version files are deleted</div><div> </div><div class="diff-removed">-    // filter matches everything</div><div class="diff-removed">-    let filter = Filter::new_must_not(Condition::Field(FieldCondition::new_match(</div><div class="diff-removed">-        JsonPath::new(STR_KEY),</div><div class="diff-removed">-        STR_KEY.to_owned().into(),</div><div class="diff-removed">-    )));</div><div class="diff-added">+### 7. **File Management**</div><div class="diff-added">+- **`sparse_vector_index_files`**: Verifies correct file creation for different index types</div><div class="diff-added">+- Tests file existence and count for both RAM and MMAP implementations</div><div> </div><div class="diff-removed">-    // compares results with and without filters</div><div class="diff-removed">-    // expects the filter to have no effect on the results because the filter matches everything</div><div class="diff-removed">-    for query in query_vectors {</div><div class="diff-removed">-        let maximum_number_of_results = sparse_vector_index.max_result_count(&query);</div><div class="diff-removed">-        // get all results minus 10 to force a bit of pruning</div><div class="diff-removed">-        let top = max(1, maximum_number_of_results.saturating_sub(10));</div><div class="diff-removed">-        let query_vector: QueryVector = query.clone().into();</div><div class="diff-removed">-        // with filter</div><div class="diff-removed">-        let index_results_filter = sparse_vector_index</div><div class="diff-removed">-            .search(</div><div class="diff-removed">-                &[&query_vector],</div><div class="diff-removed">-                Some(&filter),</div><div class="diff-removed">-                top,</div><div class="diff-removed">-                None,</div><div class="diff-removed">-                &Default::default(),</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .unwrap();</div><div class="diff-added">+## Test Infrastructure</div><div> </div><div class="diff-removed">-        // without filter</div><div class="diff-removed">-        let index_results_no_filter = sparse_vector_index</div><div class="diff-removed">-            .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-added">+### Constants</div><div class="diff-added">+- `MAX_SPARSE_DIM`: 4096 - Maximum sparse vector dimension</div><div class="diff-added">+- `NUM_VECTORS`: 2000 - Number of test vectors</div><div class="diff-added">+- `LOW_FULL_SCAN_THRESHOLD`: 1 - Forces index usage</div><div class="diff-added">+- `LARGE_FULL_SCAN_THRESHOLD`: 20000 - Forces plain search</div><div> </div><div class="diff-removed">-        assert_eq!(index_results_filter.len(), index_results_no_filter.len());</div><div class="diff-added">+### Index Types Tested</div><div class="diff-added">+- `InvertedIndexRam` - Mutable RAM index</div><div class="diff-added">+- `InvertedIndexCompressedImmutableRam` - Compressed immutable RAM index</div><div class="diff-added">+- `InvertedIndexCompressedMmap` - Compressed memory-mapped index</div><div> </div><div class="diff-removed">-        for (filter_result, no_filter_result) in index_results_filter</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .zip(index_results_no_filter.iter())</div><div class="diff-removed">-        {</div><div class="diff-removed">-            assert_eq!(</div><div class="diff-removed">-                filter_result.len(),</div><div class="diff-removed">-                no_filter_result.len(),</div><div class="diff-removed">-                "query = {query:#?}, filter_result = {filter_result:#?} no_filter_result = {no_filter_result:#?}",</div><div class="diff-removed">-            );</div><div class="diff-removed">-            // skip zero scores because index skips non-overlapping points, but plain search does not</div><div class="diff-removed">-            for (filter_result, no_filter_result) in filter_result</div><div class="diff-removed">-                .iter()</div><div class="diff-removed">-                .filter(|s| s.score != 0.0)</div><div class="diff-removed">-                .zip(no_filter_result.iter().filter(|s| s.score != 0.0))</div><div class="diff-removed">-            {</div><div class="diff-removed">-                if filter_result.idx != no_filter_result.idx {</div><div class="diff-removed">-                    // we do not break ties when identical scores</div><div class="diff-removed">-                    assert_eq!(filter_result.score, no_filter_result.score);</div><div class="diff-removed">-                } else {</div><div class="diff-removed">-                    assert_eq!(filter_result, no_filter_result);</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+### Helper Functions</div><div class="diff-added">+- `check_index_storage_consistency`: Validates posting lists match storage</div><div class="diff-added">+- `check_persistence`: Generic persistence testing across index types</div><div> </div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_ram_filter_search() {</div><div class="diff-removed">-    // very low full scan threshold to force usage of inverted index</div><div class="diff-removed">-    compare_sparse_vectors_search_with_without_filter(LOW_FULL_SCAN_THRESHOLD);</div><div class="diff-removed">-}</div><div class="diff-added">+## Key Features Validated</div><div> </div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_fallback_plain_search() {</div><div class="diff-removed">-    // very high full scan threshold to force fallback to plain search</div><div class="diff-removed">-    compare_sparse_vectors_search_with_without_filter(NUM_VECTORS + 1);</div><div class="diff-removed">-}</div><div class="diff-added">+1. **Correctness**: Search results match expected outcomes</div><div class="diff-added">+2. **Performance**: Proper fallback between indexed and plain search</div><div class="diff-added">+3. **Persistence**: Data survives restarts and format migrations</div><div class="diff-added">+4. **Memory Management**: Both RAM and MMAP implementations work correctly</div><div class="diff-added">+5. **Edge Cases**: Handles empty vectors and extreme dimension values</div><div class="diff-added">+6. **Filtering**: Payload-based filtering integrates with sparse search</div><div class="diff-added">+7. **Deletion**: Points can be deleted and are excluded from results</div><div class="diff-added">+8. **Hardware Counters**: IO measurement integration for performance monitoring</div><div> </div><div class="diff-removed">-/// Checks that the sparse vector index is consistent with the underlying storage</div><div class="diff-removed">-#[cfg(test)]</div><div class="diff-removed">-fn check_index_storage_consistency<T: InvertedIndex>(sparse_vector_index: &SparseVectorIndex<T>) {</div><div class="diff-removed">-    let borrowed_vector_storage = sparse_vector_index.vector_storage().borrow();</div><div class="diff-removed">-    let point_count = borrowed_vector_storage.available_vector_count();</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::disposable();</div><div class="diff-removed">-    for id in 0..point_count as PointOffsetType {</div><div class="diff-removed">-        // assuming no deleted points</div><div class="diff-removed">-        let vector = borrowed_vector_storage.get_vector(id);</div><div class="diff-removed">-        let vector: &SparseVector = vector.as_vec_ref().try_into().unwrap();</div><div class="diff-removed">-        let remapped_vector = sparse_vector_index</div><div class="diff-removed">-            .indices_tracker()</div><div class="diff-removed">-            .remap_vector(vector.to_owned());</div><div class="diff-removed">-        // check posting lists are consistent with storage</div><div class="diff-removed">-        for (dim_id, dim_value) in remapped_vector</div><div class="diff-removed">-            .indices</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .zip(remapped_vector.values.iter())</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let posting_list = sparse_vector_index</div><div class="diff-removed">-                .inverted_index()</div><div class="diff-removed">-                .get(*dim_id, &hw_counter)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            // assert posting list sorted by record id</div><div class="diff-removed">-            assert!(</div><div class="diff-removed">-                posting_list</div><div class="diff-removed">-                    .clone()</div><div class="diff-removed">-                    .into_std_iter()</div><div class="diff-removed">-                    .tuple_windows()</div><div class="diff-removed">-                    .all(|(w0, w1)| w0.record_id < w1.record_id),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            // assert posted list contains record id</div><div class="diff-removed">-            assert!(</div><div class="diff-removed">-                posting_list</div><div class="diff-removed">-                    .into_std_iter()</div><div class="diff-removed">-                    .any(|e| e.record_id == id && e.weight == *dim_value),</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // check the vector can be found via search using large top</div><div class="diff-removed">-        let top = sparse_vector_index.max_result_count(vector);</div><div class="diff-removed">-        let query_vector: QueryVector = vector.to_owned().into();</div><div class="diff-removed">-        let results = sparse_vector_index</div><div class="diff-removed">-            .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert!(results[0].iter().any(|s| s.idx == id));</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-added">+## Testing Methodology</div><div> </div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_consistent_with_storage() {</div><div class="diff-removed">-    let stopped = AtomicBool::new(false);</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-added">+- Uses deterministic random seeds for reproducibility</div><div class="diff-added">+- Tests multiple index implementations using `fixture_for_all_indices` macro</div><div class="diff-added">+- Validates both functional correctness and internal data structure consistency</div><div class="diff-added">+- Includes both unit-style focused tests and integration scenarios</div><div> </div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    let sparse_vector_ram_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div class="diff-removed">-        &mut rnd,</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-removed">-        LOW_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // check consistency with underlying RAM inverted index</div><div class="diff-removed">-    check_index_storage_consistency(&sparse_vector_ram_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    let mmap_index_dir = Builder::new().prefix("mmap_index_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    // create mmap sparse vector index</div><div class="diff-removed">-    let mut sparse_index_config = sparse_vector_ram_index.config();</div><div class="diff-removed">-    sparse_index_config.index_type = SparseIndexType::Mmap;</div><div class="diff-removed">-    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =</div><div class="diff-removed">-        SparseVectorIndex::open(SparseVectorIndexOpenArgs {</div><div class="diff-removed">-            config: sparse_index_config,</div><div class="diff-removed">-            id_tracker: sparse_vector_ram_index.id_tracker().clone(),</div><div class="diff-removed">-            vector_storage: sparse_vector_ram_index.vector_storage().clone(),</div><div class="diff-removed">-            payload_index: sparse_vector_ram_index.payload_index().clone(),</div><div class="diff-removed">-            path: mmap_index_dir.path(),</div><div class="diff-removed">-            stopped: &stopped,</div><div class="diff-removed">-            tick_progress: || (),</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_mmap_index.indexed_vector_count(),</div><div class="diff-removed">-        sparse_vector_ram_index.indexed_vector_count()</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // check consistency with underlying mmap inverted index</div><div class="diff-removed">-    check_index_storage_consistency(&sparse_vector_mmap_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // drop and reload index</div><div class="diff-removed">-    drop(sparse_vector_mmap_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // load index from memmap file</div><div class="diff-removed">-    let mut sparse_index_config = sparse_vector_ram_index.config();</div><div class="diff-removed">-    sparse_index_config.index_type = SparseIndexType::Mmap;</div><div class="diff-removed">-    let sparse_vector_mmap_index: SparseVectorIndex<InvertedIndexCompressedMmap<f32>> =</div><div class="diff-removed">-        SparseVectorIndex::open(SparseVectorIndexOpenArgs {</div><div class="diff-removed">-            config: sparse_index_config,</div><div class="diff-removed">-            id_tracker: sparse_vector_ram_index.id_tracker().clone(),</div><div class="diff-removed">-            vector_storage: sparse_vector_ram_index.vector_storage().clone(),</div><div class="diff-removed">-            payload_index: sparse_vector_ram_index.payload_index().clone(),</div><div class="diff-removed">-            path: mmap_index_dir.path(),</div><div class="diff-removed">-            stopped: &stopped,</div><div class="diff-removed">-            tick_progress: || (),</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_mmap_index.indexed_vector_count(),</div><div class="diff-removed">-        sparse_vector_ram_index.indexed_vector_count()</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // check consistency with underlying mmap inverted index</div><div class="diff-removed">-    check_index_storage_consistency(&sparse_vector_mmap_index);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_load_missing_mmap() {</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    let sparse_vector_index: OperationResult<SparseVectorIndex<InvertedIndexCompressedMmap<f32>>> =</div><div class="diff-removed">-        fixture_sparse_index_from_iter(</div><div class="diff-removed">-            data_dir.path(),</div><div class="diff-removed">-            [].iter().cloned(),</div><div class="diff-removed">-            10_000,</div><div class="diff-removed">-            SparseIndexType::Mmap,</div><div class="diff-removed">-        );</div><div class="diff-removed">-    // absent configuration file for mmap are ignored</div><div class="diff-removed">-    // a new index is created</div><div class="diff-removed">-    assert!(sparse_vector_index.is_ok())</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_ram_deleted_points_search() {</div><div class="diff-removed">-    let top = 10;</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-removed">-</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let sparse_vector_index = fixture_sparse_index_from_iter::<InvertedIndexRam>(</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-        (0..NUM_VECTORS).map(|_| random_sparse_vector(&mut rnd, MAX_SPARSE_DIM)),</div><div class="diff-removed">-        LOW_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-        SparseIndexType::MutableRam,</div><div class="diff-removed">-    )</div><div class="diff-removed">-    .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    // sanity check (all indexed, no deleted points)</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .id_tracker()</div><div class="diff-removed">-            .borrow()</div><div class="diff-removed">-            .available_point_count(),</div><div class="diff-removed">-        sparse_vector_index.indexed_vector_count()</div><div class="diff-removed">-    );</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .id_tracker()</div><div class="diff-removed">-            .borrow()</div><div class="diff-removed">-            .deleted_point_count(),</div><div class="diff-removed">-        0</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // query index</div><div class="diff-removed">-    let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();</div><div class="diff-removed">-    let before_deletion_results: Vec<_> = sparse_vector_index</div><div class="diff-removed">-        .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    // pick a point to delete</div><div class="diff-removed">-    let deleted_idx = before_deletion_results[0][0].idx;</div><div class="diff-removed">-</div><div class="diff-removed">-    // delete a point</div><div class="diff-removed">-    let deleted_external = sparse_vector_index</div><div class="diff-removed">-        .id_tracker()</div><div class="diff-removed">-        .borrow_mut()</div><div class="diff-removed">-        .external_id(deleted_idx)</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    sparse_vector_index</div><div class="diff-removed">-        .id_tracker()</div><div class="diff-removed">-        .borrow_mut()</div><div class="diff-removed">-        .drop(deleted_external)</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .id_tracker()</div><div class="diff-removed">-            .borrow()</div><div class="diff-removed">-            .is_deleted_point(deleted_idx),</div><div class="diff-removed">-    );</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .id_tracker()</div><div class="diff-removed">-            .borrow()</div><div class="diff-removed">-            .deleted_point_count(),</div><div class="diff-removed">-        1</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // assert that the deleted point is no longer in the index</div><div class="diff-removed">-    let after_deletion_results: Vec<_> = sparse_vector_index</div><div class="diff-removed">-        .search(&[&query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    assert_ne!(before_deletion_results, after_deletion_results);</div><div class="diff-removed">-    assert!(</div><div class="diff-removed">-        after_deletion_results</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .all(|x| x.iter().all(|y| y.idx != deleted_idx)),</div><div class="diff-removed">-    );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_ram_filtered_search() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-removed">-</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    // setup index</div><div class="diff-removed">-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div class="diff-removed">-        &mut rnd,</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-removed">-        LOW_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // query index by payload</div><div class="diff-removed">-    let field_name = "field";</div><div class="diff-removed">-    let field_value = "important value";</div><div class="diff-removed">-    let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(</div><div class="diff-removed">-        JsonPath::new(field_name),</div><div class="diff-removed">-        field_value.to_owned().into(),</div><div class="diff-removed">-    )));</div><div class="diff-removed">-</div><div class="diff-removed">-    // query all sparse dimension to get all points</div><div class="diff-removed">-    let query_vector: QueryVector = random_full_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();</div><div class="diff-removed">-    let before_result = sparse_vector_index</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            &[&query_vector],</div><div class="diff-removed">-            Some(&filter),</div><div class="diff-removed">-            10,</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    assert_eq!(before_result.len(), 1);</div><div class="diff-removed">-    assert_eq!(before_result[0].len(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-    // create payload field index</div><div class="diff-removed">-    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();</div><div class="diff-removed">-    payload_index</div><div class="diff-removed">-        .set_indexed(&JsonPath::new(field_name), Keyword, &hw_counter)</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    drop(payload_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // assert payload field index created and empty</div><div class="diff-removed">-    let payload_index = sparse_vector_index.payload_index().borrow();</div><div class="diff-removed">-    let indexed_fields = payload_index.indexed_fields();</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        *indexed_fields.get(&JsonPath::new(field_name)).unwrap(),</div><div class="diff-removed">-        FieldType(Keyword)</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    let field_indexes = &payload_index.field_indexes;</div><div class="diff-removed">-    let field_index = field_indexes.get(&JsonPath::new(field_name)).unwrap();</div><div class="diff-removed">-    assert_eq!(field_index[0].count_indexed_points(), 0);</div><div class="diff-removed">-    drop(payload_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // add payload on the first half of the points</div><div class="diff-removed">-    let half_indexed_count = sparse_vector_index.indexed_vector_count() / 2;</div><div class="diff-removed">-    let payload = payload_json! {field_name: field_value};</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();</div><div class="diff-removed">-    for idx in 0..half_indexed_count {</div><div class="diff-removed">-        payload_index</div><div class="diff-removed">-            .set_payload(idx as PointOffsetType, &payload, &None, &hw_counter)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-    }</div><div class="diff-removed">-    drop(payload_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // assert payload index updated</div><div class="diff-removed">-    let payload_index = sparse_vector_index.payload_index().borrow();</div><div class="diff-removed">-    let field_indexes = &payload_index.field_indexes;</div><div class="diff-removed">-    let field_index = field_indexes.get(&JsonPath::new(field_name)).unwrap();</div><div class="diff-removed">-    assert_eq!(field_index[0].count_indexed_points(), half_indexed_count);</div><div class="diff-removed">-    drop(payload_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // request all points with payload</div><div class="diff-removed">-    let after_result = sparse_vector_index</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            &[&query_vector],</div><div class="diff-removed">-            Some(&filter),</div><div class="diff-removed">-            half_indexed_count * 2, // original top</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    assert_eq!(after_result.len(), 1);</div><div class="diff-removed">-    assert_eq!(after_result[0].len(), half_indexed_count); // expect half of the points</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_plain_search() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-removed">-</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    // setup index</div><div class="diff-removed">-    let sparse_vector_index = fixture_sparse_index::<InvertedIndexCompressedImmutableRam<f32>, _>(</div><div class="diff-removed">-        &mut rnd,</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-removed">-        LARGE_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // query index by payload</div><div class="diff-removed">-    let field_name = "field";</div><div class="diff-removed">-    let field_value = "important value";</div><div class="diff-removed">-    let filter = Filter::new_must(Condition::Field(FieldCondition::new_match(</div><div class="diff-removed">-        JsonPath::new(field_name),</div><div class="diff-removed">-        field_value.to_owned().into(),</div><div class="diff-removed">-    )));</div><div class="diff-removed">-</div><div class="diff-removed">-    // query all sparse dimension to get all points</div><div class="diff-removed">-    let query_vector: QueryVector = random_full_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();</div><div class="diff-removed">-</div><div class="diff-removed">-    // empty when searching payload index directly</div><div class="diff-removed">-    let before_plain_results = sparse_vector_index</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            &[&query_vector],</div><div class="diff-removed">-            Some(&filter),</div><div class="diff-removed">-            10,</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(before_plain_results.len(), 1);</div><div class="diff-removed">-    assert_eq!(before_plain_results[0].len(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-    let payload = payload_json! {field_name: field_value};</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-    // add payload to all points</div><div class="diff-removed">-    let mut payload_index = sparse_vector_index.payload_index().borrow_mut();</div><div class="diff-removed">-    for idx in 0..NUM_VECTORS {</div><div class="diff-removed">-        payload_index</div><div class="diff-removed">-            .set_payload(idx as PointOffsetType, &payload, &None, &hw_counter)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-    }</div><div class="diff-removed">-    drop(payload_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // same results when searching payload index directly</div><div class="diff-removed">-    let after_plain_results = sparse_vector_index</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            &[&query_vector],</div><div class="diff-removed">-            Some(&filter),</div><div class="diff-removed">-            NUM_VECTORS,</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(after_plain_results.len(), 1);</div><div class="diff-removed">-    assert_eq!(after_plain_results[0].len(), NUM_VECTORS);</div><div class="diff-removed">-</div><div class="diff-removed">-    // check that plain searchers were used</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .get_telemetry_data(TelemetryDetail::default())</div><div class="diff-removed">-            .filtered_small_cardinality</div><div class="diff-removed">-            .count,</div><div class="diff-removed">-        2</div><div class="diff-removed">-    );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn handling_empty_sparse_vectors() {</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-removed">-</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    let sparse_vector_index: SparseVectorIndex<InvertedIndexCompressedImmutableRam<f32>> =</div><div class="diff-removed">-        fixture_sparse_index_from_iter(</div><div class="diff-removed">-            data_dir.path(),</div><div class="diff-removed">-            (0..NUM_VECTORS).map(|_| SparseVector::default()),</div><div class="diff-removed">-            DEFAULT_SPARSE_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-            SparseIndexType::ImmutableRam,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    let mut borrowed_storage = sparse_vector_index.vector_storage().borrow_mut();</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-    // add empty points to storage</div><div class="diff-removed">-    for idx in 0..NUM_VECTORS {</div><div class="diff-removed">-        let vec = &SparseVector::new(vec![], vec![]).unwrap();</div><div class="diff-removed">-        borrowed_storage</div><div class="diff-removed">-            .insert_vector(idx as PointOffsetType, vec.into(), &hw_counter)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-    }</div><div class="diff-removed">-    drop(borrowed_storage);</div><div class="diff-removed">-</div><div class="diff-removed">-    // assert all empty points are in storage</div><div class="diff-removed">-    assert_eq!(</div><div class="diff-removed">-        sparse_vector_index</div><div class="diff-removed">-            .vector_storage()</div><div class="diff-removed">-            .borrow()</div><div class="diff-removed">-            .available_vector_count(),</div><div class="diff-removed">-        NUM_VECTORS,</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    // empty vectors are not indexed</div><div class="diff-removed">-    assert_eq!(sparse_vector_index.indexed_vector_count(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-    let query_vector: QueryVector = random_sparse_vector(&mut rnd, MAX_SPARSE_DIM).into();</div><div class="diff-removed">-</div><div class="diff-removed">-    // empty vectors are not searchable (recommend using scroll API to retrieve those)</div><div class="diff-removed">-    let results = sparse_vector_index</div><div class="diff-removed">-        .search(&[&query_vector], None, 10, None, &Default::default())</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-    assert_eq!(results.len(), 1);</div><div class="diff-removed">-    assert_eq!(results[0].len(), 0);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_persistence_test() {</div><div class="diff-removed">-    let stopped = AtomicBool::new(false);</div><div class="diff-removed">-</div><div class="diff-removed">-    let dim = 8;</div><div class="diff-removed">-    let num_vectors: u64 = 5_000;</div><div class="diff-removed">-    let top = 3;</div><div class="diff-removed">-    let mut rnd = StdRng::seed_from_u64(42);</div><div class="diff-removed">-</div><div class="diff-removed">-    let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let config = SegmentConfig {</div><div class="diff-removed">-        vector_data: Default::default(),</div><div class="diff-removed">-        sparse_vector_data: HashMap::from([(</div><div class="diff-removed">-            SPARSE_VECTOR_NAME.to_owned(),</div><div class="diff-removed">-            SparseVectorDataConfig {</div><div class="diff-removed">-                index: SparseIndexConfig {</div><div class="diff-removed">-                    full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),</div><div class="diff-removed">-                    index_type: SparseIndexType::MutableRam,</div><div class="diff-removed">-                    datatype: Some(VectorStorageDatatype::Float32),</div><div class="diff-removed">-                },</div><div class="diff-removed">-                storage_type: SparseVectorStorageType::default(),</div><div class="diff-removed">-            },</div><div class="diff-removed">-        )]),</div><div class="diff-removed">-        payload_storage_type: Default::default(),</div><div class="diff-removed">-    };</div><div class="diff-removed">-    let mut segment = build_segment(dir.path(), &config, true).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-    for n in 0..num_vectors {</div><div class="diff-removed">-        let vector: VectorInternal = random_sparse_vector(&mut rnd, dim).into();</div><div class="diff-removed">-        let mut named_vector = NamedVectors::default();</div><div class="diff-removed">-        named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);</div><div class="diff-removed">-        let idx = n.into();</div><div class="diff-removed">-        segment</div><div class="diff-removed">-            .upsert_point(n as SeqNumberType, idx, named_vector, &hw_counter)</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-    }</div><div class="diff-removed">-    segment.flush(true, false).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let search_vector = random_sparse_vector(&mut rnd, dim);</div><div class="diff-removed">-    let query_vector: QueryVector = search_vector.into();</div><div class="diff-removed">-</div><div class="diff-removed">-    let search_result = segment</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            SPARSE_VECTOR_NAME,</div><div class="diff-removed">-            &query_vector,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            top,</div><div class="diff-removed">-            None,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(search_result.len(), top);</div><div class="diff-removed">-</div><div class="diff-removed">-    let path = segment.current_path.clone();</div><div class="diff-removed">-    drop(segment);</div><div class="diff-removed">-</div><div class="diff-removed">-    // persistence using rebuild of inverted index</div><div class="diff-removed">-    // for appendable segment vector index has to be rebuilt</div><div class="diff-removed">-    let segment = load_segment(&path, &stopped).unwrap().unwrap();</div><div class="diff-removed">-    let search_after_reload_result = segment</div><div class="diff-removed">-        .search(</div><div class="diff-removed">-            SPARSE_VECTOR_NAME,</div><div class="diff-removed">-            &query_vector,</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-            &Default::default(),</div><div class="diff-removed">-            None,</div><div class="diff-removed">-            top,</div><div class="diff-removed">-            None,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    assert_eq!(search_after_reload_result.len(), top);</div><div class="diff-removed">-    assert_eq!(search_result, search_after_reload_result);</div><div class="diff-removed">-</div><div class="diff-removed">-    fixture_for_all_indices!(check_persistence::<_>(</div><div class="diff-removed">-        &segment,</div><div class="diff-removed">-        &search_result,</div><div class="diff-removed">-        &query_vector,</div><div class="diff-removed">-        top</div><div class="diff-removed">-    ));</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn check_persistence<TInvertedIndex: InvertedIndex>(</div><div class="diff-removed">-    segment: &Segment,</div><div class="diff-removed">-    search_result: &[ScoredPoint],</div><div class="diff-removed">-    query_vector: &QueryVector,</div><div class="diff-removed">-    top: usize,</div><div class="diff-removed">-) {</div><div class="diff-removed">-    let stopped = AtomicBool::new(false);</div><div class="diff-removed">-</div><div class="diff-removed">-    let inverted_index_dir = Builder::new()</div><div class="diff-removed">-        .prefix("inverted_index_ram")</div><div class="diff-removed">-        .tempdir()</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let open_index = || -> SparseVectorIndex<TInvertedIndex> {</div><div class="diff-removed">-        SparseVectorIndex::open(SparseVectorIndexOpenArgs {</div><div class="diff-removed">-            config: SparseIndexConfig {</div><div class="diff-removed">-                full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),</div><div class="diff-removed">-                index_type: SparseIndexType::Mmap,</div><div class="diff-removed">-                datatype: Some(VectorStorageDatatype::Float32),</div><div class="diff-removed">-            },</div><div class="diff-removed">-            id_tracker: segment.id_tracker.clone(),</div><div class="diff-removed">-            vector_storage: segment.vector_data[SPARSE_VECTOR_NAME]</div><div class="diff-removed">-                .vector_storage</div><div class="diff-removed">-                .clone(),</div><div class="diff-removed">-            payload_index: segment.payload_index.clone(),</div><div class="diff-removed">-            path: inverted_index_dir.path(),</div><div class="diff-removed">-            stopped: &stopped,</div><div class="diff-removed">-            tick_progress: || (),</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .unwrap()</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    let check_search = |sparse_vector_index: &SparseVectorIndex<TInvertedIndex>| {</div><div class="diff-removed">-        // check that the loaded index performs the same search</div><div class="diff-removed">-        let search_after_reload_result = sparse_vector_index</div><div class="diff-removed">-            .search(&[query_vector], None, top, None, &Default::default())</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-        assert_eq!(search_after_reload_result[0].len(), top);</div><div class="diff-removed">-        for (search_1, search_2) in search_result</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .zip(search_after_reload_result[0].iter())</div><div class="diff-removed">-        {</div><div class="diff-removed">-            let id_1 = segment</div><div class="diff-removed">-                .id_tracker</div><div class="diff-removed">-                .borrow_mut()</div><div class="diff-removed">-                .internal_id(search_1.id)</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            assert_eq!(id_1, search_2.idx);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    let sparse_vector_index = open_index();</div><div class="diff-removed">-</div><div class="diff-removed">-    let version_file = inverted_index_dir.path().join(VERSION_FILE);</div><div class="diff-removed">-    assert!(version_file.exists());</div><div class="diff-removed">-</div><div class="diff-removed">-    // reload sparse index from file</div><div class="diff-removed">-    drop(sparse_vector_index);</div><div class="diff-removed">-    let sparse_vector_index = open_index();</div><div class="diff-removed">-    check_search(&sparse_vector_index);</div><div class="diff-removed">-</div><div class="diff-removed">-    // drop version file and reload index</div><div class="diff-removed">-    drop(sparse_vector_index);</div><div class="diff-removed">-    remove_file(&version_file).unwrap();</div><div class="diff-removed">-    let sparse_vector_index = open_index();</div><div class="diff-removed">-    assert!(version_file.exists(), "version file should be recreated");</div><div class="diff-removed">-    check_search(&sparse_vector_index);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_index_files() {</div><div class="diff-removed">-    fixture_for_all_indices!(check_sparse_vector_index_files::<_>());</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn check_sparse_vector_index_files<I: InvertedIndex>() {</div><div class="diff-removed">-    let data_dir = Builder::new().prefix("data_dir").tempdir().unwrap();</div><div class="diff-removed">-    let index = fixture_sparse_index::<I, _>(</div><div class="diff-removed">-        &mut StdRng::seed_from_u64(42),</div><div class="diff-removed">-        1,</div><div class="diff-removed">-        MAX_SPARSE_DIM,</div><div class="diff-removed">-        LOW_FULL_SCAN_THRESHOLD,</div><div class="diff-removed">-        data_dir.path(),</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-removed">-    let files = index.files();</div><div class="diff-removed">-    // sparse index config + version + inverted index config + inverted index data + tracker</div><div class="diff-removed">-    assert_eq!(files.len(), 5);</div><div class="diff-removed">-    for file in files.iter() {</div><div class="diff-removed">-        assert!(file.exists(), "file {file:?} does not exist");</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[test]</div><div class="diff-removed">-fn sparse_vector_test_large_index() {</div><div class="diff-removed">-    let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-    let config = SegmentConfig {</div><div class="diff-removed">-        vector_data: Default::default(),</div><div class="diff-removed">-        sparse_vector_data: HashMap::from([(</div><div class="diff-removed">-            SPARSE_VECTOR_NAME.to_owned(),</div><div class="diff-removed">-            SparseVectorDataConfig {</div><div class="diff-removed">-                index: SparseIndexConfig {</div><div class="diff-removed">-                    full_scan_threshold: Some(DEFAULT_SPARSE_FULL_SCAN_THRESHOLD),</div><div class="diff-removed">-                    index_type: SparseIndexType::MutableRam,</div><div class="diff-removed">-                    datatype: Some(VectorStorageDatatype::Float32),</div><div class="diff-removed">-                },</div><div class="diff-removed">-                storage_type: SparseVectorStorageType::OnDisk,</div><div class="diff-removed">-            },</div><div class="diff-removed">-        )]),</div><div class="diff-removed">-        payload_storage_type: Default::default(),</div><div class="diff-removed">-    };</div><div class="diff-removed">-    let mut segment = build_segment(dir.path(), &config, true).unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-    let vector: VectorInternal = SparseVector {</div><div class="diff-removed">-        indices: vec![DimId::MAX],</div><div class="diff-removed">-        values: vec![0.0],</div><div class="diff-removed">-    }</div><div class="diff-removed">-    .into();</div><div class="diff-removed">-    let mut named_vector = NamedVectors::default();</div><div class="diff-removed">-    named_vector.insert(SPARSE_VECTOR_NAME.to_owned(), vector);</div><div class="diff-removed">-    let idx = 0.into();</div><div class="diff-removed">-    segment</div><div class="diff-removed">-        .upsert_point(0 as SeqNumberType, idx, named_vector, &hw_counter)</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-    let borrowed_vector_index = segment.vector_data[SPARSE_VECTOR_NAME]</div><div class="diff-removed">-        .vector_index</div><div class="diff-removed">-        .borrow();</div><div class="diff-removed">-    match &*borrowed_vector_index {</div><div class="diff-removed">-        VectorIndexEnum::SparseRam(sparse_vector_index) => {</div><div class="diff-removed">-            assert!(</div><div class="diff-removed">-                sparse_vector_index</div><div class="diff-removed">-                    .indices_tracker()</div><div class="diff-removed">-                    .remap_index(DimId::MAX)</div><div class="diff-removed">-                    .is_some(),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            assert_eq!(sparse_vector_index.inverted_index().max_index().unwrap(), 0);</div><div class="diff-removed">-        }</div><div class="diff-removed">-        _ => panic!("unexpected vector index type"),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+This test suite ensures robust sparse vector indexing functionality across various storage backends, query patterns, and edge cases.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    