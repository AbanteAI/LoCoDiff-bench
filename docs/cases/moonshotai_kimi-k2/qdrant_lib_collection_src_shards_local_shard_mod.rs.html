<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Kimi K2</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <h2>Model: Kimi K2</h2>
        <p><a href="../../models/moonshotai_kimi-k2.html">All Kimi K2 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Kimi K2</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Native Prompt Tokens:</strong> 58801</p>
                <p><strong>Native Completion Tokens:</strong> 9236</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.05475937</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/moonshotai_kimi-k2/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/moonshotai_kimi-k2/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/moonshotai_kimi-k2/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index c9341cb38..6ae87e911 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected):tmp/tmps7bx2lty_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual):tmp/tmpirvbrx2k_actual.txt	</div><div class="diff-info">@@ -52,12 +52,12 @@ use crate::collection_manager::optimizers::TrackerLog;</div><div> use crate::collection_manager::segments_searcher::SegmentsSearcher;</div><div> use crate::common::file_utils::{move_dir, move_file};</div><div> use crate::config::CollectionConfigInternal;</div><div class="diff-removed">-use crate::operations::OperationWithClockTag;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{</div><div>     CollectionError, CollectionResult, OptimizersStatus, ShardInfoInternal, ShardStatus,</div><div>     check_sparse_compatible_with_segment_config,</div><div> };</div><div class="diff-added">+use crate::operations::OperationWithClockTag;</div><div> use crate::optimizers_builder::{OptimizersConfig, build_optimizers, clear_temp_segments};</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::CollectionId;</div><div class="diff-info">@@ -183,6 +183,13 @@ impl LocalShard {</div><div>         )</div><div>         .await;</div><div> </div><div class="diff-added">+        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-added">+            strict_mode</div><div class="diff-added">+                .read_rate_limit</div><div class="diff-added">+                .map(RateLimiter::new_per_minute)</div><div class="diff-added">+                .map(ParkingMutex::new)</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div>         let mut update_handler = UpdateHandler::new(</div><div>             shared_storage_config.clone(),</div><div>             payload_index_schema.clone(),</div><div class="diff-info">@@ -197,6 +204,7 @@ impl LocalShard {</div><div>             config.optimizer_config.max_optimization_threads,</div><div>             clocks.clone(),</div><div>             shard_path.into(),</div><div class="diff-added">+            disk_usage_watcher.clone(),</div><div>         );</div><div> </div><div>         let (update_sender, update_receiver) =</div><div class="diff-info">@@ -205,13 +213,6 @@ impl LocalShard {</div><div> </div><div>         let update_tracker = segment_holder.read().update_tracker();</div><div> </div><div class="diff-removed">-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .read_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(ParkingMutex::new)</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div>         drop(config); // release `shared_config` from borrow checker</div><div> </div><div>         Self {</div><div class="diff-info">@@ -234,8 +235,160 @@ impl LocalShard {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub(super) fn segments(&self) -> &RwLock<SegmentHolder> {</div><div class="diff-removed">-        self.segments.deref()</div><div class="diff-added">+    pub fn shard_path(&self) -> PathBuf {</div><div class="diff-added">+        self.path.clone()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn wal_path(shard_path: &Path) -> PathBuf {</div><div class="diff-added">+        shard_path.join(WAL_PATH)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn segments_path(shard_path: &Path) -> PathBuf {</div><div class="diff-added">+        shard_path.join(SEGMENTS_PATH)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div class="diff-added">+    pub async fn build_local(</div><div class="diff-added">+        id: ShardId,</div><div class="diff-added">+        collection_id: CollectionId,</div><div class="diff-added">+        shard_path: &Path,</div><div class="diff-added">+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+        update_runtime: Handle,</div><div class="diff-added">+        search_runtime: Handle,</div><div class="diff-added">+        optimizer_resource_budget: ResourceBudget,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div class="diff-added">+    ) -> CollectionResult<LocalShard> {</div><div class="diff-added">+        // initialize local shard config file</div><div class="diff-added">+        let local_shard_config = ShardConfig::new_replica_set();</div><div class="diff-added">+        let shard = Self::build(</div><div class="diff-added">+            id,</div><div class="diff-added">+            collection_id,</div><div class="diff-added">+            shard_path,</div><div class="diff-added">+            collection_config,</div><div class="diff-added">+            shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            update_runtime,</div><div class="diff-added">+            search_runtime,</div><div class="diff-added">+            optimizer_resource_budget,</div><div class="diff-added">+            effective_optimizers_config,</div><div class="diff-added">+        )</div><div class="diff-added">+        .await?;</div><div class="diff-added">+        local_shard_config.save(shard_path)?;</div><div class="diff-added">+        Ok(shard)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.</div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div class="diff-added">+    pub async fn build(</div><div class="diff-added">+        id: ShardId,</div><div class="diff-added">+        collection_id: CollectionId,</div><div class="diff-added">+        shard_path: &Path,</div><div class="diff-added">+        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-added">+        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-added">+        update_runtime: Handle,</div><div class="diff-added">+        search_runtime: Handle,</div><div class="diff-added">+        optimizer_resource_budget: ResourceBudget,</div><div class="diff-added">+        effective_optimizers_config: OptimizersConfig,</div><div class="diff-added">+    ) -> CollectionResult<LocalShard> {</div><div class="diff-added">+        let config = collection_config.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        let wal_path = Self::wal_path(shard_path);</div><div class="diff-added">+</div><div class="diff-added">+        create_dir_all(&wal_path).await.map_err(|err| {</div><div class="diff-added">+            CollectionError::service_error(format!(</div><div class="diff-added">+                "Can't create shard wal directory. Error: {err}"</div><div class="diff-added">+            ))</div><div class="diff-added">+        })?;</div><div class="diff-added">+</div><div class="diff-added">+        let segments_path = Self::segments_path(shard_path);</div><div class="diff-added">+</div><div class="diff-added">+        create_dir_all(&segments_path).await.map_err(|err| {</div><div class="diff-added">+            CollectionError::service_error(format!(</div><div class="diff-added">+                "Can't create shard segments directory. Error: {err}"</div><div class="diff-added">+            ))</div><div class="diff-added">+        })?;</div><div class="diff-added">+</div><div class="diff-added">+        let mut segment_holder = SegmentHolder::default();</div><div class="diff-added">+        let mut build_handlers = vec![];</div><div class="diff-added">+</div><div class="diff-added">+        let vector_params = config.params.to_base_vector_data()?;</div><div class="diff-added">+        let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div class="diff-added">+        let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-added">+</div><div class="diff-added">+        for _sid in 0..segment_number {</div><div class="diff-added">+            let path_clone = segments_path.clone();</div><div class="diff-added">+            let segment_config = SegmentConfig {</div><div class="diff-added">+                vector_data: vector_params.clone(),</div><div class="diff-added">+                sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-added">+                payload_storage_type: config.params.payload_storage_type(),</div><div class="diff-added">+            };</div><div class="diff-added">+            let segment = thread::Builder::new()</div><div class="diff-added">+                .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-added">+                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-added">+                .unwrap();</div><div class="diff-added">+            build_handlers.push(segment);</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let join_results = build_handlers</div><div class="diff-added">+            .into_iter()</div><div class="diff-added">+            .map(|handler| handler.join())</div><div class="diff-added">+            .collect_vec();</div><div class="diff-added">+</div><div class="diff-added">+        for join_result in join_results {</div><div class="diff-added">+            let segment = join_result.map_err(|err| {</div><div class="diff-added">+                let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-added">+                let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-added">+</div><div class="diff-added">+                CollectionError::service_error(format!(</div><div class="diff-added">+                    "Segment DB create panicked{separator}{message}",</div><div class="diff-added">+                ))</div><div class="diff-added">+            })??;</div><div class="diff-added">+</div><div class="diff-added">+            segment_holder.add_new(segment);</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-added">+            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div class="diff-added">+</div><div class="diff-added">+        let optimizers = build_optimizers(</div><div class="diff-added">+            shard_path,</div><div class="diff-added">+            &config.params,</div><div class="diff-added">+            &effective_optimizers_config,</div><div class="diff-added">+            &config.hnsw_config,</div><div class="diff-added">+            &config.quantization_config,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(config); // release `shared_config` from borrow checker</div><div class="diff-added">+</div><div class="diff-added">+        let collection = LocalShard::new(</div><div class="diff-added">+            segment_holder,</div><div class="diff-added">+            collection_config,</div><div class="diff-added">+            shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            wal,</div><div class="diff-added">+            optimizers,</div><div class="diff-added">+            optimizer_resource_budget,</div><div class="diff-added">+            shard_path,</div><div class="diff-added">+            LocalShardClocks::default(),</div><div class="diff-added">+            update_runtime,</div><div class="diff-added">+            search_runtime,</div><div class="diff-added">+        )</div><div class="diff-added">+        .await;</div><div class="diff-added">+</div><div class="diff-added">+        Ok(collection)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn stop_flush_worker(&self) {</div><div class="diff-added">+        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-added">+        update_handler.stop_flush_worker()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-added">+        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-added">+        update_handler.wait_workers_stops().await</div><div>     }</div><div> </div><div>     /// Recovers shard from disk.</div><div class="diff-info">@@ -309,18 +462,12 @@ impl LocalShard {</div><div> </div><div>         let mut load_handlers = vec![];</div><div> </div><div class="diff-removed">-        // This semaphore is used to limit the number of threads that load segments concurrently.</div><div class="diff-removed">-        // Uncomment it if you need to debug segment loading.</div><div class="diff-removed">-        // let semaphore = Arc::new(parking_lot::Mutex::new(()));</div><div class="diff-removed">-</div><div>         for segment_path in segment_paths {</div><div>             let payload_index_schema = payload_index_schema.clone();</div><div class="diff-removed">-            // let semaphore_clone = semaphore.clone();</div><div>             load_handlers.push(</div><div>                 thread::Builder::new()</div><div>                     .name(format!("shard-load-{collection_id}-{id}"))</div><div>                     .spawn(move || {</div><div class="diff-removed">-                        // let _guard = semaphore_clone.lock();</div><div>                         let mut res = load_segment(&segment_path, &AtomicBool::new(false))?;</div><div>                         if let Some(segment) = &mut res {</div><div>                             segment.check_consistency_and_repair()?;</div><div class="diff-info">@@ -398,9 +545,7 @@ impl LocalShard {</div><div>                 false,</div><div>                 "Shard has no appendable segments, this should never happen",</div><div>             );</div><div class="diff-removed">-            log::warn!(</div><div class="diff-removed">-                "Shard has no appendable segments, this should never happen. Creating new appendable segment now",</div><div class="diff-removed">-            );</div><div class="diff-added">+            log::warn!("Shard has no appendable segments, this should never happen. Creating new appendable segment now");</div><div>             let segments_path = LocalShard::segments_path(shard_path);</div><div>             let collection_params = collection_config.read().await.params.clone();</div><div>             let payload_index_schema = payload_index_schema.read();</div><div class="diff-info">@@ -429,6 +574,10 @@ impl LocalShard {</div><div>         // Apply outstanding operations from WAL</div><div>         local_shard.load_from_wal(collection_id).await?;</div><div> </div><div class="diff-added">+        // The storage is expected to be consistent after WAL recovery</div><div class="diff-added">+        #[cfg(feature = "data-consistency-check")]</div><div class="diff-added">+        self.check_data_consistency()?;</div><div class="diff-added">+</div><div>         Ok(local_shard)</div><div>     }</div><div> </div><div class="diff-info">@@ -444,150 +593,6 @@ impl LocalShard {</div><div>         shard_path.join(SEGMENTS_PATH)</div><div>     }</div><div> </div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build_local(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        // initialize local shard config file</div><div class="diff-removed">-        let local_shard_config = ShardConfig::new_replica_set();</div><div class="diff-removed">-        let shard = Self::build(</div><div class="diff-removed">-            id,</div><div class="diff-removed">-            collection_id,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            effective_optimizers_config,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await?;</div><div class="diff-removed">-        local_shard_config.save(shard_path)?;</div><div class="diff-removed">-        Ok(shard)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Creates new empty shard with given configuration, initializing all storages, optimizers and directories.</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn build(</div><div class="diff-removed">-        id: ShardId,</div><div class="diff-removed">-        collection_id: CollectionId,</div><div class="diff-removed">-        shard_path: &Path,</div><div class="diff-removed">-        collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-        shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-removed">-        payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div class="diff-removed">-        update_runtime: Handle,</div><div class="diff-removed">-        search_runtime: Handle,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-        effective_optimizers_config: OptimizersConfig,</div><div class="diff-removed">-    ) -> CollectionResult<LocalShard> {</div><div class="diff-removed">-        let config = collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal_path = Self::wal_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&wal_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard wal directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let segments_path = Self::segments_path(shard_path);</div><div class="diff-removed">-</div><div class="diff-removed">-        create_dir_all(&segments_path).await.map_err(|err| {</div><div class="diff-removed">-            CollectionError::service_error(format!(</div><div class="diff-removed">-                "Can't create shard segments directory. Error: {err}"</div><div class="diff-removed">-            ))</div><div class="diff-removed">-        })?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut segment_holder = SegmentHolder::default();</div><div class="diff-removed">-        let mut build_handlers = vec![];</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_params = config.params.to_base_vector_data()?;</div><div class="diff-removed">-        let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div class="diff-removed">-        let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-removed">-</div><div class="diff-removed">-        for _sid in 0..segment_number {</div><div class="diff-removed">-            let path_clone = segments_path.clone();</div><div class="diff-removed">-            let segment_config = SegmentConfig {</div><div class="diff-removed">-                vector_data: vector_params.clone(),</div><div class="diff-removed">-                sparse_vector_data: sparse_vector_params.clone(),</div><div class="diff-removed">-                payload_storage_type: config.params.payload_storage_type(),</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let segment = thread::Builder::new()</div><div class="diff-removed">-                .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-removed">-                .unwrap();</div><div class="diff-removed">-            build_handlers.push(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let join_results = build_handlers</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .map(|handler| handler.join())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for join_result in join_results {</div><div class="diff-removed">-            let segment = join_result.map_err(|err| {</div><div class="diff-removed">-                let message = panic::downcast_str(&err).unwrap_or("");</div><div class="diff-removed">-                let separator = if !message.is_empty() { "with:\n" } else { "" };</div><div class="diff-removed">-</div><div class="diff-removed">-                CollectionError::service_error(format!(</div><div class="diff-removed">-                    "Segment DB create panicked{separator}{message}",</div><div class="diff-removed">-                ))</div><div class="diff-removed">-            })??;</div><div class="diff-removed">-</div><div class="diff-removed">-            segment_holder.add_new(segment);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        let wal: SerdeWal<OperationWithClockTag> =</div><div class="diff-removed">-            SerdeWal::new(wal_path.to_str().unwrap(), (&config.wal_config).into())?;</div><div class="diff-removed">-</div><div class="diff-removed">-        let optimizers = build_optimizers(</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &effective_optimizers_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-</div><div class="diff-removed">-        drop(config); // release `shared_config` from borrow checker</div><div class="diff-removed">-</div><div class="diff-removed">-        let collection = LocalShard::new(</div><div class="diff-removed">-            segment_holder,</div><div class="diff-removed">-            collection_config,</div><div class="diff-removed">-            shared_storage_config,</div><div class="diff-removed">-            payload_index_schema,</div><div class="diff-removed">-            wal,</div><div class="diff-removed">-            optimizers,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            shard_path,</div><div class="diff-removed">-            LocalShardClocks::default(),</div><div class="diff-removed">-            update_runtime,</div><div class="diff-removed">-            search_runtime,</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(collection)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn stop_flush_worker(&self) {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.stop_flush_worker()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn wait_update_workers_stop(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-        update_handler.wait_workers_stops().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     /// Loads latest collection operations from WAL</div><div>     pub async fn load_from_wal(&self, collection_id: CollectionId) -> CollectionResult<()> {</div><div>         let mut newest_clocks = self.wal.newest_clocks.lock().await;</div><div class="diff-info">@@ -619,19 +624,6 @@ impl LocalShard {</div><div>             );</div><div>         }</div><div> </div><div class="diff-removed">-        // When `Segment`s are flushed, WAL is truncated up to the index of the last operation</div><div class="diff-removed">-        // that has been applied and flushed.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal` wrapper persists/keeps track of this index (in addition to any handling</div><div class="diff-removed">-        // in the `wal` crate itself).</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `SerdeWal::read_all` starts reading WAL from the first "un-truncated" index,</div><div class="diff-removed">-        // so no additional handling required to "skip" any potentially applied entries.</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // Note, that it's not guaranteed that some operation won't be re-applied to the storage.</div><div class="diff-removed">-        // (`SerdeWal::read_all` may even start reading WAL from some already truncated</div><div class="diff-removed">-        // index *occasionally*), but the storage can handle it.</div><div class="diff-removed">-</div><div>         for (op_num, update) in wal.read_all(false) {</div><div>             if let Some(clock_tag) = update.clock_tag {</div><div>                 newest_clocks.advance_clock(clock_tag);</div><div class="diff-info">@@ -708,44 +700,12 @@ impl LocalShard {</div><div>         bar.finish();</div><div>         if !show_progress_bar {</div><div>             log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-added">+                "Recovered shard {}: {0}/{0} (100%)",</div><div class="diff-added">+                self.path.display(),</div><div>                 wal.len(false),</div><div>             );</div><div>         }</div><div> </div><div class="diff-removed">-        // The storage is expected to be consistent after WAL recovery</div><div class="diff-removed">-        #[cfg(feature = "data-consistency-check")]</div><div class="diff-removed">-        self.check_data_consistency()?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Check data consistency for all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns an error at the first inconsistent segment</div><div class="diff-removed">-    pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        log::info!("Checking data consistency for shard {:?}", self.path);</div><div class="diff-removed">-        let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-removed">-            match segment {</div><div class="diff-removed">-                LockedSegment::Original(raw_segment) => {</div><div class="diff-removed">-                    let segment_guard = raw_segment.read();</div><div class="diff-removed">-                    if let Err(err) = segment_guard.check_data_consistency() {</div><div class="diff-removed">-                        log::error!(</div><div class="diff-removed">-                            "Segment {:?} is inconsistent: {}",</div><div class="diff-removed">-                            segment_guard.current_path,</div><div class="diff-removed">-                            err</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                        return Err(err.into());</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }</div><div class="diff-removed">-                LockedSegment::Proxy(_) => {</div><div class="diff-removed">-                    return Err(CollectionError::service_error(</div><div class="diff-removed">-                        "Proxy segment found in check_data_consistency",</div><div class="diff-removed">-                    ));</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -868,7 +828,6 @@ impl LocalShard {</div><div>             rx.await?;</div><div>         }</div><div> </div><div class="diff-removed">-        let segments_path = Self::segments_path(&self.path);</div><div>         let collection_params = self.collection_config.read().await.params.clone();</div><div>         let temp_path = temp_path.to_owned();</div><div>         let payload_index_schema = self.payload_index_schema.clone();</div><div class="diff-info">@@ -878,7 +837,7 @@ impl LocalShard {</div><div>             // Do not change segments while snapshotting</div><div>             SegmentHolder::snapshot_all_segments(</div><div>                 segments.clone(),</div><div class="diff-removed">-                &segments_path,</div><div class="diff-added">+                &temp_path,</div><div>                 Some(&collection_params),</div><div>                 &payload_index_schema.read().clone(),</div><div>                 &temp_path,</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    