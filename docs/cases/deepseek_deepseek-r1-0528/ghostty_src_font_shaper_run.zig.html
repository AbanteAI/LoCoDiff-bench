<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/font/shaper/run.zig - DeepSeek R1 0528</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/font/shaper/run.zig</h1>
        <h2>Model: DeepSeek R1 0528</h2>
        <p><a href="../../models/deepseek_deepseek-r1-0528.html">All DeepSeek R1 0528 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1 0528</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 18593</p>
                <p><strong>Native Prompt Tokens:</strong> 19904</p>
                <p><strong>Native Completion Tokens:</strong> 12972</p>
                <p><strong>Native Tokens Reasoning:</strong> 12668</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.03823096</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_font_shaper_run.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_font_shaper_run.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_font_shaper_run.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index e41616d2b..1f6be1fb1 100644</div><div class="diff-header">--- a/ghostty_src_font_shaper_run.zig_expectedoutput.txt (expected):tmp/tmp7r8xif75_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_font_shaper_run.zig_extracted.txt (actual):tmp/tmpr8sofq89_actual.txt	</div><div class="diff-info">@@ -1,191 +1,84 @@</div><div> const std = @import("std");</div><div> const assert = std.debug.assert;</div><div> const Allocator = std.mem.Allocator;</div><div class="diff-added">+const ziglyph = @import("ziglyph");</div><div> const font = @import("../main.zig");</div><div> const shape = @import("../shape.zig");</div><div> const terminal = @import("../../terminal/main.zig");</div><div class="diff-removed">-const autoHash = std.hash.autoHash;</div><div class="diff-removed">-const Hasher = std.hash.Wyhash;</div><div class="diff-added">+const trace = @import("tracy").trace;</div><div> </div><div> /// A single text run. A text run is only valid for one Shaper instance and</div><div> /// until the next run is created. A text run never goes across multiple</div><div> /// rows in a terminal, so it is guaranteed to always be one line.</div><div> pub const TextRun = struct {</div><div class="diff-removed">-    /// A unique hash for this run. This can be used to cache the shaping</div><div class="diff-removed">-    /// results. We don't provide a means to compare actual values if the</div><div class="diff-removed">-    /// hash is the same, so we should continue to improve this hash to</div><div class="diff-removed">-    /// lower the chance of hash collisions if they become a problem. If</div><div class="diff-removed">-    /// there are hash collisions, it would result in rendering issues but</div><div class="diff-removed">-    /// the core data would be correct.</div><div class="diff-removed">-    hash: u64,</div><div class="diff-removed">-</div><div>     /// The offset in the row where this run started</div><div>     offset: u16,</div><div> </div><div>     /// The total number of cells produced by this run.</div><div>     cells: u16,</div><div> </div><div class="diff-removed">-    /// The font grid that built this run.</div><div class="diff-removed">-    grid: *font.SharedGrid,</div><div class="diff-added">+    /// The font group that built this run.</div><div class="diff-added">+    group: *font.GroupCache,</div><div> </div><div>     /// The font index to use for the glyphs of this run.</div><div class="diff-removed">-    font_index: font.Collection.Index,</div><div class="diff-added">+    font_index: font.Group.FontIndex,</div><div> };</div><div> </div><div> /// RunIterator is an iterator that yields text runs.</div><div> pub const RunIterator = struct {</div><div>     hooks: font.Shaper.RunIteratorHook,</div><div class="diff-removed">-    grid: *font.SharedGrid,</div><div class="diff-removed">-    screen: *const terminal.Screen,</div><div class="diff-removed">-    row: terminal.Pin,</div><div class="diff-added">+    group: *font.GroupCache,</div><div class="diff-added">+    row: terminal.Screen.Row,</div><div>     selection: ?terminal.Selection = null,</div><div>     cursor_x: ?usize = null,</div><div>     i: usize = 0,</div><div> </div><div>     pub fn next(self: *RunIterator, alloc: Allocator) !?TextRun {</div><div class="diff-removed">-        const cells = self.row.cells(.all);</div><div class="diff-added">+        const tracy = trace(@src());</div><div class="diff-added">+        defer tracy.end();</div><div> </div><div>         // Trim the right side of a row that might be empty</div><div>         const max: usize = max: {</div><div class="diff-removed">-            for (0..cells.len) |i| {</div><div class="diff-removed">-                const rev_i = cells.len - i - 1;</div><div class="diff-removed">-                if (!cells[rev_i].isEmpty()) break :max rev_i + 1;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            break :max 0;</div><div class="diff-added">+            var j: usize = self.row.lenCells();</div><div class="diff-added">+            while (j > 0) : (j -= 1) if (!self.row.getCell(j - 1).empty()) break;</div><div class="diff-added">+            break :max j;</div><div>         };</div><div> </div><div class="diff-removed">-        // Invisible cells don't have any glyphs rendered,</div><div class="diff-removed">-        // so we explicitly skip them in the shaping process.</div><div class="diff-removed">-        while (self.i < max and</div><div class="diff-removed">-            self.row.style(&cells[self.i]).flags.invisible)</div><div class="diff-removed">-        {</div><div class="diff-removed">-            self.i += 1;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div>         // We're over at the max</div><div>         if (self.i >= max) return null;</div><div> </div><div>         // Track the font for our current run</div><div class="diff-removed">-        var current_font: font.Collection.Index = .{};</div><div class="diff-added">+        var current_font: font.Group.FontIndex = .{};</div><div> </div><div>         // Allow the hook to prepare</div><div>         try self.hooks.prepare();</div><div> </div><div class="diff-removed">-        // Initialize our hash for this run.</div><div class="diff-removed">-        var hasher = Hasher.init(0);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Let's get our style that we'll expect for the run.</div><div class="diff-removed">-        const style = self.row.style(&cells[self.i]);</div><div class="diff-removed">-</div><div>         // Go through cell by cell and accumulate while we build our run.</div><div>         var j: usize = self.i;</div><div>         while (j < max) : (j += 1) {</div><div>             const cluster = j;</div><div class="diff-removed">-            const cell = &cells[j];</div><div class="diff-added">+            const cell = self.row.getCell(j);</div><div> </div><div>             // If we have a selection and we're at a boundary point, then</div><div>             // we break the run here.</div><div>             if (self.selection) |unordered_sel| {</div><div>                 if (j > self.i) {</div><div class="diff-removed">-                    const sel = unordered_sel.ordered(self.screen, .forward);</div><div class="diff-removed">-                    const start_x = sel.start().x;</div><div class="diff-removed">-                    const end_x = sel.end().x;</div><div class="diff-removed">-</div><div class="diff-removed">-                    if (start_x > 0 and</div><div class="diff-removed">-                        j == start_x) break;</div><div class="diff-removed">-</div><div class="diff-removed">-                    if (end_x > 0 and</div><div class="diff-removed">-                        j == end_x + 1) break;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-added">+                    const sel = unordered_sel.ordered(.forward);</div><div> </div><div class="diff-removed">-            // If we're a spacer, then we ignore it</div><div class="diff-removed">-            switch (cell.wide) {</div><div class="diff-removed">-                .narrow, .wide => {},</div><div class="diff-removed">-                .spacer_head, .spacer_tail => continue,</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // If our cell attributes are changing, then we split the run.</div><div class="diff-removed">-            // This prevents a single glyph for ">=" to be rendered with</div><div class="diff-removed">-            // one color when the two components have different styling.</div><div class="diff-removed">-            if (j > self.i) style: {</div><div class="diff-removed">-                const prev_cell = cells[j - 1];</div><div class="diff-added">+                    if (sel.start.x > 0 and</div><div class="diff-added">+                        j == sel.start.x and</div><div class="diff-added">+                        self.row.graphemeBreak(sel.start.x)) break;</div><div> </div><div class="diff-removed">-                // If the prev cell and this cell are both plain</div><div class="diff-removed">-                // codepoints then we check if they are commonly "bad"</div><div class="diff-removed">-                // ligatures and spit the run if they are.</div><div class="diff-removed">-                if (prev_cell.content_tag == .codepoint and</div><div class="diff-removed">-                    cell.content_tag == .codepoint)</div><div class="diff-removed">-                {</div><div class="diff-removed">-                    const prev_cp = prev_cell.codepoint();</div><div class="diff-removed">-                    switch (prev_cp) {</div><div class="diff-removed">-                        // fl, fi</div><div class="diff-removed">-                        'f' => {</div><div class="diff-removed">-                            const cp = cell.codepoint();</div><div class="diff-removed">-                            if (cp == 'l' or cp == 'i') break;</div><div class="diff-removed">-                        },</div><div class="diff-removed">-</div><div class="diff-removed">-                        // st</div><div class="diff-removed">-                        's' => {</div><div class="diff-removed">-                            const cp = cell.codepoint();</div><div class="diff-removed">-                            if (cp == 't') break;</div><div class="diff-removed">-                        },</div><div class="diff-removed">-</div><div class="diff-removed">-                        else => {},</div><div class="diff-removed">-                    }</div><div class="diff-added">+                    if (sel.end.x > 0 and</div><div class="diff-added">+                        j == sel.end.x + 1 and</div><div class="diff-added">+                        self.row.graphemeBreak(sel.end.x)) break;</div><div>                 }</div><div class="diff-removed">-</div><div class="diff-removed">-                // If the style is exactly the change then fast path out.</div><div class="diff-removed">-                if (prev_cell.style_id == cell.style_id) break :style;</div><div class="diff-removed">-</div><div class="diff-removed">-                // The style is different. We allow differing background</div><div class="diff-removed">-                // styles but any other change results in a new run.</div><div class="diff-removed">-                const c1 = comparableStyle(style);</div><div class="diff-removed">-                const c2 = comparableStyle(self.row.style(&cells[j]));</div><div class="diff-removed">-                if (!c1.eql(c2)) break;</div><div>             }</div><div> </div><div class="diff-removed">-            // Text runs break when font styles change so we need to get</div><div class="diff-removed">-            // the proper style.</div><div class="diff-removed">-            const font_style: font.Style = style: {</div><div class="diff-removed">-                if (style.flags.bold) {</div><div class="diff-removed">-                    if (style.flags.italic) break :style .bold_italic;</div><div class="diff-removed">-                    break :style .bold;</div><div class="diff-removed">-                }</div><div class="diff-removed">-</div><div class="diff-removed">-                if (style.flags.italic) break :style .italic;</div><div class="diff-removed">-                break :style .regular;</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            // Determine the presentation format for this glyph.</div><div class="diff-removed">-            const presentation: ?font.Presentation = if (cell.hasGrapheme()) p: {</div><div class="diff-removed">-                // We only check the FIRST codepoint because I believe the</div><div class="diff-removed">-                // presentation format must be directly adjacent to the codepoint.</div><div class="diff-removed">-                const cps = self.row.grapheme(cell) orelse break :p null;</div><div class="diff-removed">-                assert(cps.len > 0);</div><div class="diff-removed">-                if (cps[0] == 0xFE0E) break :p .text;</div><div class="diff-removed">-                if (cps[0] == 0xFE0F) break :p .emoji;</div><div class="diff-removed">-                break :p null;</div><div class="diff-removed">-            } else emoji: {</div><div class="diff-removed">-                // If we're not a grapheme, our individual char could be</div><div class="diff-removed">-                // an emoji so we want to check if we expect emoji presentation.</div><div class="diff-removed">-                // The font grid indexForCodepoint we use below will do this</div><div class="diff-removed">-                // automatically.</div><div class="diff-removed">-                break :emoji null;</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div>             // If our cursor is on this line then we break the run around the</div><div>             // cursor. This means that any row with a cursor has at least</div><div>             // three breaks: before, exactly the cursor, and after.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // We do not break a cell that is exactly the grapheme. If there</div><div class="diff-removed">-            // are cells following that contain joiners, we allow those to</div><div class="diff-removed">-            // break. This creates an effect where hovering over an emoji</div><div class="diff-removed">-            // such as a skin-tone emoji is fine, but hovering over the</div><div class="diff-removed">-            // joiners will show the joiners allowing you to modify the</div><div class="diff-removed">-            // emoji.</div><div class="diff-removed">-            if (!cell.hasGrapheme()) {</div><div class="diff-added">+            if (!cell.attrs.grapheme) {</div><div>                 if (self.cursor_x) |cursor_x| {</div><div>                     // Exactly: self.i is the cursor and we iterated once. This</div><div>                     // means that we started exactly at the cursor and did at</div><div class="diff-info">@@ -208,76 +101,74 @@ pub const RunIterator = struct {</div><div>                 }</div><div>             }</div><div> </div><div class="diff-removed">-            // We need to find a font that supports this character. If</div><div class="diff-removed">-            // there are additional zero-width codepoints (to form a single</div><div class="diff-removed">-            // grapheme, i.e. combining characters), we need to find a font</div><div class="diff-removed">-            // that supports all of them.</div><div class="diff-removed">-            const font_info: struct {</div><div class="diff-removed">-                idx: font.Collection.Index,</div><div class="diff-removed">-                fallback: ?u32 = null,</div><div class="diff-removed">-            } = font_info: {</div><div class="diff-removed">-                // If we find a font that supports this entire grapheme</div><div class="diff-removed">-                // then we use that.</div><div class="diff-removed">-                if (try self.indexForCell(</div><div class="diff-removed">-                    alloc,</div><div class="diff-removed">-                    cell,</div><div class="diff-removed">-                    font_style,</div><div class="diff-removed">-                    presentation,</div><div class="diff-removed">-                )) |idx| break :font_info .{ .idx = idx };</div><div class="diff-added">+            // If we're a spacer, then we ignore it</div><div class="diff-added">+            if (cell.attrs.wide_spacer_tail) continue;</div><div class="diff-added">+</div><div class="diff-added">+            // Text runs break when font styles change so we need to get</div><div class="diff-added">+            // the proper style.</div><div class="diff-added">+            const style: font.Style = style: {</div><div class="diff-added">+                if (cell.attrs.bold) {</div><div class="diff-added">+                    if (cell.attrs.italic) break :style .bold_italic;</div><div class="diff-added">+                    break :style .bold;</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+                if (cell.attrs.italic) break :style .italic;</div><div class="diff-added">+                break :style .regular;</div><div class="diff-added">+            };</div><div> </div><div class="diff-removed">-                // Otherwise we need a fallback character. Prefer the</div><div class="diff-removed">-                // official replacement character.</div><div class="diff-removed">-                if (try self.grid.getIndex(</div><div class="diff-removed">-                    alloc,</div><div class="diff-removed">-                    0xFFFD, // replacement char</div><div class="diff-removed">-                    font_style,</div><div class="diff-removed">-                    presentation,</div><div class="diff-removed">-                )) |idx| break :font_info .{ .idx = idx, .fallback = 0xFFFD };</div><div class="diff-added">+            // Determine the presentation format for this glyph.</div><div class="diff-added">+            const presentation: ?font.Presentation = if (cell.attrs.grapheme) p: {</div><div class="diff-added">+                // We only check the FIRST codepoint because I believe the</div><div class="diff-added">+                // presentation format must be directly adjacent to the codepoint.</div><div class="diff-added">+                var it = self.row.codepointIterator(j);</div><div class="diff-added">+                if (it.next()) |cp| {</div><div class="diff-added">+                    if (cp == 0xFE0E) break :p .text;</div><div class="diff-added">+                    if (cp == 0xFE0F) break :p .emoji;</div><div class="diff-added">+                }</div><div> </div><div class="diff-removed">-                // Fallback to space</div><div class="diff-removed">-                if (try self.grid.getIndex(</div><div class="diff-removed">-                    alloc,</div><div class="diff-removed">-                    ' ',</div><div class="diff-removed">-                    font_style,</div><div class="diff-removed">-                    presentation,</div><div class="diff-removed">-                )) |idx| break :font_info .{ .idx = idx, .fallback = ' ' };</div><div class="diff-added">+                break :p null;</div><div class="diff-added">+            } else emoji: {</div><div class="diff-added">+                // If we're not a grapheme, our individual char could be</div><div class="diff-added">+                // an emoji so we want to check if we expect emoji presentation.</div><div class="diff-added">+                if (ziglyph.emoji.isEmojiPresentation(@intCast(cell.char))) {</div><div class="diff-added">+                    break :emoji .emoji;</div><div class="diff-added">+                }</div><div> </div><div class="diff-removed">-                // We can't render at all. This is a bug, we should always</div><div class="diff-removed">-                // have a font that can render a space.</div><div class="diff-removed">-                unreachable;</div><div class="diff-added">+                break :emoji .text;</div><div>             };</div><div> </div><div class="diff-removed">-            //log.warn("char={x} info={}", .{ cell.char, font_info });</div><div class="diff-removed">-            if (j == self.i) current_font = font_info.idx;</div><div class="diff-added">+            // Determine the font for this cell. We'll use fallbacks</div><div class="diff-added">+            // manually here to try replacement chars and then a space</div><div class="diff-added">+            // for unknown glyphs.</div><div class="diff-added">+            const font_idx_opt = (try self.group.indexForCodepoint(</div><div class="diff-added">+                alloc,</div><div class="diff-added">+                if (cell.empty() or cell.char == 0) ' ' else cell.char,</div><div class="diff-added">+                style,</div><div class="diff-added">+                presentation,</div><div class="diff-added">+            )) orelse (try self.group.indexForCodepoint(</div><div class="diff-added">+                alloc,</div><div class="diff-added">+                0xFFFD,</div><div class="diff-added">+                style,</div><div class="diff-added">+                .text,</div><div class="diff-added">+            )) orelse</div><div class="diff-added">+                try self.group.indexForCodepoint(alloc, ' ', style, .text);</div><div class="diff-added">+            const font_idx = font_idx_opt.?;</div><div class="diff-added">+            //log.warn("char={x} idx={}", .{ cell.char, font_idx });</div><div class="diff-added">+            if (j == self.i) current_font = font_idx;</div><div> </div><div>             // If our fonts are not equal, then we're done with our run.</div><div class="diff-removed">-            if (font_info.idx.int() != current_font.int()) break;</div><div class="diff-added">+            if (font_idx.int() != current_font.int()) break;</div><div> </div><div class="diff-removed">-            // If we're a fallback character, add that and continue; we</div><div class="diff-removed">-            // don't want to add the entire grapheme.</div><div class="diff-removed">-            if (font_info.fallback) |cp| {</div><div class="diff-removed">-                try self.addCodepoint(&hasher, cp, @intCast(cluster));</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-added">+            // Continue with our run</div><div class="diff-added">+            try self.hooks.addCodepoint(cell.char, @intCast(cluster));</div><div> </div><div class="diff-removed">-            // If we're a Kitty unicode placeholder then we add a blank.</div><div class="diff-removed">-            if (cell.codepoint() == terminal.kitty.graphics.unicode.placeholder) {</div><div class="diff-removed">-                try self.addCodepoint(&hasher, ' ', @intCast(cluster));</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Add all the codepoints for our grapheme</div><div class="diff-removed">-            try self.addCodepoint(</div><div class="diff-removed">-                &hasher,</div><div class="diff-removed">-                if (cell.codepoint() == 0) ' ' else cell.codepoint(),</div><div class="diff-removed">-                @intCast(cluster),</div><div class="diff-removed">-            );</div><div class="diff-removed">-            if (cell.hasGrapheme()) {</div><div class="diff-removed">-                const cps = self.row.grapheme(cell).?;</div><div class="diff-removed">-                for (cps) |cp| {</div><div class="diff-removed">-                    // Do not send presentation modifiers</div><div class="diff-added">+            // If this cell is part of a grapheme cluster, add all the grapheme</div><div class="diff-added">+            // data points.</div><div class="diff-added">+            if (cell.attrs.grapheme) {</div><div class="diff-added">+                var it = self.row.codepointIterator(j);</div><div class="diff-added">+                while (it.next()) |cp| {</div><div>                     if (cp == 0xFE0E or cp == 0xFE0F) continue;</div><div class="diff-removed">-                    try self.addCodepoint(&hasher, cp, @intCast(cluster));</div><div class="diff-added">+                    try self.hooks.addCodepoint(cp, @intCast(cluster));</div><div>                 }</div><div>             }</div><div>         }</div><div class="diff-info">@@ -285,122 +176,14 @@ pub const RunIterator = struct {</div><div>         // Finalize our buffer</div><div>         try self.hooks.finalize();</div><div> </div><div class="diff-removed">-        // Add our length to the hash as an additional mechanism to avoid collisions</div><div class="diff-removed">-        autoHash(&hasher, j - self.i);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Add our font index</div><div class="diff-removed">-        autoHash(&hasher, current_font);</div><div class="diff-removed">-</div><div>         // Move our cursor. Must defer since we use self.i below.</div><div>         defer self.i = j;</div><div> </div><div>         return TextRun{</div><div class="diff-removed">-            .hash = hasher.final(),</div><div>             .offset = @intCast(self.i),</div><div>             .cells = @intCast(j - self.i),</div><div class="diff-removed">-            .grid = self.grid,</div><div class="diff-added">+            .group = self.group,</div><div>             .font_index = current_font,</div><div>         };</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn addCodepoint(self: *RunIterator, hasher: anytype, cp: u32, cluster: u32) !void {</div><div class="diff-removed">-        autoHash(hasher, cp);</div><div class="diff-removed">-        autoHash(hasher, cluster);</div><div class="diff-removed">-        try self.hooks.addCodepoint(cp, cluster);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Find a font index that supports the grapheme for the given cell,</div><div class="diff-removed">-    /// or null if no such font exists.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is used to find a font that supports the entire grapheme.</div><div class="diff-removed">-    /// We look for fonts that support each individual codepoint and then</div><div class="diff-removed">-    /// find the common font amongst all candidates.</div><div class="diff-removed">-    fn indexForCell(</div><div class="diff-removed">-        self: *RunIterator,</div><div class="diff-removed">-        alloc: Allocator,</div><div class="diff-removed">-        cell: *terminal.Cell,</div><div class="diff-removed">-        style: font.Style,</div><div class="diff-removed">-        presentation: ?font.Presentation,</div><div class="diff-removed">-    ) !?font.Collection.Index {</div><div class="diff-removed">-        if (cell.isEmpty() or</div><div class="diff-removed">-            cell.codepoint() == 0 or</div><div class="diff-removed">-            cell.codepoint() == terminal.kitty.graphics.unicode.placeholder)</div><div class="diff-removed">-        {</div><div class="diff-removed">-            return try self.grid.getIndex(</div><div class="diff-removed">-                alloc,</div><div class="diff-removed">-                ' ',</div><div class="diff-removed">-                style,</div><div class="diff-removed">-                presentation,</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Get the font index for the primary codepoint.</div><div class="diff-removed">-        const primary_cp: u32 = cell.codepoint();</div><div class="diff-removed">-        const primary = try self.grid.getIndex(</div><div class="diff-removed">-            alloc,</div><div class="diff-removed">-            primary_cp,</div><div class="diff-removed">-            style,</div><div class="diff-removed">-            presentation,</div><div class="diff-removed">-        ) orelse return null;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Easy, and common: we aren't a multi-codepoint grapheme, so</div><div class="diff-removed">-        // we just return whatever index for the cell codepoint.</div><div class="diff-removed">-        if (!cell.hasGrapheme()) return primary;</div><div class="diff-removed">-</div><div class="diff-removed">-        // If this is a grapheme, we need to find a font that supports</div><div class="diff-removed">-        // all of the codepoints in the grapheme.</div><div class="diff-removed">-        const cps = self.row.grapheme(cell) orelse return primary;</div><div class="diff-removed">-        var candidates = try std.ArrayList(font.Collection.Index).initCapacity(alloc, cps.len + 1);</div><div class="diff-removed">-        defer candidates.deinit();</div><div class="diff-removed">-        candidates.appendAssumeCapacity(primary);</div><div class="diff-removed">-</div><div class="diff-removed">-        for (cps) |cp| {</div><div class="diff-removed">-            // Ignore Emoji ZWJs</div><div class="diff-removed">-            if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;</div><div class="diff-removed">-</div><div class="diff-removed">-            // Find a font that supports this codepoint. If none support this</div><div class="diff-removed">-            // then the whole grapheme can't be rendered so we return null.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // We explicitly do not require the additional grapheme components</div><div class="diff-removed">-            // to support the base presentation, since it is common for emoji</div><div class="diff-removed">-            // fonts to support the base emoji with emoji presentation but not</div><div class="diff-removed">-            // certain ZWJ-combined characters like the male and female signs.</div><div class="diff-removed">-            const idx = try self.grid.getIndex(</div><div class="diff-removed">-                alloc,</div><div class="diff-removed">-                cp,</div><div class="diff-removed">-                style,</div><div class="diff-removed">-                null,</div><div class="diff-removed">-            ) orelse return null;</div><div class="diff-removed">-            candidates.appendAssumeCapacity(idx);</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // We need to find a candidate that has ALL of our codepoints</div><div class="diff-removed">-        for (candidates.items) |idx| {</div><div class="diff-removed">-            if (!self.grid.hasCodepoint(idx, primary_cp, presentation)) continue;</div><div class="diff-removed">-            for (cps) |cp| {</div><div class="diff-removed">-                // Ignore Emoji ZWJs</div><div class="diff-removed">-                if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;</div><div class="diff-removed">-                if (!self.grid.hasCodepoint(idx, cp, null)) break;</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                // If the while completed, then we have a candidate that</div><div class="diff-removed">-                // supports all of our codepoints.</div><div class="diff-removed">-                return idx;</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        return null;</div><div class="diff-removed">-    }</div><div class="diff-removed">-};</div><div class="diff-removed">-</div><div class="diff-removed">-/// Returns a style that when compared must be identical for a run to</div><div class="diff-removed">-/// continue.</div><div class="diff-removed">-fn comparableStyle(style: terminal.Style) terminal.Style {</div><div class="diff-removed">-    var s = style;</div><div class="diff-removed">-</div><div class="diff-removed">-    // We allow background colors to differ because we'll just paint the</div><div class="diff-removed">-    // cell background whatever the style is, and wherever the glyph</div><div class="diff-removed">-    // lands on top of it will be the color of the glyph.</div><div class="diff-removed">-    s.bg_color = .none;</div><div class="diff-removed">-</div><div class="diff-removed">-    return s;</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+};</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    