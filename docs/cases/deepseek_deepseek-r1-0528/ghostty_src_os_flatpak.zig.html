<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/os/flatpak.zig - DeepSeek R1 0528</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/os/flatpak.zig</h1>
        <h2>Model: DeepSeek R1 0528</h2>
        <p><a href="../../models/deepseek_deepseek-r1-0528.html">All DeepSeek R1 0528 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1 0528</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 11975</p>
                <p><strong>Native Prompt Tokens:</strong> 12185</p>
                <p><strong>Native Completion Tokens:</strong> 6099</p>
                <p><strong>Native Tokens Reasoning:</strong> 6099</p>
                <p><strong>Native Finish Reason:</strong> None</p>
                <p><strong>Cost:</strong> $0.0243895</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_os_flatpak.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_os_flatpak.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/ghostty_src_os_flatpak.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index f77a8d507..e69de29bb 100644</div><div class="diff-header">--- a/ghostty_src_os_flatpak.zig_expectedoutput.txt (expected):tmp/tmp1eify09u_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_os_flatpak.zig_extracted.txt (actual):tmp/tmplbleia36_actual.txt	</div><div class="diff-info">@@ -1,503 +0,0 @@</div><div class="diff-removed">-const std = @import("std");</div><div class="diff-removed">-const assert = std.debug.assert;</div><div class="diff-removed">-const Allocator = std.mem.Allocator;</div><div class="diff-removed">-const builtin = @import("builtin");</div><div class="diff-removed">-const posix = std.posix;</div><div class="diff-removed">-const xev = @import("../global.zig").xev;</div><div class="diff-removed">-</div><div class="diff-removed">-const log = std.log.scoped(.flatpak);</div><div class="diff-removed">-</div><div class="diff-removed">-/// Returns true if we're running in a Flatpak environment.</div><div class="diff-removed">-pub fn isFlatpak() bool {</div><div class="diff-removed">-    // If we're not on Linux then we'll make this comptime false.</div><div class="diff-removed">-    if (comptime builtin.os.tag != .linux) return false;</div><div class="diff-removed">-    return if (std.fs.accessAbsolute("/.flatpak-info", .{})) true else |_| false;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// A struct to help execute commands on the host via the</div><div class="diff-removed">-/// org.freedesktop.Flatpak.Development DBus module. This uses GIO/GLib</div><div class="diff-removed">-/// under the hood.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This always spawns its own thread and maintains its own GLib event loop.</div><div class="diff-removed">-/// This makes it easy for the command to behave synchronously similar to</div><div class="diff-removed">-/// std.process.Child.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// There are lots of chances for low-hanging improvements here (automatic</div><div class="diff-removed">-/// pipes, /dev/null, etc.) but this was purpose built for my needs so</div><div class="diff-removed">-/// it doesn't have all of those.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Requires GIO, GLib to be available and linked.</div><div class="diff-removed">-pub const FlatpakHostCommand = struct {</div><div class="diff-removed">-    const fd_t = posix.fd_t;</div><div class="diff-removed">-    const EnvMap = std.process.EnvMap;</div><div class="diff-removed">-    const c = @cImport({</div><div class="diff-removed">-        @cInclude("gio/gio.h");</div><div class="diff-removed">-        @cInclude("gio/gunixfdlist.h");</div><div class="diff-removed">-    });</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Argv are the arguments to call on the host with argv[0] being</div><div class="diff-removed">-    /// the command to execute.</div><div class="diff-removed">-    argv: []const []const u8,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// The cwd for the new process. If this is not set then it will use</div><div class="diff-removed">-    /// the current cwd of the calling process.</div><div class="diff-removed">-    cwd: ?[:0]const u8 = null,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Environment variables for the child process. If this is null, this</div><div class="diff-removed">-    /// does not send any environment variables.</div><div class="diff-removed">-    env: ?*const EnvMap = null,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// File descriptors to send to the child process. It is up to the</div><div class="diff-removed">-    /// caller to create the file descriptors and set them up.</div><div class="diff-removed">-    stdin: fd_t,</div><div class="diff-removed">-    stdout: fd_t,</div><div class="diff-removed">-    stderr: fd_t,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// State of the process. This is updated by the dedicated thread it</div><div class="diff-removed">-    /// runs in and is protected by the given lock and condition variable.</div><div class="diff-removed">-    state: State = .{ .init = {} },</div><div class="diff-removed">-    state_mutex: std.Thread.Mutex = .{},</div><div class="diff-removed">-    state_cv: std.Thread.Condition = .{},</div><div class="diff-removed">-</div><div class="diff-removed">-    /// State the process is in. This can't be inspected directly, you</div><div class="diff-removed">-    /// must use getters on the struct to get access.</div><div class="diff-removed">-    const State = union(enum) {</div><div class="diff-removed">-        /// Initial state</div><div class="diff-removed">-        init: void,</div><div class="diff-removed">-</div><div class="diff-removed">-        /// Error starting. The error message is only available via logs.</div><div class="diff-removed">-        /// (This isn't a fundamental limitation, just didn't need the</div><div class="diff-removed">-        /// error message yet)</div><div class="diff-removed">-        err: void,</div><div class="diff-removed">-</div><div class="diff-removed">-        /// Process started with the given pid on the host.</div><div class="diff-removed">-        started: struct {</div><div class="diff-removed">-            pid: u32,</div><div class="diff-removed">-            loop_xev: ?*xev.Loop,</div><div class="diff-removed">-            completion: ?*Completion,</div><div class="diff-removed">-            subscription: c.guint,</div><div class="diff-removed">-            loop: *c.GMainLoop,</div><div class="diff-removed">-        },</div><div class="diff-removed">-</div><div class="diff-removed">-        /// Process exited</div><div class="diff-removed">-        exited: struct {</div><div class="diff-removed">-            pid: u32,</div><div class="diff-removed">-            status: u8,</div><div class="diff-removed">-        },</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    pub const Completion = struct {</div><div class="diff-removed">-        callback: *const fn (ud: ?*anyopaque, l: *xev.Loop, c: *Completion, r: WaitError!u8) void = noopCallback,</div><div class="diff-removed">-        c_xev: xev.Completion = .{},</div><div class="diff-removed">-        userdata: ?*anyopaque = null,</div><div class="diff-removed">-        timer: ?xev.Timer = null,</div><div class="diff-removed">-        result: ?WaitError!u8 = null,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Errors that are possible from us.</div><div class="diff-removed">-    pub const Error = error{</div><div class="diff-removed">-        FlatpakMustBeStarted,</div><div class="diff-removed">-        FlatpakSpawnFail,</div><div class="diff-removed">-        FlatpakSetupFail,</div><div class="diff-removed">-        FlatpakRPCFail,</div><div class="diff-removed">-    };</div><div class="diff-removed">-</div><div class="diff-removed">-    pub const WaitError = xev.Timer.RunError || Error;</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Spawn the command. This will start the host command. On return,</div><div class="diff-removed">-    /// the pid will be available. This must only be called with the</div><div class="diff-removed">-    /// state in "init".</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Precondition: The self pointer MUST be stable.</div><div class="diff-removed">-    pub fn spawn(self: *FlatpakHostCommand, alloc: Allocator) !u32 {</div><div class="diff-removed">-        const thread = try std.Thread.spawn(.{}, threadMain, .{ self, alloc });</div><div class="diff-removed">-        thread.setName("flatpak-host-command") catch {};</div><div class="diff-removed">-</div><div class="diff-removed">-        // Wait for the process to start or error.</div><div class="diff-removed">-        self.state_mutex.lock();</div><div class="diff-removed">-        defer self.state_mutex.unlock();</div><div class="diff-removed">-        while (self.state == .init) self.state_cv.wait(&self.state_mutex);</div><div class="diff-removed">-</div><div class="diff-removed">-        return switch (self.state) {</div><div class="diff-removed">-            .init => unreachable,</div><div class="diff-removed">-            .err => Error.FlatpakSpawnFail,</div><div class="diff-removed">-            .started => |v| v.pid,</div><div class="diff-removed">-            .exited => |v| v.pid,</div><div class="diff-removed">-        };</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for the process to end and return the exit status. This</div><div class="diff-removed">-    /// can only be called ONCE. Once this returns, the state is reset.</div><div class="diff-removed">-    pub fn wait(self: *FlatpakHostCommand) !u8 {</div><div class="diff-removed">-        self.state_mutex.lock();</div><div class="diff-removed">-        defer self.state_mutex.unlock();</div><div class="diff-removed">-</div><div class="diff-removed">-        while (true) {</div><div class="diff-removed">-            switch (self.state) {</div><div class="diff-removed">-                .init => return Error.FlatpakMustBeStarted,</div><div class="diff-removed">-                .err => return Error.FlatpakSpawnFail,</div><div class="diff-removed">-                .started => {},</div><div class="diff-removed">-                .exited => |v| {</div><div class="diff-removed">-                    self.state = .{ .init = {} };</div><div class="diff-removed">-                    self.state_cv.broadcast();</div><div class="diff-removed">-                    return v.status;</div><div class="diff-removed">-                },</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            self.state_cv.wait(&self.state_mutex);</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Wait for the process to end asynchronously via libxev. This</div><div class="diff-removed">-    /// can only be called ONCE.</div><div class="diff-removed">-    pub fn waitXev(</div><div class="diff-removed">-        self: *FlatpakHostCommand,</div><div class="diff-removed">-        loop: *xev.Loop,</div><div class="diff-removed">-        completion: *Completion,</div><div class="diff-removed">-        comptime Userdata: type,</div><div class="diff-removed">-        userdata: ?*Userdata,</div><div class="diff-removed">-        comptime cb: *const fn (</div><div class="diff-removed">-            ud: ?*Userdata,</div><div class="diff-removed">-            l: *xev.Loop,</div><div class="diff-removed">-            c: *Completion,</div><div class="diff-removed">-            r: WaitError!u8,</div><div class="diff-removed">-        ) void,</div><div class="diff-removed">-    ) void {</div><div class="diff-removed">-        self.state_mutex.lock();</div><div class="diff-removed">-        defer self.state_mutex.unlock();</div><div class="diff-removed">-</div><div class="diff-removed">-        completion.* = .{</div><div class="diff-removed">-            .callback = (struct {</div><div class="diff-removed">-                fn callback(</div><div class="diff-removed">-                    ud_: ?*anyopaque,</div><div class="diff-removed">-                    l_inner: *xev.Loop,</div><div class="diff-removed">-                    c_inner: *Completion,</div><div class="diff-removed">-                    r: WaitError!u8,</div><div class="diff-removed">-                ) void {</div><div class="diff-removed">-                    const ud = @as(?*Userdata, if (Userdata == void) null else @ptrCast(@alignCast(ud_)));</div><div class="diff-removed">-                    @call(.always_inline, cb, .{ ud, l_inner, c_inner, r });</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }).callback,</div><div class="diff-removed">-            .userdata = userdata,</div><div class="diff-removed">-            .timer = xev.Timer.init() catch unreachable, // not great, but xev timer can't fail atm</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        switch (self.state) {</div><div class="diff-removed">-            .init => completion.result = Error.FlatpakMustBeStarted,</div><div class="diff-removed">-            .err => completion.result = Error.FlatpakSpawnFail,</div><div class="diff-removed">-            .started => |*v| {</div><div class="diff-removed">-                v.loop_xev = loop;</div><div class="diff-removed">-                v.completion = completion;</div><div class="diff-removed">-                return;</div><div class="diff-removed">-            },</div><div class="diff-removed">-            .exited => |v| {</div><div class="diff-removed">-                completion.result = v.status;</div><div class="diff-removed">-            },</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        completion.timer.?.run(</div><div class="diff-removed">-            loop,</div><div class="diff-removed">-            &completion.c_xev,</div><div class="diff-removed">-            0,</div><div class="diff-removed">-            anyopaque,</div><div class="diff-removed">-            completion.userdata,</div><div class="diff-removed">-            (struct {</div><div class="diff-removed">-                fn callback(</div><div class="diff-removed">-                    ud: ?*anyopaque,</div><div class="diff-removed">-                    l_inner: *xev.Loop,</div><div class="diff-removed">-                    c_inner: *xev.Completion,</div><div class="diff-removed">-                    r: xev.Timer.RunError!void,</div><div class="diff-removed">-                ) xev.CallbackAction {</div><div class="diff-removed">-                    const c_outer: *Completion = @fieldParentPtr("c_xev", c_inner);</div><div class="diff-removed">-                    defer if (c_outer.timer) |*t| t.deinit();</div><div class="diff-removed">-</div><div class="diff-removed">-                    const result = if (r) |_| c_outer.result.? else |err| err;</div><div class="diff-removed">-                    c_outer.callback(ud, l_inner, c_outer, result);</div><div class="diff-removed">-                    return .disarm;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }).callback,</div><div class="diff-removed">-        );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Send a signal to the started command. This does nothing if the</div><div class="diff-removed">-    /// command is not in the started state.</div><div class="diff-removed">-    pub fn signal(self: *FlatpakHostCommand, sig: u8, pg: bool) !void {</div><div class="diff-removed">-        const pid = pid: {</div><div class="diff-removed">-            self.state_mutex.lock();</div><div class="diff-removed">-            defer self.state_mutex.unlock();</div><div class="diff-removed">-            switch (self.state) {</div><div class="diff-removed">-                .started => |v| break :pid v.pid,</div><div class="diff-removed">-                else => return,</div><div class="diff-removed">-            }</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Get our bus connection.</div><div class="diff-removed">-        var g_err: [*c]c.GError = null;</div><div class="diff-removed">-        const bus = c.g_bus_get_sync(c.G_BUS_TYPE_SESSION, null, &g_err) orelse {</div><div class="diff-removed">-            log.warn("signal error getting bus: {s}", .{g_err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-removed">-        };</div><div class="diff-removed">-        defer c.g_object_unref(bus);</div><div class="diff-removed">-</div><div class="diff-removed">-        const reply = c.g_dbus_connection_call_sync(</div><div class="diff-removed">-            bus,</div><div class="diff-removed">-            "org.freedesktop.Flatpak",</div><div class="diff-removed">-            "/org/freedesktop/Flatpak/Development",</div><div class="diff-removed">-            "org.freedesktop.Flatpak.Development",</div><div class="diff-removed">-            "HostCommandSignal",</div><div class="diff-removed">-            c.g_variant_new(</div><div class="diff-removed">-                "(uub)",</div><div class="diff-removed">-                pid,</div><div class="diff-removed">-                sig,</div><div class="diff-removed">-                @as(c_int, @intCast(@intFromBool(pg))),</div><div class="diff-removed">-            ),</div><div class="diff-removed">-            c.G_VARIANT_TYPE("()"),</div><div class="diff-removed">-            c.G_DBUS_CALL_FLAGS_NONE,</div><div class="diff-removed">-            c.G_MAXINT,</div><div class="diff-removed">-            null,</div><div class="diff-removed">-            &g_err,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        if (g_err != null) {</div><div class="diff-removed">-            log.warn("signal send error: {s}", .{g_err.*.message});</div><div class="diff-removed">-            return;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        defer c.g_variant_unref(reply);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn threadMain(self: *FlatpakHostCommand, alloc: Allocator) void {</div><div class="diff-removed">-        // Create a new thread-local context so that all our sources go</div><div class="diff-removed">-        // to this context and we can run our loop correctly.</div><div class="diff-removed">-        const ctx = c.g_main_context_new();</div><div class="diff-removed">-        defer c.g_main_context_unref(ctx);</div><div class="diff-removed">-        c.g_main_context_push_thread_default(ctx);</div><div class="diff-removed">-        defer c.g_main_context_pop_thread_default(ctx);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Get our loop for the current thread</div><div class="diff-removed">-        const loop = c.g_main_loop_new(ctx, 1).?;</div><div class="diff-removed">-        defer c.g_main_loop_unref(loop);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Get our bus connection. This has to remain active until we exit</div><div class="diff-removed">-        // the thread otherwise our signals won't be called.</div><div class="diff-removed">-        var g_err: [*c]c.GError = null;</div><div class="diff-removed">-        const bus = c.g_bus_get_sync(c.G_BUS_TYPE_SESSION, null, &g_err) orelse {</div><div class="diff-removed">-            log.warn("spawn error getting bus: {s}", .{g_err.*.message});</div><div class="diff-removed">-            self.updateState(.{ .err = {} });</div><div class="diff-removed">-            return;</div><div class="diff-removed">-        };</div><div class="diff-removed">-        defer c.g_object_unref(bus);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Spawn the command first. This will setup all our IO.</div><div class="diff-removed">-        self.start(alloc, bus, loop) catch |err| {</div><div class="diff-removed">-            log.warn("error starting host command: {}", .{err});</div><div class="diff-removed">-            self.updateState(.{ .err = {} });</div><div class="diff-removed">-            return;</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Run the event loop. It quits in the exit callback.</div><div class="diff-removed">-        c.g_main_loop_run(loop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Start the command. This will start the host command and set the</div><div class="diff-removed">-    /// pid field on success. This will not wait for completion.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Once this is called, the self pointer MUST remain stable. This</div><div class="diff-removed">-    /// requirement is due to using GLib under the covers with callbacks.</div><div class="diff-removed">-    fn start(</div><div class="diff-removed">-        self: *FlatpakHostCommand,</div><div class="diff-removed">-        alloc: Allocator,</div><div class="diff-removed">-        bus: *c.GDBusConnection,</div><div class="diff-removed">-        loop: *c.GMainLoop,</div><div class="diff-removed">-    ) !void {</div><div class="diff-removed">-        var err: [*c]c.GError = null;</div><div class="diff-removed">-        var arena_allocator = std.heap.ArenaAllocator.init(alloc);</div><div class="diff-removed">-        defer arena_allocator.deinit();</div><div class="diff-removed">-        const arena = arena_allocator.allocator();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Our list of file descriptors that we need to send to the process.</div><div class="diff-removed">-        const fd_list = c.g_unix_fd_list_new();</div><div class="diff-removed">-        defer c.g_object_unref(fd_list);</div><div class="diff-removed">-        if (c.g_unix_fd_list_append(fd_list, self.stdin, &err) < 0) {</div><div class="diff-removed">-            log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if (c.g_unix_fd_list_append(fd_list, self.stdout, &err) < 0) {</div><div class="diff-removed">-            log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if (c.g_unix_fd_list_append(fd_list, self.stderr, &err) < 0) {</div><div class="diff-removed">-            log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Build our arguments for the file descriptors.</div><div class="diff-removed">-        const fd_builder = c.g_variant_builder_new(c.G_VARIANT_TYPE("a{uh}"));</div><div class="diff-removed">-        defer c.g_variant_builder_unref(fd_builder);</div><div class="diff-removed">-        c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 0), self.stdin);</div><div class="diff-removed">-        c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 1), self.stdout);</div><div class="diff-removed">-        c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 2), self.stderr);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Build our env vars</div><div class="diff-removed">-        const env_builder = c.g_variant_builder_new(c.G_VARIANT_TYPE("a{ss}"));</div><div class="diff-removed">-        defer c.g_variant_builder_unref(env_builder);</div><div class="diff-removed">-        if (self.env) |env| {</div><div class="diff-removed">-            var it = env.iterator();</div><div class="diff-removed">-            while (it.next()) |pair| {</div><div class="diff-removed">-                const key = try arena.dupeZ(u8, pair.key_ptr.*);</div><div class="diff-removed">-                const value = try arena.dupeZ(u8, pair.value_ptr.*);</div><div class="diff-removed">-                c.g_variant_builder_add(env_builder, "{ss}", key.ptr, value.ptr);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        // Build our args</div><div class="diff-removed">-        const args = try arena.alloc(?[*:0]u8, self.argv.len + 1);</div><div class="diff-removed">-        for (0.., self.argv) |i, arg| {</div><div class="diff-removed">-            const argZ = try arena.dupeZ(u8, arg);</div><div class="diff-removed">-            args[i] = argZ.ptr;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        args[args.len - 1] = null;</div><div class="diff-removed">-</div><div class="diff-removed">-        // Get the cwd in case we don't have ours set. A small optimization</div><div class="diff-removed">-        // would be to do this only if we need it but this isn't a</div><div class="diff-removed">-        // common code path.</div><div class="diff-removed">-        const g_cwd = c.g_get_current_dir();</div><div class="diff-removed">-        defer c.g_free(g_cwd);</div><div class="diff-removed">-</div><div class="diff-removed">-        // The params for our RPC call</div><div class="diff-removed">-        const params = c.g_variant_new(</div><div class="diff-removed">-            "(^ay^aay@a{uh}@a{ss}u)",</div><div class="diff-removed">-            @as(*const anyopaque, if (self.cwd) |*cwd| cwd.ptr else g_cwd),</div><div class="diff-removed">-            args.ptr,</div><div class="diff-removed">-            c.g_variant_builder_end(fd_builder),</div><div class="diff-removed">-            c.g_variant_builder_end(env_builder),</div><div class="diff-removed">-            @as(c_int, 0),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        _ = c.g_variant_ref_sink(params); // take ownership</div><div class="diff-removed">-        defer c.g_variant_unref(params);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Subscribe to exit notifications</div><div class="diff-removed">-        const subscription_id = c.g_dbus_connection_signal_subscribe(</div><div class="diff-removed">-            bus,</div><div class="diff-removed">-            "org.freedesktop.Flatpak",</div><div class="diff-removed">-            "org.freedesktop.Flatpak.Development",</div><div class="diff-removed">-            "HostCommandExited",</div><div class="diff-removed">-            "/org/freedesktop/Flatpak/Development",</div><div class="diff-removed">-            null,</div><div class="diff-removed">-            0,</div><div class="diff-removed">-            onExit,</div><div class="diff-removed">-            self,</div><div class="diff-removed">-            null,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        errdefer c.g_dbus_connection_signal_unsubscribe(bus, subscription_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Go!</div><div class="diff-removed">-        const reply = c.g_dbus_connection_call_with_unix_fd_list_sync(</div><div class="diff-removed">-            bus,</div><div class="diff-removed">-            "org.freedesktop.Flatpak",</div><div class="diff-removed">-            "/org/freedesktop/Flatpak/Development",</div><div class="diff-removed">-            "org.freedesktop.Flatpak.Development",</div><div class="diff-removed">-            "HostCommand",</div><div class="diff-removed">-            params,</div><div class="diff-removed">-            c.G_VARIANT_TYPE("(u)"),</div><div class="diff-removed">-            c.G_DBUS_CALL_FLAGS_NONE,</div><div class="diff-removed">-            c.G_MAXINT,</div><div class="diff-removed">-            fd_list,</div><div class="diff-removed">-            null,</div><div class="diff-removed">-            null,</div><div class="diff-removed">-            &err,</div><div class="diff-removed">-        ) orelse {</div><div class="diff-removed">-            log.warn("Flatpak.HostCommand failed: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakRPCFail;</div><div class="diff-removed">-        };</div><div class="diff-removed">-        defer c.g_variant_unref(reply);</div><div class="diff-removed">-</div><div class="diff-removed">-        var pid: u32 = 0;</div><div class="diff-removed">-        c.g_variant_get(reply, "(u)", &pid);</div><div class="diff-removed">-        log.debug("HostCommand started pid={} subscription={}", .{</div><div class="diff-removed">-            pid,</div><div class="diff-removed">-            subscription_id,</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        self.updateState(.{</div><div class="diff-removed">-            .started = .{</div><div class="diff-removed">-                .pid = pid,</div><div class="diff-removed">-                .subscription = subscription_id,</div><div class="diff-removed">-                .loop = loop,</div><div class="diff-removed">-                .completion = null,</div><div class="diff-removed">-                .loop_xev = null,</div><div class="diff-removed">-            },</div><div class="diff-removed">-        });</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Helper to update the state and notify waiters via the cv.</div><div class="diff-removed">-    fn updateState(self: *FlatpakHostCommand, state: State) void {</div><div class="diff-removed">-        self.state_mutex.lock();</div><div class="diff-removed">-        defer self.state_mutex.unlock();</div><div class="diff-removed">-        defer self.state_cv.broadcast();</div><div class="diff-removed">-        self.state = state;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn onExit(</div><div class="diff-removed">-        bus: ?*c.GDBusConnection,</div><div class="diff-removed">-        _: [*c]const u8,</div><div class="diff-removed">-        _: [*c]const u8,</div><div class="diff-removed">-        _: [*c]const u8,</div><div class="diff-removed">-        _: [*c]const u8,</div><div class="diff-removed">-        params: ?*c.GVariant,</div><div class="diff-removed">-        ud: ?*anyopaque,</div><div class="diff-removed">-    ) callconv(.C) void {</div><div class="diff-removed">-        const self = @as(*FlatpakHostCommand, @ptrCast(@alignCast(ud)));</div><div class="diff-removed">-        const state = state: {</div><div class="diff-removed">-            self.state_mutex.lock();</div><div class="diff-removed">-            defer self.state_mutex.unlock();</div><div class="diff-removed">-            break :state self.state.started;</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        var pid: u32 = 0;</div><div class="diff-removed">-        var exit_status_raw: u32 = 0;</div><div class="diff-removed">-        c.g_variant_get(params.?, "(uu)", &pid, &exit_status_raw);</div><div class="diff-removed">-        if (state.pid != pid) return;</div><div class="diff-removed">-</div><div class="diff-removed">-        const exit_status = posix.W.EXITSTATUS(exit_status_raw);</div><div class="diff-removed">-        // Update our state</div><div class="diff-removed">-        self.updateState(.{</div><div class="diff-removed">-            .exited = .{</div><div class="diff-removed">-                .pid = pid,</div><div class="diff-removed">-                .status = exit_status,</div><div class="diff-removed">-            },</div><div class="diff-removed">-        });</div><div class="diff-removed">-        if (state.completion) |completion| {</div><div class="diff-removed">-            completion.result = exit_status;</div><div class="diff-removed">-            completion.timer.?.run(</div><div class="diff-removed">-                state.loop_xev.?,</div><div class="diff-removed">-                &completion.c_xev,</div><div class="diff-removed">-                0,</div><div class="diff-removed">-                anyopaque,</div><div class="diff-removed">-                completion.userdata,</div><div class="diff-removed">-                (struct {</div><div class="diff-removed">-                    fn callback(</div><div class="diff-removed">-                        ud_inner: ?*anyopaque,</div><div class="diff-removed">-                        l_inner: *xev.Loop,</div><div class="diff-removed">-                        c_inner: *xev.Completion,</div><div class="diff-removed">-                        r: xev.Timer.RunError!void,</div><div class="diff-removed">-                    ) xev.CallbackAction {</div><div class="diff-removed">-                        const c_outer: *Completion = @fieldParentPtr("c_xev", c_inner);</div><div class="diff-removed">-                        defer if (c_outer.timer) |*t| t.deinit();</div><div class="diff-removed">-</div><div class="diff-removed">-                        const result = if (r) |_| c_outer.result.? else |err| err;</div><div class="diff-removed">-                        c_outer.callback(ud_inner, l_inner, c_outer, result);</div><div class="diff-removed">-                        return .disarm;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }).callback,</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div class="diff-removed">-        log.debug("HostCommand exited pid={} status={}", .{ pid, exit_status });</div><div class="diff-removed">-</div><div class="diff-removed">-        // We're done now, so we can unsubscribe</div><div class="diff-removed">-        c.g_dbus_connection_signal_unsubscribe(bus.?, state.subscription);</div><div class="diff-removed">-</div><div class="diff-removed">-        // We are also done with our loop so we can exit.</div><div class="diff-removed">-        c.g_main_loop_quit(state.loop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn noopCallback(_: ?*anyopaque, _: *xev.Loop, _: *Completion, _: WaitError!u8) void {}</div><div class="diff-removed">-};</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    