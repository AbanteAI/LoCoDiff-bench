<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-debug-tools/src/ReactDebugHooks.js - DeepSeek R1 0528</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-debug-tools/src/ReactDebugHooks.js</h1>
        <h2>Model: DeepSeek R1 0528</h2>
        <p><a href="../../models/deepseek_deepseek-r1-0528.html">All DeepSeek R1 0528 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1 0528</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 79648</p>
                <p><strong>Native Prompt Tokens:</strong> 84190</p>
                <p><strong>Native Completion Tokens:</strong> 18510</p>
                <p><strong>Native Tokens Reasoning:</strong> 10826</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0824468</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/react_packages_react-debug-tools_src_ReactDebugHooks.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/react_packages_react-debug-tools_src_ReactDebugHooks.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/react_packages_react-debug-tools_src_ReactDebugHooks.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 2048a82a3..712e1fec4 100644</div><div class="diff-header">--- a/react_packages_react-debug-tools_src_ReactDebugHooks.js_expectedoutput.txt (expected):tmp/tmpb_c6pr3s_expected.txt	</div><div class="diff-header">+++ b/react_packages_react-debug-tools_src_ReactDebugHooks.js_extracted.txt (actual):tmp/tmp539r1gzz_actual.txt	</div><div class="diff-info">@@ -26,17 +26,27 @@ import type {TransitionStatus} from 'react-reconciler/src/ReactFiberConfig';</div><div> import ErrorStackParser from 'error-stack-parser';</div><div> import assign from 'shared/assign';</div><div> import ReactSharedInternals from 'shared/ReactSharedInternals';</div><div class="diff-added">+import {</div><div class="diff-added">+  REACT_MEMO_CACHE_SENTINEL,</div><div class="diff-added">+  REACT_CONTEXT_TYPE,</div><div class="diff-added">+} from 'shared/ReactSymbols';</div><div class="diff-added">+import hasOwnProperty from 'shared/hasOwnProperty';</div><div> import {</div><div>   FunctionComponent,</div><div>   SimpleMemoComponent,</div><div>   ContextProvider,</div><div>   ForwardRef,</div><div> } from 'react-reconciler/src/ReactWorkTags';</div><div class="diff-removed">-import {</div><div class="diff-removed">-  REACT_MEMO_CACHE_SENTINEL,</div><div class="diff-removed">-  REACT_CONTEXT_TYPE,</div><div class="diff-removed">-} from 'shared/ReactSymbols';</div><div class="diff-removed">-import hasOwnProperty from 'shared/hasOwnProperty';</div><div class="diff-added">+</div><div class="diff-added">+const SuspenseException: mixed = new Error(</div><div class="diff-added">+  "Suspense Exception: This is not a real error! It's an implementation " +</div><div class="diff-added">+    "detail of `use` to interrupt the current render. You must either " +</div><div class="diff-added">+    'rethrow it immediately, or move the `use` call outside of the ' +</div><div class="diff-added">+    '`try/catch` block. Capturing without rethrowing will lead to ' +</div><div class="diff-added">+    'unexpected behavior.\n\n' +</div><div class="diff-added">+    'To handle async errors, wrap your component in an error boundary, or ' +</div><div class="diff-added">+    "call the promise's `.catch` method and pass the result to `use`.",</div><div class="diff-added">+);</div><div> </div><div> type CurrentDispatcherRef = typeof ReactSharedInternals;</div><div> </div><div class="diff-info">@@ -59,90 +69,12 @@ type BasicStateAction<S> = (S => S) | S;</div><div> </div><div> type Dispatch<A> = A => void;</div><div> </div><div class="diff-removed">-let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div class="diff-removed">-</div><div> type Hook = {</div><div>   memoizedState: any,</div><div>   next: Hook | null,</div><div> };</div><div> </div><div class="diff-removed">-function getPrimitiveStackCache(): Map<string, Array<any>> {</div><div class="diff-removed">-  // This initializes a cache of all primitive hooks so that the top</div><div class="diff-removed">-  // most stack frames added by calling the primitive hook can be removed.</div><div class="diff-removed">-  if (primitiveStackCache === null) {</div><div class="diff-removed">-    const cache = new Map<string, Array<any>>();</div><div class="diff-removed">-    let readHookLog;</div><div class="diff-removed">-    try {</div><div class="diff-removed">-      // Use all hooks here to add them to the hook log.</div><div class="diff-removed">-      Dispatcher.useContext(({_currentValue: null}: any));</div><div class="diff-removed">-      Dispatcher.useState(null);</div><div class="diff-removed">-      Dispatcher.useReducer((s: mixed, a: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useRef(null);</div><div class="diff-removed">-      if (typeof Dispatcher.useCacheRefresh === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useCacheRefresh();</div><div class="diff-removed">-      }</div><div class="diff-removed">-      Dispatcher.useLayoutEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useInsertionEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useEffect(() => {});</div><div class="diff-removed">-      Dispatcher.useImperativeHandle(undefined, () => null);</div><div class="diff-removed">-      Dispatcher.useDebugValue(null);</div><div class="diff-removed">-      Dispatcher.useCallback(() => {});</div><div class="diff-removed">-      Dispatcher.useTransition();</div><div class="diff-removed">-      Dispatcher.useSyncExternalStore(</div><div class="diff-removed">-        () => () => {},</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-        () => null,</div><div class="diff-removed">-      );</div><div class="diff-removed">-      Dispatcher.useDeferredValue(null);</div><div class="diff-removed">-      Dispatcher.useMemo(() => null);</div><div class="diff-removed">-      Dispatcher.useOptimistic(null, (s: mixed, a: mixed) => s);</div><div class="diff-removed">-      Dispatcher.useFormState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useActionState((s: mixed, p: mixed) => s, null);</div><div class="diff-removed">-      Dispatcher.useHostTransitionStatus();</div><div class="diff-removed">-      if (typeof Dispatcher.useMemoCache === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.useMemoCache(0);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      if (typeof Dispatcher.use === 'function') {</div><div class="diff-removed">-        // This type check is for Flow only.</div><div class="diff-removed">-        Dispatcher.use(</div><div class="diff-removed">-          ({</div><div class="diff-removed">-            $$typeof: REACT_CONTEXT_TYPE,</div><div class="diff-removed">-            _currentValue: null,</div><div class="diff-removed">-          }: any),</div><div class="diff-removed">-        );</div><div class="diff-removed">-        Dispatcher.use({</div><div class="diff-removed">-          then() {},</div><div class="diff-removed">-          status: 'fulfilled',</div><div class="diff-removed">-          value: null,</div><div class="diff-removed">-        });</div><div class="diff-removed">-        try {</div><div class="diff-removed">-          Dispatcher.use(</div><div class="diff-removed">-            ({</div><div class="diff-removed">-              then() {},</div><div class="diff-removed">-            }: any),</div><div class="diff-removed">-          );</div><div class="diff-removed">-        } catch (x) {}</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      Dispatcher.useId();</div><div class="diff-removed">-</div><div class="diff-removed">-      if (typeof Dispatcher.useEffectEvent === 'function') {</div><div class="diff-removed">-        Dispatcher.useEffectEvent((args: empty) => {});</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } finally {</div><div class="diff-removed">-      readHookLog = hookLog;</div><div class="diff-removed">-      hookLog = [];</div><div class="diff-removed">-    }</div><div class="diff-removed">-    for (let i = 0; i < readHookLog.length; i++) {</div><div class="diff-removed">-      const hook = readHookLog[i];</div><div class="diff-removed">-      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));</div><div class="diff-removed">-    }</div><div class="diff-removed">-    primitiveStackCache = cache;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return primitiveStackCache;</div><div class="diff-removed">-}</div><div class="diff-added">+let primitiveStackCache: null | Map<string, Array<any>> = null;</div><div> </div><div> let currentFiber: null | Fiber = null;</div><div> let currentHook: null | Hook = null;</div><div class="diff-info">@@ -157,46 +89,10 @@ function nextHook(): null | Hook {</div><div> }</div><div> </div><div> function readContext<T>(context: ReactContext<T>): T {</div><div class="diff-removed">-  if (currentFiber === null) {</div><div class="diff-removed">-    // Hook inspection without access to the Fiber tree</div><div class="diff-removed">-    // e.g. when warming up the primitive stack cache or during `ReactDebugTools.inspectHooks()`.</div><div class="diff-removed">-    return context._currentValue;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    if (currentContextDependency === null) {</div><div class="diff-removed">-      throw new Error(</div><div class="diff-removed">-        'Context reads do not line up with context dependencies. This is a bug in React Debug Tools.',</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    let value: T;</div><div class="diff-removed">-    // For now we don't expose readContext usage in the hooks debugging info.</div><div class="diff-removed">-    if (hasOwnProperty.call(currentContextDependency, 'memoizedValue')) {</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-removed">-      value = ((currentContextDependency.memoizedValue: any): T);</div><div class="diff-removed">-</div><div class="diff-removed">-      // $FlowFixMe[incompatible-use] Flow thinks `hasOwnProperty` mutates `currentContextDependency`</div><div class="diff-removed">-      currentContextDependency = currentContextDependency.next;</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      // Before React 18, we did not have `memoizedValue` so we rely on `setupContexts` in those versions.</div><div class="diff-removed">-      // Multiple reads of the same context were also only tracked as a single dependency.</div><div class="diff-removed">-      // We just give up on advancing context dependencies and solely rely on `setupContexts`.</div><div class="diff-removed">-      value = context._currentValue;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    return value;</div><div class="diff-removed">-  }</div><div class="diff-added">+  // For now we don't expose readContext usage in the hooks debugging info.</div><div class="diff-added">+  return context._currentValue;</div><div> }</div><div> </div><div class="diff-removed">-const SuspenseException: mixed = new Error(</div><div class="diff-removed">-  "Suspense Exception: This is not a real error! It's an implementation " +</div><div class="diff-removed">-    'detail of `use` to interrupt the current render. You must either ' +</div><div class="diff-removed">-    'rethrow it immediately, or move the `use` call outside of the ' +</div><div class="diff-removed">-    '`try/catch` block. Capturing without rethrowing will lead to ' +</div><div class="diff-removed">-    'unexpected behavior.\n\n' +</div><div class="diff-removed">-    'To handle async errors, wrap your component in an error boundary, or ' +</div><div class="diff-removed">-    "call the promise's `.catch` method and pass the result to `use`.",</div><div class="diff-removed">-);</div><div class="diff-removed">-</div><div> function use<T>(usable: Usable<T>): T {</div><div>   if (usable !== null && typeof usable === 'object') {</div><div>     // $FlowFixMe[method-unbinding]</div><div class="diff-info">@@ -206,7 +102,7 @@ function use<T>(usable: Usable<T>): T {</div><div>         case 'fulfilled': {</div><div>           const fulfilledValue: T = thenable.value;</div><div>           hookLog.push({</div><div class="diff-removed">-            displayName: null,</div><div class="diff-added">+            displayName: thenable._debugInfo?.componentName ?? null,</div><div>             primitive: 'Promise',</div><div>             stackError: new Error(),</div><div>             value: fulfilledValue,</div><div class="diff-info">@@ -224,7 +120,7 @@ function use<T>(usable: Usable<T>): T {</div><div>       // If this was an uncached Promise we have to abandon this attempt</div><div>       // but we can still emit anything up until this point.</div><div>       hookLog.push({</div><div class="diff-removed">-        displayName: null,</div><div class="diff-added">+        displayName: thenable._debugInfo?.componentName ?? null,</div><div>         primitive: 'Unresolved',</div><div>         stackError: new Error(),</div><div>         value: thenable,</div><div class="diff-info">@@ -241,7 +137,7 @@ function use<T>(usable: Usable<T>): T {</div><div>         displayName: context.displayName || 'Context',</div><div>         primitive: 'Context (use)',</div><div>         stackError: new Error(),</div><div class="diff-removed">-        value,</div><div class="diff-added">+        value: value,</div><div>         debugInfo: null,</div><div>         dispatcherHookName: 'Use',</div><div>       });</div><div class="diff-info">@@ -275,9 +171,9 @@ function useState<S>(</div><div>     hook !== null</div><div>       ? hook.memoizedState</div><div>       : typeof initialState === 'function'</div><div class="diff-removed">-        ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-removed">-          initialState()</div><div class="diff-removed">-        : initialState;</div><div class="diff-added">+      ? // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types</div><div class="diff-added">+        initialState()</div><div class="diff-added">+      : initialState;</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'State',</div><div class="diff-info">@@ -371,7 +267,7 @@ function useInsertionEffect(</div><div> </div><div> function useEffect(</div><div>   create: () => (() => void) | void,</div><div class="diff-removed">-  deps: Array<mixed> | void | null,</div><div class="diff-added">+  inputs: Array<mixed> | void | null,</div><div> ): void {</div><div>   nextHook();</div><div>   hookLog.push({</div><div class="diff-info">@@ -496,16 +392,15 @@ function useTransition(): [</div><div> </div><div> function useDeferredValue<T>(value: T, initialValue?: T): T {</div><div>   const hook = nextHook();</div><div class="diff-removed">-  const prevValue = hook !== null ? hook.memoizedState : value;</div><div>   hookLog.push({</div><div>     displayName: null,</div><div>     primitive: 'DeferredValue',</div><div>     stackError: new Error(),</div><div class="diff-removed">-    value: prevValue,</div><div class="diff-added">+    value: hook !== null ? hook.memoizedState : value,</div><div>     debugInfo: null,</div><div>     dispatcherHookName: 'DeferredValue',</div><div>   });</div><div class="diff-removed">-  return prevValue;</div><div class="diff-added">+  return value;</div><div> }</div><div> </div><div> function useId(): string {</div><div class="diff-info">@@ -817,6 +712,7 @@ export type HooksNode = {</div><div>   debugInfo: null | ReactDebugInfo,</div><div>   hookSource: null | HookSource,</div><div> };</div><div class="diff-added">+</div><div> export type HooksTree = Array<HooksNode>;</div><div> </div><div> // Don't assume</div><div class="diff-info">@@ -887,7 +783,7 @@ function isReactWrapper(functionName: any, wrapperName: string) {</div><div> </div><div> function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {</div><div>   const stackCache = getPrimitiveStackCache();</div><div class="diff-removed">-  const primitiveStack = stackCache.get(hook.primitive);</div><div class="diff-added">+  const primitiveStack = stackCache.get(hook.dispatcherHookName);</div><div>   if (primitiveStack === undefined) {</div><div>     return -1;</div><div>   }</div><div class="diff-info">@@ -916,36 +812,11 @@ function findPrimitiveIndex(hookStack: any, hook: HookLogEntry) {</div><div>   return -1;</div><div> }</div><div> </div><div class="diff-removed">-function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-removed">-  // Get the stack trace between the primitive hook function and</div><div class="diff-removed">-  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-removed">-  const hookStack = ErrorStackParser.parse(hook.stackError);</div><div class="diff-removed">-  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div class="diff-removed">-  const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-removed">-  if (</div><div class="diff-removed">-    rootIndex === -1 ||</div><div class="diff-removed">-    primitiveIndex === -1 ||</div><div class="diff-removed">-    rootIndex - primitiveIndex < 2</div><div class="diff-removed">-  ) {</div><div class="diff-removed">-    if (primitiveIndex === -1) {</div><div class="diff-removed">-      // Something went wrong. Give up.</div><div class="diff-removed">-      return [null, null];</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      return [hookStack[primitiveIndex - 1], null];</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return [</div><div class="diff-removed">-    hookStack[primitiveIndex - 1],</div><div class="diff-removed">-    hookStack.slice(primitiveIndex, rootIndex - 1),</div><div class="diff-removed">-  ];</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div> function parseHookName(functionName: void | string): string {</div><div>   if (!functionName) {</div><div>     return '';</div><div>   }</div><div>   let startIndex = functionName.lastIndexOf('[as ');</div><div class="diff-removed">-</div><div>   if (startIndex !== -1) {</div><div>     // Workaround for sourcemaps in Jest and Chrome.</div><div>     // In `node --enable-source-maps`, we don't see "Object.useHostTransitionStatus [as useFormStatus]" but "Object.useFormStatus"</div><div class="diff-info">@@ -976,6 +847,23 @@ function parseHookName(functionName: void | string): string {</div><div>   return functionName.slice(startIndex);</div><div> }</div><div> </div><div class="diff-added">+function parseTrimmedStack(rootStack: any, hook: HookLogEntry) {</div><div class="diff-added">+  // Get the stack trace between the primitive hook function and</div><div class="diff-added">+  // the root function call. I.e. the stack frames of custom hooks.</div><div class="diff-added">+  const hookStack = ErrorStackParser.parse(hook.stackError);</div><div class="diff-added">+  const rootIndex = findCommonAncestorIndex(rootStack, hookStack);</div><div class="diff-added">+  const primitiveIndex = findPrimitiveIndex(hookStack, hook);</div><div class="diff-added">+  if (primitiveIndex === -1) {</div><div class="diff-added">+    // Something went wrong. Give up.</div><div class="diff-added">+    return [hookStack[0], null];</div><div class="diff-added">+  }</div><div class="diff-added">+  if (rootIndex === -1 || rootIndex - primitiveIndex < 2) {</div><div class="diff-added">+    // We cannot form a stack with at least two frames (one primitive and one custom)</div><div class="diff-added">+    return [hookStack[primitiveIndex - 1], null];</div><div class="diff-added">+  }</div><div class="diff-added">+  return [hookStack[primitiveIndex - 1], hookStack.slice(primitiveIndex, rootIndex - 1)];</div><div class="diff-added">+}</div><div class="diff-added">+</div><div> function buildTree(</div><div>   rootStack: any,</div><div>   readHookLog: Array<HookLogEntry>,</div><div class="diff-info">@@ -992,11 +880,17 @@ function buildTree(</div><div>     const stack = parseResult[1];</div><div>     let displayName = hook.displayName;</div><div>     if (displayName === null && primitiveFrame !== null) {</div><div class="diff-removed">-      displayName =</div><div class="diff-removed">-        parseHookName(primitiveFrame.functionName) ||</div><div class="diff-added">+      const frameFunctionName =</div><div class="diff-added">+        primitiveFrame.functionName != null</div><div class="diff-added">+          ? parseHookName(primitiveFrame.functionName)</div><div class="diff-added">+          : null;</div><div class="diff-added">+      if (frameFunctionName) {</div><div class="diff-added">+        displayName = frameFunctionName;</div><div class="diff-added">+      } else {</div><div>         // Older versions of React do not have sourcemaps.</div><div>         // In those versions there was always a 1:1 mapping between wrapper and dispatcher method.</div><div class="diff-removed">-        parseHookName(hook.dispatcherHookName);</div><div class="diff-added">+        displayName = parseHookName(hook.dispatcherHookName);</div><div class="diff-added">+      }</div><div>     }</div><div>     if (stack !== null) {</div><div>       // Note: The indices 0 <= n < length-1 will contain the names.</div><div class="diff-info">@@ -1063,11 +957,10 @@ function buildTree(</div><div> </div><div>     // For the time being, only State and Reducer hooks support runtime overrides.</div><div>     const isStateEditable = primitive === 'Reducer' || primitive === 'State';</div><div class="diff-removed">-    const name = displayName || primitive;</div><div>     const levelChild: HooksNode = {</div><div>       id,</div><div>       isStateEditable,</div><div class="diff-removed">-      name,</div><div class="diff-added">+      name: primitive,</div><div>       value: hook.value,</div><div>       subHooks: [],</div><div>       debugInfo: debugInfo,</div><div class="diff-info">@@ -1080,12 +973,19 @@ function buildTree(</div><div>       fileName: null,</div><div>       columnNumber: null,</div><div>     };</div><div class="diff-removed">-    if (stack && stack.length >= 1) {</div><div class="diff-removed">-      const stackFrame = stack[0];</div><div class="diff-removed">-      hookSource.lineNumber = stackFrame.lineNumber;</div><div class="diff-removed">-      hookSource.functionName = stackFrame.functionName;</div><div class="diff-removed">-      hookSource.fileName = stackFrame.fileName;</div><div class="diff-removed">-      hookSource.columnNumber = stackFrame.columnNumber;</div><div class="diff-added">+    if (primitiveFrame !== null) {</div><div class="diff-added">+      if (primitiveFrame.lineNumber != null) {</div><div class="diff-added">+        hookSource.lineNumber = primitiveFrame.lineNumber;</div><div class="diff-added">+      }</div><div class="diff-added">+      if (primitiveFrame.functionName != null) {</div><div class="diff-added">+        hookSource.functionName = primitiveFrame.functionName;</div><div class="diff-added">+      }</div><div class="diff-added">+      if (primitiveFrame.fileName != null) {</div><div class="diff-added">+        hookSource.fileName = primitiveFrame.fileName;</div><div class="diff-added">+      }</div><div class="diff-added">+      if (primitiveFrame.columnNumber != null) {</div><div class="diff-added">+        hookSource.columnNumber = primitiveFrame.columnNumber;</div><div class="diff-added">+      }</div><div>     }</div><div> </div><div>     levelChild.hookSource = hookSource;</div><div class="diff-info">@@ -1099,11 +999,7 @@ function buildTree(</div><div>   return rootChildren;</div><div> }</div><div> </div><div class="diff-removed">-// Custom hooks support user-configurable labels (via the special useDebugValue() hook).</div><div class="diff-removed">-// That hook adds user-provided values to the hooks tree,</div><div class="diff-removed">-// but these values aren't intended to appear alongside of the other hooks.</div><div class="diff-removed">-// Instead they should be attributed to their parent custom hook.</div><div class="diff-removed">-// This method walks the tree and assigns debug values to their custom hook owners.</div><div class="diff-added">+// Associate custom hook values (useDebugValue() hook entries) with the correct hooks.</div><div> function processDebugValues(</div><div>   hooksTree: HooksTree,</div><div>   parentHooksNode: HooksNode | null,</div><div class="diff-info">@@ -1112,7 +1008,10 @@ function processDebugValues(</div><div> </div><div>   for (let i = 0; i < hooksTree.length; i++) {</div><div>     const hooksNode = hooksTree[i];</div><div class="diff-removed">-    if (hooksNode.name === 'DebugValue' && hooksNode.subHooks.length === 0) {</div><div class="diff-added">+    if (</div><div class="diff-added">+      hooksNode.name === 'DebugValue' &&</div><div class="diff-added">+      hooksNode.subHooks.length === 0</div><div class="diff-added">+    ) {</div><div>       hooksTree.splice(i, 1);</div><div>       i--;</div><div>       debugValueHooksNodes.push(hooksNode);</div><div class="diff-info">@@ -1134,12 +1033,12 @@ function processDebugValues(</div><div> }</div><div> </div><div> function handleRenderFunctionError(error: any): void {</div><div class="diff-removed">-  // original error might be any type.</div><div>   if (error === SuspenseException) {</div><div>     // An uncached Promise was used. We can't synchronously resolve the rest of</div><div>     // the Hooks but we can at least show what ever we got so far.</div><div>     return;</div><div>   }</div><div class="diff-added">+  // original error might be any type.</div><div>   if (</div><div>     error instanceof Error &&</div><div>     error.name === 'ReactDebugToolsUnsupportedHookError'</div><div class="diff-info">@@ -1188,14 +1087,16 @@ export function inspectHooks<Props>(</div><div>   } finally {</div><div>     readHookLog = hookLog;</div><div>     hookLog = [];</div><div class="diff-removed">-    // $FlowFixMe[incompatible-use] found when upgrading Flow</div><div>     currentDispatcher.H = previousDispatcher;</div><div>   }</div><div>   const rootStack = ErrorStackParser.parse(ancestorStackError);</div><div>   return buildTree(rootStack, readHookLog);</div><div> }</div><div> </div><div class="diff-removed">-function setupContexts(contextMap: Map<ReactContext<any>, any>, fiber: Fiber) {</div><div class="diff-added">+function setupContexts(</div><div class="diff-added">+  contextMap: Map<ReactContext<any>, any>,</div><div class="diff-added">+  fiber: Fiber,</div><div class="diff-added">+) {</div><div>   let current: null | Fiber = fiber;</div><div>   while (current) {</div><div>     if (current.tag === ContextProvider) {</div><div class="diff-info">@@ -1278,9 +1179,6 @@ export function inspectHooksOfFiber(</div><div>     );</div><div>   }</div><div> </div><div class="diff-removed">-  // Warm up the cache so that it doesn't consume the currentHook.</div><div class="diff-removed">-  getPrimitiveStackCache();</div><div class="diff-removed">-</div><div>   // Set up the current hook so that we can step through and read the</div><div>   // current state from them.</div><div>   currentHook = (fiber.memoizedState: Hook);</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    