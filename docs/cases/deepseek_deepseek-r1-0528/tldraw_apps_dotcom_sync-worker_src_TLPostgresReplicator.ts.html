<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: apps/dotcom/sync-worker/src/TLPostgresReplicator.ts - DeepSeek R1 0528</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: apps/dotcom/sync-worker/src/TLPostgresReplicator.ts</h1>
        <h2>Model: DeepSeek R1 0528</h2>
        <p><a href="../../models/deepseek_deepseek-r1-0528.html">All DeepSeek R1 0528 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> DeepSeek R1 0528</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 73132</p>
                <p><strong>Native Prompt Tokens:</strong> 76859</p>
                <p><strong>Native Completion Tokens:</strong> 11687</p>
                <p><strong>Native Tokens Reasoning:</strong> 9381</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.06390716</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/deepseek_deepseek-r1-0528/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 039baf10b..361bb4af9 100644</div><div class="diff-header">--- a/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_expectedoutput.txt (expected):tmp/tmp0nk7rym9_expected.txt	</div><div class="diff-header">+++ b/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_extracted.txt (actual):tmp/tmpzztwy13e_actual.txt	</div><div class="diff-info">@@ -1,1052 +1,324 @@</div><div class="diff-removed">-import { DB, TlaFile, TlaFileState, TlaRow, TlaUser, ZTable } from '@tldraw/dotcom-shared'</div><div class="diff-removed">-import {</div><div class="diff-removed">-	ExecutionQueue,</div><div class="diff-removed">-	assert,</div><div class="diff-removed">-	assertExists,</div><div class="diff-removed">-	exhaustiveSwitchError,</div><div class="diff-removed">-	groupBy,</div><div class="diff-removed">-	promiseWithResolve,</div><div class="diff-removed">-	sleep,</div><div class="diff-removed">-	stringEnum,</div><div class="diff-removed">-	throttle,</div><div class="diff-removed">-	uniqueId,</div><div class="diff-removed">-} from '@tldraw/utils'</div><div class="diff-added">+import { ROOM_PREFIX, TlaFile, TlaFileState, TlaUser } from '@tldraw/dotcom-shared'</div><div class="diff-added">+import { assert, compact, uniq } from '@tldraw/utils'</div><div> import { createSentry } from '@tldraw/worker-shared'</div><div> import { DurableObject } from 'cloudflare:workers'</div><div class="diff-removed">-import { Kysely, sql } from 'kysely'</div><div class="diff-removed">-</div><div class="diff-removed">-import { LogicalReplicationService, Wal2Json, Wal2JsonPlugin } from 'pg-logical-replication'</div><div class="diff-removed">-import { Logger } from './Logger'</div><div class="diff-removed">-import { UserChangeCollator } from './UserChangeCollator'</div><div class="diff-removed">-import { ZReplicationEventWithoutSequenceInfo } from './UserDataSyncer'</div><div class="diff-removed">-import { createPostgresConnectionPool } from './postgres'</div><div class="diff-removed">-import { getR2KeyForRoom } from './r2'</div><div class="diff-removed">-import {</div><div class="diff-removed">-	Analytics,</div><div class="diff-removed">-	Environment,</div><div class="diff-removed">-	TLPostgresReplicatorEvent,</div><div class="diff-removed">-	TLPostgresReplicatorRebootSource,</div><div class="diff-removed">-} from './types'</div><div class="diff-removed">-import { EventData, writeDataPoint } from './utils/analytics'</div><div class="diff-removed">-import {</div><div class="diff-removed">-	getRoomDurableObject,</div><div class="diff-removed">-	getStatsDurableObjct,</div><div class="diff-removed">-	getUserDurableObject,</div><div class="diff-removed">-} from './utils/durableObjects'</div><div class="diff-removed">-</div><div class="diff-removed">-const relevantTables = stringEnum('user', 'file', 'file_state', 'user_mutation_number')</div><div class="diff-removed">-</div><div class="diff-removed">-interface ReplicationEvent {</div><div class="diff-removed">-	command: 'insert' | 'update' | 'delete'</div><div class="diff-removed">-	table: keyof typeof relevantTables</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-interface Change {</div><div class="diff-removed">-	event: ReplicationEvent</div><div class="diff-removed">-	userId: string</div><div class="diff-removed">-	fileId: string | null</div><div class="diff-removed">-	row: TlaRow</div><div class="diff-removed">-	previous?: TlaRow</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-interface Migration {</div><div class="diff-removed">-	id: string</div><div class="diff-removed">-	code: string</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-const migrations: Migration[] = [</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '000_seed',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-			CREATE TABLE IF NOT EXISTS active_user (</div><div class="diff-removed">-				id TEXT PRIMARY KEY</div><div class="diff-removed">-			);</div><div class="diff-removed">-			CREATE TABLE IF NOT EXISTS user_file_subscriptions (</div><div class="diff-removed">-				userId TEXT,</div><div class="diff-removed">-				fileId TEXT,</div><div class="diff-removed">-				PRIMARY KEY (userId, fileId),</div><div class="diff-removed">-				FOREIGN KEY (userId) REFERENCES active_user(id) ON DELETE CASCADE</div><div class="diff-removed">-			);</div><div class="diff-removed">-			CREATE TABLE migrations (</div><div class="diff-removed">-				id TEXT PRIMARY KEY,</div><div class="diff-removed">-				code TEXT NOT NULL</div><div class="diff-removed">-			);</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '001_add_sequence_number',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-			ALTER TABLE active_user ADD COLUMN sequenceNumber INTEGER NOT NULL DEFAULT 0;</div><div class="diff-removed">-			ALTER TABLE active_user ADD COLUMN sequenceIdSuffix TEXT NOT NULL DEFAULT '';</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '002_add_last_updated_at',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-			ALTER TABLE active_user ADD COLUMN lastUpdatedAt INTEGER NOT NULL DEFAULT 0;</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '003_add_lsn_tracking',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-			CREATE TABLE IF NOT EXISTS meta (</div><div class="diff-removed">-				lsn TEXT PRIMARY KEY,</div><div class="diff-removed">-				slotName TEXT NOT NULL</div><div class="diff-removed">-			);</div><div class="diff-removed">-			-- The slot name references the replication slot in postgres.</div><div class="diff-removed">-			-- If something ever gets messed up beyond mortal comprehension and we need to force all</div><div class="diff-removed">-			-- clients to reboot, we can just change the slot name by altering the slotNamePrefix in the constructor.</div><div class="diff-removed">-			INSERT INTO meta (lsn, slotName) VALUES ('0/0', 'init');</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '004_keep_event_log',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-		  CREATE TABLE history (</div><div class="diff-removed">-				lsn TEXT NOT NULL,</div><div class="diff-removed">-				userId TEXT NOT NULL,</div><div class="diff-removed">-				fileId TEXT,</div><div class="diff-removed">-				json TEXT NOT NULL</div><div class="diff-removed">-			);</div><div class="diff-removed">-			CREATE INDEX history_lsn_userId ON history (lsn, userId);</div><div class="diff-removed">-			CREATE INDEX history_lsn_fileId ON history (lsn, fileId);</div><div class="diff-removed">-			PRAGMA optimize;</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-	{</div><div class="diff-removed">-		id: '005_add_history_timestamp',</div><div class="diff-removed">-		code: `</div><div class="diff-removed">-			ALTER TABLE history ADD COLUMN timestamp INTEGER NOT NULL DEFAULT 0;</div><div class="diff-removed">-		`,</div><div class="diff-removed">-	},</div><div class="diff-removed">-]</div><div class="diff-removed">-</div><div class="diff-removed">-const ONE_MINUTE = 60 * 1000</div><div class="diff-removed">-const PRUNE_INTERVAL = 10 * ONE_MINUTE</div><div class="diff-removed">-const MAX_HISTORY_ROWS = 20_000</div><div class="diff-removed">-</div><div class="diff-removed">-type PromiseWithResolve = ReturnType<typeof promiseWithResolve></div><div class="diff-removed">-</div><div class="diff-removed">-type Row =</div><div class="diff-removed">-	| TlaRow</div><div class="diff-removed">-	| {</div><div class="diff-removed">-			bootId: string</div><div class="diff-removed">-			userId: string</div><div class="diff-removed">-	  }</div><div class="diff-removed">-	| {</div><div class="diff-removed">-			mutationNumber: number</div><div class="diff-removed">-			userId: string</div><div class="diff-removed">-	  }</div><div class="diff-removed">-</div><div class="diff-removed">-type BootState =</div><div class="diff-removed">-	| {</div><div class="diff-removed">-			type: 'init'</div><div class="diff-removed">-			promise: PromiseWithResolve</div><div class="diff-removed">-	  }</div><div class="diff-removed">-	| {</div><div class="diff-removed">-			type: 'connecting'</div><div class="diff-removed">-			promise: PromiseWithResolve</div><div class="diff-removed">-	  }</div><div class="diff-removed">-	| {</div><div class="diff-removed">-			type: 'connected'</div><div class="diff-removed">-	  }</div><div class="diff-added">+import postgres from 'postgres'</div><div class="diff-added">+import type { EventHint } from 'toucan-js/node_modules/@sentry/types'</div><div class="diff-added">+import type { TLUserDurableObject } from './TLUserDurableObject'</div><div class="diff-added">+import { Environment } from './types'</div><div class="diff-added">+</div><div class="diff-added">+const seed = `</div><div class="diff-added">+DROP TABLE IF EXISTS file_state;</div><div class="diff-added">+DROP TABLE IF EXISTS file;</div><div class="diff-added">+DROP TABLE IF EXISTS user;</div><div class="diff-added">+</div><div class="diff-added">+CREATE TABLE user (</div><div class="diff-added">+	id TEXT PRIMARY KEY,</div><div class="diff-added">+	json TEXT NOT NULL</div><div class="diff-added">+);</div><div class="diff-added">+</div><div class="diff-added">+CREATE TABLE file (</div><div class="diff-added">+	id TEXT PRIMARY KEY,</div><div class="diff-added">+	ownerId TEXT NOT NULL,</div><div class="diff-added">+	json TEXT NOT NULL,</div><div class="diff-added">+	FOREIGN KEY (ownerId) REFERENCES user (id) ON DELETE CASCADE</div><div class="diff-added">+);</div><div class="diff-added">+</div><div class="diff-added">+CREATE TABLE file_state (</div><div class="diff-added">+	userId TEXT NOT NULL,</div><div class="diff-added">+	fileId TEXT NOT NULL,</div><div class="diff-added">+	json TEXT NOT NULL,</div><div class="diff-added">+	PRIMARY KEY (userId, fileId),</div><div class="diff-added">+	FOREIGN KEY (userId) REFERENCES user (id) ON DELETE CASCADE,</div><div class="diff-added">+	FOREIGN KEY (fileId) REFERENCES file (id) ON DELETE CASCADE</div><div class="diff-added">+);</div><div class="diff-added">+`</div><div> </div><div> export class TLPostgresReplicator extends DurableObject<Environment> {</div><div class="diff-removed">-	private sqlite: SqlStorage</div><div class="diff-removed">-	private state: BootState</div><div class="diff-removed">-	private measure: Analytics | undefined</div><div class="diff-removed">-	private postgresUpdates = 0</div><div class="diff-removed">-	private lastPostgresMessageTime = Date.now()</div><div class="diff-removed">-	private lastRpmLogTime = Date.now()</div><div class="diff-removed">-	private lastUserPruneTime = Date.now()</div><div class="diff-removed">-</div><div class="diff-removed">-	// we need to guarantee in-order delivery of messages to users</div><div class="diff-removed">-	// but DO RPC calls are not guaranteed to happen in order, so we need to</div><div class="diff-removed">-	// use a queue per user</div><div class="diff-removed">-	private userDispatchQueues: Map<string, ExecutionQueue> = new Map()</div><div class="diff-removed">-</div><div class="diff-added">+	sql: SqlStorage</div><div class="diff-added">+	db: ReturnType<typeof postgres></div><div> 	sentry</div><div class="diff-removed">-	// eslint-disable-next-line local/prefer-class-methods</div><div class="diff-removed">-	private captureException = (exception: unknown, extras?: Record<string, unknown>) => {</div><div class="diff-added">+	captureException(exception: unknown, eventHint?: EventHint) {</div><div> 		// eslint-disable-next-line @typescript-eslint/no-deprecated</div><div class="diff-removed">-		this.sentry?.withScope((scope) => {</div><div class="diff-removed">-			if (extras) scope.setExtras(extras)</div><div class="diff-removed">-			// eslint-disable-next-line @typescript-eslint/no-deprecated</div><div class="diff-removed">-			this.sentry?.captureException(exception) as any</div><div class="diff-removed">-		})</div><div class="diff-removed">-		this.log.debug('ERROR', (exception as any)?.stack ?? exception)</div><div class="diff-added">+		this.sentry?.captureException(exception, eventHint) as any</div><div> 		if (!this.sentry) {</div><div class="diff-removed">-			console.error(`[TLPostgresReplicator]: `, exception)</div><div class="diff-added">+			console.error(exception)</div><div> 		}</div><div> 	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private log</div><div class="diff-removed">-</div><div class="diff-removed">-	private readonly replicationService</div><div class="diff-removed">-	private readonly slotName</div><div class="diff-removed">-	private readonly wal2jsonPlugin = new Wal2JsonPlugin({</div><div class="diff-removed">-		addTables:</div><div class="diff-removed">-			'public.user,public.file,public.file_state,public.user_mutation_number,public.replicator_boot_id',</div><div class="diff-removed">-	})</div><div class="diff-removed">-</div><div class="diff-removed">-	private readonly db: Kysely<DB></div><div> 	constructor(ctx: DurableObjectState, env: Environment) {</div><div> 		super(ctx, env)</div><div class="diff-removed">-		this.measure = env.MEASURE</div><div> 		this.sentry = createSentry(ctx, env)</div><div class="diff-removed">-		this.sqlite = this.ctx.storage.sql</div><div class="diff-removed">-		this.state = {</div><div class="diff-removed">-			type: 'init',</div><div class="diff-removed">-			promise: promiseWithResolve(),</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		const slotNameMaxLength = 63 // max postgres identifier length</div><div class="diff-removed">-		const slotNamePrefix = 'tlpr_' // pick something short so we can get more of the durable object id</div><div class="diff-removed">-		const durableObjectId = this.ctx.id.toString()</div><div class="diff-removed">-		this.slotName =</div><div class="diff-removed">-			slotNamePrefix + durableObjectId.slice(0, slotNameMaxLength - slotNamePrefix.length)</div><div class="diff-removed">-</div><div class="diff-removed">-		this.log = new Logger(env, 'TLPostgresReplicator', this.sentry)</div><div class="diff-removed">-		this.db = createPostgresConnectionPool(env, 'TLPostgresReplicator', 100)</div><div> </div><div class="diff-removed">-		this.replicationService = new LogicalReplicationService(</div><div class="diff-removed">-			/**</div><div class="diff-removed">-			 * node-postgres Client options for connection</div><div class="diff-removed">-			 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_extracted.txt (actual): 'postgres',</div><div class="diff-removed">-				connectionString: env.BOTCOM_POSTGRES_CONNECTION_STRING,</div><div class="diff-removed">-				application_name: this.slotName,</div><div class="diff-removed">-			},</div><div class="diff-removed">-			/**</div><div class="diff-removed">-			 * Logical replication service config</div><div class="diff-removed">-			 * https://github.com/kibae/pg-logical-replication/blob/tldraw_apps_dotcom_sync-worker_src_TLPostgresReplicator.ts_extracted.txt (actual): {</div><div class="diff-removed">-					auto: false,</div><div class="diff-removed">-					timeoutSeconds: 10,</div><div class="diff-added">+		this.db = postgres(env.BOTCOM_POSTGRES_CONNECTION_STRING, {</div><div class="diff-added">+			types: {</div><div class="diff-added">+				bigint: {</div><div class="diff-added">+					from: [20], // PostgreSQL OID for BIGINT</div><div class="diff-added">+					parse: (value: string) => Number(value), // Convert string to number</div><div class="diff-added">+					to: 20,</div><div class="diff-added">+					serialize: (value: number) => String(value), // Convert number to string</div><div> 				},</div><div class="diff-removed">-			}</div><div class="diff-removed">-		)</div><div class="diff-removed">-</div><div class="diff-removed">-		this.alarm()</div><div class="diff-removed">-		this.ctx</div><div class="diff-removed">-			.blockConcurrencyWhile(async () => {</div><div class="diff-removed">-				await this._migrate().catch((e) => {</div><div class="diff-removed">-					this.captureException(e)</div><div class="diff-removed">-					throw e</div><div class="diff-removed">-				})</div><div class="diff-removed">-				// if the slot name changed, we set the lsn to null, which will trigger a mass user DO reboot</div><div class="diff-removed">-				if (this.sqlite.exec('select slotName from meta').one().slotName !== this.slotName) {</div><div class="diff-removed">-					this.sqlite.exec('UPDATE meta SET slotName = ?, lsn = null', this.slotName)</div><div class="diff-removed">-				}</div><div class="diff-removed">-				await sql`SELECT pg_create_logical_replication_slot(${this.slotName}, 'wal2json') WHERE NOT EXISTS (SELECT 1 FROM pg_replication_slots WHERE slot_name = ${this.slotName})`.execute(</div><div class="diff-removed">-					this.db</div><div class="diff-removed">-				)</div><div class="diff-removed">-				this.pruneHistory()</div><div class="diff-removed">-			})</div><div class="diff-removed">-			.then(() => {</div><div class="diff-removed">-				this.reboot('constructor', false).catch((e) => {</div><div class="diff-removed">-					this.captureException(e)</div><div class="diff-removed">-					this.__test__panic()</div><div class="diff-removed">-				})</div><div class="diff-removed">-			})</div><div class="diff-removed">-		// no need to catch since throwing in a blockConcurrencyWhile will trigger</div><div class="diff-removed">-		// a DO reboot</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private _applyMigration(index: number) {</div><div class="diff-removed">-		this.log.debug('running migration', migrations[index].id)</div><div class="diff-removed">-		this.sqlite.exec(migrations[index].code)</div><div class="diff-removed">-		this.sqlite.exec(</div><div class="diff-removed">-			'insert into migrations (id, code) values (?, ?)',</div><div class="diff-removed">-			migrations[index].id,</div><div class="diff-removed">-			migrations[index].code</div><div class="diff-removed">-		)</div><div class="diff-removed">-		this.log.debug('ran migration', migrations[index].id)</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private async _migrate() {</div><div class="diff-removed">-		let appliedMigrations: Migration[]</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			appliedMigrations = this.sqlite</div><div class="diff-removed">-				.exec('select code, id from migrations order by id asc')</div><div class="diff-removed">-				.toArray() as any</div><div class="diff-removed">-		} catch (_e) {</div><div class="diff-removed">-			// no migrations table, run initial migration</div><div class="diff-removed">-			this._applyMigration(0)</div><div class="diff-removed">-			appliedMigrations = [migrations[0]]</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		for (let i = 0; i < appliedMigrations.length; i++) {</div><div class="diff-removed">-			if (appliedMigrations[i].id !== migrations[i].id) {</div><div class="diff-removed">-				throw new Error(</div><div class="diff-removed">-					'TLPostgresReplicator migrations have changed!! this is an append-only array!!'</div><div class="diff-removed">-				)</div><div class="diff-removed">-			}</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		for (let i = appliedMigrations.length; i < migrations.length; i++) {</div><div class="diff-removed">-			this._applyMigration(i)</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	async __test__forceReboot() {</div><div class="diff-removed">-		this.reboot('test')</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	async __test__panic() {</div><div class="diff-removed">-		this.ctx.abort()</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	override async alarm() {</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			this.ctx.storage.setAlarm(Date.now() + 3000)</div><div class="diff-removed">-			this.maybeLogRpm()</div><div class="diff-removed">-			// If we haven't heard anything from postgres for 5 seconds, trigger a heartbeat.</div><div class="diff-removed">-			// Otherwise, if we haven't heard anything for 10 seconds, do a soft reboot.</div><div class="diff-removed">-			if (Date.now() - this.lastPostgresMessageTime > 10000) {</div><div class="diff-removed">-				this.log.debug('rebooting due to inactivity')</div><div class="diff-removed">-				this.reboot('inactivity')</div><div class="diff-removed">-			} else if (Date.now() - this.lastPostgresMessageTime > 5000) {</div><div class="diff-removed">-				// this triggers a heartbeat</div><div class="diff-removed">-				this.log.debug('triggering heartbeat due to inactivity')</div><div class="diff-removed">-				await this.replicationService.acknowledge('0/0')</div><div class="diff-removed">-			}</div><div class="diff-removed">-			await this.maybePrune()</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.captureException(e)</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private async maybePrune() {</div><div class="diff-removed">-		const now = Date.now()</div><div class="diff-removed">-		if (now - this.lastUserPruneTime < PRUNE_INTERVAL) return</div><div class="diff-removed">-		this.logEvent({ type: 'prune' })</div><div class="diff-removed">-		this.log.debug('pruning')</div><div class="diff-removed">-		const cutoffTime = now - PRUNE_INTERVAL</div><div class="diff-removed">-		const usersWithoutRecentUpdates = this.ctx.storage.sql</div><div class="diff-removed">-			.exec('SELECT id FROM active_user WHERE lastUpdatedAt < ?', cutoffTime)</div><div class="diff-removed">-			.toArray() as {</div><div class="diff-removed">-			id: string</div><div class="diff-removed">-		}[]</div><div class="diff-removed">-		for (const { id } of usersWithoutRecentUpdates) {</div><div class="diff-removed">-			await this.unregisterUser(id)</div><div class="diff-removed">-		}</div><div class="diff-removed">-		this.pruneHistory()</div><div class="diff-removed">-		this.lastUserPruneTime = Date.now()</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private pruneHistory() {</div><div class="diff-removed">-		this.sqlite.exec(`</div><div class="diff-removed">-      WITH max AS (</div><div class="diff-removed">-        SELECT MAX(rowid) AS max_id FROM history</div><div class="diff-removed">-      )</div><div class="diff-removed">-      DELETE FROM history</div><div class="diff-removed">-      WHERE rowid < (SELECT max_id FROM max) - ${MAX_HISTORY_ROWS};</div><div class="diff-removed">-    `)</div><div class="diff-removed">-	}</div><div class="diff-added">+			},</div><div class="diff-added">+		})</div><div> </div><div class="diff-removed">-	private maybeLogRpm() {</div><div class="diff-removed">-		const now = Date.now()</div><div class="diff-removed">-		if (this.postgresUpdates > 0 && now - this.lastRpmLogTime > ONE_MINUTE) {</div><div class="diff-removed">-			this.logEvent({</div><div class="diff-removed">-				type: 'rpm',</div><div class="diff-removed">-				rpm: this.postgresUpdates,</div><div class="diff-added">+		this.ctx.blockConcurrencyWhile(async () => {</div><div class="diff-added">+			let didFetchInitialData = false</div><div class="diff-added">+			// TODO: time how long this takes</div><div class="diff-added">+			await new Promise((resolve, reject) => {</div><div class="diff-added">+				this.db</div><div class="diff-added">+					.subscribe(</div><div class="diff-added">+						'*',</div><div class="diff-added">+						async (row, info) => {</div><div class="diff-added">+							if (!didFetchInitialData) {</div><div class="diff-added">+								return</div><div class="diff-added">+							}</div><div class="diff-added">+							try {</div><div class="diff-added">+								await this.handleEvent(row, info)</div><div class="diff-added">+							} catch (e) {</div><div class="diff-added">+								this.captureException(e)</div><div class="diff-added">+							}</div><div class="diff-added">+						},</div><div class="diff-added">+						async () => {</div><div class="diff-added">+							try {</div><div class="diff-added">+								const users = await this.db`SELECT * FROM public.user`</div><div class="diff-added">+								const files = await this.db`SELECT * FROM file`</div><div class="diff-added">+								const fileStates = await this.db`SELECT * FROM file_state`</div><div class="diff-added">+								this.ctx.storage.sql.exec(seed)</div><div class="diff-added">+								users.forEach((user) => this.insertRow(user, 'user'))</div><div class="diff-added">+								files.forEach((file) => this.insertRow(file, 'file'))</div><div class="diff-added">+								fileStates.forEach((fileState) => this.insertRow(fileState, 'file_state'))</div><div class="diff-added">+							} catch (e) {</div><div class="diff-added">+								this.captureException(e)</div><div class="diff-added">+								reject(e)</div><div class="diff-added">+							}</div><div class="diff-added">+							didFetchInitialData = true</div><div class="diff-added">+							resolve(null)</div><div class="diff-added">+						},</div><div class="diff-added">+						() => {</div><div class="diff-added">+							// TODO: ping team if this fails</div><div class="diff-added">+							this.captureException(new Error('replication start failed'))</div><div class="diff-added">+							reject(null)</div><div class="diff-added">+						}</div><div class="diff-added">+					)</div><div class="diff-added">+					.catch((err) => {</div><div class="diff-added">+						// TODO: ping team if this fails</div><div class="diff-added">+						this.captureException(new Error('replication start failed (catch)'))</div><div class="diff-added">+						this.captureException(err)</div><div class="diff-added">+					})</div><div> 			})</div><div class="diff-removed">-			this.postgresUpdates = 0</div><div class="diff-removed">-			this.lastRpmLogTime = now</div><div class="diff-removed">-		}</div><div class="diff-added">+		})</div><div class="diff-added">+		this.sql = this.ctx.storage.sql</div><div> 	}</div><div> </div><div class="diff-removed">-	async getDiagnostics() {</div><div class="diff-removed">-		const earliestHistoryRow = this.sqlite</div><div class="diff-removed">-			.exec('select * from history order by rowid asc limit 1')</div><div class="diff-removed">-			.toArray()[0]</div><div class="diff-removed">-		const latestHistoryRow = this.sqlite</div><div class="diff-removed">-			.exec('select * from history order by rowid desc limit 1')</div><div class="diff-removed">-			.toArray()[0]</div><div class="diff-removed">-		const activeUsers = this.sqlite.exec('select count(*) from active_user').one().count as number</div><div class="diff-removed">-		const meta = this.sqlite.exec('select * from meta').one()</div><div class="diff-removed">-		return {</div><div class="diff-removed">-			earliestHistoryRow,</div><div class="diff-removed">-			latestHistoryRow,</div><div class="diff-removed">-			activeUsers,</div><div class="diff-removed">-			meta,</div><div class="diff-added">+	async handleEvent(row: postgres.Row | null, event: postgres.ReplicationEvent) {</div><div class="diff-added">+		if (event.relation.table === 'user_mutation_number') {</div><div class="diff-added">+			if (!row) throw new Error('Row is required for delete event')</div><div class="diff-added">+			this.getStubForUser(row.userId).commitMutation(row.mutationNumber)</div><div class="diff-added">+			return</div><div> 		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private queue = new ExecutionQueue()</div><div class="diff-removed">-</div><div class="diff-removed">-	private async reboot(source: TLPostgresReplicatorRebootSource, delay = true) {</div><div class="diff-removed">-		this.logEvent({ type: 'reboot', source })</div><div class="diff-removed">-		if (!this.queue.isEmpty()) {</div><div class="diff-removed">-			this.log.debug('reboot is already in progress.', source)</div><div class="diff-added">+		if (</div><div class="diff-added">+			event.relation.table !== 'user' &&</div><div class="diff-added">+			event.relation.table !== 'file' &&</div><div class="diff-added">+			event.relation.table !== 'file_state'</div><div class="diff-added">+		) {</div><div class="diff-added">+			console.error(`Unhandled table: ${event.relation.table}`)</div><div> 			return</div><div> 		}</div><div class="diff-removed">-		this.log.debug('reboot push', source)</div><div class="diff-removed">-		await this.queue.push(async () => {</div><div class="diff-removed">-			if (delay) {</div><div class="diff-removed">-				await sleep(2000)</div><div class="diff-removed">-			}</div><div class="diff-removed">-			const start = Date.now()</div><div class="diff-removed">-			this.log.debug('rebooting', source)</div><div class="diff-removed">-			const res = await Promise.race([</div><div class="diff-removed">-				this.boot().then(() => 'ok'),</div><div class="diff-removed">-				sleep(3000).then(() => 'timeout'),</div><div class="diff-removed">-			]).catch((e) => {</div><div class="diff-removed">-				this.logEvent({ type: 'reboot_error' })</div><div class="diff-removed">-				this.log.debug('reboot error', e.stack)</div><div class="diff-removed">-				this.captureException(e)</div><div class="diff-removed">-				return 'error'</div><div class="diff-removed">-			})</div><div class="diff-removed">-			this.log.debug('rebooted', res)</div><div class="diff-removed">-			if (res === 'ok') {</div><div class="diff-removed">-				this.logEvent({ type: 'reboot_duration', duration: Date.now() - start })</div><div class="diff-removed">-			} else {</div><div class="diff-removed">-				getStatsDurableObjct(this.env).recordReplicatorBootRetry()</div><div class="diff-removed">-				this.reboot('retry')</div><div class="diff-removed">-			}</div><div class="diff-removed">-		})</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private async boot() {</div><div class="diff-removed">-		this.log.debug('booting')</div><div class="diff-removed">-		this.lastPostgresMessageTime = Date.now()</div><div class="diff-removed">-		this.replicationService.removeAllListeners()</div><div class="diff-removed">-</div><div class="diff-removed">-		// stop any previous subscriptions both here and on the postgres side to make sure we will be allowed to connect</div><div class="diff-removed">-		// to the slot again.</div><div class="diff-removed">-		this.log.debug('stopping replication')</div><div class="diff-removed">-		this.replicationService.stop().catch(this.captureException)</div><div class="diff-removed">-		this.log.debug('terminating backend')</div><div class="diff-removed">-		await sql`SELECT pg_terminate_backend(active_pid) FROM pg_replication_slots WHERE slot_name = ${this.slotName} AND active`.execute(</div><div class="diff-removed">-			this.db</div><div class="diff-removed">-		)</div><div class="diff-removed">-		this.log.debug('done')</div><div> </div><div class="diff-removed">-		const promise = 'promise' in this.state ? this.state.promise : promiseWithResolve()</div><div class="diff-removed">-		this.state = {</div><div class="diff-removed">-			type: 'connecting',</div><div class="diff-removed">-			// preserve the promise so any awaiters do eventually get resolved</div><div class="diff-removed">-			// TODO: set a timeout on the promise?</div><div class="diff-removed">-			promise,</div><div class="diff-added">+		let userIds: string[] = []</div><div class="diff-added">+		if (row) {</div><div class="diff-added">+			userIds = this.getImpactedUserIds(row, event)</div><div> 		}</div><div class="diff-removed">-</div><div class="diff-removed">-		this.replicationService.on('heartbeat', (lsn: string) => {</div><div class="diff-removed">-			this.log.debug('heartbeat', lsn)</div><div class="diff-removed">-			this.lastPostgresMessageTime = Date.now()</div><div class="diff-removed">-			this.reportPostgresUpdate()</div><div class="diff-removed">-			// don't call this.updateLsn here because it's not necessary</div><div class="diff-removed">-			// to save the lsn after heartbeats since they contain no information</div><div class="diff-removed">-			this.replicationService.acknowledge(lsn).catch(this.captureException)</div><div class="diff-removed">-		})</div><div class="diff-removed">-</div><div class="diff-removed">-		this.replicationService.addListener('data', (lsn: string, log: Wal2Json.Output) => {</div><div class="diff-removed">-			// ignore events received after disconnecting, if that can even happen</div><div class="diff-removed">-			try {</div><div class="diff-removed">-				if (this.state.type !== 'connected') return</div><div class="diff-removed">-				this.postgresUpdates++</div><div class="diff-removed">-				this.lastPostgresMessageTime = Date.now()</div><div class="diff-removed">-				this.reportPostgresUpdate()</div><div class="diff-removed">-				const collator = new UserChangeCollator()</div><div class="diff-removed">-				for (const _change of log.change) {</div><div class="diff-removed">-					if (_change.kind === 'message' && (_change as any).prefix === 'requestLsnUpdate') {</div><div class="diff-removed">-						this.requestLsnUpdate((_change as any).content)</div><div class="diff-removed">-						continue</div><div class="diff-removed">-					}</div><div class="diff-removed">-					const change = this.parseChange(_change)</div><div class="diff-removed">-					if (!change) {</div><div class="diff-removed">-						this.log.debug('IGNORING CHANGE', _change)</div><div class="diff-removed">-						continue</div><div class="diff-removed">-					}</div><div class="diff-removed">-</div><div class="diff-removed">-					this.handleEvent(collator, change, false)</div><div class="diff-removed">-					this.sqlite.exec(</div><div class="diff-removed">-						'INSERT INTO history (lsn, userId, fileId, json, timestamp) VALUES (?, ?, ?, ?, ?)',</div><div class="diff-removed">-						lsn,</div><div class="diff-removed">-						change.userId,</div><div class="diff-removed">-						change.fileId,</div><div class="diff-removed">-						JSON.stringify(change),</div><div class="diff-removed">-						Date.now()</div><div class="diff-removed">-					)</div><div class="diff-removed">-				}</div><div class="diff-removed">-				this.log.debug('changes', collator.changes.size)</div><div class="diff-removed">-				for (const [userId, changes] of collator.changes) {</div><div class="diff-removed">-					this._messageUser(userId, { type: 'changes', changes, lsn })</div><div class="diff-removed">-				}</div><div class="diff-removed">-				this.commitLsn(lsn)</div><div class="diff-removed">-			} catch (e) {</div><div class="diff-removed">-				this.captureException(e)</div><div class="diff-removed">-			}</div><div class="diff-removed">-		})</div><div class="diff-removed">-</div><div class="diff-removed">-		this.replicationService.addListener('start', () => {</div><div class="diff-removed">-			if (!this.getCurrentLsn()) {</div><div class="diff-removed">-				// make a request to force an updateLsn()</div><div class="diff-removed">-				sql`insert into replicator_boot_id ("replicatorId", "bootId") values (${this.ctx.id.toString()}, ${uniqueId()}) on conflict ("replicatorId") do update set "bootId" = excluded."bootId"`.execute(</div><div class="diff-removed">-					this.db</div><div class="diff-added">+		switch (event.command) {</div><div class="diff-added">+			case 'delete':</div><div class="diff-added">+				if (!row) throw new Error('Row is required for delete event')</div><div class="diff-added">+				this.deleteRow(row, event)</div><div class="diff-added">+				break</div><div class="diff-added">+			case 'insert':</div><div class="diff-added">+				if (!row) throw new Error('Row is required for delete event')</div><div class="diff-added">+				this.insertRow(row, event.relation.table as 'user' | 'file' | 'file_state')</div><div class="diff-added">+				break</div><div class="diff-added">+			case 'update':</div><div class="diff-added">+				if (!row) throw new Error('Row is required for delete event')</div><div class="diff-added">+				this.updateRow(row, event)</div><div class="diff-added">+				break</div><div class="diff-added">+			default:</div><div class="diff-added">+				console.error(`Unhandled event: ${event}`)</div><div class="diff-added">+		}</div><div class="diff-added">+		if (row) {</div><div class="diff-added">+			for (const userId of userIds) {</div><div class="diff-added">+				// get user DO and send update message</div><div class="diff-added">+				this.getStubForUser(userId).onRowChange(</div><div class="diff-added">+					row,</div><div class="diff-added">+					event.relation.table as 'user' | 'file' | 'file_state',</div><div class="diff-added">+					event.command</div><div> 				)</div><div> 			}</div><div class="diff-removed">-		})</div><div class="diff-removed">-</div><div class="diff-removed">-		const handleError = (e: Error) => {</div><div class="diff-removed">-			this.captureException(e)</div><div class="diff-removed">-			this.reboot('retry')</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		this.replicationService.on('error', handleError)</div><div class="diff-removed">-		this.replicationService.subscribe(this.wal2jsonPlugin, this.slotName).catch(handleError)</div><div class="diff-removed">-</div><div class="diff-removed">-		this.state = {</div><div class="diff-removed">-			type: 'connected',</div><div class="diff-removed">-		}</div><div class="diff-removed">-		promise.resolve(null)</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private getCurrentLsn() {</div><div class="diff-removed">-		return this.sqlite.exec('SELECT lsn FROM meta').one().lsn as string | null</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private async commitLsn(lsn: string) {</div><div class="diff-removed">-		const result = await this.replicationService.acknowledge(lsn)</div><div class="diff-removed">-		if (result) {</div><div class="diff-removed">-			// if the current lsn in the meta table is null it means</div><div class="diff-removed">-			// that we are using a brand new replication slot and we</div><div class="diff-removed">-			// need to force all user DOs to reboot</div><div class="diff-removed">-			const prevLsn = this.getCurrentLsn()</div><div class="diff-removed">-			this.sqlite.exec('UPDATE meta SET lsn = ?', lsn)</div><div class="diff-removed">-			if (!prevLsn) {</div><div class="diff-removed">-				this.onDidSequenceBreak()</div><div class="diff-removed">-			}</div><div class="diff-removed">-		} else {</div><div class="diff-removed">-			this.captureException(new Error('acknowledge failed'))</div><div class="diff-removed">-			this.reboot('retry')</div><div> 		}</div><div> 	}</div><div> </div><div class="diff-removed">-	private parseChange(change: Wal2Json.Change): Change | null {</div><div class="diff-removed">-		const table = change.table as ReplicationEvent['table']</div><div class="diff-removed">-		if (change.kind === 'truncate' || change.kind === 'message' || !(table in relevantTables)) {</div><div class="diff-removed">-			return null</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		const row = {} as any</div><div class="diff-removed">-		const previous = {} as any</div><div class="diff-removed">-		// take everything from change.columnnames and associated the values from change.columnvalues</div><div class="diff-removed">-		if (change.kind === 'delete') {</div><div class="diff-removed">-			const oldkeys = change.oldkeys</div><div class="diff-removed">-			assert(oldkeys, 'oldkeys is required for delete events')</div><div class="diff-removed">-			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')</div><div class="diff-removed">-			oldkeys.keynames.forEach((key, i) => {</div><div class="diff-removed">-				row[key] = oldkeys.keyvalues[i]</div><div class="diff-removed">-			})</div><div class="diff-removed">-		} else if (change.kind === 'update') {</div><div class="diff-removed">-			const oldkeys = change.oldkeys</div><div class="diff-removed">-			assert(oldkeys, 'oldkeys is required for delete events')</div><div class="diff-removed">-			assert(oldkeys.keyvalues, 'oldkeys is required for delete events')</div><div class="diff-removed">-			oldkeys.keynames.forEach((key, i) => {</div><div class="diff-removed">-				previous[key] = oldkeys.keyvalues[i]</div><div class="diff-removed">-			})</div><div class="diff-removed">-			change.columnnames.forEach((col, i) => {</div><div class="diff-removed">-				row[col] = change.columnvalues[i]</div><div class="diff-removed">-			})</div><div class="diff-removed">-		} else {</div><div class="diff-removed">-			change.columnnames.forEach((col, i) => {</div><div class="diff-removed">-				row[col] = change.columnvalues[i]</div><div class="diff-removed">-			})</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		let userId = null as string | null</div><div class="diff-removed">-		let fileId = null as string | null</div><div class="diff-removed">-		switch (table) {</div><div class="diff-added">+	deleteRow(row: postgres.Row, event: postgres.ReplicationEvent) {</div><div class="diff-added">+		switch (event.relation.table) {</div><div> 			case 'user':</div><div class="diff-removed">-				userId = (row as TlaUser).id</div><div class="diff-added">+				this.sql.exec(`DELETE FROM user WHERE id = ?`, row.id)</div><div> 				break</div><div> 			case 'file':</div><div class="diff-removed">-				userId = (row as TlaFile).ownerId</div><div class="diff-removed">-				fileId = (row as TlaFile).id</div><div class="diff-added">+				this.sql.exec(`DELETE FROM file WHERE id = ?`, row.id)</div><div> 				break</div><div class="diff-removed">-			case 'file_state':</div><div class="diff-removed">-				userId = (row as TlaFileState).userId</div><div class="diff-removed">-				fileId = (row as TlaFileState).fileId</div><div class="diff-removed">-				break</div><div class="diff-removed">-			case 'user_mutation_number':</div><div class="diff-removed">-				userId = (row as { userId: string }).userId</div><div class="diff-removed">-				break</div><div class="diff-removed">-			default: {</div><div class="diff-removed">-				// assert never</div><div class="diff-removed">-				const _x: never = table</div><div class="diff-removed">-			}</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		if (!userId) return null</div><div class="diff-removed">-</div><div class="diff-removed">-		return {</div><div class="diff-removed">-			row,</div><div class="diff-removed">-			previous,</div><div class="diff-removed">-			event: {</div><div class="diff-removed">-				command: change.kind,</div><div class="diff-removed">-				table,</div><div class="diff-removed">-			},</div><div class="diff-removed">-			userId,</div><div class="diff-removed">-			fileId,</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private onDidSequenceBreak() {</div><div class="diff-removed">-		// re-register all active users to get their latest guest info</div><div class="diff-removed">-		// do this in small batches to avoid overwhelming the system</div><div class="diff-removed">-		const users = this.sqlite.exec('SELECT id FROM active_user').toArray()</div><div class="diff-removed">-		this.reportActiveUsers()</div><div class="diff-removed">-		const BATCH_SIZE = 5</div><div class="diff-removed">-		const tick = () => {</div><div class="diff-removed">-			if (users.length === 0) return</div><div class="diff-removed">-			const batch = users.splice(0, BATCH_SIZE)</div><div class="diff-removed">-			for (const user of batch) {</div><div class="diff-removed">-				this._messageUser(user.id as string, { type: 'maybe_force_reboot' })</div><div class="diff-removed">-			}</div><div class="diff-removed">-			setTimeout(tick, 10)</div><div class="diff-removed">-		}</div><div class="diff-removed">-		tick()</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private reportPostgresUpdate = throttle(</div><div class="diff-removed">-		() => getStatsDurableObjct(this.env).recordReplicatorPostgresUpdate(),</div><div class="diff-removed">-		5000</div><div class="diff-removed">-	)</div><div class="diff-removed">-</div><div class="diff-removed">-	private handleEvent(collator: UserChangeCollator, change: Change, isReplay: boolean) {</div><div class="diff-removed">-		// ignore events received after disconnecting, if that can even happen</div><div class="diff-removed">-		if (this.state.type !== 'connected') return</div><div class="diff-removed">-</div><div class="diff-removed">-		// We shouldn't get these two, but just to be sure we'll filter them out</div><div class="diff-removed">-		const { command, table } = change.event</div><div class="diff-removed">-		this.log.debug('handleEvent', change)</div><div class="diff-removed">-		assert(this.state.type === 'connected', 'state should be connected in handleEvent')</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			switch (table) {</div><div class="diff-removed">-				case 'user_mutation_number':</div><div class="diff-removed">-					this.handleMutationConfirmationEvent(collator, change.row, { command, table })</div><div class="diff-removed">-					break</div><div class="diff-removed">-				case 'file_state':</div><div class="diff-removed">-					this.handleFileStateEvent(collator, change.row, { command, table })</div><div class="diff-removed">-					break</div><div class="diff-removed">-				case 'file':</div><div class="diff-removed">-					this.handleFileEvent(collator, change.row, change.previous, { command, table }, isReplay)</div><div class="diff-removed">-					break</div><div class="diff-removed">-				case 'user':</div><div class="diff-removed">-					this.handleUserEvent(collator, change.row, { command, table })</div><div class="diff-removed">-					break</div><div class="diff-removed">-				default: {</div><div class="diff-removed">-					const _x: never = table</div><div class="diff-removed">-					this.captureException(new Error(`Unhandled table: ${table}`), { change })</div><div class="diff-removed">-					break</div><div class="diff-removed">-				}</div><div class="diff-removed">-			}</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.captureException(e)</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private handleMutationConfirmationEvent(</div><div class="diff-removed">-		collator: UserChangeCollator,</div><div class="diff-removed">-		row: Row | null,</div><div class="diff-removed">-		event: ReplicationEvent</div><div class="diff-removed">-	) {</div><div class="diff-removed">-		if (event.command === 'delete') return</div><div class="diff-removed">-		assert(row && 'mutationNumber' in row, 'mutationNumber is required')</div><div class="diff-removed">-		collator.addChange(row.userId, {</div><div class="diff-removed">-			type: 'mutation_commit',</div><div class="diff-removed">-			mutationNumber: row.mutationNumber,</div><div class="diff-removed">-			userId: row.userId,</div><div class="diff-removed">-		})</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private handleFileStateEvent(</div><div class="diff-removed">-		collator: UserChangeCollator,</div><div class="diff-removed">-		row: Row | null,</div><div class="diff-removed">-		event: ReplicationEvent</div><div class="diff-removed">-	) {</div><div class="diff-removed">-		assert(row && 'userId' in row && 'fileId' in row, 'userId is required')</div><div class="diff-removed">-		if (!this.userIsActive(row.userId)) return</div><div class="diff-removed">-		if (event.command === 'insert') {</div><div class="diff-removed">-			if (!row.isFileOwner) {</div><div class="diff-removed">-				this.sqlite.exec(</div><div class="diff-removed">-					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,</div><div class="diff-added">+			case 'file_state': {</div><div class="diff-added">+				this.sql.exec(</div><div class="diff-added">+					`DELETE FROM file_state WHERE userId = ? AND fileId = ?`,</div><div> 					row.userId,</div><div> 					row.fileId</div><div> 				)</div><div class="diff-removed">-			}</div><div class="diff-removed">-		} else if (event.command === 'delete') {</div><div class="diff-removed">-			this.sqlite.exec(</div><div class="diff-removed">-				`DELETE FROM user_file_subscriptions WHERE userId = ? AND fileId = ?`,</div><div class="diff-removed">-				row.userId,</div><div class="diff-removed">-				row.fileId</div><div class="diff-removed">-			)</div><div class="diff-removed">-		}</div><div class="diff-removed">-		collator.addChange(row.userId, {</div><div class="diff-removed">-			type: 'row_update',</div><div class="diff-removed">-			row: row as any,</div><div class="diff-removed">-			table: event.table as ZTable,</div><div class="diff-removed">-			event: event.command,</div><div class="diff-removed">-			userId: row.userId,</div><div class="diff-removed">-		})</div><div class="diff-removed">-	}</div><div> </div><div class="diff-removed">-	private handleFileEvent(</div><div class="diff-removed">-		collator: UserChangeCollator,</div><div class="diff-removed">-		row: Row | null,</div><div class="diff-removed">-		previous: Row | undefined,</div><div class="diff-removed">-		event: ReplicationEvent,</div><div class="diff-removed">-		isReplay: boolean</div><div class="diff-removed">-	) {</div><div class="diff-removed">-		assert(row && 'id' in row && 'ownerId' in row, 'row id is required')</div><div class="diff-removed">-		const impactedUserIds = [</div><div class="diff-removed">-			row.ownerId,</div><div class="diff-removed">-			...this.sqlite</div><div class="diff-removed">-				.exec('SELECT userId FROM user_file_subscriptions WHERE fileId = ?', row.id)</div><div class="diff-removed">-				.toArray()</div><div class="diff-removed">-				.map((x) => x.userId as string),</div><div class="diff-removed">-		]</div><div class="diff-removed">-		// if the file state was deleted before the file, we might not have any impacted users</div><div class="diff-removed">-		if (event.command === 'delete') {</div><div class="diff-removed">-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidDelete(row)</div><div class="diff-removed">-			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE fileId = ?`, row.id)</div><div class="diff-removed">-		} else if (event.command === 'update') {</div><div class="diff-removed">-			assert('ownerId' in row, 'ownerId is required when updating file')</div><div class="diff-removed">-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordDidUpdate(row)</div><div class="diff-removed">-			if (previous && !isReplay) {</div><div class="diff-removed">-				const prevFile = previous as TlaFile</div><div class="diff-removed">-				if (row.published && !(prevFile as TlaFile).published) {</div><div class="diff-removed">-					this.publishSnapshot(row)</div><div class="diff-removed">-				} else if (!row.published && (prevFile as TlaFile).published) {</div><div class="diff-removed">-					this.unpublishSnapshot(row)</div><div class="diff-removed">-				} else if (row.published && row.lastPublished > prevFile.lastPublished) {</div><div class="diff-removed">-					this.publishSnapshot(row)</div><div class="diff-added">+				const files = this.sql</div><div class="diff-added">+					.exec(`SELECT * FROM file WHERE id = ? LIMIT 1`, row.fileId)</div><div class="diff-added">+					.toArray() as any as TlaFile[]</div><div class="diff-added">+				if (!files.length) break</div><div class="diff-added">+				const file = files[0] as any</div><div class="diff-added">+				if (row.userId !== file.ownerId) {</div><div class="diff-added">+					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'delete')</div><div> 				}</div><div class="diff-removed">-			}</div><div class="diff-removed">-		} else if (event.command === 'insert') {</div><div class="diff-removed">-			assert('ownerId' in row, 'ownerId is required when inserting file')</div><div class="diff-removed">-			if (!isReplay) getRoomDurableObject(this.env, row.id).appFileRecordCreated(row)</div><div class="diff-removed">-		}</div><div class="diff-removed">-		for (const userId of impactedUserIds) {</div><div class="diff-removed">-			collator.addChange(userId, {</div><div class="diff-removed">-				type: 'row_update',</div><div class="diff-removed">-				row: row as any,</div><div class="diff-removed">-				table: event.table as ZTable,</div><div class="diff-removed">-				event: event.command,</div><div class="diff-removed">-				userId,</div><div class="diff-removed">-			})</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private handleUserEvent(collator: UserChangeCollator, row: Row | null, event: ReplicationEvent) {</div><div class="diff-removed">-		assert(row && 'id' in row, 'user id is required')</div><div class="diff-removed">-		this.log.debug('USER EVENT', event.command, row.id)</div><div class="diff-removed">-		collator.addChange(row.id, {</div><div class="diff-removed">-			type: 'row_update',</div><div class="diff-removed">-			row: row as any,</div><div class="diff-removed">-			table: event.table as ZTable,</div><div class="diff-removed">-			event: event.command,</div><div class="diff-removed">-			userId: row.id,</div><div class="diff-removed">-		})</div><div class="diff-removed">-		return [row.id]</div><div class="diff-removed">-	}</div><div> </div><div class="diff-removed">-	private userIsActive(userId: string) {</div><div class="diff-removed">-		return this.sqlite.exec(`SELECT * FROM active_user WHERE id = ?`, userId).toArray().length > 0</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	async ping() {</div><div class="diff-removed">-		this.log.debug('ping')</div><div class="diff-removed">-		return { sequenceId: this.slotName }</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private async _messageUser(userId: string, event: ZReplicationEventWithoutSequenceInfo) {</div><div class="diff-removed">-		this.log.debug('messageUser', userId, event)</div><div class="diff-removed">-		if (!this.userIsActive(userId)) {</div><div class="diff-removed">-			this.log.debug('user is not active', userId)</div><div class="diff-removed">-			return</div><div class="diff-removed">-		}</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			let q = this.userDispatchQueues.get(userId)</div><div class="diff-removed">-			if (!q) {</div><div class="diff-removed">-				q = new ExecutionQueue()</div><div class="diff-removed">-				this.userDispatchQueues.set(userId, q)</div><div class="diff-added">+				break</div><div> 			}</div><div class="diff-removed">-			const { sequenceNumber, sequenceIdSuffix } = this.sqlite</div><div class="diff-removed">-				.exec(</div><div class="diff-removed">-					'UPDATE active_user SET sequenceNumber = sequenceNumber + 1, lastUpdatedAt = ? WHERE id = ? RETURNING sequenceNumber, sequenceIdSuffix',</div><div class="diff-removed">-					Date.now(),</div><div class="diff-removed">-					userId</div><div class="diff-removed">-				)</div><div class="diff-removed">-				.one()</div><div class="diff-removed">-			assert(typeof sequenceNumber === 'number', 'sequenceNumber should be a number')</div><div class="diff-removed">-			assert(typeof sequenceIdSuffix === 'string', 'sequenceIdSuffix should be a string')</div><div class="diff-removed">-</div><div class="diff-removed">-			await q.push(async () => {</div><div class="diff-removed">-				const user = getUserDurableObject(this.env, userId)</div><div class="diff-removed">-</div><div class="diff-removed">-				const res = await user.handleReplicationEvent({</div><div class="diff-removed">-					...event,</div><div class="diff-removed">-					sequenceNumber,</div><div class="diff-removed">-					sequenceId: this.slotName + sequenceIdSuffix,</div><div class="diff-removed">-				})</div><div class="diff-removed">-				if (res === 'unregister') {</div><div class="diff-removed">-					this.log.debug('unregistering user', userId, event)</div><div class="diff-removed">-					this.unregisterUser(userId)</div><div class="diff-removed">-				}</div><div class="diff-removed">-			})</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.captureException(e)</div><div> 		}</div><div> 	}</div><div> </div><div class="diff-removed">-	reportActiveUsers() {</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			const { count } = this.sqlite.exec('SELECT COUNT(*) as count FROM active_user').one()</div><div class="diff-removed">-			this.logEvent({ type: 'active_users', count: count as number })</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			console.error('Error in reportActiveUsers', e)</div><div class="diff-removed">-		}</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	private getResumeType(</div><div class="diff-removed">-		lsn: string,</div><div class="diff-removed">-		userId: string,</div><div class="diff-removed">-		guestFileIds: string[]</div><div class="diff-removed">-	): { type: 'done'; messages?: ZReplicationEventWithoutSequenceInfo[] } | { type: 'reboot' } {</div><div class="diff-removed">-		const currentLsn = assertExists(this.getCurrentLsn())</div><div class="diff-removed">-</div><div class="diff-removed">-		if (lsn >= currentLsn) {</div><div class="diff-removed">-			this.log.debug('getResumeType: resuming from current lsn', lsn, '>=', currentLsn)</div><div class="diff-removed">-			// targetLsn is now or in the future, we can register them and deliver events</div><div class="diff-removed">-			// without needing to check the history</div><div class="diff-removed">-			return { type: 'done' }</div><div class="diff-removed">-		}</div><div class="diff-removed">-		const earliestLsn = this.sqlite</div><div class="diff-removed">-			.exec<{ lsn: string }>('SELECT lsn FROM history ORDER BY rowid asc LIMIT 1')</div><div class="diff-removed">-			.toArray()[0]?.lsn</div><div class="diff-removed">-</div><div class="diff-removed">-		if (!earliestLsn || lsn < earliestLsn) {</div><div class="diff-removed">-			this.log.debug('getResumeType: not enough history', lsn, '<', earliestLsn)</div><div class="diff-removed">-			// not enough history, we can't resume</div><div class="diff-removed">-			return { type: 'reboot' }</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		const history = this.sqlite</div><div class="diff-removed">-			.exec<{ json: string; lsn: string }>(</div><div class="diff-removed">-				`</div><div class="diff-removed">-			SELECT lsn, json</div><div class="diff-removed">-			FROM history</div><div class="diff-removed">-			WHERE</div><div class="diff-removed">-			  lsn > ?</div><div class="diff-removed">-				AND (</div><div class="diff-removed">-				  userId = ? </div><div class="diff-removed">-					OR fileId IN (${guestFileIds.map((_, i) => '$' + (i + 1)).join(', ')})</div><div class="diff-removed">-				)</div><div class="diff-removed">-			ORDER BY rowid ASC</div><div class="diff-removed">-		`,</div><div class="diff-removed">-				lsn,</div><div class="diff-removed">-				userId,</div><div class="diff-removed">-				...guestFileIds</div><div class="diff-removed">-			)</div><div class="diff-removed">-			.toArray()</div><div class="diff-removed">-			.map(({ json, lsn }) => ({ change: JSON.parse(json) as Change, lsn }))</div><div class="diff-removed">-</div><div class="diff-removed">-		if (history.length === 0) {</div><div class="diff-removed">-			this.log.debug('getResumeType: no history to replay, all good', lsn)</div><div class="diff-removed">-			return { type: 'done' }</div><div class="diff-removed">-		}</div><div class="diff-removed">-</div><div class="diff-removed">-		const changesByLsn = groupBy(history, (x) => x.lsn)</div><div class="diff-removed">-		const messages: ZReplicationEventWithoutSequenceInfo[] = []</div><div class="diff-removed">-		for (const lsn of Object.keys(changesByLsn).sort()) {</div><div class="diff-removed">-			const collator = new UserChangeCollator()</div><div class="diff-removed">-			for (const change of changesByLsn[lsn]) {</div><div class="diff-removed">-				this.handleEvent(collator, change.change, true)</div><div class="diff-removed">-			}</div><div class="diff-removed">-			const changes = collator.changes.get(userId)</div><div class="diff-removed">-			if (changes?.length) {</div><div class="diff-removed">-				messages.push({ type: 'changes', changes, lsn })</div><div class="diff-added">+	insertRow(_row: object, table: 'user' | 'file' | 'file_state') {</div><div class="diff-added">+		switch (table) {</div><div class="diff-added">+			case 'user': {</div><div class="diff-added">+				const row = _row as TlaUser</div><div class="diff-added">+				this.sql.exec(`INSERT INTO user VALUES (?, ?)`, row.id, JSON.stringify(row))</div><div class="diff-added">+				break</div><div> 			}</div><div class="diff-removed">-		}</div><div class="diff-removed">-		this.log.debug('getResumeType: resuming', messages.length, messages)</div><div class="diff-removed">-		return { type: 'done', messages }</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	async registerUser({</div><div class="diff-removed">-		userId,</div><div class="diff-removed">-		lsn,</div><div class="diff-removed">-		guestFileIds,</div><div class="diff-removed">-		bootId,</div><div class="diff-removed">-	}: {</div><div class="diff-removed">-		userId: string</div><div class="diff-removed">-		lsn: string</div><div class="diff-removed">-		guestFileIds: string[]</div><div class="diff-removed">-		bootId: string</div><div class="diff-removed">-	}): Promise<{ type: 'done'; sequenceId: string; sequenceNumber: number } | { type: 'reboot' }> {</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			while (!this.getCurrentLsn()) {</div><div class="diff-removed">-				// this should only happen once per slot name change, which should never happen!</div><div class="diff-removed">-				await sleep(100)</div><div class="diff-added">+			case 'file': {</div><div class="diff-added">+				const row = _row as TlaFile</div><div class="diff-added">+				this.sql.exec(`INSERT INTO file VALUES (?, ?, ?)`, row.id, row.ownerId, JSON.stringify(row))</div><div class="diff-added">+				break</div><div> 			}</div><div class="diff-removed">-</div><div class="diff-removed">-			this.log.debug('registering user', userId, lsn, bootId, guestFileIds)</div><div class="diff-removed">-			this.logEvent({ type: 'register_user' })</div><div class="diff-removed">-</div><div class="diff-removed">-			// clear user and subscriptions</div><div class="diff-removed">-			this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)</div><div class="diff-removed">-			this.sqlite.exec(</div><div class="diff-removed">-				`INSERT INTO active_user (id, sequenceNumber, sequenceIdSuffix, lastUpdatedAt) VALUES (?, 0, ?, ?)`,</div><div class="diff-removed">-				userId,</div><div class="diff-removed">-				bootId,</div><div class="diff-removed">-				Date.now()</div><div class="diff-removed">-			)</div><div class="diff-removed">-</div><div class="diff-removed">-			this.sqlite.exec(`DELETE FROM user_file_subscriptions WHERE userId = ?`, userId)</div><div class="diff-removed">-			for (const fileId of guestFileIds) {</div><div class="diff-removed">-				this.sqlite.exec(</div><div class="diff-removed">-					`INSERT INTO user_file_subscriptions (userId, fileId) VALUES (?, ?) ON CONFLICT (userId, fileId) DO NOTHING`,</div><div class="diff-removed">-					userId,</div><div class="diff-removed">-					fileId</div><div class="diff-added">+			case 'file_state': {</div><div class="diff-added">+				const row = _row as TlaFileState</div><div class="diff-added">+				this.sql.exec(</div><div class="diff-added">+					`INSERT INTO file_state VALUES (?, ?, ?)`,</div><div class="diff-added">+					row.userId,</div><div class="diff-added">+					row.fileId,</div><div class="diff-added">+					JSON.stringify(row)</div><div> 				)</div><div class="diff-removed">-			}</div><div class="diff-removed">-			this.log.debug('inserted file subscriptions', guestFileIds.length)</div><div class="diff-removed">-</div><div class="diff-removed">-			this.reportActiveUsers()</div><div class="diff-removed">-			this.log.debug('inserted active user')</div><div class="diff-removed">-</div><div class="diff-removed">-			const resume = this.getResumeType(lsn, userId, guestFileIds)</div><div class="diff-removed">-			if (resume.type === 'reboot') {</div><div class="diff-removed">-				return { type: 'reboot' }</div><div class="diff-removed">-			}</div><div class="diff-removed">-</div><div class="diff-removed">-			if (resume.messages) {</div><div class="diff-removed">-				for (const message of resume.messages) {</div><div class="diff-removed">-					this._messageUser(userId, message)</div><div class="diff-added">+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.fileId).toArray()[0] as {</div><div class="diff-added">+					json: string</div><div class="diff-added">+					ownerId: string</div><div class="diff-added">+				} | null</div><div class="diff-added">+				if (!file) break</div><div class="diff-added">+				if (file.ownerId !== row.userId) {</div><div class="diff-added">+					this.getStubForUser(row.userId).onRowChange(JSON.parse(file.json), 'file', 'insert')</div><div> 				}</div><div class="diff-added">+				break</div><div> 			}</div><div class="diff-removed">-</div><div class="diff-removed">-			return {</div><div class="diff-removed">-				type: 'done',</div><div class="diff-removed">-				sequenceId: this.slotName + bootId,</div><div class="diff-removed">-				sequenceNumber: 0,</div><div class="diff-removed">-			}</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.captureException(e)</div><div class="diff-removed">-			throw e</div><div> 		}</div><div> 	}</div><div> </div><div class="diff-removed">-	private async requestLsnUpdate(userId: string) {</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			this.log.debug('requestLsnUpdate', userId)</div><div class="diff-removed">-			this.logEvent({ type: 'request_lsn_update' })</div><div class="diff-removed">-			const lsn = assertExists(this.getCurrentLsn(), 'lsn should exist')</div><div class="diff-removed">-			this._messageUser(userId, { type: 'changes', changes: [], lsn })</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.captureException(e)</div><div class="diff-removed">-			throw e</div><div class="diff-removed">-		}</div><div class="diff-removed">-		return</div><div class="diff-removed">-	}</div><div class="diff-added">+	getImpactedUserIds(row: postgres.Row, event: postgres.ReplicationEvent): string[] {</div><div class="diff-added">+		switch (event.relation.table) {</div><div class="diff-added">+			case 'user':</div><div class="diff-added">+				assert(row.id, 'row id is required')</div><div class="diff-added">+				return [row.id as string]</div><div class="diff-added">+			case 'file': {</div><div class="diff-added">+				assert(row.id, 'row id is required')</div><div class="diff-added">+				const file = this.sql.exec(`SELECT * FROM file WHERE id = ?`, row.id).toArray()[0]</div><div class="diff-added">+				return compact(</div><div class="diff-added">+					uniq([</div><div class="diff-added">+						...(this.sql</div><div class="diff-added">+							.exec(</div><div class="diff-added">+								`SELECT id FROM user WHERE EXISTS(select 1 from file_state where fileId = ?)`,</div><div class="diff-added">+								row.id</div><div class="diff-added">+							)</div><div class="diff-added">+							.toArray()</div><div class="diff-added">+							.map((x) => x.id) as string[]),</div><div class="diff-added">+						row.ownerId as string,</div><div class="diff-added">+						file?.ownerId as string,</div><div class="diff-added">+					])</div><div class="diff-added">+				)</div><div class="diff-added">+			}</div><div> </div><div class="diff-removed">-	async unregisterUser(userId: string) {</div><div class="diff-removed">-		this.logEvent({ type: 'unregister_user' })</div><div class="diff-removed">-		this.sqlite.exec(`DELETE FROM active_user WHERE id = ?`, userId)</div><div class="diff-removed">-		this.reportActiveUsers()</div><div class="diff-removed">-		const queue = this.userDispatchQueues.get(userId)</div><div class="diff-removed">-		if (queue) {</div><div class="diff-removed">-			queue.close()</div><div class="diff-removed">-			this.userDispatchQueues.delete(userId)</div><div class="diff-added">+			case 'file_state':</div><div class="diff-added">+				assert(row.userId, 'user id is required')</div><div class="diff-added">+				assert(row.fileId, 'file id is required')</div><div class="diff-added">+				return [row.userId as string]</div><div> 		}</div><div class="diff-added">+		return []</div><div> 	}</div><div> </div><div class="diff-removed">-	private writeEvent(eventData: EventData) {</div><div class="diff-removed">-		writeDataPoint(this.sentry, this.measure, this.env, 'replicator', eventData)</div><div class="diff-removed">-	}</div><div class="diff-removed">-</div><div class="diff-removed">-	logEvent(event: TLPostgresReplicatorEvent) {</div><div class="diff-removed">-		switch (event.type) {</div><div class="diff-removed">-			case 'reboot':</div><div class="diff-removed">-				this.writeEvent({ blobs: [event.type, event.source] })</div><div class="diff-removed">-				break</div><div class="diff-removed">-			case 'reboot_error':</div><div class="diff-removed">-			case 'register_user':</div><div class="diff-removed">-			case 'unregister_user':</div><div class="diff-removed">-			case 'request_lsn_update':</div><div class="diff-removed">-			case 'prune':</div><div class="diff-removed">-			case 'get_file_record':</div><div class="diff-removed">-				this.writeEvent({</div><div class="diff-removed">-					blobs: [event.type],</div><div class="diff-removed">-				})</div><div class="diff-added">+	updateRow(_row: postgres.Row, event: postgres.ReplicationEvent) {</div><div class="diff-added">+		switch (event.relation.table) {</div><div class="diff-added">+			case 'user': {</div><div class="diff-added">+				const row = _row as TlaUser</div><div class="diff-added">+				this.sql.exec(`UPDATE user SET json = ? WHERE id = ?`, JSON.stringify(row), row.id)</div><div> 				break</div><div class="diff-added">+			}</div><div class="diff-added">+			case 'file': {</div><div class="diff-added">+				const row = _row as TlaFile</div><div class="diff-added">+				this.sql.exec(</div><div class="diff-added">+					`UPDATE file SET json = ?, ownerId = ? WHERE id = ?`,</div><div class="diff-added">+					JSON.stringify(row),</div><div class="diff-added">+					row.ownerId,</div><div class="diff-added">+					row.id</div><div class="diff-added">+				)</div><div> </div><div class="diff-removed">-			case 'reboot_duration':</div><div class="diff-removed">-				this.writeEvent({</div><div class="diff-removed">-					blobs: [event.type],</div><div class="diff-removed">-					doubles: [event.duration],</div><div class="diff-removed">-				})</div><div class="diff-removed">-				break</div><div class="diff-removed">-			case 'rpm':</div><div class="diff-removed">-				this.writeEvent({</div><div class="diff-removed">-					blobs: [event.type],</div><div class="diff-removed">-					doubles: [event.rpm],</div><div class="diff-removed">-				})</div><div class="diff-added">+				const room = this.env.TLDR_DOC.get(</div><div class="diff-added">+					this.env.TLDR_DOC.idFromName(`/${ROOM_PREFIX}/${row.id}`)</div><div class="diff-added">+				)</div><div class="diff-added">+				room.appFileRecordDidUpdate(row).catch(console.error)</div><div> 				break</div><div class="diff-removed">-			case 'active_users':</div><div class="diff-removed">-				this.writeEvent({</div><div class="diff-removed">-					blobs: [event.type],</div><div class="diff-removed">-					doubles: [event.count],</div><div class="diff-removed">-				})</div><div class="diff-added">+			}</div><div class="diff-added">+			case 'file_state': {</div><div class="diff-added">+				const row = _row as TlaFileState</div><div class="diff-added">+				this.sql.exec(</div><div class="diff-added">+					`UPDATE file_state SET json = ? WHERE userId = ? AND fileId = ?`,</div><div class="diff-added">+					JSON.stringify(row),</div><div class="diff-added">+					row.userId,</div><div class="diff-added">+					row.fileId</div><div class="diff-added">+				)</div><div> 				break</div><div class="diff-removed">-			default:</div><div class="diff-removed">-				exhaustiveSwitchError(event)</div><div class="diff-added">+			}</div><div> 		}</div><div> 	}</div><div> </div><div class="diff-removed">-	private async publishSnapshot(file: TlaFile) {</div><div class="diff-removed">-		try {</div><div class="diff-removed">-			// make sure the room's snapshot is up to date</div><div class="diff-removed">-			await getRoomDurableObject(this.env, file.id).awaitPersist()</div><div class="diff-removed">-			// and that it exists</div><div class="diff-removed">-			const snapshot = await this.env.ROOMS.get(getR2KeyForRoom({ slug: file.id, isApp: true }))</div><div class="diff-removed">-</div><div class="diff-removed">-			if (!snapshot) {</div><div class="diff-removed">-				throw new Error('Snapshot not found')</div><div class="diff-removed">-			}</div><div class="diff-removed">-			const blob = await snapshot.blob()</div><div class="diff-removed">-</div><div class="diff-removed">-			// Create a new slug for the published room</div><div class="diff-removed">-			await this.env.SNAPSHOT_SLUG_TO_PARENT_SLUG.put(file.publishedSlug, file.id)</div><div class="diff-removed">-</div><div class="diff-removed">-			// Bang the snapshot into the database</div><div class="diff-removed">-			await this.env.ROOM_SNAPSHOTS.put(</div><div class="diff-removed">-				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}`, isApp: true }),</div><div class="diff-removed">-				blob</div><div class="diff-removed">-			)</div><div class="diff-removed">-			const currentTime = new Date().toISOString()</div><div class="diff-removed">-			await this.env.ROOM_SNAPSHOTS.put(</div><div class="diff-removed">-				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}|${currentTime}`, isApp: true }),</div><div class="diff-removed">-				blob</div><div class="diff-added">+	async fetchDataForUser(userId: string) {</div><div class="diff-added">+		const files = this.sql</div><div class="diff-added">+			.exec(</div><div class="diff-added">+				`SELECT json FROM file WHERE ownerId = ? OR EXISTS(SELECT 1 from file_state WHERE userId = ? AND file_state.fileId = file.id) `,</div><div class="diff-added">+				userId,</div><div class="diff-added">+				userId</div><div> 			)</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.log.debug('Error publishing snapshot', e)</div><div class="diff-added">+			.toArray()</div><div class="diff-added">+			.map((x) => JSON.parse(x.json as string))</div><div class="diff-added">+		const fileStates = this.sql</div><div class="diff-added">+			.exec(`SELECT json FROM file_state WHERE userId = ?`, userId)</div><div class="diff-added">+			.toArray()</div><div class="diff-added">+			.map((x) => JSON.parse(x.json as string))</div><div class="diff-added">+		const user = this.sql</div><div class="diff-added">+			.exec(`SELECT json FROM user WHERE id = ?`, userId)</div><div class="diff-added">+			.toArray()</div><div class="diff-added">+			.map((x) => JSON.parse(x.json as string))[0]</div><div class="diff-added">+		return {</div><div class="diff-added">+			files: files as TlaFile[],</div><div class="diff-added">+			fileStates: fileStates as TlaFileState[],</div><div class="diff-added">+			user: user as TlaUser,</div><div> 		}</div><div> 	}</div><div> </div><div class="diff-removed">-	private async unpublishSnapshot(file: TlaFile) {</div><div class="diff-added">+	async getFileRecord(fileId: string) {</div><div> 		try {</div><div class="diff-removed">-			await this.env.SNAPSHOT_SLUG_TO_PARENT_SLUG.delete(file.publishedSlug)</div><div class="diff-removed">-			await this.env.ROOM_SNAPSHOTS.delete(</div><div class="diff-removed">-				getR2KeyForRoom({ slug: `${file.id}/${file.publishedSlug}`, isApp: true })</div><div class="diff-removed">-			)</div><div class="diff-removed">-		} catch (e) {</div><div class="diff-removed">-			this.log.debug('Error unpublishing snapshot', e)</div><div class="diff-added">+			const { json } = this.sql.exec(`SELECT json FROM file WHERE id = ?`, fileId).one()</div><div class="diff-added">+			return JSON.parse(json as string) as TlaFile</div><div class="diff-added">+		} catch (_e) {</div><div class="diff-added">+			return null</div><div> 		}</div><div> 	}</div><div class="diff-added">+</div><div class="diff-added">+	private getStubForUser(userId: string) {</div><div class="diff-added">+		const id = this.env.TL_USER.idFromName(userId)</div><div class="diff-added">+		return this.env.TL_USER.get(id) as any as TLUserDurableObject</div><div class="diff-added">+	}</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    