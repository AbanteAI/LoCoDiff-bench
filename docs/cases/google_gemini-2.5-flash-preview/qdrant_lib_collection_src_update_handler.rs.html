<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - Gemini 2.5 Flash</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-preview.html">‚Üê Back to Gemini 2.5 Flash Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 77208</p>
                <p><strong>Native Completion Tokens:</strong> 7785</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.0162522</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -1,8 +1,8 @@ use std::cmp::min;</div><div> use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div class="diff-added">+use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> use std::sync::Arc;</div><div class="diff-removed">-use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div> </div><div> use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-info">@@ -154,12 +154,12 @@             optimizers_log,</div><div>             total_optimized_points,</div><div>             optimizer_resource_budget,</div><div class="diff-added">+            flush_interval_sec,</div><div>             flush_worker: None,</div><div>             flush_stop: None,</div><div>             runtime_handle,</div><div>             wal,</div><div>             wal_keep_from: Arc::new(u64::MAX.into()),</div><div class="diff-removed">-            flush_interval_sec,</div><div>             optimization_handles: Arc::new(TokioMutex::new(vec![])),</div><div>             max_optimization_threads,</div><div>             clocks,</div><div class="diff-info">@@ -205,7 +205,7 @@ </div><div>     pub fn stop_flush_worker(&mut self) {</div><div>         if let Some(flush_stop) = self.flush_stop.take() {</div><div class="diff-removed">-            if let Err(()) = flush_stop.send(()) {</div><div class="diff-added">+            if flush_stop.send(()).is_err() {</div><div>                 warn!("Failed to stop flush worker as it is already stopped.");</div><div>             }</div><div>         }</div><div class="diff-info">@@ -229,7 +229,7 @@ </div><div>         let mut opt_handles_guard = self.optimization_handles.lock().await;</div><div>         let opt_handles = std::mem::take(&mut *opt_handles_guard);</div><div class="diff-removed">-        let stopping_handles = opt_handles</div><div class="diff-added">+        let stopping_handles: Vec<_> = opt_handles</div><div>             .into_iter()</div><div>             .filter_map(|h| h.stop())</div><div>             .collect_vec();</div><div class="diff-info">@@ -284,8 +284,8 @@         'outer: for optimizer in optimizers.iter() {</div><div>             loop {</div><div>                 // Return early if we reached the optimization job limit</div><div class="diff-removed">-                if limit.map(|extra| handles.len() >= extra).unwrap_or(false) {</div><div class="diff-removed">-                    log::trace!("Reached optimization job limit, postponing other optimizations");</div><div class="diff-added">+                if limit.is_some_and(|extra| handles.len() >= extra) {</div><div class="diff-added">+                    trace!("Reached optimization job limit, postponing other optimizations");</div><div>                     break 'outer;</div><div>                 }</div><div> </div><div class="diff-info">@@ -340,7 +340,7 @@                     {</div><div>                         let resource_budget = optimizer_resource_budget.clone();</div><div>                         let segments = segments.clone();</div><div class="diff-removed">-                        move |stopped| {</div><div class="diff-added">+                        move |stopped| unsafe { // Unsafety: panics are marked as unsafe and must be handled here</div><div>                             // Track optimizer status</div><div>                             let tracker = Tracker::start(optimizer.as_ref().name(), nsi.clone());</div><div>                             let tracker_handle = tracker.handle();</div><div class="diff-info">@@ -354,7 +354,7 @@                                 resource_budget,</div><div>                                 stopped,</div><div>                             ) {</div><div class="diff-removed">-                                // Perform some actions when optimization if finished</div><div class="diff-added">+                                // Perform somections when optimization if finished</div><div>                                 Ok(optimized_points) => {</div><div>                                     let is_optimized = optimized_points > 0;</div><div>                                     total_optimized_points</div><div class="diff-info">@@ -364,35 +364,25 @@                                     is_optimized</div><div>                                 }</div><div>                                 // Handle and report errors</div><div class="diff-removed">-                                Err(error) => match error {</div><div class="diff-removed">-                                    CollectionError::Cancelled { description } => {</div><div class="diff-removed">-                                        debug!("Optimization cancelled - {description}");</div><div class="diff-removed">-                                        tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Cancelled(description));</div><div class="diff-removed">-                                        false</div><div class="diff-removed">-                                    }</div><div class="diff-removed">-                                    _ => {</div><div class="diff-removed">-                                        segments.write().report_optimizer_error(error.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-                                        // Error of the optimization can not be handled by API user</div><div class="diff-removed">-                                        // It is only possible to fix after full restart,</div><div class="diff-removed">-                                        // so the best available action here is to stop whole</div><div class="diff-removed">-                                        // optimization thread and log the error</div><div class="diff-removed">-                                        log::error!("Optimization error: {error}");</div><div class="diff-removed">-</div><div class="diff-removed">-                                        tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Error(error.to_string()));</div><div class="diff-removed">-</div><div class="diff-removed">-                                        panic!("Optimization error: {error}");</div><div class="diff-removed">-                                    }</div><div class="diff-removed">-                                },</div><div class="diff-added">+                                Err(error) => { // Cannot use match as it is unstable during unwinding</div><div class="diff-added">+                                    let status = match matches!(error, CollectionError::Cancelled { .. }) {</div><div class="diff-added">+                                        true => TrackerStatus::Cancelled(error.to_string()),</div><div class="diff-added">+                                        false => {</div><div class="diff-added">+                                            segments.write().report_optimizer_error(error.clone());</div><div class="diff-added">+                                            TrackerStatus::Error(error.to_string())</div><div class="diff-added">+                                        }</div><div class="diff-added">+                                    };</div><div class="diff-added">+                                    log::error!("Optimization error: {error}");</div><div class="diff-added">+                                    tracker_handle.update(status);</div><div class="diff-added">+                                    panic!("Optimization error: {error}"); // Panics are expected to be caught by handle.join_and_handle_panic()</div><div class="diff-added">+                                }</div><div>                             }</div><div>                         }</div><div>                     },</div><div>                     // Panic handler</div><div>                     Some(Box::new(move |panic_payload| {</div><div>                         let message = panic::downcast_str(&panic_payload).unwrap_or("");</div><div class="diff-removed">-                        let separator = if !message.is_empty() { ": " } else { "" };</div><div class="diff-added">+                        let separator = if message.is_empty() { "" } else { ": " };</div><div> </div><div>                         warn!(</div><div>                             "Optimization task panicked, collection may be in unstable state\</div><div class="diff-info">@@ -477,7 +467,6 @@         (has_triggered_any_optimizers, has_suboptimal_optimizers)</div><div>     }</div><div> </div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div>     pub(crate) async fn process_optimization(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>         segments: LockedSegmentHolder,</div><div class="diff-info">@@ -507,39 +496,6 @@         handles.append(&mut new_handles);</div><div>     }</div><div> </div><div class="diff-removed">-    /// Cleanup finalized optimization task handles</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This finds and removes completed tasks from our list of optimization handles.</div><div class="diff-removed">-    /// It also propagates any panics (and unknown errors) so we properly handle them if desired.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It is essential to call this every once in a while for handling panics in time.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns true if any optimization handle was finished, joined and removed.</div><div class="diff-removed">-    async fn cleanup_optimization_handles(</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    ) -> bool {</div><div class="diff-removed">-        // Remove finished handles</div><div class="diff-removed">-        let finished_handles: Vec<_> = {</div><div class="diff-removed">-            let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-            (0..handles.len())</div><div class="diff-removed">-                .filter(|i| handles[*i].is_finished())</div><div class="diff-removed">-                .collect::<Vec<_>>()</div><div class="diff-removed">-                .into_iter()</div><div class="diff-removed">-                .rev()</div><div class="diff-removed">-                .map(|i| handles.swap_remove(i))</div><div class="diff-removed">-                .collect()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let finished_any = !finished_handles.is_empty();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Finalize all finished handles to propagate panics</div><div class="diff-removed">-        for handle in finished_handles {</div><div class="diff-removed">-            handle.join_and_handle_panic().await;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        finished_any</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     async fn optimization_worker_fn(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-info">@@ -558,8 +514,7 @@         let max_handles = max_handles.unwrap_or(usize::MAX);</div><div>         let max_indexing_threads = optimizers</div><div>             .first()</div><div class="diff-removed">-            .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div class="diff-removed">-            .unwrap_or_default();</div><div class="diff-added">+            .map_or(0, |optimizer| optimizer.hnsw_config().max_indexing_threads);</div><div> </div><div>         // Asynchronous task to trigger optimizers once CPU budget is available again</div><div>         let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div class="diff-info">@@ -701,13 +656,10 @@                         Ok(())</div><div>                     };</div><div> </div><div class="diff-added">+                    let hw_counter = hw_measurements.get_counter_cell();</div><div class="diff-added">+</div><div>                     let operation_result = flush_res.and_then(|_| {</div><div class="diff-removed">-                        CollectionUpdater::update(</div><div class="diff-removed">-                            &segments,</div><div class="diff-removed">-                            op_num,</div><div class="diff-removed">-                            operation,</div><div class="diff-removed">-                            &hw_measurements.get_counter_cell(),</div><div class="diff-removed">-                        )</div><div class="diff-added">+                        CollectionUpdater::update(&segments, op_num, operation, &hw_counter)</div><div>                     });</div><div> </div><div>                     let res = match operation_result {</div><div class="diff-info">@@ -797,6 +749,7 @@                 }</div><div>             };</div><div> </div><div class="diff-added">+</div><div>             // Acknowledge confirmed version in WAL, but don't acknowledge the specified</div><div>             // `keep_from` index or higher.</div><div>             // This is to prevent truncating WAL entries that other bits of code still depend on</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    