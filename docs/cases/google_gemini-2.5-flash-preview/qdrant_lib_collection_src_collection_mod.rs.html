<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - Gemini 2.5 Flash</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-preview.html">‚Üê Back to Gemini 2.5 Flash Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 73338</p>
                <p><strong>Native Completion Tokens:</strong> 8898</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.0163395</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b..b1632b32 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmp08ia1cic_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmp929y5l6t_actual.txt	</div><div class="diff-info">@@ -3,7 +3,6 @@ mod collection_ops;</div><div> pub mod distance_matrix;</div><div> mod facet;</div><div> pub mod payload_index_schema;</div><div class="diff-removed">-mod point_ops;</div><div> pub mod query;</div><div> mod resharding;</div><div> mod search;</div><div class="diff-info">@@ -20,6 +19,10 @@ use std::time::Duration;</div><div> </div><div> use clean::ShardCleanTasks;</div><div> use common::budget::ResourceBudget;</div><div class="diff-added">+use common::collection_size_stats::{</div><div class="diff-added">+    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-added">+};</div><div class="diff-added">+use common::is_ready::IsReady;</div><div> use common::types::{DetailsLevel, TelemetryDetail};</div><div> use io::storage_version::StorageVersion;</div><div> use segment::types::ShardKey;</div><div class="diff-info">@@ -29,10 +32,6 @@ use tokio::sync::{Mutex, RwLock, RwLockWriteGuard};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_state::{ShardInfo, State};</div><div class="diff-removed">-use crate::common::collection_size_stats::{</div><div class="diff-removed">-    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-removed">-};</div><div class="diff-removed">-use crate::common::is_ready::IsReady;</div><div> use crate::config::CollectionConfigInternal;</div><div> use crate::operations::config_diff::{DiffConfig, OptimizersConfigDiff};</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div class="diff-info">@@ -76,7 +75,7 @@ pub struct Collection {</div><div>     init_time: Duration,</div><div>     // One-way boolean flag that is set to true when the collection is fully initialized</div><div>     // i.e. all shards are activated for the first time.</div><div class="diff-removed">-    is_initialized: Arc<IsReady>,</div><div class="diff-added">+    is_initialized: IsReady,</div><div>     // Lock to temporary block collection update operations while the collection is being migrated.</div><div>     // Lock is acquired for read on update operation and can be acquired for write externally,</div><div>     // which will block all update operations until the lock is released.</div><div class="diff-info">@@ -155,7 +154,6 @@ impl Collection {</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 optimizer_resource_budget.clone(),</div><div class="diff-removed">-                None,</div><div>             )</div><div>             .await?;</div><div> </div><div class="diff-info">@@ -183,10 +181,10 @@ impl Collection {</div><div>             path: path.to_owned(),</div><div>             snapshots_path: snapshots_path.to_owned(),</div><div>             channel_service,</div><div class="diff-removed">-            transfer_tasks: Mutex::new(TransferTasksPool::new(name.clone())),</div><div class="diff-added">+            transfer_tasks: Mutex::new(TransferTasksPool::new(name)),</div><div>             request_shard_transfer_cb: request_shard_transfer.clone(),</div><div>             notify_peer_failure_cb: on_replica_failure.clone(),</div><div class="diff-removed">-            abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-added">+            abort_shard_transfer_cb: abort_shard_transfer.clone(),</div><div>             init_time: start_time.elapsed(),</div><div>             is_initialized: Default::default(),</div><div>             updates_lock: Default::default(),</div><div class="diff-info">@@ -267,7 +265,7 @@ impl Collection {</div><div>         shard_holder</div><div>             .load_shards(</div><div>                 path,</div><div class="diff-removed">-                &collection_id,</div><div class="diff-added">+                collection_id.clone(),</div><div>                 shared_collection_config.clone(),</div><div>                 effective_optimizers_config,</div><div>                 shared_storage_config.clone(),</div><div class="diff-info">@@ -314,27 +312,19 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Check if stored version have consequent version.</div><div class="diff-removed">-    /// If major version is different, then it is not compatible.</div><div class="diff-removed">-    /// If the difference in consecutive versions is greater than 1 in patch,</div><div class="diff-removed">-    /// then the collection is not compatible with the current version.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Example:</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.1 = true</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.2 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.0 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.1 = false</div><div class="diff-removed">-    pub fn can_upgrade_storage(stored: &Version, app: &Version) -> bool {</div><div class="diff-removed">-        if stored.major != app.major {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.minor != app.minor {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.patch + 1 < app.patch {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        true</div><div class="diff-added">+    pub async fn start(&self) -> Result<(), CollectionError> {</div><div class="diff-added">+        let shards_holder = self.shards_holder.read().await.clone();</div><div class="diff-added">+        shards_holder.start().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn restart(&self) -> CollectionResult<()> {</div><div class="diff-added">+        let shards_holder = self.shards_holder.read().await.clone();</div><div class="diff-added">+        shards_holder.restart().await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub async fn before_drop(&self) {</div><div class="diff-added">+        self.shards_holder.read().await.before_drop().await;</div><div class="diff-added">+        self.shard_clean_tasks.abort_all().await;</div><div>     }</div><div> </div><div>     pub fn name(&self) -> String {</div><div class="diff-info">@@ -345,14 +335,12 @@ impl Collection {</div><div>         self.collection_config.read().await.uuid</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn get_shard_keys(&self) -> Vec<ShardKey> {</div><div class="diff-added">+    pub async fn get_shard_keys(&self) -> impl Iterator<Item = ShardKey> + '_ {</div><div>         self.shards_holder</div><div>             .read()</div><div>             .await</div><div>             .get_shard_key_to_ids_mapping()</div><div>             .keys()</div><div class="diff-removed">-            .cloned()</div><div class="diff-removed">-            .collect()</div><div>     }</div><div> </div><div>     /// Return a list of local shards, present on this peer</div><div class="diff-info">@@ -438,6 +426,39 @@ impl Collection {</div><div>             )));</div><div>         }</div><div> </div><div class="diff-added">+        if new_state == ReplicaState::Dead {</div><div class="diff-added">+            // Abort resharding, if resharding shard is marked as `Dead`.</div><div class="diff-added">+            //</div><div class="diff-added">+            // This branch should only be triggered, if resharding is currently at `MigratingPoints`</div><div class="diff-added">+            // stage, because target shard should be marked as `Active`, when all resharding transfers</div><div class="diff-added">+            // are successfully completed, and so the check *right above* this one would be triggered.</div><div class="diff-added">+            //</div><div class="diff-added">+            // So, if resharding reached `ReadHashRingCommitted`, this branch *won't* be triggered,</div><div class="diff-added">+            // and resharding *won't* be cancelled. The update request should *fail* with "failed to</div><div class="diff-added">+            // update all replicas of a shard" error.</div><div class="diff-added">+            //</div><div class="diff-added">+            // If resharding reached `ReadHashRingCommitted`, and this branch is triggered *somehow*,</div><div class="diff-added">+            // then `Collection::abort_resharding` call should return an error, so no special handling</div><div class="diff-added">+            // is needed.</div><div class="diff-added">+            let is_resharding = current_state</div><div class="diff-added">+                .as_ref()</div><div class="diff-added">+                .is_some_and(ReplicaState::is_resharding);</div><div class="diff-added">+            if is_resharding && new_state == ReplicaState::Dead {</div><div class="diff-added">+                drop(shard_holder);</div><div class="diff-added">+</div><div class="diff-added">+                let resharding_state = self</div><div class="diff-added">+                    .resharding_state()</div><div class="diff-added">+                    .await</div><div class="diff-added">+                    .filter(|state| state.peer_id == peer_id);</div><div class="diff-added">+</div><div class="diff-added">+                if let Some(state) = resharding_state {</div><div class="diff-added">+                    self.abort_resharding(state.key(), false).await?;</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+                return Ok(());</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div>         // Update replica status</div><div>         replica_set</div><div>             .ensure_replica_with_state(peer_id, new_state)</div><div class="diff-info">@@ -508,37 +529,8 @@ impl Collection {</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn shard_recovery_point(&self, shard_id: ShardId) -> CollectionResult<RecoveryPoint> {</div><div class="diff-removed">-        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-removed">-        let Some(replica_set) = shard else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        replica_set.shard_recovery_point().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn update_shard_cutoff_point(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        shard_id: ShardId,</div><div class="diff-removed">-        cutoff: &RecoveryPoint,</div><div class="diff-removed">-    ) -> CollectionResult<()> {</div><div class="diff-removed">-        let shard_holder_read = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let shard = shard_holder_read.get_shard(shard_id);</div><div class="diff-removed">-        let Some(replica_set) = shard else {</div><div class="diff-removed">-            return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("Shard {shard_id}"),</div><div class="diff-removed">-            });</div><div class="diff-removed">-        };</div><div> </div><div class="diff-removed">-        replica_set.update_shard_cutoff_point(cutoff).await</div><div class="diff-added">+        Ok(())</div><div>     }</div><div> </div><div>     pub async fn state(&self) -> State {</div><div class="diff-info">@@ -563,6 +555,15 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-added">+    pub async fn apply_state(</div><div class="diff-added">+        &self,</div><div class="diff-added">+        state: State,</div><div class="diff-added">+        this_peer_id: PeerId,</div><div class="diff-added">+        abort_transfer: impl FnMut(ShardTransfer),</div><div class="diff-added">+    ) -> CollectionResult<()> {</div><div class="diff-added">+        state.apply(this_peer_id, self, abort_transfer).await</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div>         // Abort resharding, if shards are removed from peer driving resharding</div><div>         // (which *usually* means the *peer* is being removed from consensus)</div><div class="diff-info">@@ -612,7 +613,7 @@ impl Collection {</div><div>         let tasks_lock = self.transfer_tasks.lock().await;</div><div>         for transfer in outgoing_transfers {</div><div>             match tasks_lock</div><div class="diff-removed">-                .get_task_status(&transfer.key())</div><div class="diff-added">+                .get_task_status(transfer.key())</div><div>                 .map(|s| s.result)</div><div>             {</div><div>                 None => {</div><div class="diff-info">@@ -838,16 +839,6 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div>         self.updates_lock.write().await</div><div>     }</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    