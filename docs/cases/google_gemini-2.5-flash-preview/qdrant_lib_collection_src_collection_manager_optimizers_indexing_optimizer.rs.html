<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs - Gemini 2.5 Flash</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/optimizers/indexing_optimizer.rs</h1>
        <h2>Model: Gemini 2.5 Flash</h2>
        <p><a href="../../models/google_gemini-2.5-flash-preview.html">All Gemini 2.5 Flash Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58760</p>
                <p><strong>Native Prompt Tokens:</strong> 74953</p>
                <p><strong>Native Completion Tokens:</strong> 9490</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.01693695</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 237415b4..f376bbed 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_expectedoutput.txt (expected):tmp/tmpb3gqcwcj_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_optimizers_indexing_optimizer.rs_extracted.txt (actual):tmp/tmpzzufcbxa_actual.txt	</div><div class="diff-info">@@ -2,6 +2,8 @@ use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div> use std::sync::Arc;</div><div> </div><div class="diff-added">+use common::budget::ResourceBudget;</div><div class="diff-added">+use common::counter::hardware_counter::HardwareCounterCell;</div><div> use parking_lot::Mutex;</div><div> use segment::common::operation_time_statistics::OperationDurationsAggregator;</div><div> use segment::types::{HnswConfig, QuantizationConfig, SegmentType};</div><div class="diff-info">@@ -33,6 +35,7 @@ pub struct IndexingOptimizer {</div><div> }</div><div> </div><div> impl IndexingOptimizer {</div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div>     pub fn new(</div><div>         default_segments_number: usize,</div><div>         thresholds_config: OptimizerThresholds,</div><div class="diff-info">@@ -54,6 +57,7 @@ impl IndexingOptimizer {</div><div>         }</div><div>     }</div><div> </div><div class="diff-added">+    #[cfg(test)]</div><div>     fn smallest_indexed_segment(</div><div>         segments: &SegmentHolder,</div><div>         excluded_ids: &HashSet<SegmentId>,</div><div class="diff-info">@@ -81,7 +85,7 @@ impl IndexingOptimizer {</div><div>                     return None;</div><div>                 }</div><div> </div><div class="diff-removed">-                Some((idx, vector_size))</div><div class="diff-added">+                Some((*idx, vector_size))</div><div>             })</div><div>             .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes)</div><div>             .map(|(idx, size)| (*idx, size))</div><div class="diff-info">@@ -100,16 +104,17 @@ impl IndexingOptimizer {</div><div>             .filter_map(|(idx, segment)| {</div><div>                 let segment_entry = segment.get();</div><div>                 let read_segment = segment_entry.read();</div><div class="diff-added">+                let point_count = read_segment.available_point_count();</div><div>                 let max_vector_size_bytes = read_segment</div><div>                     .max_available_vectors_size_in_bytes()</div><div>                     .unwrap_or_default();</div><div> </div><div class="diff-removed">-                let segment_config = read_segment.config();</div><div class="diff-removed">-</div><div>                 if read_segment.segment_type() == SegmentType::Special {</div><div>                     return None; // Never optimize already optimized segment</div><div>                 }</div><div> </div><div class="diff-added">+                let segment_config = read_segment.config();</div><div class="diff-added">+</div><div>                 let indexing_threshold_bytes = self</div><div>                     .thresholds_config</div><div>                     .indexing_threshold_kb</div><div class="diff-info">@@ -132,8 +137,7 @@ impl IndexingOptimizer {</div><div>                         let is_big_for_mmap = storage_size_bytes >= mmap_threshold_bytes;</div><div> </div><div>                         let optimize_for_index = is_big_for_index && !is_indexed;</div><div class="diff-removed">-                        let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk</div><div class="diff-removed">-                        {</div><div class="diff-added">+                        let optimize_for_mmap = if let Some(on_disk_config) = vector_config.on_disk {</div><div>                             on_disk_config && !is_on_disk</div><div>                         } else {</div><div>                             is_big_for_mmap && !is_on_disk</div><div class="diff-info">@@ -175,6 +179,7 @@ impl IndexingOptimizer {</div><div>                     }</div><div>                 }</div><div> </div><div class="diff-added">+</div><div>                 require_optimization.then_some((*idx, max_vector_size_bytes))</div><div>             })</div><div>             .collect();</div><div class="diff-info">@@ -183,10 +188,9 @@ impl IndexingOptimizer {</div><div>         let selected_segment = candidates</div><div>             .iter()</div><div>             .max_by_key(|(_, vector_size_bytes)| *vector_size_bytes);</div><div class="diff-removed">-        if selected_segment.is_none() {</div><div class="diff-added">+        let Some((selected_segment_id, selected_segment_size)) = selected_segment else {</div><div>             return vec![];</div><div class="diff-removed">-        }</div><div class="diff-removed">-        let (selected_segment_id, selected_segment_size) = *selected_segment.unwrap();</div><div class="diff-added">+        };</div><div> </div><div>         let number_of_segments = segments_read_guard.len();</div><div> </div><div class="diff-info">@@ -194,7 +198,7 @@ impl IndexingOptimizer {</div><div>         // We want to make sure that we at least do not increase number of segments after optimization, thus we take more than one segment to optimize</div><div> </div><div>         if number_of_segments < self.default_segments_number {</div><div class="diff-removed">-            return vec![selected_segment_id];</div><div class="diff-added">+            return vec![*selected_segment_id];</div><div>         }</div><div> </div><div>         // It is better for scheduling if indexing optimizer optimizes 2 segments.</div><div class="diff-info">@@ -206,39 +210,42 @@ impl IndexingOptimizer {</div><div>             .iter()</div><div>             .min_by_key(|(_, vector_size_bytes)| *vector_size_bytes);</div><div>         if let Some((idx, size)) = smallest_unindexed {</div><div class="diff-removed">-            if *idx != selected_segment_id</div><div class="diff-added">+            if *idx != *selected_segment_id</div><div>                 && selected_segment_size + size</div><div>                     < self</div><div>                         .thresholds_config</div><div>                         .max_segment_size_kb</div><div>                         .saturating_mul(BYTES_IN_KB)</div><div>             {</div><div class="diff-removed">-                return vec![selected_segment_id, *idx];</div><div class="diff-added">+                return vec![*selected_segment_id, *idx];</div><div>             }</div><div>         }</div><div> </div><div>         // Find smallest indexed to check if we can reindex together</div><div class="diff-added">+        #[cfg(test)]</div><div>         let smallest_indexed = Self::smallest_indexed_segment(&segments_read_guard, excluded_ids);</div><div class="diff-added">+        #[cfg(not(test))]</div><div class="diff-added">+        let smallest_indexed = self.smallest_indexed_segment(&segments_read_guard, excluded_ids);</div><div class="diff-added">+</div><div class="diff-added">+</div><div>         if let Some((idx, size)) = smallest_indexed {</div><div class="diff-removed">-            if idx != selected_segment_id</div><div class="diff-added">+            if idx != *selected_segment_id</div><div>                 && selected_segment_size + size</div><div>                     < self</div><div>                         .thresholds_config</div><div>                         .max_segment_size_kb</div><div>                         .saturating_mul(BYTES_IN_KB)</div><div>             {</div><div class="diff-removed">-                return vec![selected_segment_id, idx];</div><div class="diff-added">+                return vec![*selected_segment_id, idx];</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        vec![selected_segment_id]</div><div class="diff-added">+        vec![*selected_segment_id]</div><div>     }</div><div> }</div><div> </div><div> impl SegmentOptimizer for IndexingOptimizer {</div><div class="diff-removed">-    fn name(&self) -> &str {</div><div class="diff-removed">-        "indexing"</div><div class="diff-removed">-    }</div><div class="diff-added">+    const NAME: &'static str = "indexing";</div><div> </div><div>     fn segments_path(&self) -> &Path {</div><div>         self.segments_path.as_path()</div><div class="diff-info">@@ -281,8 +288,8 @@ impl SegmentOptimizer for IndexingOptimizer {</div><div> mod tests {</div><div>     use std::collections::BTreeMap;</div><div>     use std::ops::Deref;</div><div class="diff-removed">-    use std::sync::Arc;</div><div>     use std::sync::atomic::AtomicBool;</div><div class="diff-added">+    use std::sync::Arc;</div><div> </div><div>     use common::budget::ResourceBudget;</div><div>     use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-info">@@ -343,7 +350,7 @@ mod tests {</div><div>         let vectors_config: BTreeMap<VectorNameBuf, VectorParams> = segment_config</div><div>             .vector_data</div><div>             .iter()</div><div class="diff-removed">-            .map(|(name, params)| {</div><div class="diff-added">+            .map(|name, params| {</div><div>                 (</div><div>                     name.to_owned(),</div><div>                     VectorParamsBuilder::new(params.size as u64, params.distance).build(),</div><div class="diff-info">@@ -399,12 +406,12 @@ mod tests {</div><div>         let infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().info())</div><div>             .collect_vec();</div><div>         let configs = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().config().clone())</div><div>             .collect_vec();</div><div> </div><div>         assert_eq!(infos.len(), 2);</div><div class="diff-info">@@ -527,13 +534,13 @@ mod tests {</div><div> </div><div>         let permit_cpu_count = num_rayon_threads(0);</div><div>         let budget = ResourceBudget::new(permit_cpu_count, permit_cpu_count);</div><div class="diff-removed">-        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div> </div><div>         // ------ Plain -> Mmap & Indexed payload</div><div>         let suggested_to_optimize =</div><div>             index_optimizer.check_condition(locked_holder.clone(), &excluded_ids);</div><div>         assert!(suggested_to_optimize.contains(&large_segment_id));</div><div>         eprintln!("suggested_to_optimize = {suggested_to_optimize:#?}");</div><div class="diff-added">+        let permit = budget.try_acquire(0, permit_cpu_count).unwrap();</div><div>         index_optimizer</div><div>             .optimize(</div><div>                 locked_holder.clone(),</div><div class="diff-info">@@ -567,19 +574,19 @@ mod tests {</div><div> </div><div>         assert_eq!(</div><div>             locked_holder.read().len(),</div><div class="diff-removed">-            3,</div><div class="diff-added">+            4,</div><div>             "Testing no new segments were created"</div><div>         );</div><div> </div><div>         let infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().info())</div><div>             .collect_vec();</div><div>         let configs = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().config().clone())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().config().clone())</div><div>             .collect_vec();</div><div> </div><div>         let indexed_count = infos</div><div class="diff-info">@@ -587,16 +594,13 @@ mod tests {</div><div>             .filter(|info| info.segment_type == SegmentType::Indexed)</div><div>             .count();</div><div>         assert_eq!(</div><div class="diff-removed">-            indexed_count, 2,</div><div class="diff-added">+            indexed_count, 3,</div><div>             "Testing that 2 segments are actually indexed"</div><div>         );</div><div> </div><div class="diff-removed">-        let on_disk_count = configs</div><div class="diff-removed">-            .iter()</div><div class="diff-removed">-            .filter(|config| config.is_any_on_disk())</div><div class="diff-removed">-            .count();</div><div class="diff-added">+        let on_disk_count = configs.iter().filter(|config| config.is_any_on_disk()).count();</div><div>         assert_eq!(</div><div class="diff-removed">-            on_disk_count, 1,</div><div class="diff-added">+            on_disk_count, 3,</div><div>             "Testing that only largest segment is not Mmap"</div><div>         );</div><div> </div><div class="diff-info">@@ -657,7 +661,7 @@ mod tests {</div><div>         let new_infos = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().info())</div><div>             .collect_vec();</div><div>         let new_smallest_size = new_infos</div><div>             .iter()</div><div class="diff-info">@@ -692,7 +696,7 @@ mod tests {</div><div>         let new_infos2 = locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_sid, segment)| segment.get().read().info())</div><div class="diff-added">+            .map(|_sid, segment| segment.get().read().info())</div><div>             .collect_vec();</div><div> </div><div>         let mut has_empty = false;</div><div class="diff-info">@@ -718,6 +722,8 @@ mod tests {</div><div>         let insert_point_ops =</div><div>             PointOperations::UpsertPoints(PointInsertOperationsInternal::from(batch));</div><div> </div><div class="diff-added">+        let hw_counter = HardwareCounterCell::new();</div><div class="diff-added">+</div><div>         process_point_operation(</div><div>             locked_holder.deref(),</div><div>             opnum.next().unwrap(),</div><div class="diff-info">@@ -825,7 +831,7 @@ mod tests {</div><div>     ///</div><div>     /// It tests whether:</div><div>     /// - the on_disk flag is preferred over memmap_threshold</div><div class="diff-removed">-    /// - the index optimizer and config mismatch optimizer don't conflict with this preference</div><div class="diff-added">+    /// - the index optimizer and config mismatch optimizer dont conflict with this preference</div><div>     /// - there is no infinite optiization loop with the above configuration</div><div>     ///</div><div>     /// In short, this is what happens in this test:</div><div class="diff-info">@@ -915,9 +921,9 @@ mod tests {</div><div>             locked_holder</div><div>                 .read()</div><div>                 .iter()</div><div class="diff-removed">-                .map(|(_, segment)| match segment {</div><div class="diff-added">+                .map(|_sid, segment| match segment {</div><div>                     LockedSegment::Original(s) => s.read(),</div><div class="diff-removed">-                    LockedSegment::Proxy(_) => unreachable!(),</div><div class="diff-added">+                    LockedSegment::Proxy(_proxy) => unreachable!(), // not expected in this test</div><div>                 })</div><div>                 .filter(|segment| segment.total_point_count() > 0)</div><div>                 .for_each(|segment| {</div><div class="diff-info">@@ -953,7 +959,7 @@ mod tests {</div><div>             dir.path().to_owned(),</div><div>             temp_dir.path().to_owned(),</div><div>             collection_params,</div><div class="diff-removed">-            hnsw_config,</div><div class="diff-added">+            hnsw_config.clone(),</div><div>             Default::default(),</div><div>         );</div><div> </div><div class="diff-info">@@ -990,7 +996,7 @@ mod tests {</div><div>         locked_holder</div><div>             .read()</div><div>             .iter()</div><div class="diff-removed">-            .map(|(_, segment)| match segment {</div><div class="diff-added">+            .map(|_sid, segment| match segment {</div><div>                 LockedSegment::Original(s) => s.read(),</div><div>                 LockedSegment::Proxy(_) => unreachable!(),</div><div>             })</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    