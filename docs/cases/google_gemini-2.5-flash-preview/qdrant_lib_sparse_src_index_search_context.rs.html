<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/sparse/src/index/search_context.rs - Gemini 2.5 Flash</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/sparse/src/index/search_context.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-preview.html">‚Üê Back to Gemini 2.5 Flash Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 73797</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 91332</p>
                <p><strong>Native Completion Tokens:</strong> 12502</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.021201</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_sparse_src_index_search_context.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_sparse_src_index_search_context.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_sparse_src_index_search_context.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8be5822c..3b70fff5 100644</div><div class="diff-header">--- a/qdrant_lib_sparse_src_index_search_context.rs_expectedoutput.txt (expected):tmp/tmpyjpdp98t_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_sparse_src_index_search_context.rs_extracted.txt (actual):tmp/tmprnsd1r0e_actual.txt	</div><div class="diff-info">@@ -1,4 +1,5 @@</div><div class="diff-removed">-use std::cmp::{Ordering, max, min};</div><div class="diff-added">+use std::cmp::{max, min, Ordering};</div><div class="diff-added">+use std::mem::size_of;</div><div> use std::sync::atomic::AtomicBool;</div><div> use std::sync::atomic::Ordering::Relaxed;</div><div> </div><div class="diff-info">@@ -8,7 +9,7 @@ use common::types::{PointOffsetType, ScoredPointOffset};</div><div> </div><div> use super::posting_list_common::PostingListIter;</div><div> use crate::common::scores_memory_pool::PooledScoresHandle;</div><div class="diff-removed">-use crate::common::sparse_vector::{RemappedSparseVector, score_vectors};</div><div class="diff-added">+use crate::common::sparse_vector::{score_vectors, RemappedSparseVector};</div><div> use crate::common::types::{DimId, DimWeight};</div><div> use crate::index::inverted_index::InvertedIndex;</div><div> use crate::index::posting_list::PostingListIterator;</div><div class="diff-info">@@ -93,10 +94,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    const DEFAULT_SCORE: f32 = 0.0;</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Plain search against the given ids without any pruning</div><div class="diff-removed">-    pub fn plain_search(&mut self, ids: &[PointOffsetType]) -> Vec<ScoredPointOffset> {</div><div class="diff-added">+    fn plain_search(&mut self, ids: &[PointOffsetType]) -> Vec<ScoredPointOffset> {</div><div>         // sort ids to fully leverage posting list iterator traversal</div><div>         let mut sorted_ids = ids.to_vec();</div><div>         sorted_ids.sort_unstable();</div><div class="diff-info">@@ -149,7 +147,13 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         top.into_vec()</div><div>     }</div><div> </div><div class="diff-added">+    const DEFAULT_SCORE: f32 = 0.0;</div><div class="diff-added">+</div><div>     /// Advance posting lists iterators in a batch fashion.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// For a given batch range [batch_start_id, batch_last_id], this method iterates over</div><div class="diff-added">+    /// all posting lists and accumulates the scores for each record id in the batch.</div><div class="diff-added">+    /// It then publishes the non-zero scores above the current min score to the result queue.</div><div>     fn advance_batch<F: Fn(PointOffsetType) -> bool>(</div><div>         &mut self,</div><div>         batch_start_id: PointOffsetType,</div><div class="diff-info">@@ -159,7 +163,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         // init batch scores</div><div>         let batch_len = batch_last_id - batch_start_id + 1;</div><div>         self.pooled.scores.clear(); // keep underlying allocated memory</div><div class="diff-removed">-        self.pooled.scores.resize(batch_len as usize, 0.0);</div><div class="diff-added">+        self.pooled.scores.resize(batch_len as usize, Self::DEFAULT_SCORE);</div><div> </div><div>         for posting in self.postings_iterators.iter_mut() {</div><div>             posting.posting_list_iterator.for_each_till_id(</div><div class="diff-info">@@ -178,7 +182,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div> </div><div>         for (local_index, &score) in self.pooled.scores.iter().enumerate() {</div><div>             // publish only the non-zero scores above the current min to beat</div><div class="diff-removed">-            if score != 0.0 && score > self.top_results.threshold() {</div><div class="diff-added">+            if score != Self::DEFAULT_SCORE && score > self.top_results.threshold() {</div><div>                 let real_id = batch_start_id + local_index as PointOffsetType;</div><div>                 // do not score if filter condition is not satisfied</div><div>                 if !filter_condition(real_id) {</div><div class="diff-info">@@ -279,13 +283,14 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>             // Measure CPU usage of indexed sparse search.</div><div>             // Assume the complexity of the search as total volume of the posting lists</div><div>             // that are traversed in the batched search.</div><div class="diff-added">+            let cpu_counter = self.hardware_counter.cpu_counter();</div><div>             let mut cpu_cost = 0;</div><div> </div><div>             for posting in self.postings_iterators.iter() {</div><div>                 cpu_cost += posting.posting_list_iterator.len_to_end()</div><div>                     * posting.posting_list_iterator.element_size();</div><div>             }</div><div class="diff-removed">-            self.hardware_counter.cpu_counter().incr_delta(cpu_cost);</div><div class="diff-added">+            cpu_counter.incr_delta(cpu_cost);</div><div>         }</div><div> </div><div>         let mut best_min_score = f32::MIN;</div><div class="diff-info">@@ -311,7 +316,7 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div> </div><div>             // remove empty posting lists if necessary</div><div>             self.postings_iterators.retain(|posting_iterator| {</div><div class="diff-removed">-                posting_iterator.posting_list_iterator.len_to_end() != 0</div><div class="diff-added">+                !posting_iterator.posting_list_iterator.is_empty()</div><div>             });</div><div> </div><div>             // update min_record_id</div><div class="diff-info">@@ -350,8 +355,8 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>             }</div><div>         }</div><div>         // posting iterators exhausted, return result queue</div><div class="diff-removed">-        let queue = std::mem::take(&mut self.top_results);</div><div class="diff-removed">-        queue.into_vec()</div><div class="diff-added">+        let top = std::mem::take(&mut self.top_results);</div><div class="diff-added">+        top.into_vec()</div><div>     }</div><div> </div><div>     /// Prune posting lists that cannot possibly contribute to the top results</div><div class="diff-info">@@ -419,4 +424,733 @@ impl<'a, 'b, T: PostingListIter> SearchContext<'a, 'b, T> {</div><div>         // no pruning took place</div><div>         false</div><div>     }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+#[cfg(test)]</div><div class="diff-added">+#[generic_tests::define]</div><div class="diff-added">+mod tests {</div><div class="diff-added">+    use std::any::TypeId;</div><div class="diff-added">+    use std::borrow::Cow;</div><div class="diff-added">+    use std::mem::size_of;</div><div class="diff-added">+    use std::sync::OnceLock;</div><div class="diff-added">+</div><div class="diff-added">+    use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-added">+    use rand::Rng;</div><div class="diff-added">+    use tempfile::TempDir;</div><div class="diff-added">+</div><div class="diff-added">+    use super::*;</div><div class="diff-added">+    use crate::common::scores_memory_pool::ScoresMemoryPool;</div><div class="diff-added">+    use crate::common::sparse_vector::SparseVector;</div><div class="diff-added">+    use crate::common::sparse_vector_fixture::random_sparse_vector;</div><div class="diff-added">+    use crate::common::types::QuantizedU8;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_immutable_ram::InvertedIndexCompressedImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_compressed_mmap::InvertedIndexCompressedMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_immutable_ram::InvertedIndexImmutableRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_mmap::InvertedIndexMmap;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram::InvertedIndexRam;</div><div class="diff-added">+    use crate::index::inverted_index::inverted_index_ram_builder::InvertedIndexBuilder;</div><div class="diff-added">+</div><div class="diff-added">+    // ---- Test instantiations ----</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexRam>)]</div><div class="diff-added">+    mod ram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexMmap>)]</div><div class="diff-added">+    mod mmap {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexImmutableRam>)]</div><div class="diff-added">+    mod iram {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedImmutableRam<f32>>)]</div><div class="diff-added">+    mod iram_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(</div><div class="diff-added">+        <InvertedIndexCompressedImmutableRam<half::f16>> // requires `max_next_weight`</div><div class="diff-added">+    )]</div><div class="diff-added">+    mod iram_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(</div><div class="diff-added">+        <InvertedIndexCompressedImmutableRam<u8>> // requires `max_next_weight`</div><div class="diff-added">+    )]</div><div class="diff-added">+    mod iram_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(</div><div class="diff-added">+        <InvertedIndexCompressedImmutableRam<QuantizedU8>> // requires `max_next_weight`</div><div class="diff-added">+    )]</div><div class="diff-added">+    mod iram_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<f32>>)]</div><div class="diff-added">+    mod mmap_f32 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(</div><div class="diff-added">+        <InvertedIndexCompressedMmap<half::f16>> // requires `max_next_weight`</div><div class="diff-added">+    )]</div><div class="diff-added">+    mod mmap_f16 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(<InvertedIndexCompressedMmap<u8>>)] // requires `max_next_weight`</div><div class="diff-added">+    mod mmap_u8 {}</div><div class="diff-added">+</div><div class="diff-added">+    #[instantiate_tests(</div><div class="diff-added">+        <InvertedIndexCompressedMmap<QuantizedU8>> // requires `max_next_weight`</div><div class="diff-added">+    )]</div><div class="diff-added">+    mod mmap_q8 {}</div><div class="diff-added">+</div><div class="diff-added">+    // --- End of test instantiations ---</div><div class="diff-added">+</div><div class="diff-added">+    static TEST_SCORES_POOL: OnceLock<ScoresMemoryPool> =</div><div class="diff-added">+        OnceLock::new();</div><div class="diff-added">+</div><div class="diff-added">+    fn get_pooled_scores() -> PooledScoresHandle<'static> {</div><div class="diff-added">+        TEST_SCORES_POOL</div><div class="diff-added">+            .get_or_init(ScoresMemoryPool::default)</div><div class="diff-added">+            .get()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Match all filter condition for testing</div><div class="diff-added">+    fn match_all(_p: PointOffsetType) -> bool {</div><div class="diff-added">+        true</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Helper struct to store both an index and a temporary directory</div><div class="diff-added">+    struct TestIndex<I: InvertedIndex> {</div><div class="diff-added">+        index: I,</div><div class="diff-added">+        _temp_dir: TempDir,</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    impl<I: InvertedIndex> TestIndex<I> {</div><div class="diff-added">+        fn from_ram(ram_index: InvertedIndexRam) -> Self {</div><div class="diff-added">+            let temp_dir = tempfile::Builder::new()</div><div class="diff-added">+                .prefix("test_index_dir")</div><div class="diff-added">+                .tempdir()</div><div class="diff-added">+                .unwrap();</div><div class="diff-added">+            TestIndex {</div><div class="diff-added">+                index: I::from_ram_index(Cow::Owned(ram_index), &temp_dir).unwrap(),</div><div class="diff-added">+                _temp_dir: temp_dir,</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Round scores to allow some quantization errors</div><div class="diff-added">+    fn round_scores<I: 'static>(mut scores: Vec<ScoredPointOffset>) -> Vec<ScoredPointOffset> {</div><div class="diff-added">+        let errors_allowed_for = [</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedImmutableRam<QuantizedU8>>(),</div><div class="diff-added">+            TypeId::of::<InvertedIndexCompressedMmap<QuantizedU8>>(),</div><div class="diff-added">+        ];</div><div class="diff-added">+        if errors_allowed_for.contains(&TypeId::of::<I>()) {</div><div class="diff-added">+            let precision = 0.25;</div><div class="diff-added">+            scores.iter_mut().for_each(|score| {</div><div class="diff-added">+                score.score = (score.score / precision).round() * precision;</div><div class="diff-added">+            });</div><div class="diff-added">+            scores</div><div class="diff-added">+        } else {</div><div class="diff-added">+            scores</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn test_empty_query<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram(InvertedIndexRam::empty());</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector::default(), // empty query vector</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+        assert_eq!(search_context.search(&match_all), Vec::new());</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // len(QueryVector)=3 * len(vector)=3 => 3*3 => 9</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 9 * size_of::<f32>());</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_update_test<I: InvertedIndex + 'static>() {</div><div class="diff-added">+        if TypeId::of::<I>() != TypeId::of::<InvertedIndexRam>() {</div><div class="diff-added">+            // Only InvertedIndexRam supports upserts</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let mut index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // update index with new point</div><div class="diff-added">+        index.index.upsert(</div><div class="diff-added">+            4,</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![40.0, 40.0, 40.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            None,</div><div class="diff-added">+        );</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            10,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            search_context.search(&match_all),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 120.0,</div><div class="diff-added">+                    idx: 4</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn search_with_hot_key_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 1.0)].into());</div><div class="diff-added">+            builder.add(5, [(1, 2.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 3.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 4.0)].into());</div><div class="diff-added">+            builder.add(8, [(1, 5.0)].into());</div><div class="diff-added">+            builder.add(9, [(1, 6.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+        // [ID=1] (Retrieve all 9 Vectors) => 9</div><div class="diff-added">+        // [ID=2] (Retrieve 1-3)           => 3</div><div class="diff-added">+        // [ID=3] (Retrieve 1-3)           => 3</div><div class="diff-added">+        //                       3 + 3 + 9 => 15</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 15 * size_of::<f32>());</div><div class="diff-added">+</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            4,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(search_context.search(&match_all)),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 90.0,</div><div class="diff-added">+                    idx: 3</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 60.0,</div><div class="diff-added">+                    idx: 2</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    score: 30.0,</div><div class="diff-added">+                    idx: 1</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset { score: 6.0, idx: 9 },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // No difference to previous calculation because it's the same amount of score</div><div class="diff-added">+        // calculations when increasing the "top" parameter.</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 15 * size_of::<f32>());</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_single_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_to_end_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // assuming we have gathered enough results and want to prune the longest posting list</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+        // the longest posting list was pruned to the end</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 0);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn pruning_multi_under_prune_test<I: InvertedIndex>() {</div><div class="diff-added">+        if !I::Iter::reliable_max_next_weight() {</div><div class="diff-added">+            return;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 20.0)].into());</div><div class="diff-added">+            builder.add(4, [(1, 10.0)].into());</div><div class="diff-added">+            builder.add(5, [(3, 10.0)].into());</div><div class="diff-added">+            builder.add(6, [(1, 20.0), (2, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(7, [(1, 40.0), (2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            1,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        // one would expect this to prune up to `6` but it does not happen it practice because we are under pruning by design</div><div class="diff-added">+        // we should actually check the best score up to `6` - 1 only instead of the max possible score (40.0)</div><div class="diff-added">+        assert!(!search_context.prune_longest_posting_list(30.0));</div><div class="diff-added">+</div><div class="diff-added">+        assert!(search_context.prune_longest_posting_list(40.0));</div><div class="diff-added">+        // the longest posting list pruned up to id=6</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 2);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Generates a random inverted index with `num_vectors` vectors</div><div class="diff-added">+    #[allow(dead_code)]</div><div class="diff-added">+    fn random_inverted_index<R: Rng>(</div><div class="diff-added">+        rnd_gen: &mut R,</div><div class="diff-added">+        num_vectors: u32,</div><div class="diff-added">+        max_sparse_dimension: usize,</div><div class="diff-added">+    ) -> InvertedIndexRam {</div><div class="diff-added">+        let mut inverted_index_ram = InvertedIndexRam::empty();</div><div class="diff-added">+</div><div class="diff-added">+        for i in 1..=num_vectors {</div><div class="diff-added">+            let SparseVector { indices, values } =</div><div class="diff-added">+                random_sparse_vector(rnd_gen, max_sparse_dimension);</div><div class="diff-added">+            let vector = RemappedSparseVector::new(indices, values).unwrap();</div><div class="diff-added">+            inverted_index_ram.upsert(i, vector, None);</div><div class="diff-added">+        }</div><div class="diff-added">+        inverted_index_ram</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn promote_longest_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 2);</div><div class="diff-added">+</div><div class="diff-added">+        search_context.promote_longest_posting_lists_to_the_front();</div><div class="diff-added">+</div><div class="diff-added">+        assert_eq!(search_context.posting_list_len(0), 3);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn plain_search_all_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(1, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 2, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        let scores = search_context.plain_search(&[1, 3, 2]);</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(scores),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 3,</div><div class="diff-added">+                    score: 60.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 2,</div><div class="diff-added">+                    score: 40.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 1,</div><div class="diff-added">+                    score: 30.0</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // The cost of plain search is `number of IDs to score` * (`query vector dimensions` + `sum of values lengths for these dimensions`).</div><div class="diff-added">+        // This is</div><div class="diff-added">+        // For ID 1: Query {1, 2, 3} + vector {1, 2, 3} * element_size => 3 + 3 * 4 = 15</div><div class="diff-added">+        // For ID 3: Query {1, 2, 3} + vector {1, 3} * element_size => 3 + 2 * 4 = 11</div><div class="diff-added">+        // For ID 2: Query {1, 2, 3} + vector {1, 3} * element_size => 3 + 2 * 4 = 11</div><div class="diff-added">+        // Total CPU = 15 + 11 + 11 = 37</div><div class="diff-added">+        assert_eq!(accumulator.get_cpu(), 37);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    #[test]</div><div class="diff-added">+    fn plain_search_gap_test<I: InvertedIndex>() {</div><div class="diff-added">+        let index = TestIndex::<I>::from_ram({</div><div class="diff-added">+            let mut builder = InvertedIndexBuilder::new();</div><div class="diff-added">+            builder.add(1, [(1, 10.0), (2, 10.0), (3, 10.0)].into());</div><div class="diff-added">+            builder.add(2, [(1, 20.0), (3, 20.0)].into());</div><div class="diff-added">+            builder.add(3, [(2, 30.0), (3, 30.0)].into());</div><div class="diff-added">+            builder.build()</div><div class="diff-added">+        });</div><div class="diff-added">+</div><div class="diff-added">+        // query vector has a gap for dimension 2</div><div class="diff-added">+        let is_stopped = AtomicBool::new(false);</div><div class="diff-added">+        let accumulator = HwMeasurementAcc::new();</div><div class="diff-added">+        let hardware_counter = accumulator.get_counter_cell();</div><div class="diff-added">+        let mut search_context = SearchContext::new(</div><div class="diff-added">+            RemappedSparseVector {</div><div class="diff-added">+                indices: vec![1, 3],</div><div class="diff-added">+                values: vec![1.0, 1.0],</div><div class="diff-added">+            },</div><div class="diff-added">+            3,</div><div class="diff-added">+            &index.index,</div><div class="diff-added">+            get_pooled_scores(),</div><div class="diff-added">+            &is_stopped,</div><div class="diff-added">+            hardware_counter,</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        let scores = search_context.plain_search(&[1, 2, 3]);</div><div class="diff-added">+        assert_eq!(</div><div class="diff-added">+            round_scores::<I>(scores),</div><div class="diff-added">+            vec![</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 2,</div><div class="diff-added">+                    score: 40.0</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 3,</div><div class="diff-added">+                    score: 30.0 // the dimension 2 did not contribute to the score</div><div class="diff-added">+                },</div><div class="diff-added">+                ScoredPointOffset {</div><div class="diff-added">+                    idx: 1,</div><div class="diff-added">+                    score: 20.0 // the dimension 2 did not contribute to the score</div><div class="diff-added">+                },</div><div class="diff-added">+            ]</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        drop(search_context);</div><div class="diff-added">+</div><div class="diff-added">+        // The cost of plain search is `number of IDs to score` * (`query vector dimensions` + `sum of values lengths for these dimensions`).</div><div class="diff-added">+        // This is</div><div class="diff-added">+        // For ID 1: Query {1, 3} + vector {1, 2, 3} * element_size</div><div class="diff-added">+        // For ID 2: Query {1, 3} + vector {1, 3} * element_size</div><div class="diff-added">+        // For ID 3: Query {1, 3} + vector {2, 3} * element_size</div><div class="diff-added">+        match TypeId::of::<I>() {</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexRam>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * 8 = 26</div><div class="diff-added">+                // ID 2 = 2 + 2 * 8 = 18</div><div class="diff-added">+                // ID 3 = 2 + 2 * 8 = 18</div><div class="diff-added">+                // Total CPU = 26 + 18 + 18 = 62</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 62);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexMmap>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * 8 = 26</div><div class="diff-added">+                // ID 2 = 2 + 2 * 8 = 18</div><div class="diff-added">+                // ID 3 = 2 + 2 * 8 = 18</div><div class="diff-added">+                // Total CPU = 26 + 18 + 18 = 62</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 62);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexImmutableRam>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * 4 = 14</div><div class="diff-added">+                // ID 2 = 2 + 2 * 4 = 10</div><div class="diff-added">+                // ID 3 = 2 + 2 * 4 = 10</div><div class="diff-added">+                // Total CPU = 14 + 10 + 10 = 34</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 34);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedImmutableRam<f32>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * ((0+2)+4) = 20</div><div class="diff-added">+                // ID 2 = 2 + 2 * ((0+2)+4) = 14</div><div class="diff-added">+                // ID 3 = 2 + 2 * ((0+2)+4) = 14</div><div class="diff-added">+                // Total CPU = 20 + 14 + 14 = 48</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 48);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedImmutableRam<half::f16>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * ((0+2)+2) = 14</div><div class="diff-added">+                // ID 2 = 2 + 2 * ((0+2)+2) = 10</div><div class="diff-added">+                // ID 3 = 2 + 2 * ((0+2)+2) = 10</div><div class="diff-added">+                // Total CPU = 14 + 10 + 10 = 34</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 34);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedImmutableRam<u8>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * ((0+2)+1) = 11</div><div class="diff-added">+                // ID 2 = 2 + 2 * ((0+2)+1) = 8</div><div class="diff-added">+                // ID 3 = 2 + 2 * ((0+2)+1) = 8</div><div class="diff-added">+                // Total CPU = 11 + 8 + 8 = 27</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 27);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedImmutableRam<QuantizedU8>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3 * ((0+2)+1) = 11</div><div class="diff-added">+                // ID 2 = 2 + 2 * ((0+2)+1) = 8</div><div class="diff-added">+                // ID 3 = 2 + 2 * ((0+2)+1) = 8</div><div class="diff-added">+                // Total CPU = 11 + 8 + 8 = 27</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 27);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedMmap<f32>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3*8 + 3*4 = 38</div><div class="diff-added">+                // ID 2 = 2 + 2*8 + 2*4 = 26</div><div class="diff-added">+                // ID 3 = 2 + 2*8 + 2*4 = 26</div><div class="diff-added">+                // Total CPU = 38 + 26 + 26 = 90</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 90);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedMmap<half::f16>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3*8 + 3*2 = 32</div><div class="diff-added">+                // ID 2 = 2 + 2*8 + 2*2 = 22</div><div class="diff-added">+                // ID 3 = 2 + 2*8 + 2*2 = 22</div><div class="diff-added">+                // Total CPU = 32 + 22 + 22 = 76</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 76);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedMmap<u8>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3*8 + 3*1 = 29</div><div class="diff-added">+                // ID 2 = 2 + 2*8 + 2*1 = 20</div><div class="diff-added">+                // ID 3 = 2 + 2*8 + 2*1 = 20</div><div class="diff-added">+                // Total CPU = 29 + 20 + 20 = 69</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 69);</div><div class="diff-added">+            }</div><div class="diff-added">+            id if id == TypeId::of::<InvertedIndexCompressedMmap<QuantizedU8>>() => {</div><div class="diff-added">+                // ID 1 = 2 + 3*8 + 3*1 = 29</div><div class="diff-added">+                // ID 2 = 2 + 2*8 + 2*1 = 20</div><div class="diff-added">+                // ID 3 = 2 + 2*8 + 2*1 = 20</div><div class="diff-added">+                // Total CPU = 29 + 20 + 20 = 69</div><div class="diff-added">+                assert_eq!(accumulator.get_cpu(), 69);</div><div class="diff-added">+            }</div><div class="diff-added">+            _ => unexpected_type(),</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    fn unexpected_type() -> ! {</div><div class="diff-added">+        panic!("Unexpected type")</div><div class="diff-added">+    }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    