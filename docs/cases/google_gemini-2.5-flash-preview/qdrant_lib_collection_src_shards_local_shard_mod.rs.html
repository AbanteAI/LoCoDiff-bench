<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/local_shard/mod.rs - Gemini 2.5 Flash</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/local_shard/mod.rs</h1>
        <p><a href="../../models/google_gemini-2.5-flash-preview.html">‚Üê Back to Gemini 2.5 Flash Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Flash</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 59828</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 75872</p>
                <p><strong>Native Completion Tokens:</strong> 11948</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.0185496</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_shards_local_shard_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_shards_local_shard_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-flash-preview/qdrant_lib_collection_src_shards_local_shard_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_shards_local_shard_mod.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_shards_local_shard_mod.rs_extracted.txt (actual)@@ -86,7 +86,6 @@ pub struct LocalShard {</div><div>     pub(super) segments: LockedSegmentHolder,</div><div>     pub(super) collection_config: Arc<TokioRwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-    pub(super) shared_storage_config: Arc<SharedStorageConfig>,</div><div>     pub(crate) payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>     pub(super) wal: RecoverableWal,</div><div>     pub(super) update_handler: Arc<Mutex<UpdateHandler>>,</div><div class="diff-info">@@ -175,7 +174,7 @@ </div><div>         // default to 2x the WAL capacity</div><div>         let disk_buffer_threshold_mb =</div><div class="diff-removed">-            2 * (collection_config.read().await.wal_config.wal_capacity_mb);</div><div class="diff-added">+            2 * (config.wal_config.wal_capacity_mb);</div><div> </div><div>         let disk_usage_watcher = disk_usage_watcher::DiskUsageWatcher::new(</div><div>             shard_path.to_owned(),</div><div class="diff-info">@@ -205,12 +204,11 @@ </div><div>         let update_tracker = segment_holder.read().update_tracker();</div><div> </div><div class="diff-removed">-        let read_rate_limiter = config.strict_mode_config.as_ref().and_then(|strict_mode| {</div><div class="diff-removed">-            strict_mode</div><div class="diff-removed">-                .read_rate_limit</div><div class="diff-removed">-                .map(RateLimiter::new_per_minute)</div><div class="diff-removed">-                .map(ParkingMutex::new)</div><div class="diff-removed">-        });</div><div class="diff-added">+        let read_rate_limiter = config</div><div class="diff-added">+            .strict_mode_config</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+            .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute))</div><div class="diff-added">+            .map(ParkingMutex::new);</div><div> </div><div>         drop(config); // release `shared_config` from borrow checker</div><div> </div><div class="diff-info">@@ -514,6 +512,7 @@         let vector_params = config.params.to_base_vector_data()?;</div><div>         let sparse_vector_params = config.params.to_sparse_vector_data()?;</div><div>         let segment_number = config.optimizer_config.get_number_segments();</div><div class="diff-added">+        let payload_index_schema_clone = payload_index_schema.read().clone();</div><div> </div><div>         for _sid in 0..segment_number {</div><div>             let path_clone = segments_path.clone();</div><div class="diff-info">@@ -524,7 +523,24 @@             };</div><div>             let segment = thread::Builder::new()</div><div>                 .name(format!("shard-build-{collection_id}-{id}"))</div><div class="diff-removed">-                .spawn(move || build_segment(&path_clone, &segment_config, true))</div><div class="diff-added">+                .spawn(move || {</div><div class="diff-added">+                    build_segment(&path_clone, &segment_config, true)</div><div class="diff-added">+                        .and_then(|segment| {</div><div class="diff-added">+                            // Create default payload indexes as specified in config</div><div class="diff-added">+                            segment.update_all_field_indices(&payload_index_schema_clone.schema)?;</div><div class="diff-added">+                            Ok(segment)</div><div class="diff-added">+                        })</div><div class="diff-added">+                        .map(|segment| {</div><div class="diff-added">+                            // Evict all pages from cache except metadata on creation</div><div class="diff-added">+                            if segment.disk_cache_enabled() {</div><div class="diff-added">+                                segment.clear_cache().unwrap_or_else(|err| {</div><div class="diff-added">+                                    log::error!("Failed to clear cache for segment {}: {}", segment.segment_path().display(), err);</div><div class="diff-added">+                                });</div><div class="diff-added">+                            }</div><div class="diff-added">+                            </div><div class="diff-added">+                            segment</div><div class="diff-added">+                        })</div><div class="diff-added">+                })</div><div>                 .unwrap();</div><div>             build_handlers.push(segment);</div><div>         }</div><div class="diff-info">@@ -557,6 +573,12 @@             &config.hnsw_config,</div><div>             &config.quantization_config,</div><div>         );</div><div class="diff-added">+</div><div class="diff-added">+        let read_rate_limiter = config</div><div class="diff-added">+            .strict_mode_config</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+            .and_then(|strict_mode| strict_mode.read_rate_limit.map(RateLimiter::new_per_minute))</div><div class="diff-added">+            .map(ParkingMutex::new);</div><div> </div><div>         drop(config); // release `shared_config` from borrow checker</div><div> </div><div class="diff-info">@@ -638,7 +660,7 @@             }</div><div> </div><div>             // Propagate `CollectionError::ServiceError`, but skip other error types.</div><div class="diff-removed">-            match &CollectionUpdater::update(</div><div class="diff-added">+            match CollectionUpdater::update(</div><div>                 segments,</div><div>                 op_num,</div><div>                 update.operation,</div><div class="diff-info">@@ -673,10 +695,10 @@             bar.inc(1);</div><div>             if !show_progress_bar && last_progress_report.elapsed() >= WAL_LOAD_REPORT_EVERY {</div><div>                 let progress = bar.position();</div><div class="diff-added">+                let total = wal.len(false);</div><div>                 log::info!(</div><div class="diff-removed">-                    "{progress}/{} ({}%)",</div><div class="diff-removed">-                    wal.len(false),</div><div class="diff-removed">-                    (progress as f32 / wal.len(false) as f32 * 100.0) as usize,</div><div class="diff-added">+                    "{progress}/{total} ({}%)",</div><div class="diff-added">+                    (progress as f32 / total as f32 * 100.0) as usize,</div><div>                 );</div><div>                 last_progress_report = Instant::now();</div><div>             }</div><div class="diff-info">@@ -688,7 +710,7 @@             // It is possible, that after recovery, if WAL flush was not enforced.</div><div>             // We could be left with some un-versioned points.</div><div>             // To maintain consistency, we can either remove them or try to recover.</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-added">+            for segment in segments.iter() {</div><div>                 match segment {</div><div>                     LockedSegment::Original(raw_segment) => {</div><div>                         raw_segment.write().cleanup_versions()?;</div><div class="diff-info">@@ -708,7 +730,8 @@         bar.finish();</div><div>         if !show_progress_bar {</div><div>             log::info!(</div><div class="diff-removed">-                "Recovered collection {collection_id}: {0}/{0} (100%)",</div><div class="diff-added">+                "Recovered shard {}: {0}/{0} (100%)",</div><div class="diff-added">+                self.path.display(),</div><div>                 wal.len(false),</div><div>             );</div><div>         }</div><div class="diff-info">@@ -723,10 +746,11 @@     /// Check data consistency for all segments</div><div>     ///</div><div>     /// Returns an error at the first inconsistent segment</div><div class="diff-added">+    #[cfg(feature = "data-consistency-check")]</div><div>     pub fn check_data_consistency(&self) -> CollectionResult<()> {</div><div>         log::info!("Checking data consistency for shard {:?}", self.path);</div><div>         let segments = self.segments.read();</div><div class="diff-removed">-        for (_idx, segment) in segments.iter() {</div><div class="diff-added">+        for segment in segments.iter() {</div><div>             match segment {</div><div>                 LockedSegment::Original(raw_segment) => {</div><div>                     let segment_guard = raw_segment.read();</div><div class="diff-info">@@ -749,81 +773,11 @@         Ok(())</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-        let mut update_handler = self.update_handler.lock().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let (update_sender, update_receiver) =</div><div class="diff-removed">-            mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        // makes sure that the Stop signal is the last one in this channel</div><div class="diff-removed">-        let old_sender = self.update_sender.swap(Arc::new(update_sender));</div><div class="diff-removed">-        old_sender.send(UpdateSignal::Stop).await?;</div><div class="diff-removed">-        update_handler.stop_flush_worker();</div><div class="diff-removed">-</div><div class="diff-removed">-        update_handler.wait_workers_stops().await?;</div><div class="diff-removed">-        let new_optimizers = build_optimizers(</div><div class="diff-removed">-            &self.path,</div><div class="diff-removed">-            &config.params,</div><div class="diff-removed">-            &config.optimizer_config,</div><div class="diff-removed">-            &config.hnsw_config,</div><div class="diff-removed">-            &config.quantization_config,</div><div class="diff-removed">-        );</div><div class="diff-removed">-        update_handler.optimizers = new_optimizers;</div><div class="diff-removed">-        update_handler.flush_interval_sec = config.optimizer_config.flush_interval_sec;</div><div class="diff-removed">-        update_handler.max_optimization_threads = config.optimizer_config.max_optimization_threads;</div><div class="diff-removed">-        update_handler.run_workers(update_receiver);</div><div class="diff-removed">-</div><div class="diff-removed">-        self.update_sender.load().send(UpdateSignal::Nop).await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Apply shard's strict mode configuration update</div><div class="diff-removed">-    /// - Update read rate limiter</div><div class="diff-removed">-    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-removed">-            if strict_mode_config.enabled == Some(true) {</div><div class="diff-removed">-                // update read rate limiter</div><div class="diff-removed">-                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-removed">-                    let new_read_rate_limiter =</div><div class="diff-removed">-                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-removed">-                    self.read_rate_limiter</div><div class="diff-removed">-                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-removed">-                    return;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // remove read rate limiter for all other situations</div><div class="diff-removed">-        self.read_rate_limiter.take();</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn trigger_optimizers(&self) {</div><div class="diff-removed">-        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-removed">-        // - If receiver is already dead - we do not care</div><div class="diff-removed">-        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Finishes ongoing update tasks</div><div class="diff-removed">-    pub async fn stop_gracefully(&self) {</div><div class="diff-removed">-        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-removed">-            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.stop_flush_worker().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-removed">-            log::warn!("Update workers failed with: {err}");</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn restore_snapshot(snapshot_path: &Path) -> CollectionResult<()> {</div><div>         log::info!("Restoring shard snapshot {}", snapshot_path.display());</div><div>         // Read dir first as the directory contents would change during restore</div><div>         let entries = std::fs::read_dir(LocalShard::segments_path(snapshot_path))?</div><div class="diff-removed">-            .collect::<Result<Vec<_>, _>>()?;</div><div class="diff-added">+            .collect::<Result<Vec<std::fs::DirEntry>, _>>()?;</div><div> </div><div>         // Filter out hidden entries</div><div>         let entries = entries.into_iter().filter(|entry| {</div><div class="diff-info">@@ -934,9 +888,13 @@         })?;</div><div> </div><div>         tar.blocking_append_dir_all(temp_dir.path(), Path::new(WAL_PATH))</div><div class="diff-removed">-            .map_err(|err| {</div><div class="diff-removed">-                CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-            })</div><div class="diff-added">+            .map_err(|err| CollectionError::service_error(format!("Error while archiving WAL: {err}")))?;</div><div class="diff-added">+</div><div class="diff-added">+        log::info!(</div><div class="diff-added">+            "Created snapshot of empty WAL for shard, starting at index {latest_op_num}",</div><div class="diff-added">+        );</div><div class="diff-added">+</div><div class="diff-added">+        Ok(())</div><div>     }</div><div> </div><div>     /// snapshot WAL</div><div class="diff-info">@@ -968,10 +926,11 @@             }</div><div> </div><div>             tar.blocking_append_file(&entry.path(), Path::new(&entry.file_name()))</div><div class="diff-removed">-                .map_err(|err| {</div><div class="diff-removed">-                    CollectionError::service_error(format!("Error while archiving WAL: {err}"))</div><div class="diff-removed">-                })?;</div><div class="diff-removed">-        }</div><div class="diff-added">+                .map_err(|err| CollectionError::service_error(format!("Error while archiving WAL: {err}")))?;</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        log::info!("Created snapshot of WAL for shard");</div><div class="diff-added">+</div><div>         Ok(())</div><div>     }</div><div> </div><div class="diff-info">@@ -1036,7 +995,7 @@             // TODO: snapshotting also creates temp proxy segments. should differentiate.</div><div>             let has_special_segment = segments</div><div>                 .iter()</div><div class="diff-removed">-                .map(|(_, segment)| segment.get().read().info().segment_type)</div><div class="diff-added">+                .map(|segment| segment.get().read().info().segment_type)</div><div>                 .any(|segment_type| segment_type == SegmentType::Special);</div><div>             if has_special_segment {</div><div>                 return (ShardStatus::Yellow, OptimizersStatus::Ok);</div><div class="diff-info">@@ -1074,7 +1033,7 @@ </div><div>         {</div><div>             let segments = self.segments().read();</div><div class="diff-removed">-            for (_idx, segment) in segments.iter() {</div><div class="diff-added">+            for segment in segments.iter() {</div><div>                 segments_count += 1;</div><div> </div><div>                 let segment_info = segment.get().read().info();</div><div class="diff-info">@@ -1106,24 +1065,63 @@     }</div><div> </div><div>     pub fn update_tracker(&self) -> &UpdateTracker {</div><div class="diff-removed">-        &self.update_tracker</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Get the recovery point for the current shard</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is sourced from the last seen clocks from other nodes that we know about.</div><div class="diff-added">+        self.update_tracker.deref()</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     pub async fn recovery_point(&self) -> RecoveryPoint {</div><div>         self.wal.recovery_point().await</div><div>     }</div><div> </div><div>     /// Update the cutoff point on the current shard</div><div>     ///</div><div class="diff-removed">-    /// This also updates the highest seen clocks.</div><div class="diff-added">+    /// This also updates the newest seen clocks.</div><div>     pub async fn update_cutoff(&self, cutoff: &RecoveryPoint) {</div><div>         self.wal.update_cutoff(cutoff).await</div><div>     }</div><div> </div><div class="diff-added">+    /// Apply shard's strict mode configuration update</div><div class="diff-added">+    /// - Update read rate limiter</div><div class="diff-added">+    pub async fn on_strict_mode_config_update(&mut self) {</div><div class="diff-added">+        let config = self.collection_config.read().await;</div><div class="diff-added">+</div><div class="diff-added">+        if let Some(strict_mode_config) = &config.strict_mode_config {</div><div class="diff-added">+            if strict_mode_config.enabled == Some(true) {</div><div class="diff-added">+                // update read rate limiter</div><div class="diff-added">+                if let Some(read_rate_limit_per_min) = strict_mode_config.read_rate_limit {</div><div class="diff-added">+                    let new_read_rate_limiter =</div><div class="diff-added">+                        RateLimiter::new_per_minute(read_rate_limit_per_min);</div><div class="diff-added">+                    self.read_rate_limiter</div><div class="diff-added">+                        .replace(parking_lot::Mutex::new(new_read_rate_limiter));</div><div class="diff-added">+                    return;</div><div class="diff-added">+                }</div><div class="diff-added">+            }</div><div class="diff-added">+        }</div><div class="diff-added">+        // remove read rate limiter for all other situations</div><div class="diff-added">+        self.read_rate_limiter.take();</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    pub fn trigger_optimizers(&self) {</div><div class="diff-added">+        // Send a trigger signal and ignore errors because all error cases are acceptable:</div><div class="diff-added">+        // - If receiver is already dead - we do not care</div><div class="diff-added">+        // - If channel is full - optimization will be triggered by some other signal</div><div class="diff-added">+        let _ = self.update_sender.load().try_send(UpdateSignal::Nop);</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Finishes ongoing update tasks</div><div class="diff-added">+    pub async fn stop_gracefully(&self) {</div><div class="diff-added">+        if let Err(err) = self.update_sender.load().send(UpdateSignal::Stop).await {</div><div class="diff-added">+            log::warn!("Error sending stop signal to update handler: {err}");</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        self.stop_flush_worker().await;</div><div class="diff-added">+</div><div class="diff-added">+        if let Err(err) = self.wait_update_workers_stop().await {</div><div class="diff-added">+            log::warn!("Update workers failed with: {err}");</div><div class="diff-added">+        }</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div>     /// Check if the read rate limiter allows the operation to proceed</div><div class="diff-added">+    /// - cost: the cost of the operation</div><div>     /// - hw_measurement_acc: the current hardware measurement accumulator</div><div>     /// - context: the context of the operation to add on the error message</div><div>     /// - cost_fn: the cost of the operation called lazily</div><div class="diff-info">@@ -1131,6 +1129,7 @@     /// Returns an error if the rate limit is exceeded.</div><div>     fn check_read_rate_limiter<F>(</div><div>         &self,</div><div class="diff-added">+        cost: usize,</div><div>         hw_measurement_acc: &HwMeasurementAcc,</div><div>         context: &str,</div><div>         cost_fn: F,</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    