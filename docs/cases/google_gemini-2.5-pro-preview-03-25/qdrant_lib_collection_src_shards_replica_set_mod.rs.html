<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/shards/replica_set/mod.rs - Gemini 2.5 Pro</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/shards/replica_set/mod.rs</h1>
        <p><a href="../../models/google_gemini-2.5-pro-preview-03-25.html">‚Üê Back to Gemini 2.5 Pro Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Pro</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 57397</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 71651</p>
                <p><strong>Native Completion Tokens:</strong> 18102</p>
                <p><strong>Native Tokens Reasoning:</strong> 5476</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Cost:</strong> $0.27058375</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_shards_replica_set_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_shards_replica_set_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_shards_replica_set_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_shards_replica_set_mod.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_shards_replica_set_mod.rs_extracted.txt (actual)@@ -24,8 +24,8 @@ use tokio::sync::{Mutex, RwLock};</div><div> </div><div> use super::CollectionId;</div><div class="diff-added">+use super::local_shard::clock_map::RecoveryPoint;</div><div> use super::local_shard::LocalShard;</div><div class="diff-removed">-use super::local_shard::clock_map::RecoveryPoint;</div><div> use super::remote_shard::RemoteShard;</div><div> use super::transfer::ShardTransfer;</div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div class="diff-info">@@ -114,8 +114,9 @@     clock_set: Mutex<ClockSet>,</div><div>     write_rate_limiter: Option<parking_lot::Mutex<RateLimiter>>,</div><div> }</div><div class="diff-removed">-</div><div class="diff-added">+// TODO: Remove? Seems excessive to pass this around everywhere.</div><div> pub type AbortShardTransfer = Arc<dyn Fn(ShardTransfer, &str) + Send + Sync>;</div><div class="diff-added">+// TODO: Remove? Maybe consensus dispatcher or notifier can handle this?</div><div> pub type ChangePeerState = Arc<dyn Fn(PeerId, ShardId) + Send + Sync>;</div><div> pub type ChangePeerFromState = Arc<dyn Fn(PeerId, ShardId, Option<ReplicaState>) + Send + Sync>;</div><div> </div><div class="diff-info">@@ -208,8 +209,8 @@             replica_state: replica_state.into(),</div><div>             locally_disabled_peers: Default::default(),</div><div>             shard_path,</div><div class="diff-added">+            notify_peer_failure_cb: on_peer_failure,</div><div>             abort_shard_transfer_cb: abort_shard_transfer,</div><div class="diff-removed">-            notify_peer_failure_cb: on_peer_failure,</div><div>             channel_service,</div><div>             collection_id,</div><div>             collection_config,</div><div class="diff-info">@@ -224,6 +225,7 @@             write_rate_limiter,</div><div>         })</div><div>     }</div><div class="diff-added">+    // TODO(strict_mode): Maybe we should initialize the read rate limiter here too?</div><div> </div><div>     /// Recovers shard from disk.</div><div>     ///</div><div class="diff-info">@@ -301,6 +303,8 @@                     optimizer_resource_budget.clone(),</div><div>                 )</div><div>                 .await;</div><div class="diff-added">+                // TODO(resharding): Recreate shard if shard key is different from expected?</div><div class="diff-added">+                //                   In that case, `is_dirty_shard` flag should be ignored too?</div><div> </div><div>                 match res {</div><div>                     Ok(shard) => Shard::Local(shard),</div><div class="diff-info">@@ -318,7 +322,7 @@                         );</div><div> </div><div>                         Shard::Dummy(DummyShard::new(format!(</div><div class="diff-removed">-                            "Failed to load local shard {shard_path:?}: {err}"</div><div class="diff-added">+                            "Failed to load local shard {shard_path:?}: {err}",</div><div>                         )))</div><div>                     }</div><div>                 }</div><div class="diff-info">@@ -389,17 +393,17 @@ </div><div>     pub async fn is_local(&self) -> bool {</div><div>         let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::Local(_) | Shard::Dummy(_)))</div><div class="diff-added">+        matches!(local_read.as_ref(), Some(Shard::Local(_) | Shard::Dummy(_)))</div><div>     }</div><div> </div><div>     pub async fn is_queue_proxy(&self) -> bool {</div><div>         let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::QueueProxy(_)))</div><div class="diff-added">+        matches!(local_read.as_ref(), Some(Shard::QueueProxy(_)))</div><div>     }</div><div> </div><div>     pub async fn is_dummy(&self) -> bool {</div><div>         let local_read = self.local.read().await;</div><div class="diff-removed">-        matches!(*local_read, Some(Shard::Dummy(_)))</div><div class="diff-added">+        matches!(local_read.as_ref(), Some(Shard::Dummy(_)))</div><div>     }</div><div> </div><div>     pub fn peers(&self) -> HashMap<PeerId, ReplicaState> {</div><div class="diff-info">@@ -526,10 +530,9 @@     /// Clears the local shard data and loads an empty local shard</div><div>     pub async fn init_empty_local_shard(&self) -> CollectionResult<()> {</div><div>         let mut local = self.local.write().await;</div><div class="diff-removed">-</div><div>         let current_shard = local.take();</div><div class="diff-removed">-</div><div>         LocalShard::clear(&self.shard_path).await?;</div><div class="diff-added">+</div><div>         let local_shard_res = LocalShard::build(</div><div>             self.shard_id,</div><div>             self.collection_id.clone(),</div><div class="diff-info">@@ -580,7 +583,7 @@     }</div><div> </div><div>     pub async fn remove_local(&self) -> CollectionResult<()> {</div><div class="diff-removed">-        // TODO: Ensure cancel safety!</div><div class="diff-added">+        // TODO: Ensure cancel safety!?</div><div> </div><div>         self.replica_state.write(|rs| {</div><div>             rs.is_local = false;</div><div class="diff-info">@@ -590,10 +593,7 @@ </div><div>         self.update_locally_disabled(self.this_peer_id());</div><div> </div><div class="diff-removed">-        let removing_local = {</div><div class="diff-removed">-            let mut local = self.local.write().await;</div><div class="diff-removed">-            local.take()</div><div class="diff-removed">-        };</div><div class="diff-added">+        let removing_local = { self.local.write().await.take() };</div><div> </div><div>         if let Some(removing_local) = removing_local {</div><div>             // stop ongoing tasks and delete data</div><div class="diff-info">@@ -773,7 +773,7 @@ </div><div>     pub(crate) async fn on_optimizer_config_update(&self) -> CollectionResult<()> {</div><div>         let read_local = self.local.read().await;</div><div class="diff-removed">-        if let Some(shard) = &*read_local {</div><div class="diff-added">+        if let Some(shard) = read_local.as_ref() {</div><div>             shard.on_optimizer_config_update().await</div><div>         } else {</div><div>             Ok(())</div><div class="diff-info">@@ -867,7 +867,7 @@ </div><div>         let Some(remote) = remotes.iter().find(|remote| remote.peer_id == peer_id) else {</div><div>             return Err(CollectionError::NotFound {</div><div class="diff-removed">-                what: format!("{}/{}:{} shard", peer_id, self.collection_id, self.shard_id),</div><div class="diff-added">+                what: format!("{peer_id}/{}:{}} shard", self.collection_id, self.shard_id),</div><div>             });</div><div>         };</div><div> </div><div class="diff-info">@@ -936,8 +936,10 @@             });</div><div> </div><div>         // TODO(resharding): Assign clock tag to the operation!? ü§î</div><div class="diff-added">+        // Measurement is marked as disposable to avoid rate limiting this internal cleanup operation.</div><div class="diff-added">+        // If the shard deletion fails, the cleanup will be retried on the next node restart.</div><div>         let result = self</div><div class="diff-removed">-            .update_local(op.into(), true, hw_measurement_acc, force)</div><div class="diff-added">+            .update_local(op.into(), true, HwMeasurementAcc::disposable(), force)</div><div>             .await?</div><div>             .ok_or_else(|| {</div><div>                 CollectionError::bad_request(format!(</div><div class="diff-info">@@ -995,6 +997,46 @@ </div><div>         is_active_or_resharding && !is_locally_disabled</div><div>     }</div><div class="diff-added">+    // TODO(resharding-cleanup): Rename, remove?</div><div class="diff-added">+    //                           Used only in `shard_transfer`, specifically for `TransferMethod::StreamRecords`</div><div class="diff-added">+</div><div class="diff-added">+    // TODO(resharding-cleanup): Rename, remove?</div><div class="diff-added">+    //                            Used in `update` for write consistency</div><div class="diff-added">+    //                            Used in `resolve_wal_delta` for WAL delta</div><div class="diff-added">+    #[allow(unused)]</div><div class="diff-added">+    /// Check whether a peer accepts updates.</div><div class="diff-added">+    fn accepts_updates(&self, peer_id: PeerId) -> bool {</div><div class="diff-added">+        // Do not send updates to replicas in recovery state.</div><div class="diff-added">+        // The peer holding the replica may keep it in active state for some time if consensus is slow to respond.</div><div class="diff-added">+        // It allows the peer to keep responding to read requests. Those reads may be stale if we don't send updates to it, causing data inconsistencies.</div><div class="diff-added">+        // See https://github.com/qdrant/qdrant/pull/3659#pullrequestreview-1871944333</div><div class="diff-added">+        //</div><div class="diff-added">+        // UPD(1.8.0): The issue is known and documented now.</div><div class="diff-added">+        // See https://github.com/qdrant/qdrant/issues/3660</div><div class="diff-added">+        //</div><div class="diff-added">+        // UPD(1.10.0): The issue is solved now.</div><div class="diff-added">+        // See https://github.com/qdrant/qdrant/pull/5298</div><div class="diff-added">+        let Some(state) = self.peer_state(peer_id) else {</div><div class="diff-added">+            // We don't know the state of the peer, assume it doesn't accept updates</div><div class="diff-added">+            return false;</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        // Let's check the state explicitly</div><div class="diff-added">+        use ReplicaState::*;</div><div class="diff-added">+        let state_accepts_updates = match state {</div><div class="diff-added">+            Active => true,</div><div class="diff-added">+            Listener => true,</div><div class="diff-added">+            Resharding => true,</div><div class="diff-added">+            ReshardingScaleDown => true,</div><div class="diff-added">+            PartialSnapshot => true, // Since 1.8.0, accepts updates if force is true, which is handled internally</div><div class="diff-added">+            Initializing => false,</div><div class="diff-added">+            Partial => false,</div><div class="diff-added">+            Recovery => false,</div><div class="diff-added">+            Dead => false,</div><div class="diff-added">+        };</div><div class="diff-added">+</div><div class="diff-added">+        state_accepts_updates && !self.is_locally_disabled(peer_id)</div><div class="diff-added">+    }</div><div> </div><div>     fn is_locally_disabled(&self, peer_id: PeerId) -> bool {</div><div>         self.locally_disabled_peers.read().is_disabled(peer_id)</div><div class="diff-info">@@ -1059,7 +1101,7 @@ </div><div>     fn abort_shard_transfer(&self, transfer: ShardTransfer, reason: &str) {</div><div>         log::debug!(</div><div class="diff-removed">-            "Abort {}:{} / {} -> {} shard transfer",</div><div class="diff-added">+            "Abort {}:{}/({} -> {}) shard transfer: {reason}",</div><div>             self.collection_id,</div><div>             transfer.shard_id,</div><div>             transfer.from,</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    