<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - Gemini 2.5 Pro</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <p><a href="../../models/google_gemini-2.5-pro-preview-03-25.html">‚Üê Back to Gemini 2.5 Pro Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Gemini 2.5 Pro</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Output Tokens:</strong> N/A</p>
                <p><strong>Native Prompt Tokens:</strong> 77208</p>
                <p><strong>Native Completion Tokens:</strong> 16176</p>
                <p><strong>Native Tokens Reasoning:</strong> 8022</p>
                <p><strong>Native Finish Reason:</strong> STOP</p>
                <p><strong>Runtime:</strong> N/As</p>
                <p><strong>Cost:</strong> $0.25827</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/google_gemini-2.5-pro-preview-03-25/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div class="diff-header">--- qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected)+++ qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual)@@ -93,8 +93,8 @@     optimizers_log: Arc<Mutex<TrackerLog>>,</div><div>     /// Total number of optimized points since last start</div><div>     total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-    /// Global CPU budget in number of cores for all optimization tasks.</div><div class="diff-removed">-    /// Assigns CPU permits to tasks to limit overall resource utilization.</div><div class="diff-added">+    /// Global resource budget in number of cores/threads for all optimization tasks.</div><div class="diff-added">+    /// Assigns resource permits to tasks to limit overall resource utilization.</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     /// How frequent can we flush data</div><div>     /// This parameter depends on the optimizer config and should be updated accordingly.</div><div class="diff-info">@@ -143,8 +143,8 @@         max_optimization_threads: Option<usize>,</div><div>         clocks: LocalShardClocks,</div><div>         shard_path: PathBuf,</div><div class="diff-removed">-    ) -> UpdateHandler {</div><div class="diff-removed">-        UpdateHandler {</div><div class="diff-added">+    ) -> Self {</div><div class="diff-added">+        Self {</div><div>             shared_storage_config,</div><div>             payload_index_schema,</div><div>             optimizers,</div><div class="diff-info">@@ -266,6 +266,7 @@     /// Checks conditions for all optimizers until there is no suggested segment</div><div>     /// Starts a task for each optimization</div><div>     /// Returns handles for started tasks</div><div class="diff-added">+    #[allow(clippy::too_many_arguments)]</div><div>     pub(crate) fn launch_optimization<F>(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>         optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-info">@@ -284,7 +285,7 @@         'outer: for optimizer in optimizers.iter() {</div><div>             loop {</div><div>                 // Return early if we reached the optimization job limit</div><div class="diff-removed">-                if limit.map(|extra| handles.len() >= extra).unwrap_or(false) {</div><div class="diff-added">+                if limit.is_some_and(|extra| handles.len() >= extra) {</div><div>                     log::trace!("Reached optimization job limit, postponing other optimizations");</div><div>                     break 'outer;</div><div>                 }</div><div class="diff-info">@@ -295,7 +296,7 @@                     break;</div><div>                 }</div><div> </div><div class="diff-removed">-                debug!("Optimizing segments: {:?}", &nonoptimal_segment_ids);</div><div class="diff-added">+                debug!("Optimizing segments: {nonoptimal_segment_ids:?}");</div><div> </div><div>                 // Determine how many Resources we prefer for optimization task, acquire permit for it</div><div>                 // And use same amount of IO threads as CPUs</div><div class="diff-info">@@ -347,13 +348,13 @@                             optimizers_log.lock().register(tracker);</div><div> </div><div>                             // Optimize and handle result</div><div class="diff-removed">-                            match optimizer.as_ref().optimize(</div><div class="diff-added">+                            match unsafe { optimizer.as_ref().optimize(</div><div>                                 segments.clone(),</div><div>                                 nsi,</div><div>                                 permit,</div><div>                                 resource_budget,</div><div>                                 stopped,</div><div class="diff-removed">-                            ) {</div><div class="diff-added">+                            ) } {</div><div>                                 // Perform some actions when optimization if finished</div><div>                                 Ok(optimized_points) => {</div><div>                                     let is_optimized = optimized_points > 0;</div><div class="diff-info">@@ -372,6 +373,8 @@                                         false</div><div>                                     }</div><div>                                     _ => {</div><div class="diff-added">+                                        // Save only the first error</div><div class="diff-added">+                                        // If is more likely to be the real cause of all further problems</div><div>                                         segments.write().report_optimizer_error(error.clone());</div><div> </div><div>                                         // Error of the optimization can not be handled by API user</div><div class="diff-info">@@ -384,7 +387,7 @@                                             .update(TrackerStatus::Error(error.to_string()));</div><div> </div><div>                                         panic!("Optimization error: {error}");</div><div class="diff-removed">-                                    }</div><div class="diff-added">+                                    },</div><div>                                 },</div><div>                             }</div><div>                         }</div><div class="diff-info">@@ -561,7 +564,7 @@             .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div>             .unwrap_or_default();</div><div> </div><div class="diff-removed">-        // Asynchronous task to trigger optimizers once CPU budget is available again</div><div class="diff-added">+        // Asynchronous task to trigger optimizers once resource budget is available again</div><div>         let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div> </div><div>         loop {</div><div class="diff-info">@@ -652,7 +655,7 @@             }</div><div> </div><div>             // Determine optimization handle limit based on max handles we allow</div><div class="diff-removed">-            // Not related to the CPU budget, but a different limit for the maximum number</div><div class="diff-added">+            // Not related to the resource budget, but a different limit for the maximum number</div><div>             // of concurrent concrete optimizations per shard as configured by the user in</div><div>             // the Qdrant configuration.</div><div>             // Skip if we reached limit, an ongoing optimization that finishes will trigger this loop again</div><div class="diff-info">@@ -721,7 +724,9 @@ </div><div>                     if let Some(feedback) = sender {</div><div>                         feedback.send(res).unwrap_or_else(|_| {</div><div class="diff-removed">-                            debug!("Can't report operation {op_num} result. Assume already not required");</div><div class="diff-added">+                            debug!(</div><div class="diff-added">+                                "Can't report operation {op_num} result. Assume already not required",</div><div class="diff-added">+                            );</div><div>                         });</div><div>                     };</div><div>                 }</div><div class="diff-info">@@ -802,7 +807,7 @@             // This is to prevent truncating WAL entries that other bits of code still depend on</div><div>             // such as the queue proxy shard.</div><div>             // Default keep_from is `u64::MAX` to allow acknowledging all confirmed.</div><div class="diff-removed">-            let keep_from = wal_keep_from.load(std::sync::atomic::Ordering::Relaxed);</div><div class="diff-added">+            let keep_from = wal_keep_from.load(Ordering::Relaxed);</div><div> </div><div>             // If we should keep the first message, do not acknowledge at all</div><div>             if keep_from == 0 {</div><div class="diff-info">@@ -837,7 +842,7 @@     }</div><div> }</div><div> </div><div class="diff-removed">-/// Trigger optimizers when CPU budget is available</div><div class="diff-added">+/// Trigger optimizers when resource budget is available</div><div> fn trigger_optimizers_on_resource_budget(</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     desired_cpus: usize,</div><div class="diff-info">@@ -845,11 +850,11 @@     sender: Sender<OptimizerSignal>,</div><div> ) -> JoinHandle<()> {</div><div>     task::spawn(async move {</div><div class="diff-removed">-        log::trace!("Skipping optimization checks, waiting for CPU budget to be available");</div><div class="diff-added">+        log::trace!("Skipping optimization checks, waiting for resource budget to be available");</div><div>         optimizer_resource_budget</div><div>             .notify_on_budget_available(desired_cpus, desired_io)</div><div>             .await;</div><div class="diff-removed">-        log::trace!("Continue optimization checks, new CPU budget available");</div><div class="diff-added">+        log::trace!("Continue optimization checks, new resource budget available");</div><div> </div><div>         // Trigger optimizers with Nop operation</div><div>         sender.send(OptimizerSignal::Nop).await.unwrap_or_else(|_| {</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    