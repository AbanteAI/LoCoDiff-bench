<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection/mod.rs - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection/mod.rs</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../models/openai_gpt-oss-120b.html">All GPT OSS 120B Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT OSS 120B</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 58627</p>
                <p><strong>Native Prompt Tokens:</strong> 58576</p>
                <p><strong>Native Completion Tokens:</strong> 8559</p>
                <p><strong>Native Tokens Reasoning:</strong> 3007</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.02054971</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_collection_mod.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_collection_mod.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_collection_mod.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 71e15f9b2..37a0e683c 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_mod.rs_expectedoutput.txt (expected):tmp/tmpksgd8n_o_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_mod.rs_extracted.txt (actual):tmp/tmp_ety7c13_actual.txt	</div><div class="diff-info">@@ -12,7 +12,7 @@ mod sharding_keys;</div><div> mod snapshots;</div><div> mod state_management;</div><div> </div><div class="diff-removed">-use std::collections::HashMap;</div><div class="diff-added">+use std::collections::HashSet;</div><div> use std::ops::Deref;</div><div> use std::path::{Path, PathBuf};</div><div> use std::sync::Arc;</div><div class="diff-info">@@ -29,9 +29,6 @@ use tokio::sync::{Mutex, RwLock, RwLockWriteGuard};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_state::{ShardInfo, State};</div><div class="diff-removed">-use crate::common::collection_size_stats::{</div><div class="diff-removed">-    CollectionSizeAtomicStats, CollectionSizeStats, CollectionSizeStatsCache,</div><div class="diff-removed">-};</div><div> use crate::common::is_ready::IsReady;</div><div> use crate::config::CollectionConfigInternal;</div><div> use crate::operations::config_diff::{DiffConfig, OptimizersConfigDiff};</div><div class="diff-info">@@ -42,13 +39,14 @@ use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::channel_service::ChannelService;</div><div> use crate::shards::collection_shard_distribution::CollectionShardDistribution;</div><div> use crate::shards::local_shard::clock_map::RecoveryPoint;</div><div class="diff-removed">-use crate::shards::replica_set::ReplicaState::{Active, Dead, Initializing, Listener};</div><div> use crate::shards::replica_set::{</div><div>     ChangePeerFromState, ChangePeerState, ReplicaState, ShardReplicaSet,</div><div> };</div><div class="diff-added">+use crate::shards::resharding::ReshardKey;</div><div> use crate::shards::shard::{PeerId, ShardId};</div><div class="diff-removed">-use crate::shards::shard_holder::shard_mapping::ShardKeyMapping;</div><div class="diff-removed">-use crate::shards::shard_holder::{LockedShardHolder, ShardHolder, shard_not_found_error};</div><div class="diff-added">+use crate::shards::shard_holder::{</div><div class="diff-added">+    shard_not_found_error, LockedShardHolder, ShardHolder, shard_mapping::ShardKeyMapping,</div><div class="diff-added">+};</div><div> use crate::shards::transfer::helpers::check_transfer_conflicts_strict;</div><div> use crate::shards::transfer::transfer_tasks_pool::{TaskResult, TransferTasksPool};</div><div> use crate::shards::transfer::{ShardTransfer, ShardTransferMethod};</div><div class="diff-info">@@ -59,10 +57,10 @@ use crate::telemetry::{</div><div> </div><div> /// Collection's data is split into several shards.</div><div> pub struct Collection {</div><div class="diff-removed">-    pub(crate) id: CollectionId,</div><div class="diff-removed">-    pub(crate) shards_holder: Arc<LockedShardHolder>,</div><div class="diff-removed">-    pub(crate) collection_config: Arc<RwLock<CollectionConfigInternal>>,</div><div class="diff-removed">-    pub(crate) shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+    id: CollectionId,</div><div class="diff-added">+    shards_holder: Arc<LockedShardHolder>,</div><div class="diff-added">+    collection_config: Arc<RwLock<CollectionConfigInternal>>,</div><div class="diff-added">+    shared_storage_config: Arc<SharedStorageConfig>,</div><div>     payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>     optimizers_overwrite: Option<OptimizersConfigDiff>,</div><div>     this_peer_id: PeerId,</div><div class="diff-info">@@ -74,29 +72,17 @@ pub struct Collection {</div><div>     notify_peer_failure_cb: ChangePeerFromState,</div><div>     abort_shard_transfer_cb: replica_set::AbortShardTransfer,</div><div>     init_time: Duration,</div><div class="diff-removed">-    // One-way boolean flag that is set to true when the collection is fully initialized</div><div class="diff-removed">-    // i.e. all shards are activated for the first time.</div><div>     is_initialized: Arc<IsReady>,</div><div class="diff-removed">-    // Lock to temporary block collection update operations while the collection is being migrated.</div><div class="diff-removed">-    // Lock is acquired for read on update operation and can be acquired for write externally,</div><div class="diff-removed">-    // which will block all update operations until the lock is released.</div><div>     updates_lock: Arc<RwLock<()>>,</div><div class="diff-removed">-    // Update runtime handle.</div><div>     update_runtime: Handle,</div><div class="diff-removed">-    // Search runtime handle.</div><div>     search_runtime: Handle,</div><div>     optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    // Cached statistics of collection size, may be outdated.</div><div>     collection_stats_cache: CollectionSizeStatsCache,</div><div class="diff-removed">-    // Background tasks to clean shards</div><div>     shard_clean_tasks: ShardCleanTasks,</div><div> }</div><div> </div><div> pub type RequestShardTransfer = Arc<dyn Fn(ShardTransfer) + Send + Sync>;</div><div> </div><div class="diff-removed">-pub type OnTransferFailure = Arc<dyn Fn(ShardTransfer, CollectionId, &str) + Send + Sync>;</div><div class="diff-removed">-pub type OnTransferSuccess = Arc<dyn Fn(ShardTransfer, CollectionId) + Send + Sync>;</div><div class="diff-removed">-</div><div> impl Collection {</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub async fn new(</div><div class="diff-info">@@ -128,12 +114,6 @@ impl Collection {</div><div>         for (shard_id, mut peers) in shard_distribution.shards {</div><div>             let is_local = peers.remove(&this_peer_id);</div><div> </div><div class="diff-removed">-            let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-removed">-            if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-                effective_optimizers_config =</div><div class="diff-removed">-                    optimizers_overwrite.update(&effective_optimizers_config)?;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div>             let shard_key = shard_key_mapping</div><div>                 .as_ref()</div><div>                 .and_then(|mapping| mapping.shard_key(shard_id));</div><div class="diff-info">@@ -148,14 +128,11 @@ impl Collection {</div><div>                 abort_shard_transfer.clone(),</div><div>                 path,</div><div>                 shared_collection_config.clone(),</div><div class="diff-removed">-                effective_optimizers_config,</div><div class="diff-added">+                collection_config.optimizer_config.clone(),</div><div>                 shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div>                 channel_service.clone(),</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                optimizer_resource_budget.clone(),</div><div class="diff-removed">-                None,</div><div>             )</div><div>             .await?;</div><div> </div><div class="diff-info">@@ -168,7 +145,6 @@ impl Collection {</div><div>             Self::estimate_collection_size_stats(&locked_shard_holder).await,</div><div>         );</div><div> </div><div class="diff-removed">-        // Once the config is persisted - the collection is considered to be successfully created.</div><div>         CollectionVersion::save(path)?;</div><div>         collection_config.save(path)?;</div><div> </div><div class="diff-info">@@ -176,9 +152,9 @@ impl Collection {</div><div>             id: name.clone(),</div><div>             shards_holder: locked_shard_holder,</div><div>             collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div>             path: path.to_owned(),</div><div>             snapshots_path: snapshots_path.to_owned(),</div><div class="diff-info">@@ -199,14 +175,15 @@ impl Collection {</div><div>     }</div><div> </div><div>     #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub async fn load(</div><div class="diff-added">+    pub fn load(</div><div>         collection_id: CollectionId,</div><div>         this_peer_id: PeerId,</div><div>         path: &Path,</div><div>         snapshots_path: &Path,</div><div>         shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+        shard_key_mapping: Option<ShardKeyMapping>,</div><div>         channel_service: ChannelService,</div><div class="diff-removed">-        on_replica_failure: replica_set::ChangePeerFromState,</div><div class="diff-added">+        on_replica_failure: ChangePeerFromState,</div><div>         request_shard_transfer: RequestShardTransfer,</div><div>         abort_shard_transfer: replica_set::AbortShardTransfer,</div><div>         search_runtime: Option<Handle>,</div><div class="diff-info">@@ -232,30 +209,16 @@ impl Collection {</div><div>                     .unwrap_or_else(|err| panic!("Can't save collection version {err}"));</div><div>             } else {</div><div>                 log::error!("Cannot upgrade version {stored_version} to {app_version}.");</div><div class="diff-removed">-                panic!(</div><div class="diff-removed">-                    "Cannot upgrade version {stored_version} to {app_version}. Try to use older version of Qdrant first.",</div><div class="diff-removed">-                );</div><div class="diff-added">+                panic!("Cannot upgrade version {stored_version} to {app_version}. Try to use older version of Qdrant first.");</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        let collection_config = CollectionConfigInternal::load(path).unwrap_or_else(|err| {</div><div class="diff-removed">-            panic!(</div><div class="diff-removed">-                "Can't read collection config due to {}\nat {}",</div><div class="diff-removed">-                err,</div><div class="diff-removed">-                path.to_str().unwrap(),</div><div class="diff-removed">-            )</div><div class="diff-removed">-        });</div><div class="diff-added">+        let collection_config = CollectionConfigInternal::load(path)</div><div class="diff-added">+            .unwrap_or_else(|err| panic!("Can't read collection config due to {}\nat {}", err, path.to_str().unwrap()));</div><div>         collection_config.validate_and_warn();</div><div> </div><div>         let mut shard_holder = ShardHolder::new(path).expect("Can not create shard holder");</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut effective_optimizers_config = collection_config.optimizer_config.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = optimizers_overwrite.clone() {</div><div class="diff-removed">-            effective_optimizers_config = optimizers_overwrite</div><div class="diff-removed">-                .update(&effective_optimizers_config)</div><div class="diff-removed">-                .expect("Can not apply optimizer overwrite");</div><div class="diff-removed">-        }</div><div class="diff-added">+        shard_holder.set_shard_key_mappings(shard_key_mapping.clone().unwrap_or_default()).expect("Failed to set shard key mappings");</div><div> </div><div>         let shared_collection_config = Arc::new(RwLock::new(collection_config.clone()));</div><div> </div><div class="diff-info">@@ -269,16 +232,14 @@ impl Collection {</div><div>                 path,</div><div>                 &collection_id,</div><div>                 shared_collection_config.clone(),</div><div class="diff-removed">-                effective_optimizers_config,</div><div class="diff-added">+                collection_config.optimizer_config.clone(),</div><div>                 shared_storage_config.clone(),</div><div class="diff-removed">-                payload_index_schema.clone(),</div><div>                 channel_service.clone(),</div><div>                 on_replica_failure.clone(),</div><div>                 abort_shard_transfer.clone(),</div><div>                 this_peer_id,</div><div>                 update_runtime.clone().unwrap_or_else(Handle::current),</div><div>                 search_runtime.clone().unwrap_or_else(Handle::current),</div><div class="diff-removed">-                optimizer_resource_budget.clone(),</div><div>             )</div><div>             .await;</div><div> </div><div class="diff-info">@@ -292,9 +253,9 @@ impl Collection {</div><div>             id: collection_id.clone(),</div><div>             shards_holder: locked_shard_holder,</div><div>             collection_config: shared_collection_config,</div><div class="diff-removed">-            optimizers_overwrite,</div><div class="diff-removed">-            payload_index_schema,</div><div>             shared_storage_config,</div><div class="diff-added">+            payload_index_schema,</div><div class="diff-added">+            optimizers_overwrite,</div><div>             this_peer_id,</div><div>             path: path.to_owned(),</div><div>             snapshots_path: snapshots_path.to_owned(),</div><div class="diff-info">@@ -314,37 +275,10 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Check if stored version have consequent version.</div><div class="diff-removed">-    /// If major version is different, then it is not compatible.</div><div class="diff-removed">-    /// If the difference in consecutive versions is greater than 1 in patch,</div><div class="diff-removed">-    /// then the collection is not compatible with the current version.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Example:</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.1 = true</div><div class="diff-removed">-    ///   0.4.0 -> 0.4.2 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.0 = false</div><div class="diff-removed">-    ///   0.4.0 -> 0.5.1 = false</div><div class="diff-removed">-    pub fn can_upgrade_storage(stored: &Version, app: &Version) -> bool {</div><div class="diff-removed">-        if stored.major != app.major {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.minor != app.minor {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        if stored.patch + 1 < app.patch {</div><div class="diff-removed">-            return false;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        true</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub fn name(&self) -> String {</div><div>         self.id.clone()</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn uuid(&self) -> Option<uuid::Uuid> {</div><div class="diff-removed">-        self.collection_config.read().await.uuid</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn get_shard_keys(&self) -> Vec<ShardKey> {</div><div>         self.shards_holder</div><div>             .read()</div><div class="diff-info">@@ -355,7 +289,6 @@ impl Collection {</div><div>             .collect()</div><div>     }</div><div> </div><div class="diff-removed">-    /// Return a list of local shards, present on this peer</div><div>     pub async fn get_local_shards(&self) -> Vec<ShardId> {</div><div>         self.shards_holder.read().await.get_local_shards().await</div><div>     }</div><div class="diff-info">@@ -402,107 +335,66 @@ impl Collection {</div><div> </div><div>         let current_state = replica_set.peer_state(peer_id);</div><div> </div><div class="diff-removed">-        // Validation:</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // 1. Check that peer exists in the cluster (peer might *not* exist, if it was removed from</div><div class="diff-removed">-        //    the cluster right before `SetShardReplicaSet` was proposed)</div><div>         let peer_exists = self</div><div>             .channel_service</div><div>             .id_to_address</div><div>             .read()</div><div>             .contains_key(&peer_id);</div><div class="diff-removed">-</div><div>         let replica_exists = replica_set.peer_state(peer_id).is_some();</div><div> </div><div>         if !peer_exists && !replica_exists {</div><div>             return Err(CollectionError::bad_input(format!(</div><div class="diff-removed">-                "Can't set replica {peer_id}:{shard_id} state to {new_state:?}, \</div><div class="diff-removed">-                 because replica {peer_id}:{shard_id} does not exist \</div><div class="diff-removed">-                 and peer {peer_id} is not part of the cluster"</div><div class="diff-added">+                "Can't set replica {peer_id}:{shard_id} state to {new_state:?}, because replica {peer_id}:{shard_id} does not exist and peer {peer_id} is not part of the cluster"</div><div>             )));</div><div>         }</div><div> </div><div class="diff-removed">-        // 2. Check that `from_state` matches current state</div><div>         if from_state.is_some() && current_state != from_state {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Replica {peer_id} of shard {shard_id} has state {current_state:?}, but expected {from_state:?}"</div><div>             )));</div><div>         }</div><div> </div><div class="diff-removed">-        // 3. Do not deactivate the last active replica</div><div class="diff-removed">-        //</div><div class="diff-removed">-        // `is_last_active_replica` counts both `Active` and `ReshardingScaleDown` replicas!</div><div class="diff-removed">-        if replica_set.is_last_active_replica(peer_id) && !new_state.is_active() {</div><div class="diff-added">+        if new_state != ReplicaState::Active && replica_set.is_last_active_replica(peer_id) {</div><div>             return Err(CollectionError::bad_input(format!(</div><div>                 "Cannot deactivate the last active replica {peer_id} of shard {shard_id}"</div><div>             )));</div><div>         }</div><div> </div><div class="diff-removed">-        // Update replica status</div><div class="diff-removed">-        replica_set</div><div class="diff-removed">-            .ensure_replica_with_state(peer_id, new_state)</div><div class="diff-removed">-            .await?;</div><div class="diff-removed">-</div><div class="diff-removed">-        if new_state == ReplicaState::Dead {</div><div class="diff-removed">-            let resharding_state = shard_holder.resharding_state.read().clone();</div><div class="diff-removed">-            let related_transfers = shard_holder.get_related_transfers(shard_id, peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Functions below lock `shard_holder`!</div><div class="diff-added">+        let is_resharding = current_state</div><div class="diff-added">+            .as_ref()</div><div class="diff-added">+            .is_some_and(ReplicaState::is_resharding);</div><div class="diff-added">+        if is_resharding && new_state == ReplicaState::Dead {</div><div>             drop(shard_holder);</div><div class="diff-removed">-</div><div class="diff-removed">-            let mut abort_resharding_result = CollectionResult::Ok(());</div><div class="diff-removed">-</div><div class="diff-removed">-            // Abort resharding, if resharding shard is marked as `Dead`.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // This branch should only be triggered, if resharding is currently at `MigratingPoints`</div><div class="diff-removed">-            // stage, because target shard should be marked as `Active`, when all resharding transfers</div><div class="diff-removed">-            // are successfully completed, and so the check *right above* this one would be triggered.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // So, if resharding reached `ReadHashRingCommitted`, this branch *won't* be triggered,</div><div class="diff-removed">-            // and resharding *won't* be cancelled. The update request should *fail* with "failed to</div><div class="diff-removed">-            // update all replicas of a shard" error.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // If resharding reached `ReadHashRingCommitted`, and this branch is triggered *somehow*,</div><div class="diff-removed">-            // then `Collection::abort_resharding` call should return an error, so no special handling</div><div class="diff-removed">-            // is needed.</div><div class="diff-removed">-            let is_resharding = current_state</div><div class="diff-removed">-                .as_ref()</div><div class="diff-removed">-                .is_some_and(ReplicaState::is_resharding);</div><div class="diff-removed">-            if is_resharding {</div><div class="diff-removed">-                if let Some(state) = resharding_state {</div><div class="diff-removed">-                    abort_resharding_result = self.abort_resharding(state.key(), false).await;</div><div class="diff-added">+            if let Some(state) = self.resharding_state().await {</div><div class="diff-added">+                if state.peer_id == peer_id {</div><div class="diff-added">+                    self.abort_resharding(state.key(), false).await?;</div><div>                 }</div><div>             }</div><div class="diff-added">+        }</div><div class="diff-added">+</div><div class="diff-added">+        replica_set.ensure_replica_with_state(peer_id, new_state).await?;</div><div> </div><div class="diff-removed">-            // Terminate transfer if source or target replicas are now dead</div><div class="diff-added">+        if new_state == ReplicaState::Dead {</div><div class="diff-added">+            let related_transfers = shard_holder.get_related_transfers(shard_id, peer_id);</div><div class="diff-added">+            drop(shard_holder);</div><div>             for transfer in related_transfers {</div><div>                 self.abort_shard_transfer(transfer.key(), None).await?;</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Propagate resharding errors now</div><div class="diff-removed">-            abort_resharding_result?;</div><div>         }</div><div> </div><div class="diff-removed">-        // If not initialized yet, we need to check if it was initialized by this call</div><div>         if !self.is_initialized.check_ready() {</div><div>             let state = self.state().await;</div><div class="diff-removed">-</div><div>             let mut is_ready = true;</div><div class="diff-removed">-</div><div>             for (_shard_id, shard_info) in state.shards {</div><div class="diff-removed">-                let all_replicas_active = shard_info.replicas.into_iter().all(|(_, state)| {</div><div class="diff-removed">-                    matches!(</div><div class="diff-removed">-                        state,</div><div class="diff-removed">-                        ReplicaState::Active | ReplicaState::ReshardingScaleDown</div><div class="diff-removed">-                    )</div><div class="diff-removed">-                });</div><div class="diff-removed">-</div><div class="diff-removed">-                if !all_replicas_active {</div><div class="diff-added">+                if shard_info</div><div class="diff-added">+                    .replicas</div><div class="diff-added">+                    .into_iter()</div><div class="diff-added">+                    .any(|(_peer_id, state)| !state.is_active())</div><div class="diff-added">+                {</div><div>                     is_ready = false;</div><div>                     break;</div><div>                 }</div><div>             }</div><div class="diff-removed">-</div><div>             if is_ready {</div><div>                 self.is_initialized.make_ready();</div><div>             }</div><div class="diff-info">@@ -563,30 +455,6 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn remove_shards_at_peer(&self, peer_id: PeerId) -> CollectionResult<()> {</div><div class="diff-removed">-        // Abort resharding, if shards are removed from peer driving resharding</div><div class="diff-removed">-        // (which *usually* means the *peer* is being removed from consensus)</div><div class="diff-removed">-        let resharding_state = self</div><div class="diff-removed">-            .resharding_state()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .filter(|state| state.peer_id == peer_id);</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(state) = resharding_state {</div><div class="diff-removed">-            if let Err(err) = self.abort_resharding(state.key(), true).await {</div><div class="diff-removed">-                log::error!(</div><div class="diff-removed">-                    "Failed to abort resharding {} while removing peer {peer_id}: {err}",</div><div class="diff-removed">-                    state.key(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        self.shards_holder</div><div class="diff-removed">-            .read()</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .remove_shards_at_peer(peer_id)</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn sync_local_state(</div><div>         &self,</div><div>         on_transfer_failure: OnTransferFailure,</div><div class="diff-info">@@ -595,19 +463,11 @@ impl Collection {</div><div>         on_convert_to_listener: ChangePeerState,</div><div>         on_convert_from_listener: ChangePeerState,</div><div>     ) -> CollectionResult<()> {</div><div class="diff-removed">-        // Check for disabled replicas</div><div>         let shard_holder = self.shards_holder.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        let get_shard_transfers = |shard_id, from| {</div><div class="diff-removed">-            shard_holder</div><div class="diff-removed">-                .get_transfers(|transfer| transfer.shard_id == shard_id && transfer.from == from)</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div>         for replica_set in shard_holder.all_shards() {</div><div class="diff-removed">-            replica_set.sync_local_state(get_shard_transfers)?;</div><div class="diff-added">+            replica_set.sync_local_state().await?;</div><div>         }</div><div> </div><div class="diff-removed">-        // Check for un-reported finished transfers</div><div>         let outgoing_transfers = shard_holder.get_outgoing_transfers(self.this_peer_id);</div><div>         let tasks_lock = self.transfer_tasks.lock().await;</div><div>         for transfer in outgoing_transfers {</div><div class="diff-info">@@ -640,69 +500,38 @@ impl Collection {</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Count how many transfers we are now proposing</div><div class="diff-removed">-        // We must track this here so we can reference it when checking for tranfser limits,</div><div class="diff-removed">-        // because transfers we propose now will not be in the consensus state within the lifetime</div><div class="diff-removed">-        // of this function</div><div>         let mut proposed = HashMap::<PeerId, usize>::new();</div><div> </div><div class="diff-removed">-        // Check for proper replica states</div><div>         for replica_set in shard_holder.all_shards() {</div><div>             let this_peer_id = replica_set.this_peer_id();</div><div>             let shard_id = replica_set.shard_id;</div><div> </div><div>             let peers = replica_set.peers();</div><div>             let this_peer_state = peers.get(&this_peer_id).copied();</div><div class="diff-added">+            let is_last_active = peers.values().filter(|state| **state == Active).count() == 1;</div><div> </div><div>             if this_peer_state == Some(Initializing) {</div><div class="diff-removed">-                // It is possible, that collection creation didn't report</div><div class="diff-removed">-                // Try to activate shard, as the collection clearly exists</div><div>                 on_finish_init(this_peer_id, shard_id);</div><div>                 continue;</div><div>             }</div><div> </div><div>             if self.shared_storage_config.node_type == NodeType::Listener {</div><div class="diff-removed">-                // We probably should not switch node type during resharding, so we only check for `Active`,</div><div class="diff-removed">-                // but not `ReshardingScaleDown` replica state here...</div><div class="diff-removed">-                let is_last_active = peers.values().filter(|&&state| state == Active).count() == 1;</div><div class="diff-removed">-</div><div>                 if this_peer_state == Some(Active) && !is_last_active {</div><div class="diff-removed">-                    // Convert active node from active to listener</div><div>                     on_convert_to_listener(this_peer_id, shard_id);</div><div>                     continue;</div><div>                 }</div><div>             } else if this_peer_state == Some(Listener) {</div><div class="diff-removed">-                // Convert listener node to active</div><div>                 on_convert_from_listener(this_peer_id, shard_id);</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Don't automatically recover replicas if started in recovery mode</div><div class="diff-removed">-            if self.shared_storage_config.recovery_mode.is_some() {</div><div class="diff-added">+            if this_peer_state != Some(Dead) || replica_set.is_dummy().await {</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // Don't recover replicas if not dead</div><div class="diff-removed">-            let is_dead = this_peer_state == Some(Dead);</div><div class="diff-removed">-            if !is_dead {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Try to find dead replicas with no active transfers</div><div>             let transfers = shard_holder.get_transfers(|_| true);</div><div> </div><div class="diff-removed">-            // Respect shard transfer limit, consider already proposed transfers in our counts</div><div class="diff-removed">-            let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(this_peer_id);</div><div class="diff-removed">-            incoming += proposed.get(&this_peer_id).copied().unwrap_or(0);</div><div class="diff-removed">-            if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-removed">-                log::trace!(</div><div class="diff-removed">-                    "Postponing automatic shard {shard_id} transfer to stay below limit on this node (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-removed">-                );</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Select shard transfer method, prefer user configured method or choose one now</div><div class="diff-removed">-            // If all peers are 1.8+, we try WAL delta transfer, otherwise we use the default method</div><div class="diff-added">+            // Select shard transfer method</div><div>             let shard_transfer_method = self</div><div>                 .shared_storage_config</div><div>                 .default_shard_transfer_method</div><div class="diff-info">@@ -717,9 +546,6 @@ impl Collection {</div><div>                     }</div><div>                 });</div><div> </div><div class="diff-removed">-            // Try to find a replica to transfer from</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // `active_remote_shards` includes `Active` and `ReshardingScaleDown` replicas!</div><div>             for replica_id in replica_set.active_remote_shards() {</div><div>                 let transfer = ShardTransfer {</div><div>                     from: replica_id,</div><div class="diff-info">@@ -727,43 +553,37 @@ impl Collection {</div><div>                     shard_id,</div><div>                     to_shard_id: None,</div><div>                     sync: true,</div><div class="diff-removed">-                    // For automatic shard transfers, always select some default method from this point on</div><div>                     method: Some(shard_transfer_method),</div><div>                 };</div><div> </div><div>                 if check_transfer_conflicts_strict(&transfer, transfers.iter()).is_some() {</div><div class="diff-removed">-                    continue; // this transfer won't work</div><div class="diff-added">+                    continue;</div><div class="diff-added">+                }</div><div class="diff-added">+</div><div class="diff-added">+                let (mut incoming, outgoing) = shard_holder.count_shard_transfer_io(this_peer_id);</div><div class="diff-added">+                incoming += proposed.get(&this_peer_id).copied().unwrap_or(0);</div><div class="diff-added">+                if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-added">+                    log::trace!("Postponing automatic shard {shard_id} transfer to stay below limit on this node (incoming: {incoming}, outgoing: {outgoing})");</div><div class="diff-added">+                    continue;</div><div>                 }</div><div> </div><div class="diff-removed">-                // Respect shard transfer limit, consider already proposed transfers in our counts</div><div>                 let (incoming, mut outgoing) = shard_holder.count_shard_transfer_io(replica_id);</div><div>                 outgoing += proposed.get(&replica_id).copied().unwrap_or(0);</div><div>                 if self.check_auto_shard_transfer_limit(incoming, outgoing) {</div><div class="diff-removed">-                    log::trace!(</div><div class="diff-removed">-                        "Postponing automatic shard {shard_id} transfer to stay below limit on peer {replica_id} (incoming: {incoming}, outgoing: {outgoing})",</div><div class="diff-removed">-                    );</div><div class="diff-added">+                    log::trace!("Postponing automatic shard {shard_id} transfer to stay below limit on peer {replica_id} (incoming: {incoming}, outgoing: {outgoing})");</div><div>                     continue;</div><div>                 }</div><div> </div><div class="diff-removed">-                // TODO: Should we, maybe, throttle/backoff this requests a bit?</div><div>                 if let Err(err) = replica_set.health_check(replica_id).await {</div><div class="diff-removed">-                    // TODO: This is rather verbose, not sure if we want to log this at all... :/</div><div>                     log::trace!(</div><div class="diff-removed">-                        "Replica {replica_id}/{}:{} is not available \</div><div class="diff-removed">-                         to request shard transfer from: \</div><div class="diff-removed">-                         {err}",</div><div class="diff-removed">-                        self.id,</div><div class="diff-removed">-                        replica_set.shard_id,</div><div class="diff-added">+                        "Replica {replica_id}/{self.id}:{replica_set.shard_id} is not available to request shard transfer from: {err}"</div><div>                     );</div><div>                     continue;</div><div>                 }</div><div> </div><div>                 log::debug!(</div><div class="diff-removed">-                    "Recovering shard {}:{shard_id} on peer {this_peer_id} by requesting it from {replica_id}",</div><div class="diff-removed">-                    self.name(),</div><div class="diff-added">+                    "Recovering shard {}:{shard_id} on peer {this_peer_id} by requesting it from {replica_id}"</div><div>                 );</div><div class="diff-removed">-</div><div class="diff-removed">-                // Update our counters for proposed transfers, then request (propose) shard transfer</div><div>                 *proposed.entry(transfer.from).or_default() += 1;</div><div>                 *proposed.entry(transfer.to).or_default() += 1;</div><div>                 self.request_shard_transfer(transfer);</div><div class="diff-info">@@ -775,25 +595,25 @@ impl Collection {</div><div>     }</div><div> </div><div>     pub async fn get_telemetry_data(&self, detail: TelemetryDetail) -> CollectionTelemetry {</div><div class="diff-removed">-        let (shards_telemetry, transfers, resharding) = {</div><div class="diff-removed">-            if detail.level >= DetailsLevel::Level3 {</div><div class="diff-removed">-                let shards_holder = self.shards_holder.read().await;</div><div class="diff-removed">-                let mut shards_telemetry = Vec::new();</div><div class="diff-removed">-                for shard in shards_holder.all_shards() {</div><div class="diff-removed">-                    shards_telemetry.push(shard.get_telemetry_data(detail).await)</div><div class="diff-removed">-                }</div><div class="diff-removed">-                (</div><div class="diff-removed">-                    Some(shards_telemetry),</div><div class="diff-removed">-                    Some(shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)),</div><div class="diff-removed">-                    Some(</div><div class="diff-removed">-                        shards_holder</div><div class="diff-removed">-                            .get_resharding_operations_info()</div><div class="diff-removed">-                            .unwrap_or_default(),</div><div class="diff-removed">-                    ),</div><div class="diff-removed">-                )</div><div class="diff-removed">-            } else {</div><div class="diff-removed">-                (None, None, None)</div><div class="diff-added">+        let (shards_telemetry, transfers, resharding) = if detail.level >= DetailsLevel::Level3 {</div><div class="diff-added">+            let shards_holder = self.shards_holder.read().await;</div><div class="diff-added">+            let mut shards_vec = Vec::new();</div><div class="diff-added">+            for shard in shards_holder.all_shards() {</div><div class="diff-added">+                shards_vec.push(shard.get_telemetry_data(detail).await);</div><div>             }</div><div class="diff-added">+            (</div><div class="diff-added">+                Some(shards_vec),</div><div class="diff-added">+                Some(</div><div class="diff-added">+                    shards_holder.get_shard_transfer_info(&*self.transfer_tasks.lock().await)</div><div class="diff-added">+                ),</div><div class="diff-added">+                Some(</div><div class="diff-added">+                    shards_holder</div><div class="diff-added">+                        .get_resharding_operations_info()</div><div class="diff-added">+                        .unwrap_or_default(),</div><div class="diff-added">+                ),</div><div class="diff-added">+            )</div><div class="diff-added">+        } else {</div><div class="diff-added">+            (None, None, None)</div><div>         };</div><div> </div><div>         let shard_clean_tasks = self.clean_local_shards_statuses();</div><div class="diff-info">@@ -838,16 +658,6 @@ impl Collection {</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    pub async fn effective_optimizers_config(&self) -> CollectionResult<OptimizersConfig> {</div><div class="diff-removed">-        let config = self.collection_config.read().await;</div><div class="diff-removed">-</div><div class="diff-removed">-        if let Some(optimizers_overwrite) = self.optimizers_overwrite.clone() {</div><div class="diff-removed">-            Ok(optimizers_overwrite.update(&config.optimizer_config)?)</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Ok(config.optimizer_config.clone())</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div>     pub async fn lock_updates(&self) -> RwLockWriteGuard<()> {</div><div>         self.updates_lock.write().await</div><div>     }</div><div class="diff-info">@@ -859,39 +669,18 @@ impl Collection {</div><div>     pub fn request_shard_transfer(&self, shard_transfer: ShardTransfer) {</div><div>         self.request_shard_transfer_cb.deref()(shard_transfer)</div><div>     }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn snapshots_path(&self) -> &Path {</div><div class="diff-removed">-        &self.snapshots_path</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn shards_holder(&self) -> Arc<LockedShardHolder> {</div><div class="diff-removed">-        self.shards_holder.clone()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub async fn trigger_optimizers(&self) {</div><div class="diff-removed">-        self.shards_holder.read().await.trigger_optimizers().await;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    async fn estimate_collection_size_stats(</div><div class="diff-removed">-        shards_holder: &Arc<RwLock<ShardHolder>>,</div><div class="diff-removed">-    ) -> Option<CollectionSizeStats> {</div><div class="diff-removed">-        let shard_lock = shards_holder.read().await;</div><div class="diff-removed">-        shard_lock.estimate_collection_size_stats().await</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Returns estimations of collection sizes. This values are cached and might be not 100% up to date.</div><div class="diff-removed">-    /// The cache gets updated every 32 calls.</div><div class="diff-removed">-    pub(crate) async fn estimated_collection_stats(&self) -> Option<&CollectionSizeAtomicStats> {</div><div class="diff-removed">-        self.collection_stats_cache</div><div class="diff-removed">-            .get_or_update_cache(|| Self::estimate_collection_size_stats(&self.shards_holder))</div><div class="diff-removed">-            .await</div><div class="diff-removed">-    }</div><div> }</div><div> </div><div class="diff-removed">-struct CollectionVersion;</div><div class="diff-added">+impl Collection {</div><div class="diff-added">+    fn resharding_state_file(collection_path: &Path) -> PathBuf {</div><div class="diff-added">+        collection_path.join(RESHARDING_STATE_FILE)</div><div class="diff-added">+    }</div><div> </div><div class="diff-removed">-impl StorageVersion for CollectionVersion {</div><div class="diff-removed">-    fn current_raw() -> &'static str {</div><div class="diff-removed">-        env!("CARGO_PKG_VERSION")</div><div class="diff-added">+    fn load_resharding_state(</div><div class="diff-added">+        collection_path: &Path,</div><div class="diff-added">+    ) -> CollectionResult<SaveOnDisk<Option<ReshardingState>>> {</div><div class="diff-added">+        let resharding_state_file = Self::resharding_state_file(collection_path);</div><div class="diff-added">+        let resharding_state = SaveOnDisk::load_or_init(resharding_state_file)?;</div><div class="diff-added">+        Ok(resharding_state)</div><div>     }</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    