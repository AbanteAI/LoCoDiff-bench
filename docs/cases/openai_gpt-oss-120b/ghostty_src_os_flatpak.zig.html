<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/os/flatpak.zig - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/os/flatpak.zig</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../models/openai_gpt-oss-120b.html">All GPT OSS 120B Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT OSS 120B</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 11975</p>
                <p><strong>Native Prompt Tokens:</strong> 12077</p>
                <p><strong>Native Completion Tokens:</strong> 6584</p>
                <p><strong>Native Tokens Reasoning:</strong> 3591</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.00674955</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_os_flatpak.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_os_flatpak.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_os_flatpak.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index f77a8d507..5b8a090fc 100644</div><div class="diff-header">--- a/ghostty_src_os_flatpak.zig_expectedoutput.txt (expected):tmp/tmp2d_fb0q8_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_os_flatpak.zig_extracted.txt (actual):tmp/tmp9ex7h7e1_actual.txt	</div><div class="diff-info">@@ -3,7 +3,6 @@ const assert = std.debug.assert;</div><div> const Allocator = std.mem.Allocator;</div><div> const builtin = @import("builtin");</div><div> const posix = std.posix;</div><div class="diff-removed">-const xev = @import("../global.zig").xev;</div><div> </div><div> const log = std.log.scoped(.flatpak);</div><div> </div><div class="diff-info">@@ -14,19 +13,9 @@ pub fn isFlatpak() bool {</div><div>     return if (std.fs.accessAbsolute("/.flatpak-info", .{})) true else |_| false;</div><div> }</div><div> </div><div class="diff-removed">-/// A struct to help execute commands on the host via the</div><div class="diff-removed">-/// org.freedesktop.Flatpak.Development DBus module. This uses GIO/GLib</div><div class="diff-removed">-/// under the hood.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// This always spawns its own thread and maintains its own GLib event loop.</div><div class="diff-removed">-/// This makes it easy for the command to behave synchronously similar to</div><div class="diff-removed">-/// std.process.Child.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// There are lots of chances for low-hanging improvements here (automatic</div><div class="diff-removed">-/// pipes, /dev/null, etc.) but this was purpose built for my needs so</div><div class="diff-removed">-/// it doesn't have all of those.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// Requires GIO, GLib to be available and linked.</div><div class="diff-added">+// -----------------------------------------------------------------------------</div><div class="diff-added">+// FlatpakHostCommand</div><div class="diff-added">+// -----------------------------------------------------------------------------</div><div> pub const FlatpakHostCommand = struct {</div><div>     const fd_t = posix.fd_t;</div><div>     const EnvMap = std.process.EnvMap;</div><div class="diff-info">@@ -35,50 +24,36 @@ pub const FlatpakHostCommand = struct {</div><div>         @cInclude("gio/gunixfdlist.h");</div><div>     });</div><div> </div><div class="diff-removed">-    /// Argv are the arguments to call on the host with argv[0] being</div><div class="diff-removed">-    /// the command to execute.</div><div class="diff-added">+    /// argv[0] is the command to execute on the host.</div><div>     argv: []const []const u8,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// The cwd for the new process. If this is not set then it will use</div><div class="diff-removed">-    /// the current cwd of the calling process.</div><div class="diff-added">+    /// Current working directory. Uses caller's cwd if null.</div><div>     cwd: ?[:0]const u8 = null,</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Environment variables for the child process. If this is null, this</div><div class="diff-removed">-    /// does not send any environment variables.</div><div class="diff-added">+    /// Environment variables to send. null means don't send any.</div><div>     env: ?*const EnvMap = null,</div><div> </div><div class="diff-removed">-    /// File descriptors to send to the child process. It is up to the</div><div class="diff-removed">-    /// caller to create the file descriptors and set them up.</div><div class="diff-added">+    /// File descriptors to send to the child process.</div><div>     stdin: fd_t,</div><div>     stdout: fd_t,</div><div>     stderr: fd_t,</div><div> </div><div class="diff-removed">-    /// State of the process. This is updated by the dedicated thread it</div><div class="diff-removed">-    /// runs in and is protected by the given lock and condition variable.</div><div class="diff-added">+    /// State of the command.</div><div>     state: State = .{ .init = {} },</div><div>     state_mutex: std.Thread.Mutex = .{},</div><div>     state_cv: std.Thread.Condition = .{},</div><div> </div><div class="diff-removed">-    /// State the process is in. This can't be inspected directly, you</div><div class="diff-removed">-    /// must use getters on the struct to get access.</div><div>     const State = union(enum) {</div><div>         /// Initial state</div><div>         init: void,</div><div class="diff-removed">-</div><div class="diff-removed">-        /// Error starting. The error message is only available via logs.</div><div class="diff-removed">-        /// (This isn't a fundamental limitation, just didn't need the</div><div class="diff-removed">-        /// error message yet)</div><div class="diff-added">+        /// Error while spawning</div><div>         err: void,</div><div class="diff-removed">-</div><div class="diff-removed">-        /// Process started with the given pid on the host.</div><div class="diff-added">+        /// Process started</div><div>         started: struct {</div><div>             pid: u32,</div><div class="diff-removed">-            loop_xev: ?*xev.Loop,</div><div class="diff-removed">-            completion: ?*Completion,</div><div>             subscription: c.guint,</div><div>             loop: *c.GMainLoop,</div><div class="diff-added">+            completion: ?*Completion,</div><div class="diff-added">+            loop_xev: ?*xev.Loop,</div><div>         },</div><div class="diff-removed">-</div><div>         /// Process exited</div><div>         exited: struct {</div><div>             pid: u32,</div><div class="diff-info">@@ -87,14 +62,14 @@ pub const FlatpakHostCommand = struct {</div><div>     };</div><div> </div><div>     pub const Completion = struct {</div><div class="diff-removed">-        callback: *const fn (ud: ?*anyopaque, l: *xev.Loop, c: *Completion, r: WaitError!u8) void = noopCallback,</div><div class="diff-added">+        callback: *const fn (ud: ?*anyopaque, l: *xev.Loop, c: *Completion, r: WaitError!u8) void = &noopCallback,</div><div>         c_xev: xev.Completion = .{},</div><div>         userdata: ?*anyopaque = null,</div><div>         timer: ?xev.Timer = null,</div><div>         result: ?WaitError!u8 = null,</div><div>     };</div><div> </div><div class="diff-removed">-    /// Errors that are possible from us.</div><div class="diff-added">+    /// Errors that may be returned.</div><div>     pub const Error = error{</div><div>         FlatpakMustBeStarted,</div><div>         FlatpakSpawnFail,</div><div class="diff-info">@@ -104,18 +79,14 @@ pub const FlatpakHostCommand = struct {</div><div> </div><div>     pub const WaitError = xev.Timer.RunError || Error;</div><div> </div><div class="diff-removed">-    /// Spawn the command. This will start the host command. On return,</div><div class="diff-removed">-    /// the pid will be available. This must only be called with the</div><div class="diff-removed">-    /// state in "init".</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Precondition: The self pointer MUST be stable.</div><div class="diff-added">+    /// Spawn the command. Returns the host PID.</div><div>     pub fn spawn(self: *FlatpakHostCommand, alloc: Allocator) !u32 {</div><div>         const thread = try std.Thread.spawn(.{}, threadMain, .{ self, alloc });</div><div>         thread.setName("flatpak-host-command") catch {};</div><div> </div><div class="diff-removed">-        // Wait for the process to start or error.</div><div>         self.state_mutex.lock();</div><div>         defer self.state_mutex.unlock();</div><div class="diff-added">+</div><div>         while (self.state == .init) self.state_cv.wait(&self.state_mutex);</div><div> </div><div>         return switch (self.state) {</div><div class="diff-info">@@ -126,8 +97,7 @@ pub const FlatpakHostCommand = struct {</div><div>         };</div><div>     }</div><div> </div><div class="diff-removed">-    /// Wait for the process to end and return the exit status. This</div><div class="diff-removed">-    /// can only be called ONCE. Once this returns, the state is reset.</div><div class="diff-added">+    /// Wait synchronously for the process to exit.</div><div>     pub fn wait(self: *FlatpakHostCommand) !u8 {</div><div>         self.state_mutex.lock();</div><div>         defer self.state_mutex.unlock();</div><div class="diff-info">@@ -143,13 +113,11 @@ pub const FlatpakHostCommand = struct {</div><div>                     return v.status;</div><div>                 },</div><div>             }</div><div class="diff-removed">-</div><div>             self.state_cv.wait(&self.state_mutex);</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Wait for the process to end asynchronously via libxev. This</div><div class="diff-removed">-    /// can only be called ONCE.</div><div class="diff-added">+    /// Wait asynchronously using libxev.</div><div>     pub fn waitXev(</div><div>         self: *FlatpakHostCommand,</div><div>         loop: *xev.Loop,</div><div class="diff-info">@@ -168,18 +136,18 @@ pub const FlatpakHostCommand = struct {</div><div> </div><div>         completion.* = .{</div><div>             .callback = (struct {</div><div class="diff-removed">-                fn callback(</div><div class="diff-added">+                fn _callback(</div><div>                     ud_: ?*anyopaque,</div><div>                     l_inner: *xev.Loop,</div><div>                     c_inner: *Completion,</div><div>                     r: WaitError!u8,</div><div>                 ) void {</div><div class="diff-removed">-                    const ud = @as(?*Userdata, if (Userdata == void) null else @ptrCast(@alignCast(ud_)));</div><div class="diff-added">+                    const ud = @as(?*Userdata, if (Userdata == void) null else @ptrCast(ud_?));</div><div>                     @call(.always_inline, cb, .{ ud, l_inner, c_inner, r });</div><div>                 }</div><div class="diff-removed">-            }).callback,</div><div class="diff-added">+            })._callback,</div><div>             .userdata = userdata,</div><div class="diff-removed">-            .timer = xev.Timer.init() catch unreachable, // not great, but xev timer can't fail atm</div><div class="diff-added">+            .timer = xev.Timer.init() catch unreachable,</div><div>         };</div><div> </div><div>         switch (self.state) {</div><div class="diff-info">@@ -202,7 +170,7 @@ pub const FlatpakHostCommand = struct {</div><div>             anyopaque,</div><div>             completion.userdata,</div><div>             (struct {</div><div class="diff-removed">-                fn callback(</div><div class="diff-added">+                fn _callback(</div><div>                     ud: ?*anyopaque,</div><div>                     l_inner: *xev.Loop,</div><div>                     c_inner: *xev.Completion,</div><div class="diff-info">@@ -211,16 +179,15 @@ pub const FlatpakHostCommand = struct {</div><div>                     const c_outer: *Completion = @fieldParentPtr("c_xev", c_inner);</div><div>                     defer if (c_outer.timer) |*t| t.deinit();</div><div> </div><div class="diff-removed">-                    const result = if (r) |_| c_outer.result.? else |err| err;</div><div class="diff-added">+                    const result = if (r) |_| c_outer.result.? else |e| e;</div><div>                     c_outer.callback(ud, l_inner, c_outer, result);</div><div>                     return .disarm;</div><div>                 }</div><div class="diff-removed">-            }).callback,</div><div class="diff-added">+            })._callback,</div><div>         );</div><div>     }</div><div> </div><div class="diff-removed">-    /// Send a signal to the started command. This does nothing if the</div><div class="diff-removed">-    /// command is not in the started state.</div><div class="diff-added">+    /// Send a signal to the started command (if started).</div><div>     pub fn signal(self: *FlatpakHostCommand, sig: u8, pg: bool) !void {</div><div>         const pid = pid: {</div><div>             self.state_mutex.lock();</div><div class="diff-info">@@ -231,11 +198,10 @@ pub const FlatpakHostCommand = struct {</div><div>             }</div><div>         };</div><div> </div><div class="diff-removed">-        // Get our bus connection.</div><div>         var g_err: [*c]c.GError = null;</div><div>         const bus = c.g_bus_get_sync(c.G_BUS_TYPE_SESSION, null, &g_err) orelse {</div><div>             log.warn("signal error getting bus: {s}", .{g_err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-added">+            return Error.FlatpadSetupFail;</div><div>         };</div><div>         defer c.g_object_unref(bus);</div><div> </div><div class="diff-info">@@ -249,7 +215,7 @@ pub const FlatpakHostCommand = struct {</div><div>                 "(uub)",</div><div>                 pid,</div><div>                 sig,</div><div class="diff-removed">-                @as(c_int, @intCast(@intFromBool(pg))),</div><div class="diff-added">+                @as(c_int, @intFromBool(pg)),</div><div>             ),</div><div>             c.G_VARIANT_TYPE("()"),</div><div>             c.G_DBUS_CALL_FLAGS_NONE,</div><div class="diff-info">@@ -257,27 +223,25 @@ pub const FlatpakHostCommand = struct {</div><div>             null,</div><div>             &g_err,</div><div>         );</div><div class="diff-removed">-        if (g_err != null) {</div><div class="diff-removed">-            log.warn("signal send error: {s}", .{g_err.*.message});</div><div class="diff-added">+        if (g_err) |err| {</div><div class="diff-added">+            log.warn("signal send error: {s}", .{err.*.message});</div><div>             return;</div><div>         }</div><div>         defer c.g_variant_unref(reply);</div><div>     }</div><div> </div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div class="diff-added">+    // Internal implementation</div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div>     fn threadMain(self: *FlatpakHostCommand, alloc: Allocator) void {</div><div class="diff-removed">-        // Create a new thread-local context so that all our sources go</div><div class="diff-removed">-        // to this context and we can run our loop correctly.</div><div>         const ctx = c.g_main_context_new();</div><div>         defer c.g_main_context_unref(ctx);</div><div>         c.g_main_context_push_thread_default(ctx);</div><div>         defer c.g_main_context_pop_thread_default(ctx);</div><div> </div><div class="diff-removed">-        // Get our loop for the current thread</div><div class="diff-removed">-        const loop = c.g_main_loop_new(ctx, 1).?;</div><div class="diff-added">+        const loop = c.g_main_loop_new(c.g_main_context_get_thread_default(), 1).?;</div><div>         defer c.g_main_loop_unref(loop);</div><div> </div><div class="diff-removed">-        // Get our bus connection. This has to remain active until we exit</div><div class="diff-removed">-        // the thread otherwise our signals won't be called.</div><div>         var g_err: [*c]c.GError = null;</div><div>         const bus = c.g_bus_get_sync(c.G_BUS_TYPE_SESSION, null, &g_err) orelse {</div><div>             log.warn("spawn error getting bus: {s}", .{g_err.*.message});</div><div class="diff-info">@@ -286,22 +250,14 @@ pub const FlatpakHostCommand = struct {</div><div>         };</div><div>         defer c.g_object_unref(bus);</div><div> </div><div class="diff-removed">-        // Spawn the command first. This will setup all our IO.</div><div>         self.start(alloc, bus, loop) catch |err| {</div><div>             log.warn("error starting host command: {}", .{err});</div><div>             self.updateState(.{ .err = {} });</div><div>             return;</div><div>         };</div><div class="diff-removed">-</div><div class="diff-removed">-        // Run the event loop. It quits in the exit callback.</div><div>         c.g_main_loop_run(loop);</div><div>     }</div><div> </div><div class="diff-removed">-    /// Start the command. This will start the host command and set the</div><div class="diff-removed">-    /// pid field on success. This will not wait for completion.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Once this is called, the self pointer MUST remain stable. This</div><div class="diff-removed">-    /// requirement is due to using GLib under the covers with callbacks.</div><div>     fn start(</div><div>         self: *FlatpakHostCommand,</div><div>         alloc: Allocator,</div><div class="diff-info">@@ -309,72 +265,69 @@ pub const FlatpakHostCommand = struct {</div><div>         loop: *c.GMainLoop,</div><div>     ) !void {</div><div>         var err: [*c]c.GError = null;</div><div class="diff-removed">-        var arena_allocator = std.heap.ArenaAllocator.init(alloc);</div><div class="diff-removed">-        defer arena_allocator.deinit();</div><div class="diff-removed">-        const arena = arena_allocator.allocator();</div><div> </div><div class="diff-removed">-        // Our list of file descriptors that we need to send to the process.</div><div class="diff-added">+        // Setup fd list</div><div>         const fd_list = c.g_unix_fd_list_new();</div><div>         defer c.g_object_unref(fd_list);</div><div>         if (c.g_unix_fd_list_append(fd_list, self.stdin, &err) < 0) {</div><div>             log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-added">+            return error.FlatpakSetupFail;</div><div>         }</div><div>         if (c.g_unix_fd_list_append(fd_list, self.stdout, &err) < 0) {</div><div>             log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-added">+            return error.FlatpakSetupFail;</div><div>         }</div><div>         if (c.g_unix_fd_list_append(fd_list, self.stderr, &err) < 0) {</div><div>             log.warn("error adding fd: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakSetupFail;</div><div class="diff-added">+            return error.FlatpakSetupFail;</div><div>         }</div><div> </div><div class="diff-removed">-        // Build our arguments for the file descriptors.</div><div class="diff-added">+        // Build fd variant</div><div>         const fd_builder = c.g_variant_builder_new(c.G_VARIANT_TYPE("a{uh}"));</div><div>         defer c.g_variant_builder_unref(fd_builder);</div><div>         c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 0), self.stdin);</div><div>         c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 1), self.stdout);</div><div>         c.g_variant_builder_add(fd_builder, "{uh}", @as(c_int, 2), self.stderr);</div><div> </div><div class="diff-removed">-        // Build our env vars</div><div class="diff-added">+        // env</div><div>         const env_builder = c.g_variant_builder_new(c.G_VARIANT_TYPE("a{ss}"));</div><div>         defer c.g_variant_builder_unref(env_builder);</div><div>         if (self.env) |env| {</div><div>             var it = env.iterator();</div><div>             while (it.next()) |pair| {</div><div class="diff-removed">-                const key = try arena.dupeZ(u8, pair.key_ptr.*);</div><div class="diff-removed">-                const value = try arena.dupeZ(u8, pair.value_ptr.*);</div><div class="diff-removed">-                c.g_variant_builder_add(env_builder, "{ss}", key.ptr, value.ptr);</div><div class="diff-added">+                const key = try alloc.dupeZ(u8, pair.key);</div><div class="diff-added">+                const val = try alloc.dupeZ(u8, pair.value);</div><div class="diff-added">+                c.g_variant_builder_add(env_builder, "{ss}", key.ptr, val.ptr);</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Build our args</div><div class="diff-removed">-        const args = try arena.alloc(?[*:0]u8, self.argv.len + 1);</div><div class="diff-removed">-        for (0.., self.argv) |i, arg| {</div><div class="diff-removed">-            const argZ = try arena.dupeZ(u8, arg);</div><div class="diff-removed">-            args[i] = argZ.ptr;</div><div class="diff-added">+        // Build args array (null-terminated)</div><div class="diff-added">+        const args = try alloc.alloc(?[*:0]u8, self.argv.len + 1);</div><div class="diff-added">+        defer alloc.free(args);</div><div class="diff-added">+        for (self.argv, 0..) |arg, i| {</div><div class="diff-added">+            const dup = try alloc.dupeZ(u8, arg);</div><div class="diff-added">+            args[i] = dup.ptr;</div><div>         }</div><div>         args[args.len - 1] = null;</div><div class="diff-added">+        const args_ptr = @ptrCast([*]const ?[*:0]u8, args.ptr);</div><div> </div><div class="diff-removed">-        // Get the cwd in case we don't have ours set. A small optimization</div><div class="diff-removed">-        // would be to do this only if we need it but this isn't a</div><div class="diff-removed">-        // common code path.</div><div class="diff-added">+        // cwd</div><div>         const g_cwd = c.g_get_current_dir();</div><div>         defer c.g_free(g_cwd);</div><div> </div><div class="diff-removed">-        // The params for our RPC call</div><div class="diff-added">+        // Params</div><div>         const params = c.g_variant_new(</div><div>             "(^ay^aay@a{uh}@a{ss}u)",</div><div class="diff-removed">-            @as(*const anyopaque, if (self.cwd) |*cwd| cwd.ptr else g_cwd),</div><div class="diff-removed">-            args.ptr,</div><div class="diff-added">+            @as(*const anyopaque, if (self.cwd) |*c| c.ptr else g_cwd),</div><div class="diff-added">+            args_ptr,</div><div>             c.g_variant_builder_end(fd_builder),</div><div>             c.g_variant_builder_end(env_builder),</div><div>             @as(c_int, 0),</div><div>         );</div><div class="diff-removed">-        _ = c.g_variant_ref_sink(params); // take ownership</div><div class="diff-added">+        _ = c.g_variant_ref_sink(params);</div><div>         defer c.g_variant_unref(params);</div><div> </div><div class="diff-removed">-        // Subscribe to exit notifications</div><div class="diff-added">+        // Subscribe to exit signal</div><div>         const subscription_id = c.g_dbus_connection_signal_subscribe(</div><div>             bus,</div><div>             "org.freedesktop.Flatpak",</div><div class="diff-info">@@ -387,9 +340,9 @@ pub const FlatpakHostCommand = struct {</div><div>             self,</div><div>             null,</div><div>         );</div><div class="diff-removed">-        errdefer c.g_dbus_connection_signal_unsubscribe(bus, subscription_id);</div><div class="diff-added">+        defer c.g_dbus_connection_signal_unsubscribe(bus, subscription_id);</div><div> </div><div class="diff-removed">-        // Go!</div><div class="diff-added">+        // Call HostCommand</div><div>         const reply = c.g_dbus_connection_call_with_unix_fd_list_sync(</div><div>             bus,</div><div>             "org.freedesktop.Flatpak",</div><div class="diff-info">@@ -406,7 +359,7 @@ pub const FlatpakHostCommand = struct {</div><div>             &err,</div><div>         ) orelse {</div><div>             log.warn("Flatpak.HostCommand failed: {s}", .{err.*.message});</div><div class="diff-removed">-            return Error.FlatpakRPCFail;</div><div class="diff-added">+            return error.FlatpakRPCFail;</div><div>         };</div><div>         defer c.g_variant_unref(reply);</div><div> </div><div class="diff-info">@@ -428,14 +381,16 @@ pub const FlatpakHostCommand = struct {</div><div>         });</div><div>     }</div><div> </div><div class="diff-removed">-    /// Helper to update the state and notify waiters via the cv.</div><div class="diff-removed">-    fn updateState(self: *FlatpakHostCommand, state: State) void {</div><div class="diff-added">+    fn updateState(self: *FlatpakHostCommand, s: State) void {</div><div>         self.state_mutex.lock();</div><div>         defer self.state_mutex.unlock();</div><div class="diff-removed">-        defer self.state_cv.broadcast();</div><div class="diff-removed">-        self.state = state;</div><div class="diff-added">+        self.state = s;</div><div class="diff-added">+        self.state_cv.broadcast();</div><div>     }</div><div> </div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div class="diff-added">+    // Signal handlers</div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div>     fn onExit(</div><div>         bus: ?*c.GDBusConnection,</div><div>         _: [*c]const u8,</div><div class="diff-info">@@ -445,59 +400,34 @@ pub const FlatpakHostCommand = struct {</div><div>         params: ?*c.GVariant,</div><div>         ud: ?*anyopaque,</div><div>     ) callconv(.C) void {</div><div class="diff-removed">-        const self = @as(*FlatpakHostCommand, @ptrCast(@alignCast(ud)));</div><div class="diff-removed">-        const state = state: {</div><div class="diff-added">+        const self = @as(*FlatpakHostCommand, @alignCast(@ptrCast(ud)));</div><div class="diff-added">+</div><div class="diff-added">+        const state = blk: {</div><div>             self.state_mutex.lock();</div><div>             defer self.state_mutex.unlock();</div><div class="diff-removed">-            break :state self.state.started;</div><div class="diff-removed">-        };</div><div class="diff-added">+                break :blk self.state.started;</div><div class="diff-added">+            };</div><div> </div><div>         var pid: u32 = 0;</div><div class="diff-removed">-        var exit_status_raw: u32 = 0;</div><div class="diff-removed">-        c.g_variant_get(params.?, "(uu)", &pid, &exit_status_raw);</div><div class="diff-added">+        var exit_raw: u32 = 0;</div><div class="diff-added">+        c.g_variant_get(params.?, "(uu)", &pid, &exit_raw);</div><div>         if (state.pid != pid) return;</div><div> </div><div class="diff-removed">-        const exit_status = posix.W.EXITSTATUS(exit_status_raw);</div><div class="diff-removed">-        // Update our state</div><div class="diff-added">+        const exit_status = posix.W.EXITSTATUS(exit_raw);</div><div>         self.updateState(.{</div><div>             .exited = .{</div><div>                 .pid = pid,</div><div class="diff-removed">-                .status = exit_status,</div><div class="diff-added">+                .status = @intCast(u8, exit_status),</div><div>             },</div><div>         });</div><div class="diff-removed">-        if (state.completion) |completion| {</div><div class="diff-removed">-            completion.result = exit_status;</div><div class="diff-removed">-            completion.timer.?.run(</div><div class="diff-removed">-                state.loop_xev.?,</div><div class="diff-removed">-                &completion.c_xev,</div><div class="diff-removed">-                0,</div><div class="diff-removed">-                anyopaque,</div><div class="diff-removed">-                completion.userdata,</div><div class="diff-removed">-                (struct {</div><div class="diff-removed">-                    fn callback(</div><div class="diff-removed">-                        ud_inner: ?*anyopaque,</div><div class="diff-removed">-                        l_inner: *xev.Loop,</div><div class="diff-removed">-                        c_inner: *xev.Completion,</div><div class="diff-removed">-                        r: xev.Timer.RunError!void,</div><div class="diff-removed">-                    ) xev.CallbackAction {</div><div class="diff-removed">-                        const c_outer: *Completion = @fieldParentPtr("c_xev", c_inner);</div><div class="diff-removed">-                        defer if (c_outer.timer) |*t| t.deinit();</div><div class="diff-removed">-</div><div class="diff-removed">-                        const result = if (r) |_| c_outer.result.? else |err| err;</div><div class="diff-removed">-                        c_outer.callback(ud_inner, l_inner, c_outer, result);</div><div class="diff-removed">-                        return .disarm;</div><div class="diff-removed">-                    }</div><div class="diff-removed">-                }).callback,</div><div class="diff-removed">-            );</div><div class="diff-removed">-        }</div><div>         log.debug("HostCommand exited pid={} status={}", .{ pid, exit_status });</div><div> </div><div class="diff-removed">-        // We're done now, so we can unsubscribe</div><div>         c.g_dbus_connection_signal_unsubscribe(bus.?, state.subscription);</div><div class="diff-removed">-</div><div class="diff-removed">-        // We are also done with our loop so we can exit.</div><div>         c.g_main_loop_quit(state.loop);</div><div>     }</div><div> </div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div class="diff-added">+    // Helper</div><div class="diff-added">+    // -------------------------------------------------------------------------</div><div>     fn noopCallback(_: ?*anyopaque, _: *xev.Loop, _: *Completion, _: WaitError!u8) void {}</div><div> };</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    