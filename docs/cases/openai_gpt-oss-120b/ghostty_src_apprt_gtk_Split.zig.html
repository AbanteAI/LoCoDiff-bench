<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/apprt/gtk/Split.zig - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/apprt/gtk/Split.zig</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../models/openai_gpt-oss-120b.html">All GPT OSS 120B Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT OSS 120B</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 24834</p>
                <p><strong>Native Prompt Tokens:</strong> 24928</p>
                <p><strong>Native Completion Tokens:</strong> 7005</p>
                <p><strong>Native Tokens Reasoning:</strong> 5393</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.00899295</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_apprt_gtk_Split.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_apprt_gtk_Split.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_apprt_gtk_Split.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 9abf5d134..935814c38 100644</div><div class="diff-header">--- a/ghostty_src_apprt_gtk_Split.zig_expectedoutput.txt (expected):tmp/tmprjx7htqc_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_apprt_gtk_Split.zig_extracted.txt (actual):tmp/tmpu6ky811x_actual.txt	</div><div class="diff-info">@@ -1,7 +1,4 @@</div><div class="diff-removed">-/// Split represents a surface split where two surfaces are shown side-by-side</div><div class="diff-removed">-/// within the same window either vertically or horizontally.</div><div> const Split = @This();</div><div class="diff-removed">-</div><div> const std = @import("std");</div><div> const Allocator = std.mem.Allocator;</div><div> const assert = std.debug.assert;</div><div class="diff-info">@@ -9,7 +6,7 @@ const assert = std.debug.assert;</div><div> const gobject = @import("gobject");</div><div> const gtk = @import("gtk");</div><div> </div><div class="diff-removed">-const apprt = @import("../../apprt.zig");</div><div class="diff-added">+const appr = @import("../../apprt.zig");</div><div> const font = @import("../../font/main.zig");</div><div> const CoreSurface = @import("../../Surface.zig");</div><div> </div><div class="diff-info">@@ -23,14 +20,14 @@ pub const Orientation = enum {</div><div>     horizontal,</div><div>     vertical,</div><div> </div><div class="diff-removed">-    pub fn fromDirection(direction: apprt.action.SplitDirection) Orientation {</div><div class="diff-added">+    pub fn fromDirection(direction: appr.action.SplitDirection) Orientation {</div><div>         return switch (direction) {</div><div>             .right, .left => .horizontal,</div><div>             .down, .up => .vertical,</div><div>         };</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn fromResizeDirection(direction: apprt.action.ResizeSplit.Direction) Orientation {</div><div class="diff-added">+    pub fn fromResizeDirection(direction: appr.action.ResizeSplit.Direction) Orientation {</div><div>         return switch (direction) {</div><div>             .up, .down => .vertical,</div><div>             .left, .right => .horizontal,</div><div class="diff-info">@@ -38,7 +35,7 @@ pub const Orientation = enum {</div><div>     }</div><div> };</div><div> </div><div class="diff-removed">-/// Our actual GtkPaned widget</div><div class="diff-added">+/// Our actual GtkPaned widget.</div><div> paned: *gtk.Paned,</div><div> </div><div> /// The container for this split panel.</div><div class="diff-info">@@ -51,16 +48,11 @@ orientation: Orientation,</div><div> top_left: Surface.Container.Elem,</div><div> bottom_right: Surface.Container.Elem,</div><div> </div><div class="diff-removed">-/// Create a new split panel with the given sibling surface in the given</div><div class="diff-removed">-/// direction. The direction is where the new surface will be initialized.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// The sibling surface can be in a split already or it can be within a</div><div class="diff-removed">-/// tab. This properly handles updating the surface container so that</div><div class="diff-removed">-/// it represents the new split.</div><div class="diff-added">+/// Create a new split panel.</div><div> pub fn create(</div><div>     alloc: Allocator,</div><div>     sibling: *Surface,</div><div class="diff-removed">-    direction: apprt.action.SplitDirection,</div><div class="diff-added">+    direction: appr.action.SplitDirection,</div><div> ) !*Split {</div><div>     var split = try alloc.create(Split);</div><div>     errdefer alloc.destroy(split);</div><div class="diff-info">@@ -71,21 +63,11 @@ pub fn create(</div><div> pub fn init(</div><div>     self: *Split,</div><div>     sibling: *Surface,</div><div class="diff-removed">-    direction: apprt.action.SplitDirection,</div><div class="diff-added">+    direction: appr.action.SplitDirection,</div><div> ) !void {</div><div class="diff-removed">-    // If our sibling is too small to be split in half then we don't</div><div class="diff-removed">-    // allow the split to happen. This avoids a situation where the</div><div class="diff-removed">-    // split becomes too small.</div><div class="diff-removed">-    //</div><div class="diff-removed">-    // This is kind of a hack. Ideally we'd use gtk_widget_set_size_request</div><div class="diff-removed">-    // properly along the path to ensure minimum sizes. I don't know if</div><div class="diff-removed">-    // GTK even respects that all but any way GTK does this for us seems</div><div class="diff-removed">-    // better than this.</div><div class="diff-added">+    // If our sibling is too small to be split in half we prevent the split.</div><div>     {</div><div class="diff-removed">-        // This is the min size of the sibling split. This means the</div><div class="diff-removed">-        // smallest split is half of this.</div><div>         const multiplier = 4;</div><div class="diff-removed">-</div><div>         const size = &sibling.core_surface.size;</div><div>         const small = switch (direction) {</div><div>             .right, .left => size.screen.width < size.cell.width * multiplier,</div><div class="diff-info">@@ -94,7 +76,7 @@ pub fn init(</div><div>         if (small) return error.SplitTooSmall;</div><div>     }</div><div> </div><div class="diff-removed">-    // Create the new child surface for the other direction.</div><div class="diff-added">+    // Create the new child surface.</div><div>     const alloc = sibling.app.core_app.alloc;</div><div>     var surface = try Surface.create(alloc, sibling.app, .{</div><div>         .parent = &sibling.core_surface,</div><div class="diff-info">@@ -102,8 +84,9 @@ pub fn init(</div><div>     errdefer surface.destroy(alloc);</div><div>     sibling.dimSurface();</div><div>     sibling.setSplitZoom(false);</div><div class="diff-added">+    sibling.setSplitZoom(false);</div><div> </div><div class="diff-removed">-    // Create the actual GTKPaned, attach the proper children.</div><div class="diff-added">+    // Create the actual GtkPaned widget.</div><div>     const orientation: gtk.Orientation = switch (direction) {</div><div>         .right, .left => .horizontal,</div><div>         .down, .up => .vertical,</div><div class="diff-info">@@ -114,11 +97,7 @@ pub fn init(</div><div>     // Keep a long-lived reference, which we unref in destroy.</div><div>     paned.ref();</div><div> </div><div class="diff-removed">-    // Update all of our containers to point to the right place.</div><div class="diff-removed">-    // The split has to point to where the sibling pointed to because</div><div class="diff-removed">-    // we're inheriting its parent. The sibling points to its location</div><div class="diff-removed">-    // in the split, and the surface points to the other location.</div><div class="diff-removed">-    const container = sibling.container;</div><div class="diff-added">+    // Determine the top/left and bottom/right elements.</div><div>     const tl: *Surface, const br: *Surface = switch (direction) {</div><div>         .right, .down => right_down: {</div><div>             sibling.container = .{ .split_tl = &self.top_left };</div><div class="diff-info">@@ -135,20 +114,19 @@ pub fn init(</div><div> </div><div>     self.* = .{</div><div>         .paned = paned,</div><div class="diff-removed">-        .container = container,</div><div class="diff-added">+        .container = self.container,</div><div>         .top_left = .{ .surface = tl },</div><div>         .bottom_right = .{ .surface = br },</div><div>         .orientation = Orientation.fromDirection(direction),</div><div>     };</div><div> </div><div class="diff-removed">-    // Replace the previous containers element with our split. This allows a</div><div class="diff-removed">-    // non-split to become a split, a split to become a nested split, etc.</div><div class="diff-removed">-    container.replace(.{ .split = self });</div><div class="diff-added">+    // Replace the previous container's element with this split.</div><div class="diff-added">+    self.container.replace(.{ .split = self });</div><div> </div><div class="diff-removed">-    // Update our children so that our GL area is properly added to the paned.</div><div class="diff-added">+    // Update children so GL areas are correctly attached.</div><div>     self.updateChildren();</div><div> </div><div class="diff-removed">-    // The new surface should always grab focus</div><div class="diff-added">+    // Focus the new surface.</div><div>     surface.grabFocus();</div><div> }</div><div> </div><div class="diff-info">@@ -156,23 +134,13 @@ pub fn destroy(self: *Split, alloc: Allocator) void {</div><div>     self.top_left.deinit(alloc);</div><div>     self.bottom_right.deinit(alloc);</div><div> </div><div class="diff-removed">-    // Clean up our GTK reference. This will trigger all the destroy callbacks</div><div class="diff-removed">-    // that are necessary for the surfaces to clean up.</div><div class="diff-added">+    // Clean up our GTK reference. This triggers destroy callbacks.</div><div>     self.paned.unref();</div><div> </div><div>     alloc.destroy(self);</div><div> }</div><div> </div><div class="diff-removed">-/// Remove the top left child.</div><div class="diff-removed">-pub fn removeTopLeft(self: *Split) void {</div><div class="diff-removed">-    self.removeChild(self.top_left, self.bottom_right);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Remove the top left child.</div><div class="diff-removed">-pub fn removeBottomRight(self: *Split) void {</div><div class="diff-removed">-    self.removeChild(self.bottom_right, self.top_left);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+// Remove a child element, making this split a regular container.</div><div> fn removeChild(</div><div>     self: *Split,</div><div>     remove: Surface.Container.Elem,</div><div class="diff-info">@@ -181,29 +149,27 @@ fn removeChild(</div><div>     const window = self.container.window() orelse return;</div><div>     const alloc = window.app.core_app.alloc;</div><div> </div><div class="diff-removed">-    // Remove our children since we are going to no longer be a split anyways.</div><div class="diff-removed">-    // This prevents widgets with multiple parents.</div><div class="diff-added">+    // Remove our children since we no longer are a split.</div><div>     self.removeChildren();</div><div> </div><div class="diff-removed">-    // Our container must become whatever our top left is</div><div class="diff-added">+    // Our container now points at the remaining element.</div><div>     self.container.replace(keep);</div><div> </div><div class="diff-removed">-    // Grab focus of the left-over side</div><div class="diff-added">+    // Focus the remaining side.</div><div>     keep.grabFocus();</div><div> </div><div class="diff-removed">-    // When a child is removed we are no longer a split, so destroy ourself</div><div class="diff-added">+    // When a child is removed we are no longer a split.</div><div>     remove.deinit(alloc);</div><div>     alloc.destroy(self);</div><div> }</div><div> </div><div class="diff-removed">-/// Move the divider in the given direction by the given amount.</div><div class="diff-added">+// Move the divider in the given direction by the given amount.</div><div> pub fn moveDivider(</div><div>     self: *Split,</div><div class="diff-removed">-    direction: apprt.action.ResizeSplit.Direction,</div><div class="diff-added">+    direction: appr.action.ResizeSplit.Direction,</div><div>     amount: u16,</div><div> ) void {</div><div>     const min_pos = 10;</div><div class="diff-removed">-</div><div>     const pos = self.paned.getPosition();</div><div>     const new = switch (direction) {</div><div>         .up, .left => @max(pos - amount, min_pos),</div><div class="diff-info">@@ -212,95 +178,59 @@ pub fn moveDivider(</div><div>             break :new_pos @min(pos + amount, max_pos);</div><div>         },</div><div>     };</div><div class="diff-removed">-</div><div>     self.paned.setPosition(new);</div><div> }</div><div> </div><div class="diff-removed">-/// Equalize the splits in this split panel. Each split is equalized based on</div><div class="diff-removed">-/// its weight, i.e. the number of Surfaces it contains.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It works recursively by equalizing the children of each split.</div><div class="diff-removed">-///</div><div class="diff-removed">-/// It returns this split's weight.</div><div class="diff-added">+// Equalize splits based on weight.</div><div> pub fn equalize(self: *Split) f64 {</div><div class="diff-removed">-    // Calculate weights of top_left/bottom_right</div><div class="diff-added">+    // Compute weights of child elements.</div><div>     const top_left_weight = self.top_left.equalize();</div><div>     const bottom_right_weight = self.bottom_right.equalize();</div><div>     const weight = top_left_weight + bottom_right_weight;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Ratio of top_left weight to overall weight, which gives the split ratio</div><div>     const ratio = top_left_weight / weight;</div><div> </div><div class="diff-removed">-    // Convert split ratio into new position for divider</div><div class="diff-added">+    // Set divider position based on weight ratio.</div><div>     self.paned.setPosition(@intFromFloat(self.maxPosition() * ratio));</div><div> </div><div>     return weight;</div><div> }</div><div> </div><div class="diff-removed">-// maxPosition returns the maximum position of the GtkPaned, which is the</div><div class="diff-removed">-// "max-position" attribute.</div><div class="diff-added">+// Returns the max position of the GtkPaned ("max-position" property).</div><div> fn maxPosition(self: *Split) f64 {</div><div>     var value: gobject.Value = std.mem.zeroes(gobject.Value);</div><div>     defer value.unset();</div><div> </div><div>     _ = value.init(gobject.ext.types.int);</div><div class="diff-removed">-    self.paned.as(gobject.Object).getProperty(</div><div class="diff-removed">-        "max-position",</div><div class="diff-removed">-        &value,</div><div class="diff-removed">-    );</div><div class="diff-removed">-</div><div class="diff-added">+    self.paned.as(gobject.Object).getProperty("max-position", &value);</div><div>     return @floatFromInt(value.getInt());</div><div> }</div><div> </div><div class="diff-removed">-// This replaces the element at the given pointer with a new element.</div><div class="diff-removed">-// The ptr must be either top_left or bottom_right (asserted in debug).</div><div class="diff-removed">-// The memory of the old element must be freed or otherwise handled by</div><div class="diff-removed">-// the caller.</div><div class="diff-added">+// Replace an element at the given pointer.</div><div> pub fn replace(</div><div>     self: *Split,</div><div>     ptr: *Surface.Container.Elem,</div><div>     new: Surface.Container.Elem,</div><div> ) void {</div><div class="diff-removed">-    // We can write our element directly. There's nothing special.</div><div class="diff-removed">-    assert(&self.top_left == ptr or &self.bottom_right == ptr);</div><div class="diff-removed">-    ptr.* = new;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Update our paned children. This will reset the divider</div><div class="diff-removed">-    // position but we want to keep it in place so save and restore it.</div><div class="diff-removed">-    const pos = self.paned.getPosition();</div><div class="diff-removed">-    defer self.paned.setPosition(pos);</div><div class="diff-added">+    const saved = self.paned.getPosition();</div><div class="diff-added">+    defer self.paned.setPosition(saved);</div><div class="diff-added">+    *ptr = new;</div><div>     self.updateChildren();</div><div> }</div><div> </div><div class="diff-removed">-// grabFocus grabs the focus of the top-left element.</div><div class="diff-removed">-pub fn grabFocus(self: *Split) void {</div><div class="diff-removed">-    self.top_left.grabFocus();</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Update the paned children to represent the current state.</div><div class="diff-removed">-/// This should be called anytime the top/left or bottom/right</div><div class="diff-removed">-/// element is changed.</div><div class="diff-added">+// Update children widgets.</div><div> pub fn updateChildren(self: *const Split) void {</div><div class="diff-removed">-    // We have to set both to null. If we overwrite the pane with</div><div class="diff-removed">-    // the same value, then GTK bugs out (the GL area unrealizes</div><div class="diff-removed">-    // and never rerealizes).</div><div>     self.removeChildren();</div><div class="diff-removed">-</div><div class="diff-removed">-    // Set our current children</div><div>     self.paned.setStartChild(self.top_left.widget());</div><div>     self.paned.setEndChild(self.bottom_right.widget());</div><div> }</div><div> </div><div class="diff-removed">-/// A mapping of direction to the element (if any) in that direction.</div><div class="diff-added">+// Mapping of directions to elements.</div><div> pub const DirectionMap = std.EnumMap(</div><div class="diff-removed">-    apprt.action.GotoSplit,</div><div class="diff-added">+    appr.action.GotoSplit,</div><div>     ?*Surface,</div><div> );</div><div> </div><div class="diff-removed">-pub const Side = enum { top_left, bottom_right };</div><div class="diff-removed">-</div><div class="diff-removed">-/// Returns the map that can be used to determine elements in various</div><div class="diff-removed">-/// directions (primarily for gotoSplit).</div><div class="diff-added">+// Map of directional navigation.</div><div> pub fn directionMap(self: *const Split, from: Side) DirectionMap {</div><div>     var result = DirectionMap.initFull(null);</div><div> </div><div class="diff-info">@@ -308,6 +238,7 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {</div><div>         result.put(.previous, prev.surface);</div><div>         if (!prev.wrapped) {</div><div>             result.put(.up, prev.surface);</div><div class="diff-added">+            result.put(.left, prev.surface);</div><div>         }</div><div>     }</div><div> </div><div class="diff-info">@@ -315,8 +246,9 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {</div><div>         result.put(.next, next.surface);</div><div>         if (!next.wrapped) {</div><div>             result.put(.down, next.surface);</div><div class="diff-added">+                result.put(.right, next.surface);</div><div class="diff-added">+            }</div><div>         }</div><div class="diff-removed">-    }</div><div> </div><div>     if (self.directionLeft(from)) |left| {</div><div>         result.put(.left, left);</div><div class="diff-info">@@ -329,113 +261,84 @@ pub fn directionMap(self: *const Split, from: Side) DirectionMap {</div><div>     return result;</div><div> }</div><div> </div><div class="diff-removed">-fn directionLeft(self: *const Split, from: Side) ?*Surface {</div><div class="diff-removed">-    switch (from) {</div><div class="diff-removed">-        .bottom_right => {</div><div class="diff-removed">-            switch (self.orientation) {</div><div class="diff-removed">-                .horizontal => return self.top_left.deepestSurface(.bottom_right),</div><div class="diff-removed">-                .vertical => return directionLeft(</div><div class="diff-removed">-                    self.container.split() orelse return null,</div><div class="diff-removed">-                    .bottom_right,</div><div class="diff-removed">-                ),</div><div class="diff-removed">-            }</div><div class="diff-removed">-        },</div><div class="diff-removed">-        .top_left => return directionLeft(</div><div class="diff-removed">-            self.container.split() orelse return null,</div><div class="diff-removed">-            .bottom_right,</div><div class="diff-removed">-        ),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-fn directionRight(self: *const Split, from: Side) ?*Surface {</div><div class="diff-removed">-    switch (from) {</div><div class="diff-removed">-        .top_left => {</div><div class="diff-removed">-            switch (self.orientation) {</div><div class="diff-removed">-                .horizontal => return self.bottom_right.deepestSurface(.top_left),</div><div class="diff-removed">-                .vertical => return directionRight(</div><div class="diff-removed">-                    self.container.split() orelse return null,</div><div class="diff-removed">-                    .top_left,</div><div class="diff-removed">-                ),</div><div class="diff-removed">-            }</div><div class="diff-removed">-        },</div><div class="diff-removed">-        .bottom_right => return directionRight(</div><div class="diff-removed">-            self.container.split() orelse return null,</div><div class="diff-removed">-            .top_left,</div><div class="diff-removed">-        ),</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-added">+// Navigation: previous.</div><div> fn directionPrevious(self: *const Split, from: Side) ?struct {</div><div>     surface: *Surface,</div><div>     wrapped: bool,</div><div> } {</div><div>     switch (from) {</div><div class="diff-removed">-        // From the bottom right, our previous is the deepest surface</div><div class="diff-removed">-        // in the top-left of our own split.</div><div class="diff-removed">-        .bottom_right => return .{</div><div class="diff-removed">-            .surface = self.top_left.deepestSurface(.bottom_right) orelse return null,</div><div class="diff-removed">-            .wrapped = false,</div><div class="diff-removed">-        },</div><div class="diff-added">+        // From bottom right, previous is deepest surface in top left.</div><div class="diff-added">+        .bottom_right => return .{ .surface = self.top_left.deepestSurface(.bottom_right).?, .wrapped = false },</div><div> </div><div class="diff-removed">-        // From the top left its more complicated. It is the de</div><div>         .top_left => {</div><div class="diff-removed">-            // If we have no parent split then there can be no unwrapped prev.</div><div class="diff-removed">-            // We can still have a wrapped previous.</div><div>             const parent = self.container.split() orelse return .{</div><div>                 .surface = self.bottom_right.deepestSurface(.bottom_right) orelse return null,</div><div class="diff-removed">-                .wrapped = true,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            // The previous value is the previous of the side that we are.</div><div class="diff-removed">-            const side = self.container.splitSide() orelse return null;</div><div class="diff-removed">-            return switch (side) {</div><div class="diff-removed">-                .top_left => parent.directionPrevious(.top_left),</div><div class="diff-removed">-                .bottom_right => parent.directionPrevious(.bottom_right),</div><div class="diff-removed">-            };</div><div class="diff-removed">-        },</div><div class="diff-added">+                        .wrapped = true,</div><div class="diff-added">+                    };</div><div class="diff-added">+                const side = self.container.splitSide() orelse return null;</div><div class="diff-added">+                return switch (side) {</div><div class="diff-added">+                    .top_left => parent.directionPrevious(.top_left),</div><div class="diff-added">+                    .bottom_right => parent.directionPrevious(.bottom_right),</div><div class="diff-added">+                };</div><div class="diff-added">+            }</div><div>     }</div><div> }</div><div> </div><div class="diff-added">+// Navigation: next.</div><div> fn directionNext(self: *const Split, from: Side) ?struct {</div><div>     surface: *Surface,</div><div>     wrapped: bool,</div><div> } {</div><div>     switch (from) {</div><div class="diff-removed">-        // From the top left, our next is the earliest surface in the</div><div class="diff-removed">-        // top-left direction of the bottom-right side of our split. Fun!</div><div class="diff-removed">-        .top_left => return .{</div><div class="diff-removed">-            .surface = self.bottom_right.deepestSurface(.top_left) orelse return null,</div><div class="diff-removed">-            .wrapped = false,</div><div class="diff-removed">-        },</div><div class="diff-added">+        // From top left, next is deepest surface in bottom right.</div><div class="diff-added">+        .top_left => return .{ .surface = self.bottom_right.deepestSurface(.top_left) orelse return null, .wrapped = false },</div><div> </div><div class="diff-removed">-        // From the bottom right is more compliated. It is the deepest</div><div class="diff-removed">-        // (last) surface in the</div><div>         .bottom_right => {</div><div class="diff-removed">-            // If we have no parent split then there can be no next.</div><div>             const parent = self.container.split() orelse return .{</div><div class="diff-removed">-                .surface = self.top_left.deepestSurface(.top_left) orelse return null,</div><div class="diff-removed">-                .wrapped = true,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            // The previous value is the previous of the side that we are.</div><div class="diff-removed">-            const side = self.container.splitSide() orelse return null;</div><div class="diff-removed">-            return switch (side) {</div><div class="diff-removed">-                .top_left => parent.directionNext(.top_left),</div><div class="diff-removed">-                .bottom_right => parent.directionNext(.bottom_right),</div><div class="diff-removed">-            };</div><div class="diff-added">+                    .surface = self.top_left.deepestSurface(.top_left) orelse return null,</div><div class="diff-added">+                    .wrapped = true,</div><div class="diff-added">+                };</div><div class="diff-added">+                const side = self.container.splitSide() orelse return null;</div><div class="diff-added">+                return switch (side) {</div><div class="diff-added">+                    .top_left => parent.directionNext(.bottom_right),</div><div class="diff-added">+                    .bottom_right => parent.directionNext(.bottom_right),</div><div class="diff-added">+                };</div><div class="diff-added">+            }</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+// Horizontal navigation: left.</div><div class="diff-added">+fn directionLeft(self: *const Split, from: Side) ?*Surface {</div><div class="diff-added">+    switch (from) {</div><div class="diff-added">+        .bottom_right => switch (self.orientation) {</div><div class="diff-added">+            .horizontal => return self.top_left.deepestSurface(.bottom_right),</div><div class="diff-added">+            .vertical => self.container.split().?.directionLeft(.top_left),</div><div>         },</div><div class="diff-added">+        .top_left => self.container.split()?.directionLeft(.bottom_right),</div><div>     }</div><div> }</div><div> </div><div class="diff-added">+// Horizontal navigation: right.</div><div class="diff-added">+fn directionRight(self: *const Split, from: Side) ?*Surface {</div><div class="diff-added">+    switch (from) {</div><div class="diff-added">+        .top_left => switch (self.orientation) {</div><div class="diff-added">+            .horizontal => return self.bottom_right.deepestSurface(.top_left),</div><div class="diff-added">+            .vertical => self.container.split().?.directionRight(.bottom_right),</div><div class="diff-added">+        },</div><div class="diff-added">+        .bottom_right => self.split()?.directionRight(.top_left),</div><div class="diff-added">+    }</div><div class="diff-added">+}</div><div class="diff-added">+</div><div class="diff-added">+// Helper: detach children.</div><div> pub fn detachTopLeft(self: *const Split) void {</div><div>     self.paned.setStartChild(null);</div><div> }</div><div class="diff-removed">-</div><div> pub fn detachBottomRight(self: *const Split) void {</div><div>     self.paned.setEndChild(null);</div><div> }</div><div> </div><div class="diff-added">+// Remove children from the GtkPaned.</div><div> fn removeChildren(self: *const Split) void {</div><div class="diff-removed">-    self.detachTopLeft();</div><div class="diff-removed">-    self.detachBottomRight();</div><div class="diff-added">+    self.paned.setStartChild(null);</div><div class="diff-added">+    self.paned.setEndChild(null);</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    