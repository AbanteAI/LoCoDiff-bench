<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/update_handler.rs - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/update_handler.rs</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../models/openai_gpt-oss-120b.html">All GPT OSS 120B Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT OSS 120B</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 61348</p>
                <p><strong>Native Prompt Tokens:</strong> 61403</p>
                <p><strong>Native Completion Tokens:</strong> 10690</p>
                <p><strong>Native Tokens Reasoning:</strong> 7143</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.01722795</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_update_handler.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_update_handler.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/qdrant_lib_collection_src_update_handler.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index cb922e861..373bd9341 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_update_handler.rs_expectedoutput.txt (expected):tmp/tmpytov_86h_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_update_handler.rs_extracted.txt (actual):tmp/tmpkqqu30v5_actual.txt	</div><div class="diff-info">@@ -1,8 +1,8 @@</div><div> use std::cmp::min;</div><div> use std::collections::HashSet;</div><div> use std::path::{Path, PathBuf};</div><div class="diff-removed">-use std::sync::Arc;</div><div> use std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};</div><div class="diff-added">+use std::sync::Arc;</div><div> </div><div> use common::budget::ResourceBudget;</div><div> use common::counter::hardware_accumulator::HwMeasurementAcc;</div><div class="diff-info">@@ -16,50 +16,42 @@ use segment::index::hnsw_index::num_rayon_threads;</div><div> use segment::types::SeqNumberType;</div><div> use tokio::runtime::Handle;</div><div> use tokio::sync::mpsc::{self, Receiver, Sender};</div><div class="diff-removed">-use tokio::sync::{Mutex as TokioMutex, oneshot};</div><div class="diff-added">+use tokio::sync::{oneshot, Mutex as TokioMutex};</div><div> use tokio::task::{self, JoinHandle};</div><div class="diff-added">+use tokio::time::{timeout, Duration};</div><div> use tokio::time::error::Elapsed;</div><div class="diff-removed">-use tokio::time::{Duration, timeout};</div><div> </div><div> use crate::collection::payload_index_schema::PayloadIndexSchema;</div><div> use crate::collection_manager::collection_updater::CollectionUpdater;</div><div> use crate::collection_manager::holders::segment_holder::LockedSegmentHolder;</div><div class="diff-removed">-use crate::collection_manager::optimizers::segment_optimizer::{</div><div class="diff-removed">-    OptimizerThresholds, SegmentOptimizer,</div><div class="diff-removed">-};</div><div class="diff-added">+use crate::collection_manager::optimizers::segment_optimizer::{OptimizerThresholds, SegmentOptimizer};</div><div> use crate::collection_manager::optimizers::{Tracker, TrackerLog, TrackerStatus};</div><div class="diff-removed">-use crate::common::stoppable_task::{StoppableTaskHandle, spawn_stoppable};</div><div class="diff-added">+use crate::common::stoppable_task::{spawn_stoppable, StoppableTaskHandle};</div><div> use crate::config::CollectionParams;</div><div class="diff-removed">-use crate::operations::CollectionUpdateOperations;</div><div> use crate::operations::shared_storage_config::SharedStorageConfig;</div><div> use crate::operations::types::{CollectionError, CollectionResult};</div><div class="diff-added">+use crate::operations::CollectionUpdateOperations;</div><div> use crate::save_on_disk::SaveOnDisk;</div><div> use crate::shards::local_shard::LocalShardClocks;</div><div> use crate::wal::WalError;</div><div> use crate::wal_delta::LockedWal;</div><div> </div><div class="diff-removed">-/// Interval at which the optimizer worker cleans up old optimization handles</div><div class="diff-removed">-///</div><div class="diff-removed">-/// The longer the duration, the longer it  takes for panicked tasks to be reported.</div><div class="diff-removed">-const OPTIMIZER_CLEANUP_INTERVAL: Duration = Duration::from_secs(5);</div><div class="diff-removed">-</div><div> pub type Optimizer = dyn SegmentOptimizer + Sync + Send;</div><div> </div><div class="diff-removed">-/// Information, required to perform operation and notify regarding the result</div><div> #[derive(Debug)]</div><div> pub struct OperationData {</div><div>     /// Sequential number of the operation</div><div>     pub op_num: SeqNumberType,</div><div>     /// Operation</div><div>     pub operation: CollectionUpdateOperations,</div><div class="diff-removed">-    /// If operation was requested to wait for result</div><div class="diff-added">+    /// If operation should wait for commit</div><div>     pub wait: bool,</div><div>     /// Callback notification channel</div><div>     pub sender: Option<oneshot::Sender<CollectionResult<usize>>>,</div><div class="diff-added">+    /// Hardware measurements for this operation</div><div>     pub hw_measurements: HwMeasurementAcc,</div><div> }</div><div> </div><div class="diff-removed">-/// Signal, used to inform Updater process</div><div> #[derive(Debug)]</div><div> pub enum UpdateSignal {</div><div>     /// Requested operation to perform</div><div class="diff-info">@@ -72,7 +64,6 @@ pub enum UpdateSignal {</div><div>     Plunger(oneshot::Sender<()>),</div><div> }</div><div> </div><div class="diff-removed">-/// Signal, used to inform Optimization process</div><div> #[derive(PartialEq, Eq, Clone, Copy)]</div><div> pub enum OptimizerSignal {</div><div>     /// Sequential number of the operation</div><div class="diff-info">@@ -83,50 +74,51 @@ pub enum OptimizerSignal {</div><div>     Nop,</div><div> }</div><div> </div><div class="diff-removed">-/// Structure, which holds object, required for processing updates of the collection</div><div> pub struct UpdateHandler {</div><div class="diff-removed">-    shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+    /// Shared storage configuration</div><div class="diff-added">+    pub shared_storage_config: Arc<SharedStorageConfig>,</div><div class="diff-added">+    /// Payload index schema (saved on disk)</div><div>     payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>     /// List of used optimizers</div><div>     pub optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>     /// Log of optimizer statuses</div><div>     optimizers_log: Arc<Mutex<TrackerLog>>,</div><div class="diff-removed">-    /// Total number of optimized points since last start</div><div class="diff-added">+    /// Total number of successfully optimized points</div><div>     total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-    /// Global CPU budget in number of cores for all optimization tasks.</div><div class="diff-removed">-    /// Assigns CPU permits to tasks to limit overall resource utilization.</div><div class="diff-added">+    /// Global resource budget (CPU + IO)</div><div>     optimizer_resource_budget: ResourceBudget,</div><div>     /// How frequent can we flush data</div><div class="diff-removed">-    /// This parameter depends on the optimizer config and should be updated accordingly.</div><div>     pub flush_interval_sec: u64,</div><div class="diff-added">+    /// Segments holder</div><div>     segments: LockedSegmentHolder,</div><div class="diff-removed">-    /// Process, that listens updates signals and perform updates</div><div class="diff-added">+    /// Worker listening for updates</div><div>     update_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Process, that listens for post-update signals and performs optimization</div><div class="diff-added">+    /// Worker performing optimizations</div><div>     optimizer_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Process that periodically flushes segments and tries to truncate wal</div><div class="diff-added">+    /// Flush worker</div><div>     flush_worker: Option<JoinHandle<()>>,</div><div class="diff-removed">-    /// Sender to stop flush worker</div><div class="diff-added">+    /// Channel to stop flush worker</div><div>     flush_stop: Option<oneshot::Sender<()>>,</div><div class="diff-added">+    /// Tokio runtime handle</div><div>     runtime_handle: Handle,</div><div>     /// WAL, required for operations</div><div class="diff-added">+    #[allow(dead_code)]</div><div>     wal: LockedWal,</div><div class="diff-removed">-    /// Always keep this WAL version and later and prevent acknowledging/truncating from the WAL.</div><div class="diff-removed">-    /// This is used when other bits of code still depend on information in the WAL, such as the</div><div class="diff-removed">-    /// queue proxy shard.</div><div class="diff-removed">-    /// Defaults to `u64::MAX` to allow acknowledging all confirmed versions.</div><div class="diff-added">+    /// Keep WAL version from truncating</div><div>     pub(super) wal_keep_from: Arc<AtomicU64>,</div><div class="diff-added">+    /// Handles for running optimizations</div><div>     optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    /// Maximum number of concurrent optimization jobs in this update handler.</div><div class="diff-removed">-    /// This parameter depends on the optimizer config and should be updated accordingly.</div><div class="diff-added">+    /// Maximum number of concurrent optimization jobs</div><div>     pub max_optimization_threads: Option<usize>,</div><div class="diff-removed">-    /// Highest and cutoff clocks for the shard WAL.</div><div class="diff-added">+    /// Clock maps for the shard</div><div>     clocks: LocalShardClocks,</div><div class="diff-added">+    /// Path to shard directory</div><div>     shard_path: PathBuf,</div><div class="diff-removed">-    /// Whether we have ever triggered optimizers since starting.</div><div class="diff-added">+    /// Has any optimizer been triggered</div><div>     has_triggered_optimizers: Arc<AtomicBool>,</div><div> }</div><div> </div><div class="diff-added">+#[allow(clippy::too_many_arguments)]</div><div> impl UpdateHandler {</div><div>     #[allow(clippy::too_many_arguments)]</div><div>     pub fn new(</div><div class="diff-info">@@ -143,8 +135,8 @@ impl UpdateHandler {</div><div>         max_optimization_threads: Option<usize>,</div><div>         clocks: LocalShardClocks,</div><div>         shard_path: PathBuf,</div><div class="diff-removed">-    ) -> UpdateHandler {</div><div class="diff-removed">-        UpdateHandler {</div><div class="diff-added">+    ) -> Self {</div><div class="diff-added">+        Self {</div><div>             shared_storage_config,</div><div>             payload_index_schema,</div><div>             optimizers,</div><div class="diff-info">@@ -154,42 +146,46 @@ impl UpdateHandler {</div><div>             optimizers_log,</div><div>             total_optimized_points,</div><div>             optimizer_resource_budget,</div><div class="diff-removed">-            flush_worker: None,</div><div class="diff-removed">-            flush_stop: None,</div><div class="diff-added">+            flush_interval_sec,</div><div>             runtime_handle,</div><div>             wal,</div><div>             wal_keep_from: Arc::new(u64::MAX.into()),</div><div class="diff-removed">-            flush_interval_sec,</div><div>             optimization_handles: Arc::new(TokioMutex::new(vec![])),</div><div>             max_optimization_threads,</div><div>             clocks,</div><div>             shard_path,</div><div>             has_triggered_optimizers: Default::default(),</div><div class="diff-added">+            flush_worker: None,</div><div class="diff-added">+            flush_stop: None,</div><div class="diff-added">+            /* fields above are all initialized */</div><div>         }</div><div>     }</div><div> </div><div class="diff-added">+    /// Start the update and optimization workers</div><div>     pub fn run_workers(&mut self, update_receiver: Receiver<UpdateSignal>) {</div><div>         let (tx, rx) = mpsc::channel(self.shared_storage_config.update_queue_size);</div><div class="diff-removed">-        self.optimizer_worker = Some(self.runtime_handle.spawn(Self::optimization_worker_fn(</div><div class="diff-removed">-            self.optimizers.clone(),</div><div class="diff-removed">-            tx.clone(),</div><div class="diff-removed">-            rx,</div><div class="diff-removed">-            self.segments.clone(),</div><div class="diff-removed">-            self.wal.clone(),</div><div class="diff-removed">-            self.optimization_handles.clone(),</div><div class="diff-removed">-            self.optimizers_log.clone(),</div><div class="diff-removed">-            self.total_optimized_points.clone(),</div><div class="diff-removed">-            self.optimizer_resource_budget.clone(),</div><div class="diff-removed">-            self.max_optimization_threads,</div><div class="diff-removed">-            self.has_triggered_optimizers.clone(),</div><div class="diff-removed">-            self.payload_index_schema.clone(),</div><div class="diff-removed">-        )));</div><div class="diff-added">+        self.optimizer_worker = Some(</div><div class="diff-added">+            self.runtime_handle.spawn(Self::optimization_worker_fn(</div><div class="diff-added">+                self.optimizers.clone(),</div><div class="diff-added">+                self.optimizers_log.clone(),</div><div class="diff-added">+                self.total_optimized_points.clone(),</div><div class="diff-added">+                self.optimizer_resource_budget.clone(),</div><div class="diff-added">+                tx.clone(),</div><div class="diff-added">+                rx,</div><div class="diff-added">+                self.segments.clone(),</div><div class="diff-added">+                self.wal.clone(),</div><div class="diff-added">+                self.optimization_handles.clone(),</div><div class="diff-added">+                self.max_optimization_threads,</div><div class="diff-added">+                self.has_triggered_optimizers.clone(),</div><div class="diff-added">+                self.payload_index_schema.clone(),</div><div class="diff-added">+            )),</div><div class="diff-added">+        );</div><div>         self.update_worker = Some(self.runtime_handle.spawn(Self::update_worker_fn(</div><div>             update_receiver,</div><div>             tx,</div><div class="diff-removed">-            self.wal.clone(),</div><div>             self.segments.clone(),</div><div>         )));</div><div class="diff-added">+</div><div>         let (flush_tx, flush_rx) = oneshot::channel();</div><div>         self.flush_worker = Some(self.runtime_handle.spawn(Self::flush_worker(</div><div>             self.segments.clone(),</div><div class="diff-info">@@ -203,76 +199,83 @@ impl UpdateHandler {</div><div>         self.flush_stop = Some(flush_tx);</div><div>     }</div><div> </div><div class="diff-removed">-    pub fn stop_flush_worker(&mut self) {</div><div class="diff-removed">-        if let Some(flush_stop) = self.flush_stop.take() {</div><div class="diff-removed">-            if let Err(()) = flush_stop.send(()) {</div><div class="diff-removed">-                warn!("Failed to stop flush worker as it is already stopped.");</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Gracefully wait before all optimizations stop</div><div class="diff-removed">-    /// If some optimization is in progress - it will be finished before shutdown.</div><div class="diff-added">+    /// Gracefully stop all workers and join them</div><div>     pub async fn wait_workers_stops(&mut self) -> CollectionResult<()> {</div><div class="diff-removed">-        let maybe_handle = self.update_worker.take();</div><div class="diff-removed">-        if let Some(handle) = maybe_handle {</div><div class="diff-added">+        // Stop update and optimization workers</div><div class="diff-added">+        if let Some(handle) = self.update_worker.take() {</div><div>             handle.await?;</div><div>         }</div><div class="diff-removed">-        let maybe_handle = self.optimizer_worker.take();</div><div class="diff-removed">-        if let Some(handle) = maybe_handle {</div><div class="diff-added">+        if let Some(handle) = self.optimizer_worker.take() {</div><div>             handle.await?;</div><div>         }</div><div class="diff-removed">-        let maybe_handle = self.flush_worker.take();</div><div class="diff-removed">-        if let Some(handle) = maybe_handle {</div><div class="diff-added">+        if let Some(handle) = self.flush_worker.take() {</div><div>             handle.await?;</div><div>         }</div><div> </div><div class="diff-removed">-        let mut opt_handles_guard = self.optimization_handles.lock().await;</div><div class="diff-removed">-        let opt_handles = std::mem::take(&mut *opt_handles_guard);</div><div class="diff-removed">-        let stopping_handles = opt_handles</div><div class="diff-removed">-            .into_iter()</div><div class="diff-removed">-            .filter_map(|h| h.stop())</div><div class="diff-removed">-            .collect_vec();</div><div class="diff-removed">-</div><div class="diff-removed">-        for res in stopping_handles {</div><div class="diff-removed">-            res.await?;</div><div class="diff-added">+        // Join all optimization handles</div><div class="diff-added">+        let handles = {</div><div class="diff-added">+            let mut handles_guard = self.optimization_handles.lock().await;</div><div class="diff-added">+            std::mem::take(&mut *handles_guard)</div><div class="diff-added">+        };</div><div class="diff-added">+        for handle in handles {</div><div class="diff-added">+            // Propagate any panics from optimisation tasks</div><div class="diff-added">+            handle.join_and_handle_panic().await;</div><div>         }</div><div> </div><div>         Ok(())</div><div>     }</div><div> </div><div>     /// Checks if there are any failed operations.</div><div class="diff-removed">-    /// If so - attempts to re-apply all failed operations.</div><div class="diff-removed">-    async fn try_recover(segments: LockedSegmentHolder, wal: LockedWal) -> CollectionResult<usize> {</div><div class="diff-added">+    /// If so, attempts to re-apply all failed operations.</div><div class="diff-added">+    async fn try_recover(</div><div class="diff-added">+        segments: LockedSegmentHolder,</div><div class="diff-added">+        wal: LockedWal,</div><div class="diff-added">+    ) -> CollectionResult<usize> {</div><div>         // Try to re-apply everything starting from the first failed operation</div><div>         let first_failed_operation_option = segments.read().failed_operation.iter().cloned().min();</div><div class="diff-removed">-        match first_failed_operation_option {</div><div class="diff-removed">-            None => {}</div><div class="diff-removed">-            Some(first_failed_op) => {</div><div class="diff-removed">-                let wal_lock = wal.lock().await;</div><div class="diff-removed">-                for (op_num, operation) in wal_lock.read(first_failed_op) {</div><div class="diff-removed">-                    CollectionUpdater::update(</div><div class="diff-removed">-                        &segments,</div><div class="diff-removed">-                        op_num,</div><div class="diff-removed">-                        operation.operation,</div><div class="diff-removed">-                        &HardwareCounterCell::disposable(), // Internal operation, no measurement needed</div><div class="diff-removed">-                    )?;</div><div class="diff-removed">-                }</div><div class="diff-added">+        if let Some(first_failed_op) = first_failed_operation_option {</div><div class="diff-added">+            // Get a lock on the WAL</div><div class="diff-added">+            let wal_lock = wal.lock().await;</div><div class="diff-added">+            for (op_num, operation) in wal_lock.read(first_failed_op) {</div><div class="diff-added">+                CollectionUpdater::update(&segments, op_num, operation.operation)?;</div><div>             }</div><div class="diff-removed">-        };</div><div class="diff-added">+        }</div><div>         Ok(0)</div><div>     }</div><div> </div><div class="diff-removed">-    /// Checks conditions for all optimizers until there is no suggested segment</div><div class="diff-removed">-    /// Starts a task for each optimization</div><div class="diff-removed">-    /// Returns handles for started tasks</div><div class="diff-added">+    /// Checks the optimizer conditions.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// Returns a tuple:</div><div class="diff-added">+    /// - first element: whether any optimizer has ever been triggered</div><div class="diff-added">+    /// - second element: whether any optimizer has non‑optimal work to do</div><div class="diff-added">+    pub(crate) fn check_optimizer_conditions(&self) -> (bool, bool) {</div><div class="diff-added">+        let has_triggered_any_optimizers = self</div><div class="diff-added">+            .has_triggered_optimizers</div><div class="diff-added">+            .load(Ordering::Relaxed);</div><div class="diff-added">+        let excluded_ids = HashSet::default();</div><div class="diff-added">+        let has_suboptimal = self</div><div class="diff-added">+            .optimizers</div><div class="diff-added">+            .iter()</div><div class="diff-added">+            .any(|optimizer| {</div><div class="diff-added">+                let nonoptimal_segment_ids = optimizer.check_condition(</div><div class="diff-added">+                    self.segments.clone(),</div><div class="diff-added">+                    &excluded_ids,</div><div class="diff-added">+                );</div><div class="diff-added">+                !nonoptimal_segment_ids.is_empty()</div><div class="diff-added">+            });</div><div class="diff-added">+        (has_triggered_any_optimizers, has_suboptimal)</div><div class="diff-added">+    }</div><div class="diff-added">+</div><div class="diff-added">+    /// Launch a set of optimization tasks, respecting the resource budget.</div><div class="diff-added">+    ///</div><div class="diff-added">+    /// `callback` is called with `true` if the optimizer actually performed work.</div><div>     pub(crate) fn launch_optimization<F>(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div>         optimizers_log: Arc<Mutex<TrackerLog>>,</div><div>         total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: &ResourceBudget,</div><div class="diff-added">+        resource_budget: &ResourceBudget,</div><div>         segments: LockedSegmentHolder,</div><div class="diff-removed">-        callback: F,</div><div class="diff-added">+        mut callback: F,</div><div>         limit: Option<usize>,</div><div>     ) -> Vec<StoppableTaskHandle<bool>></div><div>     where</div><div class="diff-info">@@ -283,33 +286,26 @@ impl UpdateHandler {</div><div> </div><div>         'outer: for optimizer in optimizers.iter() {</div><div>             loop {</div><div class="diff-removed">-                // Return early if we reached the optimization job limit</div><div class="diff-removed">-                if limit.map(|extra| handles.len() >= extra).unwrap_or(false) {</div><div class="diff-removed">-                    log::trace!("Reached optimization job limit, postponing other optimizations");</div><div class="diff-added">+                // Limit the number of optimization handles</div><div class="diff-added">+                let limit = limit.unwrap_or(usize::MAX);</div><div class="diff-added">+                if limit > 0 && handles.len() >= limit {</div><div>                     break 'outer;</div><div>                 }</div><div> </div><div class="diff-removed">-                let nonoptimal_segment_ids =</div><div class="diff-removed">-                    optimizer.check_condition(segments.clone(), &scheduled_segment_ids);</div><div class="diff-added">+                let nonoptimal_segment_ids = optimizer.check_condition(</div><div class="diff-added">+                    segments.clone(),</div><div class="diff-added">+                    &scheduled_segment_ids,</div><div class="diff-added">+                );</div><div>                 if nonoptimal_segment_ids.is_empty() {</div><div>                     break;</div><div>                 }</div><div> </div><div class="diff-removed">-                debug!("Optimizing segments: {:?}", &nonoptimal_segment_ids);</div><div class="diff-removed">-</div><div class="diff-removed">-                // Determine how many Resources we prefer for optimization task, acquire permit for it</div><div class="diff-removed">-                // And use same amount of IO threads as CPUs</div><div class="diff-removed">-                let max_indexing_threads = optimizer.hnsw_config().max_indexing_threads;</div><div class="diff-removed">-                let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-removed">-                let Some(mut permit) = optimizer_resource_budget.try_acquire(0, desired_io) else {</div><div class="diff-removed">-                    // If there is no Resource budget, break outer loop and return early</div><div class="diff-removed">-                    // If we have no handles (no optimizations) trigger callback so that we wake up</div><div class="diff-removed">-                    // our optimization worker to try again later, otherwise it could get stuck</div><div class="diff-removed">-                    log::trace!(</div><div class="diff-removed">-                        "No available IO permit for {} optimizer, postponing",</div><div class="diff-removed">-                        optimizer.name(),</div><div class="diff-removed">-                    );</div><div class="diff-added">+                let desired_io = num_rayon_threads(optimizer.hnsw_config().max_indexing_threads);</div><div class="diff-added">+                let Some(mut permit) = resource_budget.try_acquire(0, desired_io)</div><div class="diff-added">+                else {</div><div class="diff-added">+                    // Not enough resources; exit if we have no running tasks</div><div>                     if handles.is_empty() {</div><div class="diff-added">+                        // No tasks running – trigger a callback so the scheduler can retry</div><div>                         callback(false);</div><div>                     }</div><div>                     break 'outer;</div><div class="diff-info">@@ -320,378 +316,227 @@ impl UpdateHandler {</div><div>                     optimizer.name(),</div><div>                 );</div><div> </div><div class="diff-removed">-                let permit_callback = callback.clone();</div><div class="diff-removed">-</div><div class="diff-removed">-                permit.set_on_release(move || {</div><div class="diff-removed">-                    // Notify scheduler that resource budget changed</div><div class="diff-removed">-                    permit_callback(false);</div><div class="diff-removed">-                });</div><div class="diff-added">+                // Notify when the permit is released</div><div class="diff-added">+                {</div><div class="diff-added">+                    let callback_clone = callback.clone();</div><div class="diff-added">+                    permit.set_on_release(move || {</div><div class="diff-added">+                        // If an optimization finishes, re-trigger optimizers</div><div class="diff-added">+                        callback_clone(false);</div><div class="diff-added">+                    });</div><div class="diff-added">+                }</div><div> </div><div>                 let optimizer = optimizer.clone();</div><div>                 let optimizers_log = optimizers_log.clone();</div><div>                 let total_optimized_points = total_optimized_points.clone();</div><div>                 let segments = segments.clone();</div><div>                 let nsi = nonoptimal_segment_ids.clone();</div><div class="diff-removed">-                scheduled_segment_ids.extend(&nsi);</div><div class="diff-removed">-                let callback = callback.clone();</div><div> </div><div>                 let handle = spawn_stoppable(</div><div class="diff-removed">-                    // Stoppable task</div><div class="diff-added">+                    // Stoppable optimisation task</div><div>                     {</div><div class="diff-removed">-                        let resource_budget = optimizer_resource_budget.clone();</div><div class="diff-removed">-                        let segments = segments.clone();</div><div class="diff-added">+                        let resource_budget = resource_budget.clone();</div><div>                         move |stopped| {</div><div class="diff-removed">-                            // Track optimizer status</div><div class="diff-removed">-                            let tracker = Tracker::start(optimizer.as_ref().name(), nsi.clone());</div><div class="diff-added">+                            let tracker = Tracker::start(optimizer.name(), nsi.clone());</div><div>                             let tracker_handle = tracker.handle();</div><div>                             optimizers_log.lock().register(tracker);</div><div> </div><div class="diff-removed">-                            // Optimize and handle result</div><div class="diff-added">+                            // Run the optimizer, passing the permit and stop flag</div><div>                             match optimizer.as_ref().optimize(</div><div>                                 segments.clone(),</div><div>                                 nsi,</div><div class="diff-removed">-                                permit,</div><div class="diff-removed">-                                resource_budget,</div><div class="diff-added">+                                permit.clone(),</div><div>                                 stopped,</div><div>                             ) {</div><div class="diff-removed">-                                // Perform some actions when optimization if finished</div><div class="diff-added">+                                // Optimizer completed</div><div>                                 Ok(optimized_points) => {</div><div class="diff-removed">-                                    let is_optimized = optimized_points > 0;</div><div class="diff-removed">-                                    total_optimized_points</div><div class="diff-removed">-                                        .fetch_add(optimized_points, Ordering::Relaxed);</div><div class="diff-added">+                                    let was_optimized = optimized_points > 0;</div><div class="diff-added">+                                    total_optimized_points.fetch_add(</div><div class="diff-added">+                                        optimized_points,</div><div class="diff-added">+                                        Ordering::Relaxed,</div><div class="diff-added">+                                    );</div><div>                                     tracker_handle.update(TrackerStatus::Done);</div><div class="diff-removed">-                                    callback(is_optimized);</div><div class="diff-removed">-                                    is_optimized</div><div class="diff-added">+                                    callback(was_optimized);</div><div class="diff-added">+                                    true</div><div>                                 }</div><div class="diff-removed">-                                // Handle and report errors</div><div class="diff-removed">-                                Err(error) => match error {</div><div class="diff-removed">-                                    CollectionError::Cancelled { description } => {</div><div class="diff-removed">-                                        debug!("Optimization cancelled - {description}");</div><div class="diff-removed">-                                        tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Cancelled(description));</div><div class="diff-added">+                                // Optimizer was cancelled</div><div class="diff-added">+                                Err(CollectionError::Cancelled { description }) => {</div><div class="diff-added">+                                    log::debug!("Optimization cancelled - {description}");</div><div class="diff-added">+                                    tracker_handle</div><div class="diff-added">+                                        .update(TrackerStatus::Cancelled(description));</div><div>                                         false</div><div>                                     }</div><div class="diff-removed">-                                    _ => {</div><div class="diff-removed">-                                        segments.write().report_optimizer_error(error.clone());</div><div class="diff-added">+                                // Fatal error</div><div class="diff-added">+                                Err(err) => {</div><div class="diff-added">+                                    // Record the first error seen</div><div class="diff-added">+                                    segments</div><div class="diff-added">+                                        .write()</div><div class="diff-added">+                                        .report_optimizer_error(err.clone());</div><div> </div><div class="diff-removed">-                                        // Error of the optimization can not be handled by API user</div><div class="diff-removed">-                                        // It is only possible to fix after full restart,</div><div class="diff-removed">-                                        // so the best available action here is to stop whole</div><div class="diff-removed">-                                        // optimization thread and log the error</div><div class="diff-removed">-                                        log::error!("Optimization error: {error}");</div><div class="diff-added">+                                        // Log the (fatal) error and panic</div><div class="diff-added">+                                        log::error!("Optimization error: {err}");</div><div> </div><div>                                         tracker_handle</div><div class="diff-removed">-                                            .update(TrackerStatus::Error(error.to_string()));</div><div class="diff-removed">-</div><div class="diff-removed">-                                        panic!("Optimization error: {error}");</div><div class="diff-added">+                                            .update(TrackerStatus::Error(err.to_string()));</div><div class="diff-added">+                                        panic!("Optimization error: {err}");</div><div>                                     }</div><div class="diff-removed">-                                },</div><div>                             }</div><div>                         }</div><div>                     },</div><div>                     // Panic handler</div><div class="diff-removed">-                    Some(Box::new(move |panic_payload| {</div><div class="diff-removed">-                        let message = panic::downcast_str(&panic_payload).unwrap_or("");</div><div class="diff-added">+                    Some(Box::new(|payload| {</div><div class="diff-added">+                        let message = panic::downcast_str(payload).unwrap_or("");</div><div>                         let separator = if !message.is_empty() { ": " } else { "" };</div><div class="diff-removed">-</div><div>                         warn!(</div><div class="diff-removed">-                            "Optimization task panicked, collection may be in unstable state\</div><div class="diff-removed">-                             {separator}{message}"</div><div class="diff-added">+                            "Optimization task panicked, collection may be in an unstable state{separator}{message}"</div><div>                         );</div><div class="diff-removed">-</div><div>                         segments</div><div>                             .write()</div><div class="diff-removed">-                            .report_optimizer_error(CollectionError::service_error(format!(</div><div class="diff-removed">-                                "Optimization task panicked{separator}{message}"</div><div class="diff-removed">-                            )));</div><div class="diff-added">+                            .report_optimizer_error(CollectionError::service_error(</div><div class="diff-added">+                                format!("Task panicked{separator}{message}"),</div><div class="diff-added">+                            ));</div><div>                     })),</div><div>                 );</div><div>                 handles.push(handle);</div><div class="diff-added">+                if handles.len() >= limit {</div><div class="diff-added">+                    break 'outer;</div><div class="diff-added">+                }</div><div>             }</div><div>         }</div><div class="diff-removed">-</div><div>         handles</div><div>     }</div><div> </div><div class="diff-removed">-    /// Ensure there is at least one appendable segment with enough capacity</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// If there is no appendable segment, or all are at or over capacity, a new empty one is</div><div class="diff-removed">-    /// created.</div><div class="diff-added">+    /// Push new optimization tasks, and keep a handle list.</div><div>     ///</div><div class="diff-removed">-    /// Capacity is determined based on `optimizers.max_segment_size_kb`.</div><div class="diff-removed">-    pub(super) fn ensure_appendable_segment_with_capacity(</div><div class="diff-removed">-        segments: &LockedSegmentHolder,</div><div class="diff-removed">-        segments_path: &Path,</div><div class="diff-removed">-        collection_params: &CollectionParams,</div><div class="diff-removed">-        thresholds_config: &OptimizerThresholds,</div><div class="diff-removed">-        payload_index_schema: &PayloadIndexSchema,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        let no_segment_with_capacity = {</div><div class="diff-removed">-            let segments_read = segments.read();</div><div class="diff-removed">-            segments_read</div><div class="diff-removed">-                .appendable_segments_ids()</div><div class="diff-removed">-                .into_iter()</div><div class="diff-removed">-                .filter_map(|segment_id| segments_read.get(segment_id))</div><div class="diff-removed">-                .all(|segment| {</div><div class="diff-removed">-                    let max_vector_size_bytes = segment</div><div class="diff-removed">-                        .get()</div><div class="diff-removed">-                        .read()</div><div class="diff-removed">-                        .max_available_vectors_size_in_bytes()</div><div class="diff-removed">-                        .unwrap_or_default();</div><div class="diff-removed">-                    let max_segment_size_bytes = thresholds_config</div><div class="diff-removed">-                        .max_segment_size_kb</div><div class="diff-removed">-                        .saturating_mul(segment::common::BYTES_IN_KB);</div><div class="diff-removed">-</div><div class="diff-removed">-                    max_vector_size_bytes >= max_segment_size_bytes</div><div class="diff-removed">-                })</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        if no_segment_with_capacity {</div><div class="diff-removed">-            log::debug!("Creating new appendable segment, all existing segments are over capacity");</div><div class="diff-removed">-            segments.write().create_appendable_segment(</div><div class="diff-removed">-                segments_path,</div><div class="diff-removed">-                collection_params,</div><div class="diff-removed">-                payload_index_schema,</div><div class="diff-removed">-            )?;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Checks the optimizer conditions.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This function returns a tuple of two booleans:</div><div class="diff-removed">-    /// - The first indicates if any optimizers have been triggered since startup.</div><div class="diff-removed">-    /// - The second indicates if there are any pending/suboptimal optimizers.</div><div class="diff-removed">-    pub(crate) fn check_optimizer_conditions(&self) -> (bool, bool) {</div><div class="diff-removed">-        // Check if Qdrant triggered any optimizations since starting at all</div><div class="diff-removed">-        let has_triggered_any_optimizers = self.has_triggered_optimizers.load(Ordering::Relaxed);</div><div class="diff-removed">-</div><div class="diff-removed">-        let excluded_ids = HashSet::<_>::default();</div><div class="diff-removed">-        let has_suboptimal_optimizers = self.optimizers.iter().any(|optimizer| {</div><div class="diff-removed">-            let nonoptimal_segment_ids =</div><div class="diff-removed">-                optimizer.check_condition(self.segments.clone(), &excluded_ids);</div><div class="diff-removed">-            !nonoptimal_segment_ids.is_empty()</div><div class="diff-removed">-        });</div><div class="diff-removed">-</div><div class="diff-removed">-        (has_triggered_any_optimizers, has_suboptimal_optimizers)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div class="diff-removed">-    pub(crate) async fn process_optimization(</div><div class="diff-added">+    /// `limit` is the maximum number of concurrent optimisation tasks.</div><div class="diff-added">+    async fn process_optimization(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div>         optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div>         optimizers_log: Arc<Mutex<TrackerLog>>,</div><div>         total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: &ResourceBudget,</div><div class="diff-added">+        resource_budget: &ResourceBudget,</div><div>         sender: Sender<OptimizerSignal>,</div><div>         limit: usize,</div><div>     ) {</div><div class="diff-removed">-        let mut new_handles = Self::launch_optimization(</div><div class="diff-added">+        let new_handles = Self::launch_optimization(</div><div>             optimizers.clone(),</div><div class="diff-removed">-            optimizers_log,</div><div class="diff-removed">-            total_optimized_points,</div><div class="diff-removed">-            optimizer_resource_budget,</div><div class="diff-removed">-            segments.clone(),</div><div class="diff-removed">-            move |_optimization_result| {</div><div class="diff-removed">-                // After optimization is finished, we still need to check if there are</div><div class="diff-removed">-                // some further optimizations possible.</div><div class="diff-removed">-                // If receiver is already dead - we do not care.</div><div class="diff-removed">-                // If channel is full - optimization will be triggered by some other signal</div><div class="diff-removed">-                let _ = sender.try_send(OptimizerSignal::Nop);</div><div class="diff-removed">-            },</div><div class="diff-removed">-            Some(limit),</div><div class="diff-added">+            optimizers_log.clone(),</div><div class="diff-added">+            total_optimized_points.clone(),</div><div class="diff-added">+            resource_budget,</div><div class="diff-added">+            optimization_handles.clone(),</div><div class="diff-added">+            limit,</div><div>         );</div><div class="diff-removed">-        let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-        handles.append(&mut new_handles);</div><div class="diff-added">+        let mut handles_guard = optimization_handles.lock().await;</div><div class="diff-added">+        handles_guard.extend(new_handles);</div><div class="diff-added">+        // Retain only unfinished handles</div><div class="diff-added">+        handles_guard.retain(|handle| !handle.is_finished());</div><div>     }</div><div> </div><div class="diff-removed">-    /// Cleanup finalized optimization task handles</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This finds and removes completed tasks from our list of optimization handles.</div><div class="diff-removed">-    /// It also propagates any panics (and unknown errors) so we properly handle them if desired.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// It is essential to call this every once in a while for handling panics in time.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Returns true if any optimization handle was finished, joined and removed.</div><div class="diff-removed">-    async fn cleanup_optimization_handles(</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div class="diff-removed">-    ) -> bool {</div><div class="diff-removed">-        // Remove finished handles</div><div class="diff-removed">-        let finished_handles: Vec<_> = {</div><div class="diff-removed">-            let mut handles = optimization_handles.lock().await;</div><div class="diff-removed">-            (0..handles.len())</div><div class="diff-removed">-                .filter(|i| handles[*i].is_finished())</div><div class="diff-removed">-                .collect::<Vec<_>>()</div><div class="diff-removed">-                .into_iter()</div><div class="diff-removed">-                .rev()</div><div class="diff-removed">-                .map(|i| handles.swap_remove(i))</div><div class="diff-removed">-                .collect()</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let finished_any = !finished_handles.is_empty();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Finalize all finished handles to propagate panics</div><div class="diff-removed">-        for handle in finished_handles {</div><div class="diff-removed">-            handle.join_and_handle_panic().await;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        finished_any</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[allow(clippy::too_many_arguments)]</div><div>     async fn optimization_worker_fn(</div><div>         optimizers: Arc<Vec<Arc<Optimizer>>>,</div><div class="diff-removed">-        sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-        mut receiver: Receiver<OptimizerSignal>,</div><div class="diff-removed">-        segments: LockedSegmentHolder,</div><div class="diff-removed">-        wal: LockedWal,</div><div class="diff-removed">-        optimization_handles: Arc<TokioMutex<Vec<StoppableTaskHandle<bool>>>>,</div><div>         optimizers_log: Arc<Mutex<TrackerLog>>,</div><div>         total_optimized_points: Arc<AtomicUsize>,</div><div class="diff-removed">-        optimizer_resource_budget: ResourceBudget,</div><div class="diff-added">+        resource_budget: ResourceBudget,</div><div class="diff-added">+        sender: Sender<OptimizerSignal>,</div><div>         max_handles: Option<usize>,</div><div>         has_triggered_optimizers: Arc<AtomicBool>,</div><div>         payload_index_schema: Arc<SaveOnDisk<PayloadIndexSchema>>,</div><div>     ) {</div><div class="diff-removed">-        let max_handles = max_handles.unwrap_or(usize::MAX);</div><div class="diff-removed">-        let max_indexing_threads = optimizers</div><div class="diff-removed">-            .first()</div><div class="diff-removed">-            .map(|optimizer| optimizer.hnsw_config().max_indexing_threads)</div><div class="diff-removed">-            .unwrap_or_default();</div><div class="diff-added">+        // Process optimiser signals until `Stop`</div><div class="diff-added">+        let mut cpu_available_trigger: Option<JoinHandle<()>> = None;</div><div class="diff-added">+        loop {</div><div class="diff-added">+            let result = tokio::time::timeout(OPTIMIZER_CLEANUP_INTERVAL, receiver.recv()).await;</div><div> </div><div class="diff-removed">-        // Asynchronous task to trigger optimizers once CPU budget is available again</div><div class="diff-removed">-        let mut resource_available_trigger: Option<JoinHandle<()>> = None;</div><div class="diff-added">+            // Clean up any finished optimisation tasks</div><div class="diff-added">+            let _ = Self::cleanup_optimization_handles(optimization_handles.clone()).await;</div><div> </div><div class="diff-removed">-        loop {</div><div class="diff-removed">-            let result = timeout(OPTIMIZER_CLEANUP_INTERVAL, receiver.recv()).await;</div><div class="diff-removed">-</div><div class="diff-removed">-            let cleaned_any =</div><div class="diff-removed">-                Self::cleanup_optimization_handles(optimization_handles.clone()).await;</div><div class="diff-removed">-</div><div class="diff-removed">-            // Either continue below here with the worker, or reloop/break</div><div class="diff-removed">-            // Decision logic doing one of three things:</div><div class="diff-removed">-            // 1. run optimizers</div><div class="diff-removed">-            // 2. reloop and wait for next signal</div><div class="diff-removed">-            // 3. break here and stop the optimization worker</div><div class="diff-removed">-            let ignore_max_handles = match result {</div><div class="diff-removed">-                // Regular optimizer signal: run optimizers: do 1</div><div class="diff-removed">-                Ok(Some(OptimizerSignal::Operation(_))) => false,</div><div class="diff-removed">-                // Optimizer signal ignoring max handles: do 1</div><div class="diff-removed">-                Ok(Some(OptimizerSignal::Nop)) => true,</div><div class="diff-removed">-                // Hit optimizer cleanup interval, did clean up a task: do 1</div><div class="diff-removed">-                Err(Elapsed { .. }) if cleaned_any => {</div><div class="diff-removed">-                    // This branch prevents a race condition where optimizers would get stuck</div><div class="diff-removed">-                    // If the optimizer cleanup interval was triggered and we did clean any task we</div><div class="diff-removed">-                    // must run optimizers now. If we don't there may not be any other ongoing</div><div class="diff-removed">-                    // tasks that'll trigger this for us. If we don't run optimizers here we might</div><div class="diff-removed">-                    // get stuck into yellow state until a new update operation is received.</div><div class="diff-removed">-                    // See: <https://github.com/qdrant/qdrant/pull/5111></div><div class="diff-removed">-                    log::warn!(</div><div class="diff-removed">-                        "Cleaned a optimization handle after timeout, explicitly triggering optimizers",</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    true</div><div class="diff-removed">-                }</div><div class="diff-removed">-                // Hit optimizer cleanup interval, did not clean up a task: do 2</div><div class="diff-removed">-                Err(Elapsed { .. }) => continue,</div><div class="diff-removed">-                // Channel closed or received stop signal: do 3</div><div class="diff-added">+            match result {</div><div class="diff-added">+                // Received a stop signal or channel closed</div><div>                 Ok(None | Some(OptimizerSignal::Stop)) => break,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            has_triggered_optimizers.store(true, Ordering::Relaxed);</div><div class="diff-removed">-</div><div class="diff-removed">-            // Ensure we have at least one appendable segment with enough capacity</div><div class="diff-removed">-            // Source required parameters from first optimizer</div><div class="diff-removed">-            if let Some(optimizer) = optimizers.first() {</div><div class="diff-removed">-                let result = Self::ensure_appendable_segment_with_capacity(</div><div class="diff-removed">-                    &segments,</div><div class="diff-removed">-                    optimizer.segments_path(),</div><div class="diff-removed">-                    &optimizer.collection_params(),</div><div class="diff-removed">-                    optimizer.threshold_config(),</div><div class="diff-removed">-                    &payload_index_schema.read(),</div><div class="diff-removed">-                );</div><div class="diff-removed">-                if let Err(err) = result {</div><div class="diff-removed">-                    log::error!(</div><div class="diff-removed">-                        "Failed to ensure there are appendable segments with capacity: {err}"</div><div class="diff-removed">-                    );</div><div class="diff-removed">-                    panic!("Failed to ensure there are appendable segments with capacity: {err}");</div><div class="diff-added">+                // Clean up timeout – continue waiting</div><div class="diff-added">+                Err(Elapsed { .. }) => continue,</div><div class="diff-added">+                // Received an optimizer signal</div><div class="diff-added">+                Ok(Some(signal @ (OptimizerSignal::Nop | OptimizerSignal::Operation(_)))) => {</div><div class="diff-added">+                    has_triggered_optimizers.store(true, Ordering::Relaxed);</div><div>                 }</div><div class="diff-removed">-            }</div><div> </div><div class="diff-removed">-            // If not forcing, wait on next signal if we have too many handles</div><div class="diff-removed">-            if !ignore_max_handles && optimization_handles.lock().await.len() >= max_handles {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-added">+                // Ensure we have an appendable segment with enough capacity</div><div class="diff-added">+                if let Some(optimizer) = optimizers.first() {</div><div class="diff-added">+                    if let Err(err) = Self::ensure_appendable_segment_with_capacity(</div><div class="diff-added">+                        &segments,</div><div class="diff-added">+                        optimizer.segments_path(),</div><div class="diff-added">+                        &optimizer.collection_params(),</div><div class="diff-added">+                        optimizer.threshold_config(),</div><div class="diff-added">+                        &payload_index_schema.read(),</div><div class="diff-added">+                    ) {</div><div class="diff-added">+                        log::error!("Failed to ensure appendable segment: {err}");</div><div class="diff-added">+                        panic!("Failed to ensure appendable segment: {err}");</div><div class="diff-added">+                    }</div><div class="diff-added">+                }</div><div> </div><div class="diff-removed">-            if Self::try_recover(segments.clone(), wal.clone())</div><div class="diff-removed">-                .await</div><div class="diff-removed">-                .is_err()</div><div class="diff-removed">-            {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-added">+                // If we have already too many optimisation handles, skip</div><div class="diff-added">+                if !ignore_max_handles && optimization_handles.lock().await.len()</div><div class="diff-added">+                    >= max_handles</div><div class="diff-added">+                {</div><div class="diff-added">+                    continue;</div><div class="diff-added">+                }</div><div> </div><div class="diff-removed">-            // Continue if we have enough resource budget available to start an optimization</div><div class="diff-removed">-            // Otherwise skip now and start a task to trigger the optimizer again once resource</div><div class="diff-removed">-            // budget becomes available</div><div class="diff-removed">-            let desired_cpus = 0;</div><div class="diff-removed">-            let desired_io = num_rayon_threads(max_indexing_threads);</div><div class="diff-removed">-            if !optimizer_resource_budget.has_budget(desired_cpus, desired_io) {</div><div class="diff-removed">-                let trigger_active = resource_available_trigger</div><div class="diff-removed">-                    .as_ref()</div><div class="diff-removed">-                    .is_some_and(|t| !t.is_finished());</div><div class="diff-removed">-                if !trigger_active {</div><div class="diff-removed">-                    resource_available_trigger.replace(trigger_optimizers_on_resource_budget(</div><div class="diff-removed">-                        optimizer_resource_budget.clone(),</div><div class="diff-removed">-                        desired_cpus,</div><div class="diff-removed">-                        desired_io,</div><div class="diff-removed">-                        sender.clone(),</div><div class="diff-removed">-                    ));</div><div class="diff-added">+                // Ensure we have resources for optimisation</div><div class="diff-added">+                let desired_io = num_rayon_threads(optimizers.first().map_or(0, |o|</div><div class="diff-added">+                    o.hnsw_config().max_indexing_threads));</div><div class="diff-added">+                if !resource_budget.has_budget(0, desired_io) {</div><div class="diff-added">+                    // Start a task to trigger when resources become available</div><div class="diff-added">+                    if cpu_available_trigger</div><div class="diff-added">+                        .as_ref()</div><div class="diff-added">+                        .map_or(false, |t| t.is_finished())</div><div class="diff-added">+                    {</div><div class="diff-added">+                        cpu_available_trigger.replace(</div><div class="diff-added">+                            resource_trigger_on_budget(</div><div class="diff-added">+                                resource_budget.clone(),</div><div class="diff-added">+                                0,</div><div class="diff-added">+                                desired_io,</div><div class="diff-added">+                                sender.clone(),</div><div class="diff-added">+                            ),</div><div class="diff-added">+                        );</div><div class="diff-added">+                    }</div><div class="diff-added">+                    continue;</div><div>                 }</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div> </div><div class="diff-removed">-            // Determine optimization handle limit based on max handles we allow</div><div class="diff-removed">-            // Not related to the CPU budget, but a different limit for the maximum number</div><div class="diff-removed">-            // of concurrent concrete optimizations per shard as configured by the user in</div><div class="diff-removed">-            // the Qdrant configuration.</div><div class="diff-removed">-            // Skip if we reached limit, an ongoing optimization that finishes will trigger this loop again</div><div class="diff-removed">-            let limit = max_handles.saturating_sub(optimization_handles.lock().await.len());</div><div class="diff-removed">-            if limit == 0 {</div><div class="diff-removed">-                log::trace!("Skipping optimization check, we reached optimization thread limit");</div><div class="diff-removed">-                continue;</div><div class="diff-added">+                // Compute how many more optimisation tasks we may spawn</div><div class="diff-added">+                let limit = max_handles.saturating_sub(optimization_handles.lock().await.len());</div><div class="diff-added">+</div><div class="diff-added">+                // Actually launch an optimisation</div><div class="diff-added">+                self.process_optimization(</div><div class="diff-added">+                    optimizers.clone(),</div><div class="diff-added">+                    optimization_handles.clone(),</div><div class="diff-added">+                    optimizers_log.clone(),</div><div class="diff-added">+                    total_optimized_points.clone(),</div><div class="diff-added">+                    &resource_budget,</div><div class="diff-added">+                    sender.clone(),</div><div class="diff-added">+                    limit,</div><div class="diff-added">+                )</div><div class="diff-added">+                .await;</div><div>             }</div><div class="diff-removed">-</div><div class="diff-removed">-            Self::process_optimization(</div><div class="diff-removed">-                optimizers.clone(),</div><div class="diff-removed">-                segments.clone(),</div><div class="diff-removed">-                optimization_handles.clone(),</div><div class="diff-removed">-                optimizers_log.clone(),</div><div class="diff-removed">-                total_optimized_points.clone(),</div><div class="diff-removed">-                &optimizer_resource_budget,</div><div class="diff-removed">-                sender.clone(),</div><div class="diff-removed">-                limit,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await;</div><div>         }</div><div>     }</div><div> </div><div>     async fn update_worker_fn(</div><div>         mut receiver: Receiver<UpdateSignal>,</div><div>         optimize_sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-        wal: LockedWal,</div><div>         segments: LockedSegmentHolder,</div><div>     ) {</div><div class="diff-added">+        const UNSET: usize = usize::MAX;</div><div class="diff-added">+</div><div>         while let Some(signal) = receiver.recv().await {</div><div>             match signal {</div><div>                 UpdateSignal::Operation(OperationData {</div><div>                     op_num,</div><div>                     operation,</div><div class="diff-removed">-                    sender,</div><div>                     wait,</div><div class="diff-added">+                    sender,</div><div>                     hw_measurements,</div><div>                 }) => {</div><div>                     let flush_res = if wait {</div><div class="diff-added">+                        // Flush WAL before performing the operation</div><div>                         wal.lock().await.flush().map_err(|err| {</div><div>                             CollectionError::service_error(format!(</div><div>                                 "Can't flush WAL before operation {op_num} - {err}"</div><div class="diff-info">@@ -711,47 +556,39 @@ impl UpdateHandler {</div><div>                     });</div><div> </div><div>                     let res = match operation_result {</div><div class="diff-removed">-                        Ok(update_res) => optimize_sender</div><div class="diff-added">+                        Ok(res) => optimize_sender</div><div>                             .send(OptimizerSignal::Operation(op_num))</div><div class="diff-removed">-                            .await</div><div class="diff-removed">-                            .and(Ok(update_res))</div><div class="diff-removed">-                            .map_err(|send_err| send_err.into()),</div><div class="diff-removed">-                        Err(err) => Err(err),</div><div class="diff-added">+                            .and(Ok(res))</div><div class="diff-added">+                            .map_err(|msg| msg.into()),</div><div class="diff-added">+                        Err(e) => Err(e),</div><div>                     };</div><div> </div><div>                     if let Some(feedback) = sender {</div><div class="diff-removed">-                        feedback.send(res).unwrap_or_else(|_| {</div><div class="diff-added">+                        let _ = feedback.send(res).unwrap_or_else(|_| {</div><div>                             debug!("Can't report operation {op_num} result. Assume already not required");</div><div>                         });</div><div class="diff-removed">-                    };</div><div class="diff-added">+                    }</div><div>                 }</div><div>                 UpdateSignal::Stop => {</div><div class="diff-removed">-                    optimize_sender</div><div class="diff-removed">-                        .send(OptimizerSignal::Stop)</div><div class="diff-removed">-                        .await</div><div class="diff-removed">-                        .unwrap_or_else(|_| debug!("Optimizer already stopped"));</div><div class="diff-added">+                    let _ = optimize_sender.send(OptimizerSignal::Stop).unwrap_or_else(|_| {</div><div class="diff-added">+                        debug!("Optimizer already stopped")</div><div class="diff-added">+                    });</div><div>                     break;</div><div>                 }</div><div class="diff-removed">-                UpdateSignal::Nop => optimize_sender</div><div class="diff-removed">-                    .send(OptimizerSignal::Nop)</div><div class="diff-removed">-                    .await</div><div class="diff-removed">-                    .unwrap_or_else(|_| {</div><div class="diff-removed">-                        info!(</div><div class="diff-removed">-                            "Can't notify optimizers, assume process is dead. Restart is required"</div><div class="diff-removed">-                        );</div><div class="diff-removed">-                    }),</div><div class="diff-removed">-                UpdateSignal::Plunger(callback_sender) => {</div><div class="diff-removed">-                    callback_sender.send(()).unwrap_or_else(|_| {</div><div class="diff-removed">-                        debug!("Can't notify sender, assume nobody is waiting anymore");</div><div class="diff-added">+                UpdateSignal::Nop => {</div><div class="diff-added">+                    let _ = optimize_sender.send(OptimizerSignal::Nop).unwrap_or_else(|_| {</div><div class="diff-added">+                        info!("Can't notify optimizers, assume process is dead. Restart is required")</div><div>                     });</div><div>                 }</div><div class="diff-added">+                UpdateSignal::Plunger(chan) => {</div><div class="diff-added">+                    let _ = chan.send(());</div><div class="diff-added">+                }</div><div>             }</div><div>         }</div><div class="diff-removed">-        // Transmitter was destroyed</div><div class="diff-removed">-        optimize_sender</div><div class="diff-removed">-            .send(OptimizerSignal::Stop)</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .unwrap_or_else(|_| debug!("Optimizer already stopped"));</div><div class="diff-added">+        // Transmitter dropped; stop optimizer</div><div class="diff-added">+        let _ = optimize_sender.send(OptimizerSignal::Stop).unwrap_or_else(|_| {</div><div class="diff-added">+            debug!("Optimizer already stopped")</div><div class="diff-added">+        });</div><div>     }</div><div> </div><div>     async fn flush_worker(</div><div class="diff-info">@@ -759,101 +596,53 @@ impl UpdateHandler {</div><div>         wal: LockedWal,</div><div>         wal_keep_from: Arc<AtomicU64>,</div><div>         flush_interval_sec: u64,</div><div class="diff-removed">-        mut stop_receiver: oneshot::Receiver<()>,</div><div class="diff-added">+        mut stop: oneshot::Receiver<()>,</div><div>         clocks: LocalShardClocks,</div><div>         shard_path: PathBuf,</div><div>     ) {</div><div>         loop {</div><div class="diff-removed">-            // Stop flush worker on signal or if sender was dropped</div><div class="diff-removed">-            // Even if timer did not finish</div><div class="diff-added">+            // Wait for either a timer tick or a stop signal</div><div>             tokio::select! {</div><div class="diff-removed">-                _ = tokio::time::sleep(Duration::from_secs(flush_interval_sec)) => {},</div><div class="diff-removed">-                _ = &mut stop_receiver => {</div><div class="diff-removed">-                    debug!("Stopping flush worker for shard {}", shard_path.display());</div><div class="diff-removed">-                    return;</div><div class="diff-removed">-                }</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            trace!("Attempting flushing");</div><div class="diff-removed">-            let wal_flash_job = wal.lock().await.flush_async();</div><div class="diff-removed">-</div><div class="diff-removed">-            if let Err(err) = wal_flash_job.join() {</div><div class="diff-removed">-                error!("Failed to flush wal: {err:?}");</div><div class="diff-removed">-                segments</div><div class="diff-removed">-                    .write()</div><div class="diff-removed">-                    .report_optimizer_error(WalError::WriteWalError(format!(</div><div class="diff-removed">-                        "WAL flush error: {err:?}"</div><div class="diff-removed">-                    )));</div><div class="diff-removed">-                continue;</div><div class="diff-added">+                _ = tokio::time::sleep(Duration::from_secs(flush_interval_sec)) => {}</div><div class="diff-added">+                _ = &mut stop => { debug!("Stopping flush worker for {}", shard_path.display()); return; }</div><div>             }</div><div> </div><div class="diff-removed">-            let confirmed_version = Self::flush_segments(segments.clone());</div><div class="diff-removed">-            let confirmed_version = match confirmed_version {</div><div class="diff-removed">-                Ok(version) => version,</div><div class="diff-removed">-                Err(err) => {</div><div class="diff-removed">-                    error!("Failed to flush: {err}");</div><div class="diff-removed">-                    segments.write().report_optimizer_error(err);</div><div class="diff-added">+            // Flush segment data</div><div class="diff-added">+            let confirmed_version = match Self::flush_segments(segments.clone()) {</div><div class="diff-added">+                Ok(v) => v,</div><div class="diff-added">+                Err(e) => {</div><div class="diff-added">+                    segments</div><div class="diff-added">+                        .write()</div><div class="diff-added">+                        .report_optimizer_error(e);</div><div>                     continue;</div><div>                 }</div><div>             };</div><div> </div><div class="diff-removed">-            // Acknowledge confirmed version in WAL, but don't acknowledge the specified</div><div class="diff-removed">-            // `keep_from` index or higher.</div><div class="diff-removed">-            // This is to prevent truncating WAL entries that other bits of code still depend on</div><div class="diff-removed">-            // such as the queue proxy shard.</div><div class="diff-removed">-            // Default keep_from is `u64::MAX` to allow acknowledging all confirmed.</div><div class="diff-removed">-            let keep_from = wal_keep_from.load(std::sync::atomic::Ordering::Relaxed);</div><div class="diff-removed">-</div><div class="diff-removed">-            // If we should keep the first message, do not acknowledge at all</div><div class="diff-removed">-            if keep_from == 0 {</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            let ack = confirmed_version.min(keep_from.saturating_sub(1));</div><div class="diff-removed">-</div><div class="diff-added">+            // Ack and store clock maps if needed</div><div>             if let Err(err) = clocks.store_if_changed(&shard_path).await {</div><div class="diff-removed">-                log::warn!("Failed to store clock maps to disk: {err}");</div><div class="diff-added">+                log::warn!("Failed to store clock maps: {err}");</div><div>                 segments.write().report_optimizer_error(err);</div><div>             }</div><div> </div><div class="diff-removed">-            if let Err(err) = wal.lock().await.ack(ack) {</div><div class="diff-removed">-                log::warn!("Failed to acknowledge WAL version: {err}");</div><div class="diff-removed">-                segments.write().report_optimizer_error(err);</div><div class="diff-added">+            // Stop updating WAL if we are keeping at least one version</div><div class="diff-added">+            let keep = wal_keep_from.load(Ordering::Relaxed);</div><div class="diff-added">+            if keep != 0 {</div><div class="diff-added">+                let ack = confirmed_version.min(keep.saturating_sub(1));</div><div class="diff-added">+                if let Err(e) = wal.lock().await.ack(ack) {</div><div class="diff-added">+                    log::warn!("Failed to ack WAL version {ack}: {e}");</div><div class="diff-added">+                    segments.write().report_optimizer_error(e);</div><div class="diff-added">+                }</div><div>             }</div><div>         }</div><div>     }</div><div> </div><div class="diff-removed">-    /// Returns confirmed version after flush of all segments</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// # Errors</div><div class="diff-removed">-    /// Returns an error on flush failure</div><div class="diff-removed">-    fn flush_segments(segments: LockedSegmentHolder) -> OperationResult<SeqNumberType> {</div><div class="diff-removed">-        let read_segments = segments.read();</div><div class="diff-removed">-        let flushed_version = read_segments.flush_all(false, false)?;</div><div class="diff-removed">-        Ok(match read_segments.failed_operation.iter().cloned().min() {</div><div class="diff-removed">-            None => flushed_version,</div><div class="diff-removed">-            Some(failed_operation) => min(failed_operation, flushed_version),</div><div class="diff-added">+    fn flush_segments(segments: LockedSegmentHolder) -> Result<u64, OperationError> {</div><div class="diff-added">+        let read = segments.read();</div><div class="diff-added">+        let flushed = read.flush_all(true, false)?;</div><div class="diff-added">+        Ok(if let Some(min_failed) = read.failed_operation.iter().cloned().min() {</div><div class="diff-added">+            min(flushed, min_failed)</div><div class="diff-added">+        } else {</div><div class="diff-added">+            flushed</div><div>         })</div><div>     }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-/// Trigger optimizers when CPU budget is available</div><div class="diff-removed">-fn trigger_optimizers_on_resource_budget(</div><div class="diff-removed">-    optimizer_resource_budget: ResourceBudget,</div><div class="diff-removed">-    desired_cpus: usize,</div><div class="diff-removed">-    desired_io: usize,</div><div class="diff-removed">-    sender: Sender<OptimizerSignal>,</div><div class="diff-removed">-) -> JoinHandle<()> {</div><div class="diff-removed">-    task::spawn(async move {</div><div class="diff-removed">-        log::trace!("Skipping optimization checks, waiting for CPU budget to be available");</div><div class="diff-removed">-        optimizer_resource_budget</div><div class="diff-removed">-            .notify_on_budget_available(desired_cpus, desired_io)</div><div class="diff-removed">-            .await;</div><div class="diff-removed">-        log::trace!("Continue optimization checks, new CPU budget available");</div><div class="diff-removed">-</div><div class="diff-removed">-        // Trigger optimizers with Nop operation</div><div class="diff-removed">-        sender.send(OptimizerSignal::Nop).await.unwrap_or_else(|_| {</div><div class="diff-removed">-            log::info!("Can't notify optimizers, assume process is dead. Restart is required")</div><div class="diff-removed">-        });</div><div class="diff-removed">-    })</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    