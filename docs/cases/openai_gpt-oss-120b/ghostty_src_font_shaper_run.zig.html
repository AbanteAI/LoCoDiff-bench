<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: src/font/shaper/run.zig - GPT OSS 120B</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: src/font/shaper/run.zig</h1>
        <h2>Model: GPT OSS 120B</h2>
        <p><a href="../../models/openai_gpt-oss-120b.html">All GPT OSS 120B Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> GPT OSS 120B</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 18593</p>
                <p><strong>Native Prompt Tokens:</strong> 18734</p>
                <p><strong>Native Completion Tokens:</strong> 5112</p>
                <p><strong>Native Tokens Reasoning:</strong> 3159</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.0066441</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_font_shaper_run.zig/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_font_shaper_run.zig/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/openai_gpt-oss-120b/ghostty_src_font_shaper_run.zig/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index e41616d2b..c3c3ad899 100644</div><div class="diff-header">--- a/ghostty_src_font_shaper_run.zig_expectedoutput.txt (expected):tmp/tmppstibesj_expected.txt	</div><div class="diff-header">+++ b/ghostty_src_font_shaper_run.zig_extracted.txt (actual):tmp/tmph1xsq3xy_actual.txt	</div><div class="diff-info">@@ -8,27 +8,25 @@ const autoHash = std.hash.autoHash;</div><div> const Hasher = std.hash.Wyhash;</div><div> </div><div> /// A single text run. A text run is only valid for one Shaper instance and</div><div class="diff-removed">-/// until the next run is created. A text run never goes across multiple</div><div class="diff-added">+/// up to the next run is created. A text run never goes across multiple</div><div> /// rows in a terminal, so it is guaranteed to always be one line.</div><div> pub const TextRun = struct {</div><div>     /// A unique hash for this run. This can be used to cache the shaping</div><div class="diff-removed">-    /// results. We don't provide a means to compare actual values if the</div><div class="diff-removed">-    /// hash is the same, so we should continue to improve this hash to</div><div class="diff-removed">-    /// lower the chance of hash collisions if they become a problem. If</div><div class="diff-removed">-    /// there are hash collisions, it would result in rendering issues but</div><div class="diff-removed">-    /// the core data would be correct.</div><div class="diff-added">+    /// results. We don't provide a means to compare actual values if</div><div class="diff-added">+    /// collisions occur. This should be improved if collisions become</div><div class="diff-added">+    /// problematic.</div><div>     hash: u64,</div><div> </div><div class="diff-removed">-    /// The offset in the row where this run started</div><div class="diff-added">+    /// The offset in the row where this run started.</div><div>     offset: u16,</div><div> </div><div>     /// The total number of cells produced by this run.</div><div>     cells: u16,</div><div> </div><div class="diff-removed">-    /// The font grid that built this run.</div><div class="diff-added">+    /// The grid that built this run.</div><div>     grid: *font.SharedGrid,</div><div> </div><div class="diff-removed">-    /// The font index to use for the glyphs of this run.</div><div class="diff-added">+    /// The index within the font collection that this run uses.</div><div>     font_index: font.Collection.Index,</div><div> };</div><div> </div><div class="diff-info">@@ -45,79 +43,68 @@ pub const RunIterator = struct {</div><div>     pub fn next(self: *RunIterator, alloc: Allocator) !?TextRun {</div><div>         const cells = self.row.cells(.all);</div><div> </div><div class="diff-removed">-        // Trim the right side of a row that might be empty</div><div class="diff-added">+        // Determine the effective length of the row, ignoring trailing empty cells.</div><div>         const max: usize = max: {</div><div>             for (0..cells.len) |i| {</div><div>                 const rev_i = cells.len - i - 1;</div><div>                 if (!cells[rev_i].isEmpty()) break :max rev_i + 1;</div><div>             }</div><div class="diff-removed">-</div><div>             break :max 0;</div><div>         };</div><div> </div><div class="diff-removed">-        // Invisible cells don't have any glyphs rendered,</div><div class="diff-removed">-        // so we explicitly skip them in the shaping process.</div><div class="diff-added">+        // Skip invisible cells at the start.</div><div>         while (self.i < max and</div><div>             self.row.style(&cells[self.i]).flags.invisible)</div><div>         {</div><div>             self.i += 1;</div><div>         }</div><div> </div><div class="diff-removed">-        // We're over at the max</div><div class="diff-added">+        // We're over at the max.</div><div>         if (self.i >= max) return null;</div><div> </div><div class="diff-removed">-        // Track the font for our current run</div><div class="diff-removed">-        var current_font: font.Collection.Index = .{};</div><div class="diff-removed">-</div><div class="diff-removed">-        // Allow the hook to prepare</div><div class="diff-removed">-        try self.hooks.prepare();</div><div class="diff-removed">-</div><div class="diff-removed">-        // Initialize our hash for this run.</div><div class="diff-added">+        // Initialize hash for this run.</div><div>         var hasher = Hasher.init(0);</div><div> </div><div class="diff-removed">-        // Let's get our style that we'll expect for the run.</div><div class="diff-added">+        // Style for the run.</div><div>         const style = self.row.style(&cells[self.i]);</div><div> </div><div class="diff-removed">-        // Go through cell by cell and accumulate while we build our run.</div><div class="diff-added">+        // Track the font for our current run.</div><div class="diff-added">+        var current_font: font.Collection.Index = .{};</div><div class="diff-added">+</div><div class="diff-added">+        // Prepare hook.</div><div class="diff-added">+        try self.hooks.prepare();</div><div class="diff-added">+</div><div class="diff-added">+        // Accumulate.</div><div>         var j: usize = self.i;</div><div>         while (j < max) : (j += 1) {</div><div>             const cluster = j;</div><div>             const cell = &cells[j];</div><div> </div><div class="diff-removed">-            // If we have a selection and we're at a boundary point, then</div><div class="diff-removed">-            // we break the run here.</div><div class="diff-added">+            // Selection boundaries.</div><div>             if (self.selection) |unordered_sel| {</div><div>                 if (j > self.i) {</div><div>                     const sel = unordered_sel.ordered(self.screen, .forward);</div><div>                     const start_x = sel.start().x;</div><div>                     const end_x = sel.end().x;</div><div> </div><div class="diff-removed">-                    if (start_x > 0 and</div><div class="diff-removed">-                        j == start_x) break;</div><div class="diff-removed">-</div><div class="diff-removed">-                    if (end_x > 0 and</div><div class="diff-removed">-                        j == end_x + 1) break;</div><div class="diff-added">+                    if (start_x > 0 and j == start_x) break;</div><div class="diff-added">+                    if (end_x > 0 and j == end_x + 1) break;</div><div>                 }</div><div>             }</div><div> </div><div class="diff-removed">-            // If we're a spacer, then we ignore it</div><div class="diff-added">+            // Skip wide spacers.</div><div>             switch (cell.wide) {</div><div class="diff-removed">-                .narrow, .wide => {},</div><div>                 .spacer_head, .spacer_tail => continue,</div><div class="diff-added">+                .narrow, .wide => {},</div><div>             }</div><div> </div><div class="diff-removed">-            // If our cell attributes are changing, then we split the run.</div><div class="diff-removed">-            // This prevents a single glyph for ">=" to be rendered with</div><div class="diff-removed">-            // one color when the two components have different styling.</div><div class="diff-added">+            // Split on common bad ligatures and other style changes.</div><div>             if (j > self.i) style: {</div><div>                 const prev_cell = cells[j - 1];</div><div> </div><div class="diff-removed">-                // If the prev cell and this cell are both plain</div><div class="diff-removed">-                // codepoints then we check if they are commonly "bad"</div><div class="diff-removed">-                // ligatures and spit the run if they are.</div><div class="diff-added">+                // Bad ligature checks for plain codepoints.</div><div>                 if (prev_cell.content_tag == .codepoint and</div><div class="diff-removed">-                    cell.content_tag == .codepoint)</div><div class="diff-removed">-                {</div><div class="diff-added">+                    cell.content_tag == .codepoint) {</div><div>                     const prev_cp = prev_cell.codepoint();</div><div>                     switch (prev_cp) {</div><div>                         // fl, fi</div><div class="diff-info">@@ -125,173 +112,129 @@ pub const RunIterator = struct {</div><div>                             const cp = cell.codepoint();</div><div>                             if (cp == 'l' or cp == 'i') break;</div><div>                         },</div><div class="diff-removed">-</div><div>                         // st</div><div>                         's' => {</div><div>                             const cp = cell.codepoint();</div><div>                             if (cp == 't') break;</div><div>                         },</div><div class="diff-removed">-</div><div>                         else => {},</div><div>                     }</div><div>                 }</div><div> </div><div class="diff-removed">-                // If the style is exactly the change then fast path out.</div><div class="diff-added">+                // If the style is exactly the same, fast‑path out.</div><div>                 if (prev_cell.style_id == cell.style_id) break :style;</div><div> </div><div class="diff-removed">-                // The style is different. We allow differing background</div><div class="diff-removed">-                // styles but any other change results in a new run.</div><div class="diff-removed">-                const c1 = comparableStyle(style);</div><div class="diff-removed">-                const c2 = comparableStyle(self.row.style(&cells[j]));</div><div class="diff-added">+                // Compare style, allowing differences in background.</div><div class="diff-added">+                const c1 = comparableStyle(self.row.style(&prev_cell));</div><div class="diff-added">+                const c2 = comparableStyle(style);</div><div>                 if (!c1.eql(c2)) break;</div><div>             }</div><div> </div><div class="diff-removed">-            // Text runs break when font styles change so we need to get</div><div class="diff-removed">-            // the proper style.</div><div class="diff-added">+            // Determine font style (bold/italic).</div><div>             const font_style: font.Style = style: {</div><div>                 if (style.flags.bold) {</div><div>                     if (style.flags.italic) break :style .bold_italic;</div><div>                     break :style .bold;</div><div>                 }</div><div class="diff-removed">-</div><div>                 if (style.flags.italic) break :style .italic;</div><div>                 break :style .regular;</div><div>             };</div><div> </div><div class="diff-removed">-            // Determine the presentation format for this glyph.</div><div class="diff-added">+            // Determine presentation.</div><div>             const presentation: ?font.Presentation = if (cell.hasGrapheme()) p: {</div><div class="diff-removed">-                // We only check the FIRST codepoint because I believe the</div><div class="diff-removed">-                // presentation format must be directly adjacent to the codepoint.</div><div>                 const cps = self.row.grapheme(cell) orelse break :p null;</div><div>                 assert(cps.len > 0);</div><div>                 if (cps[0] == 0xFE0E) break :p .text;</div><div>                 if (cps[0] == 0xFE0F) break :p .emoji;</div><div>                 break :p null;</div><div>             } else emoji: {</div><div class="diff-removed">-                // If we're not a grapheme, our individual char could be</div><div class="diff-removed">-                // an emoji so we want to check if we expect emoji presentation.</div><div class="diff-removed">-                // The font grid indexForCodepoint we use below will do this</div><div class="diff-removed">-                // automatically.</div><div class="diff-added">+                // The font grid getIndex will handle presentation automatically.</div><div>                 break :emoji null;</div><div>             };</div><div> </div><div class="diff-removed">-            // If our cursor is on this line then we break the run around the</div><div class="diff-removed">-            // cursor. This means that any row with a cursor has at least</div><div class="diff-removed">-            // three breaks: before, exactly the cursor, and after.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // We do not break a cell that is exactly the grapheme. If there</div><div class="diff-removed">-            // are cells following that contain joiners, we allow those to</div><div class="diff-removed">-            // break. This creates an effect where hovering over an emoji</div><div class="diff-removed">-            // such as a skin-tone emoji is fine, but hovering over the</div><div class="diff-removed">-            // joiners will show the joiners allowing you to modify the</div><div class="diff-removed">-            // emoji.</div><div class="diff-added">+            // Break on cursor conditions, ignoring cells that are</div><div class="diff-added">+            // part of a grapheme.</div><div>             if (!cell.hasGrapheme()) {</div><div>                 if (self.cursor_x) |cursor_x| {</div><div class="diff-removed">-                    // Exactly: self.i is the cursor and we iterated once. This</div><div class="diff-removed">-                    // means that we started exactly at the cursor and did at</div><div class="diff-removed">-                    // exactly one iteration. Why exactly one? Because we may</div><div class="diff-removed">-                    // start at our cursor but do many if our cursor is exactly</div><div class="diff-removed">-                    // on an emoji.</div><div class="diff-removed">-                    if (self.i == cursor_x and j == self.i + 1) break;</div><div class="diff-removed">-</div><div class="diff-removed">-                    // Before: up to and not including the cursor. This means</div><div class="diff-removed">-                    // that we started before the cursor (self.i < cursor_x)</div><div class="diff-removed">-                    // and j is now at the cursor meaning we haven't yet processed</div><div class="diff-removed">-                    // the cursor.</div><div class="diff-added">+                    if (self.i == cursor_x and j > self.i) {</div><div class="diff-added">+                        // Exactly at cursor, break.</div><div class="diff-added">+                        break;</div><div class="diff-added">+                    }</div><div>                     if (self.i < cursor_x and j == cursor_x) {</div><div class="diff-removed">-                        assert(j > 0);</div><div class="diff-added">+                        // Before cursor.</div><div>                         break;</div><div>                     }</div><div class="diff-removed">-</div><div class="diff-removed">-                    // After: after the cursor. We don't need to do anything</div><div class="diff-removed">-                    // special, we just let the run complete.</div><div class="diff-added">+                    // After: no break required.</div><div>                 }</div><div>             }</div><div> </div><div class="diff-removed">-            // We need to find a font that supports this character. If</div><div class="diff-removed">-            // there are additional zero-width codepoints (to form a single</div><div class="diff-removed">-            // grapheme, i.e. combining characters), we need to find a font</div><div class="diff-removed">-            // that supports all of them.</div><div class="diff-added">+            // Find a suitable font index for the cell (including grapheme.</div><div>             const font_info: struct {</div><div>                 idx: font.Collection.Index,</div><div>                 fallback: ?u32 = null,</div><div>             } = font_info: {</div><div class="diff-removed">-                // If we find a font that supports this entire grapheme</div><div class="diff-removed">-                // then we use that.</div><div class="diff-removed">-                if (try self.indexForCell(</div><div class="diff-removed">-                    alloc,</div><div class="diff-removed">-                    cell,</div><div class="diff-removed">-                    font_style,</div><div class="diff-removed">-                    presentation,</div><div class="diff-removed">-                )) |idx| break :font_info .{ .idx = idx };</div><div class="diff-removed">-</div><div class="diff-removed">-                // Otherwise we need a fallback character. Prefer the</div><div class="diff-removed">-                // official replacement character.</div><div class="diff-added">+                // Try to find a font that supports the entire grapheme.</div><div class="diff-added">+                    if (try self.indexForCell(</div><div class="diff-added">+                        alloc,</div><div class="diff-added">+                        cell,</div><div class="diff-added">+                        style,</div><div class="diff-added">+                        presentation,</div><div class="diff-added">+                    )) |idx| break :font_info .{ .idx = idx };</div><div class="diff-added">+                // Fallback to replacement character.</div><div>                 if (try self.grid.getIndex(</div><div>                     alloc,</div><div class="diff-removed">-                    0xFFFD, // replacement char</div><div class="diff-added">+                    0xFFFD,</div><div>                     font_style,</div><div>                     presentation,</div><div>                 )) |idx| break :font_info .{ .idx = idx, .fallback = 0xFFFD };</div><div class="diff-removed">-</div><div class="diff-removed">-                // Fallback to space</div><div class="diff-added">+                // Fallback to space.</div><div>                 if (try self.grid.getIndex(</div><div>                     alloc,</div><div>                     ' ',</div><div>                     font_style,</div><div>                     presentation,</div><div>                 )) |idx| break :font_info .{ .idx = idx, .fallback = ' ' };</div><div class="diff-removed">-</div><div class="diff-removed">-                // We can't render at all. This is a bug, we should always</div><div class="diff-removed">-                // have a font that can render a space.</div><div class="diff-added">+                // Should always have a space.</div><div>                 unreachable;</div><div>             };</div><div class="diff-removed">-</div><div class="diff-removed">-            //log.warn("char={x} info={}", .{ cell.char, font_info });</div><div>             if (j == self.i) current_font = font_info.idx;</div><div> </div><div class="diff-removed">-            // If our fonts are not equal, then we're done with our run.</div><div class="diff-added">+            // Break if font index changes.</div><div>             if (font_info.idx.int() != current_font.int()) break;</div><div> </div><div class="diff-removed">-            // If we're a fallback character, add that and continue; we</div><div class="diff-removed">-            // don't want to add the entire grapheme.</div><div class="diff-added">+            // Add codepoints.</div><div>             if (font_info.fallback) |cp| {</div><div class="diff-added">+                // Use fallback char.</div><div>                 try self.addCodepoint(&hasher, cp, @intCast(cluster));</div><div>                 continue;</div><div>             }</div><div> </div><div class="diff-removed">-            // If we're a Kitty unicode placeholder then we add a blank.</div><div class="diff-removed">-            if (cell.codepoint() == terminal.kitty.graphics.unicode.placeholder) {</div><div class="diff-removed">-                try self.addCodepoint(&hasher, ' ', @intCast(cluster));</div><div class="diff-removed">-                continue;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Add all the codepoints for our grapheme</div><div class="diff-added">+            // Main codepoint.</div><div>             try self.addCodepoint(</div><div>                 &hasher,</div><div>                 if (cell.codepoint() == 0) ' ' else cell.codepoint(),</div><div>                 @intCast(cluster),</div><div>             );</div><div class="diff-added">+</div><div class="diff-added">+            // Additional grapheme codepoints.</div><div>             if (cell.hasGrapheme()) {</div><div>                 const cps = self.row.grapheme(cell).?;</div><div>                 for (cps) |cp| {</div><div class="diff-removed">-                    // Do not send presentation modifiers</div><div>                     if (cp == 0xFE0E or cp == 0xFE0F) continue;</div><div>                     try self.addCodepoint(&hasher, cp, @intCast(cluster));</div><div>                 }</div><div>             }</div><div>         }</div><div> </div><div class="diff-removed">-        // Finalize our buffer</div><div class="diff-added">+        // Finalize hooks.</div><div>         try self.hooks.finalize();</div><div> </div><div class="diff-removed">-        // Add our length to the hash as an additional mechanism to avoid collisions</div><div class="diff-added">+        // Hash length.</div><div>         autoHash(&hasher, j - self.i);</div><div class="diff-removed">-</div><div class="diff-removed">-        // Add our font index</div><div class="diff-added">+        // Include font index.</div><div>         autoHash(&hasher, current_font);</div><div> </div><div class="diff-removed">-        // Move our cursor. Must defer since we use self.i below.</div><div class="diff-added">+        // Move cursor.</div><div>         defer self.i = j;</div><div> </div><div>         return TextRun{</div><div class="diff-info">@@ -309,12 +252,6 @@ pub const RunIterator = struct {</div><div>         try self.hooks.addCodepoint(cp, cluster);</div><div>     }</div><div> </div><div class="diff-removed">-    /// Find a font index that supports the grapheme for the given cell,</div><div class="diff-removed">-    /// or null if no such font exists.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// This is used to find a font that supports the entire grapheme.</div><div class="diff-removed">-    /// We look for fonts that support each individual codepoint and then</div><div class="diff-removed">-    /// find the common font amongst all candidates.</div><div>     fn indexForCell(</div><div>         self: *RunIterator,</div><div>         alloc: Allocator,</div><div class="diff-info">@@ -322,6 +259,7 @@ pub const RunIterator = struct {</div><div>         style: font.Style,</div><div>         presentation: ?font.Presentation,</div><div>     ) !?font.Collection.Index {</div><div class="diff-added">+        // Handle empty or placeholder cells.</div><div>         if (cell.isEmpty() or</div><div>             cell.codepoint() == 0 or</div><div>             cell.codepoint() == terminal.kitty.graphics.unicode.placeholder)</div><div class="diff-info">@@ -334,37 +272,24 @@ pub const RunIterator = struct {</div><div>             );</div><div>         }</div><div> </div><div class="diff-removed">-        // Get the font index for the primary codepoint.</div><div class="diff-removed">-        const primary_cp: u32 = cell.codepoint();</div><div class="diff-added">+        // Primary codepoint.</div><div>         const primary = try self.grid.getIndex(</div><div>             alloc,</div><div class="diff-removed">-            primary_cp,</div><div class="diff-added">+            cell.codepoint(),</div><div>             style,</div><div>             presentation,</div><div>         ) orelse return null;</div><div> </div><div class="diff-removed">-        // Easy, and common: we aren't a multi-codepoint grapheme, so</div><div class="diff-removed">-        // we just return whatever index for the cell codepoint.</div><div class="diff-added">+        // If not a grapheme, return primary.</div><div>         if (!cell.hasGrapheme()) return primary;</div><div> </div><div class="diff-removed">-        // If this is a grapheme, we need to find a font that supports</div><div class="diff-removed">-        // all of the codepoints in the grapheme.</div><div>         const cps = self.row.grapheme(cell) orelse return primary;</div><div>         var candidates = try std.ArrayList(font.Collection.Index).initCapacity(alloc, cps.len + 1);</div><div>         defer candidates.deinit();</div><div>         candidates.appendAssumeCapacity(primary);</div><div> </div><div>         for (cps) |cp| {</div><div class="diff-removed">-            // Ignore Emoji ZWJs</div><div>             if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;</div><div class="diff-removed">-</div><div class="diff-removed">-            // Find a font that supports this codepoint. If none support this</div><div class="diff-removed">-            // then the whole grapheme can't be rendered so we return null.</div><div class="diff-removed">-            //</div><div class="diff-removed">-            // We explicitly do not require the additional grapheme components</div><div class="diff-removed">-            // to support the base presentation, since it is common for emoji</div><div class="diff-removed">-            // fonts to support the base emoji with emoji presentation but not</div><div class="diff-removed">-            // certain ZWJ-combined characters like the male and female signs.</div><div>             const idx = try self.grid.getIndex(</div><div>                 alloc,</div><div>                 cp,</div><div class="diff-info">@@ -374,16 +299,13 @@ pub const RunIterator = struct {</div><div>             candidates.appendAssumeCapacity(idx);</div><div>         }</div><div> </div><div class="diff-removed">-        // We need to find a candidate that has ALL of our codepoints</div><div class="diff-added">+        // Find a candidate that supports all codepoints.</div><div>         for (candidates.items) |idx| {</div><div class="diff-removed">-            if (!self.grid.hasCodepoint(idx, primary_cp, presentation)) continue;</div><div class="diff-added">+            if (!self.grid.hasCodepoint(idx, primary, presentation)) continue;</div><div>             for (cps) |cp| {</div><div class="diff-removed">-                // Ignore Emoji ZWJs</div><div>                 if (cp == 0xFE0E or cp == 0xFE0F or cp == 0x200D) continue;</div><div class="diff-removed">-                if (!self.grid.hasCodepoint(idx, cp, null)) break;</div><div class="diff-added">+                if (!self.grid.hasCodepoint(idx, cp, presentation)) break;</div><div>             } else {</div><div class="diff-removed">-                // If the while completed, then we have a candidate that</div><div class="diff-removed">-                // supports all of our codepoints.</div><div>                 return idx;</div><div>             }</div><div>         }</div><div class="diff-info">@@ -392,15 +314,9 @@ pub const RunIterator = struct {</div><div>     }</div><div> };</div><div> </div><div class="diff-removed">-/// Returns a style that when compared must be identical for a run to</div><div class="diff-removed">-/// continue.</div><div class="diff-added">+/// Returns a style that is comparable for run continuation.</div><div> fn comparableStyle(style: terminal.Style) terminal.Style {</div><div>     var s = style;</div><div class="diff-removed">-</div><div class="diff-removed">-    // We allow background colors to differ because we'll just paint the</div><div class="diff-removed">-    // cell background whatever the style is, and wherever the glyph</div><div class="diff-removed">-    // lands on top of it will be the color of the glyph.</div><div>     s.bg_color = .none;</div><div class="diff-removed">-</div><div>     return s;</div><div> }</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    