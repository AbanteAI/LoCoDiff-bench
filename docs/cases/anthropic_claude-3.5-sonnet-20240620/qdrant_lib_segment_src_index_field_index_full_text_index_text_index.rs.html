<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/segment/src/index/field_index/full_text_index/text_index.rs - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/segment/src/index/field_index/full_text_index/text_index.rs</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet-20240620.html">All Sonnet 3.5 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.5</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 34279</p>
                <p><strong>Native Prompt Tokens:</strong> 46471</p>
                <p><strong>Native Completion Tokens:</strong> 399</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.145398</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 9edafacaa..b1acfd313 100644</div><div class="diff-header">--- a/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs_expectedoutput.txt (expected):tmp/tmpt9_z6qo1_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs_extracted.txt (actual):tmp/tmpi5fcivtb_actual.txt	</div><div class="diff-info">@@ -1,426 +1,28 @@</div><div class="diff-removed">-use std::collections::{BTreeSet, HashSet};</div><div class="diff-removed">-use std::path::PathBuf;</div><div class="diff-removed">-use std::sync::Arc;</div><div class="diff-added">+Here's a summary of the key changes made to the `lib/qdrant_lib_segment_src_index_field_index_full_text_index_text_index.rs_extracted.txt (actual):</div><div> </div><div class="diff-removed">-use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-use common::types::PointOffsetType;</div><div class="diff-removed">-use parking_lot::RwLock;</div><div class="diff-removed">-use rocksdb::DB;</div><div class="diff-removed">-use serde::{Deserialize, Serialize};</div><div class="diff-removed">-use serde_json::Value;</div><div class="diff-added">+1. The `FullTextIndex` is now implemented as an enum with three variants:</div><div class="diff-added">+   - `Mutable(MutableFullTextIndex)`</div><div class="diff-added">+   - `Immutable(ImmutableFullTextIndex)`</div><div class="diff-added">+   - `Mmap(Box<MmapFullTextIndex>)`</div><div> </div><div class="diff-removed">-use super::immutable_text_index::ImmutableFullTextIndex;</div><div class="diff-removed">-use super::inverted_index::{Document, InvertedIndex, ParsedQuery, TokenId};</div><div class="diff-removed">-use super::mmap_text_index::{FullTextMmapIndexBuilder, MmapFullTextIndex};</div><div class="diff-removed">-use super::mutable_text_index::MutableFullTextIndex;</div><div class="diff-removed">-use super::tokenizers::Tokenizer;</div><div class="diff-removed">-use crate::common::Flusher;</div><div class="diff-removed">-use crate::common::operation_error::{OperationError, OperationResult};</div><div class="diff-removed">-use crate::common::rocksdb_buffered_delete_wrapper::DatabaseColumnScheduledDeleteWrapper;</div><div class="diff-removed">-use crate::common::rocksdb_wrapper::DatabaseColumnWrapper;</div><div class="diff-removed">-use crate::data_types::index::TextIndexParams;</div><div class="diff-removed">-use crate::index::field_index::{</div><div class="diff-removed">-    CardinalityEstimation, FieldIndexBuilderTrait, PayloadBlockCondition, PayloadFieldIndex,</div><div class="diff-removed">-    ValueIndexer,</div><div class="diff-removed">-};</div><div class="diff-removed">-use crate::telemetry::PayloadIndexTelemetry;</div><div class="diff-removed">-use crate::types::{FieldCondition, Match, PayloadKeyType};</div><div class="diff-added">+2. New constructors and methods were added:</div><div class="diff-added">+   - `new_memory` for creating in-memory indexes</div><div class="diff-added">+   - `new_mmap` for creating memory-mapped indexes</div><div class="diff-added">+   - `builder` and `builder_mmap` for creating index builders</div><div> </div><div class="diff-removed">-pub enum FullTextIndex {</div><div class="diff-removed">-    Mutable(MutableFullTextIndex),</div><div class="diff-removed">-    Immutable(ImmutableFullTextIndex),</div><div class="diff-removed">-    Mmap(Box<MmapFullTextIndex>),</div><div class="diff-removed">-}</div><div class="diff-added">+3. Methods like `filter`, `estimate_cardinality`, and `check_match` now take a `HardwareCounterCell` parameter for IO measurements.</div><div> </div><div class="diff-removed">-impl FullTextIndex {</div><div class="diff-removed">-    pub fn new_memory(</div><div class="diff-removed">-        db: Arc<RwLock<DB>>,</div><div class="diff-removed">-        config: TextIndexParams,</div><div class="diff-removed">-        field: &str,</div><div class="diff-removed">-        is_appendable: bool,</div><div class="diff-removed">-    ) -> Self {</div><div class="diff-removed">-        let store_cf_name = Self::storage_cf_name(field);</div><div class="diff-removed">-        let db_wrapper = DatabaseColumnScheduledDeleteWrapper::new(DatabaseColumnWrapper::new(</div><div class="diff-removed">-            db,</div><div class="diff-removed">-            &store_cf_name,</div><div class="diff-removed">-        ));</div><div class="diff-removed">-        if is_appendable {</div><div class="diff-removed">-            Self::Mutable(MutableFullTextIndex::new(db_wrapper, config))</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-            Self::Immutable(ImmutableFullTextIndex::new(db_wrapper, config))</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-added">+4. The `ValueIndexer` and `PayloadFieldIndex` traits were implemented for `FullTextIndex`.</div><div> </div><div class="diff-removed">-    pub fn new_mmap(</div><div class="diff-removed">-        path: PathBuf,</div><div class="diff-removed">-        config: TextIndexParams,</div><div class="diff-removed">-        is_on_disk: bool,</div><div class="diff-removed">-    ) -> OperationResult<Self> {</div><div class="diff-removed">-        Ok(Self::Mmap(Box::new(MmapFullTextIndex::open(</div><div class="diff-removed">-            path, config, is_on_disk,</div><div class="diff-removed">-        )?)))</div><div class="diff-removed">-    }</div><div class="diff-added">+5. New methods were added to support disk caching and population:</div><div class="diff-added">+   - `is_on_disk()`</div><div class="diff-added">+   - `populate()`</div><div class="diff-added">+   - `clear_cache()`</div><div> </div><div class="diff-removed">-    pub fn init(&mut self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.init(),</div><div class="diff-removed">-            Self::Immutable(index) => index.init(),</div><div class="diff-removed">-            Self::Mmap(_) => unreachable!("not applicable for mmap immutable index"),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-added">+6. The `get_telemetry_data()` method now includes an `index_type` field to distinguish between mutable, immutable, and mmap indexes.</div><div> </div><div class="diff-removed">-    pub fn builder(</div><div class="diff-removed">-        db: Arc<RwLock<DB>>,</div><div class="diff-removed">-        config: TextIndexParams,</div><div class="diff-removed">-        field: &str,</div><div class="diff-removed">-    ) -> FullTextIndexBuilder {</div><div class="diff-removed">-        FullTextIndexBuilder(Self::new_memory(db, config, field, true))</div><div class="diff-removed">-    }</div><div class="diff-added">+7. The code now uses Rust 2024 edition features and has been updated to work with newer versions of dependencies.</div><div> </div><div class="diff-removed">-    pub fn builder_mmap(</div><div class="diff-removed">-        path: PathBuf,</div><div class="diff-removed">-        config: TextIndexParams,</div><div class="diff-removed">-        is_on_disk: bool,</div><div class="diff-removed">-    ) -> FullTextMmapIndexBuilder {</div><div class="diff-removed">-        FullTextMmapIndexBuilder::new(path, config, is_on_disk)</div><div class="diff-removed">-    }</div><div class="diff-added">+8. Various optimizations and refactorings were made to improve performance and code structure.</div><div> </div><div class="diff-removed">-    fn storage_cf_name(field: &str) -> String {</div><div class="diff-removed">-        format!("{field}_fts")</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn config(&self) -> &TextIndexParams {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => &index.config,</div><div class="diff-removed">-            Self::Immutable(index) => &index.config,</div><div class="diff-removed">-            Self::Mmap(index) => &index.config,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn points_count(&self) -> usize {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.inverted_index.points_count(),</div><div class="diff-removed">-            Self::Immutable(index) => index.inverted_index.points_count(),</div><div class="diff-removed">-            Self::Mmap(index) => index.inverted_index.points_count(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_token(&self, token: &str, hw_counter: &HardwareCounterCell) -> Option<TokenId> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.inverted_index.get_token_id(token, hw_counter),</div><div class="diff-removed">-            Self::Immutable(index) => index.inverted_index.get_token_id(token, hw_counter),</div><div class="diff-removed">-            Self::Mmap(index) => index.inverted_index.get_token_id(token, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn filter<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        query: ParsedQuery,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-removed">-    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.inverted_index.filter(query, hw_counter),</div><div class="diff-removed">-            Self::Immutable(index) => index.inverted_index.filter(query, hw_counter),</div><div class="diff-removed">-            Self::Mmap(index) => index.inverted_index.filter(query, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn payload_blocks(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        threshold: usize,</div><div class="diff-removed">-        key: PayloadKeyType,</div><div class="diff-removed">-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),</div><div class="diff-removed">-            Self::Immutable(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),</div><div class="diff-removed">-            Self::Mmap(index) => Box::new(index.inverted_index.payload_blocks(threshold, key)),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn estimate_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        query: &ParsedQuery,</div><div class="diff-removed">-        condition: &FieldCondition,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> CardinalityEstimation {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .estimate_cardinality(query, condition, hw_counter),</div><div class="diff-removed">-            Self::Immutable(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .estimate_cardinality(query, condition, hw_counter),</div><div class="diff-removed">-            Self::Mmap(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .estimate_cardinality(query, condition, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn check_match(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        query: &ParsedQuery,</div><div class="diff-removed">-        point_id: PointOffsetType,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .check_match(query, point_id, hw_counter),</div><div class="diff-removed">-            Self::Immutable(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .check_match(query, point_id, hw_counter),</div><div class="diff-removed">-            Self::Mmap(index) => index</div><div class="diff-removed">-                .inverted_index</div><div class="diff-removed">-                .check_match(query, point_id, hw_counter),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn values_count(&self, point_id: PointOffsetType) -> usize {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.inverted_index.values_count(point_id),</div><div class="diff-removed">-            Self::Immutable(index) => index.inverted_index.values_count(point_id),</div><div class="diff-removed">-            Self::Mmap(index) => index.inverted_index.values_count(point_id),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn values_is_empty(&self, point_id: PointOffsetType) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.inverted_index.values_is_empty(point_id),</div><div class="diff-removed">-            Self::Immutable(index) => index.inverted_index.values_is_empty(point_id),</div><div class="diff-removed">-            Self::Mmap(index) => index.inverted_index.values_is_empty(point_id),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(super) fn store_key(id: PointOffsetType) -> Vec<u8> {</div><div class="diff-removed">-        bincode::serialize(&id).unwrap()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(super) fn restore_key(data: &[u8]) -> PointOffsetType {</div><div class="diff-removed">-        bincode::deserialize(data).unwrap()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(super) fn serialize_document_tokens(tokens: BTreeSet<String>) -> OperationResult<Vec<u8>> {</div><div class="diff-removed">-        #[derive(Serialize)]</div><div class="diff-removed">-        struct StoredDocument {</div><div class="diff-removed">-            tokens: BTreeSet<String>,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        let doc = StoredDocument { tokens };</div><div class="diff-removed">-        serde_cbor::to_vec(&doc).map_err(|e| {</div><div class="diff-removed">-            OperationError::service_error(format!("Failed to serialize document: {e}"))</div><div class="diff-removed">-        })</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub(super) fn deserialize_document(data: &[u8]) -> OperationResult<BTreeSet<String>> {</div><div class="diff-removed">-        #[derive(Deserialize)]</div><div class="diff-removed">-        struct StoredDocument {</div><div class="diff-removed">-            tokens: BTreeSet<String>,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        serde_cbor::from_slice::<StoredDocument>(data)</div><div class="diff-removed">-            .map_err(|e| {</div><div class="diff-removed">-                OperationError::service_error(format!("Failed to deserialize document: {e}"))</div><div class="diff-removed">-            })</div><div class="diff-removed">-            .map(|doc| doc.tokens)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn get_telemetry_data(&self) -> PayloadIndexTelemetry {</div><div class="diff-removed">-        PayloadIndexTelemetry {</div><div class="diff-removed">-            field_name: None,</div><div class="diff-removed">-            index_type: match self {</div><div class="diff-removed">-                FullTextIndex::Mutable(_) => "mutable_full_text",</div><div class="diff-removed">-                FullTextIndex::Immutable(_) => "immutable_full_text",</div><div class="diff-removed">-                FullTextIndex::Mmap(_) => "mmap_full_text",</div><div class="diff-removed">-            },</div><div class="diff-removed">-            points_values_count: self.points_count(),</div><div class="diff-removed">-            points_count: self.points_count(),</div><div class="diff-removed">-            histogram_bucket_size: None,</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn parse_query(&self, text: &str, hw_counter: &HardwareCounterCell) -> ParsedQuery {</div><div class="diff-removed">-        let mut tokens = HashSet::new();</div><div class="diff-removed">-        Tokenizer::tokenize_query(text, self.config(), |token| {</div><div class="diff-removed">-            tokens.insert(self.get_token(token, hw_counter));</div><div class="diff-removed">-        });</div><div class="diff-removed">-        ParsedQuery {</div><div class="diff-removed">-            tokens: tokens.into_iter().collect(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn parse_document(&self, text: &str, hw_counter: &HardwareCounterCell) -> Document {</div><div class="diff-removed">-        let mut document_tokens = vec![];</div><div class="diff-removed">-        Tokenizer::tokenize_doc(text, self.config(), |token| {</div><div class="diff-removed">-            if let Some(token_id) = self.get_token(token, hw_counter) {</div><div class="diff-removed">-                document_tokens.push(token_id);</div><div class="diff-removed">-            }</div><div class="diff-removed">-        });</div><div class="diff-removed">-        Document::new(document_tokens)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[cfg(test)]</div><div class="diff-removed">-    pub fn query<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        query: &'a str,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-removed">-    ) -> Box<dyn Iterator<Item = PointOffsetType> + 'a> {</div><div class="diff-removed">-        let parsed_query = self.parse_query(query, hw_counter);</div><div class="diff-removed">-        self.filter(parsed_query, hw_counter)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    pub fn is_on_disk(&self) -> bool {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            FullTextIndex::Mutable(_) => false,</div><div class="diff-removed">-            FullTextIndex::Immutable(_) => false,</div><div class="diff-removed">-            FullTextIndex::Mmap(index) => index.is_on_disk(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Populate all pages in the mmap.</div><div class="diff-removed">-    /// Block until all pages are populated.</div><div class="diff-removed">-    pub fn populate(&self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            FullTextIndex::Mutable(_) => {}   // Not a mmap</div><div class="diff-removed">-            FullTextIndex::Immutable(_) => {} // Not a mmap</div><div class="diff-removed">-            FullTextIndex::Mmap(index) => index.populate()?,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Drop disk cache.</div><div class="diff-removed">-    pub fn clear_cache(&self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            FullTextIndex::Mutable(_) => {}   // Not a mmap</div><div class="diff-removed">-            FullTextIndex::Immutable(_) => {} // Not a mmap</div><div class="diff-removed">-            FullTextIndex::Mmap(index) => index.clear_cache()?,</div><div class="diff-removed">-        }</div><div class="diff-removed">-        Ok(())</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-pub struct FullTextIndexBuilder(FullTextIndex);</div><div class="diff-removed">-</div><div class="diff-removed">-impl FieldIndexBuilderTrait for FullTextIndexBuilder {</div><div class="diff-removed">-    type FieldIndexType = FullTextIndex;</div><div class="diff-removed">-</div><div class="diff-removed">-    fn init(&mut self) -> OperationResult<()> {</div><div class="diff-removed">-        self.0.init()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn add_point(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        id: PointOffsetType,</div><div class="diff-removed">-        payload: &[&Value],</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        self.0.add_point(id, payload, hw_counter)</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn finalize(self) -> OperationResult<Self::FieldIndexType> {</div><div class="diff-removed">-        Ok(self.0)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl ValueIndexer for FullTextIndex {</div><div class="diff-removed">-    type ValueType = String;</div><div class="diff-removed">-</div><div class="diff-removed">-    fn add_many(</div><div class="diff-removed">-        &mut self,</div><div class="diff-removed">-        idx: PointOffsetType,</div><div class="diff-removed">-        values: Vec<String>,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.add_many(idx, values, hw_counter),</div><div class="diff-removed">-            Self::Immutable(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Cannot add values to immutable text index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-            Self::Mmap(_) => Err(OperationError::service_error(</div><div class="diff-removed">-                "Cannot add values to mmap text index",</div><div class="diff-removed">-            )),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn get_value(value: &Value) -> Option<String> {</div><div class="diff-removed">-        if let Value::String(keyword) = value {</div><div class="diff-removed">-            return Some(keyword.to_owned());</div><div class="diff-removed">-        }</div><div class="diff-removed">-        None</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn remove_point(&mut self, id: PointOffsetType) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            FullTextIndex::Mutable(index) => index.remove_point(id),</div><div class="diff-removed">-            FullTextIndex::Immutable(index) => index.remove_point(id),</div><div class="diff-removed">-            FullTextIndex::Mmap(index) => index.remove_point(id),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-impl PayloadFieldIndex for FullTextIndex {</div><div class="diff-removed">-    fn count_indexed_points(&self) -> usize {</div><div class="diff-removed">-        self.points_count()</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn load(&mut self) -> OperationResult<bool> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.load_from_db(),</div><div class="diff-removed">-            Self::Immutable(index) => index.load_from_db(),</div><div class="diff-removed">-            Self::Mmap(_index) => Ok(true), // mmap index is always loaded</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn cleanup(self) -> OperationResult<()> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.clear(),</div><div class="diff-removed">-            Self::Immutable(index) => index.clear(),</div><div class="diff-removed">-            Self::Mmap(index) => index.clear(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn flusher(&self) -> Flusher {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(index) => index.db_wrapper.flusher(),</div><div class="diff-removed">-            Self::Immutable(index) => index.db_wrapper.flusher(),</div><div class="diff-removed">-            Self::Mmap(index) => index.flusher(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn files(&self) -> Vec<PathBuf> {</div><div class="diff-removed">-        match self {</div><div class="diff-removed">-            Self::Mutable(_) => vec![],</div><div class="diff-removed">-            Self::Immutable(_) => vec![],</div><div class="diff-removed">-            Self::Mmap(index) => index.files(),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn filter<'a>(</div><div class="diff-removed">-        &'a self,</div><div class="diff-removed">-        condition: &'a FieldCondition,</div><div class="diff-removed">-        hw_counter: &'a HardwareCounterCell,</div><div class="diff-removed">-    ) -> Option<Box<dyn Iterator<Item = PointOffsetType> + 'a>> {</div><div class="diff-removed">-        if let Some(Match::Text(text_match)) = &condition.r#match {</div><div class="diff-removed">-            let parsed_query = self.parse_query(&text_match.text, hw_counter);</div><div class="diff-removed">-            return Some(self.filter(parsed_query, hw_counter));</div><div class="diff-removed">-        }</div><div class="diff-removed">-        None</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn estimate_cardinality(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        condition: &FieldCondition,</div><div class="diff-removed">-        hw_counter: &HardwareCounterCell,</div><div class="diff-removed">-    ) -> Option<CardinalityEstimation> {</div><div class="diff-removed">-        if let Some(Match::Text(text_match)) = &condition.r#match {</div><div class="diff-removed">-            let parsed_query = self.parse_query(&text_match.text, hw_counter);</div><div class="diff-removed">-            return Some(self.estimate_cardinality(&parsed_query, condition, hw_counter));</div><div class="diff-removed">-        }</div><div class="diff-removed">-        None</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    fn payload_blocks(</div><div class="diff-removed">-        &self,</div><div class="diff-removed">-        threshold: usize,</div><div class="diff-removed">-        key: PayloadKeyType,</div><div class="diff-removed">-    ) -> Box<dyn Iterator<Item = PayloadBlockCondition> + '_> {</div><div class="diff-removed">-        self.payload_blocks(threshold, key)</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+The file now represents a more flexible and performant implementation of a full-text index, with support for different storage types (in-memory and memory-mapped) and better telemetry and hardware usage measurements.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    