<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: lib/collection/src/collection_manager/segments_searcher.rs - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: lib/collection/src/collection_manager/segments_searcher.rs</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet-20240620.html">All Sonnet 3.5 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.5</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 67928</p>
                <p><strong>Native Prompt Tokens:</strong> 90525</p>
                <p><strong>Native Completion Tokens:</strong> 8192</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> length</p>
                <p><strong>Cost:</strong> $0.394455</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/qdrant_lib_collection_src_collection_manager_segments_searcher.rs/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8096e53f4..bd0c595ec 100644</div><div class="diff-header">--- a/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_expectedoutput.txt (expected):tmp/tmpgi1yb61v_expected.txt	</div><div class="diff-header">+++ b/qdrant_lib_collection_src_collection_manager_segments_searcher.rs_extracted.txt (actual):tmp/tmp9g6mjupu_actual.txt	</div><div class="diff-info">@@ -110,7 +110,7 @@ impl SegmentsSearcher {</div><div> </div><div>         // Therefore we need to track the lowest scored element per segment for each batch</div><div>         let mut lowest_scores_per_request: Vec<Vec<ScoreType>> = vec![</div><div class="diff-removed">-            vec![f32::max_value(); batch_size]; // initial max score value for each batch</div><div class="diff-added">+            vec![f32::MAX; batch_size]; // initial max score value for each batch</div><div>             number_segments</div><div>         ];</div><div> </div><div class="diff-info">@@ -127,7 +127,7 @@ impl SegmentsSearcher {</div><div>                 lowest_scores_per_request[segment_idx][batch_req_idx] = query_res</div><div>                     .last()</div><div>                     .map(|x| x.score)</div><div class="diff-removed">-                    .unwrap_or_else(f32::min_value);</div><div class="diff-added">+                    .unwrap_or_else(f32::MIN);</div><div>                 result_aggregator.update_batch_results(batch_req_idx, query_res.into_iter());</div><div>             }</div><div>         }</div><div class="diff-info">@@ -424,8 +424,7 @@ impl SegmentsSearcher {</div><div>                 let version = segment.point_version(id).ok_or_else(|| {</div><div>                     OperationError::service_error(format!("No version for point {id}"))</div><div>                 })?;</div><div class="diff-removed">-</div><div class="diff-removed">-                // If we already have the latest point version, keep that and continue</div><div class="diff-added">+                // If this point was not found yet or this segment have later version</div><div>                 let version_entry = point_version.entry(id);</div><div>                 if matches!(&version_entry, Entry::Occupied(entry) if *entry.get() >= version) {</div><div>                     return Ok(true);</div><div class="diff-info">@@ -763,264 +762,4 @@ fn get_hnsw_ef_construct(config: &SegmentConfig, vector_name: &VectorName) -> Op</div><div>     config</div><div>         .vector_data</div><div>         .get(vector_name)</div><div class="diff-removed">-        .and_then(|config| match &config.index {</div><div class="diff-removed">-            Indexes::Plain {} => None,</div><div class="diff-removed">-            Indexes::Hnsw(hnsw) => Some(hnsw),</div><div class="diff-removed">-        })</div><div class="diff-removed">-        .map(|hnsw| hnsw.ef_construct)</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-#[cfg(test)]</div><div class="diff-removed">-mod tests {</div><div class="diff-removed">-    use ahash::AHashSet;</div><div class="diff-removed">-    use api::rest::SearchRequestInternal;</div><div class="diff-removed">-    use common::counter::hardware_counter::HardwareCounterCell;</div><div class="diff-removed">-    use parking_lot::RwLock;</div><div class="diff-removed">-    use segment::data_types::vectors::DEFAULT_VECTOR_NAME;</div><div class="diff-removed">-    use segment::fixtures::index_fixtures::random_vector;</div><div class="diff-removed">-    use segment::index::VectorIndexEnum;</div><div class="diff-removed">-    use segment::types::{Condition, HasIdCondition};</div><div class="diff-removed">-    use tempfile::Builder;</div><div class="diff-removed">-</div><div class="diff-removed">-    use super::*;</div><div class="diff-removed">-    use crate::collection_manager::fixtures::{build_test_holder, random_segment};</div><div class="diff-removed">-    use crate::collection_manager::holders::segment_holder::SegmentHolder;</div><div class="diff-removed">-    use crate::operations::types::CoreSearchRequest;</div><div class="diff-removed">-    use crate::optimizers_builder::DEFAULT_INDEXING_THRESHOLD_KB;</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_is_indexed_enough_condition() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment1 = random_segment(dir.path(), 10, 200, 256);</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_index = segment1</div><div class="diff-removed">-            .vector_data</div><div class="diff-removed">-            .get(DEFAULT_VECTOR_NAME)</div><div class="diff-removed">-            .unwrap()</div><div class="diff-removed">-            .vector_index</div><div class="diff-removed">-            .clone();</div><div class="diff-removed">-</div><div class="diff-removed">-        let vector_index_borrow = vector_index.borrow();</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_counter = HardwareCounterCell::new();</div><div class="diff-removed">-</div><div class="diff-removed">-        match &*vector_index_borrow {</div><div class="diff-removed">-            VectorIndexEnum::Plain(plain_index) => {</div><div class="diff-removed">-                let res_1 = plain_index.is_small_enough_for_unindexed_search(25, None, &hw_counter);</div><div class="diff-removed">-                assert!(!res_1);</div><div class="diff-removed">-</div><div class="diff-removed">-                let res_2 =</div><div class="diff-removed">-                    plain_index.is_small_enough_for_unindexed_search(225, None, &hw_counter);</div><div class="diff-removed">-                assert!(res_2);</div><div class="diff-removed">-</div><div class="diff-removed">-                let ids: AHashSet<_> = vec![1, 2].into_iter().map(PointIdType::from).collect();</div><div class="diff-removed">-</div><div class="diff-removed">-                let ids_filter = Filter::new_must(Condition::HasId(HasIdCondition::from(ids)));</div><div class="diff-removed">-</div><div class="diff-removed">-                let res_3 = plain_index.is_small_enough_for_unindexed_search(</div><div class="diff-removed">-                    25,</div><div class="diff-removed">-                    Some(&ids_filter),</div><div class="diff-removed">-                    &hw_counter,</div><div class="diff-removed">-                );</div><div class="diff-removed">-                assert!(res_3);</div><div class="diff-removed">-            }</div><div class="diff-removed">-            _ => panic!("Expected plain index"),</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[tokio::test]</div><div class="diff-removed">-    async fn test_segments_search() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_holder = build_test_holder(dir.path());</div><div class="diff-removed">-</div><div class="diff-removed">-        let query = vec![1.0, 1.0, 1.0, 1.0];</div><div class="diff-removed">-</div><div class="diff-removed">-        let req = CoreSearchRequest {</div><div class="diff-removed">-            query: query.into(),</div><div class="diff-removed">-            with_payload: None,</div><div class="diff-removed">-            with_vector: None,</div><div class="diff-removed">-            filter: None,</div><div class="diff-removed">-            params: None,</div><div class="diff-removed">-            limit: 5,</div><div class="diff-removed">-            score_threshold: None,</div><div class="diff-removed">-            offset: 0,</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let batch_request = CoreSearchRequestBatch {</div><div class="diff-removed">-            searches: vec![req],</div><div class="diff-removed">-        };</div><div class="diff-removed">-</div><div class="diff-removed">-        let hw_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-        let result = SegmentsSearcher::search(</div><div class="diff-removed">-            Arc::new(segment_holder),</div><div class="diff-removed">-            Arc::new(batch_request),</div><div class="diff-removed">-            &Handle::current(),</div><div class="diff-removed">-            true,</div><div class="diff-removed">-            QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_acc),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .await</div><div class="diff-removed">-        .unwrap()</div><div class="diff-removed">-        .into_iter()</div><div class="diff-removed">-        .next()</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        // eprintln!("result = {:?}", &result);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert_eq!(result.len(), 5);</div><div class="diff-removed">-</div><div class="diff-removed">-        assert!(result[0].id == 3.into() || result[0].id == 11.into());</div><div class="diff-removed">-        assert!(result[1].id == 3.into() || result[1].id == 11.into());</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[tokio::test]</div><div class="diff-removed">-    async fn test_segments_search_sampling() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment1 = random_segment(dir.path(), 10, 2000, 4);</div><div class="diff-removed">-        let segment2 = random_segment(dir.path(), 10, 4000, 4);</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut holder = SegmentHolder::default();</div><div class="diff-removed">-</div><div class="diff-removed">-        let _sid1 = holder.add_new(segment1);</div><div class="diff-removed">-        let _sid2 = holder.add_new(segment2);</div><div class="diff-removed">-</div><div class="diff-removed">-        let segment_holder = Arc::new(RwLock::new(holder));</div><div class="diff-removed">-</div><div class="diff-removed">-        let mut rnd = rand::rng();</div><div class="diff-removed">-</div><div class="diff-removed">-        for _ in 0..100 {</div><div class="diff-removed">-            let req1 = SearchRequestInternal {</div><div class="diff-removed">-                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-removed">-                limit: 150, // more than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-removed">-                offset: None,</div><div class="diff-removed">-                with_payload: None,</div><div class="diff-removed">-                with_vector: None,</div><div class="diff-removed">-                filter: None,</div><div class="diff-removed">-                params: None,</div><div class="diff-removed">-                score_threshold: None,</div><div class="diff-removed">-            };</div><div class="diff-removed">-            let req2 = SearchRequestInternal {</div><div class="diff-removed">-                vector: random_vector(&mut rnd, 4).into(),</div><div class="diff-removed">-                limit: 50, // less than LOWER_SEARCH_LIMIT_SAMPLING</div><div class="diff-removed">-                offset: None,</div><div class="diff-removed">-                filter: None,</div><div class="diff-removed">-                params: None,</div><div class="diff-removed">-                with_payload: None,</div><div class="diff-removed">-                with_vector: None,</div><div class="diff-removed">-                score_threshold: None,</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            let batch_request = CoreSearchRequestBatch {</div><div class="diff-removed">-                searches: vec![req1.into(), req2.into()],</div><div class="diff-removed">-            };</div><div class="diff-removed">-</div><div class="diff-removed">-            let batch_request = Arc::new(batch_request);</div><div class="diff-removed">-</div><div class="diff-removed">-            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-            let result_no_sampling = SegmentsSearcher::search(</div><div class="diff-removed">-                segment_holder.clone(),</div><div class="diff-removed">-                batch_request.clone(),</div><div class="diff-removed">-                &Handle::current(),</div><div class="diff-removed">-                false,</div><div class="diff-removed">-                query_context,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-</div><div class="diff-removed">-            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-            let hw_measurement_acc = HwMeasurementAcc::new();</div><div class="diff-removed">-            let query_context =</div><div class="diff-removed">-                QueryContext::new(DEFAULT_INDEXING_THRESHOLD_KB, hw_measurement_acc.clone());</div><div class="diff-removed">-</div><div class="diff-removed">-            assert!(!result_no_sampling.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-            let result_sampling = SegmentsSearcher::search(</div><div class="diff-removed">-                segment_holder.clone(),</div><div class="diff-removed">-                batch_request,</div><div class="diff-removed">-                &Handle::current(),</div><div class="diff-removed">-                true,</div><div class="diff-removed">-                query_context,</div><div class="diff-removed">-            )</div><div class="diff-removed">-            .await</div><div class="diff-removed">-            .unwrap();</div><div class="diff-removed">-            assert!(!result_sampling.is_empty());</div><div class="diff-removed">-</div><div class="diff-removed">-            assert_ne!(hw_measurement_acc.get_cpu(), 0);</div><div class="diff-removed">-</div><div class="diff-removed">-            // assert equivalence in depth</div><div class="diff-removed">-            assert_eq!(result_no_sampling[0].len(), result_sampling[0].len());</div><div class="diff-removed">-            assert_eq!(result_no_sampling[1].len(), result_sampling[1].len());</div><div class="diff-removed">-</div><div class="diff-removed">-            for (no_sampling, sampling) in</div><div class="diff-removed">-                result_no_sampling[0].iter().zip(result_sampling[0].iter())</div><div class="diff-removed">-            {</div><div class="diff-removed">-                assert_eq!(no_sampling.score, sampling.score); // different IDs may have same scores</div><div class="diff-removed">-            }</div><div class="diff-removed">-        }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_retrieve() {</div><div class="diff-removed">-        let dir = Builder::new().prefix("segment_dir").tempdir().unwrap();</div><div class="diff-removed">-        let segment_holder = build_test_holder(dir.path());</div><div class="diff-removed">-        let records = SegmentsSearcher::retrieve_blocking(</div><div class="diff-removed">-            Arc::new(segment_holder),</div><div class="diff-removed">-            &[1.into(), 2.into(), 3.into()],</div><div class="diff-removed">-            &WithPayload::from(true),</div><div class="diff-removed">-            &true.into(),</div><div class="diff-removed">-            &AtomicBool::new(false),</div><div class="diff-removed">-            HwMeasurementAcc::new(),</div><div class="diff-removed">-        )</div><div class="diff-removed">-        .unwrap();</div><div class="diff-removed">-        assert_eq!(records.len(), 3);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000, None, 464530, 35103551), 1000);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit_ef() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000, Some(100), 464530, 35103551), 100);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_sampling_limit_high() {</div><div class="diff-removed">-        assert_eq!(sampling_limit(1000000, None, 464530, 35103551), 1000000);</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    /// Tests whether calculating the effective ef limit value is correct.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// Because there was confusion about what the effective value should be for some input</div><div class="diff-removed">-    /// combinations, we decided to write this tests to ensure correctness.</div><div class="diff-removed">-    ///</div><div class="diff-removed">-    /// See: <https://github.com/qdrant/qdrant/pull/1694></div><div class="diff-removed">-    #[test]</div><div class="diff-removed">-    fn test_effective_limit() {</div><div class="diff-removed">-        // Test cases to assert: (limit, ef_limit, poisson_sampling, effective)</div><div class="diff-removed">-        let tests = [</div><div class="diff-removed">-            (1000, 128, 150, 150),</div><div class="diff-removed">-            (1000, 128, 110, 128),</div><div class="diff-removed">-            (130, 128, 150, 130),</div><div class="diff-removed">-            (130, 128, 110, 128),</div><div class="diff-removed">-            (50, 128, 150, 50),</div><div class="diff-removed">-            (50, 128, 110, 50),</div><div class="diff-removed">-            (500, 1000, 300, 500),</div><div class="diff-removed">-            (500, 400, 300, 400),</div><div class="diff-removed">-            (1000, 0, 150, 150),</div><div class="diff-removed">-            (1000, 0, 110, 110),</div><div class="diff-removed">-        ];</div><div class="diff-removed">-        tests.into_iter().for_each(|(limit, ef_limit, poisson_sampling, effective)| assert_eq!(</div><div class="diff-removed">-            effective_limit(limit, ef_limit, poisson_sampling),</div><div class="diff-removed">-            effective,</div><div class="diff-removed">-            "effective limit for [limit: {limit}, ef_limit: {ef_limit}, poisson_sampling: {poisson_sampling}] must be {effective}",</div><div class="diff-removed">-        ));</div><div class="diff-removed">-    }</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+        .an</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    