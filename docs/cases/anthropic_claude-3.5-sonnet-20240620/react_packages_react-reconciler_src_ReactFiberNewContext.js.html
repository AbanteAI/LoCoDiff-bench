<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Case: packages/react-reconciler/src/ReactFiberNewContext.js - Sonnet 3.5</title>
    <link rel="stylesheet" href="../../styles.css">
</head>
<body>
    <header>
        <h1>Case: packages/react-reconciler/src/ReactFiberNewContext.js</h1>
        <h2>Model: Sonnet 3.5</h2>
        <p><a href="../../models/anthropic_claude-3.5-sonnet-20240620.html">All Sonnet 3.5 Cases</a> | <a href="../../cases.html">All Cases</a> | <a href="../../index.html">Home</a></p>
    </header>
    <main>
        <section class="case-details">
            <div class="case-info">
                <h2>Benchmark Case Information</h2>
                <p><strong>Model:</strong> Sonnet 3.5</p>
                <p><strong>Status:</strong> <span class="failure">Failure</span></p>
                <p><strong>Prompt Tokens:</strong> 56577</p>
                <p><strong>Native Prompt Tokens:</strong> 71335</p>
                <p><strong>Native Completion Tokens:</strong> 264</p>
                <p><strong>Native Tokens Reasoning:</strong> 0</p>
                <p><strong>Native Finish Reason:</strong> stop</p>
                <p><strong>Cost:</strong> $0.217965</p>
            </div>
            
            <div class="content-links">
                <h2>View Content</h2>
                <ul>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src_ReactFiberNewContext.js/prompt.html" class="content-link">View Prompt</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src_ReactFiberNewContext.js/expected.html" class="content-link">View Expected Output</a></li>
                    <li><a href="../../content/anthropic_claude-3.5-sonnet-20240620/react_packages_react-reconciler_src_ReactFiberNewContext.js/actual.html" class="content-link">View Actual Output</a></li>
                </ul>
            </div>
            
            <div class="diff-section">
                <h2>Diff (Expected vs Actual)</h2>
                <div id="diff-output">
                    <pre class="diff"><div></div><div>index 8024290fa..6509ed7ba 100644</div><div class="diff-header">--- a/react_packages_react-reconciler_src_ReactFiberNewContext.js_expectedoutput.txt (expected):tmp/tmpzuuprulf_expected.txt	</div><div class="diff-header">+++ b/react_packages_react-reconciler_src_ReactFiberNewContext.js_extracted.txt (actual):tmp/tmpf7i0hlsi_actual.txt	</div><div class="diff-info">@@ -1,578 +1,25 @@</div><div class="diff-removed">-/**</div><div class="diff-removed">- * Copyright (c) Meta Platforms, Inc. and affiliates.</div><div class="diff-removed">- *</div><div class="diff-removed">- * This source code is licensed under the MIT license found in the</div><div class="diff-removed">- * LICENSE file in the root directory of this source tree.</div><div class="diff-removed">- *</div><div class="diff-removed">- * @flow</div><div class="diff-removed">- */</div><div class="diff-added">+Here's a summary of the key changes made to the `ReactFiberNewContext.js` file over time:</div><div> </div><div class="diff-removed">-import type {ReactContext} from 'shared/ReactTypes';</div><div class="diff-removed">-import type {</div><div class="diff-removed">-  Fiber,</div><div class="diff-removed">-  ContextDependency,</div><div class="diff-removed">-  Dependencies,</div><div class="diff-removed">-} from './ReactInternalTypes';</div><div class="diff-removed">-import type {StackCursor} from './ReactFiberStack';</div><div class="diff-removed">-import type {Lanes} from './ReactFiberLane';</div><div class="diff-removed">-import type {TransitionStatus} from './ReactFiberConfig';</div><div class="diff-removed">-import type {Hook} from './ReactFiberHooks';</div><div class="diff-added">+1. Initial implementation of the new context API with support for providers and consumers.</div><div> </div><div class="diff-removed">-import {isPrimaryRenderer, HostTransitionContext} from './ReactFiberConfig';</div><div class="diff-removed">-import {createCursor, push, pop} from './ReactFiberStack';</div><div class="diff-removed">-import {ContextProvider, DehydratedFragment} from './ReactWorkTags';</div><div class="diff-removed">-import {NoLanes, isSubsetOfLanes, mergeLanes} from './ReactFiberLane';</div><div class="diff-removed">-import {</div><div class="diff-removed">-  NoFlags,</div><div class="diff-removed">-  DidPropagateContext,</div><div class="diff-removed">-  NeedsPropagation,</div><div class="diff-removed">-} from './ReactFiberFlags';</div><div class="diff-added">+2. Added support for multiple renderers using the same context.</div><div> </div><div class="diff-removed">-import is from 'shared/objectIs';</div><div class="diff-removed">-import {enableRenderableContext} from 'shared/ReactFeatureFlags';</div><div class="diff-removed">-import {getHostTransitionProvider} from './ReactFiberHostContext';</div><div class="diff-added">+3. Introduced lazy context propagation and optimizations for performance.</div><div> </div><div class="diff-removed">-const valueCursor: StackCursor<mixed> = createCursor(null);</div><div class="diff-added">+4. Added support for reading context during reconciliation.</div><div> </div><div class="diff-removed">-let rendererCursorDEV: StackCursor<Object | null>;</div><div class="diff-removed">-if (__DEV__) {</div><div class="diff-removed">-  rendererCursorDEV = createCursor(null);</div><div class="diff-removed">-}</div><div class="diff-removed">-let renderer2CursorDEV: StackCursor<Object | null>;</div><div class="diff-removed">-if (__DEV__) {</div><div class="diff-removed">-  renderer2CursorDEV = createCursor(null);</div><div class="diff-removed">-}</div><div class="diff-added">+5. Implemented partial hydration support for Suspense boundaries.</div><div> </div><div class="diff-removed">-let rendererSigil;</div><div class="diff-removed">-if (__DEV__) {</div><div class="diff-removed">-  // Use this to detect multiple renderers using the same context</div><div class="diff-removed">-  rendererSigil = {};</div><div class="diff-removed">-}</div><div class="diff-added">+6. Added support for form actions and async actions.</div><div> </div><div class="diff-removed">-let currentlyRenderingFiber: Fiber | null = null;</div><div class="diff-removed">-let lastContextDependency: ContextDependency<mixed> | null = null;</div><div class="diff-added">+7. Introduced the `useFormStatus` hook and related context changes.</div><div> </div><div class="diff-removed">-let isDisallowedContextReadInDEV: boolean = false;</div><div class="diff-added">+8. Removed server context support.</div><div> </div><div class="diff-removed">-export function resetContextDependencies(): void {</div><div class="diff-removed">-  // This is called right before React yields execution, to ensure `readContext`</div><div class="diff-removed">-  // cannot be called outside the render phase.</div><div class="diff-removed">-  currentlyRenderingFiber = null;</div><div class="diff-removed">-  lastContextDependency = null;</div><div class="diff-removed">-  if (__DEV__) {</div><div class="diff-removed">-    isDisallowedContextReadInDEV = false;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-added">+9. Changed `<Context>` to mean `<Context.Provider>` instead of `<Context.Consumer>`.</div><div> </div><div class="diff-removed">-export function enterDisallowedContextReadInDEV(): void {</div><div class="diff-removed">-  if (__DEV__) {</div><div class="diff-removed">-    isDisallowedContextReadInDEV = true;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-added">+10. Removed experimental context profiling and bailout mechanisms.</div><div> </div><div class="diff-removed">-export function exitDisallowedContextReadInDEV(): void {</div><div class="diff-removed">-  if (__DEV__) {</div><div class="diff-removed">-    isDisallowedContextReadInDEV = false;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-added">+11. Cleaned up and removed the `enableLazyContextPropagation` feature flag.</div><div> </div><div class="diff-removed">-export function pushProvider<T>(</div><div class="diff-removed">-  providerFiber: Fiber,</div><div class="diff-removed">-  context: ReactContext<T>,</div><div class="diff-removed">-  nextValue: T,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  if (isPrimaryRenderer) {</div><div class="diff-removed">-    push(valueCursor, context._currentValue, providerFiber);</div><div class="diff-removed">-</div><div class="diff-removed">-    context._currentValue = nextValue;</div><div class="diff-removed">-    if (__DEV__) {</div><div class="diff-removed">-      push(rendererCursorDEV, context._currentRenderer, providerFiber);</div><div class="diff-removed">-</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        context._currentRenderer !== undefined &&</div><div class="diff-removed">-        context._currentRenderer !== null &&</div><div class="diff-removed">-        context._currentRenderer !== rendererSigil</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        console.error(</div><div class="diff-removed">-          'Detected multiple renderers concurrently rendering the ' +</div><div class="diff-removed">-            'same context provider. This is currently unsupported.',</div><div class="diff-removed">-        );</div><div class="diff-removed">-      }</div><div class="diff-removed">-      context._currentRenderer = rendererSigil;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    push(valueCursor, context._currentValue2, providerFiber);</div><div class="diff-removed">-</div><div class="diff-removed">-    context._currentValue2 = nextValue;</div><div class="diff-removed">-    if (__DEV__) {</div><div class="diff-removed">-      push(renderer2CursorDEV, context._currentRenderer2, providerFiber);</div><div class="diff-removed">-</div><div class="diff-removed">-      if (</div><div class="diff-removed">-        context._currentRenderer2 !== undefined &&</div><div class="diff-removed">-        context._currentRenderer2 !== null &&</div><div class="diff-removed">-        context._currentRenderer2 !== rendererSigil</div><div class="diff-removed">-      ) {</div><div class="diff-removed">-        console.error(</div><div class="diff-removed">-          'Detected multiple renderers concurrently rendering the ' +</div><div class="diff-removed">-            'same context provider. This is currently unsupported.',</div><div class="diff-removed">-        );</div><div class="diff-removed">-      }</div><div class="diff-removed">-      context._currentRenderer2 = rendererSigil;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function popProvider(</div><div class="diff-removed">-  context: ReactContext<any>,</div><div class="diff-removed">-  providerFiber: Fiber,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  const currentValue = valueCursor.current;</div><div class="diff-removed">-</div><div class="diff-removed">-  if (isPrimaryRenderer) {</div><div class="diff-removed">-    context._currentValue = currentValue;</div><div class="diff-removed">-    if (__DEV__) {</div><div class="diff-removed">-      const currentRenderer = rendererCursorDEV.current;</div><div class="diff-removed">-      pop(rendererCursorDEV, providerFiber);</div><div class="diff-removed">-      context._currentRenderer = currentRenderer;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    context._currentValue2 = currentValue;</div><div class="diff-removed">-    if (__DEV__) {</div><div class="diff-removed">-      const currentRenderer2 = renderer2CursorDEV.current;</div><div class="diff-removed">-      pop(renderer2CursorDEV, providerFiber);</div><div class="diff-removed">-      context._currentRenderer2 = currentRenderer2;</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  pop(valueCursor, providerFiber);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function scheduleContextWorkOnParentPath(</div><div class="diff-removed">-  parent: Fiber | null,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-  propagationRoot: Fiber,</div><div class="diff-removed">-) {</div><div class="diff-removed">-  // Update the child lanes of all the ancestors, including the alternates.</div><div class="diff-removed">-  let node = parent;</div><div class="diff-removed">-  while (node !== null) {</div><div class="diff-removed">-    const alternate = node.alternate;</div><div class="diff-removed">-    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {</div><div class="diff-removed">-      node.childLanes = mergeLanes(node.childLanes, renderLanes);</div><div class="diff-removed">-      if (alternate !== null) {</div><div class="diff-removed">-        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else if (</div><div class="diff-removed">-      alternate !== null &&</div><div class="diff-removed">-      !isSubsetOfLanes(alternate.childLanes, renderLanes)</div><div class="diff-removed">-    ) {</div><div class="diff-removed">-      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      // Neither alternate was updated.</div><div class="diff-removed">-      // Normally, this would mean that the rest of the</div><div class="diff-removed">-      // ancestor path already has sufficient priority.</div><div class="diff-removed">-      // However, this is not necessarily true inside offscreen</div><div class="diff-removed">-      // or fallback trees because childLanes may be inconsistent</div><div class="diff-removed">-      // with the surroundings. This is why we continue the loop.</div><div class="diff-removed">-    }</div><div class="diff-removed">-    if (node === propagationRoot) {</div><div class="diff-removed">-      break;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    node = node.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  if (__DEV__) {</div><div class="diff-removed">-    if (node !== propagationRoot) {</div><div class="diff-removed">-      console.error(</div><div class="diff-removed">-        'Expected to find the propagation root when scheduling context work. ' +</div><div class="diff-removed">-          'This error is likely caused by a bug in React. Please file an issue.',</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function propagateContextChange<T>(</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  context: ReactContext<T>,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  // TODO: This path is only used by Cache components. Update</div><div class="diff-removed">-  // lazilyPropagateParentContextChanges to look for Cache components so they</div><div class="diff-removed">-  // can take advantage of lazy propagation.</div><div class="diff-removed">-  const forcePropagateEntireTree = true;</div><div class="diff-removed">-  propagateContextChanges(</div><div class="diff-removed">-    workInProgress,</div><div class="diff-removed">-    [context],</div><div class="diff-removed">-    renderLanes,</div><div class="diff-removed">-    forcePropagateEntireTree,</div><div class="diff-removed">-  );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function propagateContextChanges<T>(</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  contexts: Array<any>,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-  forcePropagateEntireTree: boolean,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  let fiber = workInProgress.child;</div><div class="diff-removed">-  if (fiber !== null) {</div><div class="diff-removed">-    // Set the return pointer of the child to the work-in-progress fiber.</div><div class="diff-removed">-    fiber.return = workInProgress;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  while (fiber !== null) {</div><div class="diff-removed">-    let nextFiber;</div><div class="diff-removed">-</div><div class="diff-removed">-    // Visit this fiber.</div><div class="diff-removed">-    const list = fiber.dependencies;</div><div class="diff-removed">-    if (list !== null) {</div><div class="diff-removed">-      nextFiber = fiber.child;</div><div class="diff-removed">-</div><div class="diff-removed">-      let dep = list.firstContext;</div><div class="diff-removed">-      findChangedDep: while (dep !== null) {</div><div class="diff-removed">-        // Assigning these to constants to help Flow</div><div class="diff-removed">-        const dependency = dep;</div><div class="diff-removed">-        const consumer = fiber;</div><div class="diff-removed">-        findContext: for (let i = 0; i < contexts.length; i++) {</div><div class="diff-removed">-          const context: ReactContext<T> = contexts[i];</div><div class="diff-removed">-          // Check if the context matches.</div><div class="diff-removed">-          if (dependency.context === context) {</div><div class="diff-removed">-            // Match! Schedule an update on this fiber.</div><div class="diff-removed">-</div><div class="diff-removed">-            // In the lazy implementation, don't mark a dirty flag on the</div><div class="diff-removed">-            // dependency itself. Not all changes are propagated, so we can't</div><div class="diff-removed">-            // rely on the propagation function alone to determine whether</div><div class="diff-removed">-            // something has changed; the consumer will check. In the future, we</div><div class="diff-removed">-            // could add back a dirty flag as an optimization to avoid double</div><div class="diff-removed">-            // checking, but until we have selectors it's not really worth</div><div class="diff-removed">-            // the trouble.</div><div class="diff-removed">-            consumer.lanes = mergeLanes(consumer.lanes, renderLanes);</div><div class="diff-removed">-            const alternate = consumer.alternate;</div><div class="diff-removed">-            if (alternate !== null) {</div><div class="diff-removed">-              alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</div><div class="diff-removed">-            }</div><div class="diff-removed">-            scheduleContextWorkOnParentPath(</div><div class="diff-removed">-              consumer.return,</div><div class="diff-removed">-              renderLanes,</div><div class="diff-removed">-              workInProgress,</div><div class="diff-removed">-            );</div><div class="diff-removed">-</div><div class="diff-removed">-            if (!forcePropagateEntireTree) {</div><div class="diff-removed">-              // During lazy propagation, when we find a match, we can defer</div><div class="diff-removed">-              // propagating changes to the children, because we're going to</div><div class="diff-removed">-              // visit them during render. We should continue propagating the</div><div class="diff-removed">-              // siblings, though</div><div class="diff-removed">-              nextFiber = null;</div><div class="diff-removed">-            }</div><div class="diff-removed">-</div><div class="diff-removed">-            // Since we already found a match, we can stop traversing the</div><div class="diff-removed">-            // dependency list.</div><div class="diff-removed">-            break findChangedDep;</div><div class="diff-removed">-          }</div><div class="diff-removed">-        }</div><div class="diff-removed">-        dep = dependency.next;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else if (fiber.tag === DehydratedFragment) {</div><div class="diff-removed">-      // If a dehydrated suspense boundary is in this subtree, we don't know</div><div class="diff-removed">-      // if it will have any context consumers in it. The best we can do is</div><div class="diff-removed">-      // mark it as having updates.</div><div class="diff-removed">-      const parentSuspense = fiber.return;</div><div class="diff-removed">-</div><div class="diff-removed">-      if (parentSuspense === null) {</div><div class="diff-removed">-        throw new Error(</div><div class="diff-removed">-          'We just came from a parent so we must have had a parent. This is a bug in React.',</div><div class="diff-removed">-        );</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);</div><div class="diff-removed">-      const alternate = parentSuspense.alternate;</div><div class="diff-removed">-      if (alternate !== null) {</div><div class="diff-removed">-        alternate.lanes = mergeLanes(alternate.lanes, renderLanes);</div><div class="diff-removed">-      }</div><div class="diff-removed">-      // This is intentionally passing this fiber as the parent</div><div class="diff-removed">-      // because we want to schedule this fiber as having work</div><div class="diff-removed">-      // on its children. We'll use the childLanes on</div><div class="diff-removed">-      // this fiber to indicate that a context has changed.</div><div class="diff-removed">-      scheduleContextWorkOnParentPath(</div><div class="diff-removed">-        parentSuspense,</div><div class="diff-removed">-        renderLanes,</div><div class="diff-removed">-        workInProgress,</div><div class="diff-removed">-      );</div><div class="diff-removed">-      nextFiber = null;</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      // Traverse down.</div><div class="diff-removed">-      nextFiber = fiber.child;</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (nextFiber !== null) {</div><div class="diff-removed">-      // Set the return pointer of the child to the work-in-progress fiber.</div><div class="diff-removed">-      nextFiber.return = fiber;</div><div class="diff-removed">-    } else {</div><div class="diff-removed">-      // No child. Traverse to next sibling.</div><div class="diff-removed">-      nextFiber = fiber;</div><div class="diff-removed">-      while (nextFiber !== null) {</div><div class="diff-removed">-        if (nextFiber === workInProgress) {</div><div class="diff-removed">-          // We're back to the root of this subtree. Exit.</div><div class="diff-removed">-          nextFiber = null;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        const sibling = nextFiber.sibling;</div><div class="diff-removed">-        if (sibling !== null) {</div><div class="diff-removed">-          // Set the return pointer of the sibling to the work-in-progress fiber.</div><div class="diff-removed">-          sibling.return = nextFiber.return;</div><div class="diff-removed">-          nextFiber = sibling;</div><div class="diff-removed">-          break;</div><div class="diff-removed">-        }</div><div class="diff-removed">-        // No more siblings. Traverse up.</div><div class="diff-removed">-        nextFiber = nextFiber.return;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    fiber = nextFiber;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function lazilyPropagateParentContextChanges(</div><div class="diff-removed">-  current: Fiber,</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-) {</div><div class="diff-removed">-  const forcePropagateEntireTree = false;</div><div class="diff-removed">-  propagateParentContextChanges(</div><div class="diff-removed">-    current,</div><div class="diff-removed">-    workInProgress,</div><div class="diff-removed">-    renderLanes,</div><div class="diff-removed">-    forcePropagateEntireTree,</div><div class="diff-removed">-  );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-// Used for propagating a deferred tree (Suspense, Offscreen). We must propagate</div><div class="diff-removed">-// to the entire subtree, because we won't revisit it until after the current</div><div class="diff-removed">-// render has completed, at which point we'll have lost track of which providers</div><div class="diff-removed">-// have changed.</div><div class="diff-removed">-export function propagateParentContextChangesToDeferredTree(</div><div class="diff-removed">-  current: Fiber,</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-) {</div><div class="diff-removed">-  const forcePropagateEntireTree = true;</div><div class="diff-removed">-  propagateParentContextChanges(</div><div class="diff-removed">-    current,</div><div class="diff-removed">-    workInProgress,</div><div class="diff-removed">-    renderLanes,</div><div class="diff-removed">-    forcePropagateEntireTree,</div><div class="diff-removed">-  );</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function propagateParentContextChanges(</div><div class="diff-removed">-  current: Fiber,</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-  forcePropagateEntireTree: boolean,</div><div class="diff-removed">-) {</div><div class="diff-removed">-  // Collect all the parent providers that changed. Since this is usually small</div><div class="diff-removed">-  // number, we use an Array instead of Set.</div><div class="diff-removed">-  let contexts = null;</div><div class="diff-removed">-  let parent: null | Fiber = workInProgress;</div><div class="diff-removed">-  let isInsidePropagationBailout = false;</div><div class="diff-removed">-  while (parent !== null) {</div><div class="diff-removed">-    if (!isInsidePropagationBailout) {</div><div class="diff-removed">-      if ((parent.flags & NeedsPropagation) !== NoFlags) {</div><div class="diff-removed">-        isInsidePropagationBailout = true;</div><div class="diff-removed">-      } else if ((parent.flags & DidPropagateContext) !== NoFlags) {</div><div class="diff-removed">-        break;</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    if (parent.tag === ContextProvider) {</div><div class="diff-removed">-      const currentParent = parent.alternate;</div><div class="diff-removed">-</div><div class="diff-removed">-      if (currentParent === null) {</div><div class="diff-removed">-        throw new Error('Should have a current fiber. This is a bug in React.');</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      const oldProps = currentParent.memoizedProps;</div><div class="diff-removed">-      if (oldProps !== null) {</div><div class="diff-removed">-        let context: ReactContext<any>;</div><div class="diff-removed">-        if (enableRenderableContext) {</div><div class="diff-removed">-          context = parent.type;</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-          context = parent.type._context;</div><div class="diff-removed">-        }</div><div class="diff-removed">-</div><div class="diff-removed">-        const newProps = parent.pendingProps;</div><div class="diff-removed">-        const newValue = newProps.value;</div><div class="diff-removed">-</div><div class="diff-removed">-        const oldValue = oldProps.value;</div><div class="diff-removed">-</div><div class="diff-removed">-        if (!is(newValue, oldValue)) {</div><div class="diff-removed">-          if (contexts !== null) {</div><div class="diff-removed">-            contexts.push(context);</div><div class="diff-removed">-          } else {</div><div class="diff-removed">-            contexts = [context];</div><div class="diff-removed">-          }</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-    } else if (parent === getHostTransitionProvider()) {</div><div class="diff-removed">-      // During a host transition, a host component can act like a context</div><div class="diff-removed">-      // provider. E.g. in React DOM, this would be a <form />.</div><div class="diff-removed">-      const currentParent = parent.alternate;</div><div class="diff-removed">-      if (currentParent === null) {</div><div class="diff-removed">-        throw new Error('Should have a current fiber. This is a bug in React.');</div><div class="diff-removed">-      }</div><div class="diff-removed">-</div><div class="diff-removed">-      const oldStateHook: Hook = currentParent.memoizedState;</div><div class="diff-removed">-      const oldState: TransitionStatus = oldStateHook.memoizedState;</div><div class="diff-removed">-</div><div class="diff-removed">-      const newStateHook: Hook = parent.memoizedState;</div><div class="diff-removed">-      const newState: TransitionStatus = newStateHook.memoizedState;</div><div class="diff-removed">-</div><div class="diff-removed">-      // This uses regular equality instead of Object.is because we assume that</div><div class="diff-removed">-      // host transition state doesn't include NaN as a valid type.</div><div class="diff-removed">-      if (oldState !== newState) {</div><div class="diff-removed">-        if (contexts !== null) {</div><div class="diff-removed">-          contexts.push(HostTransitionContext);</div><div class="diff-removed">-        } else {</div><div class="diff-removed">-          contexts = [HostTransitionContext];</div><div class="diff-removed">-        }</div><div class="diff-removed">-      }</div><div class="diff-removed">-    }</div><div class="diff-removed">-    parent = parent.return;</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  if (contexts !== null) {</div><div class="diff-removed">-    // If there were any changed providers, search through the children and</div><div class="diff-removed">-    // propagate their changes.</div><div class="diff-removed">-    propagateContextChanges(</div><div class="diff-removed">-      workInProgress,</div><div class="diff-removed">-      contexts,</div><div class="diff-removed">-      renderLanes,</div><div class="diff-removed">-      forcePropagateEntireTree,</div><div class="diff-removed">-    );</div><div class="diff-removed">-  }</div><div class="diff-removed">-</div><div class="diff-removed">-  // This is an optimization so that we only propagate once per subtree. If a</div><div class="diff-removed">-  // deeply nested child bails out, and it calls this propagation function, it</div><div class="diff-removed">-  // uses this flag to know that the remaining ancestor providers have already</div><div class="diff-removed">-  // been propagated.</div><div class="diff-removed">-  //</div><div class="diff-removed">-  // NOTE: This optimization is only necessary because we sometimes enter the</div><div class="diff-removed">-  // begin phase of nodes that don't have any work scheduled on them —</div><div class="diff-removed">-  // specifically, the siblings of a node that _does_ have scheduled work. The</div><div class="diff-removed">-  // siblings will bail out and call this function again, even though we already</div><div class="diff-removed">-  // propagated content changes to it and its subtree. So we use this flag to</div><div class="diff-removed">-  // mark that the parent providers already propagated.</div><div class="diff-removed">-  //</div><div class="diff-removed">-  // Unfortunately, though, we need to ignore this flag when we're inside a</div><div class="diff-removed">-  // tree whose context propagation was deferred — that's what the</div><div class="diff-removed">-  // `NeedsPropagation` flag is for.</div><div class="diff-removed">-  //</div><div class="diff-removed">-  // If we could instead bail out before entering the siblings' begin phase,</div><div class="diff-removed">-  // then we could remove both `DidPropagateContext` and `NeedsPropagation`.</div><div class="diff-removed">-  // Consider this as part of the next refactor to the fiber tree structure.</div><div class="diff-removed">-  workInProgress.flags |= DidPropagateContext;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function checkIfContextChanged(</div><div class="diff-removed">-  currentDependencies: Dependencies,</div><div class="diff-removed">-): boolean {</div><div class="diff-removed">-  // Iterate over the current dependencies to see if something changed. This</div><div class="diff-removed">-  // only gets called if props and state has already bailed out, so it's a</div><div class="diff-removed">-  // relatively uncommon path, except at the root of a changed subtree.</div><div class="diff-removed">-  // Alternatively, we could move these comparisons into `readContext`, but</div><div class="diff-removed">-  // that's a much hotter path, so I think this is an appropriate trade off.</div><div class="diff-removed">-  let dependency = currentDependencies.firstContext;</div><div class="diff-removed">-  while (dependency !== null) {</div><div class="diff-removed">-    const context = dependency.context;</div><div class="diff-removed">-    const newValue = isPrimaryRenderer</div><div class="diff-removed">-      ? context._currentValue</div><div class="diff-removed">-      : context._currentValue2;</div><div class="diff-removed">-    const oldValue = dependency.memoizedValue;</div><div class="diff-removed">-    if (!is(newValue, oldValue)) {</div><div class="diff-removed">-      return true;</div><div class="diff-removed">-    }</div><div class="diff-removed">-    dependency = dependency.next;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return false;</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function prepareToReadContext(</div><div class="diff-removed">-  workInProgress: Fiber,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-): void {</div><div class="diff-removed">-  currentlyRenderingFiber = workInProgress;</div><div class="diff-removed">-  lastContextDependency = null;</div><div class="diff-removed">-</div><div class="diff-removed">-  const dependencies = workInProgress.dependencies;</div><div class="diff-removed">-  if (dependencies !== null) {</div><div class="diff-removed">-    // Reset the work-in-progress list</div><div class="diff-removed">-    dependencies.firstContext = null;</div><div class="diff-removed">-  }</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function readContext<T>(context: ReactContext<T>): T {</div><div class="diff-removed">-  if (__DEV__) {</div><div class="diff-removed">-    // This warning would fire if you read context inside a Hook like useMemo.</div><div class="diff-removed">-    // Unlike the class check below, it's not enforced in production for perf.</div><div class="diff-removed">-    if (isDisallowedContextReadInDEV) {</div><div class="diff-removed">-      console.error(</div><div class="diff-removed">-        'Context can only be read while React is rendering. ' +</div><div class="diff-removed">-          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +</div><div class="diff-removed">-          'In function components, you can read it directly in the function body, but not ' +</div><div class="diff-removed">-          'inside Hooks like useReducer() or useMemo().',</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return readContextForConsumer(currentlyRenderingFiber, context);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-export function readContextDuringReconciliation<T>(</div><div class="diff-removed">-  consumer: Fiber,</div><div class="diff-removed">-  context: ReactContext<T>,</div><div class="diff-removed">-  renderLanes: Lanes,</div><div class="diff-removed">-): T {</div><div class="diff-removed">-  if (currentlyRenderingFiber === null) {</div><div class="diff-removed">-    prepareToReadContext(consumer, renderLanes);</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return readContextForConsumer(consumer, context);</div><div class="diff-removed">-}</div><div class="diff-removed">-</div><div class="diff-removed">-function readContextForConsumer<T>(</div><div class="diff-removed">-  consumer: Fiber | null,</div><div class="diff-removed">-  context: ReactContext<T>,</div><div class="diff-removed">-): T {</div><div class="diff-removed">-  const value = isPrimaryRenderer</div><div class="diff-removed">-    ? context._currentValue</div><div class="diff-removed">-    : context._currentValue2;</div><div class="diff-removed">-</div><div class="diff-removed">-  const contextItem = {</div><div class="diff-removed">-    context: ((context: any): ReactContext<mixed>),</div><div class="diff-removed">-    memoizedValue: value,</div><div class="diff-removed">-    next: null,</div><div class="diff-removed">-  };</div><div class="diff-removed">-</div><div class="diff-removed">-  if (lastContextDependency === null) {</div><div class="diff-removed">-    if (consumer === null) {</div><div class="diff-removed">-      throw new Error(</div><div class="diff-removed">-        'Context can only be read while React is rendering. ' +</div><div class="diff-removed">-          'In classes, you can read it in the render method or getDerivedStateFromProps. ' +</div><div class="diff-removed">-          'In function components, you can read it directly in the function body, but not ' +</div><div class="diff-removed">-          'inside Hooks like useReducer() or useMemo().',</div><div class="diff-removed">-      );</div><div class="diff-removed">-    }</div><div class="diff-removed">-</div><div class="diff-removed">-    // This is the first dependency for this component. Create a new list.</div><div class="diff-removed">-    lastContextDependency = contextItem;</div><div class="diff-removed">-    consumer.dependencies = __DEV__</div><div class="diff-removed">-      ? {</div><div class="diff-removed">-          lanes: NoLanes,</div><div class="diff-removed">-          firstContext: contextItem,</div><div class="diff-removed">-          _debugThenableState: null,</div><div class="diff-removed">-        }</div><div class="diff-removed">-      : {</div><div class="diff-removed">-          lanes: NoLanes,</div><div class="diff-removed">-          firstContext: contextItem,</div><div class="diff-removed">-        };</div><div class="diff-removed">-    consumer.flags |= NeedsPropagation;</div><div class="diff-removed">-  } else {</div><div class="diff-removed">-    // Append a new context item.</div><div class="diff-removed">-    lastContextDependency = lastContextDependency.next = contextItem;</div><div class="diff-removed">-  }</div><div class="diff-removed">-  return value;</div><div class="diff-removed">-}</div><div>\ No newline at end of file</div><div class="diff-added">+The file evolved from a basic implementation of React's new context API to a more complex system supporting various features like lazy propagation, partial hydration, and form actions. Over time, experimental features were tested and either integrated or removed, and the overall structure was refined to improve performance and maintainability.</div><div>\ No newline at end of file</div><div></div></pre>
                </div>
            </div>
        </section>
    </main>
    <footer>
        <p>LoCoDiff-bench - <a href="https://github.com/AbanteAI/LoCoDiff-bench">GitHub Repository</a></p>
    </footer>
</body>
</html>
    